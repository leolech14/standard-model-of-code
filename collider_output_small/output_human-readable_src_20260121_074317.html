<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Collider v4.0.0</title>
    <style>
        /* ═══════════════════════════════════════════════════════════════════
           COLLIDER UI - Dual Sidebar Layout
           ═══════════════════════════════════════════════════════════════════ */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --surface: rgba(15, 15, 22, 0.85);
            --surface-hover: rgba(25, 25, 35, 0.9);
            --border: rgba(255, 255, 255, 0.08);
            --border-accent: rgba(74, 158, 255, 0.3);
            --text: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.5);
            --text-muted: rgba(255, 255, 255, 0.3);
            --accent: #4a9eff;
            --accent-dim: rgba(74, 158, 255, 0.15);
            --accent-glow: rgba(74, 158, 255, 0.25);
            --green: #5a9a70;
            --yellow: #a09060;
            --red: #b07070;
            --cyan: #7090a0;
            --sidebar-width: 300px;
            --right-panel-width: 280px;
            --min-sidebar-width: 240px;
            --max-sidebar-width: 500px;
            --header-height: 48px;
            --radius: 8px;
            --radius-sm: 4px;
            --glass: blur(12px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            font-size: 12px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LOADER
           ═══════════════════════════════════════════════════════════════════ */
        #loader {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 9999;
            font-size: 14px;
            letter-spacing: 2px;
        }

        #loader-status {
            font-size: 11px;
            opacity: 0.5;
        }

        /* ═══════════════════════════════════════════════════════════════════
           HEADER - Top bar spanning full width
           ═══════════════════════════════════════════════════════════════════ */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 24px;
            z-index: 200;
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 1px;
            color: var(--accent);
        }

        .logo span {
            opacity: 0.5;
            font-size: 10px;
            margin-left: 6px;
            color: var(--text);
        }

        .header-stats {
            display: flex;
            gap: 20px;
            font-size: 11px;
        }

        .stat {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .stat-label {
            opacity: 0.4;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            color: var(--cyan);
        }

        .target-name {
            margin-left: auto;
            font-size: 11px;
            opacity: 0.5;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ═══════════════════════════════════════════════════════════════════
           MAIN LAYOUT - Graph container
           ═══════════════════════════════════════════════════════════════════ */
        #3d-graph {
            position: fixed;
            top: var(--header-height);
            left: var(--sidebar-width);
            right: var(--right-panel-width);
            bottom: 0;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LEFT SIDEBAR - Controls & Filters
           ═══════════════════════════════════════════════════════════════════ */
        #left-sidebar {
            position: fixed;
            top: var(--header-height);
            left: 0;
            bottom: 0;
            width: var(--sidebar-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
        }

        #left-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #left-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #left-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           RIGHT SIDEBAR - Info Panels
           ═══════════════════════════════════════════════════════════════════ */
        #right-sidebar {
            position: fixed;
            top: var(--header-height);
            right: 0;
            bottom: 0;
            width: var(--right-panel-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #right-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #right-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #right-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SIDEBAR RESIZE DIVIDERS - Horizontal drag handles
           ═══════════════════════════════════════════════════════════════════ */
        .sidebar-resize-handle {
            position: fixed;
            top: var(--header-height);
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 101;
            background: transparent;
            transition: background 0.15s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.25);
        }

        .sidebar-resize-handle.left {
            left: calc(var(--sidebar-width) - 3px);
        }

        .sidebar-resize-handle.right {
            right: calc(var(--right-panel-width) - 3px);
        }

        /* Visual indicator line */
        .sidebar-resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 40px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .sidebar-resize-handle:hover::after {
            opacity: 1;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION - Collapsible sections
           ═══════════════════════════════════════════════════════════════════ */
        .section {
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            padding: 12px 14px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.15s;
        }

        .section-header:hover {
            opacity: 0.9;
            background: var(--surface-hover);
        }

        .section-header .arrow {
            transition: transform 0.2s;
            font-size: 8px;
        }

        .section-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        /* PRIME SECTIONS - Highlighted config sections (muted) */
        .section.prime {
            background: linear-gradient(180deg, rgba(100, 110, 130, 0.03) 0%, transparent 100%);
            border-left: 2px solid rgba(100, 110, 130, 0.3);
        }

        .section.prime .section-header {
            opacity: 0.75;
            color: var(--text-secondary);
        }

        .section.prime .section-header:hover {
            opacity: 0.9;
        }

        .section-content {
            padding: 8px 14px 14px;
            overflow-y: auto;
            transition: max-height 0.2s ease;
        }

        .section-content.collapsed {
            display: none;
        }

        /* RESIZABLE SECTIONS - Vertical drag handles */
        .section-resize-handle {
            height: 4px;
            cursor: ns-resize;
            background: transparent;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
            position: relative;
        }

        .section-resize-handle:hover,
        .section-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.2);
        }

        .section-resize-handle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 2px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .section-resize-handle:hover::after {
            opacity: 1;
        }

        /* Section content height constraints when resizing */
        .section-content.resizable {
            min-height: 60px;
            max-height: 400px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           VIEW MODE TOGGLE - ATOMS vs FILES (top of left sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            padding: 8px 10px;
            background: linear-gradient(180deg, rgba(74, 158, 255, 0.08) 0%, rgba(74, 158, 255, 0.02) 100%);
            border-bottom: 2px solid var(--accent);
        }

        .view-mode-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .view-mode-btn:first-child {
            border-radius: var(--radius-sm) 0 0 var(--radius-sm);
            border-right: none;
        }

        .view-mode-btn:last-child {
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        }

        .view-mode-btn:hover {
            background: rgba(74, 158, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        .view-mode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
        }

        .view-mode-icon {
            font-size: 14px;
        }

        .view-mode-label {
            font-size: 10px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════════════
           BUTTON GRID - For presets and actions
           ═══════════════════════════════════════════════════════════════════ */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .btn-grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .btn-grid-4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .btn-grid-6 {
            grid-template-columns: repeat(6, 1fr);
        }

        .btn {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            font-size: 9px;
            font-weight: 500;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: var(--border-accent);
        }

        .btn.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        /* Icon buttons */
        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SLIDERS
           ═══════════════════════════════════════════════════════════════════ */
        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .slider-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .slider-label {
            opacity: 0.6;
        }

        .slider-value {
            display: none;
            /* Replaced by input */
        }

        .number-input {
            width: 48px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--cyan);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 10px;
            padding: 2px 4px;
            text-align: right;
            -moz-appearance: textfield;
        }

        .number-input::-webkit-outer-spin-button,
        .number-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.4);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px var(--accent-glow);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }

        /* ═══════════════════════════════════════════════════════════════════
           FILTER CHIPS
           ═══════════════════════════════════════════════════════════════════ */
        .filter-group {
            margin-bottom: 12px;
        }

        .filter-group:last-child {
            margin-bottom: 0;
        }

        .filter-label {
            font-size: 9px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .chip {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 14px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .chip.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
        }

        .chip .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOGGLE SWITCHES
           ═══════════════════════════════════════════════════════════════════ */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            padding: 6px 0;
        }

        .toggle-row .toggle-label {
            opacity: 0.7;
        }

        .toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text);
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle.active::after {
            transform: translateX(16px);
        }

        /* ═══════════════════════════════════════════════════════════════════
           INFO PANEL - Right sidebar node info
           ═══════════════════════════════════════════════════════════════════ */
        .info-panel {
            padding: 14px;
            border-bottom: 1px solid var(--border);
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .info-panel-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .node-info {
            display: none;
        }

        .node-info.visible {
            display: block;
        }

        .node-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
            word-break: break-all;
            color: var(--cyan);
        }

        .node-kind {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row .label {
            opacity: 0.4;
        }

        .info-row .value {
            text-align: right;
        }

        .node-file {
            font-size: 9px;
            opacity: 0.3;
            margin-top: 10px;
            word-break: break-all;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .placeholder-text {
            font-size: 10px;
            opacity: 0.3;
            text-align: center;
            padding: 20px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SELECTION PANEL
           ═══════════════════════════════════════════════════════════════════ */
        .selection-panel {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
        }

        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .selection-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .selection-count {
            font-size: 9px;
            padding: 2px 8px;
            background: var(--accent-dim);
            border-radius: 10px;
            color: var(--accent);
        }

        .selection-clear {
            font-size: 9px;
            padding: 4px 8px;
            background: none;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            cursor: pointer;
        }

        .selection-clear:hover {
            color: var(--text);
            border-color: var(--text-dim);
        }

        .selection-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .selection-item {
            font-size: 10px;
            padding: 6px 8px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            margin-bottom: 2px;
            background: rgba(255, 255, 255, 0.02);
        }

        .selection-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--accent);
        }

        /* ═══════════════════════════════════════════════════════════════════
           STATS PANEL (bottom of right sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .stats-panel {
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid var(--border);
            margin-top: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stats-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-sm);
        }

        .stats-item .value {
            font-size: 16px;
            font-weight: 600;
            color: var(--cyan);
            font-variant-numeric: tabular-nums;
        }

        .stats-item .label {
            font-size: 8px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           COLOR PANELS (right sidebar color controls)
           ═══════════════════════════════════════════════════════════════════ */
        .color-panel,
        .schemes-panel {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
        }

        .color-panel .section-content,
        .schemes-panel .section-content {
            padding: 0;
            margin-top: 10px;
        }

        .color-panel .btn-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .color-panel .btn {
            padding: 6px 8px;
            font-size: 9px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .color-panel .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .color-panel .btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        /* Collapsible header for schemes panel */
        .info-panel-header.collapsible {
            cursor: pointer;
            user-select: none;
        }

        .info-panel-header.collapsible:hover {
            opacity: 0.9;
        }

        .info-panel-header .collapse-icon {
            font-size: 8px;
            transition: transform 0.2s;
        }

        .info-panel-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .schemes-panel .section-content {
            max-height: 250px;
            overflow-y: auto;
        }

        .schemes-panel .section-content::-webkit-scrollbar {
            width: 4px;
        }

        .schemes-panel .section-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .schemes-panel .section-content.collapsed {
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           PERFORMANCE HUD (optional overlay)
           ═══════════════════════════════════════════════════════════════════ */
        #perf-hud {
            position: fixed;
            top: calc(var(--header-height) + 8px);
            left: calc(var(--sidebar-width) + 8px);
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-family: 'SF Mono', Monaco, monospace;
            z-index: 150;
            display: none;
        }

        #perf-hud.visible {
            display: block;
        }

        .perf-row {
            display: flex;
            gap: 12px;
        }

        .perf-label {
            opacity: 0.5;
        }

        .perf-value {
            font-variant-numeric: tabular-nums;
        }

        .perf-good {
            color: var(--green);
        }

        .perf-warn {
            color: var(--yellow);
        }

        .perf-bad {
            color: var(--red);
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════════════ */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--surface);
            border: 1px solid var(--border-accent);
            padding: 12px 24px;
            border-radius: var(--radius);
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Selection box for drag select */
        #selection-box {
            position: fixed;
            border: 1px solid var(--accent);
            background: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION-SPECIFIC STYLING
           ═══════════════════════════════════════════════════════════════════ */

        /* Color mode buttons with color indicators */
        .color-btn {
            position: relative;
        }

        .color-btn::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .color-btn[data-preset="tier"]::before {
            background: #ff6b6b;
        }

        .color-btn[data-preset="family"]::before {
            background: #4ecdc4;
        }

        .color-btn[data-preset="layer"]::before {
            background: #95e1d3;
        }

        .color-btn[data-preset="ring"]::before {
            background: #f9ed69;
        }

        .color-btn[data-preset="file"]::before {
            background: #a8e6cf;
        }

        .color-btn[data-preset="flow"]::before {
            background: #dcd6f7;
        }

        /* Layout buttons with mini icons */
        .layout-btn {
            height: 32px;
        }
    </style>

    <script>
        window.process = window.process || { env: { NODE_ENV: "production" } };
        window.global = window.global || window;
    </script>
    <!-- THREE.js r149 (last version without deprecation warning) + 3d-force-graph -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
</head>

<body>
    <!-- Loader -->
    <div id="loader">
        <div>INITIALIZING...</div>
        <div id="loader-status">Loading data...</div>
    </div>

    <!-- Header -->
    <div id="header">
        <div class="logo">COLLIDER <span>v4.0.0</span></div>
        <div class="header-stats">
            <div class="stat">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="stat-nodes">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="stat-edges">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Entropy</span>
                <span class="stat-value" id="stat-entropy">--</span>
            </div>
        </div>
        <div class="target-name" id="target-name"></div>
    </div>

    <!-- Left Sidebar -->
    <div id="left-sidebar">
        <!-- VIEW MODE TOGGLE - TOP PRIORITY -->
        <div class="view-mode-toggle" id="view-mode-toggle">
            <button class="view-mode-btn active" data-mode="atoms">
                <span class="view-mode-icon">◉</span>
                <span class="view-mode-label">ATOMS</span>
            </button>
            <button class="view-mode-btn" data-mode="files">
                <span class="view-mode-icon">◫</span>
                <span class="view-mode-label">FILES</span>
            </button>
        </div>

        <!-- MAPPING CONTROL (Docked) -->
        <div class="section prime" id="control-bar-container">
            <!-- Injected by control-bar.js -->
        </div>

        <!-- NODE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="node-config">
                <span>⬢ Node Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-node-config">
                <!-- Size Mode Selector -->
                <div class="filter-group">
                    <div class="filter-label">Size Mode</div>
                    <div class="btn-grid btn-grid-4">
                        <button class="btn active" data-size-mode="uniform">Uniform</button>
                        <button class="btn" data-size-mode="degree">Degree</button>
                        <button class="btn" data-size-mode="fanout">Fanout</button>
                        <button class="btn" data-size-mode="complexity">Complex</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Base Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-size" min="0.2" max="4" step="0.1" value="1">
                        <input type="number" id="cfg-node-size-num" class="number-input" min="0.2" max="4" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-opacity" min="0.1" max="1" step="0.05" value="1">
                        <input type="number" id="cfg-node-opacity-num" class="number-input" min="0.1" max="1"
                            step="0.05" value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Resolution</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-res" min="4" max="32" step="4" value="8">
                        <input type="number" id="cfg-node-res-num" class="number-input" min="4" max="32" step="4"
                            value="8">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Label Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-label-size" min="0" max="3" step="0.1" value="1">
                        <input type="number" id="cfg-label-size-num" class="number-input" min="0" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="cfg-toggle-labels"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight Selected</span>
                    <div class="toggle active" id="cfg-toggle-highlight"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Pulse Animation</span>
                    <div class="toggle" id="cfg-toggle-pulse"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">3D Depth Shading</span>
                    <div class="toggle active" id="cfg-toggle-depth"></div>
                </div>
            </div>
        </div>

        <!-- EDGE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="edge-config">
                <span>⟷ Edge Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-edge-config">
                <!-- Edge Style Selector -->
                <div class="filter-group">
                    <div class="filter-label">Edge Style</div>
                    <div class="btn-grid">
                        <button class="btn active" data-edge-style="solid">Solid</button>
                        <button class="btn" data-edge-style="dashed">Dashed</button>
                        <button class="btn" data-edge-style="particle">Particle</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-opacity" min="0" max="1" step="0.05" value="0.6">
                        <input type="number" id="cfg-edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.6">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Width</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-width" min="0.2" max="5" step="0.2" value="1.5">
                        <input type="number" id="cfg-edge-width-num" class="number-input" min="0.2" max="5" step="0.1"
                            value="1.5">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Curvature</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-curve" min="0" max="1" step="0.05" value="0">
                        <input type="number" id="cfg-edge-curve-num" class="number-input" min="0" max="1" step="0.05"
                            value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Speed</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-speed" min="0" max="0.05" step="0.005" value="0.01">
                        <input type="number" id="cfg-particle-speed-num" class="number-input" min="0" max="0.05"
                            step="0.005" value="0.01">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Density</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-count" min="0" max="10" step="1" value="0">
                        <input type="number" id="cfg-particle-count-num" class="number-input" min="0" max="10" step="1"
                            value="0">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Arrows</span>
                    <div class="toggle" id="cfg-toggle-arrows"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Gradient Colors</span>
                    <div class="toggle active" id="cfg-toggle-gradient"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight on Hover</span>
                    <div class="toggle active" id="cfg-toggle-edge-hover"></div>
                </div>
            </div>
        </div>

        <!-- LAYOUT -->
        <div class="section">
            <div class="section-header" data-section="layout">
                <span>Layout</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-layout">
                <div class="btn-grid">
                    <button class="btn layout-btn active" data-layout="force">Force</button>
                    <button class="btn layout-btn" data-layout="radial">Radial</button>
                    <button class="btn layout-btn" data-layout="orbital">Orbital</button>
                    <button class="btn layout-btn" data-layout="sphere">Sphere</button>
                    <button class="btn layout-btn" data-layout="grid">Grid</button>
                    <button class="btn layout-btn" data-layout="spiral">Spiral</button>
                </div>
            </div>
        </div>

        <!-- PHYSICS -->
        <div class="section">
            <div class="section-header" data-section="physics">
                <span>Physics</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-physics">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Repulsion</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-charge" min="-500" max="0" value="-120">
                        <input type="number" id="physics-charge-num" class="number-input" min="-500" max="0"
                            value="-120">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Link Distance</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-link" min="10" max="200" value="50">
                        <input type="number" id="physics-link-num" class="number-input" min="10" max="200" value="50">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Center Pull</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-center" min="0" max="0.5" step="0.01" value="0.05">
                        <input type="number" id="physics-center-num" class="number-input" min="0" max="0.5" step="0.01"
                            value="0.05">
                    </div>
                </div>
                <div class="btn-grid btn-grid-4" style="margin-top: 8px;">
                    <button class="btn" data-physics="default">Def</button>
                    <button class="btn" data-physics="tight">Tight</button>
                    <button class="btn" data-physics="loose">Loose</button>
                    <button class="btn" data-physics="explosive">Boom</button>
                </div>
            </div>
        </div>

        <!-- APPEARANCE -->
        <div class="section">
            <div class="section-header" data-section="appearance">
                <span>Appearance</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-appearance">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Node Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="node-size" min="0.2" max="3" step="0.1" value="1">
                        <input type="number" id="node-size-num" class="number-input" min="0.2" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Edge Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="edge-opacity" min="0" max="1" step="0.05" value="0.4">
                        <input type="number" id="edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.4">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="toggle-labels"></div>
                </div>
                <!-- Starfield toggle REMOVED - nodes ARE the stars -->
            </div>
        </div>

        <!-- FILTERS -->
        <div class="section">
            <div class="section-header" data-section="filters">
                <span>Filters</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-filters">
                <div class="filter-group">
                    <div class="filter-label">Tiers</div>
                    <div class="chips" id="filter-tiers"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Rings</div>
                    <div class="chips" id="filter-rings"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Edge Types</div>
                    <div class="chips" id="filter-edges"></div>
                </div>
            </div>
        </div>

        <!-- ACTIONS -->
        <div class="section">
            <div class="section-header collapsed" data-section="actions">
                <span>Actions</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content collapsed" id="section-actions">
                <div class="btn-grid btn-grid-2">
                    <button class="btn" id="btn-reset">Reset View</button>
                    <button class="btn" id="btn-screenshot">Screenshot</button>
                    <button class="btn" id="btn-2d">Toggle 2D</button>
                    <button class="btn" id="btn-freeze">Freeze</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Graph Container -->
    <div id="3d-graph"></div>

    <!-- Sidebar Resize Handles -->
    <div class="sidebar-resize-handle left" id="left-resize-handle"></div>
    <div class="sidebar-resize-handle right" id="right-resize-handle"></div>

    <!-- Right Sidebar -->
    <div id="right-sidebar">
        <!-- Hover Info Panel -->
        <div class="info-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Node Info</span>
            </div>
            <div class="node-info" id="hover-panel">
                <div class="node-name" id="hover-name">Node Name</div>
                <div class="node-kind" id="hover-kind">function</div>
                <div class="info-row"><span class="label">Atom</span><span class="value" id="hover-atom">--</span></div>
                <div class="info-row"><span class="label">Family</span><span class="value" id="hover-family">--</span>
                </div>
                <div class="info-row"><span class="label">Ring</span><span class="value" id="hover-ring">--</span></div>
                <div class="info-row"><span class="label">Tier</span><span class="value" id="hover-tier">--</span></div>
                <div class="info-row"><span class="label">Role</span><span class="value" id="hover-role">--</span></div>
                <div class="node-file" id="hover-file"></div>
            </div>
            <div class="placeholder-text" id="hover-placeholder">Hover over a node to see details</div>
        </div>

        <!-- Selection Panel -->
        <div class="selection-panel">
            <div class="selection-header">
                <span class="selection-title">Selection</span>
                <span class="selection-count" id="selection-count">0</span>
            </div>
            <div id="selection-actions" style="display: none; margin-bottom: 10px;">
                <button class="selection-clear" id="selection-clear">Clear</button>
            </div>
            <div class="selection-list" id="selection-list">
                <div class="placeholder-text">Click nodes to select</div>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="value" id="stats-nodes">0</div>
                    <div class="label">Visible</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-edges">0</div>
                    <div class="label">Edges</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-files">0</div>
                    <div class="label">Files</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-density">--</div>
                    <div class="label">Density</div>
                </div>
            </div>
        </div>

        <!-- COLOR SCHEMES (33 Named Gradients) - Primary color selection -->
        <div class="info-panel schemes-panel">
            <div class="info-panel-header collapsible" data-target="section-schemes">
                <span class="info-panel-title">Color Schemes</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="section-content" id="section-schemes">
                <!-- Populated dynamically by sidebar.js -->
            </div>
        </div>

        <!-- COLOR MODE (Presets) - What dimension to color by -->
        <div class="info-panel color-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Color Mode</span>
            </div>
            <div class="section-content" id="section-color">
                <div class="btn-grid btn-grid-3">
                    <button class="btn color-btn active" data-preset="tier">Tier</button>
                    <button class="btn color-btn" data-preset="family">Family</button>
                    <button class="btn color-btn" data-preset="layer">Layer</button>
                    <button class="btn color-btn" data-preset="ring">Ring</button>
                    <button class="btn color-btn" data-preset="file">File</button>
                    <button class="btn color-btn" data-preset="flow">Flow</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance HUD -->
    <div id="perf-hud">
        <div class="perf-row">
            <span class="perf-label">FPS:</span>
            <span class="perf-value" id="perf-fps">60</span>
            <span class="perf-label">Frame:</span>
            <span class="perf-value" id="perf-frame">0ms</span>
        </div>
    </div>

    <!-- UPB Module (Universal Property Binder) -->
    <script src="assets/modules/upb/scales.js"></script>
    <script src="assets/modules/upb/endpoints.js"></script>
    <script src="assets/modules/upb/blenders.js"></script>
    <script src="assets/modules/upb/bindings.js"></script>
    <script src="assets/modules/upb/index.js"></script>

    <!-- Modules -->
    <script src="assets/modules/control-bar.js"></script>

    <!-- Toast -->
    <div id="toast"></div>

    <!-- Core Application Injection -->
    <div id="selection-box"></div>
    <script>
        // ═══ MODULE: performance.js ═══
/**
 * COLLIDER PERFORMANCE SUBSYSTEM
 *
 * Provides frame-budget-aware animation scheduling, adaptive quality management,
 * and real-time performance monitoring for the WebGL visualization.
 *
 * Architecture:
 *   PerformanceMonitor  → measures frame times, detects stuttering
 *   AnimationScheduler  → manages animation queue, enforces frame budget
 *   AdaptiveQuality     → degrades/upgrades quality based on performance
 *   PositionOwnership   → enforces single-owner invariant for node positions
 *
 * Usage:
 *   PERF.monitor.start()
 *   PERF.scheduler.requestTransition(nodes, targetPositions, duration)
 *   PERF.quality.current  // 'ultra' | 'high' | 'medium' | 'low' | 'minimal'
 */

const PERF = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION (loaded from performance.tokens.json or defaults)
    // =========================================================================

    const CONFIG = {
        frameBudget: {
            targetFps: 60,
            targetFrameMs: 16.67,
            warningThreshold: 0.8,   // 80% of budget
            criticalThreshold: 1.5   // 150% of budget
        },
        nodeThresholds: {
            small: 100,
            medium: 500,
            large: 1000,
            massive: 5000
        },
        monitoring: {
            sampleWindowMs: 1000,
            sampleCount: 60,
            degradeAfterConsecutiveDrops: 10,
            upgradeAfterConsecutiveGood: 30
        }
    };

    // =========================================================================
    // PERFORMANCE MONITOR
    // Tracks frame times using a rolling window
    // =========================================================================

    const PerformanceMonitor = {
        _frameTimes: [],
        _lastFrameTime: 0,
        _frameCount: 0,
        _droppedFrames: 0,
        _consecutiveDrops: 0,
        _consecutiveGood: 0,
        _isRunning: false,
        _rafId: null,

        start() {
            if (this._isRunning) return;
            this._isRunning = true;
            this._lastFrameTime = performance.now();
            this._tick();
        },

        stop() {
            this._isRunning = false;
            if (this._rafId) {
                cancelAnimationFrame(this._rafId);
                this._rafId = null;
            }
        },

        _tick() {
            if (!this._isRunning) return;

            const now = performance.now();
            const frameTime = now - this._lastFrameTime;
            this._lastFrameTime = now;

            // Record frame time
            this._frameTimes.push(frameTime);
            if (this._frameTimes.length > CONFIG.monitoring.sampleCount) {
                this._frameTimes.shift();
            }

            this._frameCount++;

            // Check for dropped frame
            const budget = CONFIG.frameBudget.targetFrameMs;
            if (frameTime > budget * CONFIG.frameBudget.criticalThreshold) {
                this._droppedFrames++;
                this._consecutiveDrops++;
                this._consecutiveGood = 0;

                // Trigger quality degradation check
                if (this._consecutiveDrops >= CONFIG.monitoring.degradeAfterConsecutiveDrops) {
                    AdaptiveQuality.degrade();
                    this._consecutiveDrops = 0;
                }
            } else if (frameTime < budget * CONFIG.frameBudget.warningThreshold) {
                this._consecutiveGood++;
                this._consecutiveDrops = 0;

                // Trigger quality upgrade check
                if (this._consecutiveGood >= CONFIG.monitoring.upgradeAfterConsecutiveGood) {
                    AdaptiveQuality.upgrade();
                    this._consecutiveGood = 0;
                }
            }

            this._rafId = requestAnimationFrame(() => this._tick());
        },

        get fps() {
            if (this._frameTimes.length < 2) return 0;
            const avg = this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
            return Math.round(1000 / avg);
        },

        get avgFrameTime() {
            if (this._frameTimes.length === 0) return 0;
            return this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
        },

        get lastFrameTime() {
            return this._frameTimes[this._frameTimes.length - 1] || 0;
        },

        get droppedFramePercent() {
            if (this._frameCount === 0) return 0;
            return Math.round((this._droppedFrames / this._frameCount) * 100);
        },

        get stats() {
            return {
                fps: this.fps,
                avgFrameTime: this.avgFrameTime.toFixed(2),
                lastFrameTime: this.lastFrameTime.toFixed(2),
                droppedPercent: this.droppedFramePercent,
                quality: AdaptiveQuality.current,
                owner: PositionOwnership.current
            };
        },

        reset() {
            this._frameTimes = [];
            this._frameCount = 0;
            this._droppedFrames = 0;
            this._consecutiveDrops = 0;
            this._consecutiveGood = 0;
        }
    };

    // =========================================================================
    // ADAPTIVE QUALITY MANAGER
    // Adjusts rendering quality based on performance
    // =========================================================================

    const QUALITY_TIERS = ['minimal', 'low', 'medium', 'high', 'ultra'];

    const QUALITY_SETTINGS = {
        ultra:   { refreshEvery: 1, flockEnabled: true,  labelDensity: 1.0, animDuration: 1500 },
        high:    { refreshEvery: 1, flockEnabled: false, labelDensity: 0.8, animDuration: 1200 },
        medium:  { refreshEvery: 2, flockEnabled: false, labelDensity: 0.5, animDuration: 800  },
        low:     { refreshEvery: 3, flockEnabled: false, labelDensity: 0.2, animDuration: 500  },
        minimal: { refreshEvery: 5, flockEnabled: false, labelDensity: 0.1, animDuration: 200  }
    };

    const AdaptiveQuality = {
        _current: 'high',
        _locked: false,
        _nodeCount: 0,
        _callbacks: [],

        init(nodeCount) {
            this._nodeCount = nodeCount;
            // Auto-select initial tier based on node count
            if (nodeCount <= CONFIG.nodeThresholds.small) {
                this._current = 'ultra';
            } else if (nodeCount <= CONFIG.nodeThresholds.medium) {
                this._current = 'high';
            } else if (nodeCount <= CONFIG.nodeThresholds.large) {
                this._current = 'medium';
            } else if (nodeCount <= CONFIG.nodeThresholds.massive) {
                this._current = 'low';
            } else {
                this._current = 'minimal';
            }
            console.log(`[PERF] Quality auto-set to '${this._current}' for ${nodeCount} nodes`);
            this._notify();
        },

        get current() { return this._current; },

        get settings() { return QUALITY_SETTINGS[this._current]; },

        set(tier) {
            if (!QUALITY_TIERS.includes(tier)) {
                console.warn(`[PERF] Unknown quality tier: ${tier}`);
                return;
            }
            this._current = tier;
            console.log(`[PERF] Quality set to '${tier}'`);
            this._notify();
        },

        degrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            if (idx > 0) {
                this._current = QUALITY_TIERS[idx - 1];
                console.log(`[PERF] Quality degraded to '${this._current}'`);
                this._notify();
            }
        },

        upgrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            // Don't upgrade beyond what node count allows
            const maxTier = this._getMaxTierForNodeCount();
            const maxIdx = QUALITY_TIERS.indexOf(maxTier);
            if (idx < maxIdx) {
                this._current = QUALITY_TIERS[idx + 1];
                console.log(`[PERF] Quality upgraded to '${this._current}'`);
                this._notify();
            }
        },

        lock() { this._locked = true; },
        unlock() { this._locked = false; },

        _getMaxTierForNodeCount() {
            const n = this._nodeCount;
            if (n <= CONFIG.nodeThresholds.small) return 'ultra';
            if (n <= CONFIG.nodeThresholds.medium) return 'high';
            if (n <= CONFIG.nodeThresholds.large) return 'medium';
            if (n <= CONFIG.nodeThresholds.massive) return 'low';
            return 'minimal';
        },

        onChange(callback) {
            this._callbacks.push(callback);
        },

        _notify() {
            this._callbacks.forEach(cb => cb(this._current, this.settings));
        }
    };

    // =========================================================================
    // POSITION OWNERSHIP
    // Enforces single-owner invariant for node positions (fx/fy/fz)
    // =========================================================================

    const OWNERS = ['none', 'transition', 'motion', 'flock', 'force'];

    const PositionOwnership = {
        _current: 'none',
        _animationId: null,

        get current() { return this._current; },

        acquire(owner, animationId = null) {
            if (!OWNERS.includes(owner)) {
                console.warn(`[PERF] Unknown position owner: ${owner}`);
                return false;
            }

            // Cancel any existing animation
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }

            this._current = owner;
            this._animationId = animationId;
            console.log(`[PERF] Position ownership: ${owner}`);
            return true;
        },

        release(owner) {
            if (this._current === owner) {
                if (this._animationId) {
                    cancelAnimationFrame(this._animationId);
                    this._animationId = null;
                }
                this._current = 'none';
                console.log(`[PERF] Position ownership released by ${owner}`);
            }
        },

        setAnimationId(id) {
            this._animationId = id;
        },

        cancelAnimation() {
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }
        }
    };

    // =========================================================================
    // ANIMATION SCHEDULER
    // Frame-budget-aware animation with throttling
    // =========================================================================

    const AnimationScheduler = {
        _refreshFrameCounter: 0,

        /**
         * Run a layout transition with frame budget awareness
         * @param {Object} options
         * @param {Array} options.nodes - Array of node objects
         * @param {Function} options.getTargetPosition - (node, index, total) => {x, y, z}
         * @param {number} options.duration - Animation duration in ms
         * @param {Function} options.onFrame - Called each frame with progress (0-1)
         * @param {Function} options.onComplete - Called when animation finishes
         * @param {Function} options.refresh - Function to call to refresh the graph
         */
        runTransition(options) {
            const { nodes, getTargetPosition, duration, onFrame, onComplete, refresh } = options;

            // Acquire ownership
            PositionOwnership.acquire('transition');

            const total = nodes.length;
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => getTargetPosition(n, i, total));

            const startTime = performance.now();
            const settings = AdaptiveQuality.settings;
            const actualDuration = Math.min(duration, settings.animDuration);

            this._refreshFrameCounter = 0;

            const animate = () => {
                // Check if we still own positions
                if (PositionOwnership.current !== 'transition') {
                    console.log('[PERF] Transition interrupted - lost ownership');
                    return;
                }

                const now = performance.now();
                const elapsed = now - startTime;
                const progress = Math.min(1, elapsed / actualDuration);

                // Smoothstep easing
                const eased = progress * progress * (3 - 2 * progress);

                // Update positions
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];
                    const s = startPos[i];
                    const t = targetPos[i];
                    n.fx = s.x + (t.x - s.x) * eased;
                    n.fy = s.y + (t.y - s.y) * eased;
                    n.fz = s.z + (t.z - s.z) * eased;
                }

                // Throttled refresh based on quality settings
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                if (onFrame) onFrame(progress);

                if (progress < 1) {
                    const id = requestAnimationFrame(animate);
                    PositionOwnership.setAnimationId(id);
                } else {
                    PositionOwnership.release('transition');
                    if (onComplete) onComplete();
                }
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Run continuous motion (rotate/orbit) with throttling
         */
        runMotion(options) {
            const { nodes, getPosition, speed, refresh } = options;

            PositionOwnership.acquire('motion');

            const total = nodes.length;
            const settings = AdaptiveQuality.settings;
            let time = 0;

            this._refreshFrameCounter = 0;

            const animate = () => {
                if (PositionOwnership.current !== 'motion') {
                    console.log('[PERF] Motion interrupted - lost ownership');
                    return;
                }

                time += speed;

                for (let i = 0; i < nodes.length; i++) {
                    const pos = getPosition(nodes[i], i, total, time);
                    nodes[i].fx = pos.x;
                    nodes[i].fy = pos.y;
                    nodes[i].fz = pos.z;
                }

                // Throttled refresh
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                const id = requestAnimationFrame(animate);
                PositionOwnership.setAnimationId(id);
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Stop any running animation
         */
        stop() {
            PositionOwnership.cancelAnimation();
            PositionOwnership._current = 'none';
        }
    };

    // =========================================================================
    // HUD OVERLAY
    // Real-time performance display (toggleable)
    // =========================================================================

    const HUD = {
        _element: null,
        _visible: false,
        _updateInterval: null,

        init() {
            this._element = document.createElement('div');
            this._element.id = 'perf-hud';
            this._element.style.cssText = `
                position: fixed;
                bottom: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.8);
                color: #0f0;
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
                padding: 8px 12px;
                border-radius: 4px;
                z-index: 10000;
                display: none;
                min-width: 140px;
                border: 1px solid #333;
            `;
            document.body.appendChild(this._element);
        },

        show() {
            if (!this._element) this.init();
            this._element.style.display = 'block';
            this._visible = true;
            this._startUpdates();
        },

        hide() {
            if (this._element) {
                this._element.style.display = 'none';
            }
            this._visible = false;
            this._stopUpdates();
        },

        toggle() {
            if (this._visible) this.hide();
            else this.show();
        },

        _startUpdates() {
            if (this._updateInterval) return;
            this._updateInterval = setInterval(() => this._update(), 100);
        },

        _stopUpdates() {
            if (this._updateInterval) {
                clearInterval(this._updateInterval);
                this._updateInterval = null;
            }
        },

        _update() {
            if (!this._element || !this._visible) return;

            const stats = PerformanceMonitor.stats;
            const fpsColor = stats.fps >= 55 ? '#0f0' : stats.fps >= 30 ? '#ff0' : '#f00';

            this._element.innerHTML = `
                <div style="color: ${fpsColor}; font-weight: bold;">${stats.fps} FPS</div>
                <div style="color: #888;">Frame: ${stats.lastFrameTime}ms</div>
                <div style="color: #888;">Avg: ${stats.avgFrameTime}ms</div>
                <div style="color: #888;">Drops: ${stats.droppedPercent}%</div>
                <div style="color: #0af;">Quality: ${stats.quality}</div>
                <div style="color: #a0f;">Owner: ${stats.owner}</div>
            `;
        }
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        monitor: PerformanceMonitor,
        quality: AdaptiveQuality,
        ownership: PositionOwnership,
        scheduler: AnimationScheduler,
        hud: HUD,
        config: CONFIG,

        /**
         * Initialize the performance subsystem
         * @param {number} nodeCount - Number of nodes in the graph
         * @param {Object} tokens - Optional performance tokens from JSON
         */
        init(nodeCount, tokens = null) {
            if (tokens) {
                Object.assign(CONFIG, tokens);
            }
            AdaptiveQuality.init(nodeCount);
            PerformanceMonitor.start();
            HUD.init();
            console.log('[PERF] Performance subsystem initialized');
        },

        /**
         * Check if flock simulation should be enabled
         */
        isFlockAllowed() {
            return AdaptiveQuality.settings.flockEnabled;
        },

        /**
         * Get current animation duration (adjusted for quality)
         */
        getAnimationDuration(requested) {
            return Math.min(requested, AdaptiveQuality.settings.animDuration);
        }
    };
})();

// Export for module systems if available
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PERF;
}


// ═══ MODULE: modules/utils.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UTILS MODULE - Pure Utility Functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Zero-dependency pure functions for math, string, and data operations.
 * These functions have NO external state dependencies and can be used anywhere.
 *
 * @module UTILS
 * @version 1.0.0
 * @confidence 99%
 */

window.UTILS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // MATH UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clamp value to [0, 1] range
     * @param {number} value - Value to clamp
     * @returns {number} Clamped value
     */
    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    /**
     * Clamp value to [min, max] range
     * @param {number} value - Value to clamp
     * @param {number} min - Minimum bound
     * @param {number} max - Maximum bound
     * @returns {number} Clamped value
     */
    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Normalize value to [0, 1] based on max.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} val - Value to normalize
     * @param {number} max - Maximum value
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value
     */
    function normalize(val, max, scaleName) {
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', val, 0, max);
        }
        // Fallback
        return Math.min(1, Math.max(0, val / max));
    }

    /**
     * Normalize metric value based on range.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} value - Value to normalize
     * @param {min: number, max: number} range - Range object
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value in [0, 1]
     */
    function normalizeMetric(value, range, scaleName) {
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', value, range.min, range.max);
        }
        // Fallback
        return clamp01((value - range.min) / (range.max - range.min));
    }

    /**
     * Calculate quantile from sorted values
     * @param {number[]} values - Array of numbers
     * @param {number} q - Quantile (0-1)
     * @returns {number} Quantile value
     */
    function quantile(values, q) {
        if (!values.length) return 0;
        const sorted = values.slice().sort((a, b) => a - b);
        const pos = (sorted.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;
        if (sorted[base + 1] !== undefined) {
            return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
        }
        return sorted[base];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HASH & SEED UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Convert any value to a unit float [0, 1] via hashing
     * @param {*} value - Any value to hash
     * @returns {number} Hash as unit float
     */
    function hashToUnit(value) {
        const str = String(value || '');
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return (hash >>> 0) / 0xffffffff;
    }

    /**
     * Generate stable seed from node and salt
     * @param {Object} node - Node object with id/name
     * @param {string} salt - Salt string
     * @returns {number} Stable seed in [0, 1]
     */
    function stableSeed(node, salt) {
        const id = String(node.id || node.name || '');
        const combined = `${id}|${salt}`;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
            hash = ((hash << 5) - hash + combined.charCodeAt(i)) | 0;
        }
        return ((hash >>> 0) % 1000) / 1000;
    }

    /**
     * Generate stable Z offset for node
     * @param {Object} node - Node object
     * @returns {number} Z offset
     */
    function stableZ(node) {
        const normalized = stableSeed(node, 'z');
        return (normalized - 0.5) * 60;
    }

    /**
     * Generate stable offset vector for node positioning
     * @param {Object} node - Node object
     * @param {string} salt - Salt string
     * @param {number} radius - Base radius
     * @returns {x: number, y: number, z: number} Offset vector
     */
    function stableOffset(node, salt, radius) {
        const angle = stableSeed(node, `${salt}:angle`) * Math.PI * 2;
        const spread = 0.3 + stableSeed(node, `${salt}:radius`) * 0.7;
        const zJitter = (stableSeed(node, `${salt}:z`) - 0.5) * radius * 0.6;
        const dist = radius * spread;
        return {
            x: Math.cos(angle) * dist,
            y: Math.sin(angle) * dist,
            z: zJitter
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STRING UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Escape HTML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML
     */
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Parse OKLCH color string
     * @param {string} value - OKLCH color string
     * @returns {L: number, C: number, H: number, A: number}|null} Parsed values or null
     */
    function parseOklchString(value) {
        if (typeof value !== 'string') return null;
        const match = value.trim().match(/^oklch\(\s*([\d.]+)%\s+([\d.]+)\s+([\d.]+)(?:\s*\/\s*([\d.]+))?\s*\)$/i);
        if (!match) return null;
        return {
            L: parseFloat(match[1]),
            C: parseFloat(match[2]),
            H: parseFloat(match[3]),
            A: match[4] !== undefined ? parseFloat(match[4]) : 1
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Resolve defaults against available values
     * @param {Array} defaults - Preferred defaults
     * @param {Array} available - Available values
     * @returns {Array} Resolved values
     */
    function resolveDefaults(defaults, available) {
        if (!Array.isArray(defaults) || defaults.length === 0) {
            return available;
        }
        const availableSet = new Set(available);
        const intersection = defaults.filter(value => availableSet.has(value));
        return intersection.length ? intersection : available;
    }

    /**
     * Build dataset key from data object
     * @param {Object} data - Data object with meta, nodes, links
     * @returns {string} Dataset key
     */
    function buildDatasetKey(data) {
        const meta = (data && data.meta) ? data.meta : {};
        const target = meta.target || meta.project || 'dataset';
        const version = meta.version || '';
        const nodeCount = Array.isArray(data?.nodes) ? data.nodes.length : 0;
        const edgeCount = Array.isArray(data?.links)
            ? data.links.length
            : (Array.isArray(data?.edges) ? data.edges.length : 0);
        const raw = `${target}|${nodeCount}|${edgeCount}|${version}`;
        return raw.replace(/[^a-zA-Z0-9_.-]/g, '_').slice(0, 180);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GEOMETRY UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Calculate bounding box from two points
     * @param {x: number, y: number} start - Start point
     * @param {x: number, y: number} end - End point
     * @returns {left: number, top: number, width: number, height: number, right: number, bottom: number} Box rect
     */
    function getBoxRect(start, end) {
        const left = Math.min(start.x, end.x);
        const top = Math.min(start.y, end.y);
        const width = Math.abs(start.x - end.x);
        const height = Math.abs(start.y - end.y);
        return {
            left,
            top,
            width,
            height,
            right: left + width,
            bottom: top + height
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Math
        clamp01,
        clampValue,
        normalize,
        normalizeMetric,
        quantile,

        // Hash & Seed
        hashToUnit,
        stableSeed,
        stableZ,
        stableOffset,

        // String
        escapeHtml,
        parseOklchString,

        // Data
        resolveDefaults,
        buildDatasetKey,

        // Geometry
        getBoxRect
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════
// These ensure existing code continues to work without modification

window.clamp01 = UTILS.clamp01;
window.clampValue = UTILS.clampValue;
window.normalize = UTILS.normalize;
window.normalizeMetric = UTILS.normalizeMetric;
window.quantile = UTILS.quantile;
window.hashToUnit = UTILS.hashToUnit;
window.stableSeed = UTILS.stableSeed;
window.stableZ = UTILS.stableZ;
window.stableOffset = UTILS.stableOffset;
window.escapeHtml = UTILS.escapeHtml;
window.parseOklchString = UTILS.parseOklchString;
window.resolveDefaults = UTILS.resolveDefaults;
window.buildDatasetKey = UTILS.buildDatasetKey;
window.getBoxRect = UTILS.getBoxRect;

console.log('[Module] UTILS loaded - 14 pure functions');


// ═══ MODULE: modules/registry.js ═══
/**
 * @module registry
 * @description Centralized UI and command registration system
 * @responsibility Manage DOM element and command handler registration
 */

const REGISTRY = (function() {
    'use strict';

    // Private state
    const _items = new Map();
    const _commands = new Map();

    /**
     * Register a command handler or DOM element
     * @param {string} id - The identifier
     * @param {Function|Element} item - Handler function or DOM element
     * @param {Object} options - Additional options
     */
    function register(id, item, options = {}) {
        // CASE 1: Registering a Command Identifier + Handler Function
        // e.g. REGISTRY.register('cmd-files', () => toggleFiles(), { desc: '...' })
        if (typeof item === 'function') {
            _commands.set(id, { handler: item, options });

            // Auto-wire if DOM element exists with this ID
            const btn = document.getElementById(id);
            if (btn) {
                btn.onclick = (e) => {
                    item(e);
                };
                btn.setAttribute('data-command-id', id);
            }
            return;
        }

        // CASE 2: Registering a DOM Element directly
        let element = item;
        let elementId = id;

        // Overload: register(element) -> id comes from element.id
        if ((item instanceof Element) && arguments.length === 1) {
            element = item;
            elementId = element.id;
        }
        // Overload: register(id, element)
        else if (item instanceof Element) {
            element = item;
        }
        // Fallback: mismatched args
        else if (!element && (typeof id === 'object' && id instanceof Element)) {
            element = id;
            elementId = element.id;
        }

        if (!element || !element.setAttribute) {
            return;
        }

        if (!elementId) {
            return;
        }

        _items.set(elementId, element);
        element.setAttribute('data-registry-id', elementId);
    }

    /**
     * Get a registered element by ID (falls back to document.getElementById)
     * @param {string} id - The element ID
     * @returns {Element|null}
     */
    function get(id) {
        return _items.get(id) || document.getElementById(id);
    }

    /**
     * Get a registered command handler
     * @param {string} id - The command ID
     * @returns {Object|undefined} - { handler, options }
     */
    function getCommand(id) {
        return _commands.get(id);
    }

    /**
     * Execute a registered command
     * @param {string} id - The command ID
     * @param {Event} event - Optional event object
     * @returns {*} - Result of handler execution
     */
    function execute(id, event) {
        const cmd = _commands.get(id);
        if (cmd && typeof cmd.handler === 'function') {
            return cmd.handler(event);
        }
        console.warn(`[Registry] Command not found: ${id}`);
        return undefined;
    }

    /**
     * Check if a command is registered
     * @param {string} id - The command ID
     * @returns {boolean}
     */
    function hasCommand(id) {
        return _commands.has(id);
    }

    /**
     * Check if an element is registered
     * @param {string} id - The element ID
     * @returns {boolean}
     */
    function hasElement(id) {
        return _items.has(id);
    }

    /**
     * Get all registered command IDs
     * @returns {string[]}
     */
    function listCommands() {
        return Array.from(_commands.keys());
    }

    /**
     * Get all registered element IDs
     * @returns {string[]}
     */
    function listElements() {
        return Array.from(_items.keys());
    }

    // Public API
    return {
        register,
        get,
        getCommand,
        execute,
        hasCommand,
        hasElement,
        listCommands,
        listElements,
        // Expose maps for backward compatibility (read-only access pattern)
        get items() { return _items; },
        get commands() { return _commands; }
    };
})();

// Expose globally for backward compatibility
window.REGISTRY = REGISTRY;


// ═══ MODULE: modules/perf-monitor.js ═══
/**
 * @module perf-monitor
 * @description Real-time performance monitoring and FPS diagnostics
 * @responsibility Track frame delivery, detect dropped frames, display HUD
 */

// NOTE: Named _PerfMonitorImpl to avoid conflict with performance.js PERF
const _PerfMonitorImpl = (function() {
    'use strict';

    // Configuration
    const _config = {
        enabled: true,
        maxFrames: 60,
        droppedFrameThreshold: 50  // ms (>50ms = <20fps)
    };

    // State
    const _state = {
        fps: 0,
        frameTime: 0,
        lastFrameTime: 0,
        frameTimes: [],
        renderCalls: 0,
        droppedFrames: 0,
        lastSecond: 0,
        framesThisSecond: 0,
        hudElement: null,
        monitoring: false
    };

    /**
     * Initialize the performance monitor
     */
    function init() {
        if (!_config.enabled) return;

        // Create HUD element
        _state.hudElement = document.createElement('div');
        _state.hudElement.id = 'perf-hud';
        _state.hudElement.style.cssText = `
            position: fixed; top: 10px; right: 10px; z-index: 99999;
            background: rgba(0,0,0,0.85); color: #0f0; font-family: monospace;
            font-size: 11px; padding: 8px 12px; border-radius: 4px;
            border: 1px solid #333; min-width: 140px; pointer-events: none;
        `;
        document.body.appendChild(_state.hudElement);
        _startMonitoring();
    }

    /**
     * Start the monitoring loop
     */
    function _startMonitoring() {
        if (_state.monitoring) return;
        _state.monitoring = true;

        const monitor = () => {
            if (!_state.monitoring) return;

            const now = performance.now();

            // Calculate frame time
            if (_state.lastFrameTime > 0) {
                _state.frameTime = now - _state.lastFrameTime;
                _state.frameTimes.push(_state.frameTime);
                if (_state.frameTimes.length > _config.maxFrames) {
                    _state.frameTimes.shift();
                }

                // Detect dropped frames
                if (_state.frameTime > _config.droppedFrameThreshold) {
                    _state.droppedFrames++;
                }
            }
            _state.lastFrameTime = now;

            // Calculate FPS every second
            const second = Math.floor(now / 1000);
            if (second !== _state.lastSecond) {
                _state.fps = _state.framesThisSecond;
                _state.framesThisSecond = 0;
                _state.lastSecond = second;
            }
            _state.framesThisSecond++;

            // Update HUD
            _updateHUD();
            requestAnimationFrame(monitor);
        };
        requestAnimationFrame(monitor);
    }

    /**
     * Update the HUD display
     */
    function _updateHUD() {
        if (!_state.hudElement) return;

        const avgFrameTime = _state.frameTimes.length > 0
            ? (_state.frameTimes.reduce((a, b) => a + b, 0) / _state.frameTimes.length).toFixed(1)
            : '0.0';

        // Color code FPS
        let fpsColor = '#0f0';  // Green = good
        if (_state.fps < 30) fpsColor = '#ff0';  // Yellow = warning
        if (_state.fps < 15) fpsColor = '#f00';  // Red = bad

        // Animation state - use ANIM module if available
        const isAnimating = typeof ANIM !== 'undefined' && ANIM.isAnimating;
        const animating = isAnimating ? '▶ ANIMATING' : '■ IDLE';
        const animColor = isAnimating ? '#0ff' : '#666';
        const staggerPattern = (typeof ANIM !== 'undefined' && ANIM.staggerPattern) || 'none';

        _state.hudElement.innerHTML = `
            <div style="color:${fpsColor};font-size:14px;font-weight:bold">${_state.fps} FPS</div>
            <div>Frame: ${avgFrameTime}ms</div>
            <div>Dropped: <span style="color:${_state.droppedFrames > 10 ? '#f00' : '#0f0'}">${_state.droppedFrames}</span></div>
            <div style="color:${animColor}">${animating}</div>
            <div style="font-size:9px;color:#666;margin-top:4px">Pattern: ${staggerPattern}</div>
        `;
    }

    /**
     * Log a performance resistance point
     * @param {string} location - Where the resistance occurred
     * @param {number} duration - Duration in milliseconds
     */
    function logResistance(location, duration) {
        if (duration > 16) {
            console.warn(`[PERF RESISTANCE] ${location}: ${duration.toFixed(1)}ms (>${Math.floor(duration / 16.67)} frames)`);
        }
    }

    /**
     * Stop monitoring
     */
    function stop() {
        _state.monitoring = false;
        if (_state.hudElement && _state.hudElement.parentNode) {
            _state.hudElement.parentNode.removeChild(_state.hudElement);
        }
        _state.hudElement = null;
    }

    /**
     * Reset statistics
     */
    function reset() {
        _state.fps = 0;
        _state.frameTime = 0;
        _state.frameTimes = [];
        _state.droppedFrames = 0;
        _state.framesThisSecond = 0;
    }

    /**
     * Toggle HUD visibility
     */
    function toggle() {
        if (_state.hudElement) {
            _state.hudElement.style.display =
                _state.hudElement.style.display === 'none' ? 'block' : 'none';
        }
    }

    /**
     * Enable/disable monitoring
     * @param {boolean} enabled
     */
    function setEnabled(enabled) {
        _config.enabled = enabled;
        if (!enabled) {
            stop();
        } else if (!_state.monitoring) {
            init();
        }
    }

    // Public API
    return {
        init,
        stop,
        reset,
        toggle,
        setEnabled,
        logResistance,
        // Read-only state access
        get fps() { return _state.fps; },
        get frameTime() { return _state.frameTime; },
        get droppedFrames() { return _state.droppedFrames; },
        get enabled() { return _config.enabled; },
        get monitoring() { return _state.monitoring; }
    };
})();

// Export as PERF_MONITOR (PERF is provided by performance.js)
const PERF_MONITOR = _PerfMonitorImpl;

// Expose globally - only PERF_MONITOR, PERF comes from performance.js
window.PERF_MONITOR = PERF_MONITOR;


// ═══ MODULE: modules/core.js ═══
/**
 * CORE MODULE
 *
 * Foundation constants and utility functions for the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   CORE.SELECTION_SIZE_MULT      // Node size multiplier when selected
 *   CORE.PENDULUM                 // OKLCH color oscillator state
 *   CORE.amplify(value, gamma)    // Power law amplification
 *   CORE.amplifyContrast(value)   // S-curve contrast expansion
 */

const CORE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

    // OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
    const PENDULUM = {
        hue: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,        // Set from appearance.tokens
            gravity: null,        // Set from appearance.tokens
            length: 1.0,
            rotationSpeed: null   // Set from appearance.tokens
        },
        chroma: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,
            gravity: null,
            length: 1.0,
            center: null,
            amplitude: null
        },
        lightness: {
            phase: 0,
            speed: null,
            center: null,
            amplitude: null
        },
        ripple: {
            speed: null,
            scale: null
        },
        currentHue: Math.random() * 360,
        lastTime: 0,
        running: false
    };

    // =========================================================================
    // AMPLIFICATION UTILITIES
    // =========================================================================

    /**
     * Amplification function using power law: f(x) = x^(1/gamma)
     * Maps normalized [0,1] input to amplified [0,1] output
     * @param {number} value - Input value (0-1)
     * @param {number} gamma - Amplification factor (default from APPEARANCE_STATE)
     * @returns {number} Amplified value (0-1)
     */
    function amplify(value, gamma) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const g = gamma !== undefined ? gamma :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (g === 1) return value;
        // Clamp to valid range
        const v = Math.max(0, Math.min(1, value));
        // Power law: v^(1/gamma) - when gamma>1, small diffs become larger
        // Using 1/gamma so that higher slider = more amplification
        return Math.pow(v, 1 / g);
    }

    /**
     * Contrast amplification: expands values away from midpoint
     * Uses S-curve (tanh) for smooth contrast expansion
     * @param {number} value - Input value (0-1)
     * @param {number} strength - Contrast strength (default from APPEARANCE_STATE)
     * @returns {number} Contrast-enhanced value (0-1)
     */
    function amplifyContrast(value, strength) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const s = strength !== undefined ? strength :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (s === 1) return value;
        const v = Math.max(0, Math.min(1, value));
        // S-curve using tanh for smooth contrast expansion
        const centered = (v - 0.5) * 2;  // [-1, 1]
        const amplified = Math.tanh(centered * s) / Math.tanh(s);
        return (amplified + 1) / 2;  // Back to [0, 1]
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Constants
        SELECTION_SIZE_MULT,
        PENDULUM,

        // Utilities
        amplify,
        amplifyContrast
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'SELECTION_SIZE_MULT', {
    get: () => CORE.SELECTION_SIZE_MULT,
    configurable: true
});
Object.defineProperty(window, 'PENDULUM', {
    get: () => CORE.PENDULUM,
    configurable: true
});
Object.defineProperty(window, 'amplify', {
    get: () => CORE.amplify,
    configurable: true
});
Object.defineProperty(window, 'amplifyContrast', {
    get: () => CORE.amplifyContrast,
    configurable: true
});


// ═══ MODULE: modules/theory.js ═══
/**
 * THEORY MODULE - Standard Model of Code Theory Constants
 *
 * Pure data representing the Standard Model topology.
 * No dependencies. This is the canonical source of truth.
 *
 * @module THEORY
 * @version 1.0.0
 */

window.THEORY = (function() {
    'use strict';

    // =========================================================================
    // THE 16 ABSTRACTION LEVELS (vertical axis: L-3 to L12)
    // =========================================================================

    const SCALE_16_LEVELS = {
        // COSMOLOGICAL (L8-L12) - Beyond scope, shown as outer haze
        'L12': { name: 'UNIVERSE', symbol: '🌐', zone: 'COSMOLOGICAL', y: 1.4, color: { h: 260, s: 30, l: 25 } },
        'L11': { name: 'DOMAIN', symbol: '🏛️', zone: 'COSMOLOGICAL', y: 1.3, color: { h: 250, s: 35, l: 30 } },
        'L10': { name: 'ORGANIZATION', symbol: '🏢', zone: 'COSMOLOGICAL', y: 1.2, color: { h: 240, s: 40, l: 35 } },
        'L9': { name: 'PLATFORM', symbol: '☁️', zone: 'COSMOLOGICAL', y: 1.1, color: { h: 230, s: 45, l: 40 } },
        'L8': { name: 'ECOSYSTEM', symbol: '🔗', zone: 'COSMOLOGICAL', y: 1.0, color: { h: 220, s: 50, l: 45 } },
        // ARCHITECTURAL (L4-L7) - Primary visible zone (teal - virtual depths)
        'L7': { name: 'SYSTEM', symbol: '⬡', zone: 'ARCHITECTURAL', y: 0.7, color: { h: 175, s: 60, l: 52 } },
        'L6': { name: 'PACKAGE', symbol: '📦', zone: 'ARCHITECTURAL', y: 0.5, color: { h: 178, s: 62, l: 48 } },
        'L5': { name: 'FILE', symbol: '📄', zone: 'ARCHITECTURAL', y: 0.3, color: { h: 180, s: 65, l: 44 } },
        'L4': { name: 'CONTAINER', symbol: '⬢', zone: 'ARCHITECTURAL', y: 0.1, color: { h: 182, s: 68, l: 40 } },
        // SEMANTIC (L1-L3) - The operational core (silver/white - surface light)
        'L3': { name: 'NODE', symbol: '★', zone: 'SEMANTIC', y: -0.1, color: { h: 210, s: 25, l: 92 } },  // Brightest - fundamental unit
        'L2': { name: 'BLOCK', symbol: '▣', zone: 'SEMANTIC', y: -0.3, color: { h: 210, s: 30, l: 85 } },
        'L1': { name: 'STATEMENT', symbol: '─', zone: 'SEMANTIC', y: -0.5, color: { h: 210, s: 35, l: 78 } },
        // SYNTACTIC (L0) - The event horizon between meaning and data
        'L0': { name: 'TOKEN', symbol: '·', zone: 'SYNTACTIC', y: -0.7, color: { h: 60, s: 90, l: 55 } },  // Bright yellow - event horizon
        // PHYSICAL (L-1 to L-3) - The substrate (deep blue - ocean floor)
        'L-1': { name: 'CHARACTER', symbol: 'a', zone: 'PHYSICAL', y: -0.9, color: { h: 220, s: 70, l: 42 } },
        'L-2': { name: 'BYTE', symbol: '01', zone: 'PHYSICAL', y: -1.1, color: { h: 220, s: 75, l: 35 } },
        'L-3': { name: 'BIT/QUBIT', symbol: '⚡', zone: 'PHYSICAL', y: -1.3, color: { h: 220, s: 80, l: 28 } }  // Deepest
    };

    // =========================================================================
    // THE THREE PARALLEL LAYERS (shells around the structure)
    // =========================================================================

    const THREE_LAYERS = {
        'PHYSICAL': { order: 0, radius: 1.8, opacity: 0.15, color: { h: 220, s: 75, l: 35 }, description: 'Hardware, bits, memory, I/O' },
        'VIRTUAL': { order: 1, radius: 1.4, opacity: 0.25, color: { h: 175, s: 65, l: 45 }, description: 'Code, structures, algorithms' },
        'SEMANTIC': { order: 2, radius: 1.0, opacity: 0.35, color: { h: 210, s: 30, l: 88 }, description: 'Meaning, business logic, intent' }
    };

    // =========================================================================
    // STANDARD MODEL THEORY CONTENT - Semantic descriptions for tooltips
    // =========================================================================

    const SMC_THEORY = {
        // THE THREE FUNDAMENTAL LAYERS
        layers: {
            'PHYSICAL': {
                icon: '⚡',
                title: 'Physical Layer',
                subtitle: 'The Substrate',
                body: 'The hardware reality: electrons, circuits, memory cells. Everything that exists in physical space-time.',
                theory: '"Matter is the canvas upon which computation paints its patterns."',
                examples: ['CPU registers', 'RAM cells', 'disk sectors', 'network signals']
            },
            'VIRTUAL': {
                icon: '💠',
                title: 'Virtual Layer',
                subtitle: 'The Structure',
                body: 'Pure information structures: code, data, algorithms. The mathematical forms that live in computational space.',
                theory: '"Between the physical and the meaningful lies the virtual — pure form without matter or purpose."',
                examples: ['variables', 'functions', 'classes', 'data structures']
            },
            'SEMANTIC': {
                icon: '🎯',
                title: 'Semantic Layer',
                subtitle: 'The Meaning',
                body: 'Intent and purpose: business logic, user goals, system behavior. The "why" behind the code.',
                theory: '"Semantics is where computation meets human intention — the bridge between bits and understanding."',
                examples: ['user stories', 'business rules', 'API contracts', 'domain models']
            }
        },

        // ATOM FAMILIES
        families: {
            'LOG': {
                icon: '📊',
                title: 'Logic Family',
                subtitle: 'The Reasoners',
                body: 'Elements that transform data through computation: conditionals, loops, calculations.',
                theory: '"Logic atoms are the decision-makers — they take inputs and produce outputs through transformation."',
                examples: ['if/else', 'for loops', 'calculations', 'validators']
            },
            'DAT': {
                icon: '📦',
                title: 'Data Family',
                subtitle: 'The Containers',
                body: 'Elements that hold and organize information: variables, structures, databases.',
                theory: '"Data atoms store state — they are the nouns in the grammar of code."',
                examples: ['variables', 'arrays', 'objects', 'databases']
            },
            'ORG': {
                icon: '🏗️',
                title: 'Organization Family',
                subtitle: 'The Architects',
                body: 'Elements that structure code: modules, classes, packages. They create boundaries.',
                theory: '"Organization atoms create order from chaos — the folders in the file system of abstraction."',
                examples: ['modules', 'classes', 'packages', 'namespaces']
            },
            'EXE': {
                icon: '⚙️',
                title: 'Execution Family',
                subtitle: 'The Doers',
                body: 'Elements that perform actions: function calls, I/O, system operations.',
                theory: '"Execution atoms are the verbs — where potential becomes actual."',
                examples: ['function calls', 'API requests', 'file writes', 'renders']
            },
            'EXT': {
                icon: '🔌',
                title: 'External Family',
                subtitle: 'The Connectors',
                body: 'Elements that interface with the outside: APIs, imports, system calls.',
                theory: '"External atoms are portals — they connect isolated systems into larger ecosystems."',
                examples: ['imports', 'API calls', 'env vars', 'dependencies']
            }
        },

        // TIERS
        tiers: {
            'T0': {
                icon: '🔬',
                title: 'Tier 0 — Foundation',
                subtitle: 'Low-level primitives',
                body: 'The atomic building blocks: individual statements, expressions, basic operations.',
                theory: '"T0 is where code meets silicon — the ground floor of abstraction."',
                examples: ['assignments', 'operators', 'literals', 'basic types']
            },
            'T1': {
                icon: '🔧',
                title: 'Tier 1 — Components',
                subtitle: 'Functional units',
                body: 'Grouped functionality: functions, methods, small modules.',
                theory: '"T1 is the sweet spot — complex enough to be useful, simple enough to understand."',
                examples: ['functions', 'methods', 'handlers', 'utilities']
            },
            'T2': {
                icon: '🏛️',
                title: 'Tier 2 — Architecture',
                subtitle: 'System structure',
                body: 'High-level organization: classes, modules, services. The skeleton of the codebase.',
                theory: '"T2 defines the shape of software — patterns emerge that echo through every line."',
                examples: ['classes', 'modules', 'services', 'controllers']
            }
        },

        // SPECIAL ELEMENTS
        special: {
            'core': {
                icon: '✨',
                title: 'The Nexus',
                subtitle: 'Singularity Point',
                body: 'The center of the topology: where all paths converge.',
                theory: '"Every codebase has a heart — the central modules that everything depends upon."',
                examples: ['main.js', 'app.py', 'index.ts', 'core.rs']
            },
            'elevator': {
                icon: '🚀',
                title: 'Data Elevator',
                subtitle: 'Cross-tier Highway',
                body: 'Vertical connections that move data between abstraction levels.',
                theory: '"Elevators are the call stacks of architecture."',
                examples: ['API layers', 'ORMs', 'serializers', 'adapters']
            },
            'hub-star': {
                icon: '⭐',
                title: 'Hub Node',
                subtitle: 'High-connectivity Center',
                body: 'A node with many incoming connections. Often a critical dependency.',
                theory: '"Hubs are the load-bearing walls — remove them and everything collapses."',
                examples: ['utils', 'config', 'logger', 'database']
            }
        }
    };

    // =========================================================================
    // LEVEL ZONES - Which levels belong to which visual band
    // =========================================================================

    const LEVEL_ZONES = {
        'COSMOLOGICAL': { levels: ['L12', 'L11', 'L10', 'L9', 'L8'], opacity: 0.2, blur: true },
        'ARCHITECTURAL': { levels: ['L7', 'L6', 'L5', 'L4'], opacity: 0.6, blur: false },
        'SEMANTIC': { levels: ['L3', 'L2', 'L1'], opacity: 1.0, blur: false },        // Primary focus
        'SYNTACTIC': { levels: ['L0'], opacity: 0.8, blur: false },                   // Event horizon
        'PHYSICAL': { levels: ['L-1', 'L-2', 'L-3'], opacity: 0.4, blur: true }
    };

    // =========================================================================
    // VISUALIZATION PRESETS - Different ways to see the topology
    // =========================================================================

    const VIS_PRESETS = {
        'tier': {
            name: 'By Tier (T0/T1/T2)',
            description: 'Core → Architecture → External',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'family': {
            name: 'By Atom Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'layer': {
            name: 'By Layer',
            description: 'Physical → Virtual → Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'ring': {
            name: 'By Ring (Domain)',
            description: 'Domain architecture layers',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'file': {
            name: 'By File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'flow': {
            name: 'Markov Flow',
            description: 'Edge width = transition probability',
            colorBy: 'tier',
            sizeBy: 'entropy',
            edgeBy: 'weight'
        },
        'depth': {
            name: 'By Depth (Call Distance)',
            description: 'Distance from entry points',
            colorBy: 'depth',
            sizeBy: 'fanout',
            edgeBy: 'type'
        }
        // NOTE: Color schemes (viridis, plasma, thermal, etc.) are now in color-engine.js schemePaths
        // Access via COLOR.listSchemes(), COLOR.applyScheme(), COLOR.getSchemeColor()
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        SCALE_16_LEVELS,
        THREE_LAYERS,
        SMC_THEORY,
        LEVEL_ZONES,
        VIS_PRESETS,

        // Convenience getters
        getLevel: (id) => SCALE_16_LEVELS[id],
        getLayer: (id) => THREE_LAYERS[id],
        getZone: (id) => LEVEL_ZONES[id],
        getPreset: (id) => VIS_PRESETS[id],

        // Theory content accessors (for tooltips)
        getTheoryContent: (category, key) => SMC_THEORY[category]?.[key],
        getLayerTheory: (key) => SMC_THEORY.layers[key],
        getFamilyTheory: (key) => SMC_THEORY.families[key],
        getTierTheory: (key) => SMC_THEORY.tiers[key],
        getSpecialTheory: (key) => SMC_THEORY.special[key]
    };
})();

// =========================================================================
// BACKWARD COMPATIBILITY SHIMS
// =========================================================================

window.SCALE_16_LEVELS = THEORY.SCALE_16_LEVELS;
window.THREE_LAYERS = THEORY.THREE_LAYERS;
window.SMC_THEORY = THEORY.SMC_THEORY;
window.LEVEL_ZONES = THEORY.LEVEL_ZONES;
window.VIS_PRESETS = THEORY.VIS_PRESETS;

console.log('[Module] THEORY loaded - 5 constants, 8 accessors');


// ═══ MODULE: modules/node-accessors.js ═══
/**
 * NODE ACCESSORS MODULE
 *
 * Provides standardized access to node properties across the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   NODE.getTier(node)       // Returns 'T0', 'T1', 'T2', or 'UNKNOWN'
 *   NODE.getFamily(node)     // Returns 'LOG', 'DAT', 'ORG', 'EXE', 'EXT', or 'UNKNOWN'
 *   NODE.getRing(node)       // Returns ring/layer value
 *   NODE.getLayer(node)      // Returns D2_LAYER value
 *   NODE.getEffect(node)     // Returns D6_EFFECT value
 */

const NODE = (function() {
    'use strict';

    // =========================================================================
    // TIER SYSTEM
    // =========================================================================

    // Tier aliases: legacy names -> canonical T0/T1/T2
    const TIER_ALIASES = {
        'CORE': 'T0', 'T0': 'T0',
        'ARCH': 'T1', 'T1': 'T1',
        'EXT': 'T2', 'T2': 'T2',
        'DISCOVERED': 'T2',  // EXT.DISCOVERED -> T2
        'UNKNOWN': 'UNKNOWN'
    };

    function normalizeTier(tier) {
        if (!tier) return 'UNKNOWN';
        const upper = String(tier).toUpperCase();
        return TIER_ALIASES[upper] || upper;
    }

    // Prefer canonical node.tier field; fallback to atom prefix inference
    function getTier(node) {
        // If node is a string (backward compat: called with atomId), infer from prefix
        if (typeof node === 'string') {
            const atomId = node;
            if (!atomId) return 'UNKNOWN';
            if (atomId.startsWith('CORE.')) return 'T0';
            if (atomId.startsWith('ARCH.')) return 'T1';
            if (atomId.startsWith('EXT.')) return 'T2';
            return 'UNKNOWN';
        }
        // Prefer canonical field
        if (node.tier) {
            return normalizeTier(node.tier);
        }
        // Fallback: infer from atom prefix
        const atomId = String(node.atom || '');
        if (atomId.startsWith('CORE.')) return 'T0';
        if (atomId.startsWith('ARCH.')) return 'T1';
        if (atomId.startsWith('EXT.')) return 'T2';
        return 'UNKNOWN';
    }

    // =========================================================================
    // FAMILY SYSTEM
    // =========================================================================

    // Get atom family from canonical field or infer from atom prefix
    function getFamily(node) {
        // Prefer canonical field
        if (node.atom_family) {
            return String(node.atom_family).toUpperCase();
        }
        // Fallback: infer from atom (e.g., "LOG.FNC.M" -> "LOG")
        const atomId = String(node.atom || '');
        const dotIdx = atomId.indexOf('.');
        if (dotIdx > 0) {
            return atomId.substring(0, dotIdx).toUpperCase();
        }
        return 'UNKNOWN';
    }

    // =========================================================================
    // RING SYSTEM
    // =========================================================================

    function normalizeRing(value) {
        if (value === null || value === undefined) return null;
        const ring = String(value).trim().toUpperCase();
        if (!ring) return null;
        const aliases = {
            TEST: 'TESTING'
        };
        return aliases[ring] || ring;
    }

    function getRing(node) {
        const ring = node.ring || node.layer || 'UNKNOWN';
        return normalizeRing(ring) || 'UNKNOWN';
    }

    // =========================================================================
    // LAYER SYSTEM (D2_LAYER)
    // =========================================================================

    function getLayer(node) {
        if (!node) return 'Unknown';
        return node.layer || node.dimensions?.D2_LAYER || 'Unknown';
    }

    // =========================================================================
    // EFFECT SYSTEM (D6_EFFECT)
    // =========================================================================

    function getEffect(node) {
        if (!node) return 'Unknown';
        return node.effect || node.dimensions?.D6_EFFECT || 'Unknown';
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Tier
        getTier,
        normalizeTier,
        TIER_ALIASES,

        // Family
        getFamily,

        // Ring
        getRing,
        normalizeRing,

        // Layer
        getLayer,

        // Effect
        getEffect
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'getNodeTier', { get: () => NODE.getTier, configurable: true });
Object.defineProperty(window, 'getNodeAtomFamily', { get: () => NODE.getFamily, configurable: true });
Object.defineProperty(window, 'getNodeRing', { get: () => NODE.getRing, configurable: true });
Object.defineProperty(window, 'getNodeLayer', { get: () => NODE.getLayer, configurable: true });
Object.defineProperty(window, 'getNodeEffect', { get: () => NODE.getEffect, configurable: true });
Object.defineProperty(window, 'normalizeTier', { get: () => NODE.normalizeTier, configurable: true });
Object.defineProperty(window, 'normalizeRingValue', { get: () => NODE.normalizeRing, configurable: true });
Object.defineProperty(window, 'TIER_ALIASES', { get: () => NODE.TIER_ALIASES, configurable: true });


// ═══ MODULE: modules/node-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * NODE-HELPERS MODULE - Node classification and color functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node color mode selection, data enrichment helpers, and tier grouping.
 * Depends on: COLOR (ColorOrchestrator), NODE (node-accessors), DM, Graph
 *
 * @module NODE_HELPERS
 * @version 1.0.0
 */

window.NODE_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR BY MODE
    // ═══════════════════════════════════════════════════════════════════════

    // =========================================================================
    // MODE_ACCESSORS: Declarative map replacing the mega-switch
    // Each mode maps to a function: (node, Color) => colorString
    // =========================================================================

    const MODE_ACCESSORS = {
        // 1. ARCHITECTURE
        tier:           (n, C) => C.get('tier', window.getNodeTier(n)),
        layer:          (n, C) => C.get('layer', (n.layer || n.dimensions?.D2_LAYER || 'UNKNOWN').toUpperCase()),
        subsystem:      (n, C) => C.get('subsystem', getSubsystem(n)),
        boundary_score: (n, C) => C.getInterval('boundary_score', window.normalize(n.rpbl?.boundary ?? 1, 9)),
        phase:          (n, C) => C.get('phase', getPhase(n)),

        // 2. TAXONOMY
        atom:           (n, C) => C.get('atom', (n.kind || n.type || 'unknown').toLowerCase()),
        family:         (n, C) => C.get('family', window.getNodeAtomFamily(n)),
        role:           (n, C) => C.get('roleCategory', n.role_cat || 'Unknown'),
        roleCategory:   (n, C) => C.get('roleCategory', n.role_cat || getRoleCategory(n)),
        fileType:       (n, C) => C.get('fileType', getFileType(n)),

        // 3. METRICS
        complexity:     (n, C) => C.getInterval('complexity', window.normalize(n.complexity || 0, 20)),
        loc:            (n, C) => C.getInterval('loc', window.normalize(n.lines_of_code || 0, 500)),
        fan_in:         (n, C) => C.getInterval('fan_in', window.normalize(n.in_degree || 0, 20)),
        fan_out:        (n, C) => C.getInterval('fan_out', window.normalize(n.out_degree || 0, 20)),
        trust:          (n, C) => C.getInterval('trust', n.trust || n.confidence || 0),

        // 4. RPBL DNA
        responsibility: (n, C) => C.getInterval('responsibility', window.normalize(n.rpbl?.responsibility ?? 1, 9)),
        purity:         (n, C) => C.getInterval('purity', window.normalize(n.rpbl?.purity ?? 1, 9)),
        lifecycle_score:(n, C) => C.getInterval('lifecycle_score', window.normalize(n.rpbl?.lifecycle ?? 1, 9)),
        state:          (n, C) => C.get('state', (n.dimensions?.D5_STATE === 'Stateful') ? 'Stateful' : 'Stateless'),
        visibility:     (n, C) => C.get('visibility', n.dimensions?.D4_BOUNDARY === 'External' ? 'Public' : 'Private'),

        // 5. TOPOLOGY
        centrality:     (n, C) => C.getInterval('centrality', n.centrality || 0),
        rank:           (n, C) => C.getInterval('centrality', n.pagerank || 0),
        ring:           (n, C) => C.get('ring', window.getNodeRing(n)),

        // 6. EVOLUTION (Placeholders)
        churn:          (n, C) => C.getInterval('churn', Math.random() * 0.5),
        age:            (n, C) => C.getInterval('churn', 0.2)
    };

    function getNodeColorByMode(node) {
        const Color = window.Color;
        const NODE_COLOR_MODE = window.NODE_COLOR_MODE;
        const DM = window.DM;

        // Special case: file coloring needs extra context
        if (NODE_COLOR_MODE === 'file') {
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx < 0) return Color.get('tier', 'UNKNOWN');
            const fileBoundaries = DM ? DM.getFileBoundaries() : [];
            const totalFiles = fileBoundaries.length;
            const fileInfo = fileBoundaries[fileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            return window.getFileColor(fileIdx, totalFiles, fileLabel);
        }

        // Use MODE_ACCESSORS map - O(1) lookup instead of if-chain
        const accessor = MODE_ACCESSORS[NODE_COLOR_MODE];
        if (accessor) return accessor(node, Color);

        // Default fallback
        return Color.get('tier', window.getNodeTier(node));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA ENRICHMENT HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getSubsystem(node) {
        if (!node.file_path) return 'Unknown';
        if (node.file_path.includes('/api/')) return 'Ingress';
        if (node.file_path.includes('/db/') || node.file_path.includes('repository')) return 'Persistence';
        if (node.file_path.includes('/core/') || node.file_path.includes('domain')) return 'Domain';
        if (node.file_path.includes('/ui/') || node.file_path.includes('frontend')) return 'Presentation';
        if (node.file_path.includes('config')) return 'Config';
        return 'Domain';
    }

    function getPhase(node) {
        const kind = (node.kind || '').toLowerCase();
        if (kind.includes('data') || kind.includes('entity') || kind.includes('schema')) return 'DATA';
        if (kind.includes('function') || kind.includes('logic')) return 'LOGIC';
        if (kind.includes('module') || kind.includes('package')) return 'ORGANIZATION';
        if (kind.includes('script') || kind.includes('main')) return 'EXECUTION';
        return 'LOGIC';
    }

    function getFileType(node) {
        const p = node.file_path || node.id || '';
        const ext = p.split('.').pop().toLowerCase();
        return ext || 'unknown';
    }

    function getRoleCategory(node) {
        const r = (node.role || '').toLowerCase();
        if (r.includes('service') || r.includes('manager')) return 'Orchestration';
        if (r.includes('repo') || r.includes('store')) return 'Storage';
        if (r.includes('controller') || r.includes('handler')) return 'Ingress';
        if (r.includes('util') || r.includes('helper')) return 'Utility';
        return 'Unknown';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR APPLICATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeColors(nodes) {
        const DM = window.DM;
        const fileBoundaries = DM ? DM.getFileBoundaries() : [];
        nodes.forEach(node => {
            if (node && node.isFileNode) {
                if (!node.color) {
                    const totalFiles = fileBoundaries.length;
                    const fileInfo = fileBoundaries[node.fileIdx] || {};
                    const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                    node.color = window.getFileColor(node.fileIdx, totalFiles, fileLabel);
                }
                return;
            }
            if (window.fileMode) {
                return;
            }
            node.color = getNodeColorByMode(node);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SIZE MODE
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeSizeMode(mode) {
        const Graph = window.Graph;
        if (!Graph) return;
        const scale = window.APPEARANCE_STATE?.nodeScale || 1;
        switch (mode) {
            case 'uniform':
                Graph.nodeVal(() => 1 * scale);
                break;
            case 'degree':
                Graph.nodeVal(n => Math.max(1, ((n.in_degree || 0) + (n.out_degree || 0)) * 0.5) * scale);
                break;
            case 'fanout':
                Graph.nodeVal(n => (n.val || n.fanout || 1) * scale);
                break;
            case 'complexity':
                Graph.nodeVal(n => Math.max(1, (n.complexity || n.loc || 10) * 0.05) * scale);
                break;
            default:
                Graph.nodeVal(n => (n.val || 1) * scale);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER/DEPTH/SIMILARITY HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNodeTierValue(node) {
        if (!node) return 1;
        const tier = window.getNodeTier(node);
        if (tier === 'T0') return 0;
        if (tier === 'T1') return 1;
        if (tier === 'T2') return 2;
        return 1;
    }

    function getNodeDepth(node) {
        if (node && typeof node.y === 'number') {
            return Math.abs(node.y) / 500;
        }
        return 0.5;
    }

    function getSemanticSimilarity(srcNode, tgtNode) {
        if (!srcNode || !tgtNode) return 0.5;
        let score = 0;
        if (srcNode.type === tgtNode.type) score += 0.4;
        if (srcNode.fileIdx === tgtNode.fileIdx) score += 0.3;
        if (window.getNodeTier(srcNode) === window.getNodeTier(tgtNode)) score += 0.2;
        if (srcNode.ring === tgtNode.ring) score += 0.1;
        return score;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER GROUPING
    // ═══════════════════════════════════════════════════════════════════════

    function groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = window.getNodeTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getColorByMode: getNodeColorByMode,
        getSubsystem: getSubsystem,
        getPhase: getPhase,
        getFileType: getFileType,
        getRoleCategory: getRoleCategory,
        applyColors: applyNodeColors,
        applySizeMode: applyNodeSizeMode,
        getTierValue: getNodeTierValue,
        getDepth: getNodeDepth,
        getSemanticSimilarity: getSemanticSimilarity,
        groupByTier: groupNodesByTier
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getNodeColorByMode = NODE_HELPERS.getColorByMode;
window.getSubsystem = NODE_HELPERS.getSubsystem;
window.getPhase = NODE_HELPERS.getPhase;
window.getFileType = NODE_HELPERS.getFileType;
window.getRoleCategory = NODE_HELPERS.getRoleCategory;
window.applyNodeColors = NODE_HELPERS.applyColors;
window.applyNodeSizeMode = NODE_HELPERS.applySizeMode;
window.getNodeTierValue = NODE_HELPERS.getTierValue;
window.getNodeDepth = NODE_HELPERS.getDepth;
window.getSemanticSimilarity = NODE_HELPERS.getSemanticSimilarity;
window.groupNodesByTier = NODE_HELPERS.groupByTier;

console.log('[Module] NODE_HELPERS loaded - 11 functions');


// ═══ MODULE: modules/color-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * COLOR-HELPERS MODULE - Color utilities and conversions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Topology colors, color normalization, file hue generation.
 * Depends on: UTILS (parseOklchString, hashToUnit, clampValue), COLOR (oklchColor)
 *
 * @module COLOR_HELPERS
 * @version 1.0.0
 */

window.COLOR_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // TOPOLOGY COLOR LOOKUP
    // ═══════════════════════════════════════════════════════════════════════

    function getTopoColor(category, key) {
        const APPEARANCE_CONFIG = window.APPEARANCE_CONFIG;
        if (!APPEARANCE_CONFIG || !APPEARANCE_CONFIG.color) return { l: 50, c: 0, h: 0 };

        let tokenKey = key;
        let section = 'atom-family'; // Default

        // Map legacy/UI keys to Token keys
        if (category === 'tiers') {
            section = 'atom';
            if (key === 'T0') tokenKey = 't0-core';
            else if (key === 'T1') tokenKey = 't1-arch';
            else if (key === 'T2') tokenKey = 't2-eco';
            else if (key === 'UNKNOWN') tokenKey = 'unknown';
        } else if (category === 'rings') {
            section = 'ring';
            if (key === 'KERNEL') tokenKey = 'DOMAIN';
            if (key === 'CORE') tokenKey = 'APPLICATION';
            if (key === 'SERVICE') tokenKey = 'PRESENTATION';
            if (key === 'ADAPTER') tokenKey = 'INTERFACE';
        } else if (category === 'families') {
            section = 'atom-family';
        }

        // Lookup token
        const tokenStr = APPEARANCE_CONFIG.color[section]?.[tokenKey] || APPEARANCE_CONFIG.color[section]?.['UNKNOWN'];

        // Parse OKLCH
        const parsed = window.parseOklchString(tokenStr);
        if (!parsed) return { l: 50, c: 0, h: 0 }; // Fallback gray

        // Normalize to internal l,c,h format (lowercase)
        return { l: parsed.L * 100, c: parsed.C, h: parsed.H };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLOR NORMALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeColorInput(color, fallback = 'rgb(128, 128, 128)') {
        if (color === null || color === undefined) {
            return fallback;
        }
        if (typeof color !== 'string') {
            return color;
        }
        const parsed = window.parseOklchString(color);
        if (parsed) {
            return window.oklchColor(parsed.L, parsed.C, parsed.H, parsed.A);
        }
        return color;
    }

    function toColorNumber(color, fallback = '#777777') {
        // Returns CSS hex string (polished-compatible) instead of JS hex int
        if (typeof color === 'number') {
            return '#' + color.toString(16).padStart(6, '0');
        }
        if (typeof color !== 'string') {
            return fallback;
        }
        const normalized = normalizeColorInput(color);
        if (typeof normalized === 'string') {
            color = normalized;
        }
        if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl')) {
            return color;  // Already valid CSS color
        }
        try {
            const hex = new THREE.Color(color).getHex();
            return '#' + hex.toString(16).padStart(6, '0');
        } catch (err) {
            return fallback;
        }
    }

    function dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILE COLOR GENERATION
    // ═══════════════════════════════════════════════════════════════════════

    function getFileHue(fileIdx, totalFiles, fileName) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const strategy = FILE_COLOR_CONFIG.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return window.hashToUnit(seed) * 360;
        }
        const angle = FILE_COLOR_CONFIG.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const COLOR_TWEAKS = window.COLOR_TWEAKS || {};
        const saturation = FILE_COLOR_CONFIG.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (FILE_COLOR_CONFIG.lightness ?? 50);
        const hue = getFileHue(fileIdx, totalFiles, fileName);
        if (typeof FILE_COLOR_CONFIG.chroma === 'number') {
            return window.oklchColor(lightness, FILE_COLOR_CONFIG.chroma, hue);
        }
        const adjustedHue = hue + (COLOR_TWEAKS.hueShift || 0);
        const adjustedLightness = window.clampValue(lightness + (COLOR_TWEAKS.lightnessShift || 0), 0, 100);
        return `hsl(${adjustedHue}, ${saturation}%, ${adjustedLightness}%)`;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getTopoColor: getTopoColor,
        normalizeInput: normalizeColorInput,
        toNumber: toColorNumber,
        dim: dimColor,
        getFileHue: getFileHue,
        getFileColor: getFileColor
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getTopoColor = COLOR_HELPERS.getTopoColor;
window.normalizeColorInput = COLOR_HELPERS.normalizeInput;
window.toColorNumber = COLOR_HELPERS.toNumber;
window.dimColor = COLOR_HELPERS.dim;
window.getFileHue = COLOR_HELPERS.getFileHue;
window.getFileColor = COLOR_HELPERS.getFileColor;

console.log('[Module] COLOR_HELPERS loaded - 6 functions');


// ═══ MODULE: modules/color-engine.js ═══
/**
 * COLOR ENGINE MODULE
 *
 * Centralized Color Intelligence System using OKLCH color space.
 * Single source of truth for ALL colors in the visualization.
 * Everything reads from here. OKLCH transforms apply here.
 *
 * Usage:
 *   COLOR.get('tier', 'T0')              // Get hex color for tier T0
 *   COLOR.getInterval('markov', 0.5)     // Get interpolated color
 *   COLOR.setTransform('hueShift', 30)   // Shift all hues by 30 degrees
 *   COLOR.subscribe(callback)            // React to transform changes
 */

const COLOR = (function () {
    'use strict';

    // =========================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =========================================================================

    const palette = {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        atom: {
            // Function-like (Green-Cyan)
            'function': { h: 160, c: 0.20, l: 0.65, label: 'Function', semantic: 'logic' },
            'method': { h: 175, c: 0.20, l: 0.62, label: 'Method', semantic: 'logic' },
            'closure': { h: 190, c: 0.20, l: 0.60, label: 'Closure', semantic: 'logic' },
            // Class-like (Blue-Purple)
            'class': { h: 260, c: 0.22, l: 0.60, label: 'Class', semantic: 'structure' },
            'interface': { h: 280, c: 0.20, l: 0.65, label: 'Interface', semantic: 'abstraction' },
            'struct': { h: 240, c: 0.20, l: 0.60, label: 'Struct', semantic: 'data' },
            // Module/Package (Orange-Yellow)
            'module': { h: 45, c: 0.22, l: 0.70, label: 'Module', semantic: 'container' },
            'package': { h: 30, c: 0.24, l: 0.65, label: 'Package', semantic: 'container' },
            // Variables/Fields (Pink-Red)
            'variable': { h: 340, c: 0.18, l: 0.65, label: 'Variable', semantic: 'state' },
            'field': { h: 350, c: 0.18, l: 0.62, label: 'Field', semantic: 'state' },
            // Unknown
            'unknown': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        roleCategory: {
            'Query': { h: 190, c: 0.20, l: 0.65, label: 'Query', semantic: 'read' },         // Cyan
            'Command': { h: 25, c: 0.24, l: 0.60, label: 'Command', semantic: 'write' },     // Orange/Red
            'Factory': { h: 280, c: 0.22, l: 0.60, label: 'Factory', semantic: 'create' },   // Purple
            'Storage': { h: 140, c: 0.20, l: 0.65, label: 'Storage', semantic: 'persist' },  // Green
            'Orchestration': { h: 240, c: 0.22, l: 0.60, label: 'Orchestration', semantic: 'manage' }, // Blue
            'Validation': { h: 45, c: 0.24, l: 0.70, label: 'Validation', semantic: 'check' }, // Yellow
            'Transform': { h: 320, c: 0.20, l: 0.60, label: 'Transform', semantic: 'change' }, // Pink
            'Event': { h: 260, c: 0.22, l: 0.65, label: 'Event', semantic: 'async' },        // Violet
            'Utility': { h: 200, c: 0.10, l: 0.70, label: 'Utility', semantic: 'helper' },   // Light Blue
            'Internal': { h: 0, c: 0.00, l: 0.60, label: 'Internal', semantic: 'private' },  // Gray
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        subsystem: {
            'Ingress': { h: 220, c: 0.24, l: 0.60, label: 'Ingress', semantic: 'entry' },
            'Egress': { h: 20, c: 0.24, l: 0.60, label: 'Egress', semantic: 'exit' },
            'Domain': { h: 260, c: 0.24, l: 0.55, label: 'Domain Core', semantic: 'core' },
            'Persistence': { h: 142, c: 0.22, l: 0.65, label: 'Persistence', semantic: 'store' },
            'Async': { h: 300, c: 0.22, l: 0.60, label: 'Async', semantic: 'bg' },
            'Presentation': { h: 190, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'ui' },
            'Security': { h: 0, c: 0.26, l: 0.55, label: 'Security', semantic: 'guard' },
            'Observability': { h: 60, c: 0.22, l: 0.75, label: 'Observability', semantic: 'monitor' },
            'Config': { h: 290, c: 0.18, l: 0.65, label: 'config', semantic: 'setup' },
            'Delivery': { h: 30, c: 0.20, l: 0.70, label: 'Delivery', semantic: 'ops' },
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        phase: {
            'DATA': { h: 142, c: 0.22, l: 0.65, label: 'Data', semantic: 'structure' },
            'LOGIC': { h: 240, c: 0.24, l: 0.60, label: 'Logic', semantic: 'flow' },
            'ORGANIZATION': { h: 280, c: 0.22, l: 0.60, label: 'Organization', semantic: 'arch' },
            'EXECUTION': { h: 20, c: 0.26, l: 0.60, label: 'Execution', semantic: 'run' }
        },
        state: {
            'Stateless': { h: 220, c: 0.20, l: 0.70, label: 'Stateless', semantic: 'pure' }, // Light Blue
            'Stateful': { h: 20, c: 0.24, l: 0.60, label: 'Stateful', semantic: 'impure' }   // Orange
        },
        effect: {
            'Pure': { h: 142, c: 0.22, l: 0.70, label: 'Pure', semantic: 'safe' },          // Green
            'SideEffect': { h: 340, c: 0.22, l: 0.60, label: 'Side Effect', semantic: 'risk' } // Pink/Red
        },
        visibility: {
            'Public': { h: 220, c: 0.20, l: 0.65, label: 'Public', semantic: 'open' },
            'Private': { h: 0, c: 0.05, l: 0.55, label: 'Private', semantic: 'closed' },
            'Internal': { h: 280, c: 0.15, l: 0.60, label: 'Internal', semantic: 'module' }
        },
        fileType: {
            'js': { h: 60, c: 0.24, l: 0.70, label: 'JavaScript', semantic: 'code' },    // Yellow
            'ts': { h: 240, c: 0.22, l: 0.60, label: 'TypeScript', semantic: 'code' },    // Blue
            'py': { h: 220, c: 0.20, l: 0.62, label: 'Python', semantic: 'code' },        // Blue
            'go': { h: 190, c: 0.22, l: 0.68, label: 'Go', semantic: 'code' },            // Cyan
            'rs': { h: 30, c: 0.24, l: 0.60, label: 'Rust', semantic: 'code' },           // Orange
            'java': { h: 40, c: 0.24, l: 0.62, label: 'Java', semantic: 'code' },         // Orange/Red
            'c': { h: 210, c: 0.18, l: 0.60, label: 'C', semantic: 'code' },             // Blue
            'cpp': { h: 210, c: 0.20, l: 0.55, label: 'C++', semantic: 'code' },          // Blue
            'h': { h: 280, c: 0.16, l: 0.60, label: 'Header', semantic: 'code' },         // Purple
            'html': { h: 20, c: 0.25, l: 0.60, label: 'HTML', semantic: 'markup' },       // Orange
            'css': { h: 230, c: 0.24, l: 0.60, label: 'CSS', semantic: 'style' },         // Blue
            'json': { h: 60, c: 0.18, l: 0.75, label: 'JSON', semantic: 'data' },         // Yellow
            'yaml': { h: 300, c: 0.18, l: 0.65, label: 'YAML', semantic: 'config' },      // Magenta
            'md': { h: 0, c: 0.04, l: 0.70, label: 'Markdown', semantic: 'doc' },         // Gray
            'unknown': { h: 0, c: 0.02, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    };

    // =========================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =========================================================================

    const transform = {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    };

    // =========================================================================
    // INTERVAL MAPPINGS: For numeric data -> color gradients
    // =========================================================================

    const intervals = {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        },
        complexity: {
            stops: [
                { value: 0.0, h: 142, c: 0.18, l: 0.70 },  // Low complexity (0) - Green
                { value: 0.3, h: 100, c: 0.18, l: 0.75 },  // Moderate (5-10) - Yellow-Green
                { value: 0.6, h: 50, c: 0.20, l: 0.70 },   // High (10-20) - Orange
                { value: 1.0, h: 15, c: 0.24, l: 0.60 }    // Very High (20+) - Red
            ]
        },
        churn: {
            stops: [
                { value: 0.0, h: 230, c: 0.10, l: 0.45 },  // Stale/Cold - Blue
                { value: 0.5, h: 300, c: 0.14, l: 0.60 },  // Active - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // Hot - Orange/Red
            ]
        },
        loc: {
            stops: [
                { value: 0.0, h: 200, c: 0.10, l: 0.75 },  // Small - Light Blue
                { value: 0.3, h: 240, c: 0.18, l: 0.60 },  // Medium - Blue
                { value: 0.7, h: 280, c: 0.20, l: 0.50 },  // Large - Purple
                { value: 1.0, h: 320, c: 0.22, l: 0.40 }   // Massive - Dark Purple
            ]
        },
        trust: {
            stops: [
                { value: 0.0, h: 0, c: 0.24, l: 0.50 },    // Untrusted - Red
                { value: 0.5, h: 60, c: 0.20, l: 0.70 },   // Warning - Yellow
                { value: 1.0, h: 142, c: 0.22, l: 0.65 }   // Trusted - Green
            ]
        },
        responsibility: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Single Purpose (1) - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.75 },   // Moderate (5) - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // God Object (9) - Red
            ]
        },
        purity: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Pure (1) - Green
                { value: 0.5, h: 220, c: 0.18, l: 0.65 },  // Mixed (5) - Blue
                { value: 1.0, h: 320, c: 0.24, l: 0.55 }   // I/O Heavy (9) - Purple/Red
            ]
        },
        boundary_score: {
            stops: [
                { value: 0.0, h: 240, c: 0.15, l: 0.65 },  // Internal (1) - Blue
                { value: 0.5, h: 280, c: 0.18, l: 0.60 },  // Module (5) - Purple
                { value: 1.0, h: 20, c: 0.24, l: 0.60 }    // External API (9) - Orange
            ]
        },
        lifecycle_score: {
            stops: [
                { value: 0.0, h: 180, c: 0.15, l: 0.70 },  // Ephemeral (1) - Cyan
                { value: 0.5, h: 220, c: 0.18, l: 0.60 },  // Managed (5) - Blue
                { value: 1.0, h: 280, c: 0.22, l: 0.50 }   // Singleton (9) - Purple
            ]
        },
        centrality: {
            stops: [
                { value: 0.0, h: 240, c: 0.05, l: 0.40 },  // Periphery - Gray/Blue
                { value: 0.5, h: 280, c: 0.20, l: 0.60 },  // Bridge - Purple
                { value: 1.0, h: 340, c: 0.25, l: 0.65 }   // Core - Pink/Red
            ]
        },
        fan_in: {
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.65 },  // Low - Blue
                { value: 0.5, h: 300, c: 0.18, l: 0.60 },  // Med - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // High - Orange
            ]
        },
        fan_out: {
            stops: [
                { value: 0.0, h: 142, c: 0.15, l: 0.65 },  // Low - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.70 },   // Med - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // High - Red
            ]
        }
    };

    // =========================================================================
    // SCHEME PATHS: 33 Named Color Gradients (OKLCH 3D Paths)
    // Each scheme is a path through OKLCH color space mapping normalized values to colors
    // =========================================================================

    const schemePaths = {
        // =====================================================================
        // PART A: FAMOUS SCIENTIFIC GRADIENTS (15 schemes)
        // Source: matplotlib/viridis family - perceptually uniform
        // =====================================================================

        // === SEQUENTIAL (monotonic lightness) ===
        viridis: {
            name: 'Viridis',
            semantic: 'The gold standard - blue→green→yellow',
            stops: [
                { value: 0.0, h: 280, c: 0.12, l: 0.25 },  // Dark purple
                { value: 0.25, h: 240, c: 0.16, l: 0.40 }, // Blue
                { value: 0.5, h: 170, c: 0.18, l: 0.55 },  // Teal
                { value: 0.75, h: 120, c: 0.20, l: 0.70 }, // Green
                { value: 1.0, h: 65, c: 0.22, l: 0.90 }    // Yellow
            ]
        },
        plasma: {
            name: 'Plasma',
            semantic: 'Purple→pink→orange→yellow arc',
            stops: [
                { value: 0.0, h: 280, c: 0.15, l: 0.20 },  // Deep purple
                { value: 0.25, h: 300, c: 0.22, l: 0.40 }, // Magenta
                { value: 0.5, h: 340, c: 0.25, l: 0.55 },  // Pink-red
                { value: 0.75, h: 30, c: 0.28, l: 0.72 },  // Orange
                { value: 1.0, h: 60, c: 0.24, l: 0.92 }    // Bright yellow
            ]
        },
        magma: {
            name: 'Magma',
            semantic: 'Black→purple→orange→white (lava)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.08 },  // Near black
                { value: 0.25, h: 300, c: 0.18, l: 0.30 }, // Deep purple
                { value: 0.5, h: 340, c: 0.24, l: 0.50 },  // Magenta
                { value: 0.75, h: 30, c: 0.26, l: 0.75 },  // Orange
                { value: 1.0, h: 60, c: 0.08, l: 0.98 }    // Near white
            ]
        },
        inferno: {
            name: 'Inferno',
            semantic: 'Black→purple→red→yellow (fire)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.05 },  // Black
                { value: 0.2, h: 300, c: 0.16, l: 0.25 },  // Purple
                { value: 0.4, h: 350, c: 0.24, l: 0.45 },  // Red-purple
                { value: 0.6, h: 20, c: 0.28, l: 0.60 },   // Red-orange
                { value: 0.8, h: 50, c: 0.26, l: 0.78 },   // Orange-yellow
                { value: 1.0, h: 65, c: 0.18, l: 0.95 }    // Bright yellow
            ]
        },
        cividis: {
            name: 'Cividis',
            semantic: 'Blue→yellow (colorblind optimized)',
            stops: [
                { value: 0.0, h: 240, c: 0.10, l: 0.25 },  // Dark blue
                { value: 0.33, h: 220, c: 0.08, l: 0.45 }, // Steel blue
                { value: 0.66, h: 80, c: 0.08, l: 0.65 },  // Olive
                { value: 1.0, h: 60, c: 0.14, l: 0.88 }    // Yellow
            ]
        },
        turbo: {
            name: 'Turbo',
            semantic: 'Improved rainbow (no banding)',
            stops: [
                { value: 0.0, h: 260, c: 0.18, l: 0.35 },  // Blue-purple
                { value: 0.2, h: 210, c: 0.22, l: 0.55 },  // Cyan-blue
                { value: 0.4, h: 150, c: 0.24, l: 0.65 },  // Green
                { value: 0.6, h: 60, c: 0.26, l: 0.75 },   // Yellow
                { value: 0.8, h: 30, c: 0.28, l: 0.65 },   // Orange
                { value: 1.0, h: 0, c: 0.24, l: 0.50 }     // Red
            ]
        },
        mako: {
            name: 'Mako',
            semantic: 'Deep ocean blue→teal',
            stops: [
                { value: 0.0, h: 260, c: 0.08, l: 0.12 },  // Abyss
                { value: 0.33, h: 240, c: 0.14, l: 0.35 }, // Deep blue
                { value: 0.66, h: 200, c: 0.18, l: 0.58 }, // Ocean blue
                { value: 1.0, h: 170, c: 0.16, l: 0.82 }   // Light teal
            ]
        },
        rocket: {
            name: 'Rocket',
            semantic: 'Dark→red→white (heat)',
            stops: [
                { value: 0.0, h: 280, c: 0.06, l: 0.10 },  // Dark
                { value: 0.33, h: 340, c: 0.20, l: 0.35 }, // Purple-red
                { value: 0.66, h: 15, c: 0.26, l: 0.60 },  // Red-orange
                { value: 1.0, h: 30, c: 0.08, l: 0.95 }    // Near white
            ]
        },

        // === DIVERGING (center-outward) ===
        coolwarm: {
            name: 'Coolwarm',
            semantic: 'Blue↔neutral↔red (diverging)',
            stops: [
                { value: 0.0, h: 230, c: 0.22, l: 0.45 },  // Cool blue
                { value: 0.25, h: 220, c: 0.12, l: 0.60 }, // Light blue
                { value: 0.5, h: 0, c: 0.02, l: 0.75 },    // Neutral gray
                { value: 0.75, h: 20, c: 0.14, l: 0.60 },  // Light red
                { value: 1.0, h: 15, c: 0.24, l: 0.45 }    // Warm red
            ]
        },
        spectral: {
            name: 'Spectral',
            semantic: 'Full rainbow diverging',
            stops: [
                { value: 0.0, h: 10, c: 0.22, l: 0.50 },   // Red
                { value: 0.25, h: 40, c: 0.24, l: 0.70 },  // Orange-yellow
                { value: 0.5, h: 60, c: 0.20, l: 0.85 },   // Yellow (center)
                { value: 0.75, h: 140, c: 0.20, l: 0.65 }, // Green
                { value: 1.0, h: 240, c: 0.18, l: 0.50 }   // Blue
            ]
        },

        // === APPLICATION-SPECIFIC ===
        thermal: {
            name: 'Thermal',
            semantic: 'Cold→hot temperature map',
            stops: [
                { value: 0.0, h: 240, c: 0.18, l: 0.30 },  // Cold blue
                { value: 0.25, h: 200, c: 0.20, l: 0.45 }, // Cool cyan
                { value: 0.5, h: 60, c: 0.22, l: 0.65 },   // Warm yellow
                { value: 0.75, h: 30, c: 0.26, l: 0.58 },  // Hot orange
                { value: 1.0, h: 0, c: 0.28, l: 0.50 }     // Burning red
            ]
        },
        nightvision: {
            name: 'Night Vision',
            semantic: 'Phosphor green display',
            stops: [
                { value: 0.0, h: 140, c: 0.02, l: 0.05 },  // Black
                { value: 0.33, h: 140, c: 0.12, l: 0.25 }, // Dark green
                { value: 0.66, h: 130, c: 0.22, l: 0.55 }, // Bright green
                { value: 1.0, h: 120, c: 0.28, l: 0.85 }   // Glowing green
            ]
        },
        ocean: {
            name: 'Ocean',
            semantic: 'Bathymetry depth map',
            stops: [
                { value: 0.0, h: 250, c: 0.12, l: 0.15 },  // Abyss
                { value: 0.33, h: 230, c: 0.18, l: 0.35 }, // Deep
                { value: 0.66, h: 200, c: 0.20, l: 0.55 }, // Mid-depth
                { value: 1.0, h: 180, c: 0.16, l: 0.80 }   // Shallow
            ]
        },
        terrain: {
            name: 'Terrain',
            semantic: 'Water→land→mountain',
            stops: [
                { value: 0.0, h: 220, c: 0.16, l: 0.40 },  // Water blue
                { value: 0.3, h: 140, c: 0.18, l: 0.55 },  // Lowland green
                { value: 0.5, h: 80, c: 0.16, l: 0.60 },   // Plains yellow-green
                { value: 0.7, h: 40, c: 0.14, l: 0.50 },   // Hills brown
                { value: 1.0, h: 0, c: 0.04, l: 0.90 }     // Snow white
            ]
        },
        electric: {
            name: 'Electric',
            semantic: 'Neon cyberpunk glow',
            stops: [
                { value: 0.0, h: 280, c: 0.25, l: 0.30 },  // Deep purple
                { value: 0.33, h: 320, c: 0.30, l: 0.50 }, // Hot pink
                { value: 0.66, h: 190, c: 0.28, l: 0.65 }, // Electric cyan
                { value: 1.0, h: 60, c: 0.26, l: 0.85 }    // Neon yellow
            ]
        },

        // =====================================================================
        // PART B: ROLE-SEMANTIC GRADIENTS (18 schemes)
        // Named after canonical roles with meaningful color journeys
        // =====================================================================

        // === GROUP 1: QUERIES & ACCESS (Cool blues/cyans - passive reads) ===
        query: {
            name: 'Query',
            semantic: 'Retrieve data calmly',
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },  // Deep blue - start
                { value: 0.5, h: 200, c: 0.15, l: 0.55 },  // Sky blue - middle
                { value: 1.0, h: 190, c: 0.20, l: 0.70 }   // Light cyan - found
            ]
        },
        finder: {
            name: 'Finder',
            semantic: 'Search and seek',
            stops: [
                { value: 0.0, h: 200, c: 0.05, l: 0.35 },  // Dim - searching
                { value: 0.3, h: 180, c: 0.12, l: 0.50 },  // Teal - hunting
                { value: 0.7, h: 160, c: 0.18, l: 0.65 },  // Cyan-green - close
                { value: 1.0, h: 140, c: 0.24, l: 0.75 }   // Bright green - found!
            ]
        },

        // === GROUP 2: COMMANDS & MUTATIONS (Warm - active writes) ===
        command: {
            name: 'Command',
            semantic: 'Execute with authority',
            stops: [
                { value: 0.0, h: 30, c: 0.15, l: 0.45 },   // Amber ready
                { value: 0.5, h: 20, c: 0.22, l: 0.58 },   // Orange active
                { value: 1.0, h: 10, c: 0.28, l: 0.65 }    // Red-orange fired
            ]
        },
        creator: {
            name: 'Creator',
            semantic: 'Bring into existence',
            stops: [
                { value: 0.0, h: 180, c: 0.10, l: 0.40 },  // Seed teal
                { value: 0.4, h: 150, c: 0.18, l: 0.55 },  // Sprout green
                { value: 0.8, h: 120, c: 0.24, l: 0.68 },  // Growth lime
                { value: 1.0, h: 90, c: 0.28, l: 0.75 }    // Full bloom yellow-green
            ]
        },
        destroyer: {
            name: 'Destroyer',
            semantic: 'Remove from existence',
            stops: [
                { value: 0.0, h: 0, c: 0.08, l: 0.60 },    // Pale warning
                { value: 0.4, h: 10, c: 0.18, l: 0.50 },   // Red alert
                { value: 0.7, h: 350, c: 0.26, l: 0.40 },  // Crimson
                { value: 1.0, h: 340, c: 0.20, l: 0.25 }   // Dark destruction
            ]
        },

        // === GROUP 3: FACTORIES (Construction - blue→green) ===
        factory: {
            name: 'Factory',
            semantic: 'Assembly line production',
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.45 },  // Blueprint blue
                { value: 0.3, h: 200, c: 0.16, l: 0.55 },  // Processing
                { value: 0.6, h: 170, c: 0.20, l: 0.62 },  // Assembly
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Product green
            ]
        },

        // === GROUP 4: STORAGE (Solid, grounded - deep blues/purples) ===
        repository: {
            name: 'Repository',
            semantic: 'Deep data vault',
            stops: [
                { value: 0.0, h: 240, c: 0.12, l: 0.30 },  // Database depths
                { value: 0.5, h: 230, c: 0.18, l: 0.45 },  // Data layer
                { value: 1.0, h: 220, c: 0.22, l: 0.60 }   // Accessible
            ]
        },
        cache: {
            name: 'Cache',
            semantic: 'Fast temporary',
            stops: [
                { value: 0.0, h: 300, c: 0.08, l: 0.50 },  // Magenta flash
                { value: 0.5, h: 320, c: 0.16, l: 0.62 },  // Pink speed
                { value: 1.0, h: 340, c: 0.22, l: 0.75 }   // Hot pink hit
            ]
        },

        // === GROUP 5: ORCHESTRATION (Purple/magenta - control flow) ===
        service: {
            name: 'Service',
            semantic: 'Coordinate operations',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Purple quiet
                { value: 0.5, h: 280, c: 0.16, l: 0.55 },  // Active violet
                { value: 1.0, h: 290, c: 0.22, l: 0.68 }   // Bright orchid
            ]
        },
        orchestrator: {
            name: 'Orchestrator',
            semantic: 'See all, conduct all',
            stops: [
                { value: 0.0, h: 200, c: 0.12, l: 0.40 },  // Start blue
                { value: 0.25, h: 270, c: 0.18, l: 0.50 }, // Through purple
                { value: 0.5, h: 330, c: 0.22, l: 0.58 },  // To pink
                { value: 0.75, h: 30, c: 0.24, l: 0.62 },  // Through orange
                { value: 1.0, h: 60, c: 0.26, l: 0.70 }    // End gold (full spectrum)
            ]
        },

        // === GROUP 6: VALIDATION (Yellow/green - pass/fail semantics) ===
        validator: {
            name: 'Validator',
            semantic: 'Check and verify',
            stops: [
                { value: 0.0, h: 0, c: 0.20, l: 0.50 },    // Red fail
                { value: 0.4, h: 45, c: 0.22, l: 0.65 },   // Yellow warning
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Green pass
            ]
        },
        guard: {
            name: 'Guard',
            semantic: 'Protect and defend',
            stops: [
                { value: 0.0, h: 350, c: 0.18, l: 0.40 },  // Dark red blocked
                { value: 0.5, h: 30, c: 0.20, l: 0.55 },   // Orange caution
                { value: 1.0, h: 120, c: 0.22, l: 0.65 }   // Green allowed
            ]
        },

        // === GROUP 7: TRANSFORMATION (Rainbow arc - any to any) ===
        transformer: {
            name: 'Transformer',
            semantic: 'Complete metamorphosis',
            stops: [
                { value: 0.0, h: 220, c: 0.14, l: 0.45 },  // Blue input
                { value: 0.3, h: 280, c: 0.18, l: 0.52 },  // Purple process
                { value: 0.6, h: 340, c: 0.22, l: 0.58 },  // Pink transition
                { value: 1.0, h: 30, c: 0.26, l: 0.65 }    // Orange output
            ]
        },
        parser: {
            name: 'Parser',
            semantic: 'Decode from wire',
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.85 },    // White wire
                { value: 0.5, h: 180, c: 0.10, l: 0.70 },  // Decoding
                { value: 1.0, h: 160, c: 0.20, l: 0.55 }   // Data teal
            ]
        },

        // === GROUP 8: EVENTS (Signals - purple/yellow pulses) ===
        handler: {
            name: 'Handler',
            semantic: 'React to event',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Waiting purple
                { value: 0.5, h: 290, c: 0.18, l: 0.55 },  // Triggered
                { value: 1.0, h: 310, c: 0.26, l: 0.68 }   // Handling pink
            ]
        },
        emitter: {
            name: 'Emitter',
            semantic: 'Broadcast signal',
            stops: [
                { value: 0.0, h: 50, c: 0.18, l: 0.55 },   // Yellow charge
                { value: 0.5, h: 45, c: 0.24, l: 0.68 },   // Bright emit
                { value: 1.0, h: 40, c: 0.30, l: 0.78 }    // Golden broadcast
            ]
        },

        // === GROUP 9: UTILITIES (Neutral supporting - grays/pastels) ===
        utility: {
            name: 'Utility',
            semantic: 'General tool',
            stops: [
                { value: 0.0, h: 220, c: 0.04, l: 0.45 },  // Gray-blue tool
                { value: 0.5, h: 200, c: 0.08, l: 0.58 },  // Soft cyan
                { value: 1.0, h: 180, c: 0.12, l: 0.72 }   // Light teal
            ]
        },
        lifecycle: {
            name: 'Lifecycle',
            semantic: 'Birth to death cycle',
            stops: [
                { value: 0.0, h: 120, c: 0.20, l: 0.65 },  // Birth green
                { value: 0.25, h: 60, c: 0.22, l: 0.70 },  // Youth yellow
                { value: 0.5, h: 30, c: 0.24, l: 0.60 },   // Maturity orange
                { value: 0.75, h: 0, c: 0.20, l: 0.50 },   // Aging red
                { value: 1.0, h: 280, c: 0.10, l: 0.35 }   // Death purple
            ]
        },

        // =====================================================================
        // PART C: OKLCH GEOMETRY GENERATORS (Function-based paths)
        // These use mathematical functions instead of discrete stops.
        // Each has a `generator` function: (t) => { h, c, l }
        // =====================================================================

        // === LOOPS (Full 360° hue cycles) ===
        'rainbow-loop': {
            name: 'Rainbow Loop',
            semantic: 'Full hue circle at constant L/C',
            generator: (t) => ({
                h: t * 360,           // Full hue rotation
                c: 0.20,              // Constant chroma
                l: 0.65               // Constant lightness
            })
        },
        'rainbow-bright': {
            name: 'Rainbow Bright',
            semantic: 'Vivid rainbow with high chroma',
            generator: (t) => ({
                h: t * 360,
                c: 0.28,              // High chroma for vivid colors
                l: 0.70
            })
        },
        'rainbow-dark': {
            name: 'Rainbow Dark',
            semantic: 'Subdued rainbow for dark themes',
            generator: (t) => ({
                h: t * 360,
                c: 0.18,
                l: 0.45               // Lower lightness
            })
        },

        // === ARCS (Partial hue sweeps) ===
        'arc-warm': {
            name: 'Warm Arc',
            semantic: 'Red→Yellow→Orange (warm sector)',
            generator: (t) => ({
                h: 0 + t * 60,        // 0° to 60° (red to yellow)
                c: 0.24,
                l: 0.55 + t * 0.15    // Slight lightness increase
            })
        },
        'arc-cool': {
            name: 'Cool Arc',
            semantic: 'Cyan→Blue→Purple (cool sector)',
            generator: (t) => ({
                h: 180 + t * 100,     // 180° to 280° (cyan to purple)
                c: 0.22,
                l: 0.50 + t * 0.15
            })
        },
        'arc-nature': {
            name: 'Nature Arc',
            semantic: 'Green→Teal→Cyan (nature)',
            generator: (t) => ({
                h: 120 + t * 60,      // 120° to 180° (green to cyan)
                c: 0.20,
                l: 0.60 + t * 0.10
            })
        },

        // === SPIRALS (Hue + varying L or C) ===
        'spiral-up': {
            name: 'Spiral Up',
            semantic: 'Hue rotates as lightness increases',
            generator: (t) => ({
                h: t * 270,           // 3/4 hue rotation
                c: 0.18,
                l: 0.30 + t * 0.55    // Dark to light
            })
        },
        'spiral-down': {
            name: 'Spiral Down',
            semantic: 'Hue rotates as lightness decreases',
            generator: (t) => ({
                h: t * 270,
                c: 0.20,
                l: 0.85 - t * 0.55    // Light to dark
            })
        },
        'spiral-chroma': {
            name: 'Spiral Chroma',
            semantic: 'Hue rotates as saturation increases',
            generator: (t) => ({
                h: t * 360,
                c: 0.06 + t * 0.22,   // Gray to vivid
                l: 0.60
            })
        },

        // === SINUSOIDAL (Wave patterns) ===
        'wave-lightness': {
            name: 'Wave Lightness',
            semantic: 'Sinusoidal lightness oscillation',
            generator: (t) => ({
                h: t * 180,           // Half hue rotation
                c: 0.20,
                l: 0.50 + Math.sin(t * Math.PI * 2) * 0.20  // Wave between 0.30 and 0.70
            })
        },
        'wave-chroma': {
            name: 'Wave Chroma',
            semantic: 'Sinusoidal saturation oscillation',
            generator: (t) => ({
                h: t * 180,
                c: 0.15 + Math.sin(t * Math.PI * 2) * 0.12, // Wave between 0.03 and 0.27
                l: 0.60
            })
        },
        'pulse': {
            name: 'Pulse',
            semantic: 'Both L and C oscillate together',
            generator: (t) => {
                const wave = Math.sin(t * Math.PI * 3); // 1.5 full waves
                return {
                    h: t * 120,       // Partial hue sweep
                    c: 0.15 + wave * 0.10,
                    l: 0.55 + wave * 0.15
                };
            }
        },

        // === LINEAR RAMPS (Simple mathematical paths) ===
        'ramp-hue': {
            name: 'Hue Ramp',
            semantic: 'Pure hue change, constant L/C',
            generator: (t) => ({
                h: 220 + t * 140,     // Blue to pink (220° to 360°)
                c: 0.22,
                l: 0.60
            })
        },
        'ramp-lightness': {
            name: 'Lightness Ramp',
            semantic: 'Dark to light, constant H/C',
            generator: (t) => ({
                h: 220,               // Fixed blue
                c: 0.18,
                l: 0.25 + t * 0.60    // 0.25 to 0.85
            })
        },
        'ramp-chroma': {
            name: 'Chroma Ramp',
            semantic: 'Gray to vivid, constant H/L',
            generator: (t) => ({
                h: 280,               // Fixed purple
                c: 0.02 + t * 0.26,   // 0.02 to 0.28
                l: 0.60
            })
        },

        // === SPECIAL GEOMETRIC PATHS ===
        'helix': {
            name: 'Helix',
            semantic: 'Full 3D path through OKLCH cylinder',
            generator: (t) => ({
                h: t * 540,           // 1.5 hue rotations
                c: 0.10 + t * 0.15,   // Increasing chroma
                l: 0.30 + t * 0.50    // Rising lightness
            })
        },
        'convergent': {
            name: 'Convergent',
            semantic: 'Colors converge toward gray',
            generator: (t) => ({
                h: t * 180,           // Half rotation
                c: 0.26 * (1 - t),    // Chroma decreases to 0
                l: 0.55
            })
        },
        'divergent': {
            name: 'Divergent',
            semantic: 'Colors diverge from gray',
            generator: (t) => ({
                h: 180 + t * 180,     // Second half of hue wheel
                c: 0.26 * t,          // Chroma increases from 0
                l: 0.55
            })
        },
        'bicone': {
            name: 'Bicone',
            semantic: 'Center peak, edges dark (HSL-like)',
            generator: (t) => {
                // Lightness peaks at center, dark at edges
                const l = t < 0.5 ? 0.30 + t * 0.70 : 0.65 - (t - 0.5) * 0.70;
                return {
                    h: t * 360,
                    c: 0.20,
                    l: Math.max(0.30, l)
                };
            }
        }
    };

    // Current active scheme
    let _activeScheme = null;

// =========================================================================
// SUBSCRIBERS: Reactive notifications
// =========================================================================

let _subscribers = [];

function subscribe(callback) {
    _subscribers.push(callback);
    return () => {
        _subscribers = _subscribers.filter(cb => cb !== callback);
    };
}

function _notifySubscribers(event, data) {
    _subscribers.forEach(cb => cb(event, data));
}

// =========================================================================
// OKLCH -> HEX CONVERSION
// =========================================================================

function _toHex(oklch) {
    const { h, c, l } = oklch;

    // Convert OKLCH to approximate RGB
    const hRad = h * Math.PI / 180;
    const a = c * Math.cos(hRad);
    const b = c * Math.sin(hRad);

    // Simplified OKLab to linear RGB (approximate)
    const L = l;
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    const l3 = l_ * l_ * l_;
    const m3 = m_ * m_ * m_;
    const s3 = s_ * s_ * s_;

    let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
    let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
    let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

    // Clamp and convert to sRGB
    const toSRGB = (x) => {
        x = Math.max(0, Math.min(1, x));
        return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
    };

    r = Math.round(toSRGB(r) * 255);
    g = Math.round(toSRGB(g) * 255);
    bl = Math.round(toSRGB(bl) * 255);

    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    bl = Math.max(0, Math.min(255, bl));

    return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
}

function _applyTransform(oklch) {
    const t = transform;

    // Apply transforms
    let h = (oklch.h + t.hueShift + 360) % 360;
    let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
    let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

    // Apply amplifier to chroma for contrast
    if (t.amplifier !== 1) {
        c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
    }

    return _toHex({ h, c, l });
}

// =========================================================================
// CORE API
// =========================================================================

/**
 * Get color with transforms applied
 * @param {string} dimension - Palette dimension (tier, family, ring, layer, edgeType)
 * @param {string} category - Category within dimension
 * @returns {string} Hex color string
 */
function get(dimension, category) {
    const base = palette[dimension]?.[category];
    if (!base) return _toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray
    return _applyTransform(base);
}

/**
 * Get color for a numeric value using interval mapping
 * @param {string} intervalName - Interval name (markov, weight, confidence)
 * @param {number} value - Value (0-1)
 * @returns {string} Hex color string
 */
function getInterval(intervalName, value) {
    const v = Math.max(0, Math.min(1, value));

    // =========================================================================
    // SCHEME OVERRIDE: If an active scheme is selected, use it for ALL intervals
    // This makes the 33 named schemes (viridis, plasma, thermal, etc.) work
    // =========================================================================
    if (_activeScheme && schemePaths[_activeScheme]) {
        return getSchemeColor(_activeScheme, v);
    }

    // Fall back to hardcoded interval if no scheme active
    const interval = intervals[intervalName];
    if (!interval) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const stops = interval.stops;

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const t = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * t,
        c: lower.c + (upper.c - lower.c) * t,
        l: lower.l + (upper.l - lower.l) * t
    };

    return _applyTransform(interpolated);
}

/**
 * Interpolate between two hex colors in OKLCH space
 * @param {string} color1 - Hex color 1
 * @param {string} color2 - Hex color 2
 * @param {number} t - Interpolation factor (0-1)
 * @returns {string} Hex result
 */
function interpolate(color1, color2, t) {
    // We assume input hexes can be approximated back to OKLCH or treated as sRGB->OKLCH
    // For simplicity in this engine which mostly generates from OKLCH, we'll assume
    // specific OKLCH-derived palettes unless provided raw hex.
    // If we really need robust hex->oklch, we need a converter.
    // BUT, for edge gradients in app.js, we often have raw HSL or OKLCH objects.
    // Let's support passing Objects {h,c,l} or hex strings (naive interpolation for hex if needed).
    // Best approach: app.js should use COLOR.get() to get objects if possible, or we expose a helper
    // that takes our internal palette objects.

    // Actually, let's keep it simple: assume app.js will partial refactoring.
    // We will accept object {h,c,l} inputs for maximum precision.
    const c1 = (typeof color1 === 'string') ? parseOklchString(color1) || { h: 0, c: 0, l: 0.5 } : color1;
    const c2 = (typeof color2 === 'string') ? parseOklchString(color2) || { h: 0, c: 0, l: 0.5 } : color2;

    t = Math.max(0, Math.min(1, t));

    // Shortest path hue interpolation
    let h1 = c1.h || c1.H || 0;
    let h2 = c2.h || c2.H || 0;
    let dh = h2 - h1;
    if (Math.abs(dh) > 180) {
        if (dh > 0) h1 += 360;
        else h2 += 360;
    }

    const h = (h1 + (h2 - h1) * t) % 360;
    const c = (c1.c !== undefined ? c1.c : c1.C) + ((c2.c !== undefined ? c2.c : c2.C) - (c1.c !== undefined ? c1.c : c1.C)) * t;
    const l = (c1.l !== undefined ? c1.l : c1.L) + ((c2.l !== undefined ? c2.l : c2.L) - (c1.l !== undefined ? c1.l : c1.L)) * t;

    return _applyTransform({ h, c, l });
}

/**
 * Get raw OKLCH values (for advanced use)
 */
function getRaw(dimension, category) {
    return palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
}

/**
 * Get all categories for a dimension
 */
function getCategories(dimension) {
    return Object.keys(palette[dimension] || {});
}

/**
 * Get label for a category
 */
function getLabel(dimension, category) {
    return palette[dimension]?.[category]?.label || category;
}

// =========================================================================
// TRANSFORM CONTROLS
// =========================================================================

function setTransform(key, value) {
    if (key in transform) {
        transform[key] = value;
        _notifySubscribers('transform-change', { key, value });
    }
}

function setAllTransforms(transforms) {
    Object.assign(transform, transforms);
    _notifySubscribers('transform-change', transforms);
}

function resetTransforms() {
    transform.hueShift = 0;
    transform.chromaScale = 1.0;
    transform.lightnessShift = 0;
    transform.amplifier = 1.0;
    _notifySubscribers('transform-change', transform);
}

function getTransform() {
    return { ...transform };
}

// =========================================================================
// SCHEME API: Named Color Gradients
// =========================================================================

/**
 * List all available scheme names
 * @returns {string[]} Array of scheme names
 */
function listSchemes() {
    return Object.keys(schemePaths);
}

/**
 * Get scheme definition
 * @param {string} schemeName - Name of the scheme
 * @returns {object|null} Scheme definition with name, semantic, and stops
 */
function getScheme(schemeName) {
    return schemePaths[schemeName] || null;
}

/**
 * Get color at position t (0-1) along a scheme path
 * Supports both:
 *   - stops: Array of discrete points (interpolated)
 *   - generator: Function (t) => { h, c, l } (direct mathematical path)
 *
 * @param {string} schemeName - Name of the scheme
 * @param {number} t - Position along path (0-1)
 * @returns {string} Hex color string
 */
function getSchemeColor(schemeName, t) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const v = Math.max(0, Math.min(1, t));

    // GENERATOR MODE: Mathematical function (OKLCH geometry)
    if (scheme.generator && typeof scheme.generator === 'function') {
        const oklch = scheme.generator(v);
        return _applyTransform(oklch);
    }

    // STOPS MODE: Discrete points with interpolation
    const stops = scheme.stops;
    if (!stops || stops.length === 0) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const interp = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * interp,
        c: lower.c + (upper.c - lower.c) * interp,
        l: lower.l + (upper.l - lower.l) * interp
    };

    return _applyTransform(interpolated);
}

/**
 * Apply a scheme as the active color scheme
 * This sets transforms and notifies subscribers
 * @param {string} schemeName - Name of the scheme
 */
function applyScheme(schemeName) {
    // Allow null/undefined to clear the active scheme
    if (!schemeName) {
        _activeScheme = null;
        _notifySubscribers('scheme-change', { scheme: null, definition: null });
        console.log('[COLOR] Cleared active scheme, using default intervals');
        return;
    }

    const scheme = schemePaths[schemeName];
    if (!scheme) {
        console.warn('[COLOR] Unknown scheme:', schemeName);
        return;
    }

    _activeScheme = schemeName;
    _notifySubscribers('scheme-change', { scheme: schemeName, definition: scheme });
    console.log('[COLOR] Applied scheme:', schemeName, '-', scheme.semantic);
}

/**
 * Get the currently active scheme name
 * @returns {string|null} Active scheme name or null
 */
function getActiveScheme() {
    return _activeScheme;
}

/**
 * Generate a CSS gradient string for a scheme (for UI previews)
 * @param {string} schemeName - Name of the scheme
 * @param {string} direction - CSS gradient direction (default: 'to right')
 * @returns {string} CSS linear-gradient string
 */
function getSchemeGradientCSS(schemeName, direction = 'to right') {
    const scheme = schemePaths[schemeName];
    if (!scheme) return 'linear-gradient(to right, #333, #666)';

    const colorStops = scheme.stops.map(stop => {
        const color = _applyTransform(stop);
        const percent = Math.round(stop.value * 100);
        return `${color} ${percent}%`;
    });

    return `linear-gradient(${direction}, ${colorStops.join(', ')})`;
}

/**
 * Get scheme metadata (name, semantic description)
 * @param {string} schemeName - Name of the scheme
 * @returns {object} {name, semantic}
 */
function getSchemeInfo(schemeName) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return { name: schemeName, semantic: 'Unknown' };
    return { name: scheme.name, semantic: scheme.semantic };
}

// =========================================================================
// DEBUG
// =========================================================================

function debug() {
    console.log('[COLOR] Transform state:', transform);
    console.log('[COLOR] Palette dimensions:', Object.keys(palette));
    console.log('[COLOR] Interval mappings:', Object.keys(intervals));
    console.log('[COLOR] Schemes:', Object.keys(schemePaths).length, 'available');
    console.log('[COLOR] Active scheme:', _activeScheme);
}

// =========================================================================
// PUBLIC API
// =========================================================================

return {
    // Core API
    get,
    getInterval,
    getRaw,
    getCategories,
    getLabel,
    interpolate,

    // Transform controls
    setTransform,
    setAllTransforms,
    resetTransforms,
    getTransform,

    // Scheme API (33 named color gradients)
    listSchemes,
    getScheme,
    getSchemeColor,
    applyScheme,
    getActiveScheme,
    getSchemeGradientCSS,
    getSchemeInfo,

    // Subscriptions
    subscribe,

    // Internal access (for migration)
    palette,
    intervals,
    transform,
    schemePaths,

    // Debug
    debug
};
}) ();

// Export to window for global access
window.COLOR = COLOR;

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'ColorOrchestrator', { get: () => COLOR, configurable: true });
Object.defineProperty(window, 'Color', { get: () => COLOR, configurable: true });

console.log('[Module] COLOR loaded - OKLCH color engine with', Object.keys(COLOR.schemePaths || {}).length, 'schemes');


// ═══ MODULE: modules/refresh-throttle.js ═══
/**
 * REFRESH THROTTLE MODULE
 *
 * Prevents excessive Graph.refresh() calls that can cause performance issues.
 * Implements frame-budget-aware throttling at 60fps max.
 *
 * Fixes ARCH-003: Unthrottled Graph.refresh() calls
 *
 * Usage:
 *   REFRESH.throttled()     // Request a throttled refresh
 *   REFRESH.force()         // Force immediate refresh (use sparingly)
 *   REFRESH.stats           // Get refresh statistics
 */

const REFRESH = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        minInterval: 16,      // 60fps max (1000ms / 60 = 16.67ms)
        maxPending: 3,        // Max queued refresh requests before forcing
        logThreshold: 100     // Log warning if more than N refreshes/second
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _pending = false;
    let _lastRefresh = 0;
    let _rafId = null;
    let _pendingCount = 0;

    // Statistics
    let _stats = {
        totalCalls: 0,
        throttledCalls: 0,
        actualRefreshes: 0,
        lastSecondRefreshes: 0,
        currentSecondRefreshes: 0,
        lastSecond: 0
    };

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Request a throttled graph refresh.
     * Multiple calls within the same frame are coalesced into one refresh.
     */
    function throttled() {
        _stats.totalCalls++;
        _pendingCount++;

        // Track calls per second for diagnostics
        const now = performance.now();
        const currentSecond = Math.floor(now / 1000);
        if (currentSecond !== _stats.lastSecond) {
            _stats.lastSecondRefreshes = _stats.currentSecondRefreshes;
            _stats.currentSecondRefreshes = 0;
            _stats.lastSecond = currentSecond;

            // Warn if too many refreshes
            if (_stats.lastSecondRefreshes > CONFIG.logThreshold) {
                console.warn(`[REFRESH] High refresh rate: ${_stats.lastSecondRefreshes}/s`);
            }
        }

        // If already pending, don't queue another
        if (_pending) {
            _stats.throttledCalls++;

            // Force refresh if too many pending
            if (_pendingCount >= CONFIG.maxPending) {
                _doRefresh();
            }
            return;
        }

        // Check if enough time has passed since last refresh
        const elapsed = now - _lastRefresh;
        if (elapsed >= CONFIG.minInterval) {
            // Enough time passed, refresh immediately
            _doRefresh();
        } else {
            // Schedule refresh for next frame
            _pending = true;
            _rafId = requestAnimationFrame(() => {
                _pending = false;
                _doRefresh();
            });
        }
    }

    /**
     * Force an immediate refresh, bypassing throttle.
     * Use sparingly - for critical updates only.
     */
    function force() {
        // Cancel any pending throttled refresh
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _doRefresh();
    }

    /**
     * Internal: Perform the actual refresh
     */
    function _doRefresh() {
        _lastRefresh = performance.now();
        _pendingCount = 0;
        _stats.actualRefreshes++;
        _stats.currentSecondRefreshes++;

        // Call the global Graph.refresh() if available
        if (typeof Graph !== 'undefined' && Graph && Graph.refresh) {
            Graph.refresh();
        }
    }

    /**
     * Cancel any pending refresh
     */
    function cancel() {
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _pendingCount = 0;
    }

    /**
     * Reset statistics
     */
    function resetStats() {
        _stats = {
            totalCalls: 0,
            throttledCalls: 0,
            actualRefreshes: 0,
            lastSecondRefreshes: 0,
            currentSecondRefreshes: 0,
            lastSecond: 0
        };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        throttled,
        force,
        cancel,
        resetStats,

        // Config (read-only access, can be modified via setConfig)
        get config() { return { ...CONFIG }; },
        setConfig(key, value) {
            if (key in CONFIG) {
                CONFIG[key] = value;
            }
        },

        // Statistics
        get stats() {
            return {
                ..._stats,
                throttleRatio: _stats.totalCalls > 0
                    ? (_stats.throttledCalls / _stats.totalCalls * 100).toFixed(1) + '%'
                    : '0%',
                pending: _pending,
                pendingCount: _pendingCount
            };
        },

        // Debug
        debug() {
            console.log('[REFRESH] Stats:', this.stats);
            console.log('[REFRESH] Config:', CONFIG);
        }
    };
})();


// ═══ MODULE: modules/legend-manager.js ═══
/**
 * LEGEND MANAGER MODULE
 *
 * Manages legend data, counts, and visibility for all visualization dimensions.
 * Delegates all color operations to the COLOR module.
 *
 * Depends on: COLOR, NODE
 *
 * Usage:
 *   LEGEND.init(nodes, links)           // Initialize with graph data
 *   LEGEND.getLegendData('tier')        // Get legend items for a dimension
 *   LEGEND.getColor('tier', 'T0')       // Get color (delegates to COLOR)
 *   LEGEND.subscribe(callback)          // React to legend changes
 */

const LEGEND = (function() {
    'use strict';

    // =========================================================================
    // DIMENSION METADATA
    // =========================================================================

    const dimensions = {
        tier: {
            name: 'TIERS',
            icon: '◐',
            extract: (node) => NODE.getTier(node)
        },
        family: {
            name: 'FAMILIES',
            icon: '⬡',
            extract: (node) => NODE.getFamily(node)
        },
        ring: {
            name: 'RINGS',
            icon: '◎',
            extract: (node) => NODE.getRing(node)
        },
        layer: {
            name: 'LAYERS',
            icon: '☰',
            extract: (node) => NODE.getLayer(node).toUpperCase()
        },
        effect: {
            name: 'EFFECTS',
            icon: '⚡',
            extract: (node) => NODE.getEffect(node)
        },
        edgeType: {
            name: 'EDGE TYPES',
            icon: '→',
            extract: (link) => (link.edge_type || link.type || 'unknown').toLowerCase()
        },
        edgeFamily: {
            name: 'EDGE FAMILIES',
            icon: '⇢',
            extract: (link) => (link.family || 'Dependency')
        }
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _counts = {};
    let _subscribers = [];

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Initialize legend with nodes and links data
     */
    function init(nodes, links) {
        _computeCounts(nodes, links);
        return LEGEND;
    }

    /**
     * Compute counts for all dimensions
     */
    function _computeCounts(nodes, links) {
        _counts = {};

        // Node dimensions
        ['tier', 'family', 'ring', 'layer', 'effect'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (nodes || []).forEach(node => {
                const cat = extract(node);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        // Edge dimensions
        ['edgeType', 'edgeFamily'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (links || []).forEach(link => {
                const cat = extract(link);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        console.log('[LEGEND] Counts computed:', Object.keys(_counts));
        _notifySubscribers('counts-updated', _counts);
    }

    /**
     * Get legend data for a dimension
     * Returns array of { id, label, color, count, dimension }
     */
    function getLegendData(dimension) {
        const counts = _counts[dimension] || {};

        return Object.keys(counts)
            .filter(cat => counts[cat] > 0)
            .sort((a, b) => (counts[b] || 0) - (counts[a] || 0))
            .map(cat => ({
                id: cat,
                label: COLOR.getLabel(dimension, cat),
                color: COLOR.get(dimension, cat),
                count: counts[cat] || 0,
                dimension: dimension
            }));
    }

    /**
     * Get color for a dimension/category (delegates to COLOR)
     */
    function getColor(dimension, category) {
        return COLOR.get(dimension, category);
    }

    /**
     * Get counts for a dimension
     */
    function getCounts(dimension) {
        return _counts[dimension] || {};
    }

    /**
     * Get all available dimensions
     */
    function getDimensions() {
        return Object.keys(dimensions);
    }

    /**
     * Get dimension metadata
     */
    function getDimensionMeta(dimension) {
        return dimensions[dimension] || null;
    }

    // =========================================================================
    // SUBSCRIPTIONS
    // =========================================================================

    function subscribe(callback) {
        _subscribers.push(callback);
        return () => {
            _subscribers = _subscribers.filter(cb => cb !== callback);
        };
    }

    function _notifySubscribers(event, data) {
        _subscribers.forEach(cb => cb(event, data));
    }

    // =========================================================================
    // DOM RENDERING
    // =========================================================================

    /**
     * Render a legend section to the DOM
     * @param {string} containerId - DOM container ID
     * @param {string} dimension - Dimension to render (tier, family, etc.)
     * @param {Set} stateSet - Filter state set (items to show)
     * @param {Function} onUpdate - Callback when filter changes
     */
    function renderSection(containerId, dimension, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        const legendData = getLegendData(dimension);
        if (!legendData || legendData.length === 0) return;

        // Build legend items
        legendData.forEach(item => {
            const el = document.createElement('div');
            el.className = 'topo-legend-item' + (stateSet && !stateSet.has(item.id) ? ' filtered' : '');
            el.dataset.category = item.id;
            el.dataset.dimension = dimension;

            // Color swatch
            const swatch = document.createElement('span');
            swatch.className = 'topo-legend-swatch';
            swatch.style.backgroundColor = item.color;

            // Label with count
            const label = document.createElement('span');
            label.className = 'topo-legend-label';
            label.textContent = item.id;

            const count = document.createElement('span');
            count.className = 'topo-legend-count';
            count.textContent = `(${item.count})`;

            el.appendChild(swatch);
            el.appendChild(label);
            el.appendChild(count);

            // Click to toggle filter
            if (stateSet) {
                el.addEventListener('click', () => {
                    if (stateSet.has(item.id)) {
                        stateSet.delete(item.id);
                        el.classList.add('filtered');
                    } else {
                        stateSet.add(item.id);
                        el.classList.remove('filtered');
                    }
                    if (onUpdate) onUpdate();
                });
            }

            container.appendChild(el);
        });

        console.log(`[Legend] Rendered ${dimension}: ${legendData.length} items`);
    }

    /**
     * Render all legend sections
     * @param {Object} filters - VIS_FILTERS object with filter Sets
     * @param {Function} onUpdate - Callback when any filter changes (typically refreshGraph)
     */
    function renderAll(filters, onUpdate) {
        // Render node legends
        renderSection('topo-tiers', 'tier', filters?.tiers, onUpdate);
        renderSection('topo-families', 'family', filters?.families, onUpdate);
        renderSection('topo-rings', 'ring', filters?.rings, onUpdate);
        renderSection('topo-layers', 'layer', filters?.layers, onUpdate);
        renderSection('topo-effects', 'effect', filters?.effects, onUpdate);

        // Render edge legends
        renderSection('topo-edges', 'edgeType', filters?.edges, onUpdate);
        renderSection('topo-edge-families', 'edgeFamily', filters?.edgeFamilies, onUpdate);

        console.log('[Legend] All sections rendered');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        getLegendData,
        getColor,
        getCounts,
        getDimensions,
        getDimensionMeta,
        subscribe,
        renderSection,
        renderAll,

        // Direct access to dimensions (for migration)
        dimensions,

        // Computed counts
        get counts() { return _counts; }
    };
})();

// Backward compatibility - LegendManager class wrapper
class LegendManager {
    constructor() {
        this.dimensions = LEGEND.dimensions;
        this.counts = {};
        this._subscribers = [];
    }

    init(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
        return this;
    }

    _computeCounts(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
    }

    getLegendData(dimension) {
        return LEGEND.getLegendData(dimension);
    }

    getColor(dimension, category) {
        return LEGEND.getColor(dimension, category);
    }

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    }

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    }
}

// Global Legend instance - defined by app.js (not duplicated here to avoid redeclaration)
// Legend is accessed as a global variable provided by app.js

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

// renderLegendSection calls LEGEND.renderSection with Legend (global) as source
window.renderLegendSection = function(containerId, dimension, stateSet, onUpdate) {
    LEGEND.renderSection(containerId, dimension, stateSet, onUpdate);
};

// renderAllLegends uses VIS_FILTERS and refreshGraph from app.js globals
// Includes 100ms debounce to prevent DOM thrashing during rapid updates
let _legendDebounceTimer = null;
window.renderAllLegends = function() {
    if (_legendDebounceTimer) clearTimeout(_legendDebounceTimer);
    _legendDebounceTimer = setTimeout(() => {
        _legendDebounceTimer = null;
        const VIS_FILTERS = window.VIS_FILTERS;
        const refreshGraph = window.refreshGraph;
        if (VIS_FILTERS && refreshGraph) {
            LEGEND.renderAll(VIS_FILTERS, refreshGraph);
        } else {
            console.warn('[Legend] VIS_FILTERS or refreshGraph not available');
        }
    }, 100);
};

console.log('[Module] LEGEND loaded - 10 functions');


// ═══ MODULE: modules/data-manager.js ═══
/**
 * DATA MANAGER MODULE
 *
 * Single gate for ALL data access in the visualization.
 * Replaces direct access to FULL_GRAPH and Graph.graphData().
 * Provides O(1) indexed lookups and cached aggregations.
 *
 * Depends on: NODE, COLOR, LEGEND
 *
 * Usage:
 *   DATA.init(graphData)                // Initialize with payload data
 *   DATA.getNodes()                     // Get all raw nodes
 *   DATA.getNode(id)                    // O(1) node lookup
 *   DATA.getNodesByTier('T0')           // O(1) tier lookup
 *   DATA.getEdgesFrom(nodeId)           // O(1) edge lookup
 *   DATA.getTierCounts()                // Cached aggregation
 */

const DATA = (function() {
    'use strict';

    // =========================================================================
    // RAW DATA (immutable after init)
    // =========================================================================

    const raw = {
        nodes: [],
        links: [],
        fileBoundaries: [],
        markov: {},
        kpis: {},
        meta: {},
        physics: {},
        config: {}
    };

    // =========================================================================
    // ANALYTICS DATA (all Collider sections)
    // =========================================================================

    const analytics = {
        counts: {},
        stats: {},
        coverage: {},
        performance: {},
        classification: {},
        auto_discovery: {},
        ecosystem_discovery: {},
        dependencies: {},
        architecture: {},
        topology: {},
        execution_flow: {},
        data_flow: {},
        knots: {},
        warnings: [],
        recommendations: [],
        theory_completeness: {},
        distributions: {},
        edge_types: {},
        rpbl_profile: {},
        purpose_field: {},
        top_hubs: [],
        orphans_list: [],
        files: [],
        semantics: {},
        llm_enrichment: {},
        brain_download: {},
        ai_insights: null
    };

    // =========================================================================
    // INDEXES (O(1) lookups - built once)
    // =========================================================================

    const index = {
        nodeById: new Map(),           // id -> node
        nodesByTier: new Map(),        // tier -> [nodes]
        nodesByFamily: new Map(),      // family -> [nodes]
        nodesByRing: new Map(),        // ring -> [nodes]
        nodesByLayer: new Map(),       // layer -> [nodes]
        nodesByEffect: new Map(),      // effect -> [nodes]
        nodesByFile: new Map(),        // fileIdx -> [nodes]
        edgesBySource: new Map(),      // nodeId -> [edges from]
        edgesByTarget: new Map(),      // nodeId -> [edges to]
        edgeByKey: new Map(),          // "src|tgt" -> edge
        fileByIndex: new Map(),        // idx -> fileBoundary
        markovBySource: new Map()      // nodeId -> sorted edges by weight
    };

    // =========================================================================
    // CACHED AGGREGATIONS (computed once, invalidated on filter)
    // =========================================================================

    const cache = {
        tierCounts: null,
        familyCounts: null,
        ringCounts: null,
        layerCounts: null,
        effectCounts: null,
        edgeTypeCounts: null,
        edgeFamilyCounts: null,
        edgeRanges: null
    };

    // =========================================================================
    // CURRENT STATE (filtered view)
    // =========================================================================

    const filtered = {
        nodes: [],
        links: []
    };

    // Legend manager instance
    let _legend = null;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function init(data) {
        // Store raw data
        raw.nodes = Array.isArray(data?.nodes) ? data.nodes : [];
        raw.links = Array.isArray(data?.links) ? data.links : [];
        raw.fileBoundaries = Array.isArray(data?.file_boundaries) ? data.file_boundaries : [];
        raw.markov = data?.markov || {};
        raw.kpis = data?.kpis || {};
        raw.meta = data?.meta || {};
        raw.physics = data?.physics || {};
        raw.config = data?.config || {};

        // Store analytics data
        Object.keys(analytics).forEach(key => {
            if (data?.[key] !== undefined) {
                analytics[key] = data[key];
            }
        });

        // Build all indexes
        _buildAllIndexes();

        // Initialize legend
        _legend = new LegendManager();
        _legend.init(raw.nodes, raw.links);

        // Set global Legend reference
        if (typeof Legend !== 'undefined') {
            Legend = _legend;
        }

        console.log('%c[DATA] Initialized', 'color: #4ade80; font-weight: bold',
            `${raw.nodes.length} nodes, ${raw.links.length} edges, ${raw.fileBoundaries.length} files`);

        return DATA;
    }

    // =========================================================================
    // INDEX BUILDING
    // =========================================================================

    function _buildAllIndexes() {
        _buildNodeIndex();
        _buildSemanticIndexes();
        _buildEdgeIndexes();
        _buildFileIndex();
        _buildMarkovIndex();
        _invalidateCache();
    }

    function _buildNodeIndex() {
        index.nodeById.clear();
        for (const node of raw.nodes) {
            if (node?.id) {
                index.nodeById.set(node.id, node);
            }
        }
    }

    function _buildSemanticIndexes() {
        index.nodesByTier.clear();
        index.nodesByFamily.clear();
        index.nodesByRing.clear();
        index.nodesByLayer.clear();
        index.nodesByEffect.clear();
        index.nodesByFile.clear();

        for (const node of raw.nodes) {
            if (!node) continue;

            // Tier index
            const tier = NODE.getTier(node);
            if (!index.nodesByTier.has(tier)) {
                index.nodesByTier.set(tier, []);
            }
            index.nodesByTier.get(tier).push(node);

            // Family index
            const family = NODE.getFamily(node);
            if (!index.nodesByFamily.has(family)) {
                index.nodesByFamily.set(family, []);
            }
            index.nodesByFamily.get(family).push(node);

            // Ring index
            const ring = NODE.getRing(node);
            if (!index.nodesByRing.has(ring)) {
                index.nodesByRing.set(ring, []);
            }
            index.nodesByRing.get(ring).push(node);

            // Layer index
            const layer = NODE.getLayer(node);
            if (!index.nodesByLayer.has(layer)) {
                index.nodesByLayer.set(layer, []);
            }
            index.nodesByLayer.get(layer).push(node);

            // Effect index
            const effect = NODE.getEffect(node);
            if (!index.nodesByEffect.has(effect)) {
                index.nodesByEffect.set(effect, []);
            }
            index.nodesByEffect.get(effect).push(node);

            // File index
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx >= 0) {
                if (!index.nodesByFile.has(fileIdx)) {
                    index.nodesByFile.set(fileIdx, []);
                }
                index.nodesByFile.get(fileIdx).push(node);
            }
        }
    }

    function _buildEdgeIndexes() {
        index.edgesBySource.clear();
        index.edgesByTarget.clear();
        index.edgeByKey.clear();

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');

            if (srcId) {
                if (!index.edgesBySource.has(srcId)) {
                    index.edgesBySource.set(srcId, []);
                }
                index.edgesBySource.get(srcId).push(link);
            }

            if (tgtId) {
                if (!index.edgesByTarget.has(tgtId)) {
                    index.edgesByTarget.set(tgtId, []);
                }
                index.edgesByTarget.get(tgtId).push(link);
            }

            if (srcId && tgtId) {
                index.edgeByKey.set(`${srcId}|${tgtId}`, link);
            }
        }
    }

    function _buildFileIndex() {
        index.fileByIndex.clear();
        for (let i = 0; i < raw.fileBoundaries.length; i++) {
            index.fileByIndex.set(i, raw.fileBoundaries[i]);
        }
    }

    function _buildMarkovIndex() {
        index.markovBySource.clear();
        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const mw = link.markov_weight || 0;
            if (srcId && mw > 0) {
                if (!index.markovBySource.has(srcId)) {
                    index.markovBySource.set(srcId, []);
                }
                index.markovBySource.get(srcId).push(link);
            }
        }
        // Sort each list by markov weight descending
        for (const [, edges] of index.markovBySource) {
            edges.sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0));
        }
    }

    function _invalidateCache() {
        Object.keys(cache).forEach(key => {
            cache[key] = null;
        });
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }

    // =========================================================================
    // RAW DATA ACCESSORS
    // =========================================================================

    function getNodes() { return raw.nodes; }
    function getLinks() { return raw.links; }
    function getFileBoundaries() { return raw.fileBoundaries; }
    function getMarkov() { return raw.markov; }
    function getKpis() { return raw.kpis; }
    function getMeta() { return raw.meta; }
    function getPhysics() { return raw.physics; }
    function getConfig() { return raw.config; }
    function getAnalytics(key) { return analytics[key]; }

    // =========================================================================
    // INDEXED LOOKUPS (O(1))
    // =========================================================================

    function getNode(id) {
        return index.nodeById.get(id) || null;
    }

    function getNodesByTier(tier) {
        return index.nodesByTier.get(tier) || [];
    }

    function getNodesByFamily(family) {
        return index.nodesByFamily.get(family) || [];
    }

    function getNodesByRing(ring) {
        return index.nodesByRing.get(ring) || [];
    }

    function getNodesByLayer(layer) {
        return index.nodesByLayer.get(layer) || [];
    }

    function getNodesByEffect(effect) {
        return index.nodesByEffect.get(effect) || [];
    }

    function getNodesByFile(fileIdx) {
        return index.nodesByFile.get(fileIdx) || [];
    }

    function getEdgesFrom(nodeId) {
        return index.edgesBySource.get(nodeId) || [];
    }

    function getEdgesTo(nodeId) {
        return index.edgesByTarget.get(nodeId) || [];
    }

    function getEdgeBetween(srcId, tgtId) {
        return index.edgeByKey.get(`${srcId}|${tgtId}`) || null;
    }

    function getFile(idx) {
        return index.fileByIndex.get(idx) || null;
    }

    function getTopMarkovEdges(nodeId, k = 5) {
        const edges = index.markovBySource.get(nodeId) || [];
        return edges.slice(0, k);
    }

    function isHighEntropyNode(nodeId) {
        const highEntropy = raw.markov?.high_entropy_nodes || [];
        return highEntropy.some(h => h.node === nodeId);
    }

    // =========================================================================
    // FILTERED DATA
    // =========================================================================

    function setFiltered(nodes, links) {
        filtered.nodes = nodes || [];
        filtered.links = links || [];
    }

    function getVisibleNodes() {
        if (filtered.nodes.length > 0) {
            return filtered.nodes;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().nodes || [])
            : [];
    }

    function getVisibleLinks() {
        if (filtered.links.length > 0) {
            return filtered.links;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().links || [])
            : [];
    }

    // =========================================================================
    // AGGREGATIONS (cached)
    // =========================================================================

    function getTierCounts() {
        if (!cache.tierCounts) {
            cache.tierCounts = new Map();
            for (const [tier, nodes] of index.nodesByTier) {
                cache.tierCounts.set(tier, nodes.length);
            }
        }
        return cache.tierCounts;
    }

    function getFamilyCounts() {
        if (!cache.familyCounts) {
            cache.familyCounts = new Map();
            for (const [family, nodes] of index.nodesByFamily) {
                cache.familyCounts.set(family, nodes.length);
            }
        }
        return cache.familyCounts;
    }

    function getRingCounts() {
        if (!cache.ringCounts) {
            cache.ringCounts = new Map();
            for (const [ring, nodes] of index.nodesByRing) {
                cache.ringCounts.set(ring, nodes.length);
            }
        }
        return cache.ringCounts;
    }

    function getLayerCounts() {
        if (!cache.layerCounts) {
            cache.layerCounts = new Map();
            for (const [layer, nodes] of index.nodesByLayer) {
                cache.layerCounts.set(layer, nodes.length);
            }
        }
        return cache.layerCounts;
    }

    function getEffectCounts() {
        if (!cache.effectCounts) {
            cache.effectCounts = new Map();
            for (const [effect, nodes] of index.nodesByEffect) {
                cache.effectCounts.set(effect, nodes.length);
            }
        }
        return cache.effectCounts;
    }

    function getEdgeTypeCounts() {
        if (!cache.edgeTypeCounts) {
            cache.edgeTypeCounts = new Map();
            for (const link of raw.links) {
                const type = link.edge_type || link.type || 'unknown';
                cache.edgeTypeCounts.set(type, (cache.edgeTypeCounts.get(type) || 0) + 1);
            }
        }
        return cache.edgeTypeCounts;
    }

    function getEdgeFamilyCounts() {
        if (!cache.edgeFamilyCounts) {
            cache.edgeFamilyCounts = new Map();
            for (const link of raw.links) {
                const family = link.family || 'Dependency';
                cache.edgeFamilyCounts.set(family, (cache.edgeFamilyCounts.get(family) || 0) + 1);
            }
        }
        return cache.edgeFamilyCounts;
    }

    function getEdgeRanges() {
        if (!cache.edgeRanges) {
            let minW = Infinity, maxW = -Infinity;
            let minC = Infinity, maxC = -Infinity;
            for (const link of raw.links) {
                const w = link.weight ?? 1;
                const c = link.confidence ?? 1;
                if (w < minW) minW = w;
                if (w > maxW) maxW = w;
                if (c < minC) minC = c;
                if (c > maxC) maxC = c;
            }
            cache.edgeRanges = {
                weight: { min: minW === Infinity ? 0 : minW, max: maxW === -Infinity ? 1 : maxW },
                confidence: { min: minC === Infinity ? 0 : minC, max: maxC === -Infinity ? 1 : maxC }
            };
        }
        return cache.edgeRanges;
    }

    // =========================================================================
    // SELF-TEST
    // =========================================================================

    function selfTest() {
        const errors = [];
        const warnings = [];
        const seenIds = new Set();

        for (const node of raw.nodes) {
            if (!node?.id) {
                errors.push('Node missing id');
                continue;
            }
            if (seenIds.has(node.id)) {
                errors.push(`Duplicate node id: ${node.id}`);
                continue;
            }
            seenIds.add(node.id);
        }

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');
            if (srcId && !index.nodeById.has(srcId)) {
                warnings.push(`Edge source not in graph: ${srcId}`);
            }
            if (tgtId && !index.nodeById.has(tgtId)) {
                warnings.push(`Edge target not in graph: ${tgtId}`);
            }
        }

        const status = errors.length === 0 ? 'PASS' : 'FAIL';
        const style = errors.length === 0
            ? 'color: #4ade80; font-weight: bold'
            : 'color: #f87171; font-weight: bold';

        console.log(`%c[DATA] Self-Test: ${status}`, style);
        console.log(`  Raw: ${raw.nodes.length} nodes, ${raw.links.length} edges`);
        console.log(`  Indexes: nodeById=${index.nodeById.size}, tiers=${index.nodesByTier.size}`);

        if (errors.length > 0) console.error('[DATA] Errors:', errors);
        if (warnings.length > 0) {
            console.warn('[DATA] Warnings:', warnings.slice(0, 5));
            if (warnings.length > 5) console.warn(`  ... and ${warnings.length - 5} more`);
        }

        return { errors, warnings, pass: errors.length === 0 };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Init
        init,

        // Raw data
        getNodes,
        getLinks,
        getFileBoundaries,
        getMarkov,
        getKpis,
        getMeta,
        getPhysics,
        getConfig,
        getAnalytics,

        // Indexed lookups
        getNode,
        getNodesByTier,
        getNodesByFamily,
        getNodesByRing,
        getNodesByLayer,
        getNodesByEffect,
        getNodesByFile,
        getEdgesFrom,
        getEdgesTo,
        getEdgeBetween,
        getFile,
        getTopMarkovEdges,
        isHighEntropyNode,

        // Filtered data
        setFiltered,
        getVisibleNodes,
        getVisibleLinks,

        // Aggregations
        getTierCounts,
        getFamilyCounts,
        getRingCounts,
        getLayerCounts,
        getEffectCounts,
        getEdgeTypeCounts,
        getEdgeFamilyCounts,
        getEdgeRanges,

        // Self-test
        selfTest,

        // Direct access (for migration)
        raw,
        index,
        cache,
        filtered,

        // Legend reference
        get legend() { return _legend; },

        // Color access (convenience)
        get color() { return COLOR; }
    };
})();

// Backward compatibility - DataManager class wrapper
class DataManager {
    constructor() {
        this.raw = DATA.raw;
        this.analytics = {};
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = null;
        this.color = COLOR;
    }

    init(data) {
        DATA.init(data);
        this.raw = DATA.raw;
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = DATA.legend;
        return this;
    }

    // Delegate all methods to DATA module
    getNodes() { return DATA.getNodes(); }
    getLinks() { return DATA.getLinks(); }
    getFileBoundaries() { return DATA.getFileBoundaries(); }
    getMarkov() { return DATA.getMarkov(); }
    getKpis() { return DATA.getKpis(); }
    getMeta() { return DATA.getMeta(); }
    getNode(id) { return DATA.getNode(id); }
    getNodesByTier(tier) { return DATA.getNodesByTier(tier); }
    getNodesByFamily(family) { return DATA.getNodesByFamily(family); }
    getNodesByRing(ring) { return DATA.getNodesByRing(ring); }
    getNodesByFile(fileIdx) { return DATA.getNodesByFile(fileIdx); }
    getEdgesFrom(nodeId) { return DATA.getEdgesFrom(nodeId); }
    getEdgesTo(nodeId) { return DATA.getEdgesTo(nodeId); }
    getEdgeBetween(srcId, tgtId) { return DATA.getEdgeBetween(srcId, tgtId); }
    getFile(idx) { return DATA.getFile(idx); }
    getTopMarkovEdges(nodeId, k) { return DATA.getTopMarkovEdges(nodeId, k); }
    isHighEntropyNode(nodeId) { return DATA.isHighEntropyNode(nodeId); }
    setFiltered(nodes, links) { DATA.setFiltered(nodes, links); }
    getVisibleNodes() { return DATA.getVisibleNodes(); }
    getVisibleLinks() { return DATA.getVisibleLinks(); }
    getTierCounts() { return DATA.getTierCounts(); }
    getFamilyCounts() { return DATA.getFamilyCounts(); }
    getRingCounts() { return DATA.getRingCounts(); }
    getLayerCounts() { return DATA.getLayerCounts(); }
    getEffectCounts() { return DATA.getEffectCounts(); }
    getEdgeTypeCounts() { return DATA.getEdgeTypeCounts(); }
    getEdgeFamilyCounts() { return DATA.getEdgeFamilyCounts(); }
    getEdgeRanges() { return DATA.getEdgeRanges(); }
    selfTest() { return DATA.selfTest(); }

    // Internal methods
    _buildAllIndexes() {}
    _buildNodeIndex() {}
    _buildSemanticIndexes() {}
    _buildEdgeIndexes() {}
    _buildFileIndex() {}
    _buildMarkovIndex() {}
    _invalidateCache() {}
    _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }
    _getNodeTier(node) { return NODE.getTier(node); }
    _getNodeFamily(node) { return NODE.getFamily(node); }
    _getNodeRing(node) { return NODE.getRing(node); }
    _getNodeLayer(node) { return NODE.getLayer(node); }
    _getNodeEffect(node) { return NODE.getEffect(node); }
}

// Global DM instance - defined by app.js (not duplicated here to avoid redeclaration)
// DM is accessed as a global variable provided by app.js

// Parity check function
function runDmParity(dm, data) {
    if (!dm) return;
    const checks = [];
    const rawNodes = Array.isArray(data?.nodes) ? data.nodes.length : 0;
    const rawEdges = Array.isArray(data?.links) ? data.links.length : 0;
    const dmNodes = dm.raw.nodes.length;
    const dmEdges = dm.raw.links.length;

    checks.push({ name: 'Node count', dm: dmNodes, old: rawNodes, pass: dmNodes === rawNodes });
    checks.push({ name: 'Edge count', dm: dmEdges, old: rawEdges, pass: dmEdges === rawEdges });
    checks.push({ name: 'Node index size', dm: dm.index.nodeById.size, old: rawNodes, pass: dm.index.nodeById.size === rawNodes });

    const allPass = checks.every(c => c.pass);
    const style = allPass ? 'color: #4ade80; font-weight: bold' : 'color: #f87171; font-weight: bold';
    console.log(`%c[DM Parity] ${allPass ? 'ALL PASS' : 'MISMATCH'}`, style);
    checks.forEach(c => {
        const icon = c.pass ? '✓' : '✗';
        console.log(`  ${icon} ${c.name}: DM=${c.dm}, Raw=${c.old}`);
    });
}


// ═══ MODULE: modules/vis-state.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VIS-STATE MODULE - Unified visualization state management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Single source of truth for visualization state. All controls funnel through
 * applyState() to ensure consistency.
 *
 * KEY DESIGN DECISIONS:
 * 1. Palette selection NEVER auto-switches colorBy mode
 * 2. Palette is "armed" - it applies when colorBy changes to interval mode
 * 3. Presets are macros that call applyState() with multiple properties
 * 4. syncUIFromState() updates all UI elements to match state
 *
 * @module VIS_STATE
 * @version 1.0.0
 */

window.VIS_STATE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CATEGORICAL vs INTERVAL MODE CLASSIFICATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Categorical modes use discrete color palettes (tier, family, atom...)
     * Interval modes use continuous gradients (complexity, fan_in, loc...)
     */
    const CATEGORICAL_MODES = new Set([
        'tier', 'family', 'atom', 'ring', 'layer', 'role', 'roleCategory',
        'subsystem', 'phase', 'fileType', 'file', 'state', 'visibility'
    ]);

    const INTERVAL_MODES = new Set([
        'complexity', 'loc', 'fan_in', 'fan_out', 'trust',
        'responsibility', 'purity', 'lifecycle_score', 'boundary_score',
        'centrality', 'rank', 'churn', 'age', 'depth'
    ]);

    function isIntervalMode(mode) {
        return INTERVAL_MODES.has(mode);
    }

    function isCategoricalMode(mode) {
        return CATEGORICAL_MODES.has(mode);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATE OBJECT - Single source of truth
    // ═══════════════════════════════════════════════════════════════════════

    const state = {
        colorBy: 'fan_in',         // Default to interval mode to show OKLCH schemes
        sizeBy: 'fanout',          // 'uniform', 'degree', 'fanout', 'complexity'
        edgeBy: 'type',            // 'type', 'resolution', 'weight', 'gradient-tier', etc.
        palette: 'helix',          // OKLCH helix path - visually striking default
        paletteType: 'interval'    // Derived: 'categorical' or 'interval'
    };

    // ═══════════════════════════════════════════════════════════════════════
    // VIEW PRESETS - Macros that set multiple properties at once
    // ═══════════════════════════════════════════════════════════════════════

    const VIEW_PRESETS = {
        tier: {
            label: 'Tier',
            description: 'T0/T1/T2 architectural height',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        family: {
            label: 'Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        layer: {
            label: 'Layer',
            description: 'Physical/Virtual/Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        ring: {
            label: 'Ring',
            description: 'Domain architecture rings',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        file: {
            label: 'File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        flow: {
            label: 'Flow',
            description: 'Markov transition probability',
            colorBy: 'fan_in',  // Use interval mode for flow
            sizeBy: 'degree',
            edgeBy: 'weight',
            special: 'flow'    // Triggers flow visualization
        }
    };

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY STATE - Central function all controls use
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply state changes. This is THE function all UI controls call.
     *
     * @param {Object} nextState - Partial state to merge
     * @param {string} reason - Debug label for console (e.g., 'preset:tier', 'control:colorBy')
     */
    function applyState(nextState, reason = 'unknown') {
        const prevColorBy = state.colorBy;
        const prevPalette = state.palette;

        // Merge new state
        if (nextState.colorBy !== undefined) state.colorBy = nextState.colorBy;
        if (nextState.sizeBy !== undefined) state.sizeBy = nextState.sizeBy;
        if (nextState.edgeBy !== undefined) state.edgeBy = nextState.edgeBy;
        if (nextState.palette !== undefined) state.palette = nextState.palette;

        // Derive paletteType from colorBy
        state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';

        console.log(`[VIS_STATE] applyState(${reason}):`, {
            colorBy: state.colorBy,
            sizeBy: state.sizeBy,
            edgeBy: state.edgeBy,
            palette: state.palette,
            paletteType: state.paletteType
        });

        // ─── Apply color mode ───
        if (nextState.colorBy !== undefined && nextState.colorBy !== prevColorBy) {
            _applyColorMode(state.colorBy);
        }

        // ─── Apply size mode ───
        if (nextState.sizeBy !== undefined) {
            _applySizeMode(state.sizeBy);
        }

        // ─── Apply edge mode ───
        if (nextState.edgeBy !== undefined) {
            _applyEdgeMode(state.edgeBy);
        }

        // ─── Apply palette (only if in interval mode) ───
        if (nextState.palette !== undefined || nextState.colorBy !== undefined) {
            _applyPalette();
        }

        // ─── Handle special modes (flow) ───
        if (nextState.special === 'flow') {
            _enableFlowMode();
        } else if (prevColorBy === 'flow' && nextState.colorBy !== 'flow') {
            _disableFlowMode();
        }

        // ─── Sync UI to match state ───
        syncUIFromState();

        // ─── Refresh visualization ───
        _refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INTERNAL APPLY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════

    function _applyColorMode(mode) {
        // Update globals for backward compatibility
        window.NODE_COLOR_MODE = mode;

        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.colorMode = mode;
            window.APPEARANCE_STATE.currentPreset = mode;
        }

        // Disable flow mode if switching away from flow
        if (mode !== 'flow' && typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _applySizeMode(mode) {
        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.sizeMode = mode;
        }

        if (typeof window.applyNodeSizeMode === 'function') {
            window.applyNodeSizeMode(mode);
        } else if (typeof window.NODE_HELPERS !== 'undefined') {
            window.NODE_HELPERS.applySizeMode(mode);
        }
    }

    function _applyEdgeMode(mode) {
        if (typeof window.EDGE_GRADIENT_MODE !== 'undefined') {
            // Edge gradient modes
            if (mode.startsWith('gradient-')) {
                window.EDGE_GRADIENT_MODE = mode.replace('gradient-', '');
            }
        }

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
    }

    function _applyPalette() {
        // Only apply scheme coloring if in interval mode
        if (state.paletteType === 'interval' && state.palette) {
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(state.palette);
            }
        } else {
            // In categorical mode, clear active scheme
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(null);
            }
        }
    }

    function _enableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && !window.flowMode) {
            if (typeof window.toggleFlowMode === 'function') {
                window.toggleFlowMode();
            }
        }
    }

    function _disableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _refreshGraph() {
        // Recompute node colors
        const DM = window.DM;
        const Graph = window.Graph;
        const nodes = DM ? DM.getNodes() : (Graph?.graphData ? Graph.graphData().nodes : []);

        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render with new function reference to force update
        if (Graph) {
            Graph.nodeColor(n => n.color);
        }

        // Refresh edge gradients
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        // Re-render legends
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SYNC UI FROM STATE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all UI elements to reflect current state.
     * Called after every applyState() and on initialization.
     */
    function syncUIFromState() {
        // ─── View Preset buttons ───
        document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
            const presetKey = btn.dataset.preset;
            const preset = VIEW_PRESETS[presetKey];
            const isActive = preset && preset.colorBy === state.colorBy;
            btn.classList.toggle('active', isActive);
        });

        // ─── Color Mode buttons (PRESET_CONFIG grid) ───
        document.querySelectorAll('.color-btn[data-preset]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.preset === state.colorBy);
        });

        // ─── Size Mode buttons ───
        document.querySelectorAll('[data-size-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.sizeMode === state.sizeBy);
        });

        // ─── Edge Mode buttons ───
        document.querySelectorAll('[data-edge-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.edgeMode === state.edgeBy);
        });

        // ─── Palette buttons ───
        document.querySelectorAll('.scheme-btn[data-scheme]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.scheme === state.palette);
        });

        // ─── Palette panel enabled/disabled state ───
        const schemesPanel = document.getElementById('section-schemes');
        if (schemesPanel) {
            const isDisabled = state.paletteType === 'categorical';
            schemesPanel.classList.toggle('disabled', isDisabled);

            // Update scheme buttons opacity/interactivity
            schemesPanel.querySelectorAll('.scheme-btn').forEach(btn => {
                btn.disabled = isDisabled;
                btn.style.opacity = isDisabled ? '0.4' : '1';
                btn.style.pointerEvents = isDisabled ? 'none' : 'auto';
            });

            // Show hint when disabled
            let hint = schemesPanel.querySelector('.scheme-hint');
            if (isDisabled) {
                if (!hint) {
                    hint = document.createElement('div');
                    hint.className = 'scheme-hint';
                    hint.style.cssText = 'padding: 8px; font-size: 10px; opacity: 0.6; text-align: center; font-style: italic;';
                    hint.textContent = 'Switch to a metric mode (Fan-In, Complexity, etc.) to enable color schemes';
                    schemesPanel.insertBefore(hint, schemesPanel.firstChild);
                }
            } else if (hint) {
                hint.remove();
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVENIENCE METHODS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply a view preset by name
     */
    function applyPreset(presetKey) {
        const preset = VIEW_PRESETS[presetKey];
        if (!preset) {
            console.warn('[VIS_STATE] Unknown preset:', presetKey);
            return;
        }

        applyState({
            colorBy: preset.colorBy,
            sizeBy: preset.sizeBy,
            edgeBy: preset.edgeBy,
            special: preset.special
        }, `preset:${presetKey}`);
    }

    /**
     * Set color mode only
     */
    function setColorBy(mode) {
        applyState({ colorBy: mode }, `colorBy:${mode}`);
    }

    /**
     * Set size mode only
     */
    function setSizeBy(mode) {
        applyState({ sizeBy: mode }, `sizeBy:${mode}`);
    }

    /**
     * Set edge mode only
     */
    function setEdgeBy(mode) {
        applyState({ edgeBy: mode }, `edgeBy:${mode}`);
    }

    /**
     * Set palette (arms the palette, applies if in interval mode)
     */
    function setPalette(schemeName) {
        applyState({ palette: schemeName }, `palette:${schemeName}`);
    }

    /**
     * Get current state (read-only copy)
     */
    function getState() {
        return { ...state };
    }

    /**
     * Initialize from saved preferences or defaults
     */
    function init() {
        try {
            const savedScheme = localStorage.getItem('collider_scheme');
            const savedColorMode = localStorage.getItem('collider_color_mode');

            if (savedScheme) state.palette = savedScheme;
            if (savedColorMode) state.colorBy = savedColorMode;

            state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';
        } catch (e) { /* ignore localStorage errors */ }

        // Apply initial state to globals (critical for NODE_COLOR_MODE)
        _applyColorMode(state.colorBy);
        _applyPalette();

        console.log('[VIS_STATE] Initialized:', state);
    }

    /**
     * Save current preferences
     */
    function savePreferences() {
        try {
            localStorage.setItem('collider_scheme', state.palette);
            localStorage.setItem('collider_color_mode', state.colorBy);
        } catch (e) { /* ignore */ }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // State access
        getState,
        isIntervalMode,
        isCategoricalMode,

        // Main API
        applyState,
        applyPreset,
        syncUIFromState,

        // Convenience setters
        setColorBy,
        setSizeBy,
        setEdgeBy,
        setPalette,

        // Lifecycle
        init,
        savePreferences,

        // Constants
        VIEW_PRESETS,
        CATEGORICAL_MODES,
        INTERVAL_MODES
    };
})();

console.log('[Module] VIS_STATE loaded - unified visualization state');


// ═══ MODULE: modules/ui-manager.js ═══
/**
 * @module ui-manager
 * @description Orchestrates the "One Dock" unified interface
 * @responsibility Manage sidebar, dock, modes, and filters UI
 * @depends_on vis-state, data-manager, refresh-throttle
 */

const UI_MANAGER = (function() {
    'use strict';

    // Private state
    let _data = null;
    let _initialized = false;

    /**
     * Initialize the UI Manager
     * @param {Object} data - Graph data object
     */
    function init(data) {
        _data = data;
        _setupSidebar();
        _setupDock();
        _setupModes();
        _populateFilters();
        _updateStatus();
        _initialized = true;
    }

    /**
     * Setup sidebar toggle and accordion behavior
     */
    function _setupSidebar() {
        const sidebar = document.getElementById('sidebar');
        const btnFilters = document.getElementById('btn-filters');
        const btnClose = document.getElementById('sidebar-close');

        const toggle = () => {
            sidebar.classList.toggle('open');
            _updateFilterBadge();
        };

        if (btnFilters) btnFilters.onclick = (e) => {
            e.stopPropagation();
            toggle();
        };
        if (btnClose) btnClose.onclick = () => sidebar.classList.remove('open');

        // Accordion Logic
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.onclick = () => {
                const accordion = header.parentElement;
                accordion.classList.toggle('open');
            };
        });
    }

    /**
     * Setup dock controls
     */
    function _setupDock() {
        // Reset Layout
        const btnReset = document.getElementById('btn-reset-layout');
        if (btnReset) btnReset.onclick = () => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.zoomToFit(1000);
            }
        };

        // Dimensions Toggle (2D/3D - stub)
        const btnDim = document.getElementById('btn-dimensions');
        if (btnDim) btnDim.onclick = () => {
            console.log("Dimension toggle requested");
        };

        // Report Button
        const btnReport = document.getElementById('btn-report');
        if (btnReport) btnReport.onclick = () => {
            const reportPanel = document.getElementById('report-panel');
            if (reportPanel) {
                const isHidden = reportPanel.style.display === 'none';
                reportPanel.style.display = isHidden ? 'block' : 'none';
                btnReport.classList.toggle('active', isHidden);
            }
        };
    }

    /**
     * Setup mode buttons (explore, files, flow)
     */
    function _setupModes() {
        const modes = ['explore', 'files', 'flow'];

        const setMode = (mode) => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.getElementById(`mode-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');

            document.querySelectorAll('.mode-control-group').forEach(g => g.style.display = 'none');
            const group = document.getElementById(`${mode}-controls`);
            if (group) group.style.display = 'flex';
        };

        modes.forEach(mode => {
            const btn = document.getElementById(`mode-${mode}`);
            if (btn) btn.onclick = () => setMode(mode);
        });

        // Files Sub-controls wiring
        const bindToggle = (id, onClick) => {
            const el = document.getElementById(id);
            if (el) el.onclick = (e) => {
                e.target.classList.toggle('active');
                if (onClick) onClick(e.target.classList.contains('active'));
            };
        };

        bindToggle('btn-file-hulls', (_active) => {
            // Toggle hull visibility
        });
    }

    /**
     * Populate filter chips for all categories
     */
    function _populateFilters() {
        if (!_data) return;

        // Helper: Create Filter Chips
        const createChips = (containerId, counts, activeSet) => {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            counts.forEach(([key, count]) => {
                const chip = document.createElement('div');
                const isActive = activeSet.has(key);
                chip.className = `filter-chip ${isActive ? 'active' : ''}`;
                chip.innerHTML = `${key} <span class="chip-count">${count}</span>`;
                chip.onclick = () => {
                    if (activeSet.has(key)) activeSet.delete(key);
                    else activeSet.add(key);

                    chip.classList.toggle('active');
                    _updateFilterBadge();
                    // Call refreshGraph if available
                    if (typeof refreshGraph === 'function') refreshGraph();
                };
                container.appendChild(chip);
            });

            const type = containerId.replace('filter-', '');
            const countEl = document.getElementById(`count-${type}`);
            if (countEl) countEl.innerText = activeSet.size;
        };

        // Get accessor functions
        const getNodeRing = typeof window.getNodeRing === 'function' ? window.getNodeRing :
            (typeof NODE !== 'undefined' ? NODE.getRing : (n => n.ring || 'Unknown'));
        const getNodeTier = typeof window.getNodeTier === 'function' ? window.getNodeTier :
            (typeof NODE !== 'undefined' ? NODE.getTier : (n => n.tier || 'Unknown'));
        const getNodeAtomFamily = typeof window.getNodeAtomFamily === 'function' ? window.getNodeAtomFamily :
            (typeof NODE !== 'undefined' ? NODE.getFamily : (n => n.atom_family || 'Unknown'));
        const normalizeRingValue = typeof window.normalizeRingValue === 'function' ? window.normalizeRingValue :
            (typeof NODE !== 'undefined' ? NODE.normalizeRing : (v => v));
        const collectCounts = typeof window.collectCounts === 'function' ? window.collectCounts :
            _defaultCollectCounts;

        // Get VIS_FILTERS
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set(), edges: new Set(), families: new Set() };

        // 1. LAYERS (Rings)
        const ringCounts = collectCounts(_data.nodes, getNodeRing);
        const rawRingDefaults = _data.controls?.filters?.rings || [];
        const ringDefaults = rawRingDefaults
            .map(v => normalizeRingValue(v))
            .filter(v => v !== null);

        if (VIS_FILTERS.rings.size === 0 && ringDefaults.length > 0) {
            const availableRings = new Set(ringCounts.map(([ring]) => ring));
            const matchedRings = ringDefaults.filter(r => availableRings.has(r));
            if (matchedRings.length > 0) {
                matchedRings.forEach(r => VIS_FILTERS.rings.add(r));
            } else {
                const familyCounts = collectCounts(_data.nodes, getNodeAtomFamily);
                const availableFamilies = new Set(familyCounts.map(([family]) => family));
                const matchedFamilies = ringDefaults.filter(f => availableFamilies.has(f));
                if (matchedFamilies.length > 0 && VIS_FILTERS.families.size === 0) {
                    matchedFamilies.forEach(f => VIS_FILTERS.families.add(f));
                    console.warn('[Filters] Ring defaults matched families; applying as family filters.');
                }
            }
        }
        createChips('filter-rings', ringCounts, VIS_FILTERS.rings);

        // 2. TIERS
        const tierCounts = collectCounts(_data.nodes, getNodeTier);
        createChips('filter-tiers', tierCounts, VIS_FILTERS.tiers);

        // 3. ROLES
        const roleCounts = collectCounts(_data.nodes, n => String(n.role || 'Unknown'));
        createChips('filter-roles', roleCounts, VIS_FILTERS.roles);

        // 4. EDGES
        const edgeCounts = collectCounts(_data.links, l => String(l.edge_type || l.type || 'default'));
        createChips('filter-edges', edgeCounts, VIS_FILTERS.edges);

        // 5. DATAMAPS
        _populateDatamaps();

        _updateFilterBadge();
    }

    /**
     * Default collectCounts implementation
     */
    function _defaultCollectCounts(items, accessor) {
        const counts = new Map();
        items.forEach(item => {
            const key = accessor(item);
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    /**
     * Populate datamap chips
     */
    function _populateDatamaps() {
        const container = document.getElementById('filter-datamaps');
        if (!container) return;
        container.innerHTML = '';

        const controls = _data.controls || {};
        const resolveDatamapConfigs = typeof window.resolveDatamapConfigs === 'function'
            ? window.resolveDatamapConfigs
            : () => [];
        const configs = resolveDatamapConfigs(controls);
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS || new Set();
        const setDatamap = typeof window.setDatamap === 'function' ? window.setDatamap : () => {};

        configs.forEach(cfg => {
            const chip = document.createElement('div');
            const isActive = ACTIVE_DATAMAPS.has(cfg.id);
            chip.className = `filter-chip ${isActive ? 'active' : ''}`;
            chip.style.width = '100%';
            chip.style.marginBottom = '4px';
            chip.innerHTML = `${cfg.label}`;

            chip.onclick = () => {
                setDatamap(cfg.id);
                Array.from(container.children).forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            };
            container.appendChild(chip);
        });

        const countEl = document.getElementById('count-datamaps');
        if (countEl) countEl.innerText = configs.length;
    }

    /**
     * Update filter badge count
     */
    function _updateFilterBadge() {
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set() };

        let total = 0;
        total += VIS_FILTERS.rings.size;
        total += VIS_FILTERS.tiers.size;
        total += VIS_FILTERS.roles.size;

        const badge = document.getElementById('filter-badge');
        const miniBadge = document.getElementById('filter-badge-mini');

        if (badge) badge.innerText = total;
        if (miniBadge) {
            miniBadge.innerText = total;
            miniBadge.classList.toggle('visible', total > 0);
        }

        const summary = document.getElementById('filter-summary');
        if (summary) {
            summary.innerText = total > 0 ? `${total} filters active` : "No filters active";
        }
    }

    /**
     * Update status display (node/edge counts)
     */
    function _updateStatus() {
        if (_data && _data.nodes) {
            const n = _data.nodes.length;
            const e = _data.links.length;
            const statusNodes = document.getElementById('status-nodes');
            const statusEdges = document.getElementById('status-edges');

            if (statusNodes) statusNodes.innerText = n;
            if (statusEdges) statusEdges.innerText = e;
        }
    }

    /**
     * Refresh filters (re-populate from current data)
     */
    function refreshFilters() {
        _populateFilters();
    }

    /**
     * Update badge count (public interface)
     */
    function updateFilterBadge() {
        _updateFilterBadge();
    }

    // Public API
    return {
        init,
        refreshFilters,
        updateFilterBadge,
        get data() { return _data; },
        get initialized() { return _initialized; }
    };
})();

// Backward compatibility - expose as UIManager
const UIManager = {
    data: null,
    init(data) {
        this.data = data;
        UI_MANAGER.init(data);
    },
    setupSidebar() { /* Now internal */ },
    setupDock() { /* Now internal */ },
    setupModes() { /* Now internal */ },
    populateFilters() { UI_MANAGER.refreshFilters(); },
    populateDatamaps() { UI_MANAGER.refreshFilters(); },
    updateFilterBadge() { UI_MANAGER.updateFilterBadge(); },
    updateStatus() { /* Now internal */ }
};

// Expose globally
window.UI_MANAGER = UI_MANAGER;
window.UIManager = UIManager;


// ═══ MODULE: modules/physics.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * PHYSICS MODULE - Force simulation controls
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Physics presets, sliders, and force parameter management.
 * Depends on: Graph, PHYSICS_STATE, PHYSICS_PRESETS (globals)
 *
 * @module PHYSICS
 * @version 1.0.0
 */

window.PHYSICS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS STATE
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsState() {
        const Graph = window.Graph;
        const PHYSICS_STATE = window.PHYSICS_STATE;
        if (!Graph) return;
        try {
            Graph.d3Force('charge')?.strength(PHYSICS_STATE.charge);
            Graph.d3Force('link')?.distance(PHYSICS_STATE.linkDistance);
            Graph.d3Force('center')?.strength(PHYSICS_STATE.centerStrength);
            Graph.d3VelocityDecay?.(PHYSICS_STATE.velocityDecay);
            Graph.d3ReheatSimulation();
        } catch (e) {
            console.warn('[Physics] Could not apply:', e.message);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS PRESET
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsPreset(presetName) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const preset = PHYSICS_PRESETS[presetName];
        if (!preset) return;
        Object.assign(PHYSICS_STATE, {
            charge: preset.charge,
            linkDistance: preset.linkDistance,
            centerStrength: preset.centerStrength,
            velocityDecay: preset.velocityDecay
        });
        applyPhysicsState();
        updatePhysicsSliders();
        window.showModeToast(`Physics: ${preset.label}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE PHYSICS SLIDERS
    // ═══════════════════════════════════════════════════════════════════════

    function updatePhysicsSliders() {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const sliders = {
            'physics-charge': PHYSICS_STATE.charge,
            'physics-link-distance': PHYSICS_STATE.linkDistance,
            'physics-center': PHYSICS_STATE.centerStrength,
            'physics-damping': PHYSICS_STATE.velocityDecay
        };
        for (const [id, value] of Object.entries(sliders)) {
            const input = document.getElementById(id);
            const display = document.getElementById(id + '-value');
            if (input) input.value = value;
            if (display) display.textContent = typeof value === 'number' && value % 1 !== 0 ? value.toFixed(2) : value;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // BUILD PHYSICS CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function buildPhysicsControls(containerId) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const container = document.getElementById(containerId);
        if (!container) return;

        // Preset buttons
        const presetRow = document.createElement('div');
        presetRow.className = 'physics-presets';
        presetRow.style.cssText = 'display:flex;gap:4px;margin-bottom:8px;flex-wrap:wrap;';
        Object.entries(PHYSICS_PRESETS).forEach(([key, preset]) => {
            const btn = document.createElement('button');
            btn.className = 'preset-btn physics-preset-btn';
            btn.textContent = preset.label;
            btn.style.cssText = 'font-size:9px;padding:2px 6px;';
            btn.onclick = () => applyPhysicsPreset(key);
            presetRow.appendChild(btn);
        });
        container.appendChild(presetRow);

        // Sliders
        const sliderDefs = [
            {
                id: 'physics-charge',
                label: 'REPULSION',
                min: -500,
                max: 50,
                step: 10,
                value: PHYSICS_STATE.charge,
                onChange: (val) => { PHYSICS_STATE.charge = val; applyPhysicsState(); }
            },
            {
                id: 'physics-link-distance',
                label: 'LINK DIST',
                min: 10,
                max: 200,
                step: 5,
                value: PHYSICS_STATE.linkDistance,
                onChange: (val) => { PHYSICS_STATE.linkDistance = val; applyPhysicsState(); }
            },
            {
                id: 'physics-center',
                label: 'CENTER PULL',
                min: 0,
                max: 0.3,
                step: 0.01,
                value: PHYSICS_STATE.centerStrength,
                onChange: (val) => { PHYSICS_STATE.centerStrength = val; applyPhysicsState(); }
            },
            {
                id: 'physics-damping',
                label: 'DAMPING',
                min: 0,
                max: 1,
                step: 0.05,
                value: PHYSICS_STATE.velocityDecay,
                onChange: (val) => { PHYSICS_STATE.velocityDecay = val; applyPhysicsState(); }
            }
        ];

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row';

            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            valueDisplay.textContent = def.step < 1 ? def.value.toFixed(2) : def.value;
            header.appendChild(label);
            header.appendChild(valueDisplay);

            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = def.value;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = def.step < 1 ? val.toFixed(2) : val;
                def.onChange(val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);
            container.appendChild(wrapper);
        });

        console.log('[Physics] Controls initialized');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        applyState: applyPhysicsState,
        applyPreset: applyPhysicsPreset,
        updateSliders: updatePhysicsSliders,
        buildControls: buildPhysicsControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.applyPhysicsState = PHYSICS.applyState;
window.applyPhysicsPreset = PHYSICS.applyPreset;
window.updatePhysicsSliders = PHYSICS.updateSliders;
window.buildPhysicsControls = PHYSICS.buildControls;

console.log('[Module] PHYSICS loaded - 4 functions');


// ═══ MODULE: modules/datamap.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DATAMAP MODULE - Data mapping and filtering
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Datamap configuration, matching, and UI control updates.
 * Depends on: DM, VIS_FILTERS, ACTIVE_DATAMAPS, NODE (node-accessors)
 *
 * @module DATAMAP
 * @version 1.0.0
 */

window.DATAMAP = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NORMALIZE DATAMAP CONFIG
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeDatamapConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const id = String(raw.id || raw.key || raw.label || '').trim();
        if (!id) return null;
        const normalizeList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => String(item).toUpperCase());
        };
        const normalizeTierList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => window.normalizeTier(item));
        };
        const match = raw.match || {};
        return {
            id: id.toUpperCase(),
            label: String(raw.label || raw.id || id).toUpperCase(),
            match: {
                atom_families: normalizeList(match.atom_families),
                atom_prefixes: normalizeList(match.atom_prefixes),
                tiers: normalizeTierList(match.tiers),
                rings: normalizeList(match.rings),
                roles: normalizeList(match.roles)
            },
            default: Boolean(raw.default)
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // RESOLVE DATAMAP CONFIGS
    // ═══════════════════════════════════════════════════════════════════════

    function resolveDatamapConfigs(controlsConfig) {
        const fromTokens = Array.isArray(controlsConfig.datamaps) ? controlsConfig.datamaps : [];
        const normalized = fromTokens
            .map(normalizeDatamapConfig)
            .filter(Boolean);
        if (normalized.length) return normalized;

        const fallback = controlsConfig.buttons?.datamaps || {};
        return Object.entries(fallback).map(([label, config]) => {
            const prefix = config.filter || null;
            return normalizeDatamapConfig({
                id: label.toUpperCase(),
                label: label.toUpperCase(),
                match: prefix ? { atom_prefixes: [prefix] } : {},
                default: false
            });
        }).filter(Boolean);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP MATCHING
    // ═══════════════════════════════════════════════════════════════════════

    function datamapMatches(node, config) {
        const match = config.match || {};
        const atomId = String(node.atom || '');
        const atomFamily = window.getNodeAtomFamily(node);
        const tier = window.getNodeTier(node);
        const ring = window.getNodeRing(node);
        const role = String(node.role || 'Unknown').toUpperCase();

        if (Array.isArray(match.atom_families) && match.atom_families.length) {
            if (!match.atom_families.includes(atomFamily)) return false;
        }

        if (Array.isArray(match.atom_prefixes) && match.atom_prefixes.length) {
            const matchesFamily = match.atom_prefixes.includes(atomFamily);
            const matchesPrefix = match.atom_prefixes.some(prefix => atomId.startsWith(prefix));
            if (!matchesFamily && !matchesPrefix) return false;
        }

        if (Array.isArray(match.tiers) && match.tiers.length) {
            if (!match.tiers.includes(tier)) return false;
        }

        if (Array.isArray(match.rings) && match.rings.length) {
            if (!match.rings.includes(ring)) return false;
        }

        if (Array.isArray(match.roles) && match.roles.length) {
            if (!match.roles.includes(role)) return false;
        }
        return true;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET DATAMAP
    // ═══════════════════════════════════════════════════════════════════════

    function setDatamap(prefix) {
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const nextSet = new Set(ACTIVE_DATAMAPS);
        if (!prefix) {
            nextSet.clear();
        } else if (nextSet.has(prefix)) {
            nextSet.delete(prefix);
        } else {
            nextSet.add(prefix);
        }

        if (!window.DM) {
            window.ACTIVE_DATAMAPS = nextSet;
            updateDatamapControls();
            return;
        }

        const subset = window.filterGraph(null, window.CURRENT_DENSITY, nextSet, window.VIS_FILTERS);
        if (!subset.nodes.length) {
            window.showToast('No nodes for that datamap selection.');
            updateDatamapControls();
            return;
        }

        window.ACTIVE_DATAMAPS = nextSet;
        updateDatamapControls();
        window.refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET NODE COLOR MODE
    // ═══════════════════════════════════════════════════════════════════════

    function setNodeColorMode(mode) {
        window.NODE_COLOR_MODE = mode;
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
        window.refreshGraph();
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY DATAMAP (ALIAS)
    // ═══════════════════════════════════════════════════════════════════════

    function applyDatamap(prefix) {
        setDatamap(prefix);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE DATAMAP CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function updateDatamapControls() {
        const DM = window.DM;
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const DATAMAP_UI = window.DATAMAP_UI;
        const DATAMAP_CONFIGS = window.DATAMAP_CONFIGS;
        const GRAPH_MODE = window.GRAPH_MODE;
        const VIS_FILTERS = window.VIS_FILTERS;

        if (!DM) return;
        const datamapEnabled = GRAPH_MODE === 'atoms';
        const base = window.filterGraph(null, window.CURRENT_DENSITY, new Set(), VIS_FILTERS);
        const nodes = base.nodes || [];
        const totalCount = nodes.length;

        const allUI = DATAMAP_UI.get('__ALL__');
        if (allUI) {
            allUI.input.checked = ACTIVE_DATAMAPS.size === 0;
            if (allUI.count) {
                allUI.count.textContent = datamapEnabled ? String(totalCount) : '--';
            }
            allUI.input.disabled = !datamapEnabled;
            allUI.wrapper.classList.toggle('disabled', !datamapEnabled);
            allUI.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.size === 0);
        }

        DATAMAP_CONFIGS.forEach((config) => {
            const count = nodes.reduce((acc, node) => acc + (datamapMatches(node, config) ? 1 : 0), 0);
            const ui = DATAMAP_UI.get(config.id);
            if (!ui) return;
            if (ui.count) {
                ui.count.textContent = datamapEnabled ? String(count) : '--';
            }
            ui.input.disabled = !datamapEnabled || count === 0;
            ui.wrapper.classList.toggle('disabled', !datamapEnabled || count === 0);
            ui.input.checked = ACTIVE_DATAMAPS.has(config.id);
            ui.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.has(config.id));
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        normalizeConfig: normalizeDatamapConfig,
        resolveConfigs: resolveDatamapConfigs,
        matches: datamapMatches,
        set: setDatamap,
        setColorMode: setNodeColorMode,
        apply: applyDatamap,
        updateControls: updateDatamapControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.normalizeDatamapConfig = DATAMAP.normalizeConfig;
window.resolveDatamapConfigs = DATAMAP.resolveConfigs;
window.datamapMatches = DATAMAP.matches;
window.setDatamap = DATAMAP.set;
window.setNodeColorMode = DATAMAP.setColorMode;
window.applyDatamap = DATAMAP.apply;
window.updateDatamapControls = DATAMAP.updateControls;

console.log('[Module] DATAMAP loaded - 7 functions');


// ═══ MODULE: modules/groups.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * GROUPS MODULE - Node grouping functionality
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Group creation, storage, rendering, and management.
 * Depends on: GROUPS, ACTIVE_GROUP_ID, SELECTED_NODE_IDS, GROUPS_STORAGE_KEY
 *
 * @module GROUPS_MODULE
 * @version 1.0.0
 */

window.GROUPS_MODULE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    function loadGroups() {
        window.GROUPS = [];
        try {
            const stored = localStorage.getItem(window.GROUPS_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    window.GROUPS = parsed;
                }
            }
        } catch (e) {
            // localStorage unavailable
        }
        window.GROUPS = window.GROUPS.filter(group => group && group.id && Array.isArray(group.node_ids));
        window.GROUPS.forEach(group => {
            if (group.visible === undefined) group.visible = true;
        });
    }

    function saveGroups() {
        try {
            localStorage.setItem(window.GROUPS_STORAGE_KEY, JSON.stringify(window.GROUPS));
        } catch (e) {
            // localStorage unavailable
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNextGroupColor() {
        const hue = (window.GROUPS.length * 137.5) % 360;
        return window.hslColor(hue, 65, 55);
    }

    function getGroupById(groupId) {
        return window.GROUPS.find(group => group.id === groupId) || null;
    }

    function getPrimaryGroupForNode(nodeId) {
        const visibleGroups = window.GROUPS.filter(group =>
            group.visible !== false && Array.isArray(group.node_ids) && group.node_ids.includes(nodeId)
        );
        if (!visibleGroups.length) return null;
        if (window.ACTIVE_GROUP_ID) {
            const active = visibleGroups.find(group => group.id === window.ACTIVE_GROUP_ID);
            if (active) return active;
        }
        return visibleGroups[0];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP LIST RENDERING
    // ═══════════════════════════════════════════════════════════════════════

    function renderGroupList() {
        const container = document.getElementById('group-list');
        if (!container) return;
        container.innerHTML = '';

        if (!window.GROUPS.length) {
            const empty = document.createElement('div');
            empty.style.fontSize = '9px';
            empty.style.color = 'rgba(255,255,255,0.4)';
            empty.textContent = 'No groups yet';
            container.appendChild(empty);
            return;
        }

        window.GROUPS.forEach(group => {
            const row = document.createElement('div');
            row.className = 'group-item';
            row.classList.toggle('active', group.id === window.ACTIVE_GROUP_ID);

            const dot = document.createElement('span');
            dot.className = 'group-color';
            dot.style.background = group.color || '#6fe8ff';

            const name = document.createElement('span');
            name.className = 'group-name';
            name.textContent = group.name || 'Group';

            const count = document.createElement('span');
            count.className = 'group-count';
            count.textContent = String((group.node_ids || []).length);

            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.className = 'group-toggle';
            toggle.checked = group.visible !== false;
            toggle.onchange = (e) => {
                e.stopPropagation();
                group.visible = toggle.checked;
                saveGroups();
                window.updateSelectionVisuals();
                renderGroupList();
            };

            row.onclick = (e) => {
                if (e.target === toggle) return;
                window.ACTIVE_GROUP_ID = group.id;
                renderGroupList();
                window.setSelection(group.node_ids || []);
                window.updateSelectionVisuals();
            };

            row.appendChild(dot);
            row.appendChild(name);
            row.appendChild(count);
            row.appendChild(toggle);
            container.appendChild(row);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP BUTTON STATE
    // ═══════════════════════════════════════════════════════════════════════

    function updateGroupButtonState() {
        const btn = document.getElementById('btn-create-group');
        if (!btn) return;
        const hasSelection = window.SELECTED_NODE_IDS.size > 0;
        btn.classList.toggle('disabled', !hasSelection);
        btn.disabled = !hasSelection;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CREATE GROUP FROM SELECTION
    // ═══════════════════════════════════════════════════════════════════════

    function createGroupFromSelection() {
        if (window.SELECTED_NODE_IDS.size === 0) return;
        const nodeIds = Array.from(window.SELECTED_NODE_IDS);
        const groupId = `group_${Date.now().toString(36)}`;
        const groupName = `Group ${window.GROUPS.length + 1}`;
        const groupColor = getNextGroupColor();
        window.GROUPS.push({
            id: groupId,
            name: groupName,
            color: groupColor,
            node_ids: nodeIds,
            visible: true
        });
        window.ACTIVE_GROUP_ID = groupId;
        saveGroups();
        renderGroupList();
        window.updateSelectionVisuals();
        window.showToast(`Created ${groupName} (${nodeIds.length})`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        load: loadGroups,
        save: saveGroups,
        getNextColor: getNextGroupColor,
        getById: getGroupById,
        getPrimaryForNode: getPrimaryGroupForNode,
        renderList: renderGroupList,
        updateButtonState: updateGroupButtonState,
        createFromSelection: createGroupFromSelection
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.loadGroups = GROUPS_MODULE.load;
window.saveGroups = GROUPS_MODULE.save;
window.getNextGroupColor = GROUPS_MODULE.getNextColor;
window.getGroupById = GROUPS_MODULE.getById;
window.getPrimaryGroupForNode = GROUPS_MODULE.getPrimaryForNode;
window.renderGroupList = GROUPS_MODULE.renderList;
window.updateGroupButtonState = GROUPS_MODULE.updateButtonState;
window.createGroupFromSelection = GROUPS_MODULE.createFromSelection;

console.log('[Module] GROUPS_MODULE loaded - 8 functions');


// ═══ MODULE: modules/hover.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HOVER MODULE - Node hover and click interactions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node hover panel updates, click handling, and interaction management.
 * Depends on: HOVERED_NODE, VIS_FILTERS, GRAPH_MODE, DM, Graph
 *
 * @module HOVER
 * @version 1.0.0
 */

window.HOVER = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE HOVER PANEL
    // ═══════════════════════════════════════════════════════════════════════

    function updateHoverPanel(node) {
        const hoverPanel = document.getElementById('hover-panel');
        const placeholder = document.getElementById('hover-placeholder');
        if (!hoverPanel) return;

        if (!node) {
            hoverPanel.classList.remove('has-node');
            if (placeholder) placeholder.style.display = '';
            return;
        }

        hoverPanel.classList.add('has-node');
        if (placeholder) placeholder.style.display = 'none';

        // Helper to set element text safely
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val ?? '--';
        };

        // Basic info
        setEl('hover-name', node.label || node.id || 'Unknown');
        setEl('hover-type', node.type || node.kind || '--');
        setEl('hover-file', node.file_path || '--');

        // Tier/Ring/Family
        setEl('hover-tier', window.getNodeTier ? window.getNodeTier(node) : (node.tier || '--'));
        setEl('hover-ring', window.getNodeRing ? window.getNodeRing(node) : (node.ring || '--'));
        setEl('hover-family', window.getNodeAtomFamily ? window.getNodeAtomFamily(node) : (node.atom_family || '--'));

        // Metrics
        setEl('hover-complexity', node.complexity ?? '--');
        setEl('hover-loc', node.lines_of_code ?? node.loc ?? '--');
        setEl('hover-fanin', node.in_degree ?? '--');
        setEl('hover-fanout', node.out_degree ?? '--');

        // Role
        setEl('hover-role', node.role || '--');

        // Code preview (if available)
        const codeEl = document.getElementById('hover-code');
        if (codeEl) {
            const code = node.body_source || node.body || '';
            codeEl.textContent = code ? code.substring(0, 500) : '// no source';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE HOVER
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeHover(node, data) {
        const filePanel = document.getElementById('file-panel');
        window.HOVERED_NODE = node || null;

        // Always update hover panel
        updateHoverPanel(node);

        // Guard: file-panel may not exist
        if (!filePanel) return;

        const VIS_FILTERS = window.VIS_FILTERS;
        if (!VIS_FILTERS.metadata.showFilePanel) {
            filePanel.classList.remove('visible');
            return;
        }

        if (!node) {
            setTimeout(() => {
                if (!window.fileMode) filePanel.classList.remove('visible');
            }, 300);
            return;
        }

        // Get file info from boundaries
        const boundaries = data.file_boundaries || [];
        const fileIdx = node.fileIdx;

        if (fileIdx < 0 || fileIdx >= boundaries.length) {
            return;
        }

        const fileInfo = boundaries[fileIdx];

        // Update panel content
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        };
        setEl('file-name', fileInfo.file_name || 'unknown');
        setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
        setEl('file-purpose', fileInfo.purpose || '--');
        setEl('file-atom-count', fileInfo.atom_count || 0);
        setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
        setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
        setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

        // Code preview from node body
        const code = node.body || '// no source available';
        setEl('file-code', code);

        // Show panel
        filePanel.classList.add('visible');
        if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE CLICK
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeClick(node, event) {
        if (!node) return;
        const additive = event && event.shiftKey;
        if (additive) {
            window.toggleSelection(node);
            return;
        }
        if (node.id) {
            window.setSelection([node.id]);
        }
        const GRAPH_MODE = window.GRAPH_MODE;
        if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
            window.toggleFileExpand(node.fileIdx);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updatePanel: updateHoverPanel,
        onNodeHover: handleNodeHover,
        onNodeClick: handleNodeClick
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateHoverPanel = HOVER.updatePanel;
window.handleNodeHover = HOVER.onNodeHover;
window.handleNodeClick = HOVER.onNodeClick;

console.log('[Module] HOVER loaded - 3 functions');


// ═══ MODULE: modules/flow.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * FLOW MODULE - Flow visualization mode with presets
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Flow mode highlights high-entropy nodes and edge transition probabilities.
 * Cycles through visual presets (EMBER, OCEAN, PLASMA, MATRIX, PULSE, AURORA).
 * Depends on: Graph, DM, THEME_CONFIG, APPEARANCE_CONFIG, FLOW_CONFIG
 *
 * @module FLOW
 * @version 1.0.0
 */

window.FLOW = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // PRESET COLOR/VALUE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getFlowPresetColor(presetName, property, fallback) {
        const schemes = (window.THEME_CONFIG && window.THEME_CONFIG.colors && window.THEME_CONFIG.colors.schemes) || {};
        const scheme = schemes[presetName.toLowerCase()] || {};
        return scheme[property] || fallback;
    }

    function getFlowPresetValue(presetName, property, fallback) {
        const presets = (typeof window.APPEARANCE_CONFIG !== 'undefined' && window.APPEARANCE_CONFIG && window.APPEARANCE_CONFIG['flow-presets']) || {};
        const preset = presets[presetName.toLowerCase()] || {};
        const value = preset[property];
        return (value !== undefined && value !== null) ? value : fallback;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FLOW PRESETS
    // ═══════════════════════════════════════════════════════════════════════

    const PRESETS = [
        {
            name: 'EMBER',
            highlightColor: getFlowPresetColor('EMBER', 'highlightColor', getFlowPresetValue('ember', 'highlightColor', '#ff8c00')),
            particleColor: getFlowPresetColor('EMBER', 'particleColor', getFlowPresetValue('ember', 'particleColor', '#ffaa00')),
            dimColor: getFlowPresetColor('EMBER', 'dimColor', getFlowPresetValue('ember', 'dimColor', '#331100')),
            edgeColor: getFlowPresetColor('EMBER', 'edgeColor', getFlowPresetValue('ember', 'edgeColor', '#ff6600')),
            particleCount: getFlowPresetValue('ember', 'particleCount', 3),
            particleWidth: getFlowPresetValue('ember', 'particleWidth', 2.5),
            particleSpeed: getFlowPresetValue('ember', 'particleSpeed', 0.008),
            edgeWidthScale: getFlowPresetValue('ember', 'edgeWidthScale', 3.0),
            sizeMultiplier: getFlowPresetValue('ember', 'sizeMultiplier', 1.8),
            edgeOpacityMin: getFlowPresetValue('ember', 'edgeOpacityMin', 0.3),
            dimOpacity: getFlowPresetValue('ember', 'dimOpacity', 0.05)
        },
        {
            name: 'OCEAN',
            highlightColor: getFlowPresetColor('OCEAN', 'highlightColor', getFlowPresetValue('ocean', 'highlightColor', '#00d4ff')),
            particleColor: getFlowPresetColor('OCEAN', 'particleColor', getFlowPresetValue('ocean', 'particleColor', '#4df0ff')),
            dimColor: getFlowPresetColor('OCEAN', 'dimColor', getFlowPresetValue('ocean', 'dimColor', '#001122')),
            edgeColor: getFlowPresetColor('OCEAN', 'edgeColor', getFlowPresetValue('ocean', 'edgeColor', '#0088cc')),
            particleCount: getFlowPresetValue('ocean', 'particleCount', 4),
            particleWidth: getFlowPresetValue('ocean', 'particleWidth', 2.0),
            particleSpeed: getFlowPresetValue('ocean', 'particleSpeed', 0.006),
            edgeWidthScale: getFlowPresetValue('ocean', 'edgeWidthScale', 2.5),
            sizeMultiplier: getFlowPresetValue('ocean', 'sizeMultiplier', 1.6),
            edgeOpacityMin: getFlowPresetValue('ocean', 'edgeOpacityMin', 0.25),
            dimOpacity: getFlowPresetValue('ocean', 'dimOpacity', 0.03)
        },
        {
            name: 'PLASMA',
            highlightColor: getFlowPresetColor('PLASMA', 'highlightColor', getFlowPresetValue('plasma', 'highlightColor', '#ff00ff')),
            particleColor: getFlowPresetColor('PLASMA', 'particleColor', getFlowPresetValue('plasma', 'particleColor', '#ff66ff')),
            dimColor: getFlowPresetColor('PLASMA', 'dimColor', getFlowPresetValue('plasma', 'dimColor', '#110011')),
            edgeColor: getFlowPresetColor('PLASMA', 'edgeColor', getFlowPresetValue('plasma', 'edgeColor', '#cc00cc')),
            particleCount: getFlowPresetValue('plasma', 'particleCount', 5),
            particleWidth: getFlowPresetValue('plasma', 'particleWidth', 3.0),
            particleSpeed: getFlowPresetValue('plasma', 'particleSpeed', 0.012),
            edgeWidthScale: getFlowPresetValue('plasma', 'edgeWidthScale', 4.0),
            sizeMultiplier: getFlowPresetValue('plasma', 'sizeMultiplier', 2.0),
            edgeOpacityMin: getFlowPresetValue('plasma', 'edgeOpacityMin', 0.35),
            dimOpacity: getFlowPresetValue('plasma', 'dimOpacity', 0.04)
        },
        {
            name: 'MATRIX',
            highlightColor: getFlowPresetColor('MATRIX', 'highlightColor', getFlowPresetValue('matrix', 'highlightColor', '#00ff00')),
            particleColor: getFlowPresetColor('MATRIX', 'particleColor', getFlowPresetValue('matrix', 'particleColor', '#88ff88')),
            dimColor: getFlowPresetColor('MATRIX', 'dimColor', getFlowPresetValue('matrix', 'dimColor', '#001100')),
            edgeColor: getFlowPresetColor('MATRIX', 'edgeColor', getFlowPresetValue('matrix', 'edgeColor', '#00cc00')),
            particleCount: getFlowPresetValue('matrix', 'particleCount', 6),
            particleWidth: getFlowPresetValue('matrix', 'particleWidth', 1.5),
            particleSpeed: getFlowPresetValue('matrix', 'particleSpeed', 0.015),
            edgeWidthScale: getFlowPresetValue('matrix', 'edgeWidthScale', 2.0),
            sizeMultiplier: getFlowPresetValue('matrix', 'sizeMultiplier', 1.4),
            edgeOpacityMin: getFlowPresetValue('matrix', 'edgeOpacityMin', 0.2),
            dimOpacity: getFlowPresetValue('matrix', 'dimOpacity', 0.02)
        },
        {
            name: 'PULSE',
            highlightColor: getFlowPresetColor('PULSE', 'highlightColor', getFlowPresetValue('pulse', 'highlightColor', '#ff4444')),
            particleColor: getFlowPresetColor('PULSE', 'particleColor', getFlowPresetValue('pulse', 'particleColor', '#ff8888')),
            dimColor: getFlowPresetColor('PULSE', 'dimColor', getFlowPresetValue('pulse', 'dimColor', '#110000')),
            edgeColor: getFlowPresetColor('PULSE', 'edgeColor', getFlowPresetValue('pulse', 'edgeColor', '#cc2222')),
            particleCount: getFlowPresetValue('pulse', 'particleCount', 2),
            particleWidth: getFlowPresetValue('pulse', 'particleWidth', 4.0),
            particleSpeed: getFlowPresetValue('pulse', 'particleSpeed', 0.004),
            edgeWidthScale: getFlowPresetValue('pulse', 'edgeWidthScale', 5.0),
            sizeMultiplier: getFlowPresetValue('pulse', 'sizeMultiplier', 2.2),
            edgeOpacityMin: getFlowPresetValue('pulse', 'edgeOpacityMin', 0.4),
            dimOpacity: getFlowPresetValue('pulse', 'dimOpacity', 0.06)
        },
        {
            name: 'AURORA',
            highlightColor: getFlowPresetColor('AURORA', 'highlightColor', getFlowPresetValue('aurora', 'highlightColor', '#33ccbb')),
            particleColor: getFlowPresetColor('AURORA', 'particleColor', getFlowPresetValue('aurora', 'particleColor', '#66ffee')),
            dimColor: getFlowPresetColor('AURORA', 'dimColor', getFlowPresetValue('aurora', 'dimColor', '#002222')),
            edgeColor: getFlowPresetColor('AURORA', 'edgeColor', getFlowPresetValue('aurora', 'edgeColor', '#22aa99')),
            particleCount: getFlowPresetValue('aurora', 'particleCount', 4),
            particleWidth: getFlowPresetValue('aurora', 'particleWidth', 2.2),
            particleSpeed: getFlowPresetValue('aurora', 'particleSpeed', 0.007),
            edgeWidthScale: getFlowPresetValue('aurora', 'edgeWidthScale', 3.5),
            sizeMultiplier: getFlowPresetValue('aurora', 'sizeMultiplier', 1.7),
            edgeOpacityMin: getFlowPresetValue('aurora', 'edgeOpacityMin', 0.28),
            dimOpacity: getFlowPresetValue('aurora', 'dimOpacity', 0.04)
        }
    ];

    let currentPresetIndex = 0;

    // ═══════════════════════════════════════════════════════════════════════
    // TOGGLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function toggle() {
        const flowMode = window.flowMode;

        // If already in flow mode, cycle to next preset
        if (flowMode) {
            currentPresetIndex = (currentPresetIndex + 1) % PRESETS.length;
            const preset = PRESETS[currentPresetIndex];
            console.log(`[Flow] Cycling to preset: ${preset.name}`);
            applyVisualization();
            window.showModeToast(`FLOW: ${preset.name}`);
            return;
        }

        window.flowMode = true;
        currentPresetIndex = 0;
        console.log('[Flow] Toggled to:', window.flowMode);

        // Sync BOTH potential buttons (Dock vs CommandBar)
        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.toggle('active', window.flowMode);

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.toggle('active', window.flowMode);

        // Show/hide flow legend
        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.toggle('visible', window.flowMode);

        // EXCLUSIVE MODE: Clear other visual noise
        if (typeof window.clearAllFileModes === 'function') {
            window.clearAllFileModes();
        }
        // Ensure standard file/hull buttons are off
        document.querySelectorAll('.file-mode-btn').forEach(b => b.classList.remove('active'));

        applyVisualization();
        const preset = PRESETS[currentPresetIndex];
        window.showModeToast(`FLOW: ${preset.name}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DISABLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function disable() {
        if (!window.flowMode) return;
        window.flowMode = false;
        currentPresetIndex = 0;

        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.remove('active');

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.remove('active');

        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.remove('visible');

        clearVisualization();
        window.showModeToast('Flow mode off');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyVisualization() {
        const Graph = window.Graph;
        const DM = window.DM;

        // Guard: Ensure Graph is ready
        if (!Graph || !DM) {
            console.warn('[Flow] Graph or DM not ready');
            return;
        }

        // Get current preset settings
        const preset = PRESETS[currentPresetIndex];
        const markov = DM.getMarkov ? DM.getMarkov() : {};
        const highEntropy = markov.high_entropy_nodes || [];

        // Use preset values (fallback to FLOW_CONFIG for topK/minWeight if not in preset)
        const flowCfg = window.FLOW_CONFIG || {};
        const highlightColor = preset.highlightColor;
        const particleColor = preset.particleColor;
        const sizeMult = preset.sizeMultiplier;
        const edgeScale = preset.edgeWidthScale;
        const particleCount = preset.particleCount;
        const particleWidth = preset.particleWidth;
        const particleSpeed = preset.particleSpeed;
        const edgeOpacityMin = preset.edgeOpacityMin;
        const dimOpacity = preset.dimOpacity;
        const topK = flowCfg.topKEdges || 3;
        const minWeight = flowCfg.minWeight || 0.01;

        // Build set of high entropy node names
        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();
        highEntropy.forEach(n => highEntropyNodes.add(n.node));
        window.highEntropyNodes = highEntropyNodes;

        const graphNodes = Graph.graphData().nodes;
        const graphLinks = Graph.graphData().links;

        // THRESHOLDING: Build a map of top-K outgoing edges per source node
        const edgesBySource = new Map();
        graphLinks.forEach(link => {
            const srcId = typeof link.source === 'object' ? link.source.id : link.source;
            if (!edgesBySource.has(srcId)) {
                edgesBySource.set(srcId, []);
            }
            edgesBySource.get(srcId).push(link);
        });

        // For each source, keep only top-K by markov_weight (transition probability)
        const visibleEdges = new Set();
        edgesBySource.forEach((edges, srcId) => {
            const sorted = edges
                .filter(e => (e.markov_weight || 0) >= minWeight)
                .sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0))
                .slice(0, topK);
            sorted.forEach(e => visibleEdges.add(e));
        });

        // Store original colors and sizes, then apply flow coloring
        const originalNodeColors = window.originalNodeColors || new Map();
        window.originalNodeColors = originalNodeColors;

        graphNodes.forEach(node => {
            if (!originalNodeColors.has(node.id)) {
                originalNodeColors.set(node.id, node.color);
            }
            // Restore original size first (in case switching presets)
            if (node._originalVal) {
                node.val = node._originalVal;
            } else {
                node._originalVal = node.val || 1;
            }
            // High entropy nodes highlighted (decision points)
            if (highEntropyNodes.has(node.name)) {
                node.color = highlightColor;
                node.val = node._originalVal * sizeMult;
            }
        });

        // Update link widths based on markov_weight (with amplification)
        const maxMarkov = Math.max(0.001, ...graphLinks.map(l => l.markov_weight || 0));
        const amplify = window.amplify || (x => x);

        Graph.linkWidth(link => {
            if (!visibleEdges.has(link)) return 0.1;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return 0.5 + amplified * edgeScale * 2;
        });

        // Update link opacity to emphasize important edges
        Graph.linkOpacity(link => {
            if (!visibleEdges.has(link)) return dimOpacity;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return edgeOpacityMin + amplified * (1.0 - edgeOpacityMin);
        });

        // Add directional particles only on visible edges
        Graph.linkDirectionalParticles(link => {
            if (!visibleEdges.has(link)) return 0;
            return particleCount;
        });
        Graph.linkDirectionalParticleWidth(particleWidth);
        Graph.linkDirectionalParticleSpeed(particleSpeed);
        Graph.linkDirectionalParticleColor(() => particleColor);

        // Update node coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }

        // Debug: count edges with markov weights
        const edgesWithMarkov = graphLinks.filter(l => l.markov_weight > 0).length;
        console.log(`[Flow] Preset: ${preset.name} | ${highEntropyNodes.size} high entropy nodes, ${visibleEdges.size} visible edges (top-${topK}), ${edgesWithMarkov}/${graphLinks.length} edges with markov`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CLEAR FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function clearVisualization() {
        const Graph = window.Graph;

        // Guard: Ensure Graph is ready
        if (!Graph) return;

        const graphNodes = Graph.graphData().nodes;
        const originalNodeColors = window.originalNodeColors || new Map();

        // Restore original node colors and sizes
        graphNodes.forEach(node => {
            if (originalNodeColors.has(node.id)) {
                node.color = originalNodeColors.get(node.id);
            }
            // Restore original size from saved value
            if (node._originalVal) {
                node.val = node._originalVal;
                delete node._originalVal;
            }
        });

        // Reset link widths
        Graph.linkWidth(1);

        // Reset link opacity
        Graph.linkOpacity(0.6);

        // Remove directional particles
        Graph.linkDirectionalParticles(0);

        // Update coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getPresetColor: getFlowPresetColor,
        getPresetValue: getFlowPresetValue,
        toggle: toggle,
        disable: disable,
        apply: applyVisualization,
        clear: clearVisualization,
        PRESETS: PRESETS,
        getCurrentPreset: () => PRESETS[currentPresetIndex],
        getCurrentPresetIndex: () => currentPresetIndex
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getFlowPresetColor = FLOW.getPresetColor;
window.getFlowPresetValue = FLOW.getPresetValue;
window.toggleFlowMode = FLOW.toggle;
window.disableFlowMode = FLOW.disable;
window.applyFlowVisualization = FLOW.apply;
window.clearFlowVisualization = FLOW.clear;
window.FLOW_PRESETS = FLOW.PRESETS;

console.log('[Module] FLOW loaded - 6 functions');


// ═══ MODULE: modules/ui-builders.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UI-BUILDERS MODULE - DOM element construction utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Factory functions for building common UI elements: checkboxes, toggles,
 * filter groups, and option selectors.
 *
 * @module UI_BUILDERS
 * @version 1.0.0
 */

window.UI_BUILDERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // COUNT COLLECTION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Collect counts by key from items
     * @param {Array} items - Items to count
     * @param {Function} keyFn - Function to extract key from item
     * @returns {Array} Array of [key, count] pairs sorted by count desc
     */
    function collectCounts(items, keyFn) {
        const counts = new Map();
        items.forEach(item => {
            const key = keyFn(item);
            if (!key) return;
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHECKBOX ROW
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a checkbox row element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Element ID
     * @param {string} label - Display label
     * @param {number|null} count - Optional count to display
     * @param {boolean} checked - Initial checked state
     * @param {Function} onChange - Callback when checkbox changes
     * @returns {HTMLInputElement} The checkbox input element
     */
    function buildCheckboxRow(container, id, label, count, checked, onChange) {
        const row = document.createElement('div');
        row.className = 'filter-item';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = id;
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('label');
        text.setAttribute('for', id);
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'filter-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        row.appendChild(input);
        row.appendChild(text);
        if (countEl.textContent) {
            row.appendChild(countEl);
        }
        container.appendChild(row);

        return input;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER GROUP
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a filter group with ALL checkbox and individual items
     * @param {string} containerId - Container element ID
     * @param {Array} items - Array of [value, count] pairs
     * @param {Set} stateSet - Set to track selected values
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildFilterGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const allId = `${containerId}-all`;
        let allCheckbox = null;

        allCheckbox = buildCheckboxRow(container, allId, 'ALL', null, true, (checked) => {
            stateSet.clear();
            if (checked) {
                items.forEach(([value]) => stateSet.add(value));
            }
            container.querySelectorAll('input[type="checkbox"]').forEach(box => {
                if (box.id !== allId) box.checked = checked;
            });
            onUpdate();
        });

        items.forEach(([value, count], index) => {
            const id = `${containerId}-${index}`;
            const checked = stateSet.has(value);
            buildCheckboxRow(container, id, value, count, checked, (isChecked) => {
                if (isChecked) {
                    stateSet.add(value);
                } else {
                    stateSet.delete(value);
                }
                const allChecked = items.every(([v]) => stateSet.has(v));
                allCheckbox.checked = allChecked;
                onUpdate();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a datamap toggle element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Toggle ID
     * @param {string} label - Display label
     * @param {boolean} checked - Initial checked state
     * @param {number|null} count - Optional count to display
     * @param {Function} onChange - Callback when toggle changes
     * @returns {Object} Object with wrapper, input, and count elements
     */
    function buildDatamapToggle(container, id, label, checked, count, onChange) {
        const wrapper = document.createElement('label');
        wrapper.className = 'datamap-toggle';
        wrapper.setAttribute('data-id', id);

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('span');
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'datamap-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        wrapper.appendChild(input);
        wrapper.appendChild(text);
        wrapper.appendChild(countEl);
        container.appendChild(wrapper);

        return { wrapper, input, count: countEl };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // EXCLUSIVE OPTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build exclusive (radio-like) options using checkboxes
     * @param {string} containerId - Container element ID
     * @param {Array} options - Array of {label, value} objects
     * @param {*} activeValue - Currently active value
     * @param {Function} onSelect - Callback when option is selected
     */
    function buildExclusiveOptions(containerId, options, activeValue, onSelect) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const inputs = [];
        options.forEach((option, index) => {
            const id = `${containerId}-${index}`;
            const input = buildCheckboxRow(
                container,
                id,
                option.label,
                null,
                option.value === activeValue,
                (checked) => {
                    if (!checked) {
                        input.checked = true;
                        return;
                    }
                    inputs.forEach(other => {
                        if (other !== input) other.checked = false;
                    });
                    onSelect(option.value);
                }
            );
            inputs.push(input);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHIP GROUP BUILDER - Filter chips with ALL toggle
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build chip buttons for filter groups
     * @param {string} containerId - Container element ID
     * @param {Map} items - Map of key -> count
     * @param {Set} stateSet - Set tracking selected items
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildChipGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        // "ALL" chip
        const allChip = document.createElement('button');
        allChip.className = 'chip active';
        allChip.textContent = 'ALL';
        allChip.addEventListener('click', () => {
            // Toggle all on/off
            const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
            if (allActive) {
                stateSet.clear();
                container.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
            } else {
                items.forEach((count, key) => stateSet.add(key));
                container.querySelectorAll('.chip').forEach(c => c.classList.add('active'));
            }
            if (onUpdate) onUpdate();
        });
        container.appendChild(allChip);

        // Individual chips
        items.forEach((count, key) => {
            const chip = document.createElement('button');
            chip.className = 'chip' + (stateSet.has(key) ? ' active' : '');
            chip.innerHTML = `${key}<span class="chip-count">${count}</span>`;
            chip.addEventListener('click', () => {
                if (stateSet.has(key)) {
                    stateSet.delete(key);
                    chip.classList.remove('active');
                } else {
                    stateSet.add(key);
                    chip.classList.add('active');
                }
                // Update "ALL" chip state
                const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
                allChip.classList.toggle('active', allActive);
                if (onUpdate) onUpdate();
            });
            container.appendChild(chip);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA CONTROLS - Visibility toggles
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build metadata visibility controls
     * @param {string} containerId - Container element ID
     * @param {Object} metadata - Metadata state object with boolean flags
     */
    function buildMetadataControls(containerId, metadata) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const toggles = [
            { id: 'meta-labels', label: 'LABELS', key: 'showLabels' },
            { id: 'meta-file-panel', label: 'FILE PANEL', key: 'showFilePanel' },
            { id: 'meta-report', label: 'REPORT', key: 'showReportPanel' },
            { id: 'meta-edges', label: 'EDGES', key: 'showEdges' }
        ];

        toggles.forEach((toggle) => {
            buildCheckboxRow(container, toggle.id, toggle.label, null, metadata[toggle.key], (checked) => {
                metadata[toggle.key] = checked;
                if (typeof applyMetadataVisibility === 'function') applyMetadataVisibility();
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPEARANCE SLIDERS - Pure UI builder (decoupled from global state)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build appearance sliders - PURE UI, no global dependencies
     *
     * @param {string} containerId - Container element ID
     * @param {Array} sliderDefs - Array of slider definitions:
     *   { id, label, min, max, step, value, onChange?, description?, className? }
     * @param {Function} globalOnChange - Optional global callback: (sliderId, newValue) => void
     *
     * Supports two patterns:
     * 1. Individual: Each sliderDef has its own onChange(value) handler
     * 2. Global: A single globalOnChange(sliderId, value) handles all
     */
    function buildAppearanceSliders(containerId, sliderDefs, globalOnChange) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row' + (def.className ? ' ' + def.className : '');

            // Header row with label and value
            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            const safeValue = def.value ?? def.min ?? 0;
            valueDisplay.textContent = safeValue.toFixed(def.step < 1 ? 2 : 0);
            header.appendChild(label);
            header.appendChild(valueDisplay);

            // The slider input
            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = safeValue;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = val.toFixed(def.step < 1 ? 2 : 0);
                // Support both patterns: individual onChange or global
                if (def.onChange) def.onChange(val);
                if (globalOnChange) globalOnChange(def.id, val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);

            // Optional description for meta-sliders
            if (def.description) {
                const desc = document.createElement('div');
                desc.className = 'slider-desc';
                desc.textContent = def.description;
                wrapper.appendChild(desc);
            }

            container.appendChild(wrapper);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        collectCounts: collectCounts,
        buildCheckboxRow: buildCheckboxRow,
        buildFilterGroup: buildFilterGroup,
        buildDatamapToggle: buildDatamapToggle,
        buildExclusiveOptions: buildExclusiveOptions,
        buildChipGroup: buildChipGroup,
        buildMetadataControls: buildMetadataControls,
        buildAppearanceSliders: buildAppearanceSliders
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.collectCounts = UI_BUILDERS.collectCounts;
window.buildCheckboxRow = UI_BUILDERS.buildCheckboxRow;
window.buildFilterGroup = UI_BUILDERS.buildFilterGroup;
window.buildDatamapToggle = UI_BUILDERS.buildDatamapToggle;
window.buildExclusiveOptions = UI_BUILDERS.buildExclusiveOptions;
window.buildChipGroup = UI_BUILDERS.buildChipGroup;
window.buildMetadataControls = UI_BUILDERS.buildMetadataControls;
// Note: buildAppearanceSliders shim is in app.js (orchestration layer)

console.log('[Module] UI_BUILDERS loaded - 8 functions (appearance sliders decoupled)');


// ═══ MODULE: modules/layout-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT-HELPERS MODULE - Layout stability and position utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Functions for saving/restoring node positions, freezing/unfreezing layout,
 * and calculating file positions.
 * Depends on: Graph, NODE_POSITION_CACHE, LAYOUT_FROZEN, IS_3D
 *
 * @module LAYOUT_HELPERS
 * @version 1.0.0
 */

window.LAYOUT_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // POSITION PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Save current node positions to cache
     */
    function saveNodePositions() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;
        if (!Graph || !cache) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined && node.y !== undefined) {
                cache.set(node.id, {
                    x: node.x, y: node.y, z: node.z || 0,
                    vx: node.vx || 0, vy: node.vy || 0, vz: node.vz || 0,
                    fx: node.fx, fy: node.fy, fz: node.fz
                });
            }
        });
    }

    /**
     * Restore node positions from cache
     * @param {Array} nodes - Nodes to restore positions for
     */
    function restoreNodePositions(nodes) {
        const cache = window.NODE_POSITION_CACHE;
        const frozen = window.LAYOUT_FROZEN;
        if (!cache) return;

        nodes.forEach(node => {
            const cached = cache.get(node.id);
            if (cached) {
                node.x = cached.x;
                node.y = cached.y;
                node.z = cached.z;
                node.vx = cached.vx;
                node.vy = cached.vy;
                node.vz = cached.vz;
                // Pin nodes in place when layout is frozen
                if (frozen) {
                    node.fx = cached.x;
                    node.fy = cached.y;
                    node.fz = cached.z;
                }
            }
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LAYOUT FREEZE/UNFREEZE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Freeze layout by pinning all nodes in place
     */
    function freezeLayout() {
        window.LAYOUT_FROZEN = true;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined) {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            }
        });
        Graph.cooldownTicks(0);  // Stop simulation immediately
    }

    /**
     * Unfreeze layout by unpinning all nodes
     */
    function unfreezeLayout() {
        window.LAYOUT_FROZEN = false;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            node.fx = undefined;
            node.fy = undefined;
            node.fz = undefined;
        });
    }

    /**
     * Reset layout - clear cache and reheat simulation
     */
    function resetLayout() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;

        // Clear position cache
        if (cache) cache.clear();

        // Unfreeze and restart simulation
        unfreezeLayout();

        if (Graph) {
            Graph.cooldownTicks(200);  // Allow simulation to run
            Graph.d3ReheatSimulation();
        }

        if (typeof window.showModeToast === 'function') {
            window.showModeToast('Layout reset - physics running');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LINK/FILE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get the ID of a link endpoint (source or target)
     * @param {Object} link - The link object
     * @param {string} side - 'source' or 'target'
     * @returns {string|undefined} The endpoint ID
     */
    function getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.id || endpoint;
        }
        return endpoint;
    }

    /**
     * Calculate target position for a file node in radial layout
     * @param {number} fileIdx - Index of the file
     * @param {number} totalFiles - Total number of files
     * @param {number} radius - Radius of the circle
     * @param {number} zSpacing - Z-axis spacing between files
     * @returns {Object} Position {x, y, z}
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpacing) {
        if (totalFiles <= 0) {
            return { x: 0, y: 0, z: 0 };
        }
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        const is3D = window.IS_3D;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: is3D ? (fileIdx - totalFiles / 2) * zSpacing : 0
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        savePositions: saveNodePositions,
        restorePositions: restoreNodePositions,
        freeze: freezeLayout,
        unfreeze: unfreezeLayout,
        reset: resetLayout,
        getLinkEndpointId: getLinkEndpointId,
        getFileTarget: getFileTarget
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.saveNodePositions = LAYOUT_HELPERS.savePositions;
window.restoreNodePositions = LAYOUT_HELPERS.restorePositions;
window.freezeLayout = LAYOUT_HELPERS.freeze;
window.unfreezeLayout = LAYOUT_HELPERS.unfreeze;
window.resetLayout = LAYOUT_HELPERS.reset;
window.getLinkEndpointId = LAYOUT_HELPERS.getLinkEndpointId;
window.getFileTarget = LAYOUT_HELPERS.getFileTarget;

console.log('[Module] LAYOUT_HELPERS loaded - 7 functions');


// ═══ MODULE: modules/spatial.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SPATIAL MODULE - Spatial algorithms and collision detection
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Spatial hashing for O(n) collision detection, convex hull calculation,
 * and node sampling utilities.
 * Depends on: IS_3D, FILE_CONTAINMENT, THREE
 *
 * @module SPATIAL
 * @version 1.0.0
 */

window.SPATIAL = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SAMPLING
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Sample nodes evenly if there are too many
     * @param {Array} nodes - Array of nodes
     * @param {number} maxPoints - Maximum number of points to return
     * @returns {Array} Sampled nodes
     */
    function sampleFileNodes(nodes, maxPoints) {
        if (nodes.length <= maxPoints) return nodes;
        const step = Math.ceil(nodes.length / maxPoints);
        return nodes.filter((_, idx) => idx % step === 0);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVEX HULL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build 2D convex hull using Andrew's monotone chain algorithm
     * @param {Array} points - Array of {x, y} points
     * @returns {Array|null} Hull points or null if insufficient points
     */
    function buildHull2D(points) {
        if (points.length < 3) return null;

        // Remove duplicates
        const unique = new Map();
        points.forEach(p => {
            const key = `${p.x.toFixed(4)},${p.y.toFixed(4)}`;
            if (!unique.has(key)) unique.set(key, p);
        });

        // Sort by x, then y
        const pts = Array.from(unique.values()).sort((a, b) => {
            if (a.x === b.x) return a.y - b.y;
            return a.x - b.x;
        });

        if (pts.length < 3) return null;

        // Cross product of vectors OA and OB
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

        // Build lower hull
        const lower = [];
        for (const p of pts) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                lower.pop();
            }
            lower.push(p);
        }

        // Build upper hull
        const upper = [];
        for (let i = pts.length - 1; i >= 0; i--) {
            const p = pts[i];
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                upper.pop();
            }
            upper.push(p);
        }

        // Remove last point of each half (it's the starting point of the other)
        upper.pop();
        lower.pop();

        return lower.concat(upper);
    }

    /**
     * Compute centroid of points
     * @param {Array} points - Array of THREE.Vector3-like objects
     * @returns {THREE.Vector3} Centroid
     */
    function computeCentroid(points) {
        const THREE = window.THREE;
        const centroid = new THREE.Vector3();
        points.forEach(p => centroid.add(p));
        return centroid.divideScalar(Math.max(1, points.length));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SPATIAL HASHING - O(n) collision detection
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build spatial hash grid for efficient neighbor queries
     * @param {Array} nodes - Array of nodes with x, y, z coordinates
     * @param {number} cellSize - Size of each grid cell
     * @returns {Map} Grid map with cell keys to node arrays
     */
    function buildSpatialGrid(nodes, cellSize) {
        const is3D = window.IS_3D;
        const grid = new Map();

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) grid.set(key, []);
            grid.get(key).push(node);
        });

        // Store for file containment
        if (window.FILE_CONTAINMENT) {
            window.FILE_CONTAINMENT.spatialGrid = grid;
        }

        return grid;
    }

    /**
     * Get keys for neighboring cells (3x3x3 in 3D, 3x3 in 2D)
     * @param {number} cellX - Cell X coordinate
     * @param {number} cellY - Cell Y coordinate
     * @param {number} cellZ - Cell Z coordinate
     * @returns {Array} Array of neighbor cell keys
     */
    function getNeighborCells(cellX, cellY, cellZ) {
        const is3D = window.IS_3D;
        const neighbors = [];

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = is3D ? -1 : 0; dz <= (is3D ? 1 : 0); dz++) {
                    neighbors.push(`${cellX + dx},${cellY + dy},${cellZ + dz}`);
                }
            }
        }

        return neighbors;
    }

    /**
     * Apply soft collision forces to push overlapping nodes apart
     * @param {Array} nodes - Array of nodes
     * @param {number} cellSize - Spatial grid cell size
     * @param {number} repulsionStrength - Strength of repulsion (0-1)
     */
    function applySoftCollisions(nodes, cellSize, repulsionStrength = 0.5) {
        const containment = window.FILE_CONTAINMENT;
        const is3D = window.IS_3D;

        if (!containment || !containment.collisionEnabled) return;

        const grid = buildSpatialGrid(nodes, cellSize);
        const minDist = 8;  // Minimum distance between particles
        const minDistSq = minDist * minDist;

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            if (!node.__physics) {
                node.__physics = { vx: 0, vy: 0, vz: 0 };
            }

            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const neighborKeys = getNeighborCells(cellX, cellY, cellZ);

            neighborKeys.forEach(key => {
                const cellNodes = grid.get(key);
                if (!cellNodes) return;

                cellNodes.forEach(other => {
                    if (other === node) return;

                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dz = is3D ? ((node.z || 0) - (other.z || 0)) : 0;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < minDistSq && distSq > 0.001) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        const force = (overlap / minDist) * repulsionStrength;

                        // Push apart along normal
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = is3D ? dz / dist : 0;

                        node.__physics.vx += nx * force;
                        node.__physics.vy += ny * force;
                        if (is3D) node.__physics.vz += nz * force;
                    }
                });
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        sampleFileNodes: sampleFileNodes,
        buildHull2D: buildHull2D,
        computeCentroid: computeCentroid,
        buildSpatialGrid: buildSpatialGrid,
        getNeighborCells: getNeighborCells,
        applySoftCollisions: applySoftCollisions
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.sampleFileNodes = SPATIAL.sampleFileNodes;
window.buildHull2D = SPATIAL.buildHull2D;
window.computeCentroid = SPATIAL.computeCentroid;
window.buildSpatialGrid = SPATIAL.buildSpatialGrid;
window.getNeighborCells = SPATIAL.getNeighborCells;
window.applySoftCollisions = SPATIAL.applySoftCollisions;

console.log('[Module] SPATIAL loaded - 6 functions');


// ═══ MODULE: modules/layout.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT MODULE - Unified UI Layout Engine
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * MIGRATED FROM: app.js HudLayoutManager (390 lines)
 * This is the SINGLE SOURCE OF TRUTH for UI layout intelligence.
 *
 * Features:
 *   - Panel placement with collision avoidance (from HudLayoutManager)
 *   - Component registration system (NEW)
 *   - Toast/control-bar collision detection (NEW)
 *   - Min-width graph validation (NEW)
 *   - Debug overlay with Ctrl+Shift+L (NEW)
 *
 * @module LAYOUT
 * @version 2.0.0
 * @confidence 94%
 */

window.LAYOUT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CONFIGURATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    const CONFIG = {
        MARGIN: 16,
        MIN_GRAPH_WIDTH: 320,
        REFLOW_THROTTLE_MS: 50,
        DEBUG_COLORS: {
            dock: 'rgba(100, 150, 255, 0.3)',
            overlay: 'rgba(255, 150, 100, 0.3)',
            floating: 'rgba(100, 255, 150, 0.3)',
            fixed: 'rgba(150, 150, 150, 0.3)'
        }
    };

    // Panels by priority (higher = more important, won't be moved)
    // MIGRATED from HudLayoutManager
    const FIXED_PANELS = ['top-left-header', 'stats-panel', 'metrics-panel', 'bottom-dock', 'report-panel', 'side-dock'];
    const DYNAMIC_PANELS = ['hover-panel', 'file-panel', 'selection-panel'];

    // ═══════════════════════════════════════════════════════════════════════
    // STATE
    // ═══════════════════════════════════════════════════════════════════════

    // Throttle state (from HudLayoutManager)
    let _rafPending = false;
    let _lastReflow = 0;

    // Mouse position for hover-panel placement (from HudLayoutManager)
    let _mouseX = 0;
    let _mouseY = 0;

    // Component registry (NEW)
    const _registry = new Map();

    // Debug overlay state (NEW)
    let _debugEnabled = false;
    let _debugOverlay = null;

    // ═══════════════════════════════════════════════════════════════════════
    // VIEWPORT & RECT UTILITIES (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get viewport rectangle with margins
     */
    function getViewport() {
        return {
            left: CONFIG.MARGIN,
            top: CONFIG.MARGIN,
            right: window.innerWidth - CONFIG.MARGIN,
            bottom: window.innerHeight - CONFIG.MARGIN,
            width: window.innerWidth - 2 * CONFIG.MARGIN,
            height: window.innerHeight - 2 * CONFIG.MARGIN
        };
    }

    /**
     * Check if sidebar is effectively "open" (occupying space)
     */
    function isSidebarOpen() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock) return false;
        const state = window.SIDEBAR_STATE;
        return (state && (state.locked || state.open)) ||
            sideDock.classList.contains('locked') ||
            sideDock.classList.contains('expanded') ||
            sideDock.matches(':hover');
    }

    /**
     * Get rectangle for an element (returns null if hidden/missing)
     */
    function getRect(el) {
        if (!el) return null;
        if (typeof el === 'string') {
            el = document.getElementById(el) || document.querySelector(el);
        }
        if (!el) return null;
        const style = window.getComputedStyle(el);
        if (style.display === 'none' || style.visibility === 'hidden') return null;
        const r = el.getBoundingClientRect();
        if (r.width === 0 && r.height === 0) return null;
        return { left: r.left, top: r.top, right: r.right, bottom: r.bottom, width: r.width, height: r.height };
    }

    /**
     * Get sidebar occupied region (full expanded width when open)
     */
    function getSidebarRect() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock || !isSidebarOpen()) return null;
        const sideWidth = parseInt(getComputedStyle(sideDock).getPropertyValue('--side-width')) || 260;
        return {
            left: 0,
            top: 0,
            right: 16 + sideWidth + 20,
            bottom: window.innerHeight,
            width: 16 + sideWidth + 20,
            height: window.innerHeight
        };
    }

    /**
     * Get all occupied rectangles (fixed panels + sidebar when open)
     */
    function getOccupiedRects() {
        const rects = [];

        // Sidebar takes priority when open
        const sidebarRect = getSidebarRect();
        if (sidebarRect) rects.push(sidebarRect);

        // Fixed panels
        FIXED_PANELS.forEach(id => {
            if (id === 'side-dock') return;
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (rect) rects.push(rect);
        });

        // Top-left header (special case - class-based)
        const topLeft = document.querySelector('.top-left');
        const topLeftRect = getRect(topLeft);
        if (topLeftRect) rects.push(topLeftRect);

        return rects;
    }

    /**
     * Calculate overlap area between two rectangles
     */
    function overlapArea(r1, r2) {
        if (!r1 || !r2) return 0;
        const xOverlap = Math.max(0, Math.min(r1.right, r2.right) - Math.max(r1.left, r2.left));
        const yOverlap = Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
        return xOverlap * yOverlap;
    }

    /**
     * Check if rect is fully inside viewport
     */
    function isInsideViewport(rect, viewport) {
        return rect.left >= viewport.left &&
            rect.top >= viewport.top &&
            rect.right <= viewport.right &&
            rect.bottom <= viewport.bottom;
    }

    /**
     * Clamp position to keep panel inside viewport
     */
    function clampToViewport(pos, panelWidth, panelHeight, viewport) {
        return {
            left: Math.max(viewport.left, Math.min(pos.left, viewport.right - panelWidth)),
            top: Math.max(viewport.top, Math.min(pos.top, viewport.bottom - panelHeight))
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CANDIDATE GENERATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Generate candidate positions for file panel
     */
    function getFilePanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Generate candidate positions for selection panel
     */
    function getSelectionPanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Get screen centroid of selected nodes
     */
    function getSelectionCentroid() {
        const Graph = window.Graph;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (!Graph || !Graph.graphData || !selectedIds || selectedIds.size === 0) return null;

        const nodes = Graph.graphData().nodes || [];
        const selectedNodes = nodes.filter(n => selectedIds.has(n.id));
        if (selectedNodes.length === 0) return null;

        let sumX = 0, sumY = 0, sumZ = 0;
        selectedNodes.forEach(n => {
            sumX += n.x || 0;
            sumY += n.y || 0;
            sumZ += n.z || 0;
        });
        const centroid3D = {
            x: sumX / selectedNodes.length,
            y: sumY / selectedNodes.length,
            z: sumZ / selectedNodes.length
        };

        const camera = Graph.camera();
        if (!camera || !window.THREE) return null;
        const vector = new window.THREE.Vector3(centroid3D.x, centroid3D.y, centroid3D.z);
        vector.project(camera);
        return {
            x: (vector.x * 0.5 + 0.5) * window.innerWidth,
            y: (-vector.y * 0.5 + 0.5) * window.innerHeight
        };
    }

    /**
     * Generate candidate positions for hover panel
     */
    function getHoverPanelCandidates(mouseX, mouseY, panelWidth, panelHeight) {
        const vp = getViewport();
        const offset = 16;

        let anchorX = mouseX;
        let anchorY = mouseY;

        const hoveredNode = window.HOVERED_NODE;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (hoveredNode && selectedIds && selectedIds.has(hoveredNode.id)) {
            const centroid = getSelectionCentroid();
            if (centroid) {
                anchorX = mouseX * 0.3 + centroid.x * 0.7;
                anchorY = mouseY * 0.3 + centroid.y * 0.7;
            }
        }

        const sidebarOpen = isSidebarOpen();
        const sidebarRect = sidebarOpen ? getSidebarRect() : null;
        const minLeft = sidebarRect ? sidebarRect.right + offset : vp.left;

        let candidates = [
            { left: anchorX + offset, top: anchorY - panelHeight - offset },
            { left: anchorX + offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY - panelHeight - offset }
        ];

        if (sidebarRect) {
            candidates = candidates.map(c => ({
                left: Math.max(c.left, minLeft),
                top: c.top
            }));
        }

        return candidates;
    }

    /**
     * Update mouse position
     */
    function updateMousePosition(x, y) {
        _mouseX = x;
        _mouseY = y;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PANEL PLACEMENT (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Place a panel at the best position (least overlap)
     */
    function placePanel(panelEl, candidates, occupiedRects) {
        if (!panelEl) return null;

        const rect = panelEl.getBoundingClientRect();
        const panelWidth = rect.width || 400;
        const panelHeight = rect.height || 350;
        const viewport = getViewport();

        let bestPos = candidates[0];
        let bestOverlap = Infinity;

        for (const pos of candidates) {
            const clampedPos = clampToViewport(pos, panelWidth, panelHeight, viewport);
            const panelRect = {
                left: clampedPos.left,
                top: clampedPos.top,
                right: clampedPos.left + panelWidth,
                bottom: clampedPos.top + panelHeight
            };

            let totalOverlap = 0;
            for (const occRect of occupiedRects) {
                totalOverlap += overlapArea(panelRect, occRect);
            }

            if (!isInsideViewport(panelRect, viewport)) {
                totalOverlap += 10000;
            }

            if (totalOverlap < bestOverlap) {
                bestOverlap = totalOverlap;
                bestPos = clampedPos;
                if (totalOverlap === 0) break;
            }
        }

        return bestPos;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST/CONTROL-BAR COLLISION (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Check and resolve toast/control-bar collision
     * Returns offset to apply to toast if collision detected
     */
    function resolveToastCollision() {
        const toast = document.getElementById('toast') ||
                      document.getElementById('hud-toast') ||
                      document.getElementById('mode-toast');
        const controlBar = document.querySelector('.control-bar');

        if (!toast || !controlBar) return 0;

        const toastRect = getRect(toast);
        const barRect = getRect(controlBar);

        if (!toastRect || !barRect) return 0;

        const overlap = overlapArea(toastRect, barRect);
        if (overlap > 0) {
            // Move toast above control bar
            const offset = barRect.height + CONFIG.MARGIN;
            console.log(`[LAYOUT] Toast/control-bar collision: ${overlap}px², offset: -${offset}px`);
            return -offset;
        }
        return 0;
    }

    /**
     * Apply toast offset if needed
     */
    function applyToastOffset() {
        const offset = resolveToastCollision();
        if (offset !== 0) {
            const toast = document.getElementById('toast') ||
                          document.getElementById('hud-toast');
            if (toast) {
                toast.style.transform = `translateX(-50%) translateY(${offset}px)`;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MIN-WIDTH VALIDATOR (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Validate graph has minimum width, adjust sidebars if needed
     */
    function validateGraphWidth() {
        const leftSidebar = document.getElementById('left-sidebar');
        const rightSidebar = document.getElementById('right-sidebar');
        const viewport = getViewport();

        const leftWidth = leftSidebar ? (getRect(leftSidebar)?.width || 0) : 0;
        const rightWidth = rightSidebar ? (getRect(rightSidebar)?.width || 0) : 0;
        const graphWidth = viewport.width - leftWidth - rightWidth;

        if (graphWidth < CONFIG.MIN_GRAPH_WIDTH) {
            const deficit = CONFIG.MIN_GRAPH_WIDTH - graphWidth;
            console.warn(`[LAYOUT] Graph width ${graphWidth}px < ${CONFIG.MIN_GRAPH_WIDTH}px minimum`);

            // Try to reduce right sidebar
            if (rightSidebar && rightWidth > 200) {
                const newWidth = Math.max(200, rightWidth - deficit);
                document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
                return { adjusted: true, component: 'right-sidebar', newWidth };
            }
        }
        return { adjusted: false };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // REFLOW (from HudLayoutManager, enhanced)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Reflow all dynamic panels
     */
    function reflow() {
        const now = Date.now();
        if (now - _lastReflow < CONFIG.REFLOW_THROTTLE_MS) {
            if (!_rafPending) {
                _rafPending = true;
                requestAnimationFrame(() => {
                    _rafPending = false;
                    reflow();
                });
            }
            return;
        }
        _lastReflow = now;

        const occupiedRects = getOccupiedRects();

        // Place hover panel first (higher priority)
        const hoverPanel = document.getElementById('hover-panel');
        let hoverPanelRect = null;
        if (hoverPanel && hoverPanel.classList.contains('visible')) {
            const hoverWidth = hoverPanel.offsetWidth || 280;
            const hoverHeight = hoverPanel.offsetHeight || 200;
            const candidates = getHoverPanelCandidates(_mouseX, _mouseY, hoverWidth, hoverHeight);
            const pos = placePanel(hoverPanel, candidates, occupiedRects);
            if (pos) {
                hoverPanel.style.left = pos.left + 'px';
                hoverPanel.style.top = pos.top + 'px';
                hoverPanel.style.right = 'auto';
                hoverPanelRect = {
                    left: pos.left, top: pos.top,
                    right: pos.left + hoverWidth, bottom: pos.top + hoverHeight
                };
            }
        }

        const filePanelOccupied = [...occupiedRects];
        if (hoverPanelRect) filePanelOccupied.push(hoverPanelRect);

        // Place selection panel
        const selectionPanel = document.getElementById('selection-panel');
        if (selectionPanel && selectionPanel.classList.contains('visible')) {
            const candidates = getSelectionPanelCandidates(
                selectionPanel.offsetWidth || 320,
                selectionPanel.offsetHeight || 280
            );
            const pos = placePanel(selectionPanel, candidates, filePanelOccupied);
            if (pos) {
                selectionPanel.style.left = pos.left + 'px';
                selectionPanel.style.top = pos.top + 'px';
                selectionPanel.style.right = 'auto';
                filePanelOccupied.push({
                    left: pos.left, top: pos.top,
                    right: pos.left + (selectionPanel.offsetWidth || 320),
                    bottom: pos.top + (selectionPanel.offsetHeight || 280)
                });
            }
        }

        // Place file panel
        const filePanel = document.getElementById('file-panel');
        if (filePanel && filePanel.classList.contains('visible')) {
            const candidates = getFilePanelCandidates(
                filePanel.offsetWidth || 400,
                filePanel.offsetHeight || 350
            );
            const pos = placePanel(filePanel, candidates, filePanelOccupied);
            if (pos) {
                filePanel.style.left = pos.left + 'px';
                filePanel.style.top = pos.top + 'px';
                filePanel.style.bottom = 'auto';
            }
        }

        // NEW: Check toast/control-bar collision
        applyToastOffset();

        // NEW: Validate graph width
        validateGraphWidth();

        // NEW: Update debug overlay
        if (_debugEnabled) updateDebugOverlay();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DEBUG OVERLAY (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle debug overlay
     */
    function toggleDebugOverlay() {
        _debugEnabled = !_debugEnabled;

        if (_debugEnabled) {
            if (!_debugOverlay) {
                _debugOverlay = document.createElement('div');
                _debugOverlay.id = 'layout-debug-overlay';
                _debugOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none; z-index: 10001;
                `;
                document.body.appendChild(_debugOverlay);
            }
            updateDebugOverlay();
            console.log('[LAYOUT] Debug overlay ON (Ctrl+Shift+L)');
        } else {
            if (_debugOverlay) {
                _debugOverlay.remove();
                _debugOverlay = null;
            }
            console.log('[LAYOUT] Debug overlay OFF');
        }
    }

    /**
     * Update debug overlay with current component bounds
     */
    function updateDebugOverlay() {
        if (!_debugOverlay) return;

        let html = '';
        const allPanels = [...FIXED_PANELS, ...DYNAMIC_PANELS, 'toast', 'control-bar', 'left-sidebar', 'right-sidebar'];

        allPanels.forEach(id => {
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (!rect) return;

            const kind = FIXED_PANELS.includes(id) ? 'fixed' :
                         DYNAMIC_PANELS.includes(id) ? 'floating' : 'overlay';
            const color = CONFIG.DEBUG_COLORS[kind] || 'rgba(128,128,128,0.3)';

            html += `
                <div style="
                    position: fixed;
                    left: ${rect.left}px; top: ${rect.top}px;
                    width: ${rect.width}px; height: ${rect.height}px;
                    background: ${color};
                    border: 1px solid ${color.replace('0.3', '0.8')};
                    font-size: 10px; color: white; text-shadow: 0 0 2px black;
                    padding: 2px 4px; box-sizing: border-box; overflow: hidden;
                ">${id}</div>
            `;
        });

        _debugOverlay.innerHTML = html;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COMPONENT REGISTRATION (NEW - for future explicit constraints)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Register a component (for explicit constraint tracking)
     */
    function register(descriptor) {
        const { id, selector, kind = 'dock' } = descriptor;
        if (!id) return null;

        let element = typeof selector === 'string' ?
            (document.getElementById(selector.replace('#', '')) || document.querySelector(selector)) :
            selector;

        _registry.set(id, { ...descriptor, element });
        console.log(`[LAYOUT] Registered: ${id} (${kind})`);
        return _registry.get(id);
    }

    /**
     * Get registered component
     */
    function get(id) {
        return _registry.get(id) || null;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize layout system
     */
    function init() {
        // Window resize
        window.addEventListener('resize', () => reflow());

        // Track mouse position
        window.addEventListener('mousemove', (e) => {
            updateMousePosition(e.clientX, e.clientY);
        }, { passive: true });

        // Sidebar state changes
        const sideDock = document.getElementById('side-dock');
        if (sideDock) {
            sideDock.addEventListener('mouseenter', () => reflow());
            sideDock.addEventListener('mouseleave', () => {
                setTimeout(() => reflow(), 200);
            });
        }

        // Debug overlay shortcut (Ctrl+Shift+L)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                e.preventDefault();
                toggleDebugOverlay();
            }
        });

        console.log('[LAYOUT] Initialized (replaces HudLayoutManager)');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Core utilities
        getViewport,
        getRect,
        overlapArea,
        isInsideViewport,
        clampToViewport,

        // Panel placement (backward compatible with HudLayoutManager)
        getOccupiedRects,
        placePanel,
        getFilePanelCandidates,
        getSelectionPanelCandidates,
        getHoverPanelCandidates,
        getSelectionCentroid,
        updateMousePosition,

        // Main entry points
        reflow,
        init,

        // NEW: Validation
        validateGraphWidth,
        resolveToastCollision,

        // NEW: Debug
        toggleDebugOverlay,

        // NEW: Registration
        register,
        get,

        // Config (read-only)
        CONFIG: Object.freeze({ ...CONFIG })
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY: HudLayoutManager alias
// ═══════════════════════════════════════════════════════════════════════════

window.HudLayoutManager = LAYOUT;
window.Layout = LAYOUT;

console.log('[Module] LAYOUT loaded - Unified Layout Engine v2.0.0');


// ═══ MODULE: modules/hud.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HUD MODULE - Heads-up display management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles HUD fade behavior and stats panel updates.
 * Depends on: DOM elements (stat-nodes, stat-edges, stat-entropy, etc.)
 *
 * @module HUD
 * @version 1.0.0
 */

window.HUD = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // HUD FADE BEHAVIOR
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup HUD auto-fade on idle
     * Fades HUD elements after period of inactivity
     */
    function setupFade() {
        const idleDelay = 2200;
        let timer = null;

        const activate = () => {
            document.body.classList.remove('hud-quiet');
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                document.body.classList.add('hud-quiet');
            }, idleDelay);
        };

        ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach((evt) => {
            window.addEventListener(evt, activate, { passive: true });
        });

        activate();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATS UPDATES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all HUD stats elements
     * @param {Object} data - Graph data with nodes, links, meta
     */
    function updateStats(data) {
        if (!data) return;

        // Stats panel: NODES, EDGES, ENTROPY
        const nodeCount = (data.nodes || []).length;
        const edgeCount = (data.links || []).length;

        const statNodes = document.getElementById('stat-nodes');
        const statEdges = document.getElementById('stat-edges');
        const statEntropy = document.getElementById('stat-entropy');

        if (statNodes) statNodes.textContent = nodeCount.toLocaleString();
        if (statEdges) statEdges.textContent = edgeCount.toLocaleString();
        if (statEntropy) {
            const entropy = data.meta?.entropy ?? data.entropy ?? '--';
            statEntropy.textContent = typeof entropy === 'number' ? entropy.toFixed(2) : entropy;
        }

        // Header panel: target name and timestamp
        const targetName = document.getElementById('target-name');
        const timestamp = document.getElementById('timestamp');

        if (targetName) {
            const target = data.meta?.target || data.target || 'Unknown';
            // Show just the last part of the path
            const shortTarget = target.split('/').pop() || target;
            targetName.textContent = shortTarget;
        }

        if (timestamp) {
            const ts = data.meta?.timestamp || data.timestamp || '';
            // Format: 2024-01-15T10:30:00 -> 2024-01-15 10:30
            const formatted = ts.replace('T', ' ').substring(0, 16);
            timestamp.textContent = formatted || 'Live';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupFade: setupFade,
        updateStats: updateStats
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupHudFade = HUD.setupFade;
window.updateHudStats = HUD.updateStats;

console.log('[Module] HUD loaded - 2 functions');


// ═══ MODULE: modules/dimension.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DIMENSION MODULE - 2D/3D dimension switching with animation
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles smooth animated transitions between 2D and 3D graph views.
 * Depends on: Graph, IS_3D, DIMENSION_TRANSITION, stableSeed, stableZ,
 *             fileMode, GRAPH_MODE, applyFileVizMode
 *
 * @module DIMENSION
 * @version 1.1.0
 */

window.DIMENSION = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // DIMENSION TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle between 2D and 3D dimensions
     */
    function toggle() {
        if (window.DIMENSION_TRANSITION) return;
        window.DIMENSION_TRANSITION = true;

        const target3d = !window.IS_3D;
        const button = document.getElementById('btn-2d');

        animateChange(target3d, () => {
            window.IS_3D = target3d;
            window.DIMENSION_TRANSITION = false;
            if (button) button.textContent = window.IS_3D ? '2D' : '3D';

            // Re-apply file viz mode if active
            if (window.fileMode && window.GRAPH_MODE === 'atoms') {
                if (typeof window.applyFileVizMode === 'function') {
                    window.applyFileVizMode();
                }
            }
        });
    }

    /**
     * Setup the dimension toggle button
     */
    function setup() {
        const button = document.getElementById('btn-2d');
        if (!button) return;

        const updateLabel = () => {
            button.textContent = window.IS_3D ? '2D' : '3D';
        };
        updateLabel();
        button.onclick = toggle;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ANIMATED TRANSITION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Animate transition between 2D and 3D
     * @param {boolean} target3d - Whether transitioning to 3D
     * @param {Function} done - Callback when animation completes
     */
    function animateChange(target3d, done) {
        const Graph = window.Graph;
        // STARFIELD & BLOOM removed - nodes ARE the stars, post-processing not in r149+ UMD builds
        const stableSeed = window.stableSeed;
        const stableZ = window.stableZ;

        const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
        const startTime = performance.now();
        const duration = 3000;
        const delayMin = 0;
        const delayMax = 2000;
        const lockPositionsAfterTransition = true;

        const easeInOutSine = (t) => 0.5 - 0.5 * Math.cos(Math.PI * t);

        // Store previous simulation settings
        const previousVelocityDecay = (Graph && Graph.d3VelocityDecay) ? Graph.d3VelocityDecay() : null;
        const previousAlphaTarget = (Graph && Graph.d3AlphaTarget) ? Graph.d3AlphaTarget() : null;
        const previousCooldownTicks = (Graph && Graph.cooldownTicks) ? Graph.cooldownTicks() : null;
        const previousCooldownTime = (Graph && Graph.cooldownTime) ? Graph.cooldownTime() : null;

        // Freeze simulation during transition
        if (Graph && Graph.cooldownTicks) Graph.cooldownTicks(Infinity);
        if (Graph && Graph.cooldownTime) Graph.cooldownTime(Infinity);
        if (Graph && Graph.d3VelocityDecay) Graph.d3VelocityDecay(1);
        if (Graph && Graph.d3AlphaTarget) Graph.d3AlphaTarget(0);
        if (Graph && Graph.d3ReheatSimulation) Graph.d3ReheatSimulation();

        // Initialize node animation state
        nodes.forEach((node) => {
            node.__xStart = node.x || 0;
            node.__yStart = node.y || 0;
            node.__zStart = node.z || 0;
            node.__delay = delayMin + (stableSeed(node, 'delay') * (delayMax - delayMin));
            node.fx = node.__xStart;
            node.fy = node.__yStart;
            node.vx = 0;
            node.vy = 0;
            node.vz = 0;

            if (target3d) {
                if (node.__z3d === undefined || node.__z3d === null) {
                    node.__z3d = node.__zStart || stableZ(node);
                }
            } else {
                node.__z3d = node.__zStart;
            }
        });

        const maxDistance = nodes.reduce((acc, node) => Math.max(acc, Math.abs(node.__zStart || 0)), 1);

        Graph.numDimensions(3);

        const animate = (now) => {
            const elapsed = now - startTime;
            const t = Math.min(1, elapsed / duration);

            // Animate each node's Z position
            nodes.forEach((node) => {
                const startZ = node.__zStart || 0;
                const targetZ = target3d ? (node.__z3d || 0) : 0;
                const delay = node.__delay || 0;
                const localDuration = Math.max(600, duration - delay);
                const localElapsed = Math.max(0, elapsed - delay);
                const localT = Math.min(1, localElapsed / localDuration);
                const localEase = easeInOutSine(localT);
                const distanceRatio = maxDistance > 0 ? Math.abs(startZ) / maxDistance : 0;
                const distanceCurve = 0.6 + (1 - distanceRatio) * 0.6;
                const progress = Math.pow(localEase, distanceCurve);
                const nextZ = startZ + (targetZ - startZ) * progress;
                node.z = nextZ;
                node.fz = nextZ;
                node.vz = 0;
            });

            if (t < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - clean up
                nodes.forEach((node) => {
                    delete node.fz;
                    delete node.__zStart;
                    delete node.__xStart;
                    delete node.__yStart;
                    delete node.__delay;

                    if (!target3d) {
                        node.z = 0;
                        node.fz = 0;
                    } else if (lockPositionsAfterTransition) {
                        node.z = node.__z3d || node.z || 0;
                        node.fz = node.z;
                    } else {
                        delete node.fx;
                        delete node.fy;
                    }
                });

                Graph.numDimensions(target3d ? 3 : 2);

                // Restore simulation settings
                if (Graph && Graph.d3VelocityDecay && previousVelocityDecay !== null) {
                    Graph.d3VelocityDecay(previousVelocityDecay);
                }
                if (Graph && Graph.d3AlphaTarget && previousAlphaTarget !== null) {
                    Graph.d3AlphaTarget(previousAlphaTarget);
                }
                if (Graph && Graph.cooldownTicks && previousCooldownTicks !== null) {
                    Graph.cooldownTicks(previousCooldownTicks);
                }
                if (Graph && Graph.cooldownTime && previousCooldownTime !== null) {
                    Graph.cooldownTime(previousCooldownTime);
                }

                if (done) done();
            }
        };

        requestAnimationFrame(animate);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        toggle: toggle,
        setup: setup,
        animateChange: animateChange
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.toggleDimensions = DIMENSION.toggle;
window.setupDimensionToggle = DIMENSION.setup;
window.animateDimensionChange = DIMENSION.animateChange;

console.log('[Module] DIMENSION loaded - 3 functions');


// ═══ MODULE: modules/report.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * REPORT MODULE - Report panel, AI insights, and metrics display
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles the brain download report, AI insights panel, and metrics/KPI display.
 * Depends on: escapeHtml (from utils.js), DOM elements
 *
 * @module REPORT
 * @version 1.0.0
 */

window.REPORT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BRAIN DOWNLOAD REPORT
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the brain download report panel
     * @param {Object} data - Data object with brain_download field
     */
    function setupReport(data) {
        const panel = document.getElementById('report-panel');
        const content = document.getElementById('report-content');
        // Guard: elements may not exist in minimal template
        if (!content) return;
        const report = (data && data.brain_download) ? data.brain_download : '';
        content.textContent = report || 'No report available.';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // AI INSIGHTS PANEL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the AI insights panel
     * @param {Object} data - Data object with ai_insights field
     */
    function setupAIInsights(data) {
        const escapeHtml = window.escapeHtml || ((s) => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])));

        const panel = document.getElementById('insights-panel');
        const content = document.getElementById('insights-content');
        const btn = document.getElementById('btn-insights');

        const insights = (data && data.ai_insights) ? data.ai_insights : null;

        if (!insights) {
            // Hide the button if no insights available
            if (btn) btn.style.display = 'none';
            return;
        }

        // Show the button
        if (btn) btn.style.display = 'inline-flex';

        // Render insights
        let html = '';

        // Executive Summary
        if (insights.executive_summary) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Executive Summary</div>
                <div class="insights-summary">${escapeHtml(insights.executive_summary)}</div>
            </div>`;
        }

        // Patterns Detected
        if (insights.patterns_detected && insights.patterns_detected.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Patterns Detected</div>`;
            for (const pattern of insights.patterns_detected) {
                const confidencePercent = Math.round((pattern.confidence || 0) * 100);
                html += `<div class="insights-pattern">
                    <div class="insights-pattern-header">
                        <span class="insights-pattern-name">${escapeHtml(pattern.pattern_name || 'Unknown')}</span>
                        <span class="insights-pattern-type ${pattern.pattern_type || ''}">${escapeHtml(pattern.pattern_type || '')}</span>
                    </div>
                    <div class="insights-confidence">
                        <div class="insights-confidence-bar">
                            <div class="insights-confidence-fill" style="width: ${confidencePercent}%"></div>
                        </div>
                        <span>${confidencePercent}%</span>
                    </div>
                    ${pattern.evidence ? `<div class="insights-pattern-evidence">${escapeHtml(pattern.evidence)}</div>` : ''}
                    ${pattern.recommendation ? `<div class="insights-pattern-evidence" style="color: var(--color-accent-secondary);">Tip: ${escapeHtml(pattern.recommendation)}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Refactoring Opportunities
        if (insights.refactoring_opportunities && insights.refactoring_opportunities.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Refactoring Opportunities</div>`;
            for (const refactor of insights.refactoring_opportunities) {
                html += `<div class="insights-refactor">
                    <div class="insights-refactor-title">
                        ${escapeHtml(refactor.title || 'Untitled')}
                        <span class="insights-refactor-priority ${refactor.priority || 'LOW'}">${refactor.priority || 'LOW'}</span>
                    </div>
                    ${refactor.description ? `<div class="insights-refactor-desc">${escapeHtml(refactor.description)}</div>` : ''}
                    ${refactor.affected_files && refactor.affected_files.length > 0 ?
                        `<div class="insights-refactor-desc" style="margin-top: 4px; color: var(--color-text-muted);">Files: ${refactor.affected_files.slice(0, 3).map(f => escapeHtml(f)).join(', ')}${refactor.affected_files.length > 3 ? '...' : ''}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Topology Analysis
        if (insights.topology_analysis) {
            const topo = insights.topology_analysis;
            html += `<div class="insights-section">
                <div class="insights-section-title">Topology Analysis</div>
                ${topo.shape_interpretation ? `<div class="insights-summary">${escapeHtml(topo.shape_interpretation)}</div>` : ''}
                ${topo.health_assessment ? `<div class="insights-pattern-evidence">Health: ${escapeHtml(topo.health_assessment)}</div>` : ''}
                ${topo.coupling_analysis ? `<div class="insights-pattern-evidence">Coupling: ${escapeHtml(topo.coupling_analysis)}</div>` : ''}
            </div>`;
        }

        // Risk Areas
        if (insights.risk_areas && insights.risk_areas.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Risk Areas</div>`;
            for (const risk of insights.risk_areas) {
                html += `<div class="insights-risk">
                    <span class="insights-risk-level ${risk.risk_level || 'LOW'}">${risk.risk_level || 'LOW'}</span>
                    <div class="insights-risk-content">
                        <div class="insights-risk-area">${escapeHtml(risk.area || 'Unknown')}</div>
                        ${risk.description ? `<div class="insights-risk-desc">${escapeHtml(risk.description)}</div>` : ''}
                        ${risk.mitigation ? `<div class="insights-risk-desc" style="color: var(--color-accent-secondary); margin-top: 4px;">Tip: ${escapeHtml(risk.mitigation)}</div>` : ''}
                    </div>
                </div>`;
            }
            html += '</div>';
        }

        // Meta information
        if (insights.meta) {
            const meta = insights.meta;
            html += `<div class="insights-meta">
                Generated: ${meta.generated_at ? new Date(meta.generated_at).toLocaleString() : 'Unknown'}
                | Model: ${escapeHtml(meta.model || 'Unknown')}
                ${meta.confidence ? ` | Confidence: ${Math.round(meta.confidence * 100)}%` : ''}
            </div>`;
        }

        content.innerHTML = html || '<div class="insights-placeholder">No insights data available.</div>';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METRICS / KPI DISPLAY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup metrics and health indicators
     * @param {Object} data - Data object with kpis field
     */
    function setupMetrics(data) {
        const kpis = (data && data.kpis) ? data.kpis : {};

        const setText = (id, value) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = value;
        };

        const asNumber = (val) => {
            const num = Number(val);
            return Number.isFinite(num) ? num : null;
        };

        const formatPercent = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}%`;
        };

        const formatCount = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${Math.round(num)}`;
        };

        const formatScore = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}/10`;
        };

        // Set metric values
        setText('metric-edge-resolution', formatPercent(kpis.edge_resolution_percent));
        setText('metric-call-ratio', formatPercent(kpis.call_ratio_percent));
        setText('metric-reachability', formatPercent(kpis.reachability_percent));
        setText('metric-dead-code', formatPercent(kpis.dead_code_percent));
        setText('metric-knot-score', formatScore(kpis.knot_score));
        setText('metric-topology', kpis.topology_shape || 'UNKNOWN');
        setText('metric-orphans', formatCount(kpis.orphan_count));
        setText('metric-top-hubs', formatCount(kpis.top_hub_count));

        // Set health indicators (traffic light bars)
        const setHealth = (id, level) => {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('good', 'medium', 'bad', 'neutral');
                el.classList.add(level);
            }
        };

        // Edge Resolution: >90% good, 70-90% medium, <70% bad
        const edgeRes = asNumber(kpis.edge_resolution_percent);
        setHealth('health-edge-resolution', edgeRes === null ? 'neutral' : edgeRes >= 90 ? 'good' : edgeRes >= 70 ? 'medium' : 'bad');

        // Call Ratio: >60% good, 40-60% medium, <40% bad
        const callRatio = asNumber(kpis.call_ratio_percent);
        setHealth('health-call-ratio', callRatio === null ? 'neutral' : callRatio >= 60 ? 'good' : callRatio >= 40 ? 'medium' : 'bad');

        // Reachability: >90% good, 70-90% medium, <70% bad
        const reach = asNumber(kpis.reachability_percent);
        setHealth('health-reachability', reach === null ? 'neutral' : reach >= 90 ? 'good' : reach >= 70 ? 'medium' : 'bad');

        // Dead Code: <5% good, 5-15% medium, >15% bad (INVERTED - lower is better)
        const dead = asNumber(kpis.dead_code_percent);
        setHealth('health-dead-code', dead === null ? 'neutral' : dead <= 5 ? 'good' : dead <= 15 ? 'medium' : 'bad');

        // Knot Score: <3 good, 3-6 medium, >6 bad (INVERTED - lower is better)
        const knot = asNumber(kpis.knot_score);
        setHealth('health-knot-score', knot === null ? 'neutral' : knot <= 3 ? 'good' : knot <= 6 ? 'medium' : 'bad');

        // Topology: neutral (informational only)
        setHealth('health-topology', 'neutral');

        // Orphans: <10 good, 10-50 medium, >50 bad (INVERTED - lower is better)
        const orphans = asNumber(kpis.orphan_count);
        setHealth('health-orphans', orphans === null ? 'neutral' : orphans <= 10 ? 'good' : orphans <= 50 ? 'medium' : 'bad');

        // Top Hubs: neutral (informational only)
        setHealth('health-top-hubs', 'neutral');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupReport: setupReport,
        setupAIInsights: setupAIInsights,
        setupMetrics: setupMetrics
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupReport = REPORT.setupReport;
window.setupAIInsights = REPORT.setupAIInsights;
window.setupMetrics = REPORT.setupMetrics;

console.log('[Module] REPORT loaded - 3 functions');


// ═══ MODULE: modules/visibility.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VISIBILITY MODULE - UI visibility controls and filter utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles background brightness, metadata visibility, filter clearing,
 * and collapsible section management.
 * Depends on: Graph, APPEARANCE_STATE, VIS_FILTERS, THREE
 *
 * @module VISIBILITY
 * @version 1.0.0
 */

window.VISIBILITY = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BACKGROUND CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update background brightness based on APPEARANCE_STATE
     */
    function updateBackgroundBrightness() {
        const Graph = window.Graph;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const THREE = window.THREE;

        if (!Graph || !APPEARANCE_STATE.backgroundBase) return;
        const baseColor = new THREE.Color(APPEARANCE_STATE.backgroundBase);
        const brightness = APPEARANCE_STATE.backgroundBrightness ?? 1;
        const adjusted = baseColor.clone().multiplyScalar(brightness);
        Graph.backgroundColor(`#${adjusted.getHexString()}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA VISIBILITY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply metadata visibility settings (report panel, file panel, etc.)
     */
    function applyMetadataVisibility() {
        const VIS_FILTERS = window.VIS_FILTERS;

        const reportPanel = document.getElementById('report-panel');
        const reportButton = document.getElementById('btn-report');
        const filePanel = document.getElementById('file-panel');

        // Guard: elements may not exist in minimal template
        if (!reportPanel && !reportButton) return;

        if (!VIS_FILTERS.metadata.showReportPanel) {
            if (reportPanel) reportPanel.style.display = 'none';
            if (reportButton) {
                reportButton.classList.remove('active');
                reportButton.style.display = 'none';
            }
        } else {
            if (reportButton) reportButton.style.display = 'inline-flex';
        }
        if (!VIS_FILTERS.metadata.showFilePanel && filePanel) {
            filePanel.classList.remove('visible');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clear all dimension filters (tier, ring, family, role, file, edge)
     * Used for zero-node recovery and manual reset
     */
    function clearAllFilters() {
        const VIS_FILTERS = window.VIS_FILTERS;

        VIS_FILTERS.tiers.clear();
        VIS_FILTERS.rings.clear();
        VIS_FILTERS.families.clear();
        VIS_FILTERS.roles.clear();
        VIS_FILTERS.files.clear();
        VIS_FILTERS.edges.clear();
        VIS_FILTERS.layers.clear();
        VIS_FILTERS.effects.clear();
        VIS_FILTERS.edgeFamilies.clear();

        // Update legend UI
        document.querySelectorAll('.topo-legend-item.filtered').forEach(el => el.classList.remove('filtered'));

        // Update chip UI
        document.querySelectorAll('.filter-chip.active').forEach(el => el.classList.remove('active'));

        console.log('[Filters] All filters cleared');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLLAPSIBLE SECTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup collapsible sections in sidebar and panels
     */
    function setupCollapsibleSections() {
        // Standard sidebar sections
        const titles = document.querySelectorAll('.side-title.collapsible');
        titles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('collapsed', isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });

        // Topology section collapsibles (GEOMETRY panel)
        const topoTitles = document.querySelectorAll('.topo-section-title.collapsible');
        topoTitles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('expanded', !isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updateBackgroundBrightness: updateBackgroundBrightness,
        applyMetadataVisibility: applyMetadataVisibility,
        clearAllFilters: clearAllFilters,
        setupCollapsibleSections: setupCollapsibleSections
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateBackgroundBrightness = VISIBILITY.updateBackgroundBrightness;
window.applyMetadataVisibility = VISIBILITY.applyMetadataVisibility;
window.clearAllFilters = VISIBILITY.clearAllFilters;
window.setupCollapsibleSections = VISIBILITY.setupCollapsibleSections;

console.log('[Module] VISIBILITY loaded - 4 functions');


// ═══ MODULE: modules/animation.js ═══
/**
 * ANIMATION MODULE
 *
 * Unified animation controller for all layout transitions and continuous motions.
 * Addresses ARCH-002 (O(n^2) flock), ARCH-003 (unthrottled refresh), ARCH-004 (conflicts).
 *
 * Key improvements:
 * - Single animation ownership prevents conflicts
 * - Spatial hashing reduces flock from O(n^2) to O(n)
 * - Integration with REFRESH module for throttled updates
 *
 * Usage:
 *   ANIM.applyLayout('orbital')           // Apply a layout preset
 *   ANIM.stop()                           // Stop all animations
 *   ANIM.setStaggerPattern('radial')      // Change wave pattern
 */

const ANIM = (function () {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        baseDuration: 1200,      // Base animation duration (ms)
        staggerSpread: 800,      // Stagger spread (ms)
        flockMaxNodes: 500,      // Max nodes for flock simulation
        spatialGridSize: 50,     // Grid cell size for spatial hashing
        motionFrameSkip: 0       // Skip frames for motion (0 = no skip)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _currentLayout = 'force';
    let _animationId = null;
    let _layoutTime = 0;
    let _currentStaggerPattern = 'tier';
    let _owner = 'none';  // Current animation owner

    // =========================================================================
    // STAGGER PATTERNS - Wave-based node transitions
    // =========================================================================

    const STAGGER_PATTERNS = {
        // Radial ripple: center nodes move first, ripples outward
        radial: (node, startPos, targetPos) => {
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2 + startPos.z ** 2);
            return Math.min(1, dist / 500);
        },
        // Tier cascade: T0 first, then T1, then T2
        tier: (node) => {
            const tier = NODE.getTier(node);
            const tierNum = tier === 'T0' ? 0 : tier === 'T1' ? 1 : 2;
            return tierNum / 2;
        },
        // Distance-based: shortest travel first
        distance: (node, startPos, targetPos) => {
            const dx = targetPos.x - startPos.x;
            const dy = targetPos.y - startPos.y;
            const dz = targetPos.z - startPos.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            return Math.min(1, dist / 400);
        },
        // File grouping: nodes in same file move together
        file: (node) => {
            const fileIdx = node.fileIdx ?? 0;
            return (fileIdx % 8) / 8;
        },
        // Spiral pattern
        spiral: (node, startPos) => {
            const angle = Math.atan2(startPos.y, startPos.x);
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2);
            return ((angle + Math.PI) / (2 * Math.PI) + dist / 1000) % 1;
        },
        // Random stagger
        random: () => Math.random() * 0.6
    };

    // =========================================================================
    // LAYOUT PRESETS
    // =========================================================================

    const LAYOUT_PRESETS = {
        'force': {
            name: 'FORCE', icon: '?', description: 'Physics-based clustering',
            motion: 'settle', cooldown: 300, warmupTicks: 40, getPosition: null
        },
        'orbital': {
            name: 'ORBITAL', icon: '?', description: 'Planetary orbit bands',
            motion: 'orbit', cooldown: Infinity, orbitSpeed: 0.002,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const r = { T0: 80, T1: 160, T2: 280, UNKNOWN: 200 }[tier] || 200;
                const fOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const angle = (fOff / 5) * Math.PI * 2 + (idx / Math.max(1, total)) * Math.PI * 0.3 + (time || 0) * (0.5 + r * 0.001);
                const wobble = Math.sin(idx * 0.7 + (time || 0) * 2) * 15;
                return {
                    x: Math.cos(angle) * (r + wobble),
                    y: Math.sin(idx * 0.3) * 40 + (tier === 'T0' ? -50 : tier === 'T2' ? 50 : 0),
                    z: Math.sin(angle) * (r + wobble)
                };
            }
        },
        'radial': {
            name: 'RADIAL', icon: '?', description: 'Concentric tier rings',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total, time, tierGroups) => {
                const tier = NODE.getTier(node);
                const r = { T0: 60, T1: 150, T2: 280, UNKNOWN: 220 }[tier] || 180;
                const tierNodes = tierGroups?.[tier] || [];
                const tierIdx = tierNodes.indexOf(node);
                const tierTotal = tierNodes.length || 1;
                const angle = (tierIdx / tierTotal) * Math.PI * 2;
                return { x: Math.cos(angle) * r, y: 0, z: Math.sin(angle) * r };
            }
        },
        'spiral': {
            name: 'SPIRAL', icon: '?', description: 'DNA-like helix',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.003,
            getPosition: (node, idx, total, time) => {
                const t = idx / Math.max(1, total);
                const angle = t * Math.PI * 2 * 4 + (time || 0);
                const r = 100 + t * 150;
                return { x: Math.cos(angle) * r, y: (t - 0.5) * 400, z: Math.sin(angle) * r };
            }
        },
        'sphere': {
            name: 'SPHERE', icon: '?', description: 'Globe surface',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const latBase = { T0: 0.8, T1: 0.5, T2: 0.2, UNKNOWN: 0.5 }[tier] || 0.5;
                const lat = (latBase + (idx % 10) * 0.02) * Math.PI;
                const lonBase = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 180 }[family] || 0;
                const lon = ((lonBase + idx * 3) % 360) * Math.PI / 180 + (time || 0);
                const r = 200;
                return {
                    x: Math.sin(lat) * Math.cos(lon) * r,
                    y: Math.cos(lat) * r,
                    z: Math.sin(lat) * Math.sin(lon) * r
                };
            }
        },
        'grid': {
            name: 'GRID', icon: '?', description: '3D lattice',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const tierX = { T0: -150, T1: 0, T2: 150, UNKNOWN: 0 }[tier] || 0;
                const famZ = { LOG: -120, DAT: -60, ORG: 0, EXE: 60, EXT: 120, UNKNOWN: 0 }[family] || 0;
                const row = Math.floor(idx / 15);
                const col = idx % 15;
                return { x: tierX + (col - 7) * 20, y: row * 25 - 100, z: famZ + Math.sin(idx * 0.5) * 20 };
            }
        },
        'flock': {
            name: 'FLOCK', icon: '?', description: 'Swarming birds',
            motion: 'flock', cooldown: Infinity,
            flockParams: { separation: 25, alignment: 0.05, cohesion: 0.01, maxSpeed: 2 },
            getPosition: null
        },
        'galaxy': {
            name: 'GALAXY', icon: '?', description: 'Spiral arms',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const family = NODE.getFamily(node);
                const tier = NODE.getTier(node);
                const armOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const baseAngle = (armOff / 5) * Math.PI * 2;
                const dist = 50 + (idx / total) * 250;
                const spiralAngle = baseAngle + dist * 0.015 + (time || 0);
                const tierY = { T0: -30, T1: 0, T2: 30, UNKNOWN: 0 }[tier] || 0;
                return {
                    x: Math.cos(spiralAngle) * dist,
                    y: tierY + Math.sin(idx * 0.5) * 20,
                    z: Math.sin(spiralAngle) * dist
                };
            }
        }
    };

    // =========================================================================
    // SPATIAL HASHING - O(n) neighbor lookup for flock simulation
    // =========================================================================

    function _buildSpatialGrid(nodes, cellSize) {
        const grid = new Map();

        nodes.forEach((node, idx) => {
            const x = node.x || 0;
            const y = node.y || 0;
            const z = node.z || 0;

            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) {
                grid.set(key, []);
            }
            grid.get(key).push({ node, idx });
        });

        return grid;
    }

    function _getNeighborsFromGrid(grid, node, cellSize, radius) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);

        const neighbors = [];
        const cellRadius = Math.ceil(radius / cellSize);

        // Check neighboring cells
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                    const key = `${cellX + dx},${cellY + dy},${cellZ + dz}`;
                    const cell = grid.get(key);
                    if (cell) {
                        cell.forEach(entry => {
                            if (entry.node !== node) {
                                neighbors.push(entry.node);
                            }
                        });
                    }
                }
            }
        }

        return neighbors;
    }

    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================

    function _groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = NODE.getTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    function _acquireOwnership(owner) {
        // Cancel any existing animation
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = owner;
        return true;
    }

    function _releaseOwnership(owner) {
        if (_owner === owner) {
            if (_animationId) {
                cancelAnimationFrame(_animationId);
                _animationId = null;
            }
            _owner = 'none';
        }
    }

    // =========================================================================
    // LAYOUT APPLICATION
    // =========================================================================

    function applyLayout(presetKey, animate = true) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset) return;

        _currentLayout = presetKey;
        _acquireOwnership('layout');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);

        // Handle force layout specially
        if (presetKey === 'force') {
            nodes.forEach(n => {
                n.fx = undefined;
                n.fy = undefined;
                n.fz = undefined;
            });
            Graph.cooldownTicks(preset.cooldown);
            Graph.d3ReheatSimulation();
            _releaseOwnership('layout');
            if (typeof showModeToast === 'function') {
                showModeToast('? FORCE layout');
            }
            return;
        }

        // Handle flock specially
        if (preset.motion === 'flock') {
            _startFlockSimulation(preset.flockParams);
            Graph.cooldownTicks(preset.cooldown);
            if (typeof showModeToast === 'function') {
                showModeToast(`${preset.icon} ${preset.name} layout`);
            }
            return;
        }

        // Position-based layouts
        if (preset.getPosition) {
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => preset.getPosition(n, i, total, 0, tierGroups));

            if (animate && total > 100) {
                // STAGGERED ANIMATION for large graphs
                _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey);
            } else if (animate) {
                // SIMPLE ANIMATION for small graphs
                _animateSimple(nodes, startPos, targetPos, preset, presetKey);
            } else {
                // INSTANT
                nodes.forEach((n, i) => {
                    const p = targetPos[i];
                    n.fx = p.x;
                    n.fy = p.y;
                    n.fz = p.z;
                });
                if (typeof REFRESH !== 'undefined') {
                    REFRESH.force();
                } else if (Graph) {
                    REFRESH.throttled();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                }
            }
        }

        Graph.cooldownTicks(preset.cooldown);
        if (typeof showModeToast === 'function') {
            showModeToast(`${preset.icon} ${preset.name} layout`);
        }
    }

    function _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey) {
        const baseDuration = CONFIG.baseDuration;
        const staggerSpread = CONFIG.staggerSpread;
        const startTime = Date.now();

        // Hide edges during animation for performance
        Graph.linkOpacity(0);

        // Calculate delay for each node
        const pattern = STAGGER_PATTERNS[_currentStaggerPattern] || STAGGER_PATTERNS.tier;
        const delays = nodes.map((n, i) => pattern(n, startPos[i], targetPos[i]) * staggerSpread);

        function animateFrame() {
            if (_owner !== 'layout') return;

            const elapsed = Date.now() - startTime;

            nodes.forEach((n, i) => {
                const nodeStart = delays[i];
                const nodeElapsed = elapsed - nodeStart;

                if (nodeElapsed <= 0) {
                    n.fx = startPos[i].x;
                    n.fy = startPos[i].y;
                    n.fz = startPos[i].z;
                } else if (nodeElapsed >= baseDuration) {
                    n.fx = targetPos[i].x;
                    n.fy = targetPos[i].y;
                    n.fz = targetPos[i].z;
                } else {
                    const progress = nodeElapsed / baseDuration;
                    const eased = progress * progress * (3 - 2 * progress);
                    n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                    n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                    n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
                }
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            const totalDuration = baseDuration + staggerSpread;
            if (elapsed < totalDuration) {
                _animationId = requestAnimationFrame(animateFrame);
            } else {
                // Restore edges
                if (typeof applyEdgeMode === 'function') {
                    applyEdgeMode();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                } else {
                    _releaseOwnership('layout');
                }
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _animateSimple(nodes, startPos, targetPos, preset, presetKey) {
        const duration = 1500;
        const startTime = Date.now();

        function animateFrame() {
            if (_owner !== 'layout') return;

            const progress = Math.min(1, (Date.now() - startTime) / duration);
            const eased = progress * progress * (3 - 2 * progress);

            nodes.forEach((n, i) => {
                n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            if (progress < 1) {
                _animationId = requestAnimationFrame(animateFrame);
            } else if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                _startLayoutMotion(presetKey);
            } else {
                _releaseOwnership('layout');
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _startLayoutMotion(presetKey) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset || !preset.getPosition) return;

        _acquireOwnership('motion');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);
        const speed = preset.rotateSpeed || preset.orbitSpeed || 0.002;

        function animate() {
            if (_owner !== 'motion') return;

            _layoutTime += speed;

            nodes.forEach((n, i) => {
                const pos = preset.getPosition(n, i, total, _layoutTime, tierGroups);
                n.fx = pos.x;
                n.fy = pos.y;
                n.fz = pos.z;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(animate);
        }

        _animationId = requestAnimationFrame(animate);
    }

    // =========================================================================
    // FLOCK SIMULATION - O(n) with spatial hashing
    // =========================================================================

    function _startFlockSimulation(params) {
        const nodes = Graph?.graphData()?.nodes || [];

        // Performance guard
        if (nodes.length > CONFIG.flockMaxNodes) {
            console.warn(`[ANIM] Flock disabled: ${nodes.length} nodes exceeds ${CONFIG.flockMaxNodes} limit`);
            if (typeof showModeToast === 'function') {
                showModeToast('Warning: Flock disabled (too many nodes)');
            }
            return;
        }

        _acquireOwnership('flock');

        const { separation, alignment, cohesion, maxSpeed } = params;

        // Initialize velocities
        nodes.forEach(n => {
            n._vx = (Math.random() - 0.5) * 2;
            n._vy = (Math.random() - 0.5) * 2;
            n._vz = (Math.random() - 0.5) * 2;
        });

        function flockStep() {
            if (_owner !== 'flock') return;

            // Build spatial grid for O(n) neighbor lookup
            const grid = _buildSpatialGrid(nodes, CONFIG.spatialGridSize);
            const neighborRadius = separation * 3;

            nodes.forEach(n => {
                // Get nearby neighbors from spatial grid (O(1) per node)
                const neighbors = _getNeighborsFromGrid(grid, n, CONFIG.spatialGridSize, neighborRadius);

                let sepX = 0, sepY = 0, sepZ = 0, sepCount = 0;
                let alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;

                const myFamily = NODE.getFamily(n);

                neighbors.forEach(other => {
                    const dx = (other.x || 0) - (n.x || 0);
                    const dy = (other.y || 0) - (n.y || 0);
                    const dz = (other.z || 0) - (n.z || 0);
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 0.001;

                    // Separation
                    if (dist < separation * 2) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                        sepZ -= dz / dist;
                        sepCount++;
                    }

                    // Alignment and cohesion (same family only)
                    if (NODE.getFamily(other) === myFamily && dist < 150) {
                        alignX += other._vx || 0;
                        alignY += other._vy || 0;
                        alignZ += other._vz || 0;
                        alignCount++;

                        cohX += other.x || 0;
                        cohY += other.y || 0;
                        cohZ += other.z || 0;
                        cohCount++;
                    }
                });

                // Apply forces
                if (sepCount > 0) {
                    n._vx += (sepX / sepCount) * separation * 0.05;
                    n._vy += (sepY / sepCount) * separation * 0.05;
                    n._vz += (sepZ / sepCount) * separation * 0.05;
                }
                if (alignCount > 0) {
                    n._vx += ((alignX / alignCount) - n._vx) * alignment;
                    n._vy += ((alignY / alignCount) - n._vy) * alignment;
                    n._vz += ((alignZ / alignCount) - n._vz) * alignment;
                }
                if (cohCount > 0) {
                    n._vx += (cohX / cohCount - (n.x || 0)) * cohesion;
                    n._vy += (cohY / cohCount - (n.y || 0)) * cohesion;
                    n._vz += (cohZ / cohCount - (n.z || 0)) * cohesion;
                }

                // Center attraction
                n._vx -= (n.x || 0) * 0.0005;
                n._vy -= (n.y || 0) * 0.0005;
                n._vz -= (n.z || 0) * 0.0005;

                // Speed limit
                const speed = Math.sqrt(n._vx * n._vx + n._vy * n._vy + n._vz * n._vz);
                if (speed > maxSpeed) {
                    n._vx = (n._vx / speed) * maxSpeed;
                    n._vy = (n._vy / speed) * maxSpeed;
                    n._vz = (n._vz / speed) * maxSpeed;
                }

                // Update position
                n.fx = (n.x || 0) + n._vx;
                n.fy = (n.y || 0) + n._vy;
                n.fz = (n.z || 0) + n._vz;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(flockStep);
        }

        _animationId = requestAnimationFrame(flockStep);
    }

    // =========================================================================
    // PULSE ANIMATION
    // =========================================================================

    let _pulseId = null;

    function togglePulse(active) {
        if (active) {
            _startPulse();
        } else {
            _stopPulse();
        }
    }

    function _startPulse() {
        if (_pulseId) return;
        const startTime = Date.now();

        function loop() {
            const elapsed = Date.now() - startTime;
            // Oscillate lightness +/- 10%
            const val = Math.sin(elapsed * 0.003) * 10;

            if (typeof COLOR !== 'undefined') {
                COLOR.setTransform('lightnessShift', val);
                // Also breathe chroma a bit
                COLOR.setTransform('chromaScale', 1.0 + Math.sin(elapsed * 0.003) * 0.2);
            }

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof Graph !== 'undefined' && Graph) {
                // Determine if we need to force re-coloring or if just re-rendering canvas is enough.
                // Since transforms affect color calculation, we likely need to re-apply colors.
                if (typeof window.applyNodeColors === 'function') {
                    const nodes = Graph.graphData().nodes;
                    window.applyNodeColors(nodes);
                    Graph.nodeColor(Graph.nodeColor()); // Trigger internal update
                }
            }

            _pulseId = requestAnimationFrame(loop);
        }
        _pulseId = requestAnimationFrame(loop);
        if (typeof showModeToast === 'function') showModeToast('Pulse Animation ON');
    }

    function _stopPulse() {
        if (_pulseId) {
            cancelAnimationFrame(_pulseId);
            _pulseId = null;
        }
        // Reset
        if (typeof COLOR !== 'undefined') {
            COLOR.setTransform('lightnessShift', 0);
            COLOR.setTransform('chromaScale', 1.0);
        }

        // Final refresh to clear artifacts
        if (typeof window.applyNodeColors === 'function' && typeof Graph !== 'undefined') {
            const nodes = Graph.graphData().nodes;
            window.applyNodeColors(nodes);
            Graph.nodeColor(Graph.nodeColor());
        }

        if (typeof showModeToast === 'function') showModeToast('Pulse Animation OFF');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function stop() {
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = 'none';
    }

    function setStaggerPattern(pattern) {
        if (STAGGER_PATTERNS[pattern]) {
            _currentStaggerPattern = pattern;
            if (typeof showModeToast === 'function') {
                showModeToast(`Wave pattern: ${pattern.toUpperCase()}`);
            }
        }
    }

    function cycleStaggerPattern() {
        const patterns = Object.keys(STAGGER_PATTERNS);
        const currentIdx = patterns.indexOf(_currentStaggerPattern);
        _currentStaggerPattern = patterns[(currentIdx + 1) % patterns.length];
        if (typeof showModeToast === 'function') {
            showModeToast(`Wave pattern: ${_currentStaggerPattern.toUpperCase()}`);
        }
        return _currentStaggerPattern;
    }

    return {
        // Layout control
        applyLayout,
        stop,

        // Stagger patterns
        setStaggerPattern,
        cycleStaggerPattern,
        togglePulse, // Added to public API
        get staggerPattern() { return _currentStaggerPattern; },
        get staggerPatterns() { return Object.keys(STAGGER_PATTERNS); },

        // State
        get currentLayout() { return _currentLayout; },
        get isAnimating() { return _animationId !== null; },
        get owner() { return _owner; },

        // Layout presets
        presets: LAYOUT_PRESETS,

        // Config
        config: CONFIG
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// Note: CURRENT_LAYOUT, LAYOUT_ANIMATION_ID, LAYOUT_TIME, CURRENT_STAGGER_PATTERN
// are managed by app.js (separate animation system) - not duplicated here
Object.defineProperty(window, 'LAYOUT_PRESETS', { get: () => ANIM.presets, configurable: true });
Object.defineProperty(window, 'STAGGER_PATTERNS', { get: () => ANIM.staggerPatterns, configurable: true });

function applyLayoutPreset(presetKey, animate) {
    ANIM.applyLayout(presetKey, animate);
}

function cycleStaggerPattern() {
    ANIM.cycleStaggerPattern();
}

function startFlockSimulation(params) {
    // Handled internally by ANIM
    ANIM.applyLayout('flock');
}

function groupNodesByTier(nodes) {
    const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
    nodes.forEach(n => {
        const tier = NODE.getTier(n);
        (groups[tier] || groups.UNKNOWN).push(n);
    });
    return groups;
}


// ═══ MODULE: modules/selection.js ═══
/**
 * SELECTION MODULE
 *
 * Manages node selection, multi-select, marquee selection, and selection visuals.
 * Includes animated selection colors using OKLCH pendulum system.
 *
 * Depends on: CORE (PENDULUM, SELECTION_SIZE_MULT), NODE, COLOR
 *
 * Usage:
 *   SELECT.set([id1, id2])              // Set selection
 *   SELECT.toggle(node)                 // Toggle node selection
 *   SELECT.clear()                      // Clear selection
 *   SELECT.getSelectedNodes()           // Get selected node objects
 *   SELECT.ids                          // Get Set of selected IDs
 */

const SELECT = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    const _ids = new Set();
    let _marqueeActive = false;
    let _marqueeStart = null;
    let _marqueeAdditive = false;
    let _lastMarqueeEndTs = 0;

    // Selection visuals state
    const _selectionOriginals = new Map();
    const _originalColorsForDim = new Map();

    // THREE.js geometries (created lazily)
    let _selectionHaloGeometry = null;
    let _groupHaloGeometry = null;

    // =========================================================================
    // CORE SELECTION FUNCTIONS
    // =========================================================================

    /**
     * Get currently selected nodes
     */
    function getSelectedNodes() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return [];
        const nodes = Graph.graphData().nodes || [];
        return nodes.filter(node => node && node.id && _ids.has(node.id));
    }

    /**
     * Set selection (optionally additive)
     */
    function set(ids, additive = false) {
        if (!additive) {
            _ids.clear();
        }
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        // Use app.js's updateSelectionVisuals if available (has group halo logic)
        // Otherwise fall back to internal _updateVisuals
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Toggle a node's selection state
     */
    function toggle(node) {
        if (!node || !node.id) return;
        if (_ids.has(node.id)) {
            _ids.delete(node.id);
        } else {
            _ids.add(node.id);
        }
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Clear all selection
     */
    function clear() {
        _ids.clear();
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Maybe clear selection (with marquee debounce)
     */
    function maybeClear() {
        const now = Date.now();
        if (_marqueeActive) return;
        if (now - _lastMarqueeEndTs < 250) return;
        clear();
    }

    /**
     * Add nodes to selection
     */
    function add(ids) {
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Remove nodes from selection
     */
    function remove(ids) {
        (ids || []).forEach(id => {
            _ids.delete(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    // =========================================================================
    // OKLCH COLOR UTILITIES
    // =========================================================================

    function _oklchToHex(L, C, H) {
        const hRad = H * Math.PI / 180;
        const a = C * Math.cos(hRad);
        const b = C * Math.sin(hRad);

        const l_ = L / 100 + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L / 100 - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L / 100 - 0.0894841775 * a - 1.2914855480 * b;

        const l = l_ * l_ * l_;
        const m = m_ * m_ * m_;
        const s = s_ * s_ * s_;

        let rLin = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
        let gLin = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
        let bLin = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

        const gamma = x => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;

        let rOut = Math.round(gamma(rLin) * 255);
        let gOut = Math.round(gamma(gLin) * 255);
        let bOut = Math.round(gamma(bLin) * 255);

        rOut = Math.max(0, Math.min(255, rOut));
        gOut = Math.max(0, Math.min(255, gOut));
        bOut = Math.max(0, Math.min(255, bOut));

        return '#' + [rOut, gOut, bOut].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function _dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // =========================================================================
    // PENDULUM ANIMATION
    // =========================================================================

    function _updatePendulums(dt) {
        const PENDULUM = CORE.PENDULUM;
        const p1 = PENDULUM.hue;
        const p2 = PENDULUM.chroma;

        // Pendulum 1: Modulates hue rotation speed
        const accel1 = -(p1.gravity / p1.length) * Math.sin(p1.angle);
        p1.velocity += accel1 * dt;
        p1.velocity *= p1.damping;
        p1.angle += p1.velocity * dt;

        // Continuous hue rotation
        const speedMod = 1 + Math.sin(p1.angle) * 0.5;
        PENDULUM.currentHue = (PENDULUM.currentHue + p1.rotationSpeed * speedMod * (dt / 16)) % 360;

        // Pendulum 2: Chroma with coupling
        const coupling = 0.00015 * Math.sin(p1.angle);
        const accel2 = -(p2.gravity / p2.length) * Math.sin(p2.angle) + coupling;
        p2.velocity += accel2 * dt;
        p2.velocity *= p2.damping;
        p2.angle += p2.velocity * dt;

        // Lightness phase
        PENDULUM.lightness.phase += PENDULUM.lightness.speed * dt;
    }

    function _getSelectionColor(phaseOffset = 0) {
        const PENDULUM = CORE.PENDULUM;
        const p2 = PENDULUM.chroma;
        const p3 = PENDULUM.lightness;

        const H = (PENDULUM.currentHue + phaseOffset * 45) % 360;
        const C = Math.max(0.18, p2.center + Math.sin(p2.angle + phaseOffset * Math.PI * 2) * p2.amplitude);
        const L = p3.center + Math.sin(p3.phase + phaseOffset * Math.PI * 4) * p3.amplitude;

        return _oklchToHex(L, C, H);
    }

    function _getNodeSpatialPhase(node) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const distance = Math.sqrt(x * x + y * y + z * z);
        const PENDULUM = CORE.PENDULUM;
        const scale = PENDULUM.ripple ? (PENDULUM.ripple.scale || 200) : 200;
        const ripplePhase = (distance / scale) % 1;

        const angle = Math.atan2(y, x);
        const angularOffset = Math.sin(angle * 3) * 0.1;

        return (ripplePhase + angularOffset + 1) % 1;
    }

    function _animateSelectionColors(timestamp) {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) return;

        const dt = PENDULUM.lastTime ? Math.min(timestamp - PENDULUM.lastTime, 50) : 16;
        PENDULUM.lastTime = timestamp;

        _updatePendulums(dt);

        if (_ids.size > 0 && typeof Graph !== 'undefined' && Graph?.graphData) {
            const nodes = Graph.graphData().nodes || [];

            nodes.forEach(node => {
                if (_ids.has(node.id)) {
                    const spatialPhase = _getNodeSpatialPhase(node);
                    node.color = _getSelectionColor(spatialPhase);
                }
            });

            if (typeof toColorNumber === 'function') {
                Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
            }
        }

        requestAnimationFrame(_animateSelectionColors);
    }

    function startAnimation() {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) {
            PENDULUM.running = true;
            PENDULUM.hue.velocity = 0.02 + Math.random() * 0.01;
            PENDULUM.chroma.velocity = 0.015 + Math.random() * 0.01;
            PENDULUM.lastTime = 0;
            requestAnimationFrame(_animateSelectionColors);
        }
    }

    function stopAnimation() {
        CORE.PENDULUM.running = false;
    }

    // =========================================================================
    // VISUAL UPDATES
    // =========================================================================

    function _updateVisuals() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;

        const nodes = Graph.graphData().nodes || [];
        const hasSelection = _ids.size > 0;
        const SELECTION_SIZE_MULT = CORE.SELECTION_SIZE_MULT;

        nodes.forEach(node => {
            const isSelected = _ids.has(node.id);

            // Save original for restoration
            if (hasSelection && !_originalColorsForDim.has(node.id)) {
                _originalColorsForDim.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            if (isSelected && !_selectionOriginals.has(node.id)) {
                _selectionOriginals.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            // Apply styling
            if (hasSelection) {
                if (isSelected) {
                    const orig = _selectionOriginals.get(node.id);
                    node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
                } else {
                    const orig = _originalColorsForDim.get(node.id);
                    if (orig) {
                        node.color = _dimColor(orig.color, 0.5);
                        node.val = orig.val * 0.7;
                    }
                }
            } else {
                // Restore originals
                const orig = _originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = orig.color;
                    node.val = orig.val;
                }
            }

            // Update halo visibility
            if (node.__selectionHalo) {
                node.__selectionHalo.visible = isSelected;
            }
        });

        // Handle animation state
        if (hasSelection) {
            startAnimation();
        } else {
            stopAnimation();
            _selectionOriginals.clear();
            _originalColorsForDim.clear();
        }

        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (Graph) {
            REFRESH.throttled();
        }
    }

    function _updatePanel() {
        if (typeof updateSelectionPanel === 'function') {
            updateSelectionPanel();
        }
    }

    function _updateGroupButtonState() {
        if (typeof updateGroupButtonState === 'function') {
            updateGroupButtonState();
        }
    }

    // =========================================================================
    // NODE OVERLAYS (3D halos)
    // =========================================================================

    function ensureOverlays(node) {
        if (!node) return null;
        if (node.__overlayGroup) return node.__overlayGroup;

        // Lazy init geometry
        if (!_selectionHaloGeometry) {
            _selectionHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
            _groupHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
        }

        const group = new THREE.Group();

        const selectionMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
        });
        const selectionHalo = new THREE.Mesh(_selectionHaloGeometry, selectionMaterial);
        selectionHalo.visible = false;
        selectionHalo.renderOrder = 3;

        const groupMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.45,
            depthWrite: false
        });
        const groupHalo = new THREE.Mesh(_groupHaloGeometry, groupMaterial);
        groupHalo.visible = false;
        groupHalo.renderOrder = 2;

        group.add(selectionHalo);
        group.add(groupHalo);

        node.__selectionHalo = selectionHalo;
        node.__groupHalo = groupHalo;
        node.__overlayGroup = group;

        return group;
    }

    function updateOverlayScale(node) {
        const APPEARANCE_STATE = typeof window !== 'undefined' ? window.APPEARANCE_STATE : { nodeScale: 1 };
        const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE?.nodeScale || 1));
        const selectionScale = base * 2.5;
        const groupScale = base * 1.8;

        if (node.__selectionHalo) {
            node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
        }
        if (node.__groupHalo) {
            node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
        }
    }

    // =========================================================================
    // MARQUEE STATE
    // =========================================================================

    function setMarqueeActive(active) {
        _marqueeActive = active;
        if (!active) {
            _lastMarqueeEndTs = Date.now();
        }
    }

    function setMarqueeStart(pos) {
        _marqueeStart = pos;
    }

    function setMarqueeAdditive(additive) {
        _marqueeAdditive = additive;
    }

    // =========================================================================
    // UI HELPERS
    // =========================================================================

    function formatCountList(items, limit = 4) {
        return items.slice(0, limit).map(([key, count]) => `${key} ${count}`).join(' · ') || '--';
    }

    function appendSelectionRow(container, label, value) {
        const row = document.createElement('div');
        row.className = 'selection-row';
        const labelEl = document.createElement('span');
        labelEl.className = 'label';
        labelEl.textContent = label;
        const valueEl = document.createElement('span');
        valueEl.textContent = value || '--';
        row.appendChild(labelEl);
        row.appendChild(valueEl);
        container.appendChild(row);
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel() {
        const panel = document.getElementById('selection-panel');
        const body = document.getElementById('selection-body');
        const title = document.getElementById('selection-title');
        if (!panel || !body) return;

        const nodes = getSelectedNodes();
        if (!nodes.length) {
            panel.classList.remove('visible');
            body.innerHTML = '';
            return;
        }

        panel.classList.add('visible');
        if (title) title.textContent = `SELECTION (${nodes.length})`;
        body.innerHTML = '';

        if (nodes.length <= 3) {
            nodes.forEach(node => {
                const item = document.createElement('div');
                item.className = 'selection-item';
                const name = document.createElement('div');
                name.className = 'selection-name';
                name.textContent = node.name || node.id || 'Unknown';
                item.appendChild(name);
                appendSelectionRow(item, 'Family', typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--');
                appendSelectionRow(item, 'Ring', typeof getNodeRing === 'function' ? getNodeRing(node) : '--');
                appendSelectionRow(item, 'Tier', typeof getNodeTier === 'function' ? getNodeTier(node) : '--');
                appendSelectionRow(item, 'Role', node.role || '--');
                const filePath = node.file_path || node.file || '';
                if (filePath) {
                    const shortPath = filePath.length > 48 ? '...' + filePath.slice(-45) : filePath;
                    appendSelectionRow(item, 'File', shortPath);
                }
                body.appendChild(item);
            });
        } else {
            const summary = document.createElement('div');
            summary.className = 'selection-summary';

            const families = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(n) : '--') : [];
            const rings = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeRing === 'function' ? getNodeRing(n) : '--') : [];
            const tiers = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeTier === 'function' ? getNodeTier(n) : '--') : [];

            const total = document.createElement('div');
            total.textContent = `Total: ${nodes.length} nodes`;
            summary.appendChild(total);

            const familyRow = document.createElement('div');
            familyRow.textContent = `Family: ${formatCountList(families)}`;
            summary.appendChild(familyRow);

            const ringRow = document.createElement('div');
            ringRow.textContent = `Ring: ${formatCountList(rings)}`;
            summary.appendChild(ringRow);

            const tierRow = document.createElement('div');
            tierRow.textContent = `Tier: ${formatCountList(tiers)}`;
            summary.appendChild(tierRow);

            const numericKeys = [
                ['tokens', 'TOKENS'],
                ['bytes', 'BYTES'],
                ['loc', 'LOC'],
                ['lines', 'LINES'],
                ['lines_of_code', 'LOC'],
                ['size', 'SIZE']
            ];
            const totals = {};
            nodes.forEach(node => {
                numericKeys.forEach(([key]) => {
                    const value = Number(node[key]);
                    if (Number.isFinite(value)) {
                        totals[key] = (totals[key] || 0) + value;
                    }
                });
            });
            numericKeys.forEach(([key, label]) => {
                if (totals[key]) {
                    const row = document.createElement('div');
                    row.textContent = `${label}: ${Math.round(totals[key])}`;
                    summary.appendChild(row);
                }
            });

            body.appendChild(summary);
        }

        if (typeof HudLayoutManager !== 'undefined' && HudLayoutManager.reflow) {
            HudLayoutManager.reflow();
        }
    }

    // =========================================================================
    // SELECTION MODAL
    // =========================================================================

    function showSelectionModal() {
        const nodes = getSelectedNodes();
        if (!nodes.length) {
            if (typeof showToast === 'function') showToast('No nodes selected');
            return;
        }

        const overlay = document.getElementById('selection-modal-overlay');
        const title = document.getElementById('selection-modal-title');
        const statsContainer = document.getElementById('selection-modal-stats');
        const body = document.getElementById('selection-modal-body');

        if (!overlay || !body) return;

        // Calculate aggregates
        let totalTokens = 0, totalBytes = 0, totalLoc = 0;
        const tierCounts = {};
        const ringCounts = {};
        const familyCounts = {};

        nodes.forEach(node => {
            totalTokens += Number(node.tokens) || 0;
            totalBytes += Number(node.bytes) || 0;
            totalLoc += Number(node.loc || node.lines || node.lines_of_code) || 0;

            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';

            tierCounts[tier] = (tierCounts[tier] || 0) + 1;
            ringCounts[ring] = (ringCounts[ring] || 0) + 1;
            familyCounts[family] = (familyCounts[family] || 0) + 1;
        });

        const maxVal = Math.max(...nodes.map(n => n.val || n.size || 1));

        title.textContent = `SELECTED NODES (${nodes.length})`;

        // Build stats bar
        statsContainer.innerHTML = '';
        const stats = [
            ['NODES', nodes.length.toLocaleString()],
            ['TOKENS', totalTokens.toLocaleString()],
            ['BYTES', totalBytes.toLocaleString()],
            ['LOC', totalLoc.toLocaleString()],
            ['TIERS', Object.keys(tierCounts).join(', ')],
            ['FAMILIES', Object.keys(familyCounts).length]
        ];
        stats.forEach(([label, value]) => {
            if (value && value !== '0') {
                const stat = document.createElement('div');
                stat.className = 'selection-modal-stat';
                stat.innerHTML = `
                    <span class="selection-modal-stat-label">${label}</span>
                    <span class="selection-modal-stat-value">${value}</span>
                `;
                statsContainer.appendChild(stat);
            }
        });

        // Build table
        const sortedNodes = [...nodes].sort((a, b) => (b.val || b.size || 1) - (a.val || a.size || 1));

        body.innerHTML = `
            <table class="selection-modal-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Tier</th>
                        <th>Ring</th>
                        <th>Family</th>
                        <th>Level</th>
                        <th>Tokens</th>
                        <th>LOC</th>
                        <th>Relevance</th>
                    </tr>
                </thead>
                <tbody id="selection-modal-tbody"></tbody>
            </table>
        `;

        const tbody = document.getElementById('selection-modal-tbody');
        sortedNodes.forEach(node => {
            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';
            const level = node.level || node.scale_level || 'L3';
            const tokens = Number(node.tokens) || '--';
            const loc = Number(node.loc || node.lines || node.lines_of_code) || '--';
            const relevance = ((node.val || node.size || 1) / maxVal * 100).toFixed(0);

            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="node-name" title="${node.name || node.id}">${node.name || node.id}</td>
                <td><span class="level-badge tier-badge">${tier}</span></td>
                <td><span class="level-badge ring-badge">${ring}</span></td>
                <td><span class="level-badge family-badge">${family}</span></td>
                <td>${level}</td>
                <td class="numeric">${typeof tokens === 'number' ? tokens.toLocaleString() : tokens}</td>
                <td class="numeric">${typeof loc === 'number' ? loc.toLocaleString() : loc}</td>
                <td>
                    <div class="relevance-bar">
                        <div class="relevance-fill" style="width: ${relevance}%"></div>
                    </div>
                </td>
            `;
            tbody.appendChild(row);
        });

        overlay.classList.add('visible');
    }

    function hideSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        if (overlay) overlay.classList.remove('visible');
    }

    function initSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        const closeBtn = document.getElementById('selection-modal-close');
        const selectionTitle = document.getElementById('selection-title');

        if (closeBtn) {
            closeBtn.addEventListener('click', hideSelectionModal);
        }

        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) hideSelectionModal();
            });
        }

        if (selectionTitle) {
            selectionTitle.style.cursor = 'pointer';
            selectionTitle.addEventListener('click', showSelectionModal);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey) {
                const activeEl = document.activeElement;
                if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
                if (getSelectedNodes().length > 0) {
                    e.preventDefault();
                    showSelectionModal();
                }
            }
            if (e.key === 'Escape') {
                hideSelectionModal();
            }
        });
    }

    // =========================================================================
    // SELECTION BOX / MARQUEE
    // =========================================================================

    let _selectionBox = null;

    function updateSelectionBox(rect) {
        if (!_selectionBox) _selectionBox = document.getElementById('selection-box');
        if (!_selectionBox) return;
        _selectionBox.style.display = 'block';
        _selectionBox.style.left = `${rect.left}px`;
        _selectionBox.style.top = `${rect.top}px`;
        _selectionBox.style.width = `${rect.width}px`;
        _selectionBox.style.height = `${rect.height}px`;
    }

    function getNodeScreenPosition(node) {
        if (typeof Graph === 'undefined' || !Graph?.camera || !node) return null;
        if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return null;
        const camera = Graph.camera();
        const vector = new THREE.Vector3(node.x, node.y, node.z || 0);
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        return { x, y };
    }

    function selectNodesInBox(rect, additive = true) {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const nodes = Graph.graphData().nodes || [];
        const selected = [];
        nodes.forEach(node => {
            const pos = getNodeScreenPosition(node);
            if (!pos) return;
            if (pos.x >= rect.left && pos.x <= rect.right &&
                pos.y >= rect.top && pos.y <= rect.bottom) {
                if (node.id) selected.push(node.id);
            }
        });
        if (selected.length) {
            set(selected, additive);
        }
    }

    function setupSelectionInteractions() {
        const clearBtn = document.getElementById('selection-clear');
        if (clearBtn) {
            clearBtn.onclick = () => clear();
        }

        const groupBtn = document.getElementById('btn-create-group');
        if (groupBtn && typeof createGroupFromSelection === 'function') {
            groupBtn.onclick = () => createGroupFromSelection();
        }

        _selectionBox = document.getElementById('selection-box');
        if (typeof Graph === 'undefined' || !Graph?.renderer || !_selectionBox) return;

        const canvas = Graph.renderer().domElement;
        if (!canvas) return;

        const onPointerDown = (e) => {
            if (e.button !== 0) return;
            if (typeof SPACE_PRESSED !== 'undefined' && SPACE_PRESSED) return;
            if (e.target !== canvas) return;
            if (typeof HOVERED_NODE !== 'undefined' && HOVERED_NODE) return;
            _marqueeActive = true;
            _marqueeAdditive = !!e.shiftKey;
            _marqueeStart = { x: e.clientX, y: e.clientY };
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, _marqueeStart) : { left: e.clientX, top: e.clientY, width: 0, height: 0 });
            if (Graph.controls()) {
                Graph.controls().enabled = false;
            }
            e.preventDefault();
        };

        const onPointerMove = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) });
        };

        const finishSelection = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            const rect = typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) };
            _selectionBox.style.display = 'none';
            const additive = _marqueeAdditive;
            _marqueeActive = false;
            _marqueeStart = null;
            _marqueeAdditive = false;
            _lastMarqueeEndTs = Date.now();
            if (Graph.controls()) {
                Graph.controls().enabled = true;
            }
            const didDrag = rect.width > 4 && rect.height > 4;
            if (didDrag) {
                selectNodesInBox(rect, additive);
            }
        };

        canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
        canvas.addEventListener('pointermove', onPointerMove, { passive: true });
        canvas.addEventListener('pointerup', finishSelection, { passive: true });
        canvas.addEventListener('pointerleave', finishSelection, { passive: true });
    }

    // =========================================================================
    // SYNC AND INIT
    // =========================================================================

    function syncSelectionAfterGraphUpdate() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const visibleIds = new Set((Graph.graphData().nodes || []).map(n => n.id));
        const idsToRemove = [];
        Array.from(_ids).forEach(id => {
            if (!visibleIds.has(id)) {
                idsToRemove.push(id);
            }
        });
        if (idsToRemove.length > 0) {
            remove(idsToRemove);
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    function initSelectionState(data) {
        if (typeof buildDatasetKey === 'function') {
            window.DATASET_KEY = buildDatasetKey(data);
            window.GROUPS_STORAGE_KEY = `collider_groups_${window.DATASET_KEY}`;
        }
        if (typeof loadGroups === 'function') loadGroups();
        if (typeof renderGroupList === 'function') renderGroupList();
        updateSelectionPanel();
        _updateGroupButtonState();
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core selection
        set,
        toggle,
        clear,
        maybeClear,
        add,
        remove,
        getSelectedNodes,

        // State access
        get ids() { return _ids; },
        get size() { return _ids.size; },
        has(id) { return _ids.has(id); },

        // Animation
        startAnimation,
        stopAnimation,

        // Overlays
        ensureOverlays,
        updateOverlayScale,

        // Marquee
        setMarqueeActive,
        setMarqueeStart,
        setMarqueeAdditive,
        get marqueeActive() { return _marqueeActive; },
        get marqueeStart() { return _marqueeStart; },
        get marqueeAdditive() { return _marqueeAdditive; },
        get lastMarqueeEndTs() { return _lastMarqueeEndTs; },

        // Internal access (for migration)
        _selectionOriginals,
        _originalColorsForDim,

        // UI (moved from app.js)
        updateSelectionPanel,
        showSelectionModal,
        hideSelectionModal,
        initSelectionModal,
        updateSelectionBox,
        getNodeScreenPosition,
        selectNodesInBox,
        setupSelectionInteractions,
        syncSelectionAfterGraphUpdate,
        initSelectionState
    };
})();

// Backward compatibility aliases - Using getters to ensure live updates
// Note: All variables use Object.defineProperty to avoid duplicate declarations with app.js
// SELECTED_NODE_IDS - selection.js is now the SINGLE SOURCE OF TRUTH (unified in modularization)
Object.defineProperty(window, 'SELECTED_NODE_IDS', { get: () => SELECT.ids, configurable: true });
Object.defineProperty(window, 'MARQUEE_ACTIVE', { get: () => SELECT.marqueeActive, configurable: true });
Object.defineProperty(window, 'MARQUEE_START', { get: () => SELECT.marqueeStart, configurable: true });
Object.defineProperty(window, 'MARQUEE_ADDITIVE', { get: () => SELECT.marqueeAdditive, configurable: true });
Object.defineProperty(window, 'LAST_MARQUEE_END_TS', { get: () => SELECT.lastMarqueeEndTs, configurable: true });
// selectionOriginals, originalColorsForDim - app.js owns these, not duplicated here

function getSelectedNodes() { return SELECT.getSelectedNodes(); }
function setSelection(ids, additive) { SELECT.set(ids, additive); }
function toggleSelection(node) { SELECT.toggle(node); }
function clearSelection() { SELECT.clear(); }
function maybeClearSelection() { SELECT.maybeClear(); }
function startSelectionAnimation() { SELECT.startAnimation(); }
function stopSelectionAnimation() { SELECT.stopAnimation(); }
function ensureNodeOverlays(node) { return SELECT.ensureOverlays(node); }
function updateOverlayScale(node) { SELECT.updateOverlayScale(node); }

// UI functions (moved from app.js)
function updateSelectionPanel() { SELECT.updateSelectionPanel(); }
function showSelectionModal() { SELECT.showSelectionModal(); }
function hideSelectionModal() { SELECT.hideSelectionModal(); }
function initSelectionModal() { SELECT.initSelectionModal(); }
function updateSelectionBox(rect) { SELECT.updateSelectionBox(rect); }
function getNodeScreenPosition(node) { return SELECT.getNodeScreenPosition(node); }
function selectNodesInBox(rect, additive) { SELECT.selectNodesInBox(rect, additive); }
function setupSelectionInteractions() { SELECT.setupSelectionInteractions(); }
function syncSelectionAfterGraphUpdate() { SELECT.syncSelectionAfterGraphUpdate(); }
function initSelectionState(data) { SELECT.initSelectionState(data); }

console.log('[Module] SELECT loaded - selection UI, modal, marquee, animation');


// ═══ MODULE: modules/panels.js ═══
/**
 * PANELS MODULE
 *
 * Manages floating panels and HUD layout for the visualization.
 * Handles panel open/close, command bar, and UI dimming.
 *
 * Usage:
 *   PANELS.open('view')       // Open a panel
 *   PANELS.close('view')      // Close a panel
 *   PANELS.toggle('view')     // Toggle panel visibility
 *   PANELS.initCommandBar()   // Wire up command bar buttons
 */

const PANELS = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _activePanelId = null;

    // =========================================================================
    // PANEL FUNCTIONS
    // =========================================================================

    /**
     * Open a panel by ID
     */
    function open(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        // Close any already-open panel
        if (_activePanelId && _activePanelId !== panelId) {
            close(_activePanelId);
        }

        if (panel) {
            panel.classList.add('visible');
            setTimeout(() => { panel.style.opacity = '1'; }, 10);
        }
        if (btn) btn.classList.add('active');
        _activePanelId = panelId;

        // Dim the universe when panel opens
        document.body.classList.add('ui-active');

        // Dim starfield via JS
        if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
            const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
            STARFIELD.material.opacity = baseOpacity * 0.3;
        }
    }

    /**
     * Close a panel by ID
     */
    function close(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        if (panel) {
            panel.classList.remove('visible');
        }
        if (btn) btn.classList.remove('active');
        if (_activePanelId === panelId) _activePanelId = null;

        // Restore universe when all panels closed
        if (!_activePanelId) {
            document.body.classList.remove('ui-active');

            // Restore starfield
            if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
                const starsBtn = document.getElementById('btn-stars');
                const starsVisible = starsBtn && starsBtn.classList.contains('active');
                const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
                STARFIELD.material.opacity = starsVisible ? baseOpacity : 0;
            }
        }
    }

    /**
     * Toggle a panel
     */
    function toggle(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        if (panel && panel.classList.contains('visible')) {
            close(panelId);
        } else {
            open(panelId);
        }
    }

    /**
     * Get active panel ID
     */
    function getActive() {
        return _activePanelId;
    }

    // =========================================================================
    // COMMAND BAR INITIALIZATION
    // =========================================================================

    function initCommandBar() {
        const cmdBtns = {
            'cmd-view': 'view',
            'cmd-filter': 'filter',
            'cmd-style': 'style',
            'cmd-settings': 'settings'
        };

        Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', () => toggle(panelId));
            }
        });

        // Settings panel: Oval margin slider
        _initOvalMarginSlider();
        _initOvalDebugToggle();

        // Style panel sliders (consolidated from app.js)
        _initStylePanelSliders();
        _initToggleSwitches();
        _initSegmentedControls();
        _initCommandBarActions();
    }

    // ═══════════════════════════════════════════════════════════════════
    // STYLE PANEL SLIDERS - Connected to appearance system
    // ═══════════════════════════════════════════════════════════════════

    function _initStylePanelSliders() {
        // Node Size Slider
        const nodeSizeSlider = document.getElementById('node-size-slider');
        const nodeSizeValue = document.getElementById('node-size-value');
        if (nodeSizeSlider) {
            nodeSizeSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (nodeSizeValue) nodeSizeValue.textContent = val.toFixed(1) + 'x';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.nodeVal(node => (node.val || node.size || 1) * val);
                }
            });
        }

        // Edge Opacity Slider
        const edgeOpacitySlider = document.getElementById('edge-opacity-slider');
        const edgeOpacityValue = document.getElementById('edge-opacity-value');
        if (edgeOpacitySlider) {
            edgeOpacitySlider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (edgeOpacityValue) edgeOpacityValue.textContent = val + '%';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val / 100;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
            });
        }

        // Density Slider (filter panel) - NOTE: #density-slider2 not in current HTML template
        // Code retained for future filter panel implementation
        const densitySlider2 = document.getElementById('density-slider2');
        const densityValue2 = document.getElementById('density-value2');
        if (densitySlider2) {
            densitySlider2.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (densityValue2) densityValue2.textContent = val + '%';
                if (typeof CURRENT_DENSITY !== 'undefined') window.CURRENT_DENSITY = val;
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        }
    }

    function _initToggleSwitches() {
        document.querySelectorAll('.toggle-switch').forEach(toggle => {
            toggle.addEventListener('click', () => {
                toggle.classList.toggle('active');
            });
        });
    }

    function _initSegmentedControls() {
        document.querySelectorAll('.segmented-control').forEach(control => {
            control.querySelectorAll('.segment').forEach(segment => {
                segment.addEventListener('click', () => {
                    control.querySelectorAll('.segment').forEach(s => s.classList.remove('active'));
                    segment.classList.add('active');

                    // Handle dimension change
                    if (control.id === 'dim-control') {
                        const dim = segment.dataset.dim;
                        if (typeof IS_3D !== 'undefined') {
                            window.IS_3D = (dim !== '2');
                            if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                        }
                    }

                    // Handle node color mode
                    if (control.id === 'node-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode && typeof setNodeColorMode === 'function') {
                            setNodeColorMode(mode);
                        }
                    }

                    // Handle edge color mode
                    if (control.id === 'edge-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode) {
                            if (typeof EDGE_MODE !== 'undefined') window.EDGE_MODE = mode;
                            if (typeof applyEdgeMode === 'function') applyEdgeMode();
                        }
                    }

                    // Handle panel layout
                    if (control.id === 'layout-control') {
                        const layout = segment.dataset.layout;
                        if (layout) {
                            document.body.setAttribute('data-layout', layout);
                        }
                    }
                });
            });
        });
    }

    function _initCommandBarActions() {
        // Skip if REGISTRY not available (defensive)
        if (typeof REGISTRY === 'undefined' || !REGISTRY.register) return;

        // File mode toggle
        REGISTRY.register('cmd-files2', () => {
            if (typeof setFileModeState === 'function') {
                const newState = typeof fileMode !== 'undefined' ? !fileMode : true;
                setFileModeState(newState);
                const btn = document.getElementById('cmd-files2');
                if (btn) btn.classList.toggle('active', newState);
            }
        }, { desc: 'Toggle File Boundaries Mode' });

        // Flow mode toggle
        REGISTRY.register('cmd-flow2', () => {
            if (typeof toggleFlowMode === 'function') {
                toggleFlowMode();
                const btn = document.getElementById('cmd-flow2');
                if (btn && typeof flowMode !== 'undefined') btn.classList.toggle('active', flowMode);
            }
        }, { desc: 'Toggle Flow Mode' });

        // 3D toggle
        REGISTRY.register('cmd-3d', () => {
            if (typeof toggleDimensions === 'function') {
                toggleDimensions();
            } else if (typeof IS_3D !== 'undefined') {
                window.IS_3D = !window.IS_3D;
                if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                const btnDim = document.getElementById('btn-dimensions');
                if (btnDim) btnDim.textContent = window.IS_3D ? '2D' : '3D';
            }
            const btn = document.getElementById('cmd-3d');
            if (btn && typeof IS_3D !== 'undefined') btn.classList.toggle('active', window.IS_3D);

            // Update dim-control if exists
            const dimControl = document.getElementById('dim-control');
            if (dimControl && typeof IS_3D !== 'undefined') {
                dimControl.querySelectorAll('.segment').forEach(s => {
                    s.classList.toggle('active', s.dataset.dim === (window.IS_3D ? '3' : '2'));
                });
            }
        }, { desc: 'Toggle 2D/3D View' });

        console.log('[PANELS] Command bar actions registered');
    }

    function _initOvalMarginSlider() {
        const ovalSlider = document.getElementById('oval-margin-slider');
        const ovalValue = document.getElementById('oval-margin-value');
        let ovalDebounceTimer = null;

        if (ovalSlider) {
            ovalSlider.addEventListener('input', (e) => {
                if (ovalValue) ovalValue.textContent = e.target.value + '%';
            });

            const applyOvalMargin = () => {
                clearTimeout(ovalDebounceTimer);
                ovalDebounceTimer = setTimeout(() => {
                    const val = ovalSlider.value;
                    document.documentElement.style.setProperty('--oval-margin', val + '%');
                }, 300);
            };

            ovalSlider.addEventListener('mouseup', applyOvalMargin);
            ovalSlider.addEventListener('touchend', applyOvalMargin);
            ovalSlider.addEventListener('change', applyOvalMargin);
        }
    }

    function _initOvalDebugToggle() {
        const toggleOvalDebug = document.getElementById('toggle-oval-debug');
        if (toggleOvalDebug) {
            toggleOvalDebug.addEventListener('click', () => {
                toggleOvalDebug.classList.toggle('active');
                const ovalDebug = document.querySelector('.oval-debug');
                if (ovalDebug) {
                    ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
                }
            });
        }
    }

    // =========================================================================
    // HUD LAYOUT MANAGER - REMOVED, USE LAYOUT MODULE
    // =========================================================================
    // The HudLayoutManager has been unified into modules/layout.js
    // Use LAYOUT.reflow() instead of PANELS.HudLayoutManager.reflow()

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        open,
        close,
        toggle,
        getActive,
        initCommandBar,

        // State access
        get activePanelId() { return _activePanelId; }
    };
})();

// Backward compatibility - _activePanelId is managed by app.js
function openPanel(panelId) { PANELS.open(panelId); }
function closePanel(panelId) { PANELS.close(panelId); }
function togglePanel(panelId) { PANELS.toggle(panelId); }
function initCommandBar() { PANELS.initCommandBar(); }
// HudLayoutManager - app.js owns this, not duplicated here

// ════════════════════════════════════════════════════════════════════════
// PANEL DRAG & RESIZE - Make panels movable and resizable
// ════════════════════════════════════════════════════════════════════════

const PANEL_DRAG = (function() {
    'use strict';

    const _panels = new Map();
    let _dragState = null;
    let _resizeState = null;
    const STORAGE_KEY = 'collider-panel-positions';

    function init() {
        // Initialize draggable/resizable panels (use actual element IDs)
        initPanel('side-dock', { draggable: true, resizable: true, minWidth: 150, maxWidth: 400 });
        initPanel('header-panel', { draggable: true, resizable: false });
        initPanel('stats-panel', { draggable: true, resizable: false });
        initPanel('metrics-panel', { draggable: true, resizable: true, minWidth: 180, maxWidth: 350 });

        // Restore saved positions
        restorePositions();

        // Global mouse handlers
        document.addEventListener('mousemove', (e) => _onMouseMove(e));
        document.addEventListener('mouseup', (e) => _onMouseUp(e));
    }

    function initPanel(id, options = {}) {
        const panel = document.getElementById(id) || document.querySelector('.' + id);
        if (!panel) return;

        const config = {
            el: panel,
            id: id,
            draggable: options.draggable !== false,
            resizable: options.resizable === true,
            minWidth: options.minWidth || 100,
            maxWidth: options.maxWidth || 600,
            minHeight: options.minHeight || 50,
            maxHeight: options.maxHeight || window.innerHeight - 100
        };

        _panels.set(id, config);

        // Make panel positioned if not already
        const style = window.getComputedStyle(panel);
        if (style.position === 'static') {
            panel.style.position = 'absolute';
        }

        // Add drag handle (the panel header or title)
        if (config.draggable) {
            const header = panel.querySelector('.side-title, .hud-title, .panel-header') || panel;
            header.style.cursor = 'move';
            header.addEventListener('mousedown', (e) => _startDrag(e, id));
        }

        // Add resize handle
        if (config.resizable) {
            const handle = document.createElement('div');
            handle.className = 'panel-resize-handle';
            handle.addEventListener('mousedown', (e) => _startResize(e, id));
            panel.appendChild(handle);
            panel.style.position = 'absolute';
        }
    }

    function _startDrag(e, panelId) {
        // Don't drag if clicking on interactive elements
        if (e.target.closest('input, button, select, .collapsible-content, .preset-btn, .layout-btn, .scheme-btn')) {
            return;
        }

        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        const rect = config.el.getBoundingClientRect();

        _dragState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startLeft: rect.left,
            startTop: rect.top
        };

        config.el.classList.add('panel-dragging');
    }

    function _startResize(e, panelId) {
        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        e.stopPropagation();

        const rect = config.el.getBoundingClientRect();

        _resizeState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startWidth: rect.width,
            startHeight: rect.height
        };

        config.el.classList.add('panel-resizing');
    }

    function _onMouseMove(e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (!config) return;

            const dx = e.clientX - _dragState.startX;
            const dy = e.clientY - _dragState.startY;

            let newLeft = _dragState.startLeft + dx;
            let newTop = _dragState.startTop + dy;

            // Keep within viewport
            newLeft = Math.max(0, Math.min(window.innerWidth - 50, newLeft));
            newTop = Math.max(0, Math.min(window.innerHeight - 50, newTop));

            config.el.style.left = newLeft + 'px';
            config.el.style.top = newTop + 'px';
            config.el.style.right = 'auto';
            config.el.style.bottom = 'auto';
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (!config) return;

            const dx = e.clientX - _resizeState.startX;
            const dy = e.clientY - _resizeState.startY;

            let newWidth = _resizeState.startWidth + dx;
            let newHeight = _resizeState.startHeight + dy;

            // Apply constraints
            newWidth = Math.max(config.minWidth, Math.min(config.maxWidth, newWidth));
            newHeight = Math.max(config.minHeight, Math.min(config.maxHeight, newHeight));

            config.el.style.width = newWidth + 'px';
            // Only resize height for certain panels
            if (config.el.classList.contains('side-dock') || config.el.classList.contains('side-content')) {
                // Don't change height for sidebar - it's auto
            } else {
                config.el.style.height = newHeight + 'px';
            }
        }
    }

    function _onMouseUp(_e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (config) {
                config.el.classList.remove('panel-dragging');
                savePositions();
            }
            _dragState = null;
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (config) {
                config.el.classList.remove('panel-resizing');
                savePositions();
            }
            _resizeState = null;
        }
    }

    function savePositions() {
        const positions = {};
        _panels.forEach((config, id) => {
            const rect = config.el.getBoundingClientRect();
            const style = config.el.style;
            positions[id] = {
                left: style.left || rect.left + 'px',
                top: style.top || rect.top + 'px',
                width: style.width || null,
                height: style.height || null
            };
        });
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not save positions:', e);
        }
    }

    function restorePositions() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;

            const positions = JSON.parse(saved);
            Object.entries(positions).forEach(([id, pos]) => {
                const config = _panels.get(id);
                if (!config) return;

                if (pos.left) config.el.style.left = pos.left;
                if (pos.top) config.el.style.top = pos.top;
                if (pos.width) config.el.style.width = pos.width;
                if (pos.height) config.el.style.height = pos.height;

                // Clear right/bottom if we're setting left/top
                if (pos.left) config.el.style.right = 'auto';
                if (pos.top) config.el.style.bottom = 'auto';
            });
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not restore positions:', e);
        }
    }

    function resetPositions() {
        try {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not reset positions:', e);
        }
    }

    return {
        init,
        initPanel,
        savePositions,
        restorePositions,
        resetPositions,
        get panels() { return _panels; }
    };
})();

// Backward compatibility wrapper
const PanelManager = {
    panels: PANEL_DRAG.panels,
    init() { PANEL_DRAG.init(); },
    initPanel(id, opts) { PANEL_DRAG.initPanel(id, opts); },
    savePositions() { PANEL_DRAG.savePositions(); },
    restorePositions() { PANEL_DRAG.restorePositions(); },
    resetPositions() { PANEL_DRAG.resetPositions(); }
};

// Initialize after DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => PANEL_DRAG.init());
} else {
    setTimeout(() => PANEL_DRAG.init(), 100);
}

// Expose globally
window.PANEL_DRAG = PANEL_DRAG;
window.PanelManager = PanelManager;


// ═══ MODULE: modules/sidebar.js ═══
/**
 * SIDEBAR MODULE
 *
 * Manages sidebar controls including color presets, layout presets,
 * physics controls, appearance controls, filters, and panel updates.
 *
 * Depends on: ANIM (for layouts), REFRESH (for throttled updates)
 *
 * Usage:
 *   SIDEBAR.init()                         // Initialize after DOM ready
 *   SIDEBAR.setColorMode('tier')           // Change color mode
 *   SIDEBAR.setLayout('force')             // Change layout
 *   SIDEBAR.setPhysicsPreset('tight')      // Apply physics preset
 *   SIDEBAR.updateStats(nodes, edges)      // Update stat displays
 */

// Note: Using window assignment instead of const to avoid duplicate declaration with app.js
window.SIDEBAR = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _refreshTimer = null;
    let _bound = false;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    /**
     * Initialize sidebar - call after DOM is ready
     */
    function init() {
        if (_bound) return;
        _bound = true;

        // Initialize unified state manager first
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.init();
        }

        _bindSectionHeaders();
        _bindColorPresets();
        _bindLayoutPresets();
        _bindPhysicsControls();
        _bindAppearanceControls();
        _bindActionButtons();
        initSchemeNavigator();
        initViewModeToggle();
        initSectionResize();   // Enable vertical section resizing
        initSidebarResize();   // Enable horizontal sidebar resizing

        // Sync UI to initial state
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.syncUIFromState();
        }

        console.log('[SIDEBAR] Initialized');
    }

    // =========================================================================
    // SECTION COLLAPSE/EXPAND
    // =========================================================================

    function _bindSectionHeaders() {
        document.querySelectorAll('.section-header[data-section]').forEach(header => {
            header.addEventListener('click', () => {
                const sectionId = header.dataset.section;
                const content = document.getElementById(`section-${sectionId}`);
                if (!content) return;

                const isCollapsed = header.classList.toggle('collapsed');
                content.classList.toggle('collapsed', isCollapsed);
            });
        });
    }

    // =========================================================================
    // COLOR PRESETS (TIER, FAMILY, LAYER, RING, FILE, FLOW)
    // =========================================================================

    // =========================================================================
    // COLOR PRESETS: SMART SIDEBAR CONFIGURATION
    // =========================================================================

    const PRESET_CONFIG = [
        {
            category: 'Architecture',
            presets: [
                { id: 'tier', label: 'Tier', desc: 'Auto-detected architectural height' },
                { id: 'layer', label: 'Layer', desc: 'Business logic strata' },
                { id: 'subsystem', label: 'Subsystem', desc: 'Functional domain grouping' },
                { id: 'boundary_score', label: 'Boundary', desc: 'Internal vs External (1-9)' },
                { id: 'phase', label: 'Phase', desc: 'Data-Logic-Org-Exec (MIPO)' }
            ]
        },
        {
            category: 'Taxonomy',
            presets: [
                { id: 'atom', label: 'Atom', desc: 'Function, Class, Module types' },
                { id: 'family', label: 'Family', desc: 'Logic, Data, Execution' },
                { id: 'role', label: 'Role', desc: 'Service, Repo, Controller' },
                { id: 'roleCategory', label: 'Role Cat', desc: 'Query, Command, Event' },
                { id: 'fileType', label: 'File Type', desc: 'Extension-based coloring' }
            ]
        },
        {
            category: 'Metrics',
            presets: [
                { id: 'complexity', label: 'Complexity', desc: 'Cyclomatic complexity' },
                { id: 'loc', label: 'LOC', desc: 'Lines of Code' },
                { id: 'fan_in', label: 'Fan-In', desc: 'Incoming dependencies' },
                { id: 'fan_out', label: 'Fan-Out', desc: 'Outgoing dependencies' },
                { id: 'trust', label: 'Trust', desc: 'Detection confidence' }
            ]
        },
        {
            category: 'RPBL DNA',
            presets: [
                { id: 'responsibility', label: 'Responsibility', desc: 'SRP alignment (1-9)' },
                { id: 'purity', label: 'Purity', desc: 'Side-effect profile (1-9)' },
                { id: 'lifecycle_score', label: 'Lifecycle', desc: 'Static vs Dynamic (1-9)' },
                { id: 'state', label: 'State', desc: 'Stateful vs Stateless' },
                { id: 'visibility', label: 'Visibility', desc: 'Public vs Private' }
            ]
        },
        {
            category: 'Topology',
            presets: [
                { id: 'centrality', label: 'Centrality', desc: 'Graph importance' },
                { id: 'rank', label: 'PageRank', desc: 'Algorithmic influence' }, // mapped to centrality logic or similar
                { id: 'ring', label: 'Ring', desc: 'Concentric architecture rings' },
                { id: 'flow', label: 'Flow', desc: 'Dependency direction' }
            ]
        },
        {
            category: 'Evolution',
            presets: [
                { id: 'churn', label: 'Churn', desc: 'Change frequency (Simulated)' },
                { id: 'age', label: 'Age', desc: 'Time since creation (Simulated)' }
            ]
        }
    ];

    // =========================================================================
    // SCHEME NAVIGATOR: 33 Named Color Schemes
    // =========================================================================

    const SCHEME_CONFIG = [
        // PART A: Famous Scientific (15)
        { category: 'Sequential', schemes: ['viridis', 'plasma', 'magma', 'inferno', 'cividis', 'turbo', 'mako', 'rocket'] },
        { category: 'Diverging', schemes: ['coolwarm', 'spectral'] },
        { category: 'Thematic', schemes: ['thermal', 'nightvision', 'ocean', 'terrain', 'electric'] },

        // PART B: Role-Semantic (18 key roles)
        { category: 'Access', schemes: ['query', 'finder'] },
        { category: 'Mutation', schemes: ['command', 'creator', 'destroyer'] },
        { category: 'Construction', schemes: ['factory'] },
        { category: 'Storage', schemes: ['repository', 'cache'] },
        { category: 'Control', schemes: ['service', 'orchestrator'] },
        { category: 'Validation', schemes: ['validator', 'guard'] },
        { category: 'Transform', schemes: ['transformer', 'parser'] },
        { category: 'Events', schemes: ['handler', 'emitter'] },
        { category: 'Support', schemes: ['utility', 'lifecycle'] },

        // PART C: OKLCH Geometry (Mathematical paths through color space)
        { category: 'Loops', schemes: ['rainbow-loop', 'rainbow-bright', 'rainbow-dark'] },
        { category: 'Arcs', schemes: ['arc-warm', 'arc-cool', 'arc-nature'] },
        { category: 'Spirals', schemes: ['spiral-up', 'spiral-down', 'spiral-chroma'] },
        { category: 'Waves', schemes: ['wave-lightness', 'wave-chroma', 'pulse'] },
        { category: 'Ramps', schemes: ['ramp-hue', 'ramp-lightness', 'ramp-chroma'] },
        { category: 'Paths', schemes: ['helix', 'convergent', 'divergent', 'bicone'] }
    ];

    function _bindColorPresets() {
        // Init Smart Sidebar
        const container = document.getElementById('section-color');
        if (!container) return;

        // Clear existing static buttons if any (except header)
        const contentDiv = container.querySelector('.section-content');
        if (contentDiv) {
            contentDiv.innerHTML = ''; // Rebuild from scratch
            renderSmartSidebar(contentDiv);
        }
    }

    function renderSmartSidebar(container) {
        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Presets...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.preset-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.btn').forEach(btn => {
                    const match = btn.textContent.toLowerCase().includes(term) || btn.title.toLowerCase().includes(term);
                    btn.style.display = match ? 'block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        searchContainer.appendChild(searchInput);
        container.appendChild(searchContainer);

        // Render Categories
        PRESET_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'preset-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'btn-grid btn-grid-3'; // Default to 3-col

            section.presets.forEach(p => {
                const btn = document.createElement('button');
                btn.className = 'btn color-btn';
                btn.textContent = p.label;
                btn.title = p.desc;
                btn.dataset.preset = p.id;

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    setColorMode(p.id);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    // =========================================================================
    // SCHEME NAVIGATOR RENDERER
    // =========================================================================

    function renderSchemeNavigator(container) {
        if (!container) return;
        container.innerHTML = '';

        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Schemes...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.scheme-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.scheme-btn').forEach(btn => {
                    const match = btn.dataset.scheme.toLowerCase().includes(term) ||
                        (btn.title && btn.title.toLowerCase().includes(term));
                    btn.style.display = match ? 'inline-block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear';
        clearBtn.title = 'Remove scheme, use default colors';
        clearBtn.style.cssText = 'margin-left: 8px; padding: 4px 8px; font-size: 9px; background: rgba(255,100,100,0.2); border: 1px solid rgba(255,100,100,0.3); color: var(--text); border-radius: 4px; cursor: pointer;';
        clearBtn.addEventListener('click', clearColorScheme);

        searchContainer.appendChild(searchInput);
        searchContainer.appendChild(clearBtn);
        container.appendChild(searchContainer);

        // Render Categories
        SCHEME_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'scheme-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'scheme-grid';
            grid.style.cssText = 'display: flex; flex-wrap: wrap; gap: 4px;';

            section.schemes.forEach(schemeName => {
                const btn = document.createElement('button');
                btn.className = 'scheme-btn';
                btn.dataset.scheme = schemeName;

                // Get scheme info from COLOR engine
                let info = { name: schemeName, semantic: '' };
                if (typeof COLOR !== 'undefined' && COLOR.getSchemeInfo) {
                    info = COLOR.getSchemeInfo(schemeName);
                }

                btn.title = info.semantic || schemeName;

                // Create clean color swatches (5 stops) instead of ugly gradient
                const swatchContainer = document.createElement('div');
                swatchContainer.className = 'scheme-swatches';

                if (typeof COLOR !== 'undefined' && COLOR.getSchemeColor) {
                    // Sample 5 colors from the scheme path
                    [0, 0.25, 0.5, 0.75, 1].forEach(t => {
                        const swatch = document.createElement('span');
                        swatch.className = 'scheme-swatch';
                        swatch.style.backgroundColor = COLOR.getSchemeColor(schemeName, t);
                        swatchContainer.appendChild(swatch);
                    });
                }

                btn.appendChild(swatchContainer);

                // Label below swatches
                const label = document.createElement('span');
                label.className = 'scheme-label';
                label.textContent = info.name;
                btn.appendChild(label);

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    applyColorScheme(schemeName);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    /**
     * Apply a named color scheme (palette)
     *
     * NEW BEHAVIOR (via VIS_STATE):
     * - Palette is "armed" but does NOT auto-switch colorBy mode
     * - Palette only visually applies when colorBy is an interval mode
     * - When user switches to interval mode, the armed palette becomes active
     */
    function applyColorScheme(schemeName) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(schemeName);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(schemeName);
        }

        try {
            localStorage.setItem('collider_scheme', schemeName);
        } catch (e) { /* ignore */ }

        _refreshGraphColors();
        console.log('[SIDEBAR] Applied scheme:', schemeName);
    }

    /**
     * Clear active scheme, return to default interval colors
     */
    function clearColorScheme() {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(null);
            return;
        }

        // Fallback
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(null);
        }

        try {
            localStorage.removeItem('collider_scheme');
        } catch (e) { /* ignore */ }

        document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));

        _refreshGraphColors();

        console.log('[SIDEBAR] Cleared color scheme');
    }

    /**
     * Internal: Refresh all node colors and re-render the graph
     */
    function _refreshGraphColors() {
        if (typeof Graph === 'undefined' || !Graph) return;

        // Get current nodes from DataManager or Graph
        const DM = window.DM;
        const nodes = DM ? DM.getNodes() : (Graph.graphData ? Graph.graphData().nodes : []);

        // Recompute colors using current mode
        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render
        Graph.nodeColor(Graph.nodeColor());

        // Also refresh edges if in gradient mode
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    /**
     * Initialize scheme navigator in sidebar
     */
    function initSchemeNavigator() {
        const container = document.getElementById('section-schemes');
        if (container) {
            renderSchemeNavigator(container);
        }

        // Setup collapsible header for schemes panel
        const collapsibleHeaders = document.querySelectorAll('.info-panel-header.collapsible');
        collapsibleHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    header.classList.toggle('collapsed', isCollapsed);
                }
            });
        });

        // Setup color mode buttons (for right sidebar)
        const colorBtns = document.querySelectorAll('.color-panel .color-btn');
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                if (!preset) return;

                // Apply color mode via VIS_STATE (handles UI sync)
                setColorMode(preset);
            });
        });

        // NOTE: Saved preferences are now loaded by VIS_STATE.init()
        // UI sync is handled by VIS_STATE.syncUIFromState()
    }

    // =========================================================================
    // VIEW MODE TOGGLE (ATOMS vs FILES)
    // =========================================================================

    let _currentViewMode = 'atoms';
    let _deferredViewMode = null;  // Stores mode to apply after data loads

    /**
     * Initialize the view mode toggle (Atoms vs Files)
     * Note: Only sets up event handlers and button visual state.
     * Actual mode application for 'files' is deferred until data is loaded.
     */
    function initViewModeToggle() {
        const toggle = document.getElementById('view-mode-toggle');
        if (!toggle) return;

        const buttons = toggle.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                if (!mode || mode === _currentViewMode) return;

                setViewMode(mode);
            });
        });

        // Load saved preference - but only update button state, defer actual mode switch
        try {
            const saved = localStorage.getItem('collider_view_mode');
            if (saved && (saved === 'atoms' || saved === 'files')) {
                // Update button visual state immediately
                buttons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === saved);
                });
                _currentViewMode = saved;

                // If files mode, defer application until data is loaded
                if (saved === 'files') {
                    _deferredViewMode = 'files';
                    console.log('[SIDEBAR] Files mode saved - deferring until data loads');
                }
            }
        } catch (e) { /* ignore */ }
    }

    /**
     * Apply deferred view mode after data is loaded
     * Call this from initGraph() after DM.init() completes
     */
    function applyDeferredViewMode() {
        if (_deferredViewMode === 'files') {
            console.log('[SIDEBAR] Applying deferred files mode now that data is loaded');
            _deferredViewMode = null;  // Clear to prevent re-application

            // Apply files mode (data is now available)
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
                console.log('[SIDEBAR] View mode: FILES - showing file nodes');

                if (typeof showToast === 'function') {
                    showToast('FILE VIEW: Each node is a file. Click to expand.');
                }
            }
        }
    }

    /**
     * Set the view mode (atoms or files)
     */
    function setViewMode(mode) {
        if (mode !== 'atoms' && mode !== 'files') return;
        _currentViewMode = mode;

        // Update button states
        const buttons = document.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });

        // Save preference
        try {
            localStorage.setItem('collider_view_mode', mode);
        } catch (e) { /* ignore */ }

        // Apply view mode via FILE_VIZ module
        if (mode === 'files') {
            // Switch to file-nodes view
            if (typeof FILE_VIZ !== 'undefined') {
                // Build the file graph first (required before switching mode)
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'files';
                if (typeof buildFileGraph === 'function') buildFileGraph(null);
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: FILES - showing file nodes');
        } else {
            // Switch to atoms view
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.graphMode = 'atoms';
                FILE_VIZ.setEnabled(false);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'atoms';
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: ATOMS - showing individual atoms');
        }

        // Show toast notification
        if (typeof showToast === 'function') {
            const msg = mode === 'files'
                ? 'FILE VIEW: Each node is a file. Click to expand.'
                : 'ATOM VIEW: Each node is a code element.';
            showToast(msg);
        }
    }

    /**
     * Get current view mode
     */
    function getViewMode() {
        return _currentViewMode;
    }

    function setColorMode(mode) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setColorBy(mode);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof APPEARANCE_STATE !== 'undefined') {
            APPEARANCE_STATE.colorMode = mode;
            APPEARANCE_STATE.currentPreset = mode;
        }

        if (typeof setNodeColorMode === 'function') {
            setNodeColorMode(mode);
        }

        // Handle flow mode specially
        if (mode === 'flow') {
            if (typeof flowMode !== 'undefined' && !flowMode && typeof toggleFlowMode === 'function') {
                toggleFlowMode();
            }
        } else if (typeof flowMode !== 'undefined' && flowMode && typeof disableFlowMode === 'function') {
            disableFlowMode();
        }

        if (typeof window !== 'undefined' && typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        console.log('[SIDEBAR] Color mode:', mode);
    }

    // =========================================================================
    // LAYOUT PRESETS (FORCE, RADIAL, ORBITAL, SPHERE, GRID, SPIRAL)
    // =========================================================================

    function _bindLayoutPresets() {
        const container = document.getElementById('section-layout');
        if (!container) return;

        container.querySelectorAll('.btn[data-layout]').forEach(btn => {
            btn.addEventListener('click', () => {
                const layout = btn.dataset.layout;
                setLayout(layout);

                // Update active state
                container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });
    }

    function setLayout(layout) {
        // Prefer ANIM module if available
        if (typeof ANIM !== 'undefined' && ANIM.applyLayout) {
            ANIM.applyLayout(layout, true);
        } else if (typeof applyLayoutPreset === 'function') {
            applyLayoutPreset(layout, true);
        }
        console.log('[SIDEBAR] Layout:', layout);
    }

    // =========================================================================
    // PHYSICS CONTROLS
    // =========================================================================

    const PHYSICS_PRESETS = {
        default: { charge: -120, link: 50, center: 0.05, damping: 0.4 },
        tight: { charge: -80, link: 30, center: 0.1, damping: 0.5 },
        loose: { charge: -200, link: 80, center: 0.02, damping: 0.3 },
        explosive: { charge: -400, link: 120, center: 0.01, damping: 0.2 }
    };

    function _bindPhysicsControls() {
        // Charge (repulsion)
        _bindSlider('physics-charge', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('charge').strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Link distance
        _bindSlider('physics-link', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('link').distance(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Center pull
        _bindSlider('physics-center', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                const center = Graph.d3Force('center');
                if (center && center.strength) center.strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Damping (velocity decay)
        _bindSlider('physics-damping', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3VelocityDecay(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Physics presets
        const container = document.getElementById('section-physics');
        if (container) {
            container.querySelectorAll('.btn[data-physics]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.physics;
                    setPhysicsPreset(preset);
                });
            });
        }
    }

    function setPhysicsPreset(preset) {
        const p = PHYSICS_PRESETS[preset];
        if (!p) return;

        // Update sliders
        _setSliderValue('physics-charge', p.charge);
        _setSliderValue('physics-link', p.link);
        _setSliderValue('physics-center', p.center);
        _setSliderValue('physics-damping', p.damping);

        // Apply to graph
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('charge').strength(p.charge);
            Graph.d3Force('link').distance(p.link);
            const center = Graph.d3Force('center');
            if (center && center.strength) center.strength(p.center);
            Graph.d3VelocityDecay(p.damping);
            Graph.d3ReheatSimulation();
        }

        console.log('[SIDEBAR] Physics preset:', preset);
    }

    // =========================================================================
    // APPEARANCE CONTROLS
    // =========================================================================

    function _bindAppearanceControls() {
        // Auto-bind all sliders that have a matching numeric input
        // This covers cfg-node-size, cfg-node-opacity, etc.
        const ranges = document.querySelectorAll('input[type="range"]');
        ranges.forEach(range => {
            if (range.id) {
                _bindSlider(range.id, (val) => {
                    // Dispatch to specific handlers based on ID
                    // This creates a centralized handler dispatch
                    _handleSliderChange(range.id, val);
                });
            }
        });

        // Toggles
        _bindToggle('cfg-toggle-labels', (active) => {
            if (typeof VIS_FILTERS !== 'undefined' && VIS_FILTERS.metadata) {
                VIS_FILTERS.metadata.showLabels = active;
            }
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.nodeLabel(n => active ? n.name : null);
            }
        });

        _bindToggle('cfg-toggle-highlight', (active) => {
            // Handled by VIS_STATE or interactions
        });

        _bindToggle('cfg-toggle-pulse', (active) => {
            if (typeof ANIM !== 'undefined') {
                ANIM.togglePulse(active);
            }
        });

        _bindToggle('cfg-toggle-depth', (active) => {
            // 3D shading toggle
        });

        _bindToggle('cfg-toggle-arrows', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.showArrows = active;
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.linkDirectionalArrowLength(active ? 6 : 0);
                Graph.linkDirectionalArrowRelPos(0.9);
            }
        });

        _bindToggle('cfg-toggle-gradient', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.gradientEdges = active;
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            window.refreshGradientEdgeColors && window.refreshGradientEdgeColors();
        });
    }

    // Centralized handler for all sliders
    function _handleSliderChange(id, val) {
        // Map ID to logic
        switch (id) {
            // Node Config
            case 'cfg-node-size':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeVal(n => (n.val || 1) * val);
                break;
            case 'cfg-node-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode(); // Re-apply colors with new alpha
                break;
            case 'cfg-node-res':
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeResolution(val);
                break;
            case 'cfg-label-size':
                // Note: 3d-force-graph doesn't have a direct dynamic label size multiplier, 
                // but we can trigger a re-render or update state.
                break;

            // Edge Config    
            case 'cfg-edge-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
                break;
            case 'cfg-edge-width':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeWidth = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkWidth(val);
                break;
            case 'cfg-edge-curve':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeCurvature = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkCurvature(val);
                break;
            case 'cfg-particle-speed':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticleSpeed(val);
                break;
            case 'cfg-particle-count':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticles(val);
                break;

            // Physics (Updated IDs)
            case 'physics-charge':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('charge').strength(val);
                    Graph.d3ReheatSimulation();
                }
                break;
            case 'physics-link':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('link').distance(val);
                    Graph.d3ReheatSimulation();
                }
                break;
        }
    }


    // =========================================================================
    // ACTION BUTTONS
    // =========================================================================

    function _bindActionButtons() {
        // Reset view
        const resetBtn = document.getElementById('btn-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
                }
            });
        }

        // Screenshot
        const screenshotBtn = document.getElementById('btn-screenshot');
        if (screenshotBtn) {
            screenshotBtn.addEventListener('click', () => {
                if (typeof takeScreenshot === 'function') {
                    takeScreenshot();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    const link = document.createElement('a');
                    link.download = 'collider-screenshot.png';
                    link.href = Graph.renderer().domElement.toDataURL('image/png');
                    link.click();
                }
            });
        }

        // Toggle 2D
        const toggle2dBtn = document.getElementById('btn-2d');
        if (toggle2dBtn) {
            toggle2dBtn.addEventListener('click', () => {
                if (typeof toggle2DMode === 'function') toggle2DMode();
            });
        }

        // Freeze simulation
        const freezeBtn = document.getElementById('btn-freeze');
        if (freezeBtn) {
            freezeBtn.addEventListener('click', () => {
                if (typeof toggleFreeze === 'function') {
                    toggleFreeze();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    // Simple freeze toggle
                    const alpha = Graph.d3AlphaTarget();
                    Graph.d3AlphaTarget(alpha === 0 ? 0.3 : 0);
                    freezeBtn.classList.toggle('active', alpha !== 0);
                }
            });
        }
    }

    // =========================================================================
    // FILTER CHIPS
    // =========================================================================

    function populateFilterChips(data) {
        if (!data || !data.nodes) return;

        // Tiers
        const tiers = [...new Set(data.nodes.map(n => n.tier).filter(Boolean))].sort();
        _populateChipGroup('filter-tiers', tiers, 'tiers');

        // Rings
        const rings = [...new Set(data.nodes.map(n => n.ring).filter(Boolean))].sort();
        _populateChipGroup('filter-rings', rings, 'rings');

        // Edge types
        const edgeTypes = [...new Set(data.links?.map(e => e.type).filter(Boolean) || [])].sort();
        _populateChipGroup('filter-edges', edgeTypes, 'edges');
    }

    function _populateChipGroup(containerId, items, filterKey) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';
        items.forEach(item => {
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = item;
            chip.addEventListener('click', () => {
                const isActive = chip.classList.toggle('active');
                setFilter(filterKey, item, !isActive); // active = filtered OUT
                _scheduleRefresh();
            });
            container.appendChild(chip);
        });
    }

    function setFilter(dimension, value, visible) {
        if (typeof VIS_FILTERS === 'undefined') return;
        const set = VIS_FILTERS[dimension];
        if (!set) return;

        if (visible) {
            set.delete(value); // Remove from filter = show
        } else {
            set.add(value);    // Add to filter = hide
        }
    }

    // =========================================================================
    // HOVER PANEL
    // =========================================================================

    function showHoverPanel(node) {
        const panel = document.getElementById('hover-panel');
        if (!panel || !node) return;

        const setField = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value || '--';
        };

        setField('hover-name', node.name);
        setField('hover-kind', node.kind || node.type || 'unknown');
        setField('hover-atom', node.atom);
        setField('hover-family', node.family || (node.atom ? node.atom.split('.')[0] : null));
        setField('hover-ring', node.ring);
        setField('hover-tier', node.tier);
        setField('hover-role', node.role);

        const fileEl = document.getElementById('hover-file');
        if (fileEl) fileEl.textContent = node.file_path || node.file || '';

        panel.classList.add('visible');
    }

    function hideHoverPanel() {
        const panel = document.getElementById('hover-panel');
        if (panel) panel.classList.remove('visible');
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel(selectedNodes) {
        const panel = document.getElementById('selection-panel');
        const title = document.getElementById('selection-title');
        const list = document.getElementById('selection-list');
        const clearBtn = document.getElementById('selection-clear');

        if (!panel || !list) return;

        if (!selectedNodes || selectedNodes.length === 0) {
            panel.classList.remove('visible');
            return;
        }

        if (title) title.textContent = `SELECTED (${selectedNodes.length})`;

        list.innerHTML = selectedNodes.slice(0, 20).map(n =>
            `<div class="selection-item">${n.name || n.id}</div>`
        ).join('');

        if (selectedNodes.length > 20) {
            list.innerHTML += `<div class="selection-item" style="opacity:0.5">...and ${selectedNodes.length - 20} more</div>`;
        }

        panel.classList.add('visible');

        // Bind clear button
        if (clearBtn) {
            clearBtn.onclick = () => {
                if (typeof SELECT !== 'undefined') {
                    SELECT.clear();
                } else if (typeof clearSelection === 'function') {
                    clearSelection();
                }
                panel.classList.remove('visible');
            };
        }
    }

    // =========================================================================
    // STATS DISPLAY
    // =========================================================================

    function updateStats(nodes, edges, entropy) {
        const nodeEl = document.getElementById('stat-nodes');
        const edgeEl = document.getElementById('stat-edges');
        const entropyEl = document.getElementById('stat-entropy');

        if (nodeEl) nodeEl.textContent = nodes?.toLocaleString() || '0';
        if (edgeEl) edgeEl.textContent = edges?.toLocaleString() || '0';
        if (entropyEl) entropyEl.textContent = entropy?.toFixed(2) || '--';
    }

    // =========================================================================
    // HELPER: SLIDERS
    // =========================================================================

    function _bindSlider(id, callback) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);

        // Handle deprecated value span if it exists (for backward compat)
        const valSpan = document.getElementById(`${id}-val`);

        if (!slider) return;

        // Slider -> Number
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (numberInput) numberInput.value = val;
            if (valSpan) valSpan.textContent = val;
            callback(val);
        });

        // Number -> Slider
        if (numberInput) {
            numberInput.addEventListener('change', () => { // Change triggers on enter/blur
                let val = parseFloat(numberInput.value);

                // Clamp
                if (slider.min) val = Math.max(parseFloat(slider.min), val);
                if (slider.max) val = Math.min(parseFloat(slider.max), val);

                numberInput.value = val;
                slider.value = val;
                if (valSpan) valSpan.textContent = val;
                callback(val);
            });

            // Optional: Live update while typing? Maybe too heavy. Use change for now.
        }
    }

    function _setSliderValue(id, value) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);
        const valSpan = document.getElementById(`${id}-val`);

        if (slider) slider.value = value;
        if (numberInput) numberInput.value = value;
        if (valSpan) valSpan.textContent = value;
    }

    // =========================================================================
    // HELPER: TOGGLES
    // =========================================================================

    function _bindToggle(id, callback) {
        const toggle = document.getElementById(id);
        if (!toggle) {
            console.warn('[SIDEBAR] _bindToggle: element not found:', id);
            return;
        }

        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            callback(isActive);
        });
    }

    // =========================================================================
    // DEBOUNCED REFRESH
    // =========================================================================

    function _scheduleRefresh() {
        clearTimeout(_refreshTimer);
        _refreshTimer = setTimeout(() => {
            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof refreshGraph === 'function') {
                refreshGraph();
            }
        }, 16); // ~1 frame
    }

    // =========================================================================
    // SECTION RESIZING - Vertical drag handles
    // =========================================================================

    const SECTION_HEIGHT_KEY = 'viz_section_heights';
    let _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };

    function initSectionResize() {
        // Add resize handles to each section
        document.querySelectorAll('.section-content').forEach(content => {
            const sectionId = content.id;
            if (!sectionId) return;

            // Make content resizable
            content.classList.add('resizable');

            // Create resize handle
            const handle = document.createElement('div');
            handle.className = 'section-resize-handle';
            handle.dataset.section = sectionId;

            // Insert after section-content (before next section)
            const section = content.closest('.section');
            if (section && section.nextElementSibling) {
                section.parentNode.insertBefore(handle, section.nextElementSibling);
            }

            // Bind drag events
            handle.addEventListener('mousedown', _startResize);
        });

        // Global mouse events
        document.addEventListener('mousemove', _onResize);
        document.addEventListener('mouseup', _endResize);

        // Restore saved heights
        _restoreSectionHeights();

        console.log('[SIDEBAR] Section resize initialized');
    }

    function _startResize(e) {
        const sectionId = e.target.dataset.section;
        const content = document.getElementById(sectionId);
        if (!content) return;

        _resizeState = {
            active: true,
            section: content,
            startY: e.clientY,
            startHeight: content.offsetHeight
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }

    function _onResize(e) {
        if (!_resizeState.active || !_resizeState.section) return;

        const delta = e.clientY - _resizeState.startY;
        const newHeight = Math.max(60, Math.min(400, _resizeState.startHeight + delta));

        _resizeState.section.style.maxHeight = newHeight + 'px';
    }

    function _endResize() {
        if (!_resizeState.active) return;

        // Save height
        if (_resizeState.section) {
            _saveSectionHeight(_resizeState.section.id, _resizeState.section.style.maxHeight);
        }

        // Cleanup
        document.querySelectorAll('.section-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };
    }

    function _saveSectionHeight(sectionId, height) {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            heights[sectionId] = height;
            localStorage.setItem(SECTION_HEIGHT_KEY, JSON.stringify(heights));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save section height:', e);
        }
    }

    function _restoreSectionHeights() {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            Object.entries(heights).forEach(([sectionId, height]) => {
                const content = document.getElementById(sectionId);
                if (content && height) {
                    content.style.maxHeight = height;
                }
            });
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore section heights:', e);
        }
    }

    // =========================================================================
    // SIDEBAR RESIZING - Horizontal drag handles
    // =========================================================================

    const SIDEBAR_WIDTH_KEY = 'viz_sidebar_widths';
    let _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };

    function initSidebarResize() {
        const leftHandle = document.getElementById('left-resize-handle');
        const rightHandle = document.getElementById('right-resize-handle');

        if (leftHandle) {
            leftHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'left'));
        }
        if (rightHandle) {
            rightHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'right'));
        }

        // Global mouse events
        document.addEventListener('mousemove', _onSidebarResize);
        document.addEventListener('mouseup', _endSidebarResize);

        // Restore saved widths
        _restoreSidebarWidths();

        console.log('[SIDEBAR] Sidebar resize initialized');
    }

    function _startSidebarResize(e, side) {
        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        const currentWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(cssVar)) || 280;

        _sidebarResizeState = {
            active: true,
            side: side,
            startX: e.clientX,
            startWidth: currentWidth
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        e.preventDefault();
    }

    function _onSidebarResize(e) {
        if (!_sidebarResizeState.active) return;

        const { side, startX, startWidth } = _sidebarResizeState;
        const delta = side === 'left' ? (e.clientX - startX) : (startX - e.clientX);
        const minWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-sidebar-width')) || 200;
        const maxWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-sidebar-width')) || 400;
        const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + delta));

        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        document.documentElement.style.setProperty(cssVar, newWidth + 'px');

        // Update handle position
        const handle = document.getElementById(`${side}-resize-handle`);
        if (handle) {
            if (side === 'left') {
                handle.style.left = (newWidth - 3) + 'px';
            } else {
                handle.style.right = (newWidth - 3) + 'px';
            }
        }
    }

    function _endSidebarResize() {
        if (!_sidebarResizeState.active) return;

        // Save widths
        _saveSidebarWidths();

        // Cleanup
        document.querySelectorAll('.sidebar-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };
    }

    function _saveSidebarWidths() {
        try {
            const left = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width');
            const right = getComputedStyle(document.documentElement).getPropertyValue('--right-panel-width');
            localStorage.setItem(SIDEBAR_WIDTH_KEY, JSON.stringify({ left, right }));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save sidebar widths:', e);
        }
    }

    function _restoreSidebarWidths() {
        try {
            const widths = JSON.parse(localStorage.getItem(SIDEBAR_WIDTH_KEY) || '{}');
            if (widths.left) {
                document.documentElement.style.setProperty('--sidebar-width', widths.left);
                const leftHandle = document.getElementById('left-resize-handle');
                if (leftHandle) leftHandle.style.left = `calc(${widths.left} - 3px)`;
            }
            if (widths.right) {
                document.documentElement.style.setProperty('--right-panel-width', widths.right);
                const rightHandle = document.getElementById('right-resize-handle');
                if (rightHandle) rightHandle.style.right = `calc(${widths.right} - 3px)`;
            }
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore sidebar widths:', e);
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Initialization
        init,
        initSectionResize,
        initSidebarResize,

        // Color modes
        setColorMode,

        // Color Schemes (33 named gradients)
        applyColorScheme,
        clearColorScheme,
        renderSchemeNavigator,
        initSchemeNavigator,
        SCHEME_CONFIG,

        // Layouts
        setLayout,

        // Physics
        setPhysicsPreset,
        PHYSICS_PRESETS,

        // Filters
        populateFilterChips,
        setFilter,
        renderSmartSidebar, // Export for debug/manual re-render

        // Panels
        showHoverPanel,
        hideHoverPanel,
        updateSelectionPanel,

        // Stats
        updateStats,

        // View Mode (ATOMS/FILES toggle)
        initViewModeToggle,
        setViewMode,
        getViewMode,
        applyDeferredViewMode
    };
})();

// Backward compatibility - SidebarManager class is defined in app.js, not duplicated here
// The SIDEBAR module provides all functionality via SIDEBAR.* calls


// ═══ MODULE: modules/edge-system.js ═══
/**
 * EDGE SYSTEM MODULE
 *
 * Manages edge coloring, width, modes, and gradient effects.
 * Includes gradient palettes for tier, file, flow, depth, and semantic modes.
 *
 * Depends on: COLOR (for type-based colors), NODE (for tier lookups)
 *
 * Usage:
 *   EDGE.getColor(link)           // Get color for a link
 *   EDGE.getWidth(link)           // Get width for a link
 *   EDGE.setMode('gradient-tier') // Change edge mode
 *   EDGE.apply()                  // Apply current mode to graph
 */

const EDGE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODE_ORDER = [
        'gradient-tier',      // Source→Target tier flow (architecture layers)
        'gradient-file',      // File boundaries (module regions)
        'gradient-flow',      // Markov probability (hot paths)
        'gradient-depth',     // Call depth progression
        'gradient-semantic',  // Semantic distance (type similarity)
        'type',               // Classic type-based
        'weight',             // Weight intensity
        'mono'                // Minimal monochrome
    ];

    const MODE_LABELS = {
        'gradient-tier': '▼ TIER FLOW',
        'gradient-file': '▼ FILE REGIONS',
        'gradient-flow': '▼ HOT PATHS',
        'gradient-depth': '▼ CALL DEPTH',
        'gradient-semantic': '▼ SEMANTIC',
        type: 'EDGE: TYPE',
        weight: 'EDGE: WEIGHT',
        mono: 'EDGE: MONO'
    };

    const MODE_HINTS = {
        'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
        'gradient-file': 'Color by file region - shows module boundaries',
        'gradient-flow': 'Hot paths - markov probability gradient',
        'gradient-depth': 'Color by call chain depth',
        'gradient-semantic': 'Color by semantic similarity of endpoints',
        type: 'Edge color by type (calls, imports, etc.)',
        weight: 'Edge width & color by weight',
        mono: 'Minimal monochrome'
    };

    // Gradient color palettes for different modes
    const PALETTES = {
        tier: {
            // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
            T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
            T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
            T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
            UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
        },
        file: {
            // Rainbow hues distributed across files
            saturation: 65,
            lightness: 48
        },
        flow: {
            // Cold (low prob) to Hot (high prob)
            cold: { h: 220, s: 60, l: 45 },   // Blue
            warm: { h: 45, s: 85, l: 50 },    // Yellow
            hot: { h: 0, s: 90, l: 55 }       // Red
        },
        depth: {
            // Shallow (bright) to Deep (dark, saturated)
            shallow: { h: 180, s: 50, l: 65 },  // Light cyan
            mid: { h: 260, s: 70, l: 50 },      // Purple
            deep: { h: 320, s: 80, l: 40 }      // Magenta
        },
        semantic: {
            // Similar (harmonious) to Different (contrasting)
            similar: { h: 150, s: 60, l: 50 },    // Green - same type
            related: { h: 200, s: 65, l: 48 },    // Cyan - related
            different: { h: 340, s: 75, l: 50 }   // Pink - different
        }
    };

    const DEFAULT_OPACITY = 0.08;
    const MIN_WIDTH = 0.6;
    const MAX_WIDTH = 2.2;
    const BASE_WIDTH = 1.0;

    // =========================================================================
    // STATE
    // =========================================================================

    let _mode = 'gradient-file';  // Default mode
    let _ranges = { weight: { min: 1, max: 1 }, confidence: { min: 1, max: 1 } };
    let _nodeFileIndex = new Map();
    let _fileHueMap = new Map();
    let _config = {
        opacity: DEFAULT_OPACITY,
        dim: { interfile_factor: 0.25 }
    };

    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================

    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function interpolateHSL(hsl1, hsl2, t) {
        t = clamp01(t);
        // Handle hue interpolation (shortest path on color wheel)
        let h1 = hsl1.h, h2 = hsl2.h;
        let dh = h2 - h1;
        if (Math.abs(dh) > 180) {
            if (dh > 0) h1 += 360;
            else h2 += 360;
        }
        const h = (h1 + (h2 - h1) * t) % 360;
        const s = hsl1.s + (hsl2.s - hsl1.s) * t;
        const l = hsl1.l + (hsl2.l - hsl1.l) * t;
        return hslColor(h, s, l);
    }

    /**
     * Normalize a metric value to [0,1] range.
     * NOW DELEGATES TO UPB_SCALES when available.
     */
    function normalizeMetric(value, range, scaleName) {
        // If range is degenerate (all same values), return based on absolute value
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }

        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(
                scaleName || 'linear',
                value,
                range.min,
                range.max
            );
        }

        // Fallback: inline linear normalization
        return clamp01((value - range.min) / (range.max - range.min));
    }

    // =========================================================================
    // NODE HELPERS (use canonical versions from node-helpers.js via window.*)
    // =========================================================================

    function getLinkFileIdx(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.fileIdx ?? -1;
        }
        if (endpoint) {
            return _nodeFileIndex.get(endpoint) ?? -1;
        }
        return -1;
    }

    // =========================================================================
    // FILE HUE MAP
    // =========================================================================

    function buildFileHueMap() {
        _fileHueMap.clear();
        // Try DATA module first, then DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
                   (typeof DM !== 'undefined' ? DM : null);
        if (!dm || !dm.getFileBoundaries) return;

        const files = dm.getFileBoundaries();
        const goldenAngle = 137.508;  // Golden angle for good distribution
        files.forEach((file, idx) => {
            const hue = (idx * goldenAngle) % 360;
            _fileHueMap.set(idx, hue);
        });
    }

    // =========================================================================
    // RANGE UPDATES
    // =========================================================================

    function updateRanges() {
        const links = (typeof Graph !== 'undefined' && Graph?.graphData()?.links) || [];
        let minWeight = Infinity, maxWeight = -Infinity;
        let minConf = Infinity, maxConf = -Infinity;

        links.forEach(link => {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            minWeight = Math.min(minWeight, weight);
            maxWeight = Math.max(maxWeight, weight);
            minConf = Math.min(minConf, confidence);
            maxConf = Math.max(maxConf, confidence);
        });

        _ranges = {
            weight: {
                min: isFinite(minWeight) ? minWeight : 1,
                max: isFinite(maxWeight) ? maxWeight : 1
            },
            confidence: {
                min: isFinite(minConf) ? minConf : 1,
                max: isFinite(maxConf) ? maxConf : 1
            }
        };
    }

    function refreshNodeFileIndex() {
        _nodeFileIndex.clear();
        const nodes = (typeof Graph !== 'undefined' && Graph?.graphData()?.nodes) || [];
        nodes.forEach(node => {
            if (node && node.id) {
                _nodeFileIndex.set(node.id, node.fileIdx ?? -1);
            }
        });
    }

    // =========================================================================
    // GRADIENT EDGE COLOR
    // =========================================================================

    function getGradientColor(link, mode) {
        const srcNode = typeof link.source === 'object' ? link.source :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.source) : null);
        const tgtNode = typeof link.target === 'object' ? link.target :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.target) : null);

        if (mode === 'gradient-tier') {
            const srcTier = window.getNodeTierValue(srcNode);
            const tgtTier = window.getNodeTierValue(tgtNode);
            const avgTier = (srcTier + tgtTier) / 2;

            const palette = PALETTES.tier;
            let color;
            if (avgTier < 0.5) {
                color = interpolateHSL(palette.T0, palette.T1, avgTier * 2);
            } else if (avgTier < 1.5) {
                color = interpolateHSL(palette.T0, palette.T1, (avgTier - 0.5));
            } else {
                color = interpolateHSL(palette.T1, palette.T2, (avgTier - 1) / 2);
            }

            // Highlight tier transitions (edges crossing tiers)
            if (srcTier !== tgtTier) {
                return hslColor(
                    parseInt(color.slice(4)),
                    75,  // Higher saturation
                    55   // Brighter
                );
            }
            return color;
        }

        if (mode === 'gradient-file') {
            const srcFile = srcNode?.fileIdx ?? -1;
            const tgtFile = tgtNode?.fileIdx ?? -1;
            const palette = PALETTES.file;

            if (srcFile === tgtFile && srcFile >= 0) {
                const hue = _fileHueMap.get(srcFile) ?? (srcFile * 37 % 360);
                return hslColor(hue, palette.saturation, palette.lightness);
            } else {
                const srcHue = _fileHueMap.get(srcFile) ?? 0;
                const tgtHue = _fileHueMap.get(tgtFile) ?? 180;
                let midHue = (srcHue + tgtHue) / 2;
                if (Math.abs(srcHue - tgtHue) > 180) {
                    midHue = (midHue + 180) % 360;
                }
                return hslColor(midHue, palette.saturation * 0.6, palette.lightness * 1.1);
            }
        }

        if (mode === 'gradient-flow') {
            const mw = link.markov_weight ?? link.weight ?? 0;
            const palette = PALETTES.flow;

            if (mw < 0.3) {
                return interpolateHSL(palette.cold, palette.warm, mw / 0.3);
            } else if (mw < 0.7) {
                return interpolateHSL(palette.warm, palette.hot, (mw - 0.3) / 0.4);
            } else {
                return hslColor(palette.hot.h, palette.hot.s + 10, palette.hot.l + 10);
            }
        }

        if (mode === 'gradient-depth') {
            const srcDepth = window.getNodeDepth(srcNode);
            const tgtDepth = window.getNodeDepth(tgtNode);
            const avgDepth = (srcDepth + tgtDepth) / 2;
            const palette = PALETTES.depth;

            if (avgDepth < 0.33) {
                return interpolateHSL(palette.shallow, palette.mid, avgDepth * 3);
            } else if (avgDepth < 0.66) {
                return interpolateHSL(palette.mid, palette.deep, (avgDepth - 0.33) * 3);
            } else {
                return hslColor(palette.deep.h, palette.deep.s, palette.deep.l - 10);
            }
        }

        if (mode === 'gradient-semantic') {
            const similarity = window.getSemanticSimilarity(srcNode, tgtNode);
            const palette = PALETTES.semantic;

            if (similarity > 0.7) {
                return interpolateHSL(palette.related, palette.similar, (similarity - 0.7) / 0.3);
            } else if (similarity > 0.3) {
                return interpolateHSL(palette.different, palette.related, (similarity - 0.3) / 0.4);
            } else {
                return hslColor(palette.different.h, palette.different.s + 10, palette.different.l);
            }
        }

        return '#444444';
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(link) {
        // Gradient modes
        if (_mode.startsWith('gradient-')) {
            return getGradientColor(link, _mode);
        }

        const edgeKey = String(link.edge_type || link.type || 'unknown').toLowerCase();

        if (_mode === 'type') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', edgeKey) : '#666666';
        }

        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const t = normalizeMetric(weight, _ranges.weight);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('weight', t) : hslColor(30, 70, 50 + t * 30);
        }

        if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            const t = normalizeMetric(confidence, _ranges.confidence);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('confidence', t) : hslColor(200, 70, 50 + t * 30);
        }

        if (_mode === 'mono') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', 'unknown') : '#555555';
        }

        // Default: type-based coloring
        return typeof COLOR !== 'undefined' ?
            COLOR.get('edgeType', edgeKey) : '#666666';
    }

    // =========================================================================
    // EDGE WIDTH
    // =========================================================================

    function getWidth(link) {
        // For most modes, return uniform width for visual consistency
        if (_mode !== 'weight' && _mode !== 'confidence') {
            return BASE_WIDTH;
        }

        // Weight/confidence modes: subtle variation within tight bounds
        let t = 0.5;
        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            t = normalizeMetric(weight, _ranges.weight);
        } else if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            t = normalizeMetric(confidence, _ranges.confidence);
        }

        return MIN_WIDTH + (t * (MAX_WIDTH - MIN_WIDTH));
    }

    // =========================================================================
    // APPLY MODE TO GRAPH
    // =========================================================================

    function apply() {
        updateRanges();
        refreshNodeFileIndex();
        buildFileHueMap();

        if (typeof Graph === 'undefined' || !Graph) return;

        Graph.linkColor(link => {
            const color = getColor(link);
            return typeof toColorNumber === 'function' ?
                toColorNumber(color, 0x222222) : color;
        });

        Graph.linkOpacity(link => {
            const overrideOpacity = (typeof APPEARANCE_STATE !== 'undefined' &&
                typeof APPEARANCE_STATE.edgeOpacity === 'number')
                ? APPEARANCE_STATE.edgeOpacity
                : null;
            const baseOpacity = (overrideOpacity !== null)
                ? overrideOpacity
                : (link.opacity ?? DEFAULT_OPACITY);

            // File mode dimming
            const fileMode = typeof window !== 'undefined' && window.fileMode;
            const graphMode = typeof GRAPH_MODE !== 'undefined' ? GRAPH_MODE : 'atoms';
            if (fileMode && graphMode === 'atoms') {
                const srcIdx = getLinkFileIdx(link, 'source');
                const tgtIdx = getLinkFileIdx(link, 'target');
                if (srcIdx >= 0 && tgtIdx >= 0 && srcIdx !== tgtIdx) {
                    const dimFactor = _config.dim?.interfile_factor ?? 0.25;
                    return baseOpacity * dimFactor;
                }
            }
            return baseOpacity;
        });

        // Don't override width in flow mode
        const flowMode = typeof window !== 'undefined' && window.flowMode;
        if (!flowMode) {
            Graph.linkWidth(link => {
                const baseWidth = getWidth(link);
                // Respect APPEARANCE_STATE.edgeWidth multiplier if set
                const widthMultiplier = (typeof APPEARANCE_STATE !== 'undefined' &&
                    typeof APPEARANCE_STATE.edgeWidth === 'number')
                    ? APPEARANCE_STATE.edgeWidth
                    : 1;
                return Math.max(0.5, baseWidth * widthMultiplier);
            });
        }
    }

    // =========================================================================
    // MODE MANAGEMENT
    // =========================================================================

    function setMode(mode) {
        if (!MODE_ORDER.includes(mode)) return;
        _mode = mode;

        const button = document.getElementById('btn-edge-mode');
        if (button) {
            button.textContent = MODE_LABELS[_mode] || 'EDGE';
        }

        apply();

        // Update legend to reflect edge mode colors
        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        // Show mode toast hint
        if (typeof showModeToast === 'function') {
            showModeToast(MODE_HINTS[mode] || `Edge mode: ${mode}`);
        }
    }

    function cycleMode() {
        const currentIndex = MODE_ORDER.indexOf(_mode);
        const nextIndex = (currentIndex + 1) % MODE_ORDER.length;
        setMode(MODE_ORDER[nextIndex]);
    }

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getWidth,
        apply,

        // Mode management
        setMode,
        cycleMode,
        get mode() { return _mode; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Constants
        MODE_ORDER,
        MODE_LABELS,
        MODE_HINTS,
        PALETTES,

        // Internal access (for migration)
        get ranges() { return _ranges; },
        get nodeFileIndex() { return _nodeFileIndex; },
        get fileHueMap() { return _fileHueMap; },

        // Utility exports
        buildFileHueMap,
        updateRanges,
        refreshNodeFileIndex
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// These create getters/setters that sync with EDGE module state
Object.defineProperty(window, 'EDGE_MODE', {
    get: () => EDGE.mode,
    set: (v) => EDGE.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'EDGE_RANGES', {
    get: () => EDGE.ranges,
    configurable: true
});
Object.defineProperty(window, 'NODE_FILE_INDEX', {
    get: () => EDGE.nodeFileIndex,
    configurable: true
});
Object.defineProperty(window, 'FILE_HUE_MAP', {
    get: () => EDGE.fileHueMap,
    configurable: true
});
// Static constants - app.js owns these, not duplicated here
// EDGE_MODE_ORDER, EDGE_MODE_LABELS, EDGE_MODE_HINTS, GRADIENT_PALETTES - defined in app.js

function getEdgeColor(link) { return EDGE.getColor(link); }
function getEdgeWidth(link) { return EDGE.getWidth(link); }
function applyEdgeMode() { EDGE.apply(); }
function setEdgeMode(mode) { EDGE.setMode(mode); }
function cycleEdgeMode() { EDGE.cycleMode(); }
function updateEdgeRanges() { EDGE.updateRanges(); }
function refreshNodeFileIndex() { EDGE.refreshNodeFileIndex(); }
function buildFileHueMap() { EDGE.buildFileHueMap(); }
function getGradientEdgeColor(link, mode) { return EDGE.getColor(link); }


// ═══ MODULE: modules/file-viz.js ═══
/**
 * FILE VIZ MODULE
 *
 * Manages file visualization modes: color, hulls, cluster, map, spheres.
 * Handles file coloring, boundaries, mode switching, and FILE GRAPH.
 *
 * FILE GRAPH: Shows repository structure as first-class nodes where each
 * file becomes a hoverable, selectable node. This provides:
 * - Clear view of the repository file system
 * - Hover to see file details (atom count, path, metrics)
 * - Click to expand and see atoms within
 * - Edge weights show inter-file dependencies
 *
 * Depends on: DATA (for file boundaries), COLOR (for transforms)
 *
 * Pattern: IIFE with State Unification (see docs/specs/VISUALIZATION_UI_SPEC.md)
 *
 * Usage:
 *   FILE_VIZ.setMode('map')          // Switch to file-nodes view
 *   FILE_VIZ.toggle()                // Toggle file mode on/off
 *   FILE_VIZ.getColor(idx, total)    // Get color for a file
 *   FILE_VIZ.buildFileGraph()        // Build file-level graph
 *   FILE_VIZ.apply()                 // Apply current mode
 */

const FILE_VIZ = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODES = ['color', 'hulls', 'cluster', 'map', 'spheres'];

    const MODE_HINTS = {
        color: 'Files colored by hue - each file gets unique color',
        hulls: 'Boundary hulls around file clusters',
        cluster: 'Force clustering groups files together',
        map: 'FILE NODES view - see repository structure as nodes! Click to expand.',
        spheres: 'Containment spheres with collision physics'
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _enabled = false;
    let _mode = 'color';
    let _config = {
        strategy: 'golden-angle',
        angle: 137.5,
        chroma: null,
        saturation: 70,
        lightness: 50
    };
    let _boundaryMeshes = [];
    let _hullRedrawTimer = null;
    let _hullRedrawAttempts = 0;

    // FILE GRAPH STATE - for file-as-nodes visualization
    let _fileGraph = null;          // { nodes: [], links: [] } for file-level view
    let _fileNodeIds = new Map();   // fileIdx -> nodeId mapping
    let _fileNodePositions = new Map(); // Preserve positions across mode switches
    let _expandedFiles = new Set(); // Files expanded to show atoms
    let _graphMode = 'atoms';       // atoms | files | hybrid
    let _expandMode = 'inline';     // inline | detach
    let _activeMapping = 'format';  // Current visual mapping mode

    // =========================================================================
    // VISUAL MAPPING SYSTEM - Map metadata to visual properties
    // =========================================================================

    /**
     * Visual dimension mappings - connect file metadata to visual properties.
     * Each mapping defines: source metadata field → visual property + scale
     */
    const VISUAL_MAPPINGS = {
        // Size-based mappings
        size_bytes: {
            property: 'nodeSize',
            scale: 'sqrt',
            min: 2,
            max: 20,
            label: 'File Size (bytes)'
        },
        token_estimate: {
            property: 'nodeSize',
            scale: 'log',
            min: 2,
            max: 18,
            label: 'Token Count'
        },
        line_count: {
            property: 'nodeSize',
            scale: 'sqrt',
            min: 2,
            max: 15,
            label: 'Line Count'
        },

        // Time-based mappings
        age_days: {
            property: 'opacity',
            scale: 'linear',
            invert: true,  // Older = more faded
            min: 0.3,
            max: 1.0,
            label: 'File Age'
        },

        // Categorical mappings (discrete colors)
        format_category: {
            property: 'hue',
            discrete: true,
            values: {
                code: 210,  // Blue - primary code
                config: 45,   // Orange - configuration
                doc: 120,  // Green - documentation
                data: 280,  // Purple - data files
                test: 340,  // Pink - test files
                style: 180,  // Cyan - stylesheets
                script: 30,   // Yellow-Orange - scripts
                build: 0,    // Red - build files
                other: 0     // Gray (handled by saturation)
            },
            label: 'File Format'
        },
        purpose: {
            property: 'hue',
            discrete: true,
            values: {
                test: 340,  // Pink
                config: 45,   // Orange
                model: 260,  // Purple
                service: 210,  // Blue
                controller: 180,  // Cyan
                utility: 90,   // Yellow-Green
                interface: 300,  // Magenta
                data: 30,   // Orange-Yellow
                general: 200   // Light Blue
            },
            label: 'File Purpose'
        },

        // Complexity mappings
        complexity_density: {
            property: 'saturation',
            scale: 'linear',
            min: 30,
            max: 90,
            label: 'Complexity'
        },
        cohesion: {
            property: 'lightness',
            scale: 'linear',
            min: 35,
            max: 65,
            label: 'Cohesion'
        },

        // Git mappings (if available)
        git_commits: {
            property: 'pulse',  // Animation intensity
            scale: 'log',
            min: 0,
            max: 1,
            label: 'Git Commits'
        }
    };

    /**
     * Apply a visual mapping to file nodes.
     * NOW DELEGATES TO UPB (Universal Property Binder)
     *
     * @param {string} mappingKey - Key from VISUAL_MAPPINGS (source property)
     * @param {Array} fileNodes - Array of file node objects
     */
    function applyVisualMapping(mappingKey, fileNodes) {
        const mapping = VISUAL_MAPPINGS[mappingKey];
        if (!mapping) {
            console.warn(`[FILE_VIZ] Unknown mapping: ${mappingKey}`);
            return;
        }

        _activeMapping = mappingKey;

        // Get data range for normalization
        const values = fileNodes.map(n => n[mappingKey]).filter(v => v !== undefined && v !== null);
        if (values.length === 0) {
            console.warn(`[FILE_VIZ] No data for mapping: ${mappingKey}`);
            return;
        }

        const dataMin = Math.min(...values);
        const dataMax = Math.max(...values);

        // === UPB INTEGRATION ===
        // Use UPB for scaling if available, with graceful fallback
        const useUPB = window.UPB && window.UPB_SCALES;

        fileNodes.forEach(node => {
            const rawValue = node[mappingKey];
            if (rawValue === undefined || rawValue === null) return;

            if (mapping.discrete) {
                // Categorical mapping - direct value lookup
                const discreteValue = mapping.values[rawValue] ?? mapping.values['other'] ?? 0;
                _applyVisualProperty(node, mapping.property, discreteValue);
            } else {
                // Continuous mapping - use UPB_SCALES
                let normalized;
                if (useUPB) {
                    // Delegate to UPB_SCALES
                    normalized = window.UPB_SCALES.applyScale(
                        mapping.scale || 'linear',
                        rawValue,
                        dataMin,
                        dataMax
                    );
                } else {
                    // Fallback to inline (for when UPB not loaded)
                    normalized = _normalizeValueFallback(rawValue, dataMin, dataMax, mapping.scale);
                }

                if (mapping.invert) normalized = 1 - normalized;

                const visualMin = mapping.min ?? 0;
                const visualMax = mapping.max ?? 1;
                const visualValue = visualMin + normalized * (visualMax - visualMin);

                _applyVisualProperty(node, mapping.property, visualValue);
            }
        });

        console.log(`[FILE_VIZ] Applied mapping: ${mappingKey} (${mapping.label})${useUPB ? ' [via UPB]' : ''}`);
    }

    /**
     * FALLBACK scale normalization - used when UPB_SCALES not available.
     * @deprecated Prefer UPB_SCALES.applyScale() when UPB is loaded.
     */
    function _normalizeValueFallback(value, min, max, scale) {
        if (max === min) return 0.5;

        let normalized;
        switch (scale) {
            case 'log':
                const logMin = Math.log10(Math.max(1, min));
                const logMax = Math.log10(Math.max(1, max));
                const logVal = Math.log10(Math.max(1, value));
                normalized = (logVal - logMin) / (logMax - logMin);
                break;
            case 'sqrt':
                const sqrtMin = Math.sqrt(min);
                const sqrtMax = Math.sqrt(max);
                const sqrtVal = Math.sqrt(value);
                normalized = (sqrtVal - sqrtMin) / (sqrtMax - sqrtMin);
                break;
            default: // linear
                normalized = (value - min) / (max - min);
        }
        return Math.max(0, Math.min(1, normalized));
    }

    function _applyVisualProperty(node, property, value) {
        switch (property) {
            case 'nodeSize':
                node.val = value;
                break;
            case 'hue':
                // Rebuild color with new hue
                const sat = _config.saturation ?? 70;
                const light = _config.lightness ?? 50;
                node.color = hslColor(value, sat, light);
                break;
            case 'saturation':
                // Would need to parse existing color - simplified approach
                node._saturation = value;
                break;
            case 'lightness':
                node._lightness = value;
                break;
            case 'opacity':
                node._opacity = value;
                break;
            case 'pulse':
                node._pulseIntensity = value;
                break;
        }
    }

    /**
     * Get color for file based on active mapping or default
     */
    function getColorForMapping(node) {
        const mapping = VISUAL_MAPPINGS[_activeMapping];
        if (!mapping || mapping.property !== 'hue') {
            // Use default golden angle coloring
            return getColor(node.fileIdx, 100, node.file_name);
        }

        const rawValue = node[_activeMapping];
        if (rawValue === undefined || !mapping.discrete) {
            return getColor(node.fileIdx, 100, node.file_name);
        }

        const hue = mapping.values[rawValue] ?? 200;
        const sat = node._saturation ?? (_config.saturation ?? 70);
        const light = node._lightness ?? (_config.lightness ?? 50);
        return hslColor(hue, sat, light);
    }

    // =========================================================================
    // COLOR UTILITIES
    // =========================================================================

    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function hashToUnit(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash;
        }
        return Math.abs(hash % 1000) / 1000;
    }

    function getHue(fileIdx, totalFiles, fileName) {
        const strategy = _config.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return hashToUnit(seed) * 360;
        }
        const angle = _config.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const saturation = _config.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (_config.lightness ?? 50);
        const hue = getHue(fileIdx, totalFiles, fileName);

        // Apply color tweaks if available
        const tweaks = typeof COLOR_TWEAKS !== 'undefined' ? COLOR_TWEAKS : {};

        if (typeof _config.chroma === 'number' && typeof oklchColor === 'function') {
            return oklchColor(lightness, _config.chroma, hue);
        }

        const adjustedHue = hue + (tweaks.hueShift || 0);
        const adjustedLightness = clampValue(lightness + (tweaks.lightnessShift || 0), 0, 100);
        return hslColor(adjustedHue, saturation, adjustedLightness);
    }

    // =========================================================================
    // APPLY COLORS TO NODES
    // =========================================================================

    function applyColors(graphNodes) {
        // Get file boundaries from DATA module or DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        const boundaries = dm?.getFileBoundaries ? dm.getFileBoundaries() : [];
        const totalFiles = boundaries.length;

        graphNodes.forEach(node => {
            if (node.fileIdx >= 0) {
                const fileInfo = boundaries[node.fileIdx] || {};
                const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                node.color = getColor(node.fileIdx, totalFiles, fileLabel);
            }
        });

        if (typeof Graph !== 'undefined' && Graph) {
            Graph.nodeColor(n => {
                return typeof toColorNumber === 'function' ?
                    toColorNumber(n.color, 0x888888) : n.color;
            });
        }
    }

    // =========================================================================
    // FILE GRAPH BUILDING - Repository as Nodes
    // =========================================================================

    /**
     * Build a file-level graph where each file is a node.
     * This creates a clear view of repository structure with:
     * - File nodes sized by atom count
     * - Edges weighted by inter-file dependencies
     * - Colors by file index (golden angle distribution)
     */
    function buildFileGraph() {
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        const boundaries = dm?.getFileBoundaries ? dm.getFileBoundaries() : [];
        const nodes = dm?.getNodes ? dm.getNodes() : [];
        const links = dm?.getLinks ? dm.getLinks() : [];

        // Get current atom positions from Graph for centroid calculation
        const currentGraphNodes = (typeof Graph !== 'undefined' && Graph)
            ? (Graph.graphData()?.nodes || [])
            : [];
        const atomPositions = new Map();
        currentGraphNodes.forEach(n => {
            if (n && n.id && Number.isFinite(n.x) && Number.isFinite(n.y)) {
                atomPositions.set(n.id, { x: n.x, y: n.y, z: n.z || 0 });
            }
        });

        const totalFiles = boundaries.length;
        const fileNodes = [];
        _fileNodeIds.clear();
        const nodeFileIdx = new Map();

        // Build node -> fileIdx mapping
        nodes.forEach(n => {
            if (n && n.id) {
                nodeFileIdx.set(n.id, n.fileIdx ?? -1);
            }
        });

        // Build file -> atoms mapping for centroid calculation
        const fileAtoms = new Map(); // fileIdx -> [atom positions]
        nodes.forEach(n => {
            if (n && n.id && n.fileIdx !== undefined && n.fileIdx >= 0) {
                const pos = atomPositions.get(n.id);
                if (pos) {
                    if (!fileAtoms.has(n.fileIdx)) fileAtoms.set(n.fileIdx, []);
                    fileAtoms.get(n.fileIdx).push(pos);
                }
            }
        });

        // Create file nodes with centroid positions
        boundaries.forEach((boundary, idx) => {
            const label = boundary.file_name || boundary.file || `file-${idx}`;
            const atomCount = boundary.atom_count || 1;
            const nodeId = `file:${idx}`;
            _fileNodeIds.set(idx, nodeId);

            // Calculate centroid from atom positions (SMOOTH TRANSITION)
            const atoms = fileAtoms.get(idx) || [];
            let cx = 0, cy = 0, cz = 0;
            if (atoms.length > 0) {
                atoms.forEach(p => { cx += p.x; cy += p.y; cz += p.z; });
                cx /= atoms.length;
                cy /= atoms.length;
                cz /= atoms.length;
            } else {
                // Fallback: radial layout for files with no positioned atoms
                const angle = (idx / totalFiles) * Math.PI * 2;
                const radius = 200;
                cx = Math.cos(angle) * radius;
                cy = Math.sin(angle) * radius;
                cz = (Math.random() - 0.5) * 50;
            }

            fileNodes.push({
                id: nodeId,
                name: label,
                fileIdx: idx,
                isFileNode: true,
                // POSITION: Initialize at centroid of atoms for smooth transition
                x: cx, y: cy, z: cz,
                fx: undefined, fy: undefined, fz: undefined, // Allow physics to relax
                val: Math.max(2, Math.sqrt(atomCount) * 1.5), // Size by atom count
                color: getColor(idx, totalFiles, label),
                file_path: boundary.file || '',
                atom_count: atomCount,
                // Enriched file metadata for hover panel and visual mappings
                tier: boundary.tier || 'UNKNOWN',
                ring: boundary.ring || 'UNKNOWN',
                internal_edges: boundary.internal_edges || 0,
                external_edges: boundary.external_edges || 0,
                // Physical metadata
                size_bytes: boundary.size_bytes ?? 0,
                size_kb: boundary.size_kb ?? 0,
                token_estimate: boundary.token_estimate ?? 0,
                line_count: boundary.line_count ?? 0,
                code_lines: boundary.code_lines ?? 0,
                // Temporal metadata
                age_days: boundary.age_days ?? 0,
                modified_date: boundary.modified_date || '',
                is_stale: boundary.is_stale ?? false,
                is_recent: boundary.is_recent ?? false,
                // Categorical metadata
                format_category: boundary.format_category || 'other',
                purpose: boundary.purpose || 'general',
                extension: boundary.extension || '',
                is_test: boundary.is_test ?? false,
                is_config: boundary.is_config ?? false,
                // Complexity metadata
                complexity_density: boundary.complexity_density ?? 0,
                cohesion: boundary.cohesion ?? 0.5,
                code_ratio: boundary.code_ratio ?? 0.5
            });
        });

        // Build inter-file edges with weights
        const edgeMap = new Map();
        links.forEach(link => {
            const srcId = _getLinkEndpointId(link, 'source');
            const tgtId = _getLinkEndpointId(link, 'target');
            const srcIdx = nodeFileIdx.get(srcId) ?? -1;
            const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;

            // Skip internal edges and invalid indices
            if (srcIdx < 0 || tgtIdx < 0 || srcIdx === tgtIdx) return;

            const key = `${srcIdx}->${tgtIdx}`;
            const existing = edgeMap.get(key) || {
                source: _fileNodeIds.get(srcIdx),
                target: _fileNodeIds.get(tgtIdx),
                weight: 0,
                edge_type: 'file-dependency',
                resolution: 'file'
            };
            existing.weight += 1;
            edgeMap.set(key, existing);
        });

        _fileGraph = {
            nodes: fileNodes,
            links: Array.from(edgeMap.values())
        };

        console.log(`[FILE_VIZ] Built file graph: ${fileNodes.length} files, ${edgeMap.size} inter-file edges`);
        return _fileGraph;
    }

    function _getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (!endpoint) return null;
        if (typeof endpoint === 'object') return endpoint.id;
        return endpoint;
    }

    /**
     * Save current file node positions for smooth transitions
     */
    function captureFileNodePositions() {
        _fileNodePositions.clear();
        if (typeof Graph === 'undefined' || !Graph) return;

        const nodes = Graph.graphData()?.nodes || [];
        nodes.forEach(node => {
            if (node && node.isFileNode && Number.isFinite(node.x) && Number.isFinite(node.y)) {
                _fileNodePositions.set(node.fileIdx, {
                    x: node.x,
                    y: node.y,
                    z: Number.isFinite(node.z) ? node.z : 0
                });
            }
        });
    }

    /**
     * Restore saved positions to file nodes
     */
    function restoreFileNodePositions(nodes) {
        nodes.forEach(node => {
            if (node.isFileNode && _fileNodePositions.has(node.fileIdx)) {
                const pos = _fileNodePositions.get(node.fileIdx);
                node.x = pos.x;
                node.y = pos.y;
                node.z = pos.z;
            }
        });
    }

    /**
     * Get file target position for radial layout
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpread) {
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: (Math.random() - 0.5) * zSpread
        };
    }

    /**
     * Expand a file to show its atoms
     */
    function expandFile(fileIdx) {
        _expandedFiles.add(fileIdx);
        _graphMode = 'hybrid';
        if (typeof refreshGraph === 'function') refreshGraph();
    }

    /**
     * Collapse a file to hide its atoms
     */
    function collapseFile(fileIdx) {
        _expandedFiles.delete(fileIdx);
        _graphMode = _expandedFiles.size > 0 ? 'hybrid' : 'files';
        if (typeof refreshGraph === 'function') refreshGraph();
    }

    /**
     * Toggle file expansion
     */
    function toggleFileExpansion(fileIdx) {
        if (_expandedFiles.has(fileIdx)) {
            collapseFile(fileIdx);
        } else {
            expandFile(fileIdx);
        }
    }

    /**
     * Apply the file graph to the visualization
     */
    function applyFileGraphMode() {
        if (!_fileGraph) {
            buildFileGraph();
        }
        if (!_fileGraph || typeof Graph === 'undefined' || !Graph) return;

        restoreFileNodePositions(_fileGraph.nodes);
        Graph.graphData(_fileGraph);
        applyColors(_fileGraph.nodes);

        // UPB Hook: Re-apply any active bindings to the new file nodes
        if (window.UPB && typeof window.UPB.apply === 'function') {
            // CRITICAL FIX: Recalculate ranges for FILE nodes because they track
            // much larger values (e.g. Total Tokens) than individual Atoms.
            // Without this, everything gets clamped to 1.0 (Max Size/Color).
            if (window.UPB.BINDINGS && window.UPB.BINDINGS.defaultGraph) {
                const activeBindings = window.UPB.BINDINGS.defaultGraph._bindings;
                const newRanges = {};

                Object.keys(activeBindings).forEach(targetKey => {
                    const bindings = activeBindings[targetKey];
                    bindings.forEach(b => {
                        const sourceKey = b.source;
                        // Extract values from file nodes for this source
                        const values = _fileGraph.nodes
                            .map(n => n[sourceKey])
                            .filter(v => typeof v === 'number');

                        if (values.length > 0) {
                            newRanges[sourceKey] = {
                                min: Math.min(...values),
                                max: Math.max(...values)
                            };
                        }
                    });
                });

                // Update graph ranges for this context
                window.UPB.init(newRanges);
            }

            const updates = window.UPB.apply(_fileGraph.nodes);

            // Apply updates to nodes
            updates.forEach(update => {
                const node = _fileGraph.nodes.find(n => n.id === update.id);
                if (node && update.visuals) {
                    Object.keys(update.visuals).forEach(key => {
                        if (typeof CONTROL_BAR !== 'undefined' && CONTROL_BAR.applyToNode) {
                            CONTROL_BAR.applyToNode(node, key, update.visuals[key]);
                        }
                    });
                }
            });
        }

        // Reheat simulation for nice spread
        Graph.d3ReheatSimulation();

        if (typeof showToast === 'function') {
            showToast(`File view: ${_fileGraph.nodes.length} files. Click to expand atoms.`);
        }
    }

    // =========================================================================
    // BOUNDARY MANAGEMENT
    // =========================================================================

    function clearBoundaries() {
        if (typeof Graph === 'undefined' || !Graph) return;
        const scene = Graph.scene();
        if (!scene) return;

        _boundaryMeshes.forEach(mesh => scene.remove(mesh));
        _boundaryMeshes = [];
    }

    function scheduleHullRedraw(delayMs = 1200) {
        if (_hullRedrawTimer) {
            clearTimeout(_hullRedrawTimer);
        }
        _hullRedrawTimer = setTimeout(() => {
            if (!(_enabled && _mode === 'hulls')) {
                _hullRedrawAttempts = 0;
                return;
            }

            // Call external drawFileBoundaries if available
            if (typeof drawFileBoundaries === 'function') {
                const drawn = drawFileBoundaries(null);
                if (drawn === 0 && _hullRedrawAttempts < 3) {
                    _hullRedrawAttempts += 1;
                    scheduleHullRedraw(1000);
                }
            }
        }, delayMs);
    }

    // =========================================================================
    // MODE CLEARING
    // =========================================================================

    function clearAllModes() {
        clearBoundaries();

        // Reset file cohesion force if active
        if (typeof clearFileCohesion === 'function') {
            clearFileCohesion();
        }

        // Reset cluster force if active
        if (typeof clusterForceActive !== 'undefined' && clusterForceActive &&
            typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('cluster', null);
            if (typeof DEFAULT_LINK_DISTANCE !== 'undefined' && DEFAULT_LINK_DISTANCE !== null) {
                Graph.d3Force('link').distance(DEFAULT_LINK_DISTANCE);
            }
            Graph.d3ReheatSimulation();
        }

        // Stop containment animation if active
        if (typeof stopContainmentAnimation === 'function') {
            stopContainmentAnimation();
        }

        // Clear containment spheres
        if (typeof FILE_CONTAINMENT !== 'undefined' && FILE_CONTAINMENT?.spheres) {
            const scene = typeof Graph !== 'undefined' ? Graph?.scene() : null;
            if (scene) {
                FILE_CONTAINMENT.spheres.forEach(s => {
                    if (s.mesh) scene.remove(s.mesh);
                });
            }
            FILE_CONTAINMENT.spheres = [];
            FILE_CONTAINMENT.boundariesPopped = false;
        }

        // Clear lingering filters
        if (typeof VIS_FILTERS !== 'undefined') {
            const filterSets = ['rings', 'tiers', 'families', 'files', 'roles', 'edges', 'layers', 'effects', 'edgeFamilies'];
            filterSets.forEach(key => {
                if (VIS_FILTERS[key]?.clear) VIS_FILTERS[key].clear();
            });
            document.querySelectorAll('.filter-chip.active').forEach(c => c.classList.remove('active'));
        }

        // Reset POP button state
        const popBtn = document.getElementById('btn-file-pop');
        if (popBtn) {
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
        }
    }

    // =========================================================================
    // SET FILE MODE STATE
    // =========================================================================

    function setEnabled(enabled) {
        _enabled = enabled;

        // Update UI buttons
        const cmdBtn = document.getElementById('cmd-files');
        if (cmdBtn) cmdBtn.classList.toggle('active', _enabled);
        const dockBtn = document.getElementById('btn-files');
        if (dockBtn) dockBtn.classList.toggle('active', _enabled);

        // Update panels
        const filePanel = document.getElementById('file-panel');
        const modeControls = document.getElementById('file-mode-controls');
        const expandControls = document.getElementById('file-expand-controls');

        if (_enabled) {
            if (filePanel) filePanel.classList.add('visible');
            if (modeControls) modeControls.classList.add('visible');
            if (expandControls) expandControls.classList.toggle('visible', _mode === 'map');
            apply();
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            // Use unified LAYOUT module for reflow
            if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
        } else {
            if (filePanel) filePanel.classList.remove('visible');
            if (modeControls) modeControls.classList.remove('visible');
            if (expandControls) expandControls.classList.remove('visible');

            // Clear expanded files
            if (typeof EXPANDED_FILES !== 'undefined') EXPANDED_FILES.clear();
            if (typeof GRAPH_MODE !== 'undefined') window.GRAPH_MODE = 'atoms';

            // Use unified LAYOUT module for reflow
            if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();

            clearAllModes();
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            if (typeof refreshGraph === 'function') refreshGraph();
        }
    }

    function toggle() {
        setEnabled(!_enabled);
    }

    // =========================================================================
    // SET VIZ MODE
    // =========================================================================

    function setMode(mode) {
        if (!MODES.includes(mode)) return;
        _mode = mode;

        // Update button states
        document.querySelectorAll('.file-mode-btn').forEach(btn => btn.classList.remove('active'));
        const modeBtn = document.getElementById('btn-file-' + mode);
        if (modeBtn) modeBtn.classList.add('active');

        // Toggle expand controls visibility
        const expandControls = document.getElementById('file-expand-controls');
        if (expandControls) expandControls.classList.toggle('visible', _mode === 'map');
        if (_mode === 'map' && typeof updateExpandButtons === 'function') {
            updateExpandButtons();
        }

        // Update graph mode
        if (_mode === 'map') {
            const hasExpanded = typeof EXPANDED_FILES !== 'undefined' && EXPANDED_FILES.size > 0;
            if (typeof GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = hasExpanded ? 'hybrid' : 'files';
            }
        } else {
            if (typeof EXPANDED_FILES !== 'undefined') EXPANDED_FILES.clear();
            if (typeof GRAPH_MODE !== 'undefined') window.GRAPH_MODE = 'atoms';
        }

        // Apply mode
        if (!_enabled) {
            setEnabled(true);
        } else if (_mode === 'map') {
            apply();
        } else {
            if (typeof refreshGraph === 'function') refreshGraph();
        }
    }

    // =========================================================================
    // APPLY CURRENT MODE
    // =========================================================================

    function apply() {
        if (!_enabled) return;

        // Clear previous state
        clearBoundaries();
        if (_mode !== 'hulls') {
            _hullRedrawAttempts = 0;
        }

        // Get graph nodes
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        const graphNodes = dm?.getVisibleNodes ?
            dm.getVisibleNodes() :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes || [] : []);

        // Apply file cohesion for color/hulls/cluster modes
        if (_mode === 'color' || _mode === 'hulls' || _mode === 'cluster') {
            if (typeof applyFileCohesion === 'function' && dm?.raw) {
                const physicsPayload = { physics: dm.raw.physics, config: dm.raw.config };
                applyFileCohesion(physicsPayload);
            }
        }

        if (_mode === 'color') {
            applyColors(graphNodes);
        }
        else if (_mode === 'hulls') {
            applyColors(graphNodes);
            scheduleHullRedraw(1500);
        }
        else if (_mode === 'cluster') {
            applyColors(graphNodes);
            if (typeof applyClusterForce === 'function' && dm?.raw) {
                applyClusterForce(dm.raw);
            }
        }
        else if (_mode === 'map') {
            const hasExpanded = typeof EXPANDED_FILES !== 'undefined' && EXPANDED_FILES.size > 0;
            if (typeof GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = hasExpanded ? 'hybrid' : 'files';
            }
            if (typeof refreshGraph === 'function') refreshGraph();
            if (typeof showToast === 'function') {
                showToast('File map active. Click a file node to expand.');
            }
        }
        else if (_mode === 'spheres') {
            applyColors(graphNodes);
            if (typeof buildDirectoryTree === 'function' && dm?.raw) {
                buildDirectoryTree(dm.raw);
            }
            if (typeof computeFileActivity === 'function' && dm?.raw) {
                computeFileActivity(dm.raw, graphNodes);
            }
            if (typeof drawContainmentSpheres === 'function' && dm?.raw) {
                drawContainmentSpheres(dm.raw, graphNodes);
            }
            if (typeof startContainmentAnimation === 'function') {
                startContainmentAnimation();
            }
            if (typeof showToast === 'function') {
                showToast('Containment spheres active. Files as force fields. Click POP! to release.');
            }
        }
    }

    // =========================================================================
    // FILE CLUSTERING FORCES - D3 force manipulation for file grouping
    // =========================================================================

    let _clusterForceActive = false;
    let _fileCohesionActive = false;

    /**
     * Apply cluster force to group nodes by file
     * Creates fixed target positions arranged in a circular pattern
     */
    function applyClusterForce(data) {
        const Graph = window.Graph;
        const DM = window.DM;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const IS_3D = window.IS_3D;

        const clusterConfig = data?.physics?.cluster || {};
        const modeStrength = (typeof clusterConfig.modes?.strong === 'number') ? clusterConfig.modes.strong : null;
        const sliderStrength = (typeof APPEARANCE_STATE?.clusterStrength === 'number') ? APPEARANCE_STATE.clusterStrength : null;
        const clusterStrength = (typeof sliderStrength === 'number')
            ? sliderStrength
            : ((typeof modeStrength === 'number')
                ? modeStrength
                : ((typeof clusterConfig.strength === 'number') ? clusterConfig.strength : 0.3));
        const clusterRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius : 150;
        const clusterZSpacing = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing : 30;
        const linkDistance = (typeof clusterConfig.linkDistance === 'number')
            ? clusterConfig.linkDistance
            : (data?.physics?.forces?.link?.distance || 50);

        const graphNodes = DM ? DM.getVisibleNodes() : (Graph?.graphData()?.nodes || []);
        const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
        const numFiles = boundaries.length;

        // Fixed target positions: arrange files in circular pattern
        const fileTargets = {};
        for (let i = 0; i < numFiles; i++) {
            fileTargets[i] = getFileTarget(i, numFiles, clusterRadius, clusterZSpacing);
        }

        // Reduce link distance to keep intra-file nodes tighter
        Graph.d3Force('link').distance(linkDistance);

        // Apply strong clustering force toward fixed targets
        Graph.d3Force('cluster', (alpha) => {
            const k = alpha * clusterStrength;
            graphNodes.forEach(node => {
                const target = fileTargets[node.fileIdx];
                if (target) {
                    node.vx = (node.vx || 0) + (target.x - node.x) * k;
                    node.vy = (node.vy || 0) + (target.y - node.y) * k;
                    if (IS_3D) {
                        node.vz = (node.vz || 0) + (target.z - node.z) * k;
                    }
                }
            });
        });

        _clusterForceActive = true;
        Graph.d3ReheatSimulation();
        scheduleHullRedraw(1500);
    }

    /**
     * Apply file cohesion force - nodes in same file attract each other
     * Also stretches inter-file links for better separation
     */
    function applyFileCohesion(data) {
        if (_fileCohesionActive) return;

        const Graph = window.Graph;
        const DM = window.DM;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const IS_3D = window.IS_3D;
        const DEFAULT_LINK_DISTANCE = window.DEFAULT_LINK_DISTANCE || 50;

        const config = data?.physics?.fileCohesion || {};
        const strength = (typeof APPEARANCE_STATE?.fileCohesionStrength === 'number')
            ? APPEARANCE_STATE.fileCohesionStrength
            : (config.strength ?? 0.15);
        const linkMult = config.interFileLinkMultiplier ?? 2.5;
        const minDist = config.minDistance ?? 20;

        const nodes = DM ? DM.getVisibleNodes() : (Graph?.graphData()?.nodes || []);
        if (!nodes.length) return;

        // Pre-compute file groups
        const groups = new Map();
        nodes.forEach(n => {
            const f = n.fileIdx ?? -1;
            if (f >= 0) (groups.get(f) || groups.set(f, []).get(f)).push(n);
        });

        // Intra-file centroid attraction
        Graph.d3Force('fileCohesion', (alpha) => {
            const k = strength * alpha;
            groups.forEach(g => {
                if (g.length < 2) return;
                let cx = 0, cy = 0, cz = 0;
                g.forEach(n => { cx += n.x || 0; cy += n.y || 0; cz += n.z || 0; });
                cx /= g.length; cy /= g.length; cz /= g.length;
                g.forEach(n => {
                    const dx = cx - (n.x || 0), dy = cy - (n.y || 0), dz = cz - (n.z || 0);
                    const d = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;
                    if (d > minDist) {
                        const f = k * Math.min(1, d / 100);
                        n.vx = (n.vx || 0) + dx * f;
                        n.vy = (n.vy || 0) + dy * f;
                        if (IS_3D) n.vz = (n.vz || 0) + dz * f;
                    }
                });
            });
        });

        // Inter-file links stretched
        const base = DEFAULT_LINK_DISTANCE;
        Graph.d3Force('link').distance(link => {
            const s = typeof link.source === 'object' ? link.source : nodes.find(n => n.id === link.source);
            const t = typeof link.target === 'object' ? link.target : nodes.find(n => n.id === link.target);
            if (!s || !t) return base;
            const sf = s.fileIdx ?? -1, tf = t.fileIdx ?? -1;
            return (sf >= 0 && tf >= 0 && sf !== tf) ? base * linkMult : base;
        });

        _fileCohesionActive = true;
        Graph.d3ReheatSimulation();
    }

    /**
     * Clear file cohesion force
     */
    function clearFileCohesion() {
        if (!_fileCohesionActive) return;

        const Graph = window.Graph;
        const DEFAULT_LINK_DISTANCE = window.DEFAULT_LINK_DISTANCE;

        Graph.d3Force('fileCohesion', null);
        if (DEFAULT_LINK_DISTANCE !== null) {
            Graph.d3Force('link').distance(DEFAULT_LINK_DISTANCE);
        }
        _fileCohesionActive = false;
        Graph.d3ReheatSimulation();
    }

    /**
     * Clear cluster force
     */
    function clearClusterForce() {
        if (!_clusterForceActive) return;

        const Graph = window.Graph;
        Graph.d3Force('cluster', null);
        _clusterForceActive = false;
        Graph.d3ReheatSimulation();
    }

    // =========================================================================
    // FILE CONTAINMENT SYSTEM - Spherical fields with particle physics
    // "Metaphysical force from another dimension" - holding particles together
    // =========================================================================

    const _containment = {
        spheres: [],              // Three.js sphere meshes
        directoryTree: null,      // Parsed directory hierarchy
        particleActivity: {},     // FileIdx → activity level (0-1)
        boundariesPopped: false,  // Animation state
        popProgress: 0,           // 0 = contained, 1 = fully free
        slowMotionFactor: 0.15,   // Time multiplier for dreamy slow motion
        collisionEnabled: true,   // Enable soft collisions
        spatialGrid: null,        // For efficient collision detection
        gridCellSize: 20,         // Size of spatial hash cells
        animationFrame: null,
        isAnimating: false
    };

    /**
     * Toggle file expansion for a single file
     */
    function toggleFileExpand(fileIdx) {
        if (!Number.isFinite(fileIdx)) return;
        captureFileNodePositions();
        const dm = typeof DATA !== 'undefined' ? DATA : (typeof DM !== 'undefined' ? DM : null);
        const fileInfo = dm ? dm.getFile(fileIdx) : {};
        const fileLabel = fileInfo?.file_name || fileInfo?.file || `file-${fileIdx}`;
        if (_expandedFiles.has(fileIdx)) {
            _expandedFiles.delete(fileIdx);
            if (typeof showToast === 'function') showToast(`Collapsed ${fileLabel}`);
        } else {
            _expandedFiles.clear();
            _expandedFiles.add(fileIdx);
            if (typeof showToast === 'function') showToast(`Expanded ${fileLabel}`);
        }
        window.GRAPH_MODE = (_expandedFiles.size > 0) ? 'hybrid' : 'files';
        if (typeof refreshGraph === 'function') refreshGraph();
    }

    /**
     * Draw file boundary hulls
     */
    function drawFileBoundaries(data) {
        const Graph = window.Graph;
        const IS_3D = window.IS_3D;
        const APPEARANCE_STATE = window.APPEARANCE_STATE || {};
        const dm = typeof DATA !== 'undefined' ? DATA : (typeof DM !== 'undefined' ? DM : null);

        let drawn = 0;
        const boundaryConfig = data?.appearance?.boundary || {};
        const fillOpacity =
            (typeof APPEARANCE_STATE.boundaryFill === 'number')
                ? APPEARANCE_STATE.boundaryFill
                : (boundaryConfig.fill_opacity || 0.08);
        const wireOpacity =
            (typeof APPEARANCE_STATE.boundaryWire === 'number')
                ? APPEARANCE_STATE.boundaryWire
                : (boundaryConfig.wire_opacity || 0.3);
        const padding = boundaryConfig.padding || 1.2;
        const minExtent = boundaryConfig.min_extent || 6;
        const quantileRange = boundaryConfig.quantile || 0.9;
        const lowQ = Math.max(0, (1 - quantileRange) / 2);
        const highQ = Math.min(1, 1 - lowQ);
        const boundaryPhysics = data?.physics?.boundary || {};
        const hullType = String(boundaryPhysics.hullType || 'convex').toLowerCase();
        const fileBoundaries = dm ? dm.getFileBoundaries() : (data?.file_boundaries || []);
        const totalFiles = fileBoundaries.length;

        const graphNodes = dm ? dm.getVisibleNodes() : (Graph?.graphData()?.nodes || []);
        const scene = Graph?.scene();
        if (!scene) return drawn;

        // Clear existing boundary meshes
        _boundaryMeshes.forEach(mesh => scene.remove(mesh));
        _boundaryMeshes = [];

        if (!_enabled) return drawn;

        // Group nodes by file (only use nodes with stable positions)
        const fileGroups = {};
        const validNodes = graphNodes.filter(node => {
            if (!node) return false;
            if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return false;
            if (IS_3D && !Number.isFinite(node.z)) return false;
            return true;
        });

        if (!validNodes.length) return drawn;

        validNodes.forEach(node => {
            const idx = node.fileIdx;
            if (idx >= 0) {
                if (!fileGroups[idx]) fileGroups[idx] = [];
                fileGroups[idx].push(node);
            }
        });

        // Draw boundary for each file group
        Object.entries(fileGroups).forEach(([fileIdx, nodes]) => {
            const sampled = typeof sampleFileNodes === 'function' ? sampleFileNodes(nodes, 180) : nodes.slice(0, 180);
            const xs = sampled.map(n => n.x || 0);
            const ys = sampled.map(n => n.y || 0);
            const zs = sampled.map(n => n.z || 0);

            const quantileFn = typeof quantile === 'function' ? quantile : (arr, q) => arr.sort((a, b) => a - b)[Math.floor(arr.length * q)] || 0;
            const minX = quantileFn(xs, lowQ);
            const maxX = quantileFn(xs, highQ);
            const minY = quantileFn(ys, lowQ);
            const maxY = quantileFn(ys, highQ);
            const minZ = quantileFn(zs, lowQ);
            const maxZ = quantileFn(zs, highQ);

            const filtered = sampled.filter(n => {
                const x = n.x || 0;
                const y = n.y || 0;
                const z = n.z || 0;
                return x >= minX && x <= maxX && y >= minY && y <= maxY && z >= minZ && z <= maxZ;
            });
            const hullNodes = filtered.length >= 3 ? filtered : sampled;
            const positions = hullNodes.map(n => new THREE.Vector3(n.x || 0, n.y || 0, n.z || 0));
            const centroid = typeof computeCentroid === 'function' ? computeCentroid(positions) :
                new THREE.Vector3(
                    positions.reduce((s, p) => s + p.x, 0) / positions.length,
                    positions.reduce((s, p) => s + p.y, 0) / positions.length,
                    positions.reduce((s, p) => s + p.z, 0) / positions.length
                );
            const zRange = maxZ - minZ;
            const extentX = Math.max(0.001, maxX - minX);
            const extentY = Math.max(0.001, maxY - minY);
            const extentZ = Math.max(0.001, maxZ - minZ);
            const scaleFixX = Math.max(1, minExtent / extentX);
            const scaleFixY = Math.max(1, minExtent / extentY);
            const scaleFixZ = IS_3D ? Math.max(1, minExtent / extentZ) : 1;
            const scaleX = padding * scaleFixX;
            const scaleY = padding * scaleFixY;
            const scaleZ = padding * scaleFixZ;
            const sizeX = extentX * scaleX;
            const sizeY = extentY * scaleY;
            const sizeZ = extentZ * scaleZ;

            const fileIndex = Number.parseInt(fileIdx, 10);
            const safeFileIdx = Number.isFinite(fileIndex) ? fileIndex : 0;
            const fileInfo = (fileBoundaries || [])[safeFileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            const color = new THREE.Color(getColor(safeFileIdx, totalFiles, fileLabel));

            let mesh = null;
            let wireMesh = null;

            if (nodes.length < 3) {
                const rawPositions = nodes.map(n => new THREE.Vector3(n.x || 0, n.y || 0, n.z || 0));
                const smallCentroid = typeof computeCentroid === 'function' ? computeCentroid(rawPositions) :
                    new THREE.Vector3(
                        rawPositions.reduce((s, p) => s + p.x, 0) / rawPositions.length,
                        rawPositions.reduce((s, p) => s + p.y, 0) / rawPositions.length,
                        rawPositions.reduce((s, p) => s + p.z, 0) / rawPositions.length
                    );
                const maxRadius = rawPositions.reduce((acc, p) => {
                    return Math.max(acc, p.distanceTo(smallCentroid));
                }, 0);
                const bubbleRadius = Math.max(minExtent * 0.5, maxRadius + minExtent * 0.35);
                const material = new THREE.MeshBasicMaterial({
                    color: color, transparent: true, opacity: fillOpacity,
                    wireframe: false, side: THREE.DoubleSide
                });
                if (IS_3D) {
                    const geometry = new THREE.SphereGeometry(bubbleRadius, 14, 10);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.copy(smallCentroid);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(geometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                } else {
                    const geometry = new THREE.CircleGeometry(bubbleRadius, 32);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(smallCentroid.x, smallCentroid.y, smallCentroid.z);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(geometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                }
            }

            if (!mesh && hullType === 'convex') {
                if (IS_3D && zRange > 0.001 && positions.length >= 4) {
                    const ConvexCtor =
                        (typeof ConvexGeometry !== 'undefined')
                            ? ConvexGeometry
                            : (THREE.ConvexGeometry || null);
                    const relPoints = positions.map(p => p.clone().sub(centroid));
                    let boundaryGeometry = null;
                    if (ConvexCtor) {
                        try { boundaryGeometry = new ConvexCtor(relPoints); }
                        catch (err) { boundaryGeometry = null; }
                    }
                    if (boundaryGeometry) {
                        const material = new THREE.MeshBasicMaterial({
                            color: color, transparent: true, opacity: fillOpacity,
                            wireframe: false, side: THREE.DoubleSide
                        });
                        mesh = new THREE.Mesh(boundaryGeometry, material);
                        mesh.position.copy(centroid);
                        mesh.scale.set(scaleX, scaleY, scaleZ);
                        const wireMaterial = new THREE.LineBasicMaterial({
                            color: color, transparent: true, opacity: wireOpacity
                        });
                        const edges = new THREE.EdgesGeometry(boundaryGeometry);
                        wireMesh = new THREE.LineSegments(edges, wireMaterial);
                        wireMesh.position.copy(centroid);
                        wireMesh.scale.copy(mesh.scale);
                    }
                }

                if (!mesh) {
                    const hull2d = typeof buildHull2D === 'function' ?
                        buildHull2D(positions.map(p => new THREE.Vector2(p.x, p.y))) : null;
                    if (!hull2d || hull2d.length < 3) return;
                    const localHull = hull2d.map(p => new THREE.Vector2(p.x - centroid.x, p.y - centroid.y));
                    const shape = new THREE.Shape(localHull);
                    const boundaryGeometry = new THREE.ShapeGeometry(shape);
                    const material = new THREE.MeshBasicMaterial({
                        color: color, transparent: true, opacity: fillOpacity,
                        wireframe: false, side: THREE.DoubleSide
                    });
                    mesh = new THREE.Mesh(boundaryGeometry, material);
                    mesh.position.set(centroid.x, centroid.y, centroid.z);
                    mesh.scale.set(scaleX, scaleY, 1);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const wireGeometry = new THREE.BufferGeometry().setFromPoints(
                        localHull.map(p => new THREE.Vector3(p.x, p.y, 0))
                    );
                    wireMesh = new THREE.LineLoop(wireGeometry, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                    wireMesh.scale.copy(mesh.scale);
                }
            } else if (!mesh && hullType === 'box') {
                const material = new THREE.MeshBasicMaterial({
                    color: color, transparent: true, opacity: fillOpacity,
                    wireframe: false, side: THREE.DoubleSide
                });
                if (IS_3D) {
                    const geometry = new THREE.BoxGeometry(sizeX, sizeY, sizeZ);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.copy(centroid);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(geometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                } else {
                    const geometry = new THREE.PlaneGeometry(sizeX, sizeY);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(centroid.x, centroid.y, centroid.z);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(geometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                }
            } else if (!mesh) {
                const radius = 0.5 * Math.max(sizeX, sizeY, IS_3D ? sizeZ : 0);
                const material = new THREE.MeshBasicMaterial({
                    color: color, transparent: true, opacity: fillOpacity,
                    wireframe: false, side: THREE.DoubleSide
                });
                if (IS_3D) {
                    const geometry = new THREE.SphereGeometry(radius, 18, 14);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.copy(centroid);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(geometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                } else {
                    const geometry = new THREE.CircleGeometry(radius, 40);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(centroid.x, centroid.y, centroid.z);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(geometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                }
            }

            if (!mesh) return;
            scene.add(mesh);
            _boundaryMeshes.push(mesh);
            drawn += 1;
            if (wireMesh) {
                scene.add(wireMesh);
                _boundaryMeshes.push(wireMesh);
            }
        });
        return drawn;
    }

    /**
     * Build directory tree from file paths
     */
    function buildDirectoryTree(data) {
        const fileBoundaries = data?.file_boundaries || [];
        const tree = { name: '/', path: '', depth: 0, children: {}, files: [], totalNodes: 0 };

        fileBoundaries.forEach((file, idx) => {
            const filePath = file.file || file.file_name || '';
            const parts = filePath.split('/').filter(p => p);
            let current = tree;

            parts.forEach((part, partIdx) => {
                const isFile = partIdx === parts.length - 1;
                if (isFile) {
                    current.files.push({
                        name: part, path: filePath, fileIdx: idx,
                        nodeCount: (file.atom_ids || []).length, activity: 0
                    });
                } else {
                    if (!current.children[part]) {
                        current.children[part] = {
                            name: part, path: parts.slice(0, partIdx + 1).join('/'),
                            depth: partIdx + 1, children: {}, files: [], totalNodes: 0
                        };
                    }
                    current = current.children[part];
                }
            });
        });

        _containment.directoryTree = tree;
        return tree;
    }

    /**
     * Compute activity levels from markov transitions
     */
    function computeFileActivity(data) {
        const markov = data?.markov || {};
        const highEntropy = markov.high_entropy_nodes || [];
        const transitions = markov.transitions || {};
        const fileActivity = {};

        (data?.file_boundaries || []).forEach((file, idx) => {
            const atomIds = file.atom_ids || [];
            let activity = 0;
            atomIds.forEach(atomId => {
                if (highEntropy.some(h => h.node === atomId)) activity += 0.3;
                const fanout = Object.keys(transitions[atomId] || {}).length;
                activity += Math.min(fanout / 10, 0.5);
            });
            fileActivity[idx] = Math.min(1, activity / Math.max(1, atomIds.length));
        });

        _containment.particleActivity = fileActivity;
        return fileActivity;
    }

    /**
     * Draw containment spheres/boxes
     */
    function drawContainmentSpheres(_data) {
        const Graph = window.Graph;
        const flowMode = window.flowMode;
        const dm = typeof DATA !== 'undefined' ? DATA : (typeof DM !== 'undefined' ? DM : null);

        const scene = Graph?.scene();
        if (!scene) return;
        const graphNodes = dm ? dm.getVisibleNodes() : (Graph?.graphData()?.nodes || []);

        // Clear existing
        _containment.spheres.forEach(s => {
            if (s.mesh) scene.remove(s.mesh);
            if (s.wireframe) scene.remove(s.wireframe);
            if (s.glow) scene.remove(s.glow);
        });
        _containment.spheres = [];

        const hullsActive = document.getElementById('btn-file-hulls')?.classList.contains('active');
        if (!_enabled || flowMode || !hullsActive || _containment.boundariesPopped) return;

        // Group nodes by file
        const fileGroups = {};
        graphNodes.filter(n => n && Number.isFinite(n.x)).forEach(node => {
            if (node.fileIdx >= 0) {
                if (!fileGroups[node.fileIdx]) fileGroups[node.fileIdx] = [];
                fileGroups[node.fileIdx].push(node);
            }
        });

        Object.entries(fileGroups).forEach(([fileIdx, nodes]) => {
            if (nodes.length < 3) return;

            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            nodes.forEach(n => {
                minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x);
                minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y);
                minZ = Math.min(minZ, n.z || 0); maxZ = Math.max(maxZ, n.z || 0);
            });

            const pad = 10;
            const width = (maxX - minX) + pad * 2;
            const height = (maxY - minY) + pad * 2;
            const depth = (maxZ - minZ) + pad * 2;

            if (width < 5 || height < 5 || depth < 5) return;

            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;
            const cz = (minZ + maxZ) / 2;

            const geometry = new THREE.BoxGeometry(width, height, depth);
            const color = new THREE.Color(nodes[0].color || '#4488ff');

            const material = new THREE.MeshLambertMaterial({
                color: color, transparent: true, opacity: 0.15,
                depthWrite: false, side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(cx, cy, cz);
            scene.add(mesh);

            const wireGeo = new THREE.EdgesGeometry(geometry);
            const wireMat = new THREE.LineBasicMaterial({
                color: color, transparent: true, opacity: 0.4,
                blending: THREE.AdditiveBlending
            });
            const wireframe = new THREE.LineSegments(wireGeo, wireMat);
            wireframe.position.set(cx, cy, cz);
            scene.add(wireframe);

            _containment.spheres.push({
                mesh, wireframe,
                fileIdx: parseInt(fileIdx),
                velocity: new THREE.Vector3(0, 0, 0),
                activity: _containment.particleActivity[fileIdx] || 0,
                nodes: nodes.map(n => n.id)
            });
        });
    }

    /**
     * Start containment animation loop
     */
    function startContainmentAnimation() {
        if (_containment.isAnimating) return;
        _containment.isAnimating = true;
        const Graph = window.Graph;
        const IS_3D = window.IS_3D;

        function animate() {
            if (!_containment.isAnimating) return;

            const time = Date.now() * 0.001 * _containment.slowMotionFactor;
            const graphNodes = Graph?.graphData()?.nodes || [];

            if (_containment.boundariesPopped) {
                if (typeof applySoftCollisions === 'function') {
                    applySoftCollisions(graphNodes, _containment.gridCellSize, 0.4);
                }

                graphNodes.forEach(node => {
                    if (!node || !node.__physics) return;
                    const p = node.__physics;
                    const wander = 0.08;
                    p.vx += (Math.sin(time * 0.7 + (node.__wanderPhase || 0)) - 0.5) * wander;
                    p.vy += (Math.cos(time * 0.5 + (node.__wanderPhase || 0) * 1.3) - 0.5) * wander;
                    if (IS_3D) p.vz += (Math.sin(time * 0.6 + (node.__wanderPhase || 0) * 0.7) - 0.5) * wander;
                    p.vx *= 0.985;
                    p.vy *= 0.985;
                    p.vz *= 0.985;
                    node.x += p.vx;
                    node.y += p.vy;
                    if (IS_3D) node.z = (node.z || 0) + p.vz;
                });
            } else {
                _containment.spheres.forEach(sphere => {
                    const activity = sphere.activity;
                    const pulse = Math.sin(time * 2 + sphere.fileIdx) * 0.5 + 0.5;
                    if (sphere.mesh?.material) {
                        sphere.mesh.material.opacity = 0.04 + activity * 0.12 * pulse;
                    }
                    if (sphere.wireframe?.material) {
                        sphere.wireframe.material.opacity = 0.08 + activity * 0.2 * pulse;
                    }
                    if (activity < 0.05) return;

                    sphere.nodes.forEach(nodeId => {
                        const node = graphNodes.find(n => n.id === nodeId);
                        if (!node || !Number.isFinite(node.x)) return;
                        if (!node.__activityPhase) {
                            node.__activityPhase = {
                                x: Math.random() * Math.PI * 2,
                                y: Math.random() * Math.PI * 2,
                                z: Math.random() * Math.PI * 2
                            };
                        }
                        const amp = activity * 0.4;
                        const freq = 0.5 + activity * 0.5;
                        const phase = node.__activityPhase;
                        node.__renderOffsetX = Math.sin(time * freq + phase.x) * amp;
                        node.__renderOffsetY = Math.sin(time * freq * 1.2 + phase.y) * amp;
                        if (IS_3D) node.__renderOffsetZ = Math.sin(time * freq * 0.9 + phase.z) * amp;
                    });
                });
            }

            if (Graph) REFRESH.throttled();
            _containment.animationFrame = requestAnimationFrame(animate);
        }

        animate();
    }

    /**
     * Stop containment animation
     */
    function stopContainmentAnimation() {
        _containment.isAnimating = false;
        if (_containment.animationFrame) {
            cancelAnimationFrame(_containment.animationFrame);
        }
    }

    /**
     * Pop boundaries - release particles into free Brownian motion
     */
    function popBoundaries(duration = 3000) {
        if (_containment.boundariesPopped) {
            restoreBoundaries(duration);
            return;
        }

        console.log('[Containment] Popping boundaries...');
        _containment.boundariesPopped = true;
        const startTime = Date.now();
        const Graph = window.Graph;
        const IS_3D = window.IS_3D;
        const scene = Graph?.scene();
        const graphNodes = Graph?.graphData()?.nodes || [];

        graphNodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            node.__physics = {
                vx: (Math.random() - 0.5) * 1.5,
                vy: (Math.random() - 0.5) * 1.5,
                vz: IS_3D ? (Math.random() - 0.5) * 1.5 : 0
            };
            node.__wanderPhase = Math.random() * Math.PI * 2;
        });

        function animatePop() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);
            _containment.popProgress = progress;
            const eased = 1 - Math.pow(1 - progress, 3);

            _containment.spheres.forEach(s => {
                if (s.mesh?.material) s.mesh.material.opacity = (1 - eased) * 0.1;
                if (s.wireframe?.material) s.wireframe.material.opacity = (1 - eased) * 0.25;
                if (s.glow?.material) s.glow.material.opacity = (1 - eased) * 0.08;
            });

            if (progress < 1) {
                requestAnimationFrame(animatePop);
            } else {
                _containment.spheres.forEach(s => {
                    if (s.mesh) scene.remove(s.mesh);
                    if (s.wireframe) scene.remove(s.wireframe);
                    if (s.glow) scene.remove(s.glow);
                });
                _containment.spheres = [];
                console.log('[Containment] Particles now FREE - Brownian motion with collisions');
            }

            if (Graph) REFRESH.throttled();
        }

        animatePop();
        startContainmentAnimation();
    }

    /**
     * Restore boundaries
     */
    function restoreBoundaries(duration = 2000) {
        if (!_containment.boundariesPopped) return;

        console.log('[Containment] Restoring boundaries...');
        const startTime = Date.now();
        const Graph = window.Graph;
        const IS_3D = window.IS_3D;
        const dm = typeof DATA !== 'undefined' ? DATA : (typeof DM !== 'undefined' ? DM : null);
        const graphNodes = Graph?.graphData()?.nodes || [];

        graphNodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            node.__freePos = { x: node.x, y: node.y, z: node.z || 0 };
        });

        function animateRestore() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);
            _containment.popProgress = 1 - progress;
            const eased = Math.pow(progress, 2);

            graphNodes.forEach(node => {
                if (!node || !node.__freePos || !node.__originalPos) return;
                node.x = node.__freePos.x + (node.__originalPos.x - node.__freePos.x) * eased;
                node.y = node.__freePos.y + (node.__originalPos.y - node.__freePos.y) * eased;
                if (IS_3D) node.z = node.__freePos.z + ((node.__originalPos.z || 0) - node.__freePos.z) * eased;
            });

            if (progress < 1) {
                requestAnimationFrame(animateRestore);
            } else {
                _containment.boundariesPopped = false;
                drawContainmentSpheres(null);
                console.log('[Containment] Boundaries restored');
            }

            if (Graph) REFRESH.throttled();
        }

        animateRestore();
    }

    /**
     * Update expand mode buttons
     */
    function updateExpandButtons() {
        const inlineBtn = document.getElementById('btn-expand-inline');
        const detachBtn = document.getElementById('btn-expand-detach');
        if (inlineBtn) inlineBtn.classList.toggle('active', _expandMode === 'inline');
        if (detachBtn) detachBtn.classList.toggle('active', _expandMode === 'detach');
    }

    /**
     * Handle cmd-files button click
     */
    function handleCmdFiles() {
        const btn = document.getElementById('cmd-files');
        const isActive = btn ? btn.classList.contains('active') : false;
        setEnabled(!isActive);
    }

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getHue,
        applyColors,

        // Mode management
        setMode,
        get mode() { return _mode; },
        MODES,
        MODE_HINTS,

        // Enable/disable
        setEnabled,
        toggle,
        get enabled() { return _enabled; },

        // Apply
        apply,

        // FILE GRAPH - Repository as Nodes
        buildFileGraph,
        applyFileGraphMode,
        expandFile,
        collapseFile,
        toggleFileExpansion,
        captureFileNodePositions,
        restoreFileNodePositions,
        getFileTarget,
        get fileGraph() { return _fileGraph; },
        get fileNodeIds() { return _fileNodeIds; },
        get expandedFiles() { return _expandedFiles; },
        get graphMode() { return _graphMode; },
        set graphMode(val) { _graphMode = val; },
        get expandMode() { return _expandMode; },
        set expandMode(val) { _expandMode = val; },

        // VISUAL MAPPING - Metadata to Visual Properties
        applyVisualMapping,
        getColorForMapping,
        VISUAL_MAPPINGS,
        get activeMapping() { return _activeMapping; },
        set activeMapping(val) { _activeMapping = val; },

        // Boundaries
        clearBoundaries,
        clearAllModes,
        scheduleHullRedraw,

        // File Clustering Forces
        applyClusterForce,
        clearClusterForce,
        applyFileCohesion,
        clearFileCohesion,
        get clusterForceActive() { return _clusterForceActive; },
        get fileCohesionActive() { return _fileCohesionActive; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Internal state access (for migration)
        get boundaryMeshes() { return _boundaryMeshes; },
        set boundaryMeshes(val) { _boundaryMeshes = val; },

        // FILE CONTAINMENT SYSTEM - Moved from app.js
        toggleFileExpand,
        drawFileBoundaries,
        buildDirectoryTree,
        computeFileActivity,
        drawContainmentSpheres,
        startContainmentAnimation,
        stopContainmentAnimation,
        popBoundaries,
        restoreBoundaries,
        updateExpandButtons,
        handleCmdFiles,
        get containment() { return _containment; }
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'fileMode', {
    get: () => FILE_VIZ.enabled,
    set: (v) => FILE_VIZ.setEnabled(v),
    configurable: true
});
Object.defineProperty(window, 'fileVizMode', {
    get: () => FILE_VIZ.mode,
    set: (v) => FILE_VIZ.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'FILE_COLOR_CONFIG', {
    get: () => FILE_VIZ.config,
    configurable: true
});
Object.defineProperty(window, 'fileBoundaryMeshes', {
    get: () => FILE_VIZ.boundaryMeshes,
    set: (v) => { FILE_VIZ.boundaryMeshes = v; },
    configurable: true
});
// hullRedrawTimer, hullRedrawAttempts - app.js owns these, not duplicated here

function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride) {
    return FILE_VIZ.getColor(fileIdx, totalFiles, fileName, lightnessOverride);
}
function getFileHue(fileIdx, totalFiles, fileName) {
    return FILE_VIZ.getHue(fileIdx, totalFiles, fileName);
}
function setFileModeState(enabled) {
    FILE_VIZ.setEnabled(enabled);
}
function setFileVizMode(mode) {
    FILE_VIZ.setMode(mode);
}
function applyFileVizMode() {
    FILE_VIZ.apply();
}
function applyFileColors(graphNodes) {
    FILE_VIZ.applyColors(graphNodes);
}
function clearFileBoundaries() {
    FILE_VIZ.clearBoundaries();
}
function clearAllFileModes() {
    FILE_VIZ.clearAllModes();
}
function scheduleHullRedraw(delayMs) {
    FILE_VIZ.scheduleHullRedraw(delayMs);
}

// File graph backward compatibility - Using getters for live updates
Object.defineProperty(window, 'FILE_GRAPH', {
    get: () => FILE_VIZ.fileGraph,
    set: (val) => { /* Ignore - module manages state */ },
    configurable: true
});
Object.defineProperty(window, 'FILE_NODE_IDS', {
    get: () => FILE_VIZ.fileNodeIds,
    configurable: true
});
// FILE_NODE_POSITIONS is managed by app.js (not in this module's scope)
Object.defineProperty(window, 'EXPANDED_FILES', {
    get: () => FILE_VIZ.expandedFiles,
    configurable: true
});
Object.defineProperty(window, 'FILE_EXPAND_MODE', {
    get: () => FILE_VIZ.expandMode,
    set: (val) => { FILE_VIZ.expandMode = val; },
    configurable: true
});

function buildFileGraph(data) {
    // Calls module's buildFileGraph - FILE_GRAPH getter will return the result
    FILE_VIZ.buildFileGraph();
    FILE_NODE_IDS = FILE_VIZ.fileNodeIds;
    return FILE_VIZ.fileGraph;  // Return directly from module
}
function captureFileNodePositions() {
    FILE_VIZ.captureFileNodePositions();
}
function restoreNodePositions(nodes) {
    FILE_VIZ.restoreFileNodePositions(nodes);
}
function getFileTarget(fileIdx, totalFiles, radius, zSpread) {
    return FILE_VIZ.getFileTarget(fileIdx, totalFiles, radius, zSpread);
}

// File clustering force shims
function applyClusterForce(data) {
    FILE_VIZ.applyClusterForce(data);
}
function clearClusterForce() {
    FILE_VIZ.clearClusterForce();
}
function applyFileCohesion(data) {
    FILE_VIZ.applyFileCohesion(data);
}
function clearFileCohesion() {
    FILE_VIZ.clearFileCohesion();
}
Object.defineProperty(window, 'clusterForceActive', {
    get: () => FILE_VIZ.clusterForceActive,
    configurable: true
});
Object.defineProperty(window, 'fileCohesionActive', {
    get: () => FILE_VIZ.fileCohesionActive,
    configurable: true
});

// File containment system shims - moved from app.js
function toggleFileExpand(fileIdx) { FILE_VIZ.toggleFileExpand(fileIdx); }
function drawFileBoundaries(data) { return FILE_VIZ.drawFileBoundaries(data); }
function buildDirectoryTree(data) { return FILE_VIZ.buildDirectoryTree(data); }
function computeFileActivity(data, graphNodes) { return FILE_VIZ.computeFileActivity(data, graphNodes); }
function drawContainmentSpheres(data) { FILE_VIZ.drawContainmentSpheres(data); }
function startContainmentAnimation() { FILE_VIZ.startContainmentAnimation(); }
function stopContainmentAnimation() { FILE_VIZ.stopContainmentAnimation(); }
function popBoundaries(duration) { FILE_VIZ.popBoundaries(duration); }
function restoreBoundaries(duration) { FILE_VIZ.restoreBoundaries(duration); }
function updateExpandButtons() { FILE_VIZ.updateExpandButtons(); }
function handleCmdFiles() { FILE_VIZ.handleCmdFiles(); }

// Expose to global for button bindings and backward compatibility
window.popBoundaries = popBoundaries;
window.restoreBoundaries = restoreBoundaries;
window.toggleFileExpand = toggleFileExpand;
window.drawFileBoundaries = drawFileBoundaries;
window.buildDirectoryTree = buildDirectoryTree;
window.computeFileActivity = computeFileActivity;
window.drawContainmentSpheres = drawContainmentSpheres;
window.startContainmentAnimation = startContainmentAnimation;
window.stopContainmentAnimation = stopContainmentAnimation;
window.updateExpandButtons = updateExpandButtons;
window.handleCmdFiles = handleCmdFiles;

// FILE_CONTAINMENT state exposed via module
Object.defineProperty(window, 'FILE_CONTAINMENT', {
    get: () => FILE_VIZ.containment,
    configurable: true
});

console.log('[Module] FILE_VIZ loaded - file visualization, boundaries, containment');


// ═══ MODULE: modules/tooltips.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * TOOLTIPS MODULE - Tooltip and Toast Notifications
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles topology tooltips and toast notifications.
 * Depends on: TOOLTIP_STATE, HINTS_ENABLED, SMC_THEORY (globals)
 *
 * @module TOOLTIPS
 * @version 1.0.0
 * @confidence 99%
 */

window.TOOLTIPS = (function() {
    'use strict';

    // Module-local timeout reference
    let _toastTimeout = null;

    // ═══════════════════════════════════════════════════════════════════════
    // TOOLTIP OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize tooltip elements
     */
    function initTooltips() {
        const state = window.TOOLTIP_STATE;
        if (state) {
            state.element = document.getElementById('topo-tooltip');
        }
    }

    /**
     * Show topology tooltip with theory content
     * @param {string} category - Theory category (tiers, rings, families, etc.)
     * @param {string} key - Item key within category
     * @param {number} x - Screen X position
     * @param {number} y - Screen Y position
     */
    function showTopoTooltip(category, key, x, y) {
        const state = window.TOOLTIP_STATE;
        if (!state) return;

        if (!state.element) initTooltips();
        if (!state.element) return;

        const theory = window.SMC_THEORY;
        const content = theory?.[category]?.[key];
        if (!content) return;

        clearTimeout(state.hideTimeout);

        // Populate tooltip content
        const iconEl = document.getElementById('tooltip-icon');
        const titleEl = document.getElementById('tooltip-title');
        const subtitleEl = document.getElementById('tooltip-subtitle');
        const bodyEl = document.getElementById('tooltip-body');
        const theoryEl = document.getElementById('tooltip-theory');
        const examplesEl = document.getElementById('tooltip-examples');

        if (iconEl) iconEl.textContent = content.icon || '';
        if (titleEl) titleEl.textContent = content.title || key;
        if (subtitleEl) subtitleEl.textContent = content.subtitle || '';
        if (bodyEl) bodyEl.textContent = content.body || '';
        if (theoryEl) theoryEl.textContent = content.theory || '';
        if (examplesEl) {
            examplesEl.innerHTML = (content.examples || [])
                .map(ex => `<span class="topo-tooltip-example">${ex}</span>`)
                .join('');
        }

        // Position tooltip
        const tooltip = state.element;
        let left = x + 15, top = y + 15;
        if (left + 280 > window.innerWidth) left = x - 295;
        if (top + 200 > window.innerHeight) top = y - 215;
        if (left < 0) left = 15;
        if (top < 0) top = 15;

        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.classList.add('visible');

        state.visible = true;
        state.currentKey = `${category}:${key}`;
    }

    /**
     * Hide topology tooltip
     * @param {boolean} immediate - Hide immediately without delay
     */
    function hideTopoTooltip(immediate = false) {
        const state = window.TOOLTIP_STATE;
        if (!state || !state.element) return;

        if (immediate) {
            state.element.classList.remove('visible');
            state.visible = false;
        } else {
            state.hideTimeout = setTimeout(() => {
                state.element.classList.remove('visible');
                state.visible = false;
            }, 150);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Show a toast notification
     * @param {string} message - Message to display
     */
    function showToast(message) {
        const toast = document.getElementById('hud-toast');
        if (!toast) return;

        toast.textContent = message;
        toast.classList.add('visible');

        clearTimeout(toast._timer);
        toast._timer = setTimeout(() => {
            toast.classList.remove('visible');
        }, 2200);
    }

    /**
     * Show mode change toast (respects hints setting)
     * @param {string} message - Message to display
     */
    function showModeToast(message) {
        if (!window.HINTS_ENABLED) return;

        let toast = document.getElementById('mode-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'mode-toast';
            toast.className = 'mode-toast';
            document.body.appendChild(toast);
        }

        toast.textContent = message;
        toast.classList.add('visible');

        if (_toastTimeout) clearTimeout(_toastTimeout);
        _toastTimeout = setTimeout(() => {
            toast.classList.remove('visible');
        }, 1200);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        init: initTooltips,
        showTopo: showTopoTooltip,
        hideTopo: hideTopoTooltip,
        toast: showToast,
        modeToast: showModeToast
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.initTooltips = TOOLTIPS.init;
window.showTopoTooltip = TOOLTIPS.showTopo;
window.hideTopoTooltip = TOOLTIPS.hideTopo;
window.showToast = TOOLTIPS.toast;
window.showModeToast = TOOLTIPS.modeToast;

console.log('[Module] TOOLTIPS loaded - 5 functions');


// ═══ MODULE: modules/theme.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * THEME MODULE - Runtime Theme Management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles theme switching, persistence, and initialization.
 * Depends on: THEME_CONFIG (global), Graph (global), THREE (global)
 *
 * @module THEME
 * @version 1.0.0
 * @confidence 99%
 */

window.THEME = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // THEME OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Set the active theme by name.
     * Updates document data-theme attribute and stores preference.
     * @param {string} themeName - Theme name: 'dark', 'light', or 'high-contrast'
     */
    function setTheme(themeName) {
        const config = window.THEME_CONFIG;
        if (!config || !config.available.includes(themeName)) {
            console.warn(`[Theme] Unknown theme: ${themeName}. Available: ${config?.available?.join(', ') || 'none'}`);
            return;
        }

        // Update document attribute for CSS variable switching
        document.documentElement.setAttribute('data-theme', themeName);

        // Update global state
        config.current = themeName;

        // Store preference in localStorage
        try {
            localStorage.setItem('collider-theme', themeName);
        } catch (e) {
            console.warn('[Theme] Could not save preference:', e);
        }

        // Update canvas background if WebGL renderer is active
        const Graph = window.Graph;
        if (Graph && Graph.scene && Graph.scene()) {
            const scene = Graph.scene();
            if (scene.background) {
                const vizColors = window.VIZ_COLORS || {};
                const bgColor = getComputedStyle(document.documentElement)
                    .getPropertyValue('--color-viz-canvas-bg')?.trim() || vizColors.canvasBg || '#0a0a0f';
                scene.background = new THREE.Color(bgColor);
            }
        }

        // Update theme toggle buttons
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.theme === themeName);
        });

        const consoleColors = window.CONSOLE_COLORS || { success: '#4caf50' };
        console.log(`%c[Theme] Switched to: ${themeName}`, `color: ${consoleColors.success}; font-weight: bold`);

        // Show toast if available
        if (typeof window.showToast === 'function') {
            window.showToast(`Theme: ${themeName}`);
        }
    }

    /**
     * Get the current theme name.
     * @returns {string} Current theme name
     */
    function getTheme() {
        const config = window.THEME_CONFIG;
        return config ? config.current : 'dark';
    }

    /**
     * Get list of available themes.
     * @returns {string[]} Array of theme names
     */
    function getAvailableThemes() {
        const config = window.THEME_CONFIG;
        return config ? config.available : ['dark'];
    }

    /**
     * Cycle to the next theme in the list.
     */
    function cycleTheme() {
        const config = window.THEME_CONFIG;
        if (!config) return;

        const current = config.current;
        const themes = config.available;
        const currentIndex = themes.indexOf(current);
        const nextIndex = (currentIndex + 1) % themes.length;
        setTheme(themes[nextIndex]);
    }

    /**
     * Initialize theme from saved preference or default.
     */
    function initTheme() {
        const config = window.THEME_CONFIG;
        if (!config) {
            console.warn('[Theme] THEME_CONFIG not available');
            return;
        }

        // Check for saved preference
        let savedTheme = null;
        try {
            savedTheme = localStorage.getItem('collider-theme');
        } catch (e) {
            // Ignore storage errors
        }

        // Use saved preference if valid
        if (savedTheme && config.available.includes(savedTheme)) {
            setTheme(savedTheme);
            return;
        }

        // Fall back to default theme
        setTheme(config.default || 'dark');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        set: setTheme,
        get: getTheme,
        available: getAvailableThemes,
        cycle: cycleTheme,
        init: initTheme
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setTheme = THEME.set;
window.getTheme = THEME.get;
window.getAvailableThemes = THEME.available;
window.cycleTheme = THEME.cycle;
window.initTheme = THEME.init;

console.log('[Module] THEME loaded - 5 functions');


// ═══ MODULE: modules/control-bar.js ═══
/**
 * CONTROL BAR MODULE - Visual Mapping Command Center
 *
 * A persistent control bar (like ChatGPT/Claude input) that allows dynamic
 * mapping of any data characteristic to any visual/physics property.
 *
 * Features:
 * - Always visible at bottom of screen
 * - Works with selected nodes or node groups
 * - Dropdown to choose data source (any field)
 * - Dropdown to choose visual target (size, color, position, physics...)
 * - Group comparison with numbered badges
 * - Real-time preview as you adjust
 *
 * Depends on: DATA, COLOR, ANIM, SELECT
 */

const CONTROL_BAR = (function () {
    'use strict';

    // =========================================================================
    // AVAILABLE DATA SOURCES (what we can map FROM)
    // =========================================================================

    // =========================================================================
    // AVAILABLE DATA SOURCES (Delegated to UPB)
    // =========================================================================
    const DATA_SOURCES = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.SOURCES) || {
        // Fallback for safety if UPB fails to load
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Delegated to UPB)
    // =========================================================================
    const VISUAL_TARGETS = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.TARGETS) || {
        // Fallback
        nodeSize: { label: 'Node Size', category: 'appearance', range: [1, 30] }
    };

    // =========================================================================
    // SCALE FUNCTIONS (Delegated to UPB)
    // =========================================================================
    const SCALES = (window.UPB && window.UPB.SCALES && window.UPB.SCALES.SCALES) || {
        linear: (v, min, max) => (v - min) / (max - min || 1)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _visible = false;
    let _container = null;
    let _activeMapping = null;
    let _groups = [];         // [{id, name, nodeIds, color}]
    let _groupCounter = 0;

    // Current mapping configuration
    let _config = {
        source: 'token_estimate',
        target: 'nodeSize',
        scale: 'sqrt',
        scope: 'selection',   // 'selection' | 'all' | 'group:X'
        invert: false
    };

    // =========================================================================
    // UI BUILDING
    // =========================================================================

    let _isDocked = false;

    function createUI() {
        if (_container) return _container;

        const dockContainer = document.getElementById('control-bar-container');
        _isDocked = !!dockContainer;

        _container = document.createElement('div');
        _container.id = 'control-bar';
        _container.className = _isDocked ? 'control-bar docked' : 'control-bar';

        // Scope Section
        const scopeHTML = `
            <div class="control-section scope-section">
                <label>SCOPE</label>
                <div class="row-group">
                    <select id="cb-scope" class="cb-select">
                        <option value="selection">Selected Nodes</option>
                        <option value="all">All Nodes</option>
                        <optgroup label="Groups" id="cb-groups-optgroup"></optgroup>
                    </select>
                    <button id="cb-add-group" class="cb-btn cb-btn-small" title="Create group from selection">+G</button>
                    <span id="cb-node-count" class="cb-badge">0</span>
                </div>
            </div>
        `;

        // Map FROM
        const sourceHTML = `
            <div class="control-section">
                <label>MAP DATA SOURCE</label>
                <select id="cb-source" class="cb-select full-width">
                    <optgroup label="Structural">
                        <option value="token_estimate">Token Count</option>
                        <option value="line_count">Line Count</option>
                        <option value="size_bytes">File Size</option>
                        <option value="code_lines">Code Lines</option>
                        <option value="complexity_density">Complexity</option>
                        <option value="cohesion">Cohesion</option>
                    </optgroup>
                    <optgroup label="Temporal">
                        <option value="age_days">Age (days)</option>
                    </optgroup>
                    <optgroup label="Graph">
                        <option value="in_degree">In-Degree</option>
                        <option value="out_degree">Out-Degree</option>
                    </optgroup>
                    <optgroup label="Categorical">
                        <option value="tier">Tier</option>
                        <option value="ring">Ring</option>
                        <option value="layer">Layer</option>
                        <option value="role">Role</option>
                        <option value="format_category">Format</option>
                        <option value="effect">Effect</option>
                    </optgroup>
                    <optgroup label="Boolean">
                        <option value="is_test">Is Test?</option>
                        <option value="is_config">Is Config?</option>
                        <option value="is_stale">Is Stale?</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Arrow (only for float mode, skip or style differently in dock)
        const arrowHTML = _isDocked ? '' : `
            <div class="control-section arrow-section">
                <span class="arrow">&#8594;</span>
            </div>
        `;

        // Map TO
        const targetHTML = `
            <div class="control-section">
                <label>TO VISUAL PROPERTY</label>
                <select id="cb-target" class="cb-select full-width">
                    <optgroup label="Appearance">
                        <option value="nodeSize">Node Size</option>
                        <option value="hue">Color Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="lightness">Lightness</option>
                        <option value="opacity">Opacity</option>
                    </optgroup>
                    <optgroup label="Position">
                        <option value="xPosition">X Position</option>
                        <option value="yPosition">Y Position</option>
                        <option value="zPosition">Z Depth</option>
                        <option value="radius">Radial Distance</option>
                    </optgroup>
                    <optgroup label="Physics">
                        <option value="charge">Charge (repel)</option>
                        <option value="mass">Mass</option>
                    </optgroup>
                    <optgroup label="Animation">
                        <option value="pulseSpeed">Pulse Speed</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Scale
        const scaleHTML = `
            <div class="control-section">
                <label>SCALING</label>
                <select id="cb-scale" class="cb-select full-width">
                    <option value="linear">Linear</option>
                    <option value="sqrt" selected>Sqrt</option>
                    <option value="log">Log</option>
                    <option value="inverse">Inverse</option>
                </select>
            </div>
        `;

        // Actions
        const actionsHTML = `
            <div class="control-section actions-section">
                <button id="cb-apply" class="cb-btn cb-btn-primary full-width">APPLY MAPPING</button>
                <button id="cb-reset" class="cb-btn full-width" style="margin-top:4px">Reset</button>
            </div>
        `;

        // Groups Display
        const groupsHTML = `
            <div class="control-section groups-section" id="cb-groups-display"></div>
        `;

        // Toggle (only for float mode)
        const toggleHTML = _isDocked ? '' : `
            <button id="cb-toggle" class="cb-toggle" title="Toggle Control Bar">
                <span class="chevron">&#9660;</span>
            </button>
        `;

        _container.innerHTML = `
            <div class="control-bar-inner">
                ${scopeHTML}
                ${sourceHTML}
                ${arrowHTML}
                ${targetHTML}
                ${scaleHTML}
                ${actionsHTML}
                ${groupsHTML}
                ${toggleHTML}
            </div>
        `;

        // Add styles
        addStyles();

        // Attach event listeners
        attachListeners();

        if (_isDocked) {
            dockContainer.appendChild(_container);
        } else {
            document.body.appendChild(_container);
        }

        _visible = true;

        return _container;
    }

    function addStyles() {
        if (document.getElementById('control-bar-styles')) return;

        const style = document.createElement('style');
        style.id = 'control-bar-styles';
        style.textContent = `
            /* BASE STYLES */
            .control-bar {
                font-family: 'SF Mono', 'Consolas', monospace;
            }

            /* FLOATING MODE */
            .control-bar:not(.docked) {
                position: fixed;
                bottom: 16px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 900px;
                width: calc(100% - 48px);
                z-index: 9999;
                background: linear-gradient(180deg, rgba(28, 30, 35, 0.95) 0%, rgba(22, 24, 28, 0.98) 100%);
                backdrop-filter: blur(12px);
                border: 1px solid rgba(100, 105, 115, 0.15);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.35);
                transition: transform 0.3s ease, opacity 0.3s ease;
            }

            .control-bar:not(.docked) .control-bar-inner {
                display: flex;
                align-items: center;
                gap: 16px;
                padding: 12px 20px;
                overflow-x: auto;
            }

            /* DOCKED MODE */
            .control-bar.docked {
                position: static;
                width: 100%;
                background: transparent;
                border: none;
                box-shadow: none;
                padding: 0;
            }

            .control-bar.docked .control-bar-inner {
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 0;
            }

            /* SHARED COMPONENTS */
            .control-section {
                display: flex;
                flex-direction: column;
                gap: 4px;
                width: 100%; /* Full width when docked */
            }

            .control-section label {
                font-size: 9px;
                font-weight: 600;
                color: rgba(140, 145, 155, 0.6);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .row-group {
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .cb-select {
                background: rgba(35, 38, 45, 0.85);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #c8ccd5;
                padding: 6px 10px;
                font-size: 11px;
                font-family: inherit;
                cursor: pointer;
                transition: all 0.2s;
                flex: 1;
            }

            .cb-select:hover {
                background: rgba(45, 48, 55, 0.9);
                border-color: rgba(120, 125, 135, 0.35);
            }
            
            .cb-select:focus {
                outline: none;
                border-color: var(--accent, #4a9eff);
            }

            .full-width {
                width: 100%;
            }

            .cb-btn {
                background: rgba(50, 55, 65, 0.6);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #b0b5c0;
                padding: 6px 12px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
            }
            .actions-section {
                width: 100%;
            }
            .cb-btn:hover {
                background: rgba(65, 70, 80, 0.75);
                color: #fff;
            }

            .cb-btn-primary {
                background: var(--accent-dim, rgba(74, 158, 255, 0.15));
                color: var(--accent, #4a9eff);
                border-color: var(--accent, #4a9eff);
            }

            .cb-btn-primary:hover {
                background: var(--accent, #4a9eff);
                color: #000;
            }

            .cb-btn-small {
                padding: 4px 8px;
                min-width: 30px;
            }

            .cb-badge {
                font-size: 10px;
                color: #666;
                min-width: 15px;
                text-align: center;
            }

            /* GROUP CHIPS */
            .groups-section {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 4px;
            }

            .group-chip {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
                padding: 2px 8px;
                font-size: 10px;
                cursor: default;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .group-color {
                width: 6px;
                height: 6px;
                border-radius: 50%;
            }

            .group-remove {
                margin-left: 4px;
                cursor: pointer;
                opacity: 0.5;
            }
            .group-remove:hover { opacity: 1; }
        `;

        document.head.appendChild(style);
    }

    function attachListeners() {
        // Toggle collapse
        const toggleBtn = document.getElementById('cb-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', toggle);
        }

        // Scope change
        const scopeSelect = document.getElementById('cb-scope');
        if (scopeSelect) {
            scopeSelect.addEventListener('change', (e) => {
                _config.scope = e.target.value;
                updateNodeCount();
            });
        }

        // Source change
        const sourceSelect = document.getElementById('cb-source');
        if (sourceSelect) {
            sourceSelect.addEventListener('change', (e) => {
                _config.source = e.target.value;
            });
        }

        // Target change
        const targetSelect = document.getElementById('cb-target');
        if (targetSelect) {
            targetSelect.addEventListener('change', (e) => {
                _config.target = e.target.value;
            });
        }

        // Scale change
        const scaleSelect = document.getElementById('cb-scale');
        if (scaleSelect) {
            scaleSelect.addEventListener('change', (e) => {
                _config.scale = e.target.value;
            });
        }

        // Apply button
        const applyBtn = document.getElementById('cb-apply');
        if (applyBtn) {
            applyBtn.addEventListener('click', applyMapping);
        }

        // Reset button
        const resetBtn = document.getElementById('cb-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', resetMapping);
        }

        // Add group button
        const addGroupBtn = document.getElementById('cb-add-group');
        if (addGroupBtn) {
            addGroupBtn.addEventListener('click', createGroupFromSelection);
        }

        // Update node count periodically
        setInterval(updateNodeCount, 1000);
    }

    // =========================================================================
    // GROUP MANAGEMENT
    // =========================================================================

    const GROUP_COLORS = [
        '#4a9eff', '#ff6b6b', '#51cf66', '#ffd43b',
        '#cc5de8', '#20c997', '#ff922b', '#748ffc'
    ];

    function createGroupFromSelection() {
        const selectedIds = getSelectedNodeIds();
        if (selectedIds.length === 0) {
            showToast('Select nodes first to create a group');
            return;
        }

        _groupCounter++;
        const groupId = `group-${_groupCounter}`;
        const color = GROUP_COLORS[(_groupCounter - 1) % GROUP_COLORS.length];

        const group = {
            id: groupId,
            name: `Group ${_groupCounter}`,
            nodeIds: [...selectedIds],
            color: color
        };

        _groups.push(group);
        updateGroupsUI();
        showToast(`Created ${group.name} with ${selectedIds.length} nodes`);
    }

    function removeGroup(groupId) {
        _groups = _groups.filter(g => g.id !== groupId);
        updateGroupsUI();
    }

    function updateGroupsUI() {
        // Update dropdown
        const optgroup = document.getElementById('cb-groups-optgroup');
        if (optgroup) {
            optgroup.innerHTML = _groups.map(g =>
                `<option value="group:${g.id}">${g.name} (${g.nodeIds.length})</option>`
            ).join('');
        }

        // Update chips display
        const display = document.getElementById('cb-groups-display');
        if (display) {
            display.innerHTML = _groups.map(g => `
                <div class="group-chip" data-group="${g.id}">
                    <span class="group-color" style="background: ${g.color}"></span>
                    <span class="group-name">${g.name}</span>
                    <span class="group-count">${g.nodeIds.length}</span>
                    <span class="group-remove" onclick="CONTROL_BAR.removeGroup('${g.id}')">&times;</span>
                </div>
            `).join('');
        }
    }

    // =========================================================================
    // MAPPING APPLICATION
    // =========================================================================

    function getTargetNodes() {
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        const allNodes = dm?.getNodes ? dm.getNodes() : (typeof graphNodes !== 'undefined' ? graphNodes : []);

        if (_config.scope === 'all') {
            return allNodes;
        }

        if (_config.scope === 'selection') {
            const selectedIds = getSelectedNodeIds();
            return allNodes.filter(n => selectedIds.includes(n.id));
        }

        if (_config.scope.startsWith('group:')) {
            const groupId = _config.scope.replace('group:', '');
            const group = _groups.find(g => g.id === groupId);
            if (group) {
                return allNodes.filter(n => group.nodeIds.includes(n.id));
            }
        }

        return [];
    }

    function applyMapping() {
        if (!window.UPB) {
            console.error('UPB not loaded');
            return;
        }

        const nodes = getTargetNodes();
        if (nodes.length === 0) {
            showToast('No nodes to map. Select nodes or change scope.');
            return;
        }

        const sourceKey = _config.source;
        const targetKey = _config.target;

        // 1. Create/Update Binding in UPB Graph
        window.UPB.bind(sourceKey, targetKey, {
            id: `cb-binding-${Date.now()}`,
            scale: _config.scale,
            range: VISUAL_TARGETS[targetKey]?.range
        });

        // 2. Refresh Data Ranges (if needed, usually DM handles this)
        // For now, we rely on the UPB Binding to calculate ranges per node or usage
        // But UPB.evaluate needs data ranges (min/max) for normalization.
        // We calculate them here ad-hoc for the current selection and push to UPB.
        const values = nodes.map(n => getNodeValue(n, sourceKey)).filter(v => typeof v === 'number');
        if (values.length > 0) {
            const min = Math.min(...values);
            const max = Math.max(...values);

            // Access the underlying graph to set range
            // TODO: Move this to a central DataManager
            if (window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = { min, max };
            }
        }

        // 3. Apply to Nodes
        const updates = window.UPB.apply(nodes);

        // 4. Render Updates
        updates.forEach(update => {
            const node = nodes.find(n => n.id === update.id);
            if (node) {
                Object.keys(update.visuals).forEach(key => {
                    applyToNode(node, key, update.visuals[key]);
                });
            }
        });

        // Refresh graph
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }

        showToast(`Bound ${sourceKey} -> ${targetKey} via UPB`);
        console.log(`[CONTROL_BAR] UPB Binding Active: ${sourceKey} -> ${targetKey}`);
    }

    function getNodeValue(node, key) {
        // Direct property
        if (node[key] !== undefined) return node[key];

        // Nested in dimensions
        if (node.dimensions && node.dimensions[key] !== undefined) {
            return node.dimensions[key];
        }

        // Check common dimension mappings
        const dimMap = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };

        if (dimMap[key] && node.dimensions) {
            return node.dimensions[dimMap[key]];
        }

        return null;
    }

    function applyToNode(node, targetKey, value) {
        switch (targetKey) {
            case 'nodeSize':
                node.val = value;
                break;

            case 'hue':
                const currentColor = node.color || 'hsl(200, 70%, 50%)';
                node.color = setHSLComponent(currentColor, 'h', value);
                break;

            case 'saturation':
                node.color = setHSLComponent(node.color || 'hsl(200, 70%, 50%)', 's', value);
                break;

            case 'lightness':
                node.color = setHSLComponent(node.color || 'hsl(200, 70%, 50%)', 'l', value);
                break;

            case 'opacity':
                node.opacity = value;
                // Update color alpha if using rgba
                if (node.color && !node.color.startsWith('hsl')) {
                    node.color = setAlpha(node.color, value);
                }
                break;

            case 'xPosition':
                node.fx = value;
                break;

            case 'yPosition':
                node.fy = value;
                break;

            case 'zPosition':
                node.fz = value;
                break;

            case 'radius':
                // Position on a circle at given radius
                const angle = (node.fileIdx || Math.random() * 100) * 0.618 * Math.PI * 2;
                node.fx = Math.cos(angle) * value;
                node.fy = Math.sin(angle) * value;
                break;

            case 'charge':
                node.__charge = value;
                break;

            case 'mass':
                node.__mass = value;
                break;

            case 'pulseSpeed':
                node.__pulseSpeed = value;
                break;

            default:
                node[targetKey] = value;
        }
    }

    function setHSLComponent(colorStr, component, value) {
        // Parse existing HSL or convert
        let h = 200, s = 70, l = 50;

        const hslMatch = colorStr.match(/hsl\((\d+),\s*(\d+)%?,\s*(\d+)%?\)/);
        if (hslMatch) {
            h = parseInt(hslMatch[1]);
            s = parseInt(hslMatch[2]);
            l = parseInt(hslMatch[3]);
        }

        switch (component) {
            case 'h': h = value; break;
            case 's': s = value; break;
            case 'l': l = value; break;
        }

        return `hsl(${Math.round(h)}, ${Math.round(s)}%, ${Math.round(l)}%)`;
    }

    function setAlpha(colorStr, alpha) {
        // Simple alpha injection
        if (colorStr.startsWith('rgba')) {
            return colorStr.replace(/[\d.]+\)$/, `${alpha})`);
        }
        if (colorStr.startsWith('rgb')) {
            return colorStr.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        }
        return colorStr;
    }

    function resetMapping() {
        // Clear fixed positions
        const nodes = getTargetNodes();
        nodes.forEach(n => {
            delete n.fx;
            delete n.fy;
            delete n.fz;
            delete n.__charge;
            delete n.__mass;
            delete n.__pulseSpeed;
        });

        // Reheat simulation
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3ReheatSimulation();
        }

        showToast('Reset node positions and custom properties');
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function getSelectedNodeIds() {
        if (typeof SELECT !== 'undefined' && SELECT.getSelectedNodes) {
            return SELECT.getSelectedNodes().map(n => n.id);
        }
        if (typeof SELECTED_NODE_IDS !== 'undefined') {
            return Array.from(SELECTED_NODE_IDS);
        }
        return [];
    }

    function updateNodeCount() {
        const badge = document.getElementById('cb-node-count');
        if (!badge) return;

        const nodes = getTargetNodes();
        badge.textContent = nodes.length;
    }

    function showToast(msg) {
        if (typeof window.showToast === 'function') {
            window.showToast(msg);
        } else {
            console.log(`[CONTROL_BAR] ${msg}`);
        }
    }

    function toggle() {
        if (_container) {
            _container.classList.toggle('collapsed');
            _visible = !_container.classList.contains('collapsed');
        }
    }

    function show() {
        if (_container) {
            _container.classList.remove('collapsed');
            _visible = true;
        }
    }

    function hide() {
        if (_container) {
            _container.classList.add('collapsed');
            _visible = false;
        }
    }

    // =========================================================================
    // INIT
    // =========================================================================

    function init() {
        createUI();
        updateNodeCount();
        console.log('[CONTROL_BAR] Initialized');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        toggle,
        show,
        hide,
        applyMapping,
        resetMapping,
        createGroupFromSelection,
        removeGroup,
        get visible() { return _visible; },
        get config() { return _config; },
        get groups() { return _groups; },
        DATA_SOURCES,
        VISUAL_TARGETS,
        SCALES
    };

})();

// Auto-init when DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => CONTROL_BAR.init());
} else {
    // Small delay to ensure other modules are loaded
    setTimeout(() => CONTROL_BAR.init(), 100);
}


// ═══ MODULE: modules/main.js ═══
/**
 * MAIN.JS - MODULE INTEGRATION ENTRY POINT
 *
 * This file wires up all modules and provides backward compatibility
 * for HTML onclick handlers and global function calls.
 *
 * Module Loading Order (already handled by visualize_graph_webgl.py):
 * 1. performance.js       - Performance subsystem
 * 2. core.js              - Constants & utilities
 * 3. node-accessors.js    - Node property functions
 * 4. color-engine.js      - OKLCH color system
 * 5. refresh-throttle.js  - Throttled graph updates
 * 6. legend-manager.js    - Legend system
 * 7. data-manager.js      - Data access layer
 * 8. animation.js         - Layout & animation controller
 * 9. selection.js         - Selection system
 * 10. panels.js           - Panel management
 * 11. sidebar.js          - Sidebar controls
 * 12. edge-system.js      - Edge coloring & modes
 * 13. file-viz.js         - File visualization modes
 * 14. control-bar.js      - Visual mapping command bar
 * 15. main.js             - This file (wiring)
 * 16. app.js              - Legacy monolith (shrinking)
 */

;(function() {
    'use strict';

    // =========================================================================
    // VERIFY MODULE LOADING
    // =========================================================================

    const REQUIRED_MODULES = [
        { name: 'CORE', module: typeof CORE !== 'undefined' ? CORE : null },
        { name: 'NODE', module: typeof NODE !== 'undefined' ? NODE : null },
        { name: 'COLOR', module: typeof COLOR !== 'undefined' ? COLOR : null },
        { name: 'REFRESH', module: typeof REFRESH !== 'undefined' ? REFRESH : null },
        { name: 'LEGEND', module: typeof LEGEND !== 'undefined' ? LEGEND : null },
        { name: 'DATA', module: typeof DATA !== 'undefined' ? DATA : null },
        { name: 'LAYOUT', module: typeof LAYOUT !== 'undefined' ? LAYOUT : null },  // UI Layout Engine
        { name: 'ANIM', module: typeof ANIM !== 'undefined' ? ANIM : null },
        { name: 'SELECT', module: typeof SELECT !== 'undefined' ? SELECT : null },
        { name: 'PANELS', module: typeof PANELS !== 'undefined' ? PANELS : null },
        { name: 'SIDEBAR', module: typeof SIDEBAR !== 'undefined' ? SIDEBAR : null },
        { name: 'EDGE', module: typeof EDGE !== 'undefined' ? EDGE : null },
        { name: 'FILE_VIZ', module: typeof FILE_VIZ !== 'undefined' ? FILE_VIZ : null },
        { name: 'CONTROL_BAR', module: typeof CONTROL_BAR !== 'undefined' ? CONTROL_BAR : null },
        // STARS module removed - nodes ARE the stars
        { name: 'HUD', module: typeof HUD !== 'undefined' ? HUD : null },
        { name: 'DIMENSION', module: typeof DIMENSION !== 'undefined' ? DIMENSION : null }
    ];

    const loaded = REQUIRED_MODULES.filter(m => m.module !== null);
    const missing = REQUIRED_MODULES.filter(m => m.module === null);

    console.log(`[MAIN] Modules loaded: ${loaded.length}/${REQUIRED_MODULES.length}`);
    if (missing.length > 0) {
        console.warn('[MAIN] Missing modules:', missing.map(m => m.name).join(', '));
    }

    // =========================================================================
    // WINDOW-LEVEL EXPORTS FOR HTML ONCLICK HANDLERS
    // =========================================================================

    // Selection functions
    if (typeof SELECT !== 'undefined') {
        window.clearSelection = SELECT.clear;
        window.setSelection = SELECT.set;
        window.toggleSelection = SELECT.toggle;
        window.getSelectedNodes = SELECT.getSelectedNodes;
    }

    // Animation functions
    if (typeof ANIM !== 'undefined') {
        window.applyLayoutPreset = ANIM.applyLayout;
        window.stopAnimation = ANIM.stop;
    }

    // Edge functions
    if (typeof EDGE !== 'undefined') {
        window.setEdgeMode = EDGE.setMode;
        window.cycleEdgeMode = EDGE.cycleMode;
        window.applyEdgeMode = EDGE.apply;
    }

    // File visualization functions
    if (typeof FILE_VIZ !== 'undefined') {
        window.setFileVizMode = FILE_VIZ.setMode;
        window.toggleFileMode = FILE_VIZ.toggle;
    }

    // Panel functions
    if (typeof PANELS !== 'undefined') {
        window.openPanel = PANELS.open;
        window.closePanel = PANELS.close;
        window.togglePanel = PANELS.toggle;
    }

    // Sidebar functions
    if (typeof SIDEBAR !== 'undefined') {
        window.setColorMode = SIDEBAR.setColorMode;
        window.setLayout = SIDEBAR.setLayout;
    }

    // Refresh function
    if (typeof REFRESH !== 'undefined') {
        window.throttledRefresh = REFRESH.throttled;
    }

    // Control bar functions
    if (typeof CONTROL_BAR !== 'undefined') {
        window.toggleControlBar = CONTROL_BAR.toggle;
        window.showControlBar = CONTROL_BAR.show;
        window.hideControlBar = CONTROL_BAR.hide;
        window.applyVisualMapping = CONTROL_BAR.applyMapping;
    }

    // =========================================================================
    // CROSS-MODULE INTEGRATION
    // =========================================================================

    /**
     * Initialize all modules with data
     * NOTE: Currently unused - app.js calls module inits directly in setupControls()
     * Kept for potential future centralization
     * @deprecated Use direct module init calls instead
     */
    window.initializeModules = function(data) {
        console.log('[MAIN] Initializing modules with data...');

        // Initialize DATA module
        if (typeof DATA !== 'undefined' && DATA.init) {
            DATA.init(data);
            console.log('[MAIN] DATA module initialized');
        }

        // Initialize LEGEND module
        if (typeof LEGEND !== 'undefined' && LEGEND.init) {
            LEGEND.init(data.nodes, data.links || data.edges);
            console.log('[MAIN] LEGEND module initialized');
        }

        // Initialize SIDEBAR
        if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
            SIDEBAR.init();
            console.log('[MAIN] SIDEBAR module initialized');
        }

        // Initialize PANELS command bar
        if (typeof PANELS !== 'undefined' && PANELS.initCommandBar) {
            PANELS.initCommandBar();
            console.log('[MAIN] PANELS module initialized');
        }

        // Initialize LAYOUT (replaces HudLayoutManager from app.js)
        if (typeof LAYOUT !== 'undefined' && LAYOUT.init) {
            LAYOUT.init();
            console.log('[MAIN] LAYOUT module initialized (Ctrl+Shift+L for debug overlay)');
        }

        // STARS module removed - nodes ARE the stars

        // Initialize HUD (fade behavior)
        if (typeof HUD !== 'undefined' && HUD.setupFade) {
            HUD.setupFade();
            console.log('[MAIN] HUD module initialized');
        }

        // Initialize DIMENSION toggle
        if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) {
            DIMENSION.setup();
            console.log('[MAIN] DIMENSION module initialized');
        }

        console.log('[MAIN] Module initialization complete');
    };

    /**
     * Global refresh function that uses the throttled refresher
     */
    window.moduleRefresh = function() {
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }
    };

    // =========================================================================
    // MODULE HEALTH CHECK
    // =========================================================================

    window.checkModuleHealth = function() {
        console.log('=== MODULE HEALTH CHECK ===');
        REQUIRED_MODULES.forEach(({ name, module }) => {
            const status = module ? 'OK' : 'MISSING';
            const color = module ? 'color: green' : 'color: red';
            console.log(`%c[${status}] ${name}`, color);
        });

        if (typeof REFRESH !== 'undefined') {
            console.log('REFRESH stats:', REFRESH.stats);
        }

        console.log('===========================');
    };

    // =========================================================================
    // INITIALIZATION MESSAGE
    // =========================================================================

    console.log('[MAIN] Entry point loaded. Modules ready for initialization.');

})();


// ═══ MODULE: modules/circuit-breaker.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * CIRCUIT BREAKER MODULE - UI Control Validator
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Runtime self-test system that validates all visualization UI controls.
 * Acts as a quality guardian - detects binding failures, state issues,
 * and provides actionable fix recommendations.
 *
 * @module CIRCUIT
 * @version 2.0.0
 *
 * ## API
 *
 * | Method | Returns | Description |
 * |--------|---------|-------------|
 * | `runAll()` | `{passed, failed, total, results}` | Run all tests |
 * | `test(name)` | `{passed, error, trace}` | Test single control |
 * | `report()` | `Map<name, result>` | Get all results |
 * | `listTests()` | `string[]` | List test names |
 * | `diagnose()` | `{category, failures}[]` | Get categorized fix recommendations |
 * | `inventory()` | `string` | Markdown table of all controls |
 * | `inventoryJSON()` | `object[]` | JSON array of control definitions |
 *
 * ## CLI Integration
 *
 * ```bash
 * python tools/validate_ui.py <html_path> --verbose
 * ```
 *
 * ## Browser Console
 *
 * ```javascript
 * CIRCUIT.runAll()        // Run all tests
 * CIRCUIT.inventory()     // Print control table
 * CIRCUIT.diagnose()      // Get fix recommendations
 * ```
 *
 * @see tools/validate_ui.py - Headless test runner
 * @see CLAUDE.md - UI Controls section
 */

const CIRCUIT = (function() {
    'use strict';

    // Test results storage
    const _results = new Map();
    let _running = false;

    // =========================================================================
    // DIAGNOSTIC HELPERS
    // =========================================================================

    function getStateValue(path) {
        try {
            const parts = path.split('.');
            let obj = window;
            for (const part of parts) {
                if (obj === undefined || obj === null) return { exists: false, value: undefined };
                obj = obj[part];
            }
            return { exists: true, value: obj };
        } catch (e) {
            return { exists: false, value: undefined, error: e.message };
        }
    }

    function traceBinding(elementId, statePath, graphMethod) {
        const trace = {
            element: { id: elementId, found: false, hasListeners: false },
            state: { path: statePath, exists: false, value: undefined },
            graph: { method: graphMethod, callable: false },
            chain: []
        };

        // Check element
        const el = document.getElementById(elementId);
        if (el) {
            trace.element.found = true;
            trace.element.tagName = el.tagName;
            trace.element.type = el.type || el.tagName;
            trace.element.value = el.value;
            trace.chain.push(`✓ DOM element #${elementId} exists`);
        } else {
            trace.chain.push(`✗ DOM element #${elementId} NOT FOUND`);
            return trace;
        }

        // Check state
        if (statePath) {
            const stateResult = getStateValue(statePath);
            trace.state.exists = stateResult.exists;
            trace.state.value = stateResult.value;
            if (stateResult.exists) {
                trace.chain.push(`✓ State ${statePath} = ${JSON.stringify(stateResult.value)}`);
            } else {
                trace.chain.push(`✗ State ${statePath} is undefined`);
            }
        }

        // Check Graph method
        if (graphMethod && typeof Graph !== 'undefined' && Graph) {
            const method = Graph[graphMethod];
            trace.graph.callable = typeof method === 'function';
            if (trace.graph.callable) {
                trace.chain.push(`✓ Graph.${graphMethod}() is callable`);
            } else {
                trace.chain.push(`✗ Graph.${graphMethod}() NOT a function`);
            }
        }

        return trace;
    }

    // =========================================================================
    // TEST DEFINITIONS - Enhanced with diagnostics
    // =========================================================================

    const TESTS = [
        // --- EDGE CONTROLS ---
        {
            name: 'edge-opacity',
            type: 'slider',
            elementId: 'cfg-edge-opacity',
            statePath: 'APPEARANCE_STATE.edgeOpacity',
            graphMethod: 'linkOpacity',
            expected: 0.8,
            trigger: (el) => {
                el.value = '0.8';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeOpacity');
                return {
                    passed: state.exists && state.value === 0.8,
                    expected: 0.8,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0.6';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Ensure bindSlider() in app.js updates APPEARANCE_STATE.edgeOpacity and calls applyEdgeMode()'
        },
        {
            name: 'edge-width',
            type: 'slider',
            elementId: 'cfg-edge-width',
            statePath: 'APPEARANCE_STATE.edgeWidth',
            graphMethod: 'linkWidth',
            expected: 'changed',
            trigger: (el) => {
                // Store initial value, then change it
                window._edgeWidthBefore = getStateValue('APPEARANCE_STATE.edgeWidth').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeWidth');
                const changed = state.exists && state.value !== window._edgeWidthBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeWidthBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeWidthBefore;
            },
            fix: 'Check if cfg-edge-width has oninput handler that updates APPEARANCE_STATE.edgeWidth'
        },
        {
            name: 'edge-curvature',
            type: 'slider',
            elementId: 'cfg-edge-curve',
            statePath: 'APPEARANCE_STATE.edgeCurvature',
            graphMethod: 'linkCurvature',
            expected: 'changed',
            trigger: (el) => {
                window._edgeCurveBefore = getStateValue('APPEARANCE_STATE.edgeCurvature').value;
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeCurvature');
                const changed = state.exists && state.value !== window._edgeCurveBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeCurveBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeCurveBefore;
            },
            fix: 'Check if cfg-edge-curve has oninput handler that updates APPEARANCE_STATE.edgeCurvature'
        },

        // --- NODE CONTROLS ---
        {
            name: 'node-size',
            type: 'slider',
            elementId: 'cfg-node-size',
            statePath: 'APPEARANCE_STATE.nodeScale',
            graphMethod: 'nodeRelSize',
            expected: 'changed',
            trigger: (el) => {
                // Slider has max=4, so use valid value
                window._nodeSizeBefore = getStateValue('APPEARANCE_STATE.nodeScale').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeScale');
                const changed = state.exists && state.value !== window._nodeSizeBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._nodeSizeBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._nodeSizeBefore;
            },
            fix: 'Check if cfg-node-size has oninput handler that updates APPEARANCE_STATE.nodeScale'
        },
        {
            name: 'node-opacity',
            type: 'slider',
            elementId: 'cfg-node-opacity',
            statePath: 'APPEARANCE_STATE.nodeOpacity',
            graphMethod: 'nodeOpacity',
            expected: 0.5,
            trigger: (el) => {
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeOpacity');
                return {
                    passed: state.exists && state.value === 0.5,
                    expected: 0.5,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Check if cfg-node-opacity has oninput handler that updates APPEARANCE_STATE.nodeOpacity'
        },

        // --- TOGGLES ---
        {
            name: 'toggle-arrows',
            type: 'toggle',
            elementId: 'cfg-toggle-arrows',
            statePath: null,
            graphMethod: 'linkDirectionalArrowLength',
            expected: 'toggled',
            trigger: (el) => {
                window._arrowsActiveBefore = el.classList.contains('active');
                el.click();
            },
            validate: () => {
                const el = document.getElementById('cfg-toggle-arrows');
                if (!el) return { passed: false, error: 'Element not found' };
                const isActiveNow = el.classList.contains('active');
                return {
                    passed: isActiveNow !== window._arrowsActiveBefore,
                    expected: !window._arrowsActiveBefore,
                    actual: isActiveNow,
                    stateExists: true
                };
            },
            cleanup: (el) => {
                el.click();
                delete window._arrowsActiveBefore;
            },
            fix: 'Ensure toggle click handler toggles .active class and calls Graph.linkDirectionalArrowLength()'
        },

        // --- PHYSICS CONTROLS ---
        {
            name: 'physics-charge',
            type: 'slider',
            elementId: 'physics-charge',
            statePath: null,  // Bypasses PHYSICS_STATE, goes direct to Graph
            graphMethod: 'd3Force',
            expected: -200,
            trigger: (el) => {
                window._originalChargeValue = el.value;
                el.value = '-200';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                // Use window.Graph explicitly (Graph is exposed at app.js:1111)
                const G = window.Graph;
                if (!G) {
                    return { passed: false, error: 'Graph not defined', stateExists: false };
                }
                if (!G.d3Force) {
                    return { passed: false, error: 'Graph.d3Force not available', stateExists: false };
                }
                try {
                    const chargeForce = G.d3Force('charge');
                    if (!chargeForce || !chargeForce.strength) {
                        return { passed: false, error: 'charge force not configured', stateExists: false };
                    }
                    // d3-force strength() returns accessor function, not value
                    // Call it with dummy node to get actual strength
                    const strengthFn = chargeForce.strength();
                    const strength = typeof strengthFn === 'function' ? strengthFn({}, 0, []) : strengthFn;
                    return {
                        passed: strength === -200,
                        expected: -200,
                        actual: strength,
                        stateExists: true
                    };
                } catch (e) {
                    return { passed: false, error: e.message, stateExists: false };
                }
            },
            cleanup: (el) => {
                if (window._originalChargeValue) {
                    el.value = window._originalChargeValue;
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    delete window._originalChargeValue;
                }
            },
            fix: 'Ensure physics-charge slider calls Graph.d3Force("charge").strength(value) - check sidebar.js binding'
        },

        // NOTE: btn-edge-mode test removed - button never existed in template.html
        // The EDGE module handles missing button gracefully (line 443-446 of edge-system.js)

        // --- DIMENSION TOGGLE ---
        {
            name: 'dimension-toggle',
            type: 'button',
            elementId: 'btn-2d',
            statePath: 'DIMENSION_TRANSITION',
            graphMethod: null,
            expected: 'transition started',
            trigger: (el) => {
                // Animation takes 3s, so we check DIMENSION_TRANSITION flag (set immediately)
                window._transitionBefore = window.DIMENSION_TRANSITION;
                el.click();
            },
            validate: () => {
                // DIMENSION_TRANSITION is set true immediately on click, then false after 3s animation
                // We check that clicking triggered the transition (flag went true or animation completed)
                const transitionStarted = window.DIMENSION_TRANSITION === true ||
                                         window.DIMENSION_TRANSITION !== window._transitionBefore;
                return {
                    passed: transitionStarted || window.DIMENSION_TRANSITION === true,
                    expected: 'DIMENSION_TRANSITION = true (animation in progress)',
                    actual: window.DIMENSION_TRANSITION,
                    stateExists: typeof window.DIMENSION_TRANSITION !== 'undefined'
                };
            },
            cleanup: () => {
                // Don't click again - let animation complete naturally
                delete window._transitionBefore;
            },
            fix: 'Check if btn-2d click handler sets DIMENSION_TRANSITION and calls DIMENSION.toggle() - see dimension.js'
        },

        // --- VIEW MODE ---
        {
            name: 'view-mode-files',
            type: 'button',
            elementId: null,
            selector: '[data-mode="files"]',
            statePath: 'GRAPH_MODE',
            graphMethod: null,
            expected: 'files',
            trigger: (el) => {
                el.click();
            },
            validate: () => {
                const state = getStateValue('GRAPH_MODE');
                return {
                    passed: state.exists && state.value === 'files',
                    expected: 'files',
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: () => {
                const atomsBtn = document.querySelector('[data-mode="atoms"]');
                if (atomsBtn) atomsBtn.click();
            },
            fix: 'Ensure [data-mode="files"] button sets GRAPH_MODE = "files" and rebuilds graph'
        }
    ];

    // =========================================================================
    // TEST RUNNER - Enhanced with diagnostics
    // =========================================================================

    async function runTest(testDef) {
        const result = {
            name: testDef.name,
            type: testDef.type,
            passed: false,
            error: null,
            elementFound: false,
            // Enhanced diagnostics
            expected: testDef.expected,
            actual: null,
            stateExists: false,
            trace: null,
            fix: testDef.fix || null
        };

        try {
            // Find element
            const el = testDef.elementId
                ? document.getElementById(testDef.elementId)
                : document.querySelector(testDef.selector);

            if (!el) {
                result.error = 'Element not found';
                result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);
                return result;
            }
            result.elementFound = true;

            // Trace binding chain before test
            result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);

            // Run trigger
            testDef.trigger(el);

            // Small delay for async effects
            await new Promise(r => setTimeout(r, 50));

            // Validate with enhanced result
            const validateResult = testDef.validate();
            if (typeof validateResult === 'object') {
                result.passed = validateResult.passed;
                result.expected = validateResult.expected !== undefined ? validateResult.expected : testDef.expected;
                result.actual = validateResult.actual;
                result.stateExists = validateResult.stateExists;
                if (validateResult.error) result.error = validateResult.error;
            } else {
                result.passed = validateResult;
            }

            // Cleanup
            if (testDef.cleanup) {
                await new Promise(r => setTimeout(r, 50));
                testDef.cleanup(el);
            }

        } catch (err) {
            result.error = err.message;
            result.passed = false;
        }

        return result;
    }

    async function runAll() {
        if (_running) {
            console.warn('[CIRCUIT] Already running');
            return;
        }
        _running = true;
        _results.clear();

        console.log('%c[CIRCUIT] Starting control validation...', 'color: #4dd4ff; font-weight: bold');

        const startTime = performance.now();
        let passed = 0;
        let failed = 0;

        for (const test of TESTS) {
            const result = await runTest(test);
            _results.set(test.name, result);

            if (result.passed) {
                passed++;
                console.log(`  %c✓ ${test.name}`, 'color: #4ade80');
            } else {
                failed++;
                const reason = result.error || (!result.elementFound ? 'Element not found' : 'Validation failed');
                console.log(`  %c✗ ${test.name}: ${reason}`, 'color: #f87171');
                if (result.expected !== undefined && result.actual !== undefined) {
                    console.log(`    Expected: ${JSON.stringify(result.expected)}, Got: ${JSON.stringify(result.actual)}`);
                }
            }

            // Small delay between tests
            await new Promise(r => setTimeout(r, 100));
        }

        const elapsed = (performance.now() - startTime).toFixed(0);
        const total = passed + failed;
        const pct = ((passed / total) * 100).toFixed(1);

        console.log('%c─────────────────────────────────────', 'color: #666');
        if (failed === 0) {
            console.log(`%c[CIRCUIT] ALL PASS: ${passed}/${total} controls (${elapsed}ms)`,
                'color: #4ade80; font-weight: bold');
        } else {
            console.log(`%c[CIRCUIT] ${passed}/${total} passed (${pct}%), ${failed} FAILED (${elapsed}ms)`,
                'color: #f87171; font-weight: bold');
        }

        _running = false;
        return { passed, failed, total, results: Object.fromEntries(_results) };
    }

    async function test(name) {
        const testDef = TESTS.find(t => t.name === name);
        if (!testDef) {
            console.error(`[CIRCUIT] Unknown test: ${name}`);
            return null;
        }
        const result = await runTest(testDef);
        _results.set(name, result);
        return result;
    }

    function report() {
        return Object.fromEntries(_results);
    }

    function listTests() {
        return TESTS.map(t => ({ name: t.name, type: t.type }));
    }

    /**
     * Get detailed fix recommendations for all failures
     */
    function diagnose() {
        const failures = [];
        for (const [name, result] of _results) {
            if (!result.passed) {
                failures.push({
                    control: name,
                    type: result.type,
                    error: result.error,
                    expected: result.expected,
                    actual: result.actual,
                    elementFound: result.elementFound,
                    stateExists: result.stateExists,
                    trace: result.trace ? result.trace.chain : [],
                    fix: result.fix
                });
            }
        }
        return failures;
    }

    // =========================================================================
    // INVENTORY - Generate control tables for documentation
    // =========================================================================

    /**
     * Generate markdown table of all tested controls
     * @returns {string} Markdown table
     */
    function inventory() {
        const lines = [
            '| Control | Type | Element ID | State Path | Purpose |',
            '|---------|------|------------|------------|---------|'
        ];
        TESTS.forEach(t => {
            const purpose = t.fix ? t.fix.split(' - ')[0].replace(/^(Check|Ensure) /, '') : t.name;
            lines.push(`| ${t.name} | ${t.type} | \`${t.elementId || '-'}\` | \`${t.statePath || '-'}\` | ${purpose.substring(0, 40)} |`);
        });
        return lines.join('\n');
    }

    /**
     * Generate JSON inventory of all controls
     * @returns {Array} Control definitions
     */
    function inventoryJSON() {
        return TESTS.map(t => ({
            name: t.name,
            type: t.type,
            elementId: t.elementId,
            statePath: t.statePath,
            graphMethod: t.graphMethod,
            expected: t.expected
        }));
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        runAll,
        test,
        report,
        listTests,
        diagnose,
        inventory,
        inventoryJSON,
        get isRunning() { return _running; },
        TESTS
    };
})();

// Global shortcut
window.CIRCUIT = CIRCUIT;

console.log('[Module] CIRCUIT loaded - UI control validator with diagnostics');


// ═══ MAIN APPLICATION ═══
window.process = window.process || { env: { NODE_ENV: "production" } };
window.global = window.global || window;
// UMD globals: THREE, ForceGraph3D, pako already loaded
// Three.js addons attach to THREE global: THREE.ConvexGeometry
const ConvexGeometry = THREE.ConvexGeometry;
// Note: Post-processing (bloom) removed for simplicity - addons not available in r149+ UMD builds

// COMPRESSED_PAYLOAD: Base64-encoded gzipped JSON data
const COMPRESSED_PAYLOAD = "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okwxRJliiDLFEGWKIcoUQ5QphihTDFGmGKJMMUSZYogyxRBliiHKFEOUKYYoUwxRphiiTDFEmWKIMsUQZYohyhRDlCmGKFMMUaYYokwxRJliiDLFEGWKIcoUQ5QphihTDFGmGKJMMUSZYogyxRBliiHKFEOUKYYoUwxRphiiTDFEmWKIMsWfaAu8gr84g784g784g784g784g784f6It8Aq+vgy+vvyJtsArOI7yJ9oCr+D7yOD7yOD7yOD7yJ9oC7yCExmDExmDExl/oi3wCq4+fIlO8DTwZHiaeFp42ng6eLp4eniiLfAKbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbggMbgj/f3vXwty2kaT/CkpOaiWVJJNDPX21dSVLtM1Er0i0s9nVFg0BIAkLBBg8JDOb/Pfr/nowA5CQrOSkXFwnOcWQg8Y8enp6erp7uhWuIShcQ1C4hqBwDUHhGoLCNQSFawgK1xAUriEoXENQuIagcA1B4RqCwjUEhWsICtcQFK4hKFxDULiGoHANQeEagsI1BIVrCArXEBSuIShcQ1C4hqBwDUHhGoLCNQT6bLq8LTY/fUnX2lDE6PMeR+qfXGtc60KF/Qs+5Y6uaJLfiNEWnydTazcYWDuk2AbPCqPwEOPBrWs0vq61MWVGJSsacTEWpFNr8BV1xkwUCYm1mInFz+hSxM7+Q1HRn+fWFidq29g09rmwNvuDsVHpTgyU2GyOrN1tijf6+PyxsBav732jJ3atTXpmDIdA+4++NWyNAdZ3jdZFdDHoxFtrgvDRxi0+T8YGQmw6mMAjPLseG0PLJ6vfEZtpRU0jpvg3MuxxxVRrNexihvhnYXDwjW/dAH4q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";

// --------------------------------------------------------------------
// WEB WORKER: JSON Parsing Only (Decompression in main thread)
// OPTIMIZED: Main thread uses already-loaded pako, no duplicate CDN fetch
// --------------------------------------------------------------------
const workerScript = `
        self.onmessage = function(e) {
            const jsonStr = e.data;
            try {
                self.postMessage({status: 'PARSING...'});
                const data = JSON.parse(jsonStr);
                self.postMessage({status: 'ANALYZING COSMOS...', result: data});
            } catch (err) {
                self.postMessage({error: err.message});
            }
        };
        `;

// Initialize Worker (minimal - no pako needed)
const blob = new Blob([workerScript], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));

// OPTIMIZED: Decompress in main thread using already-loaded pako
function decompressPayload(payload) {
    // Update status
    const statusEl = document.getElementById('loader-status');
    if (statusEl) statusEl.innerText = 'DECOMPRESSING...';

    // 1. Decode Base64
    const charData = atob(payload);
    const binData = new Uint8Array(charData.length);
    for (let i = 0; i < charData.length; i++) {
        binData[i] = charData.charCodeAt(i);
    }

    // 2. Inflate using main thread's pako (already loaded from CDN)
    if (statusEl) statusEl.innerText = 'INFLATING...';
    const jsonStr = pako.inflate(binData, { to: 'string' });

    return jsonStr;
}

let FULL_GRAPH = null;
let Graph = null;
let DM = null;  // DataManager instance - initialized in initGraph()
let Legend = null;  // LegendManager instance - initialized in initGraph()
let CURRENT_DENSITY = 1; // Default: show all nodes
let ACTIVE_DATAMAPS = new Set();
let DATAMAP_CONFIGS = [];
let DATAMAP_INDEX = {};
let DATAMAP_UI = new Map();
let HOVERED_NODE = null;
// SELECTED_NODE_IDS - provided by selection.js module (getter to SELECT.ids)
let DATASET_KEY = 'default';
let GROUPS_STORAGE_KEY = 'collider_groups_default';
let GROUPS = [];
let ACTIVE_GROUP_ID = null;
// MARQUEE_ACTIVE, MARQUEE_START, MARQUEE_ADDITIVE, LAST_MARQUEE_END_TS - provided by selection.js module
let SELECTION_BOX = null;
const SELECTION_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
const GROUP_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
let SPACE_PRESSED = false;
let IS_3D = true;
// Expose for circuit-breaker tests (dimension-toggle test checks window.IS_3D)
Object.defineProperty(window, 'IS_3D', {
    get: () => IS_3D,
    set: (v) => { IS_3D = v; },
    configurable: true
});
let DIMENSION_TRANSITION = false;
// Expose for dimension.js module and circuit-breaker tests
Object.defineProperty(window, 'DIMENSION_TRANSITION', {
    get: () => DIMENSION_TRANSITION,
    set: (v) => { DIMENSION_TRANSITION = v; },
    configurable: true
});
// STARFIELD & BLOOM - REMOVED (nodes ARE the stars, post-processing not in r149+ UMD builds)
// EDGE_MODE - provided by edge-system.js module
let EDGE_DEFAULT_OPACITY = null;  // Initialized from appearance.tokens at runtime (token value: 0.08)

// PERF_MONITOR - provided by perf-monitor.js module (window.PERF, window.PERF_MONITOR)

// Initialize after DOM ready
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => PERF_MONITOR.init(), 100);
    // Initialize SidebarManager facade for sidebar controls
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
        SIDEBAR.init();
    }
});
let DEFAULT_LINK_DISTANCE = null;

// =================================================================
// THEME CONFIGURATION: Loaded from payload at runtime
// =================================================================
let THEME_CONFIG = {
    available: ['dark'],
    default: 'dark',
    current: 'dark',
    colors: {
        edge: {},
        viz: {},
        console: {},
        schemes: {}
    }
};

// Default color configs - will be overridden by payload tokens
// Edge mode configuration - populated from appearance.tokens at runtime
// Fallback values are defined in appearance.tokens.json:131-204
let EDGE_MODE_CONFIG = {
    resolution: {},
    weight: {},
    confidence: {},
    width: {},
    dim: {},
    opacity: null
};
// Edge type colors - populated from theme.tokens.json:501-512 at runtime
let EDGE_COLOR_CONFIG = {};
// FILE_COLOR_CONFIG, EDGE_RANGES, NODE_FILE_INDEX - provided by modules (file-viz.js, edge-system.js)
let NODE_COLOR_CONFIG = { tier: {}, ring: {}, unknown: '#666666' };

// Console logging colors - populated from theme config
let CONSOLE_COLORS = {
    success: '#4ade80',
    error: '#f87171',
    warning: '#ffaa00',
    info: '#4dd4ff'
};

// Viz colors for canvas and fallbacks - populated from theme config
let VIZ_COLORS = {
    canvasBg: '#03040a',
    nodeFallback: '#888888',
    edgeFallback: '#333333',
    groupHalo: '#88d0ff'
};
let FLOW_CONFIG = {};  // Flow mode settings from THE REMOTE CONTROL
window.GRAPH_MODE = 'atoms'; // atoms | files | hybrid - on window for FILE_VIZ access

// Layout stability: cache node positions to prevent re-randomization on toggles
let NODE_POSITION_CACHE = new Map();
let LAYOUT_FROZEN = false;  // When true, don't reheat simulation
let HINTS_ENABLED = true;   // Show mode toasts

// FILE_GRAPH, FILE_NODE_IDS, EXPANDED_FILES, FILE_EXPAND_MODE - provided by file-viz.js module
let LAST_FILTER_SUMMARY = null;
let FILE_NODE_POSITIONS = new Map();
let NODE_COLOR_MODE = 'tier';
let COLOR_TWEAKS = {
    hueShift: 0,
    chromaScale: 1,
    lightnessShift: 0
};
let VIS_FILTERS = {
    tiers: new Set(),
    rings: new Set(),
    roles: new Set(),
    edges: new Set(),
    families: new Set(),  // Atom families: LOG, DAT, ORG, EXE, EXT
    files: new Set(),     // File-based filtering
    layers: new Set(),    // D2_LAYER: Interface, Application, Core, Infrastructure, Test
    effects: new Set(),   // D6_EFFECT: Pure, Read, Write, ReadWrite
    edgeFamilies: new Set(), // Edge families: Structural, Dependency, Inheritance, Semantic, Temporal
    metadata: {
        showLabels: true,
        showFilePanel: true,
        showReportPanel: true,
        showEdges: true
    }
};
let SIDEBAR_STATE = {
    open: false,
    locked: false
};
let APPEARANCE_STATE = {
    nodeScale: 1,
    nodeOpacity: 1,
    labelSize: 1,
    showLabels: true,
    highlightSelected: true,
    edgeOpacity: null,
    edgeWidth: 1,
    edgeCurvature: 0,
    showArrows: false,
    gradientEdges: true,
    boundaryFill: null,
    boundaryWire: null,
    backgroundBase: null,
    backgroundBrightness: 1,
    fileLightness: null,
    clusterStrength: null,
    currentPreset: 'tier',
    colorMode: 'tier',
    sizeMode: 'fanout',
    edgeMode: 'type',
    // Amplifier: Power law exponent for visual contrast
    // γ=1 linear, γ>1 amplifies differences, γ<1 compresses
    amplifier: 1.0,
    amplifierTarget: 'all'  // 'all', 'edges', 'nodes', 'opacity'
};
// Expose for modules and circuit-breaker tests
window.APPEARANCE_STATE = APPEARANCE_STATE;

// =====================================================================
// FILE BOUNDARY & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
// fileBoundaryMeshes, fileMode, fileVizMode - provided by file-viz.js module
let originalNodeColors = new Map();
let clusterForceActive = false;
let hullRedrawTimer = null;
let hullRedrawAttempts = 0;
const originalColorsForDim = new Map();
let flowMode = false; // Hoisted from line 7333

// REGISTRY - provided by registry.js module (window.REGISTRY)


// =================================================================
// GLOBAL CONSTANTS (Hoisted for safety)
// =================================================================
const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

// OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
const PENDULUM = {
    hue: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,        // Set from appearance.tokens
        gravity: null,        // Set from appearance.tokens
        length: 1.0,
        rotationSpeed: null   // Set from appearance.tokens
    },
    chroma: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,
        gravity: null,
        length: 1.0,
        center: null,
        amplitude: null
    },
    lightness: {
        phase: 0,
        speed: null,
        center: null,
        amplitude: null
    },
    ripple: {
        speed: null,
        scale: null
    },
    currentHue: Math.random() * 360,
    lastTime: 0,
    running: false
};
// =====================================================================
// HOVER & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
let _lastHoveredNodeId = null;
const selectionOriginals = new Map();

// amplify, amplifyContrast - provided by core.js module

// =====================================================================
// DATA MANAGER: Minimal runtime checks for deterministic self-test/parity
// =====================================================================

// =====================================================================
// COLOR ORCHESTRATOR: Centralized Color Intelligence System
// =====================================================================
// SINGLE SOURCE OF TRUTH for ALL colors in the visualization.
// Everything reads from here. OKLCH transforms apply here.
// =====================================================================
const ColorOrchestrator = {
    // =================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =================================================================
    palette: {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    },

    // =================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =================================================================
    transform: {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    },

    // =================================================================
    // INTERVAL MAPPINGS: For numeric data → color gradients
    // =================================================================
    intervals: {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        }
    },

    // =================================================================
    // CORE API: Get color with transforms applied
    // =================================================================
    get(dimension, category) {
        const base = this.palette[dimension]?.[category];
        if (!base) return this._toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray

        return this._applyTransform(base);
    },

    // Get color for a numeric value using interval mapping
    getInterval(intervalName, value) {
        const interval = this.intervals[intervalName];
        if (!interval) return this._toHex({ h: 0, c: 0.02, l: 0.40 });

        const stops = interval.stops;
        const v = Math.max(0, Math.min(1, value));

        // Find surrounding stops
        let lower = stops[0];
        let upper = stops[stops.length - 1];

        for (let i = 0; i < stops.length - 1; i++) {
            if (v >= stops[i].value && v <= stops[i + 1].value) {
                lower = stops[i];
                upper = stops[i + 1];
                break;
            }
        }

        // Interpolate between stops
        const range = upper.value - lower.value;
        const t = range > 0 ? (v - lower.value) / range : 0;

        const interpolated = {
            h: lower.h + (upper.h - lower.h) * t,
            c: lower.c + (upper.c - lower.c) * t,
            l: lower.l + (upper.l - lower.l) * t
        };

        return this._applyTransform(interpolated);
    },

    // Get raw OKLCH values (for advanced use)
    getRaw(dimension, category) {
        return this.palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
    },

    // Get all categories for a dimension
    getCategories(dimension) {
        return Object.keys(this.palette[dimension] || {});
    },

    // Get label for a category
    getLabel(dimension, category) {
        return this.palette[dimension]?.[category]?.label || category;
    },

    // =================================================================
    // TRANSFORM CONTROLS: Update OKLCH state
    // =================================================================
    setTransform(key, value) {
        if (key in this.transform) {
            this.transform[key] = value;
            this._notifySubscribers('transform-change', { key, value });
        }
    },

    setAllTransforms(transforms) {
        Object.assign(this.transform, transforms);
        this._notifySubscribers('transform-change', transforms);
    },

    resetTransforms() {
        this.transform = {
            hueShift: 0,
            chromaScale: 1.0,
            lightnessShift: 0,
            amplifier: 1.0
        };
        this._notifySubscribers('transform-change', this.transform);
    },

    // =================================================================
    // INTERNAL: Apply OKLCH transforms and convert to hex
    // =================================================================
    _applyTransform(oklch) {
        const t = this.transform;

        // Apply transforms
        let h = (oklch.h + t.hueShift + 360) % 360;
        let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
        let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

        // Apply amplifier to chroma for contrast
        if (t.amplifier !== 1) {
            c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
        }

        return this._toHex({ h, c, l });
    },

    _toHex(oklch) {
        // OKLCH to sRGB conversion (simplified)
        // Using CSS color conversion would be ideal, but this approximation works
        const { h, c, l } = oklch;

        // Convert OKLCH to approximate RGB
        const hRad = h * Math.PI / 180;
        const a = c * Math.cos(hRad);
        const b = c * Math.sin(hRad);

        // Simplified OKLab to linear RGB (approximate)
        const L = l;
        const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

        const l3 = l_ * l_ * l_;
        const m3 = m_ * m_ * m_;
        const s3 = s_ * s_ * s_;

        let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
        let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
        let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

        // Clamp and convert to sRGB
        const toSRGB = (x) => {
            x = Math.max(0, Math.min(1, x));
            return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
        };

        r = Math.round(toSRGB(r) * 255);
        g = Math.round(toSRGB(g) * 255);
        bl = Math.round(toSRGB(bl) * 255);

        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        bl = Math.max(0, Math.min(255, bl));

        return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
    },

    // =================================================================
    // REACTIVE SUBSCRIPTIONS
    // =================================================================
    _subscribers: [],

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    },

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    },

    // =================================================================
    // DEBUG: Log current state
    // =================================================================
    debug() {
        console.log('[ColorOrchestrator] Transform state:', this.transform);
        console.log('[ColorOrchestrator] Palette dimensions:', Object.keys(this.palette));
        console.log('[ColorOrchestrator] Interval mappings:', Object.keys(this.intervals));
    }
};

// Global alias for convenience
const Color = ColorOrchestrator;



// =====================================================================
// FLOATING PANEL CONTROL SYSTEM - CONSOLIDATED INTO modules/panels.js
// =====================================================================
// openPanel, closePanel, togglePanel, initCommandBar - ALL IN panels.js
// (backward compat shims in panels.js)


// Populate filter chips in floating panels
function populateFilterChips() {
    if (!DM) return;  // ALL DATA FROM DM

    // Use DM cached aggregations (O(1) lookups)
    const tierCounts = DM.getTierCounts();
    const ringCounts = DM.getRingCounts();
    const edgeCounts = DM.getEdgeTypeCounts();

    buildChipGroup('chips-tiers', tierCounts, VIS_FILTERS.tiers, refreshGraph);
    buildChipGroup('chips-rings', ringCounts, VIS_FILTERS.rings, refreshGraph);
    buildChipGroup('chips-edges', edgeCounts, VIS_FILTERS.edges, refreshGraph);
}

// renderLegendSection, renderAllLegends - MOVED TO modules/legend-manager.js
// (debounce is now built into legend-manager.js, no monkey-patching needed)

// =====================================================================
// HUD LAYOUT MANAGER: MIGRATED TO modules/layout.js
// =====================================================================
// HudLayoutManager (390 lines) has been migrated to modules/layout.js
// which provides the LAYOUT module with:
//   - All original panel placement functionality
//   - NEW: Toast/control-bar collision detection
//   - NEW: Min-width graph validation
//   - NEW: Debug overlay (Ctrl+Shift+L)
//   - NEW: Component registration system
//
// Backward compatibility: window.HudLayoutManager = LAYOUT (alias)
// =====================================================================

worker.onmessage = function (e) {
    if (e.data.status && !e.data.result) {
        document.getElementById('loader-status').innerText = e.data.status;
    } else if (e.data.error) {
        document.getElementById('loader-status').innerText = "ERROR: " + e.data.error;
        document.getElementById('loader-status').style.color = "red";
    } else if (e.data.result) {
        FULL_GRAPH = e.data.result;
        FILE_GRAPH = null;
        FILE_NODE_POSITIONS = new Map();
        EXPANDED_FILES.clear();
        window.GRAPH_MODE = 'atoms';
        document.getElementById('loader-status').innerText = "INITIALIZING VISUALIZATION...";
        initGraph(FULL_GRAPH);
    }
};

// Start Work: Decompress in main thread, then send JSON string to worker for parsing
try {
    const jsonStr = decompressPayload(COMPRESSED_PAYLOAD);
    worker.postMessage(jsonStr);
} catch (err) {
    document.getElementById('loader-status').innerText = "ERROR: " + err.message;
    document.getElementById('loader-status').style.color = "red";
    console.error('[Decompression] Failed:', err);
}

// =====================================================================
// 2D CANVAS FALLBACK: Used when WebGL is unavailable
// =====================================================================
function initFallback2D(container, graphData, fullData) {
    console.log('[2D Fallback] Initializing canvas renderer');
    showToast('WebGL unavailable - using 2D fallback');

    const loader = document.getElementById('loader');
    if (loader) loader.style.display = 'none';

    // Update HUD stats even in 2D fallback mode
    updateHudStats(fullData);

    container.innerHTML = '';
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.background = VIZ_COLORS.canvasBg;
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    let width = container.clientWidth || window.innerWidth;
    let height = container.clientHeight || window.innerHeight;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    // Layout: simple force-directed positions
    const nodes = graphData.nodes || [];
    const links = graphData.links || [];
    const nodeMap = new Map();

    nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        const radius = Math.min(width, height) * 0.35;
        n._x = width / 2 + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);
        n._y = height / 2 + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5);
        n._vx = 0;
        n._vy = 0;
        nodeMap.set(n.id, n);
    });

    // Camera state
    let camX = 0, camY = 0, zoom = 1;
    let dragging = false, lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mousemove', e => {
        if (!dragging) return;
        camX += (e.clientX - lastX) / zoom;
        camY += (e.clientY - lastY) / zoom;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        zoom = Math.max(0.1, Math.min(5, zoom * factor));
    }, { passive: false });

    function toScreen(x, y) {
        return {
            x: (x + camX - width / 2) * zoom + width / 2,
            y: (y + camY - height / 2) * zoom + height / 2
        };
    }

    function parseColor(c) {
        if (typeof c === 'number') {
            return '#' + c.toString(16).padStart(6, '0');
        }
        return c || VIZ_COLORS.nodeFallback;
    }

    function render() {
        ctx.fillStyle = VIZ_COLORS.canvasBg;
        ctx.fillRect(0, 0, width, height);

        // Draw edges
        ctx.strokeStyle = 'rgba(100,100,100,0.3)';
        ctx.lineWidth = 0.5;
        for (const link of links) {
            const src = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
            const tgt = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);
            if (!src || !tgt) continue;
            const p1 = toScreen(src._x, src._y);
            const p2 = toScreen(tgt._x, tgt._y);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // Draw nodes
        for (const node of nodes) {
            const p = toScreen(node._x, node._y);
            const r = Math.max(2, (node.val || 1) * zoom * 0.5);
            ctx.fillStyle = parseColor(node.color);
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Info overlay
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '11px monospace';
        ctx.fillText('2D Fallback Mode (WebGL unavailable)', 10, 20);
        ctx.fillText('Drag to pan, scroll to zoom', 10, 35);
        ctx.fillText(`Nodes: ${nodes.length} | Edges: ${links.length}`, 10, 50);

        requestAnimationFrame(render);
    }

    function resize() {
        width = container.clientWidth || window.innerWidth;
        height = container.clientHeight || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', resize);
    render();

    // Initialize DataManager (required for UI controls)
    DM = new DataManager();
    DM.init(fullData);
    window.DM = DM;

    // Setup UI controls (they work independently of 3D graph)
    setupControls(fullData);
    setupReport(fullData);
    setupAIInsights(fullData);
    setupMetrics(fullData);
    setupHudFade();
    setupDimensionToggle();

    // Update stats with actual node/edge counts
    updateHudStats(graphData);
}

function initGraph(data) {
    // =================================================================
    // DATA MANAGER: Self-test + parity checks
    // =================================================================
    DM = new DataManager();
    DM.init(data);
    window.DM = DM;
    DM.selfTest();
    runDmParity(DM, data);

    // =================================================================
    // HUD STATS: Populate header and stats panel with graph data
    // =================================================================
    updateHudStats(data);

    // =================================================================
    // SIDEBAR: Populate filter chips from loaded data
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.populateFilterChips) {
        SIDEBAR.populateFilterChips(data);
    }

    // =================================================================
    // SIDEBAR: Apply deferred view mode (files mode if saved in localStorage)
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.applyDeferredViewMode) {
        SIDEBAR.applyDeferredViewMode();
    }

    // =================================================================
    // TOKEN-DRIVEN CONFIG: Extract from payload
    // =================================================================
    const physicsConfig = data.physics || {};
    const appearanceConfig = data.appearance || {};
    window.APPEARANCE_CONFIG = appearanceConfig;

    // =================================================================
    // THEME CONFIG: Load theme configuration for runtime switching
    // =================================================================
    if (data.theme_config) {
        THEME_CONFIG = {
            ...THEME_CONFIG,
            available: data.theme_config.available || ['dark'],
            default: data.theme_config.default || 'dark',
            current: data.theme_config.default || 'dark',
            colors: data.theme_config.colors || THEME_CONFIG.colors
        };

        // Apply edge colors from theme config
        if (THEME_CONFIG.colors.edge) {
            EDGE_COLOR_CONFIG = { ...EDGE_COLOR_CONFIG, ...THEME_CONFIG.colors.edge };
        }

        // Apply viz colors from theme config
        if (THEME_CONFIG.colors.viz) {
            const viz = THEME_CONFIG.colors.viz;
            VIZ_COLORS = {
                canvasBg: viz['canvas-bg'] || VIZ_COLORS.canvasBg,
                nodeFallback: viz['node-fallback'] || VIZ_COLORS.nodeFallback,
                edgeFallback: viz['edge-fallback'] || VIZ_COLORS.edgeFallback,
                groupHalo: viz['group-halo'] || VIZ_COLORS.groupHalo
            };
        }

        // Apply console colors from theme config
        if (THEME_CONFIG.colors.console) {
            CONSOLE_COLORS = { ...CONSOLE_COLORS, ...THEME_CONFIG.colors.console };
        }

        console.log(`%c[Theme] Loaded: ${THEME_CONFIG.available.join(', ')}`, `color: ${CONSOLE_COLORS.info}; font-weight: bold`);
    }
    const simulation = physicsConfig.simulation || {};
    // background.bloom, background.stars - REMOVED (post-processing not available in r149+ UMD builds)
    // renderConfig, highlightConfig - REMOVED (unused, features not implemented)
    FLOW_CONFIG = appearanceConfig.flow_mode || {};

    // Merge animation tokens into PENDULUM (T004)
    const animationConfig = appearanceConfig.animation || {};
    if (animationConfig.hue) {
        PENDULUM.hue.damping = animationConfig.hue.damping ?? 0.9995;
        PENDULUM.hue.gravity = animationConfig.hue.speed ?? 0.0008;
        PENDULUM.hue.rotationSpeed = animationConfig.hue.rotation ?? 0.8;
    }
    if (animationConfig.chroma) {
        PENDULUM.chroma.damping = animationConfig.chroma.damping ?? 0.998;
        PENDULUM.chroma.gravity = animationConfig.chroma.gravity ?? 0.0004;
        PENDULUM.chroma.center = animationConfig.chroma.center ?? 0.32;
        PENDULUM.chroma.amplitude = animationConfig.chroma.amplitude ?? 0.08;
    }
    if (animationConfig.lightness) {
        PENDULUM.lightness.speed = animationConfig.lightness.speed ?? 0.02;
        PENDULUM.lightness.center = animationConfig.lightness.center ?? 82;
        PENDULUM.lightness.amplitude = animationConfig.lightness.amplitude ?? 10;
    }
    if (animationConfig.ripple) {
        PENDULUM.ripple.speed = animationConfig.ripple.speed ?? 0.035;
        PENDULUM.ripple.scale = animationConfig.ripple.scale ?? 200;
    }
    const edgeModes = appearanceConfig.edge_modes || {};
    EDGE_MODE_CONFIG = {
        resolution: edgeModes.resolution || { internal: '#4dd4ff', external: '#ff6b6b', unresolved: '#9aa0a6', unknown: '#666666' },
        weight: edgeModes.weight || { hue_min: 210, hue_max: 50, saturation: 45, lightness: 42 },
        confidence: edgeModes.confidence || { hue_min: 20, hue_max: 120, saturation: 45, lightness: 44 },
        width: edgeModes.width || { base: 0.6, weight_scale: 2.0, confidence_scale: 1.5 },
        dim: edgeModes.dim || { interfile_factor: 0.25 },
        opacity: (typeof edgeModes.opacity === 'number') ? edgeModes.opacity : 0.08
    };

    FILE_COLOR_CONFIG = Object.assign({}, FILE_COLOR_CONFIG, appearanceConfig.file_color || {});
    // Token value 0.08 from appearance.tokens.json:202, fallback only if token system fails
    EDGE_DEFAULT_OPACITY =
        (typeof EDGE_MODE_CONFIG.opacity === 'number') ? EDGE_MODE_CONFIG.opacity : 0.08;
    const boundaryConfig = appearanceConfig.boundary || {};
    APPEARANCE_STATE.edgeOpacity = EDGE_DEFAULT_OPACITY;
    APPEARANCE_STATE.boundaryFill = boundaryConfig.fill_opacity ?? APPEARANCE_STATE.boundaryFill;
    APPEARANCE_STATE.boundaryWire = boundaryConfig.wire_opacity ?? APPEARANCE_STATE.boundaryWire;
    const background = appearanceConfig.background || {};
    APPEARANCE_STATE.backgroundBase = background.color || '#000000';
    APPEARANCE_STATE.fileLightness = FILE_COLOR_CONFIG.lightness ?? APPEARANCE_STATE.fileLightness;
    const nodeColor = appearanceConfig.node_color || {};
    NODE_COLOR_CONFIG = {
        tier: nodeColor.tier || {},
        ring: nodeColor.ring || {},
        unknown: nodeColor.unknown || '#666666'
    };
    const edgeColor = appearanceConfig.edge_color || {};
    EDGE_COLOR_CONFIG = {
        default: edgeColor.default || '#333333',
        calls: edgeColor.calls || '#4dd4ff',
        contains: edgeColor.contains || '#00ff9d',
        uses: edgeColor.uses || '#ffb800',
        imports: edgeColor.imports || '#9aa0a6',
        inherits: edgeColor.inherits || '#ff6b6b'
    };

    // Initial Filter: show full graph
    const filtered = filterGraph(data, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);

    // ═══════════════════════════════════════════════════════════════════
    // DATA PREP FOR ANIMATIONS: Assign file indices for wave patterns
    // ═══════════════════════════════════════════════════════════════════
    const fileMap = new Map();
    let nextFileIdx = 0;
    filtered.nodes.forEach(node => {
        // Extract filename from ID (assuming file path is in ID or explicit file prop)
        const file = node.file || (node.id.includes('/') ? node.id.split(':')[0] : 'unknown');
        if (!fileMap.has(file)) fileMap.set(file, nextFileIdx++);
        node.file_idx = fileMap.get(file);
    });

    const div = document.getElementById('3d-graph');

    // ═══════════════════════════════════════════════════════════════════
    // GRADIENT EDGES: Custom THREE.js lines with vertex colors
    // Creates beautiful gradients from source to target node colors
    // ═══════════════════════════════════════════════════════════════════
    let GRADIENT_EDGES_ENABLED = true;  // Toggle for gradient edges

    function hexToRgb(hex) {
        // Convert hex color to RGB array [0-1, 0-1, 0-1]
        if (typeof hex === 'number') {
            return [
                ((hex >> 16) & 255) / 255,
                ((hex >> 8) & 255) / 255,
                (hex & 255) / 255
            ];
        }
        if (typeof hex === 'string') {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                ((num >> 16) & 255) / 255,
                ((num >> 8) & 255) / 255,
                (num & 255) / 255
            ];
        }
        return [0.5, 0.5, 0.5];  // Default gray
    }

    function createGradientEdge(link) {
        // Get source and target nodes
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        // Get colors from nodes (using current color mode)
        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        // Create geometry with 2 vertices
        const geometry = new THREE.BufferGeometry();

        // Positions will be updated by linkPositionUpdate
        const positions = new Float32Array([0, 0, 0, 0, 0, 0]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Vertex colors: source color at start, target color at end
        const colors = new Float32Array([
            srcRgb[0], srcRgb[1], srcRgb[2],  // Source vertex color
            tgtRgb[0], tgtRgb[1], tgtRgb[2]   // Target vertex color
        ]);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Material with vertex colors
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: link.opacity ?? EDGE_DEFAULT_OPACITY,
            linewidth: 1  // Note: linewidth > 1 only works on some platforms
        });

        return new THREE.Line(geometry, material);
    }

    function updateGradientEdge(line, link, coords) {
        // Update line positions
        const posArr = line.geometry.attributes.position.array;
        posArr[0] = coords.start.x || 0;
        posArr[1] = coords.start.y || 0;
        posArr[2] = coords.start.z || 0;
        posArr[3] = coords.end.x || 0;
        posArr[4] = coords.end.y || 0;
        posArr[5] = coords.end.z || 0;
        line.geometry.attributes.position.needsUpdate = true;

        // Update colors based on current node colors
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        const colArr = line.geometry.attributes.color.array;
        colArr[0] = srcRgb[0]; colArr[1] = srcRgb[1]; colArr[2] = srcRgb[2];
        colArr[3] = tgtRgb[0]; colArr[4] = tgtRgb[1]; colArr[5] = tgtRgb[2];
        line.geometry.attributes.color.needsUpdate = true;
    }

    // Refresh all gradient edge colors (call when node color mode changes)
    function refreshGradientEdgeColors() {
        if (!GRADIENT_EDGES_ENABLED || !Graph) return;
        // Force rebuild of all link objects to update colors
        Graph.linkThreeObject(link => createGradientEdge(link));
    }

    // Make it globally accessible for color mode changes
    window.refreshGradientEdgeColors = refreshGradientEdgeColors;

    // TOKEN-DRIVEN: Read render config from THE REMOTE CONTROL
    const renderConfig = appearanceConfig.render || {};
    const dimensions = renderConfig.dimensions || 3;
    const nodeRes = renderConfig.nodeResolution || 8;

    try {
        Graph = ForceGraph3D({
            rendererConfig: {
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            }
        })
            (div)
            .graphData(filtered)
            .numDimensions(dimensions)
            .backgroundColor(toColorNumber(background.color, 0x000000))
            .nodeLabel('name')
            .nodeColor(node => toColorNumber(node.color, 0x888888))
            .nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale)
            // ═══════════════════════════════════════════════════════════════════
            // GRADIENT EDGES: Custom THREE.Line with vertex colors
            // Each edge smoothly transitions from source node color to target node color
            // ═══════════════════════════════════════════════════════════════════
            .linkThreeObject(link => GRADIENT_EDGES_ENABLED ? createGradientEdge(link) : null)
            .linkPositionUpdate((line, coords, link) => {
                if (GRADIENT_EDGES_ENABLED && line) {
                    updateGradientEdge(line, link, coords);
                }
                return true;  // Keep default behavior for non-gradient
            })
            .linkColor(link => GRADIENT_EDGES_ENABLED ? null : toColorNumber(getEdgeColor(link), 0x222222))
            .linkOpacity(link => GRADIENT_EDGES_ENABLED ? 0 : (link.opacity ?? EDGE_DEFAULT_OPACITY))
            .nodeThreeObjectExtend(true)
            .nodeThreeObject(node => ensureNodeOverlays(node))
            .nodeResolution(Math.max(nodeRes, 16))
            .linkResolution(6)
            .showNavInfo(false)
            .warmupTicks(simulation.warmupTicks || 30)
            .cooldownTicks(simulation.cooldownTicks || 0)
            .onNodeHover(node => handleNodeHover(node, data))
            .onNodeClick((node, event) => handleNodeClick(node, event))
            .onBackgroundClick(() => maybeClearSelection())
            // ═══════════════════════════════════════════════════════════════════
            // GROUP DRAG: Move all selected nodes together, maintaining offsets
            // Note: onNodeDragStart doesn't exist - detect start via flag
            // ═══════════════════════════════════════════════════════════════════
            .onNodeDrag((node, _translate) => {
                // Only handle group drag if multiple nodes selected and this node is selected
                if (SELECTED_NODE_IDS.size > 1 && SELECTED_NODE_IDS.has(node.id)) {
                    // First drag frame: store relative offsets
                    if (!window._groupDragActive) {
                        window._groupDragActive = true;
                        window._groupDragOffsets = new Map();
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            if (SELECTED_NODE_IDS.has(n.id) && n.id !== node.id) {
                                window._groupDragOffsets.set(n.id, {
                                    dx: (n.x || 0) - (node.x || 0),
                                    dy: (n.y || 0) - (node.y || 0),
                                    dz: (n.z || 0) - (node.z || 0)
                                });
                            }
                        });
                    }
                    // Move all other selected nodes with their offsets
                    if (window._groupDragOffsets) {
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            const offset = window._groupDragOffsets.get(n.id);
                            if (offset) {
                                n.fx = node.x + offset.dx;
                                n.fy = node.y + offset.dy;
                                n.fz = node.z + offset.dz;
                            }
                        });
                    }
                }
            })
            .onNodeDragEnd(_node => {
                // Clear group drag state
                window._groupDragActive = false;
                window._groupDragOffsets = null;
                // Fix all selected nodes at their final positions
                if (SELECTED_NODE_IDS.size > 0) {
                    const nodes = Graph.graphData().nodes;
                    nodes.forEach(n => {
                        if (SELECTED_NODE_IDS.has(n.id)) {
                            n.fx = n.x; n.fy = n.y; n.fz = n.z;
                        }
                    });
                }
            })
            .onEngineStop(() => {
                // Physics-dependent operations (run after simulation stabilizes)
                drawFileBoundaries(data);
                // LAYOUT STABILITY: Freeze layout after initial simulation completes
                if (!LAYOUT_FROZEN) {
                    saveNodePositions();
                    freezeLayout();
                }
            });
    } catch (err) {
        console.error('[WebGL] Failed to initialize 3D graph:', err);
        initFallback2D(div, filtered, data);
        return;
    }

    window.Graph = Graph;

    // FIX: Drift on resize
    // Updates Graph renderer size when window creates
    window.addEventListener('resize', () => {
        if (Graph) {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        }
    });

    // OPTIMIZATION: Hide loader immediately after Graph creation (don't wait for physics)
    // This makes the visualization appear 200-500ms faster
    document.getElementById('loader').style.display = 'none';

    // =================================================================
    // RENDERER QUALITY: Enable anti-aliasing and high DPI
    // =================================================================
    const renderer = Graph.renderer();
    if (renderer) {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Enable high quality rendering
        renderer.antialias = true;
        renderer.alpha = true;
        renderer.powerPreference = 'high-performance';
    }

    initSelectionState(data);
    setupSelectionInteractions();
    // updateSelectionVisuals is in selection.js (window scope), may not be loaded yet
    if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();

    // =================================================================
    // CONTROLS: keep default camera behavior, enable damping
    // =================================================================
    const controls = Graph.controls();
    if (controls) {
        // TOKEN-DRIVEN: Read from payload (if available), else use defaults
        // Allow remote configuration of mouse buttons and damping
        const navConfig = data.config?.controls || data.controls || {};

        controls.enableDamping = navConfig.enableDamping !== undefined ? navConfig.enableDamping : true;
        controls.dampingFactor = navConfig.dampingFactor || 0.1;
        controls.enableRotate = navConfig.enableRotate !== undefined ? navConfig.enableRotate : true;
        controls.enablePan = navConfig.enablePan !== undefined ? navConfig.enablePan : true;

        // Mouse Buttons: Map generic names to integer constants
        // 0: ROTATE, 1: DOLLY (Zoom), 2: PAN
        const defaultButtons = {
            LEFT: 2, // PAN
            MIDDLE: 1, // DOLLY
            RIGHT: 0 // ROTATE
        };

        if (navConfig.mouseButtons) {
            controls.mouseButtons = {
                LEFT: navConfig.mouseButtons.LEFT ?? defaultButtons.LEFT,
                MIDDLE: navConfig.mouseButtons.MIDDLE ?? defaultButtons.MIDDLE,
                RIGHT: navConfig.mouseButtons.RIGHT ?? defaultButtons.RIGHT
            };
        } else {
            controls.mouseButtons = defaultButtons;
        }

        // Spacebar toggling disabled to ensure stability
    }

    // =================================================================
    // TOKEN-DRIVEN: Force Configuration
    // =================================================================
    const forces = physicsConfig.forces || {};
    if (forces.charge?.enabled) {
        Graph.d3Force('charge').strength(forces.charge.strength || -120);
        Graph.d3Force('charge').distanceMax(forces.charge.distanceMax || 500);
    }
    if (forces.link?.enabled) {
        const linkDistance = forces.link.distance || 50;
        Graph.d3Force('link').distance(linkDistance);
        DEFAULT_LINK_DISTANCE = linkDistance;
    }
    if (forces.center?.enabled) {
        Graph.d3Force('center').strength(forces.center.strength || 0.05);
    }

    // =================================================================
    // STARFIELD REMOVED - Nodes ARE the stars
    // Rationale: Adding background dots creates visual confusion with actual data nodes.
    // The cosmos metaphor works better when the data itself forms the starfield.
    // =================================================================

    // =================================================================
    // TOKEN-DRIVEN: Bloom Post-Processing (DISABLED - UMD build compatibility)
    // Post-processing addons require ES modules; using UMD for file:// support
    // =================================================================
    // Bloom disabled for compatibility - visualization works without it

    // Setup Hud Controls (TOKEN-DRIVEN)
    // OPTIMIZATION: Defer UI setup to next frame so graph renders first
    // This makes the visualization appear 150-200ms faster
    Promise.resolve().then(() => {
        setupControls(data);
        setupReport(data);
        setupAIInsights(data);
        setupMetrics(data);
        setupHudFade();
        setupDimensionToggle();
        applyEdgeMode();

        // SELF-TEST: Deterministic validation of UI controls (deferred)
        runSelfTest(data);
    });
}

function runSelfTest(data) {
    const results = {
        timestamp: new Date().toISOString(),
        passed: [],
        failed: []
    };

    const test = (name, condition) => {
        if (condition) {
            results.passed.push(name);
        } else {
            results.failed.push(name);
        }
    };

    // Test 1: Core UI structure (dual-sidebar layout)

    // Main layout containers
    test('header-exists', !!document.getElementById('header'));
    test('left-sidebar-exists', !!document.getElementById('left-sidebar'));
    test('right-sidebar-exists', !!document.getElementById('right-sidebar'));
    test('graph-container-exists', !!document.getElementById('3d-graph'));

    // Header stats
    test('stat-nodes-exists', !!document.getElementById('stat-nodes'));
    test('stat-edges-exists', !!document.getElementById('stat-edges'));
    test('target-name-exists', !!document.getElementById('target-name'));

    // Left sidebar configuration sections
    test('section-node-config-exists', !!document.getElementById('section-node-config'));
    test('section-edge-config-exists', !!document.getElementById('section-edge-config'));
    test('section-layout-exists', !!document.getElementById('section-layout'));
    test('section-physics-exists', !!document.getElementById('section-physics'));
    test('section-filters-exists', !!document.getElementById('section-filters'));
    test('section-actions-exists', !!document.getElementById('section-actions'));

    // Left sidebar action buttons
    test('btn-reset-exists', !!document.getElementById('btn-reset'));
    test('btn-screenshot-exists', !!document.getElementById('btn-screenshot'));
    test('btn-2d-exists', !!document.getElementById('btn-2d'));
    test('btn-freeze-exists', !!document.getElementById('btn-freeze'));

    // Right sidebar panels
    test('hover-panel-exists', !!document.getElementById('hover-panel'));
    test('section-schemes-exists', !!document.getElementById('section-schemes'));
    test('section-color-exists', !!document.getElementById('section-color'));

    // Selection elements
    test('selection-count-exists', !!document.getElementById('selection-count'));
    test('selection-list-exists', !!document.getElementById('selection-list'));

    // Stats panel
    test('stats-nodes-exists', !!document.getElementById('stats-nodes'));
    test('stats-edges-exists', !!document.getElementById('stats-edges'));

    // Performance HUD
    test('perf-hud-exists', !!document.getElementById('perf-hud'));
    test('perf-fps-exists', !!document.getElementById('perf-fps'));

    // Test 1b: Color mode buttons exist
    const colorButtons = document.querySelectorAll('.color-btn[data-preset]');
    test('color-mode-buttons-exist', colorButtons.length >= 4);

    // Test 1c: HUD Layout Manager tests
    test('hud-layout-manager-exists', typeof HudLayoutManager === 'object' && HudLayoutManager !== null);
    test('hud-layout-manager-has-reflow', typeof HudLayoutManager.reflow === 'function');
    test('hud-layout-manager-has-placePanel', typeof HudLayoutManager.placePanel === 'function');

    // Test 1d: HUD placement with synthetic rects (collision avoidance)
    if (typeof HudLayoutManager.placePanel === 'function') {
        // Create a test scenario: occupied rect on top-left, panel should avoid it
        const fakeOccupied = [{ left: 0, top: 0, right: 300, bottom: 200 }];
        const fakeCandidates = [
            { left: 20, top: 100 },   // Would overlap with occupied
            { left: 400, top: 100 }   // Should be clear
        ];
        // Create a mock panel element
        const mockPanel = document.createElement('div');
        mockPanel.style.width = '200px';
        mockPanel.style.height = '150px';
        mockPanel.style.position = 'fixed';
        document.body.appendChild(mockPanel);

        const result = HudLayoutManager.placePanel(mockPanel, fakeCandidates, fakeOccupied);
        // Should choose the second candidate (no overlap)
        const pickedNonOverlapping = result && result.left >= 300;
        test('hud-placement-avoids-overlap', pickedNonOverlapping);

        document.body.removeChild(mockPanel);
    }

    // Test 1e: Canonical taxonomy field tests
    // Test that node.tier is preferred over atom prefix inference
    const mockNodeWithTier = { tier: 'T2', atom: 'CORE.001', ring: 'DOMAIN' };
    const tierResult = getNodeTier(mockNodeWithTier);
    test('node-tier-prefers-field', tierResult === 'T2');  // Should use tier field, not infer T0 from CORE.

    // Test that node.ring is used when present
    const mockNodeWithRing = { ring: 'PRESENTATION', layer: 'APPLICATION' };
    const ringResult = getNodeRing(mockNodeWithRing);
    test('node-ring-prefers-field', ringResult === 'PRESENTATION');  // Should use ring, not layer

    // Test tier aliases work (CORE → T0, EXT → T2)
    test('tier-alias-core-to-t0', normalizeTier('CORE') === 'T0');
    test('tier-alias-ext-to-t2', normalizeTier('EXT') === 'T2');

    // Test atom_family extraction
    const mockNodeWithFamily = { atom_family: 'LOG', atom: 'ORG.AGG.M' };
    const familyResult = getNodeAtomFamily(mockNodeWithFamily);
    test('node-atom-family-prefers-field', familyResult === 'LOG');  // Should use atom_family, not infer ORG

    // Test 1f: Hover panel tests
    test('hover-panel-exists', document.getElementById('hover-panel') !== null);

    // Test hover panel uses canonical fields
    const mockCanonicalNode = {
        name: 'TestNode',
        atom_family: 'LOG',
        ring: 'PRESENTATION',
        tier: 'T2',
        atom: 'ORG.AGG.M',
        kind: 'function',
        role: 'Utility'
    };
    // Simulate updateHoverPanel with mock node
    if (typeof updateHoverPanel === 'function') {
        updateHoverPanel(mockCanonicalNode);
        const hoverFamily = document.getElementById('hover-family')?.textContent;
        const hoverRing = document.getElementById('hover-ring')?.textContent;
        const hoverTier = document.getElementById('hover-tier')?.textContent;
        // Verify canonical fields are used (LOG not ORG, PRESENTATION, T2)
        test('hover-panel-uses-canonical-fields',
            hoverFamily === 'LOG' && hoverRing === 'PRESENTATION' && hoverTier === 'T2');
        // Clean up: hide panel
        updateHoverPanel(null);
    }

    // Test 2: Header stats populated (stat-* elements - these are set early)
    const headerNodes = document.getElementById('stat-nodes');
    const headerEdges = document.getElementById('stat-edges');
    test('header-nodes-populated', headerNodes && headerNodes.textContent !== '0');
    test('header-edges-populated', headerEdges && headerEdges.textContent !== '0');

    // Test 3: Data integrity
    test('nodes-count-positive', data.nodes && data.nodes.length > 0);
    test('links-count-positive', data.links && data.links.length > 0);
    test('graph-initialized', !!window.Graph);

    // Test 4: Controls config loaded
    test('controls-config-exists', !!data.controls);
    test('appearance-config-exists', !!data.appearance);
    test('physics-config-exists', !!data.physics);

    // Test 5: Initial state correct
    const physicsCharge = document.getElementById('physics-charge');
    test('physics-slider-has-value', physicsCharge && physicsCharge.value !== undefined);
    test('3d-mode-default', IS_3D === true);

    // Test 6: VIS_STATE module loaded
    test('vis-state-module-exists', typeof VIS_STATE !== 'undefined');
    test('vis-state-has-applyState', typeof VIS_STATE?.applyState === 'function');
    test('vis-state-has-getState', typeof VIS_STATE?.getState === 'function');

    // Expose results to window for external testing
    window.SELF_TEST_RESULTS = results;

    // Log summary
    const total = results.passed.length + results.failed.length;
    const passRate = ((results.passed.length / total) * 100).toFixed(1);

    if (results.failed.length === 0) {
        console.log(`%c✅ SELF-TEST PASSED: ${results.passed.length}/${total} tests (${passRate}%)`, 'color: #00ff00; font-weight: bold');
    } else {
        console.warn(`%c⚠️ SELF-TEST: ${results.passed.length}/${total} passed (${passRate}%)`, 'color: #ffaa00; font-weight: bold');
        console.warn('Failed tests:', results.failed);
    }

    return results;
}

// TIER_ALIASES, normalizeTier, getNodeTier, getNodeAtomFamily, normalizeRingValue,
// getNodeRing, getNodeLayer, getNodeEffect - provided by node-accessors.js module

// getNodeColorByMode, getSubsystem, getPhase, getFileType, getRoleCategory, applyNodeColors - MOVED TO modules/node-helpers.js
// normalize - MOVED TO modules/utils.js

function filterGraph(data, minVal, datamapSet, filters) {
    // ALL DATA FROM DM - the processing pipeline
    const allNodes = DM ? DM.getNodes() : (data?.nodes || []);
    const allLinks = DM ? DM.getLinks() : (data?.links || []);

    const tierFilter = filters?.tiers || new Set();
    const ringFilter = filters?.rings || new Set();
    const roleFilter = filters?.roles || new Set();
    const edgeFilter = filters?.edges || new Set();
    const familyFilter = filters?.families || new Set();
    const layerFilter = filters?.layers || new Set();
    const effectFilter = filters?.effects || new Set();
    const edgeFamilyFilter = filters?.edgeFamilies || new Set();
    const showEdges = filters?.metadata?.showEdges !== false;

    const availableRings = Array.from(new Set(allNodes.map(n => getNodeRing(n)))).sort();
    let ringFilterValues = Array.from(ringFilter);
    let ringIntersection = ringFilterValues.filter(r => availableRings.includes(r));
    if (ringFilterValues.length > 0 && ringIntersection.length === 0) {
        console.warn('[Filters] Ring filter values not present in dataset; clearing.', {
            ringValues: ringFilterValues,
            availableRings
        });
        ringFilter.clear();
        ringFilterValues = [];
        ringIntersection = [];
    }

    // Filter nodes by size/importance
    let visibleNodes = allNodes.filter(n => (n.val ?? 1) >= minVal);

    if (datamapSet && datamapSet.size > 0) {
        visibleNodes = visibleNodes.filter(n => {
            for (const id of datamapSet) {
                const config = DATAMAP_INDEX[id];
                if (config && datamapMatches(n, config)) return true;
            }
            return false;
        });
    }

    const tierFilterActive = tierFilter.size > 0;
    const ringFilterActive = ringFilter.size > 0;
    const roleFilterActive = roleFilter.size > 0;
    const familyFilterActive = familyFilter.size > 0;
    const layerFilterActive = layerFilter.size > 0;
    const effectFilterActive = effectFilter.size > 0;

    const filterSummary = {
        active: {
            tier: tierFilter.size,
            ring: ringFilter.size,
            role: roleFilter.size,
            family: familyFilter.size,
            layer: layerFilter.size,
            effect: effectFilter.size
        },
        ringValues: ringFilterValues.slice().sort(),
        availableRings,
        ringIntersectionSize: ringIntersection.length
    };
    const filterSummaryKey = JSON.stringify(filterSummary);
    if (filterSummaryKey !== LAST_FILTER_SUMMARY) {
        console.log('[Filters] summary', filterSummary);
        LAST_FILTER_SUMMARY = filterSummaryKey;
    }

    visibleNodes = visibleNodes.filter(n => {
        if (tierFilterActive && !tierFilter.has(getNodeTier(n))) return false;
        if (ringFilterActive && !ringFilter.has(getNodeRing(n))) return false;
        if (roleFilterActive && !roleFilter.has(String(n.role || 'Unknown'))) return false;
        if (familyFilterActive && !familyFilter.has(getNodeAtomFamily(n))) return false;
        if (layerFilterActive && !layerFilter.has(getNodeLayer(n))) return false;
        if (effectFilterActive && !effectFilter.has(getNodeEffect(n))) return false;
        return true;
    });



    // Zero-node protection: warn when dimension filters result in empty graph
    if (visibleNodes.length === 0 && (tierFilterActive || ringFilterActive || roleFilterActive || familyFilterActive || layerFilterActive || effectFilterActive)) {
        const activeFilters = [];
        if (tierFilterActive) activeFilters.push(`tiers: [${Array.from(tierFilter).join(', ')}]`);
        if (ringFilterActive) activeFilters.push(`rings: [${Array.from(ringFilter).join(', ')}]`);
        if (roleFilterActive) activeFilters.push(`roles: [${Array.from(roleFilter).join(', ')}]`);
        if (familyFilterActive) activeFilters.push(`families: [${Array.from(familyFilter).join(', ')}]`);
        if (layerFilterActive) activeFilters.push(`layers: [${Array.from(layerFilter).join(', ')}]`);
        if (effectFilterActive) activeFilters.push(`effects: [${Array.from(effectFilter).join(', ')}]`);
        console.warn('[filterGraph] Zero nodes match filters:', activeFilters.join(', '));
    }

    const visibleIds = new Set(visibleNodes.map(n => n.id));

    // Keep edges only between visible nodes
    let visibleLinks = allLinks.filter(l =>
        visibleIds.has(l.source.id || l.source) &&
        visibleIds.has(l.target.id || l.target)
    );

    if (edgeFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFilter.has(String(l.edge_type || l.type || 'default')));
    }

    if (edgeFamilyFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFamilyFilter.has(l.family || 'Dependency'));
    }

    if (!showEdges) {
        visibleLinks = [];
    }

    return { nodes: visibleNodes, links: visibleLinks };
}

// ====================================================================
// LAYOUT STABILITY: saveNodePositions, restoreNodePositions, freezeLayout, unfreezeLayout, resetLayout - MOVED TO modules/layout-helpers.js
// showModeToast - MOVED TO modules/tooltips.js
// getLinkEndpointId, getFileTarget - MOVED TO modules/layout-helpers.js
// stableOffset - MOVED TO modules/utils.js

// buildFileGraph - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.buildFileGraph)
// captureFileNodePositions - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.captureFileNodePositions)

function buildHybridGraph(data) {
    // ALL DATA FROM DM - the reaction chamber for data chemistry
    if (!FILE_GRAPH) {
        FILE_GRAPH = buildFileGraph(data);
    }
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const nodes = DM ? DM.getNodes() : (data?.nodes || []);
    const links = DM ? DM.getLinks() : (data?.links || []);

    const totalFiles = boundaries.length;
    const clusterConfig = data?.physics?.cluster || {};
    const detachRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius * 1.3 : 200;
    const detachZ = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing * 2 : 80;
    const expandRadius = 30;
    const expandedSet = new Set(EXPANDED_FILES);

    const fileNodes = FILE_GRAPH.nodes.map(node => {
        const copy = Object.assign({}, node);
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach' && expandedSet.has(node.fileIdx))
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        copy.x = anchor.x + detachOffset.x;
        copy.y = anchor.y + detachOffset.y;
        copy.z = (anchor.z || 0) + detachOffset.z;
        return copy;
    });

    const nodeFileIdx = new Map();
    nodes.forEach(n => {
        if (n && n.id) {
            nodeFileIdx.set(n.id, n.fileIdx ?? -1);
        }
    });

    const childNodes = [];
    nodes.forEach(node => {
        if (!expandedSet.has(node.fileIdx)) return;
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach')
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        const local = stableOffset(node, `file-${node.fileIdx}`, expandRadius);
        const copy = Object.assign({}, node);
        copy.x = anchor.x + detachOffset.x + local.x;
        copy.y = anchor.y + detachOffset.y + local.y;
        copy.z = (anchor.z || 0) + detachOffset.z + (IS_3D ? local.z : 0);
        childNodes.push(copy);
    });

    const childLinks = [];
    links.forEach(link => {
        const srcId = getLinkEndpointId(link, 'source');
        const tgtId = getLinkEndpointId(link, 'target');
        const srcIdx = nodeFileIdx.get(srcId) ?? -1;
        const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;
        if (srcIdx < 0 || tgtIdx < 0 || srcIdx !== tgtIdx) return;
        if (!expandedSet.has(srcIdx)) return;
        childLinks.push({
            source: srcId,
            target: tgtId,
            color: link.color,
            opacity: link.opacity,
            edge_type: link.edge_type,
            weight: link.weight,
            confidence: link.confidence,
            resolution: link.resolution
        });
    });

    return {
        nodes: fileNodes.concat(childNodes),
        links: FILE_GRAPH.links.concat(childLinks)
    };
}

function setupControls(data) {
    // Initialize the Unified UI Manager
    UIManager.init(data);

    // Initialize modules that require data/DOM to be ready
    // (SIDEBAR.init() is called earlier in DOMContentLoaded)
    if (typeof LAYOUT !== 'undefined' && LAYOUT.init) LAYOUT.init();
    if (typeof HUD !== 'undefined' && HUD.setupFade) HUD.setupFade();
    if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) DIMENSION.setup();

    // Initialize Command Bar and Floating Panels
    initCommandBar();

    // Initialize Selection Detail Modal
    initSelectionModal();

    // Initialize Node & Edge Config Controls (PRIME SECTIONS)
    setupConfigControls();

    // Render color-coded legends with counts
    renderAllLegends();

    // Flow mode button (attached here for proper DOM timing)
    const btnFlow = document.getElementById('btn-flow');
    if (btnFlow) btnFlow.onclick = () => toggleFlowMode();
}

/**
 * =================================================================
 * setupConfigControls: Initialize NODE CONFIG and EDGE CONFIG panels
 * =================================================================
 * These are the "prime position" controls at the top of the sidebar
 */
function setupConfigControls() {
    // Helper: Bind slider with value display
    const bindSlider = (id, valueId, onChange, decimals = 1) => {
        const slider = document.getElementById(id);
        const valueEl = document.getElementById(valueId);
        if (!slider) return;
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (valueEl) valueEl.textContent = decimals === 0 ? val.toString() : val.toFixed(decimals);
            onChange(val);
        });
    };

    // Helper: Bind toggle switch
    const bindToggle = (id, initialState, onChange) => {
        const toggle = document.getElementById(id);
        if (!toggle) return;
        if (initialState) toggle.classList.add('active');
        else toggle.classList.remove('active');
        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            onChange(isActive);
        });
    };

    // Helper: Bind button group (radio-like selection)
    const bindButtonGroup = (container, dataAttr, onChange) => {
        const buttons = container.querySelectorAll(`[${dataAttr}]`);
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                onChange(btn.getAttribute(dataAttr));
            });
        });
    };

    // ═══════════════════════════════════════════════════════════════════
    // NODE CONFIG
    // ═══════════════════════════════════════════════════════════════════

    // Size Mode Selector
    const nodeCfg = document.getElementById('section-node-config');
    if (nodeCfg) {
        bindButtonGroup(nodeCfg, 'data-size-mode', (mode) => {
            APPEARANCE_STATE.sizeMode = mode;
            applyNodeSizeMode(mode);
            console.log('[CONFIG] Size mode:', mode);
        });
    }

    // Node Base Size
    bindSlider('cfg-node-size', 'cfg-node-size-val', (val) => {
        APPEARANCE_STATE.nodeScale = val;
        applyNodeSizeMode(APPEARANCE_STATE.sizeMode || 'uniform');
    });

    // Node Opacity
    bindSlider('cfg-node-opacity', 'cfg-node-opacity-val', (val) => {
        APPEARANCE_STATE.nodeOpacity = val;
        if (Graph) Graph.nodeOpacity(val);
    });

    // Node Resolution (sphere segments)
    bindSlider('cfg-node-res', 'cfg-node-res-val', (val) => {
        APPEARANCE_STATE.nodeResolution = Math.round(val);
        if (Graph) Graph.nodeResolution(Math.round(val));
    }, 0);

    // Label Size
    bindSlider('cfg-label-size', 'cfg-label-size-val', (val) => {
        APPEARANCE_STATE.labelSize = val;
        if (Graph && APPEARANCE_STATE.showLabels) {
            Graph.nodeLabel(node => val > 0.2 ? (node.name || node.id) : null);
        }
    });

    // Show Labels Toggle
    bindToggle('cfg-toggle-labels', APPEARANCE_STATE.showLabels, (active) => {
        APPEARANCE_STATE.showLabels = active;
        if (Graph) Graph.nodeLabel(node => active ? (node.name || node.id) : null);
    });

    // Highlight Selected Toggle
    bindToggle('cfg-toggle-highlight', APPEARANCE_STATE.highlightSelected, (active) => {
        APPEARANCE_STATE.highlightSelected = active;
        if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();
    });

    // Pulse Animation Toggle
    bindToggle('cfg-toggle-pulse', false, (active) => {
        APPEARANCE_STATE.pulseAnimation = active;
        console.log('[CONFIG] Pulse animation:', active ? 'ON' : 'OFF');
    });

    // 3D Depth Shading Toggle
    bindToggle('cfg-toggle-depth', true, (active) => {
        APPEARANCE_STATE.depthShading = active;
        console.log('[CONFIG] Depth shading:', active ? 'ON' : 'OFF');
    });

    // ═══════════════════════════════════════════════════════════════════
    // EDGE CONFIG - Enhanced with better visibility and flow animation
    // ═══════════════════════════════════════════════════════════════════

    // Edge Style Selector
    const edgeCfg = document.getElementById('section-edge-config');
    if (edgeCfg) {
        bindButtonGroup(edgeCfg, 'data-edge-style', (style) => {
            APPEARANCE_STATE.edgeStyle = style;
            applyEdgeStyle(style);
            console.log('[CONFIG] Edge style:', style);
        });
    }

    // Edge Opacity - ENHANCED: Higher default for visibility
    bindSlider('cfg-edge-opacity', 'cfg-edge-opacity-val', (val) => {
        APPEARANCE_STATE.edgeOpacity = val;
        // Use applyEdgeMode to ensure consistent function-based opacity
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Width - ENHANCED: Thicker default
    bindSlider('cfg-edge-width', 'cfg-edge-width-val', (val) => {
        APPEARANCE_STATE.edgeWidth = val;
        // Use applyEdgeMode to ensure consistent function-based width
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Curvature - Direct Graph API (not handled by EDGE module)
    bindSlider('cfg-edge-curve', 'cfg-edge-curve-val', (val) => {
        APPEARANCE_STATE.edgeCurvature = val;
        if (Graph) Graph.linkCurvature(val);
    });

    // Particle Speed - For FLOW visualization
    bindSlider('cfg-particle-speed', 'cfg-particle-speed-val', (val) => {
        APPEARANCE_STATE.particleSpeed = val;
        if (Graph) Graph.linkDirectionalParticleSpeed(val);
    }, 3);

    // Particle Density - For FLOW visualization
    bindSlider('cfg-particle-count', 'cfg-particle-count-val', (val) => {
        APPEARANCE_STATE.particleCount = Math.round(val);
        if (Graph) Graph.linkDirectionalParticles(Math.round(val));
    }, 0);

    // NOTE: Toggle bindings moved to sidebar.js (_bindAppearanceControls)
    // Keeping only initial state sync here
    const arrowToggle = document.getElementById('cfg-toggle-arrows');
    if (arrowToggle && APPEARANCE_STATE.showArrows) arrowToggle.classList.add('active');

    const gradientToggle = document.getElementById('cfg-toggle-gradient');
    if (gradientToggle && APPEARANCE_STATE.gradientEdges) gradientToggle.classList.add('active');

    // Highlight Edges on Hover Toggle
    bindToggle('cfg-toggle-edge-hover', true, (active) => {
        APPEARANCE_STATE.edgeHoverHighlight = active;
    });

    // ═══════════════════════════════════════════════════════════════════
    // Section Collapse Handlers
    // ═══════════════════════════════════════════════════════════════════
    document.querySelectorAll('.section-header[data-section]').forEach(header => {
        header.addEventListener('click', () => {
            const sectionId = header.dataset.section;
            const content = document.getElementById(`section-${sectionId}`);
            if (!content) return;
            const isCollapsed = header.classList.toggle('collapsed');
            content.classList.toggle('collapsed', isCollapsed);
        });
    });

    console.log('[CONFIG] Node & Edge config controls initialized');
}

// applyNodeSizeMode - MOVED TO modules/node-helpers.js

/**
 * Apply edge style - controls edge rendering mode
 */
function applyEdgeStyle(style) {
    if (!Graph) return;
    const opacity = APPEARANCE_STATE.edgeOpacity || 0.4;
    const speed = APPEARANCE_STATE.particleSpeed || 0.01;
    const count = APPEARANCE_STATE.particleCount || 0;

    switch (style) {
        case 'solid':
            Graph.linkLineDash(null);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'dashed':
            Graph.linkLineDash([4, 4]);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'particle':
            // Particle mode: dim lines, bright particles for flow effect
            Graph.linkLineDash(null);
            Graph.linkOpacity(Math.max(0.1, opacity * 0.3));
            Graph.linkDirectionalParticles(Math.max(4, count));
            Graph.linkDirectionalParticleSpeed(speed);
            Graph.linkDirectionalParticleWidth(3);
            Graph.linkDirectionalParticleColor(link => {
                // Use source node color for particles
                if (link.source && typeof link.source === 'object') {
                    return link.source.__threeObj?.material?.color?.getStyle() || '#00d4ff';
                }
                return '#00d4ff';
            });
            break;
    }
}

// UIManager - provided by ui-manager.js module (window.UI_MANAGER, window.UIManager)

function refreshGraph() {
    if (!DM || !Graph) return;  // ALL DATA FROM DM

    // LAYOUT STABILITY: Save current positions before any graph update
    saveNodePositions();

    if (GRAPH_MODE === 'files') {
        if (!FILE_GRAPH) {
            FILE_GRAPH = buildFileGraph(null);  // Uses DM internally
        }
        restoreNodePositions(FILE_GRAPH.nodes);
        Graph.graphData(FILE_GRAPH);
        applyFileColors(FILE_GRAPH.nodes);
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel('name');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    if (GRAPH_MODE === 'hybrid') {
        const hybrid = buildHybridGraph(null);  // Uses DM internally
        restoreNodePositions(hybrid.nodes);
        Graph.graphData(hybrid);
        applyFileColors(hybrid.nodes);
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    const subset = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);  // Uses DM internally
    if (ACTIVE_DATAMAPS.size > 0 && subset.nodes.length === 0) {
        showToast('No nodes for that datamap selection.');
        ACTIVE_DATAMAPS.clear();
        const fallback = filterGraph(null, CURRENT_DENSITY, new Set(), VIS_FILTERS);  // Uses DM internally
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        // Force re-evaluation of accessors
        Graph.nodeColor(Graph.nodeColor());
        Graph.nodeRelSize(Graph.nodeRelSize());
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        if (fileMode && GRAPH_MODE === 'atoms') {
            applyFileVizMode();
        }
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    // Zero-node protection for VIS_FILTERS (tier/ring/family/role)
    const hasActiveFilters = VIS_FILTERS.tiers.size > 0 || VIS_FILTERS.rings.size > 0 ||
        VIS_FILTERS.families.size > 0 || VIS_FILTERS.roles.size > 0;
    if (subset.nodes.length === 0 && hasActiveFilters) {
        showToast('No nodes match current filters. Clearing filters.');
        clearAllFilters();
        const fallback = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    applyNodeColors(subset.nodes);
    restoreNodePositions(subset.nodes);
    Graph.graphData(subset);
    Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
    Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
    applyEdgeMode();
    if (fileMode && GRAPH_MODE === 'atoms') {
        applyFileVizMode();
    }
    updateDatamapControls();
    syncSelectionAfterGraphUpdate();
    if (LAYOUT_FROZEN) freezeLayout();
}

// ═══════════════════════════════════════════════════════════════════════
// THEORY CONSTANTS - MOVED TO modules/theory.js
// ═══════════════════════════════════════════════════════════════════════
// SCALE_16_LEVELS, THREE_LAYERS, SMC_THEORY, LEVEL_ZONES, VIS_PRESETS
// Now provided by THEORY module with backward-compat shims

// Tooltip state - shared with modules/tooltips.js
const TOOLTIP_STATE = { visible: false, currentKey: null, element: null, hideTimeout: null };

// initTooltips, showTopoTooltip, hideTopoTooltip - MOVED TO modules/tooltips.js

// ═══════════════════════════════════════════════════════════════════════
// getTopoColor - MOVED TO modules/color-helpers.js

// ═══════════════════════════════════════════════════════════════════════
// LAYOUT PRESETS - MOVED TO modules/animation.js
// ═══════════════════════════════════════════════════════════════════════
// LAYOUT_PRESETS, STAGGER_PATTERNS, CURRENT_LAYOUT, LAYOUT_ANIMATION_ID,
// LAYOUT_TIME, CURRENT_STAGGER_PATTERN, applyLayoutPreset, cycleStaggerPattern,
// startLayoutMotion, startFlockSimulation, groupNodesByTier
// All now provided by ANIM module with O(n) spatial hashing (fixes ARCH-002)








// Count nodes by tier and family







// Hermite basis functions for C¹ continuous color interpolation




// ═══════════════════════════════════════════════════════════════









// OKLCH-inspired colors (converted to linear RGB for Three.js)
// Chaos (bottom): OKLCH(0.25, 0.12, 240) ≈ deep cosmic blue




// ═══════════════════════════════════════════════════════════════


























// clearAllFilters - MOVED TO modules/visibility.js







// collectCounts, buildCheckboxRow, buildFilterGroup - MOVED TO modules/ui-builders.js
// resolveDefaults - MOVED TO modules/utils.js
// normalizeDatamapConfig, resolveDatamapConfigs, datamapMatches - MOVED TO modules/datamap.js
// buildDatamapToggle, buildExclusiveOptions - MOVED TO modules/ui-builders.js

// ═══════════════════════════════════════════════════════════════════════════
// APPEARANCE SLIDERS - Orchestration layer (uses UI_BUILDERS for pure UI)
// This function owns the business logic: what sliders exist, their values,
// and what happens when they change. UI_BUILDERS.buildAppearanceSliders
// handles the DOM creation.
// ═══════════════════════════════════════════════════════════════════════════

function buildAppearanceSliders(containerId, sliderConfigs) {

    const resolveSlider = (key, fallback) => {
        const config = (sliderConfigs && sliderConfigs[key]) ? sliderConfigs[key] : {};
        return {
            label: config.label || fallback.label,
            min: (config.min !== undefined) ? config.min : fallback.min,
            max: (config.max !== undefined) ? config.max : fallback.max,
            step: (config.step !== undefined) ? config.step : fallback.step,
            default: (config.default !== undefined) ? config.default : fallback.value
        };
    };

    const sliderDefs = [
        (() => {
            const config = resolveSlider('edgeOpacity', {
                label: 'EDGE OPACITY',
                min: 0.02,
                max: 0.4,
                step: 0.01,
                value: EDGE_DEFAULT_OPACITY
            });
            return {
                id: 'edge-opacity',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.edgeOpacity ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.edgeOpacity = val;
                    applyEdgeMode();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('nodeScale', {
                label: 'NODE SCALE',
                min: 0.6,
                max: 2.5,
                step: 0.1,
                value: 1
            });
            return {
                id: 'node-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.nodeScale ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.nodeScale = val;
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('backgroundBrightness', {
                label: 'BACKGROUND',
                min: 0,
                max: 1,
                step: 0.05,
                value: 1
            });
            return {
                id: 'bg-brightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.backgroundBrightness ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.backgroundBrightness = val;
                    updateBackgroundBrightness();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('fileLightness', {
                label: 'FILE LIGHT',
                min: 20,
                max: 80,
                step: 1,
                value: 50
            });
            return {
                id: 'file-lightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.fileLightness ?? config.default,
                onChange: (val) => {
                    FILE_COLOR_CONFIG.lightness = val;
                    APPEARANCE_STATE.fileLightness = val;
                    if (fileMode) {
                        applyFileVizMode();
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hueShift', {
                label: 'HUE SHIFT',
                min: -180,
                max: 180,
                step: 1,
                value: 0
            });
            return {
                id: 'hue-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.hueShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.hueShift = val;
                    Color.setTransform('hueShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('chromaScale', {
                label: 'CHROMA SCALE',
                min: 0,
                max: 2,
                step: 0.05,
                value: 1
            });
            return {
                id: 'chroma-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.chromaScale ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.chromaScale = val;
                    Color.setTransform('chromaScale', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('lightnessShift', {
                label: 'LIGHT SHIFT',
                min: -20,
                max: 20,
                step: 1,
                value: 0
            });
            return {
                id: 'lightness-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.lightnessShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.lightnessShift = val;
                    Color.setTransform('lightnessShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('boundaryOpacity', {
                label: 'HULL OPACITY',
                min: 0.02,
                max: 0.25,
                step: 0.01,
                value: 0.1
            });
            return {
                id: 'boundary-fill',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryFill ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryFill = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hullWireOpacity', {
                label: 'HULL WIRE',
                min: 0.05,
                max: 0.6,
                step: 0.02,
                value: 0.35
            });
            return {
                id: 'boundary-wire',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryWire ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryWire = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('clusterStrength', {
                label: 'CLUSTER FORCE',
                min: 0,
                max: 1,
                step: 0.1,
                value: 0.45
            });
            return {
                id: 'cluster-strength',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.clusterStrength ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.clusterStrength = val;
                    if (fileMode && fileVizMode === 'cluster') {
                        applyClusterForce(null);  // Uses DM internally
                    }
                }
            };
        })(),
        // ═══════════════════════════════════════════════════════════
        // AMPLIFIER SLIDER - Power law exponent for visual contrast
        // γ=1 linear, γ>1 amplifies small differences, γ<1 compresses
        // Formula: amplified = value^(1/γ)
        // ═══════════════════════════════════════════════════════════
        (() => {
            const config = resolveSlider('amplifier', {
                label: 'AMPLIFIER (γ)',
                min: 0.3,
                max: 5.0,
                step: 0.1,
                value: 1.0
            });
            return {
                id: 'amplifier',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.amplifier ?? config.default,
                className: 'meta-amplifier',  // Special styling for meta-slider
                description: 'γ>1 amplifies differences, γ<1 compresses',
                onChange: (val) => {
                    APPEARANCE_STATE.amplifier = val;
                    // Re-apply edge mode to update widths with new amplification
                    applyEdgeMode();
                    // If in flow mode, re-apply flow visualization
                    if (flowMode) {
                        applyFlowVisualization();
                    }
                }
            };
        })()
    ];

    // Use UI_BUILDERS for pure DOM creation (decoupled architecture)
    // Each sliderDef has its own onChange handler - business logic stays here
    UI_BUILDERS.buildAppearanceSliders(containerId, sliderDefs);
}

// ═══════════════════════════════════════════════════════════════════════
// PHYSICS CONTROLS - Real-time force simulation adjustment
// ═══════════════════════════════════════════════════════════════════════
const PHYSICS_STATE = {
    charge: -120,
    linkDistance: 50,
    centerStrength: 0.05,
    velocityDecay: 0.4
};

const PHYSICS_PRESETS = {
    default: { charge: -120, linkDistance: 50, centerStrength: 0.05, velocityDecay: 0.4, label: 'DEFAULT' },
    tight: { charge: -80, linkDistance: 30, centerStrength: 0.1, velocityDecay: 0.5, label: 'TIGHT' },
    loose: { charge: -200, linkDistance: 80, centerStrength: 0.02, velocityDecay: 0.3, label: 'LOOSE' },
    explosive: { charge: -400, linkDistance: 120, centerStrength: 0.01, velocityDecay: 0.2, label: 'EXPLOSIVE' }
};

// applyPhysicsState, applyPhysicsPreset, updatePhysicsSliders, buildPhysicsControls - MOVED TO modules/physics.js

// updateBackgroundBrightness, applyMetadataVisibility - MOVED TO modules/visibility.js

// Deprecated setupSidebar - replaced by UIManager
// Deprecated buildDatamapControls - replaced by UIManager


// ═══════════════════════════════════════════════════════════════
// PRESET BUTTONS - Quick visualization mode selection (Tier, Family, etc.)
// Uses VIS_STATE for unified state management
// ═══════════════════════════════════════════════════════════════
const presetGrid = document.getElementById('dock-presets');
const presetBtnGrid = document.getElementById('preset-grid');
if (presetBtnGrid) {
    presetBtnGrid.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const presetKey = btn.dataset.preset;

            // Use VIS_STATE for unified state management
            if (typeof VIS_STATE !== 'undefined') {
                VIS_STATE.applyPreset(presetKey);
                return;
            }

            // Fallback for when VIS_STATE not loaded
            const preset = VIS_PRESETS[presetKey];
            if (!preset) return;

            presetBtnGrid.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            APPEARANCE_STATE.currentPreset = presetKey;
            APPEARANCE_STATE.colorMode = preset.colorBy;

            setNodeColorMode(preset.colorBy);

            const edgeModes = { 'type': 'gradient-tier', 'weight': 'weight', 'resolution': 'gradient-file' };
            EDGE_MODE = edgeModes[preset.edgeBy] || preset.edgeBy || 'gradient-tier';
            applyEdgeMode();

            if (presetKey === 'flow') {
                if (!flowMode && typeof toggleFlowMode === 'function') toggleFlowMode();
            } else if (flowMode && typeof disableFlowMode === 'function') {
                disableFlowMode();
            }

            if (typeof window.refreshGradientEdgeColors === 'function') {
                window.refreshGradientEdgeColors();
            }

            if (typeof renderAllLegends === 'function') {
                renderAllLegends();
            }

            console.log('[Preset] Applied:', preset.name, '| colorBy:', preset.colorBy, '| edgeBy:', preset.edgeBy);
        });
    });
}

// ═══════════════════════════════════════════════════════════════
// NOTE: Color scheme buttons are now handled by sidebar.js via SIDEBAR.initSchemeNavigator()
// The 33 named schemes (viridis, plasma, thermal, etc.) are defined in color-engine.js schemePaths
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// LAYOUT BUTTONS - Graph layout presets with perpetual motion
// ═══════════════════════════════════════════════════════════════
const layoutGrid = document.getElementById('layout-grid');
if (layoutGrid) {
    layoutGrid.querySelectorAll('.layout-btn').forEach(btn => {
        const layoutKey = btn.dataset.layout;
        // Assign ID if missing for Registry
        if (!btn.id) btn.id = `layout-btn-${layoutKey}`;

        REGISTRY.register(btn.id, () => {
            if (!layoutKey || !LAYOUT_PRESETS[layoutKey]) return;

            // Update active state
            layoutGrid.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Apply the layout
            applyLayoutPreset(layoutKey, true);

            console.log('[Layout] Applied:', LAYOUT_PRESETS[layoutKey].name);
        }, { desc: `Activate ${layoutKey} layout` });
    });
}

// VIEW section controls
buildExclusiveOptions('filter-node-color', [
    { label: 'TIER', value: 'tier' },
    { label: 'RING', value: 'ring' },
    { label: 'FAMILY', value: 'family' },
    { label: 'LAYER', value: 'layer' },
    { label: 'FILE', value: 'file' },
    { label: 'ATOM', value: 'atom' },
    { label: 'COMPLEXITY', value: 'complexity' },
    { label: 'CHURN', value: 'churn' }
], NODE_COLOR_MODE, setNodeColorMode);
buildExclusiveOptions('filter-edge-mode', [
    { label: 'GRAD-FILE', value: 'gradient-file' },
    { label: 'GRAD-TIER', value: 'gradient-tier' },
    { label: 'GRAD-FLOW', value: 'gradient-flow' },
    { label: 'TYPE', value: 'type' },
    { label: 'WEIGHT', value: 'weight' },
    { label: 'MONO', value: 'mono' }
], EDGE_MODE, setEdgeMode);
buildMetadataControls('filter-metadata', VIS_FILTERS.metadata);
buildAppearanceSliders('appearance-sliders', {}); // controlsConfig removed - sliders built dynamically
buildPhysicsControls('physics-sliders');  // Physics/forces controls

applyMetadataVisibility();
updateBackgroundBrightness();
refreshGraph();

// setupCollapsibleSections - MOVED TO modules/visibility.js

// setupReport, setupAIInsights, setupMetrics - MOVED TO modules/report.js

// escapeHtml - MOVED TO modules/utils.js

// setupHudFade, updateHudStats - MOVED TO modules/hud.js

// showToast - MOVED TO modules/tooltips.js
// updateDatamapControls - MOVED TO modules/datamap.js

// toggleDimensions, setupDimensionToggle, animateDimensionChange - MOVED TO modules/dimension.js

// stableSeed, stableZ - MOVED TO modules/utils.js

// ====================================================================
// EDGE VISUALIZATION MODES - GRADIENT & DATA-DRIVEN SYSTEM
// ====================================================================
// NEW: Edge modes with gradients showing data progression & regions
const EDGE_MODE_ORDER = [
    'gradient-tier',      // Source→Target tier flow (architecture layers)
    'gradient-file',      // File boundaries (module regions)
    'gradient-flow',      // Markov probability (hot paths)
    'gradient-depth',     // Call depth progression
    'gradient-semantic',  // Semantic distance (type similarity)
    'type',               // Classic type-based
    'weight',             // Weight intensity
    'mono'                // Minimal monochrome
];
const EDGE_MODE_LABELS = {
    'gradient-tier': '▼ TIER FLOW',
    'gradient-file': '▼ FILE REGIONS',
    'gradient-flow': '▼ HOT PATHS',
    'gradient-depth': '▼ CALL DEPTH',
    'gradient-semantic': '▼ SEMANTIC',
    type: 'EDGE: TYPE',
    weight: 'EDGE: WEIGHT',
    mono: 'EDGE: MONO'
};
const EDGE_MODE_HINTS = {
    'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
    'gradient-file': 'Color by file region - shows module boundaries',
    'gradient-flow': 'Hot paths - markov probability gradient',
    'gradient-depth': 'Color by call chain depth',
    'gradient-semantic': 'Color by semantic similarity of endpoints',
    type: 'Edge color by type (calls, imports, etc.)',
    weight: 'Edge width & color by weight',
    mono: 'Minimal monochrome'
};

// Gradient color palettes for different modes
const GRADIENT_PALETTES = {
    tier: {
        // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
        T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
        T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
        T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
        UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
    },
    file: {
        // Rainbow hues distributed across files
        saturation: 65,
        lightness: 48
    },
    flow: {
        // Cold (low prob) to Hot (high prob)
        cold: { h: 220, s: 60, l: 45 },   // Blue
        warm: { h: 45, s: 85, l: 50 },    // Yellow
        hot: { h: 0, s: 90, l: 55 }       // Red
    },
    depth: {
        // Shallow (bright) to Deep (dark, saturated)
        shallow: { h: 180, s: 50, l: 65 },  // Light cyan
        mid: { h: 260, s: 70, l: 50 },      // Purple
        deep: { h: 320, s: 80, l: 40 }      // Magenta
    },
    semantic: {
        // Similar (harmonious) to Different (contrasting)
        similar: { h: 150, s: 60, l: 50 },    // Green - same type
        related: { h: 200, s: 65, l: 48 },    // Cyan - related
        different: { h: 340, s: 75, l: 50 }   // Pink - different
    }
};

// FILE_HUE_MAP, buildFileHueMap - provided by edge-system.js module

// Get node tier value (0=T0, 1=T1, 2=T2)
// getNodeTierValue, getNodeDepth, getSemanticSimilarity - MOVED TO modules/node-helpers.js

// interpolateColor, applyColorTweaks, oklchToSrgb, oklchColor - MOVED TO modules/color-engine.js
// Use COLOR.interpolate() and COLOR.get() instead

// getGradientEdgeColor - MOVED TO modules/edge-system.js
// clamp01, clampValue - MOVED TO modules/utils.js
// hslColor REMOVED - Using OKLCH Native via Color.interpolate
// parseOklchString - MOVED TO modules/utils.js
// normalizeColorInput, toColorNumber - MOVED TO modules/color-helpers.js

// updateEdgeRanges, refreshNodeFileIndex, getLinkFileIdx - MOVED TO modules/edge-system.js
// (shims delegate to EDGE.updateRanges, EDGE.refreshNodeFileIndex; getLinkFileIdx is internal)

// normalizeMetric - MOVED TO modules/utils.js
// getEdgeColor, getEdgeWidth, applyEdgeMode, cycleEdgeMode, setEdgeMode - MOVED TO modules/edge-system.js
// (backward compat shims in edge-system.js)

// Datamap toggles are wired in buildDatamapControls().
const btnReport = document.getElementById('btn-report');
if (btnReport) {
    btnReport.onclick = () => {
        const panel = document.getElementById('report-panel');
        const btn = document.getElementById('btn-report');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// AI INSIGHTS PANEL TOGGLE
const btnInsights = document.getElementById('btn-insights');
if (btnInsights) {
    btnInsights.onclick = () => {
        const panel = document.getElementById('insights-panel');
        const btn = document.getElementById('btn-insights');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// setStarsVisible, STARS_STORAGE_KEY, stars toggle binding - MOVED TO modules/stars.js
// Call STARS.init() to initialize (done in modules/main.js)

// Reset Layout button - explicitly re-run physics
const btnResetLayout = document.getElementById('btn-reset-layout');
if (btnResetLayout) {
    btnResetLayout.onclick = () => resetLayout();
}

// Hints toggle - enable/disable mode toasts
const btnHints = document.getElementById('btn-hints');
if (btnHints) {
    btnHints.onclick = () => {
        HINTS_ENABLED = !HINTS_ENABLED;
        btnHints.classList.toggle('active', HINTS_ENABLED);
        if (HINTS_ENABLED) {
            showModeToast('Hints enabled');
        }
    };
}

const btnEdgeMode = document.getElementById('btn-edge-mode');
if (btnEdgeMode) {
    btnEdgeMode.onclick = () => cycleEdgeMode();
}

// ====================================================================
// FLOW MODE: Markov Chain Visualization (Token-Driven)
// ====================================================================
// flowMode hoisted to top
let originalLinkWidths = new Map();
let highEntropyNodes = new Set();
// FLOW_CONFIG is set in initGraph() from THE REMOTE CONTROL tokens

// getFlowPresetColor, getFlowPresetValue - MOVED TO modules/flow.js

// FLOW_PRESETS, currentFlowPreset - MOVED TO modules/flow.js

// toggleFlowMode, disableFlowMode, applyFlowVisualization, clearFlowVisualization - MOVED TO modules/flow.js

// setDatamap, setNodeColorMode, applyDatamap - MOVED TO modules/datamap.js

// ====================================================================
// FILE BOUNDARIES & HOVER SYSTEM
// ====================================================================
// NOTE: fileBoundaryMeshes, fileMode, fileVizMode, etc. declared at top of file

// hashToUnit - MOVED TO modules/utils.js
// getFileHue, getFileColor - MOVED TO modules/color-helpers.js
// updateHoverPanel, handleNodeHover, handleNodeClick - MOVED TO modules/hover.js
// buildDatasetKey - MOVED TO modules/utils.js
// loadGroups, saveGroups, getNextGroupColor, getGroupById, getPrimaryGroupForNode - MOVED TO modules/groups.js
// renderGroupList, updateGroupButtonState, createGroupFromSelection - MOVED TO modules/groups.js

// getSelectedNodes, setSelection, toggleSelection, clearSelection, maybeClearSelection - MOVED TO modules/selection.js
// Use SELECT.getSelectedNodes(), SELECT.set(), SELECT.toggle(), SELECT.clear(), SELECT.maybeClear()
// Shims in selection.js provide global function names for backward compatibility


function handleNodeHover(node, data) {
    const filePanel = document.getElementById('file-panel');
    HOVERED_NODE = node || null;

    // Always update hover panel (separate from file panel)
    updateHoverPanel(node);

    // Guard: file-panel may not exist in minimal template
    if (!filePanel) return;

    if (!VIS_FILTERS.metadata.showFilePanel) {
        filePanel.classList.remove('visible');
        return;
    }

    if (!node) {
        // Mouse left node - hide panel after delay
        setTimeout(() => {
            if (!fileMode) filePanel.classList.remove('visible');
        }, 300);
        return;
    }

    // Get file info from boundaries
    const boundaries = data.file_boundaries || [];
    const fileIdx = node.fileIdx;

    if (fileIdx < 0 || fileIdx >= boundaries.length) {
        return;
    }

    const fileInfo = boundaries[fileIdx];

    // Update panel content (with null checks for minimal template)
    const setEl = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.textContent = val;
    };
    setEl('file-name', fileInfo.file_name || 'unknown');
    setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
    setEl('file-purpose', fileInfo.purpose || '--');
    setEl('file-atom-count', fileInfo.atom_count || 0);
    setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
    setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
    setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

    // Show code preview from node body
    const code = node.body || '// no source available';
    setEl('file-code', code);

    // Show panel and trigger smart placement
    filePanel.classList.add('visible');
    HudLayoutManager.reflow();
}

function handleNodeClick(node, event) {
    if (!node) return;
    const additive = event && event.shiftKey;
    if (additive) {
        toggleSelection(node);
        return;
    }
    if (node.id) {
        setSelection([node.id]);
    }
    if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
        toggleFileExpand(node.fileIdx);
    }
}


// ====================================================================
// FILE MODE HANDLERS
// ====================================================================

// setFileModeState - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setEnabled)

const btnFiles = document.getElementById('btn-files');
if (btnFiles) btnFiles.onclick = () => setFileModeState(!fileMode);

// COLOR mode - atoms colored by file
const btnFileColor = document.getElementById('btn-file-color');
if (btnFileColor) btnFileColor.onclick = () => setFileVizMode('color');

// HULLS mode - draw boundary spheres
const btnFileHulls = document.getElementById('btn-file-hulls');
if (btnFileHulls) btnFileHulls.onclick = () => setFileVizMode('hulls');

// CLUSTER mode - force clustering by file
const btnFileCluster = document.getElementById('btn-file-cluster');
if (btnFileCluster) btnFileCluster.onclick = () => setFileVizMode('cluster');

// MAP mode - show file nodes
const btnFileMap = document.getElementById('btn-file-map');
if (btnFileMap) btnFileMap.onclick = () => setFileVizMode('map');

// SPHERES mode - show containment spheres (button may be hidden)
const spheresBtn = document.getElementById('btn-file-spheres');
if (spheresBtn) spheresBtn.onclick = () => setFileVizMode('spheres');

// POP button - toggle boundary pop/restore (button may be hidden)
const popBtn = document.getElementById('btn-file-pop');
if (popBtn) {
    popBtn.onclick = () => {
        if (!FILE_CONTAINMENT.boundariesPopped) {
            popBoundaries(3000);
            popBtn.classList.add('active');
            popBtn.textContent = 'RESTORE';
            showToast('Boundaries popped! Particles in slow-motion chaos...');
        } else {
            restoreBoundaries(2000);
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
            showToast('Boundaries restored. Order from chaos.');
        }
    };
}

// Expand mode toggles (only relevant in MAP mode)
const btnExpandInline = document.getElementById('btn-expand-inline');
if (btnExpandInline) {
    btnExpandInline.onclick = () => {
        FILE_EXPAND_MODE = 'inline';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}

const btnExpandDetach = document.getElementById('btn-expand-detach');
if (btnExpandDetach) {
    btnExpandDetach.onclick = () => {
        FILE_EXPAND_MODE = 'detach';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}


// setFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setMode)

// applyFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.apply)

// scheduleHullRedraw - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.scheduleHullRedraw)

// applyFileColors - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.applyColors)

// clearFileBoundaries - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearBoundaries)

// Moved here to avoid temporal dead zone issue
let fileCohesionActive = false;

// clearAllFileModes - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearAllModes)

// applyClusterForce, applyFileCohesion, clearFileCohesion - MOVED TO modules/file-viz.js

// ════════════════════════════════════════════════════════════════════════
// SURFACE PARITY HANDLERS - Architectural Enforcements
// ════════════════════════════════════════════════════════════════════════

// Panel Handlers - use togglePanel('view') etc. or PANELS.toggle('view')
// togglePanelView/Filter/Style/Settings - simplified via modules/panels.js


// Action Handlers
function handleCmdFlow() { toggleFlowMode(); }
function handleCmd3d() { toggleDimensions(); }

// PanelManager - provided by panels.js module (window.PANEL_DRAG, window.PanelManager)

// =================================================================
// THEME SWITCHING - MOVED TO modules/theme.js
// setTheme, getTheme, getAvailableThemes, cycleTheme, initTheme

// Initialize theme on DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        // Small delay to ensure CSS vars are loaded
        setTimeout(initTheme, 50);
    });
} else {
    setTimeout(initTheme, 50);
}

// Expose theme functions globally
window.setTheme = setTheme;
window.getTheme = getTheme;
window.getAvailableThemes = getAvailableThemes;
window.cycleTheme = cycleTheme;
window.THEME_CONFIG = THEME_CONFIG;

// Expose filtering/graph globals for module access
window.VIS_FILTERS = VIS_FILTERS;
window.refreshGraph = refreshGraph;

    </script>
</body>

</html>