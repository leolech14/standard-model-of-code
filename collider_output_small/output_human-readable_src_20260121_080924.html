<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Collider v4.0.0</title>
    <style>
        /* ═══════════════════════════════════════════════════════════════════
           COLLIDER UI - Dual Sidebar Layout
           ═══════════════════════════════════════════════════════════════════ */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --surface: rgba(15, 15, 22, 0.85);
            --surface-hover: rgba(25, 25, 35, 0.9);
            --border: rgba(255, 255, 255, 0.08);
            --border-accent: rgba(74, 158, 255, 0.3);
            --text: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.5);
            --text-muted: rgba(255, 255, 255, 0.3);
            --accent: #4a9eff;
            --accent-dim: rgba(74, 158, 255, 0.15);
            --accent-glow: rgba(74, 158, 255, 0.25);
            --green: #5a9a70;
            --yellow: #a09060;
            --red: #b07070;
            --cyan: #7090a0;
            --sidebar-width: 300px;
            --right-panel-width: 280px;
            --min-sidebar-width: 240px;
            --max-sidebar-width: 500px;
            --header-height: 48px;
            --radius: 8px;
            --radius-sm: 4px;
            --glass: blur(12px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            font-size: 12px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LOADER
           ═══════════════════════════════════════════════════════════════════ */
        #loader {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 9999;
            font-size: 14px;
            letter-spacing: 2px;
        }

        #loader-status {
            font-size: 11px;
            opacity: 0.5;
        }

        /* ═══════════════════════════════════════════════════════════════════
           HEADER - Top bar spanning full width
           ═══════════════════════════════════════════════════════════════════ */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 24px;
            z-index: 200;
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 1px;
            color: var(--accent);
        }

        .logo span {
            opacity: 0.5;
            font-size: 10px;
            margin-left: 6px;
            color: var(--text);
        }

        .header-stats {
            display: flex;
            gap: 20px;
            font-size: 11px;
        }

        .stat {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .stat-label {
            opacity: 0.4;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            color: var(--cyan);
        }

        .target-name {
            margin-left: auto;
            font-size: 11px;
            opacity: 0.5;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ═══════════════════════════════════════════════════════════════════
           MAIN LAYOUT - Graph container
           ═══════════════════════════════════════════════════════════════════ */
        #3d-graph {
            position: fixed;
            top: var(--header-height);
            left: var(--sidebar-width);
            right: var(--right-panel-width);
            bottom: 0;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LEFT SIDEBAR - Controls & Filters
           ═══════════════════════════════════════════════════════════════════ */
        #left-sidebar {
            position: fixed;
            top: var(--header-height);
            left: 0;
            bottom: 0;
            width: var(--sidebar-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
        }

        #left-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #left-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #left-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           RIGHT SIDEBAR - Info Panels
           ═══════════════════════════════════════════════════════════════════ */
        #right-sidebar {
            position: fixed;
            top: var(--header-height);
            right: 0;
            bottom: 0;
            width: var(--right-panel-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #right-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #right-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #right-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SIDEBAR RESIZE DIVIDERS - Horizontal drag handles
           ═══════════════════════════════════════════════════════════════════ */
        .sidebar-resize-handle {
            position: fixed;
            top: var(--header-height);
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 101;
            background: transparent;
            transition: background 0.15s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.25);
        }

        .sidebar-resize-handle.left {
            left: calc(var(--sidebar-width) - 3px);
        }

        .sidebar-resize-handle.right {
            right: calc(var(--right-panel-width) - 3px);
        }

        /* Visual indicator line */
        .sidebar-resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 40px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .sidebar-resize-handle:hover::after {
            opacity: 1;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION - Collapsible sections
           ═══════════════════════════════════════════════════════════════════ */
        .section {
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            padding: 12px 14px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.15s;
        }

        .section-header:hover {
            opacity: 0.9;
            background: var(--surface-hover);
        }

        .section-header .arrow {
            transition: transform 0.2s;
            font-size: 8px;
        }

        .section-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        /* PRIME SECTIONS - Highlighted config sections (muted) */
        .section.prime {
            background: linear-gradient(180deg, rgba(100, 110, 130, 0.03) 0%, transparent 100%);
            border-left: 2px solid rgba(100, 110, 130, 0.3);
        }

        .section.prime .section-header {
            opacity: 0.75;
            color: var(--text-secondary);
        }

        .section.prime .section-header:hover {
            opacity: 0.9;
        }

        .section-content {
            padding: 8px 14px 14px;
            overflow-y: auto;
            transition: max-height 0.2s ease;
        }

        .section-content.collapsed {
            display: none;
        }

        /* RESIZABLE SECTIONS - Vertical drag handles */
        .section-resize-handle {
            height: 4px;
            cursor: ns-resize;
            background: transparent;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
            position: relative;
        }

        .section-resize-handle:hover,
        .section-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.2);
        }

        .section-resize-handle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 2px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .section-resize-handle:hover::after {
            opacity: 1;
        }

        /* Section content height constraints when resizing */
        .section-content.resizable {
            min-height: 60px;
            max-height: 400px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           VIEW MODE TOGGLE - ATOMS vs FILES (top of left sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            padding: 8px 10px;
            background: linear-gradient(180deg, rgba(74, 158, 255, 0.08) 0%, rgba(74, 158, 255, 0.02) 100%);
            border-bottom: 2px solid var(--accent);
        }

        .view-mode-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .view-mode-btn:first-child {
            border-radius: var(--radius-sm) 0 0 var(--radius-sm);
            border-right: none;
        }

        .view-mode-btn:last-child {
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        }

        .view-mode-btn:hover {
            background: rgba(74, 158, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        .view-mode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
        }

        .view-mode-icon {
            font-size: 14px;
        }

        .view-mode-label {
            font-size: 10px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════════════
           BUTTON GRID - For presets and actions
           ═══════════════════════════════════════════════════════════════════ */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .btn-grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .btn-grid-4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .btn-grid-6 {
            grid-template-columns: repeat(6, 1fr);
        }

        .btn {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            font-size: 9px;
            font-weight: 500;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: var(--border-accent);
        }

        .btn.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        /* Icon buttons */
        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SLIDERS
           ═══════════════════════════════════════════════════════════════════ */
        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .slider-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .slider-label {
            opacity: 0.6;
        }

        .slider-value {
            display: none;
            /* Replaced by input */
        }

        .number-input {
            width: 48px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--cyan);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 10px;
            padding: 2px 4px;
            text-align: right;
            -moz-appearance: textfield;
        }

        .number-input::-webkit-outer-spin-button,
        .number-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.4);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px var(--accent-glow);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }

        /* ═══════════════════════════════════════════════════════════════════
           FILTER CHIPS
           ═══════════════════════════════════════════════════════════════════ */
        .filter-group {
            margin-bottom: 12px;
        }

        .filter-group:last-child {
            margin-bottom: 0;
        }

        .filter-label {
            font-size: 9px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .chip {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 14px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .chip.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
        }

        .chip .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOGGLE SWITCHES
           ═══════════════════════════════════════════════════════════════════ */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            padding: 6px 0;
        }

        .toggle-row .toggle-label {
            opacity: 0.7;
        }

        .toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text);
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle.active::after {
            transform: translateX(16px);
        }

        /* ═══════════════════════════════════════════════════════════════════
           INFO PANEL - Right sidebar node info
           ═══════════════════════════════════════════════════════════════════ */
        .info-panel {
            padding: 14px;
            border-bottom: 1px solid var(--border);
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .info-panel-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .node-info {
            display: none;
        }

        .node-info.visible {
            display: block;
        }

        .node-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
            word-break: break-all;
            color: var(--cyan);
        }

        .node-kind {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row .label {
            opacity: 0.4;
        }

        .info-row .value {
            text-align: right;
        }

        .node-file {
            font-size: 9px;
            opacity: 0.3;
            margin-top: 10px;
            word-break: break-all;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .placeholder-text {
            font-size: 10px;
            opacity: 0.3;
            text-align: center;
            padding: 20px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SELECTION PANEL
           ═══════════════════════════════════════════════════════════════════ */
        .selection-panel {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
        }

        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .selection-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .selection-count {
            font-size: 9px;
            padding: 2px 8px;
            background: var(--accent-dim);
            border-radius: 10px;
            color: var(--accent);
        }

        .selection-clear {
            font-size: 9px;
            padding: 4px 8px;
            background: none;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            cursor: pointer;
        }

        .selection-clear:hover {
            color: var(--text);
            border-color: var(--text-dim);
        }

        .selection-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .selection-item {
            font-size: 10px;
            padding: 6px 8px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            margin-bottom: 2px;
            background: rgba(255, 255, 255, 0.02);
        }

        .selection-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--accent);
        }

        /* ═══════════════════════════════════════════════════════════════════
           STATS PANEL (bottom of right sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .stats-panel {
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid var(--border);
            margin-top: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stats-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-sm);
        }

        .stats-item .value {
            font-size: 16px;
            font-weight: 600;
            color: var(--cyan);
            font-variant-numeric: tabular-nums;
        }

        .stats-item .label {
            font-size: 8px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           COLOR PANELS (right sidebar color controls)
           ═══════════════════════════════════════════════════════════════════ */
        .color-panel,
        .schemes-panel {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
        }

        .color-panel .section-content,
        .schemes-panel .section-content {
            padding: 0;
            margin-top: 10px;
        }

        .color-panel .btn-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .color-panel .btn {
            padding: 6px 8px;
            font-size: 9px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .color-panel .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .color-panel .btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        /* Collapsible header for schemes panel */
        .info-panel-header.collapsible {
            cursor: pointer;
            user-select: none;
        }

        .info-panel-header.collapsible:hover {
            opacity: 0.9;
        }

        .info-panel-header .collapse-icon {
            font-size: 8px;
            transition: transform 0.2s;
        }

        .info-panel-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .schemes-panel .section-content {
            max-height: 250px;
            overflow-y: auto;
        }

        .schemes-panel .section-content::-webkit-scrollbar {
            width: 4px;
        }

        .schemes-panel .section-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .schemes-panel .section-content.collapsed {
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           PERFORMANCE HUD (optional overlay)
           ═══════════════════════════════════════════════════════════════════ */
        #perf-hud {
            position: fixed;
            top: calc(var(--header-height) + 8px);
            left: calc(var(--sidebar-width) + 8px);
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-family: 'SF Mono', Monaco, monospace;
            z-index: 150;
            display: none;
        }

        #perf-hud.visible {
            display: block;
        }

        .perf-row {
            display: flex;
            gap: 12px;
        }

        .perf-label {
            opacity: 0.5;
        }

        .perf-value {
            font-variant-numeric: tabular-nums;
        }

        .perf-good {
            color: var(--green);
        }

        .perf-warn {
            color: var(--yellow);
        }

        .perf-bad {
            color: var(--red);
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════════════ */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--surface);
            border: 1px solid var(--border-accent);
            padding: 12px 24px;
            border-radius: var(--radius);
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Selection box for drag select */
        #selection-box {
            position: fixed;
            border: 1px solid var(--accent);
            background: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION-SPECIFIC STYLING
           ═══════════════════════════════════════════════════════════════════ */

        /* Color mode buttons with color indicators */
        .color-btn {
            position: relative;
        }

        .color-btn::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .color-btn[data-preset="tier"]::before {
            background: #ff6b6b;
        }

        .color-btn[data-preset="family"]::before {
            background: #4ecdc4;
        }

        .color-btn[data-preset="layer"]::before {
            background: #95e1d3;
        }

        .color-btn[data-preset="ring"]::before {
            background: #f9ed69;
        }

        .color-btn[data-preset="file"]::before {
            background: #a8e6cf;
        }

        .color-btn[data-preset="flow"]::before {
            background: #dcd6f7;
        }

        /* Layout buttons with mini icons */
        .layout-btn {
            height: 32px;
        }
    </style>

    <script>
        window.process = window.process || { env: { NODE_ENV: "production" } };
        window.global = window.global || window;
    </script>
    <!-- THREE.js r149 (last version without deprecation warning) + 3d-force-graph -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
</head>

<body>
    <!-- Loader -->
    <div id="loader">
        <div>INITIALIZING...</div>
        <div id="loader-status">Loading data...</div>
    </div>

    <!-- Header -->
    <div id="header">
        <div class="logo">COLLIDER <span>v4.0.0</span></div>
        <div class="header-stats">
            <div class="stat">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="stat-nodes">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="stat-edges">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Entropy</span>
                <span class="stat-value" id="stat-entropy">--</span>
            </div>
        </div>
        <div class="target-name" id="target-name"></div>
    </div>

    <!-- Left Sidebar -->
    <div id="left-sidebar">
        <!-- VIEW MODE TOGGLE - TOP PRIORITY -->
        <div class="view-mode-toggle" id="view-mode-toggle">
            <button class="view-mode-btn active" data-mode="atoms">
                <span class="view-mode-icon">◉</span>
                <span class="view-mode-label">ATOMS</span>
            </button>
            <button class="view-mode-btn" data-mode="files">
                <span class="view-mode-icon">◫</span>
                <span class="view-mode-label">FILES</span>
            </button>
        </div>

        <!-- MAPPING CONTROL (Docked) -->
        <div class="section prime" id="control-bar-container">
            <!-- Injected by control-bar.js -->
        </div>

        <!-- NODE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="node-config">
                <span>⬢ Node Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-node-config">
                <!-- Size Mode Selector -->
                <div class="filter-group">
                    <div class="filter-label">Size Mode</div>
                    <div class="btn-grid btn-grid-4">
                        <button class="btn active" data-size-mode="uniform">Uniform</button>
                        <button class="btn" data-size-mode="degree">Degree</button>
                        <button class="btn" data-size-mode="fanout">Fanout</button>
                        <button class="btn" data-size-mode="complexity">Complex</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Base Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-size" min="0.2" max="4" step="0.1" value="1">
                        <input type="number" id="cfg-node-size-num" class="number-input" min="0.2" max="4" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-opacity" min="0.1" max="1" step="0.05" value="1">
                        <input type="number" id="cfg-node-opacity-num" class="number-input" min="0.1" max="1"
                            step="0.05" value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Resolution</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-res" min="4" max="32" step="4" value="8">
                        <input type="number" id="cfg-node-res-num" class="number-input" min="4" max="32" step="4"
                            value="8">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Label Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-label-size" min="0" max="3" step="0.1" value="1">
                        <input type="number" id="cfg-label-size-num" class="number-input" min="0" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="cfg-toggle-labels"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight Selected</span>
                    <div class="toggle active" id="cfg-toggle-highlight"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Pulse Animation</span>
                    <div class="toggle" id="cfg-toggle-pulse"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">3D Depth Shading</span>
                    <div class="toggle active" id="cfg-toggle-depth"></div>
                </div>
            </div>
        </div>

        <!-- EDGE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="edge-config">
                <span>⟷ Edge Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-edge-config">
                <!-- Edge Style Selector -->
                <div class="filter-group">
                    <div class="filter-label">Edge Style</div>
                    <div class="btn-grid">
                        <button class="btn active" data-edge-style="solid">Solid</button>
                        <button class="btn" data-edge-style="dashed">Dashed</button>
                        <button class="btn" data-edge-style="particle">Particle</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-opacity" min="0" max="1" step="0.05" value="0.6">
                        <input type="number" id="cfg-edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.6">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Width</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-width" min="0.2" max="5" step="0.2" value="1.5">
                        <input type="number" id="cfg-edge-width-num" class="number-input" min="0.2" max="5" step="0.1"
                            value="1.5">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Curvature</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-curve" min="0" max="1" step="0.05" value="0">
                        <input type="number" id="cfg-edge-curve-num" class="number-input" min="0" max="1" step="0.05"
                            value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Speed</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-speed" min="0" max="0.05" step="0.005" value="0.01">
                        <input type="number" id="cfg-particle-speed-num" class="number-input" min="0" max="0.05"
                            step="0.005" value="0.01">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Density</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-count" min="0" max="10" step="1" value="0">
                        <input type="number" id="cfg-particle-count-num" class="number-input" min="0" max="10" step="1"
                            value="0">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Arrows</span>
                    <div class="toggle" id="cfg-toggle-arrows"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Gradient Colors</span>
                    <div class="toggle active" id="cfg-toggle-gradient"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight on Hover</span>
                    <div class="toggle active" id="cfg-toggle-edge-hover"></div>
                </div>
            </div>
        </div>

        <!-- LAYOUT -->
        <div class="section">
            <div class="section-header" data-section="layout">
                <span>Layout</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-layout">
                <div class="btn-grid">
                    <button class="btn layout-btn active" data-layout="force">Force</button>
                    <button class="btn layout-btn" data-layout="radial">Radial</button>
                    <button class="btn layout-btn" data-layout="orbital">Orbital</button>
                    <button class="btn layout-btn" data-layout="sphere">Sphere</button>
                    <button class="btn layout-btn" data-layout="grid">Grid</button>
                    <button class="btn layout-btn" data-layout="spiral">Spiral</button>
                </div>
            </div>
        </div>

        <!-- PHYSICS -->
        <div class="section">
            <div class="section-header" data-section="physics">
                <span>Physics</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-physics">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Repulsion</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-charge" min="-500" max="0" value="-120">
                        <input type="number" id="physics-charge-num" class="number-input" min="-500" max="0"
                            value="-120">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Link Distance</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-link" min="10" max="200" value="50">
                        <input type="number" id="physics-link-num" class="number-input" min="10" max="200" value="50">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Center Pull</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-center" min="0" max="0.5" step="0.01" value="0.05">
                        <input type="number" id="physics-center-num" class="number-input" min="0" max="0.5" step="0.01"
                            value="0.05">
                    </div>
                </div>
                <div class="btn-grid btn-grid-4" style="margin-top: 8px;">
                    <button class="btn" data-physics="default">Def</button>
                    <button class="btn" data-physics="tight">Tight</button>
                    <button class="btn" data-physics="loose">Loose</button>
                    <button class="btn" data-physics="explosive">Boom</button>
                </div>
            </div>
        </div>

        <!-- APPEARANCE -->
        <div class="section">
            <div class="section-header" data-section="appearance">
                <span>Appearance</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-appearance">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Node Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="node-size" min="0.2" max="3" step="0.1" value="1">
                        <input type="number" id="node-size-num" class="number-input" min="0.2" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Edge Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="edge-opacity" min="0" max="1" step="0.05" value="0.4">
                        <input type="number" id="edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.4">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="toggle-labels"></div>
                </div>
                <!-- Starfield toggle REMOVED - nodes ARE the stars -->
            </div>
        </div>

        <!-- FILTERS -->
        <div class="section">
            <div class="section-header" data-section="filters">
                <span>Filters</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-filters">
                <div class="filter-group">
                    <div class="filter-label">Tiers</div>
                    <div class="chips" id="filter-tiers"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Rings</div>
                    <div class="chips" id="filter-rings"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Edge Types</div>
                    <div class="chips" id="filter-edges"></div>
                </div>
            </div>
        </div>

        <!-- ACTIONS -->
        <div class="section">
            <div class="section-header collapsed" data-section="actions">
                <span>Actions</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content collapsed" id="section-actions">
                <div class="btn-grid btn-grid-2">
                    <button class="btn" id="btn-reset">Reset View</button>
                    <button class="btn" id="btn-screenshot">Screenshot</button>
                    <button class="btn" id="btn-2d">Toggle 2D</button>
                    <button class="btn" id="btn-freeze">Freeze</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Graph Container -->
    <div id="3d-graph"></div>

    <!-- Sidebar Resize Handles -->
    <div class="sidebar-resize-handle left" id="left-resize-handle"></div>
    <div class="sidebar-resize-handle right" id="right-resize-handle"></div>

    <!-- Right Sidebar -->
    <div id="right-sidebar">
        <!-- Hover Info Panel -->
        <div class="info-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Node Info</span>
            </div>
            <div class="node-info" id="hover-panel">
                <div class="node-name" id="hover-name">Node Name</div>
                <div class="node-kind" id="hover-kind">function</div>
                <div class="info-row"><span class="label">Atom</span><span class="value" id="hover-atom">--</span></div>
                <div class="info-row"><span class="label">Family</span><span class="value" id="hover-family">--</span>
                </div>
                <div class="info-row"><span class="label">Ring</span><span class="value" id="hover-ring">--</span></div>
                <div class="info-row"><span class="label">Tier</span><span class="value" id="hover-tier">--</span></div>
                <div class="info-row"><span class="label">Role</span><span class="value" id="hover-role">--</span></div>
                <div class="node-file" id="hover-file"></div>
            </div>
            <div class="placeholder-text" id="hover-placeholder">Hover over a node to see details</div>
        </div>

        <!-- Selection Panel -->
        <div class="selection-panel">
            <div class="selection-header">
                <span class="selection-title">Selection</span>
                <span class="selection-count" id="selection-count">0</span>
            </div>
            <div id="selection-actions" style="display: none; margin-bottom: 10px;">
                <button class="selection-clear" id="selection-clear">Clear</button>
            </div>
            <div class="selection-list" id="selection-list">
                <div class="placeholder-text">Click nodes to select</div>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="value" id="stats-nodes">0</div>
                    <div class="label">Visible</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-edges">0</div>
                    <div class="label">Edges</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-files">0</div>
                    <div class="label">Files</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-density">--</div>
                    <div class="label">Density</div>
                </div>
            </div>
        </div>

        <!-- COLOR SCHEMES (33 Named Gradients) - Primary color selection -->
        <div class="info-panel schemes-panel">
            <div class="info-panel-header collapsible" data-target="section-schemes">
                <span class="info-panel-title">Color Schemes</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="section-content" id="section-schemes">
                <!-- Populated dynamically by sidebar.js -->
            </div>
        </div>

        <!-- COLOR MODE (Presets) - What dimension to color by -->
        <div class="info-panel color-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Color Mode</span>
            </div>
            <div class="section-content" id="section-color">
                <div class="btn-grid btn-grid-3">
                    <button class="btn color-btn active" data-preset="tier">Tier</button>
                    <button class="btn color-btn" data-preset="family">Family</button>
                    <button class="btn color-btn" data-preset="layer">Layer</button>
                    <button class="btn color-btn" data-preset="ring">Ring</button>
                    <button class="btn color-btn" data-preset="file">File</button>
                    <button class="btn color-btn" data-preset="flow">Flow</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance HUD -->
    <div id="perf-hud">
        <div class="perf-row">
            <span class="perf-label">FPS:</span>
            <span class="perf-value" id="perf-fps">60</span>
            <span class="perf-label">Frame:</span>
            <span class="perf-value" id="perf-frame">0ms</span>
        </div>
    </div>

    <!-- UPB Module (Universal Property Binder) -->
    <script src="assets/modules/upb/scales.js"></script>
    <script src="assets/modules/upb/endpoints.js"></script>
    <script src="assets/modules/upb/blenders.js"></script>
    <script src="assets/modules/upb/bindings.js"></script>
    <script src="assets/modules/upb/index.js"></script>

    <!-- Modules -->
    <script src="assets/modules/control-bar.js"></script>

    <!-- Toast -->
    <div id="toast"></div>

    <!-- Core Application Injection -->
    <div id="selection-box"></div>
    <script>
        // ═══ MODULE: performance.js ═══
/**
 * COLLIDER PERFORMANCE SUBSYSTEM
 *
 * Provides frame-budget-aware animation scheduling, adaptive quality management,
 * and real-time performance monitoring for the WebGL visualization.
 *
 * Architecture:
 *   PerformanceMonitor  → measures frame times, detects stuttering
 *   AnimationScheduler  → manages animation queue, enforces frame budget
 *   AdaptiveQuality     → degrades/upgrades quality based on performance
 *   PositionOwnership   → enforces single-owner invariant for node positions
 *
 * Usage:
 *   PERF.monitor.start()
 *   PERF.scheduler.requestTransition(nodes, targetPositions, duration)
 *   PERF.quality.current  // 'ultra' | 'high' | 'medium' | 'low' | 'minimal'
 */

const PERF = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION (loaded from performance.tokens.json or defaults)
    // =========================================================================

    const CONFIG = {
        frameBudget: {
            targetFps: 60,
            targetFrameMs: 16.67,
            warningThreshold: 0.8,   // 80% of budget
            criticalThreshold: 1.5   // 150% of budget
        },
        nodeThresholds: {
            small: 100,
            medium: 500,
            large: 1000,
            massive: 5000
        },
        monitoring: {
            sampleWindowMs: 1000,
            sampleCount: 60,
            degradeAfterConsecutiveDrops: 10,
            upgradeAfterConsecutiveGood: 30
        }
    };

    // =========================================================================
    // PERFORMANCE MONITOR
    // Tracks frame times using a rolling window
    // =========================================================================

    const PerformanceMonitor = {
        _frameTimes: [],
        _lastFrameTime: 0,
        _frameCount: 0,
        _droppedFrames: 0,
        _consecutiveDrops: 0,
        _consecutiveGood: 0,
        _isRunning: false,
        _rafId: null,

        start() {
            if (this._isRunning) return;
            this._isRunning = true;
            this._lastFrameTime = performance.now();
            this._tick();
        },

        stop() {
            this._isRunning = false;
            if (this._rafId) {
                cancelAnimationFrame(this._rafId);
                this._rafId = null;
            }
        },

        _tick() {
            if (!this._isRunning) return;

            const now = performance.now();
            const frameTime = now - this._lastFrameTime;
            this._lastFrameTime = now;

            // Record frame time
            this._frameTimes.push(frameTime);
            if (this._frameTimes.length > CONFIG.monitoring.sampleCount) {
                this._frameTimes.shift();
            }

            this._frameCount++;

            // Check for dropped frame
            const budget = CONFIG.frameBudget.targetFrameMs;
            if (frameTime > budget * CONFIG.frameBudget.criticalThreshold) {
                this._droppedFrames++;
                this._consecutiveDrops++;
                this._consecutiveGood = 0;

                // Trigger quality degradation check
                if (this._consecutiveDrops >= CONFIG.monitoring.degradeAfterConsecutiveDrops) {
                    AdaptiveQuality.degrade();
                    this._consecutiveDrops = 0;
                }
            } else if (frameTime < budget * CONFIG.frameBudget.warningThreshold) {
                this._consecutiveGood++;
                this._consecutiveDrops = 0;

                // Trigger quality upgrade check
                if (this._consecutiveGood >= CONFIG.monitoring.upgradeAfterConsecutiveGood) {
                    AdaptiveQuality.upgrade();
                    this._consecutiveGood = 0;
                }
            }

            this._rafId = requestAnimationFrame(() => this._tick());
        },

        get fps() {
            if (this._frameTimes.length < 2) return 0;
            const avg = this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
            return Math.round(1000 / avg);
        },

        get avgFrameTime() {
            if (this._frameTimes.length === 0) return 0;
            return this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
        },

        get lastFrameTime() {
            return this._frameTimes[this._frameTimes.length - 1] || 0;
        },

        get droppedFramePercent() {
            if (this._frameCount === 0) return 0;
            return Math.round((this._droppedFrames / this._frameCount) * 100);
        },

        get stats() {
            return {
                fps: this.fps,
                avgFrameTime: this.avgFrameTime.toFixed(2),
                lastFrameTime: this.lastFrameTime.toFixed(2),
                droppedPercent: this.droppedFramePercent,
                quality: AdaptiveQuality.current,
                owner: PositionOwnership.current
            };
        },

        reset() {
            this._frameTimes = [];
            this._frameCount = 0;
            this._droppedFrames = 0;
            this._consecutiveDrops = 0;
            this._consecutiveGood = 0;
        }
    };

    // =========================================================================
    // ADAPTIVE QUALITY MANAGER
    // Adjusts rendering quality based on performance
    // =========================================================================

    const QUALITY_TIERS = ['minimal', 'low', 'medium', 'high', 'ultra'];

    const QUALITY_SETTINGS = {
        ultra:   { refreshEvery: 1, flockEnabled: true,  labelDensity: 1.0, animDuration: 1500 },
        high:    { refreshEvery: 1, flockEnabled: false, labelDensity: 0.8, animDuration: 1200 },
        medium:  { refreshEvery: 2, flockEnabled: false, labelDensity: 0.5, animDuration: 800  },
        low:     { refreshEvery: 3, flockEnabled: false, labelDensity: 0.2, animDuration: 500  },
        minimal: { refreshEvery: 5, flockEnabled: false, labelDensity: 0.1, animDuration: 200  }
    };

    const AdaptiveQuality = {
        _current: 'high',
        _locked: false,
        _nodeCount: 0,
        _callbacks: [],

        init(nodeCount) {
            this._nodeCount = nodeCount;
            // Auto-select initial tier based on node count
            if (nodeCount <= CONFIG.nodeThresholds.small) {
                this._current = 'ultra';
            } else if (nodeCount <= CONFIG.nodeThresholds.medium) {
                this._current = 'high';
            } else if (nodeCount <= CONFIG.nodeThresholds.large) {
                this._current = 'medium';
            } else if (nodeCount <= CONFIG.nodeThresholds.massive) {
                this._current = 'low';
            } else {
                this._current = 'minimal';
            }
            console.log(`[PERF] Quality auto-set to '${this._current}' for ${nodeCount} nodes`);
            this._notify();
        },

        get current() { return this._current; },

        get settings() { return QUALITY_SETTINGS[this._current]; },

        set(tier) {
            if (!QUALITY_TIERS.includes(tier)) {
                console.warn(`[PERF] Unknown quality tier: ${tier}`);
                return;
            }
            this._current = tier;
            console.log(`[PERF] Quality set to '${tier}'`);
            this._notify();
        },

        degrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            if (idx > 0) {
                this._current = QUALITY_TIERS[idx - 1];
                console.log(`[PERF] Quality degraded to '${this._current}'`);
                this._notify();
            }
        },

        upgrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            // Don't upgrade beyond what node count allows
            const maxTier = this._getMaxTierForNodeCount();
            const maxIdx = QUALITY_TIERS.indexOf(maxTier);
            if (idx < maxIdx) {
                this._current = QUALITY_TIERS[idx + 1];
                console.log(`[PERF] Quality upgraded to '${this._current}'`);
                this._notify();
            }
        },

        lock() { this._locked = true; },
        unlock() { this._locked = false; },

        _getMaxTierForNodeCount() {
            const n = this._nodeCount;
            if (n <= CONFIG.nodeThresholds.small) return 'ultra';
            if (n <= CONFIG.nodeThresholds.medium) return 'high';
            if (n <= CONFIG.nodeThresholds.large) return 'medium';
            if (n <= CONFIG.nodeThresholds.massive) return 'low';
            return 'minimal';
        },

        onChange(callback) {
            this._callbacks.push(callback);
        },

        _notify() {
            this._callbacks.forEach(cb => cb(this._current, this.settings));
        }
    };

    // =========================================================================
    // POSITION OWNERSHIP
    // Enforces single-owner invariant for node positions (fx/fy/fz)
    // =========================================================================

    const OWNERS = ['none', 'transition', 'motion', 'flock', 'force'];

    const PositionOwnership = {
        _current: 'none',
        _animationId: null,

        get current() { return this._current; },

        acquire(owner, animationId = null) {
            if (!OWNERS.includes(owner)) {
                console.warn(`[PERF] Unknown position owner: ${owner}`);
                return false;
            }

            // Cancel any existing animation
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }

            this._current = owner;
            this._animationId = animationId;
            console.log(`[PERF] Position ownership: ${owner}`);
            return true;
        },

        release(owner) {
            if (this._current === owner) {
                if (this._animationId) {
                    cancelAnimationFrame(this._animationId);
                    this._animationId = null;
                }
                this._current = 'none';
                console.log(`[PERF] Position ownership released by ${owner}`);
            }
        },

        setAnimationId(id) {
            this._animationId = id;
        },

        cancelAnimation() {
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }
        }
    };

    // =========================================================================
    // ANIMATION SCHEDULER
    // Frame-budget-aware animation with throttling
    // =========================================================================

    const AnimationScheduler = {
        _refreshFrameCounter: 0,

        /**
         * Run a layout transition with frame budget awareness
         * @param {Object} options
         * @param {Array} options.nodes - Array of node objects
         * @param {Function} options.getTargetPosition - (node, index, total) => {x, y, z}
         * @param {number} options.duration - Animation duration in ms
         * @param {Function} options.onFrame - Called each frame with progress (0-1)
         * @param {Function} options.onComplete - Called when animation finishes
         * @param {Function} options.refresh - Function to call to refresh the graph
         */
        runTransition(options) {
            const { nodes, getTargetPosition, duration, onFrame, onComplete, refresh } = options;

            // Acquire ownership
            PositionOwnership.acquire('transition');

            const total = nodes.length;
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => getTargetPosition(n, i, total));

            const startTime = performance.now();
            const settings = AdaptiveQuality.settings;
            const actualDuration = Math.min(duration, settings.animDuration);

            this._refreshFrameCounter = 0;

            const animate = () => {
                // Check if we still own positions
                if (PositionOwnership.current !== 'transition') {
                    console.log('[PERF] Transition interrupted - lost ownership');
                    return;
                }

                const now = performance.now();
                const elapsed = now - startTime;
                const progress = Math.min(1, elapsed / actualDuration);

                // Smoothstep easing
                const eased = progress * progress * (3 - 2 * progress);

                // Update positions
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];
                    const s = startPos[i];
                    const t = targetPos[i];
                    n.fx = s.x + (t.x - s.x) * eased;
                    n.fy = s.y + (t.y - s.y) * eased;
                    n.fz = s.z + (t.z - s.z) * eased;
                }

                // Throttled refresh based on quality settings
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                if (onFrame) onFrame(progress);

                if (progress < 1) {
                    const id = requestAnimationFrame(animate);
                    PositionOwnership.setAnimationId(id);
                } else {
                    PositionOwnership.release('transition');
                    if (onComplete) onComplete();
                }
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Run continuous motion (rotate/orbit) with throttling
         */
        runMotion(options) {
            const { nodes, getPosition, speed, refresh } = options;

            PositionOwnership.acquire('motion');

            const total = nodes.length;
            const settings = AdaptiveQuality.settings;
            let time = 0;

            this._refreshFrameCounter = 0;

            const animate = () => {
                if (PositionOwnership.current !== 'motion') {
                    console.log('[PERF] Motion interrupted - lost ownership');
                    return;
                }

                time += speed;

                for (let i = 0; i < nodes.length; i++) {
                    const pos = getPosition(nodes[i], i, total, time);
                    nodes[i].fx = pos.x;
                    nodes[i].fy = pos.y;
                    nodes[i].fz = pos.z;
                }

                // Throttled refresh
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                const id = requestAnimationFrame(animate);
                PositionOwnership.setAnimationId(id);
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Stop any running animation
         */
        stop() {
            PositionOwnership.cancelAnimation();
            PositionOwnership._current = 'none';
        }
    };

    // =========================================================================
    // HUD OVERLAY
    // Real-time performance display (toggleable)
    // =========================================================================

    const HUD = {
        _element: null,
        _visible: false,
        _updateInterval: null,

        init() {
            this._element = document.createElement('div');
            this._element.id = 'perf-hud';
            this._element.style.cssText = `
                position: fixed;
                bottom: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.8);
                color: #0f0;
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
                padding: 8px 12px;
                border-radius: 4px;
                z-index: 10000;
                display: none;
                min-width: 140px;
                border: 1px solid #333;
            `;
            document.body.appendChild(this._element);
        },

        show() {
            if (!this._element) this.init();
            this._element.style.display = 'block';
            this._visible = true;
            this._startUpdates();
        },

        hide() {
            if (this._element) {
                this._element.style.display = 'none';
            }
            this._visible = false;
            this._stopUpdates();
        },

        toggle() {
            if (this._visible) this.hide();
            else this.show();
        },

        _startUpdates() {
            if (this._updateInterval) return;
            this._updateInterval = setInterval(() => this._update(), 100);
        },

        _stopUpdates() {
            if (this._updateInterval) {
                clearInterval(this._updateInterval);
                this._updateInterval = null;
            }
        },

        _update() {
            if (!this._element || !this._visible) return;

            const stats = PerformanceMonitor.stats;
            const fpsColor = stats.fps >= 55 ? '#0f0' : stats.fps >= 30 ? '#ff0' : '#f00';

            this._element.innerHTML = `
                <div style="color: ${fpsColor}; font-weight: bold;">${stats.fps} FPS</div>
                <div style="color: #888;">Frame: ${stats.lastFrameTime}ms</div>
                <div style="color: #888;">Avg: ${stats.avgFrameTime}ms</div>
                <div style="color: #888;">Drops: ${stats.droppedPercent}%</div>
                <div style="color: #0af;">Quality: ${stats.quality}</div>
                <div style="color: #a0f;">Owner: ${stats.owner}</div>
            `;
        }
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        monitor: PerformanceMonitor,
        quality: AdaptiveQuality,
        ownership: PositionOwnership,
        scheduler: AnimationScheduler,
        hud: HUD,
        config: CONFIG,

        /**
         * Initialize the performance subsystem
         * @param {number} nodeCount - Number of nodes in the graph
         * @param {Object} tokens - Optional performance tokens from JSON
         */
        init(nodeCount, tokens = null) {
            if (tokens) {
                Object.assign(CONFIG, tokens);
            }
            AdaptiveQuality.init(nodeCount);
            PerformanceMonitor.start();
            HUD.init();
            console.log('[PERF] Performance subsystem initialized');
        },

        /**
         * Check if flock simulation should be enabled
         */
        isFlockAllowed() {
            return AdaptiveQuality.settings.flockEnabled;
        },

        /**
         * Get current animation duration (adjusted for quality)
         */
        getAnimationDuration(requested) {
            return Math.min(requested, AdaptiveQuality.settings.animDuration);
        }
    };
})();

// Export for module systems if available
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PERF;
}


// ═══ MODULE: modules/utils.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UTILS MODULE - Pure Utility Functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Zero-dependency pure functions for math, string, and data operations.
 * These functions have NO external state dependencies and can be used anywhere.
 *
 * @module UTILS
 * @version 1.0.0
 * @confidence 99%
 */

window.UTILS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // MATH UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clamp value to [0, 1] range
     * @param {number} value - Value to clamp
     * @returns {number} Clamped value
     */
    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    /**
     * Clamp value to [min, max] range
     * @param {number} value - Value to clamp
     * @param {number} min - Minimum bound
     * @param {number} max - Maximum bound
     * @returns {number} Clamped value
     */
    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Normalize value to [0, 1] based on max.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} val - Value to normalize
     * @param {number} max - Maximum value
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value
     */
    function normalize(val, max, scaleName) {
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', val, 0, max);
        }
        // Fallback
        return Math.min(1, Math.max(0, val / max));
    }

    /**
     * Normalize metric value based on range.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} value - Value to normalize
     * @param {min: number, max: number} range - Range object
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value in [0, 1]
     */
    function normalizeMetric(value, range, scaleName) {
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', value, range.min, range.max);
        }
        // Fallback
        return clamp01((value - range.min) / (range.max - range.min));
    }

    /**
     * Calculate quantile from sorted values
     * @param {number[]} values - Array of numbers
     * @param {number} q - Quantile (0-1)
     * @returns {number} Quantile value
     */
    function quantile(values, q) {
        if (!values.length) return 0;
        const sorted = values.slice().sort((a, b) => a - b);
        const pos = (sorted.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;
        if (sorted[base + 1] !== undefined) {
            return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
        }
        return sorted[base];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HASH & SEED UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Convert any value to a unit float [0, 1] via hashing
     * @param {*} value - Any value to hash
     * @returns {number} Hash as unit float
     */
    function hashToUnit(value) {
        const str = String(value || '');
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return (hash >>> 0) / 0xffffffff;
    }

    /**
     * Generate stable seed from node and salt
     * @param {Object} node - Node object with id/name
     * @param {string} salt - Salt string
     * @returns {number} Stable seed in [0, 1]
     */
    function stableSeed(node, salt) {
        const id = String(node.id || node.name || '');
        const combined = `${id}|${salt}`;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
            hash = ((hash << 5) - hash + combined.charCodeAt(i)) | 0;
        }
        return ((hash >>> 0) % 1000) / 1000;
    }

    /**
     * Generate stable Z offset for node
     * @param {Object} node - Node object
     * @returns {number} Z offset
     */
    function stableZ(node) {
        const normalized = stableSeed(node, 'z');
        return (normalized - 0.5) * 60;
    }

    /**
     * Generate stable offset vector for node positioning
     * @param {Object} node - Node object
     * @param {string} salt - Salt string
     * @param {number} radius - Base radius
     * @returns {x: number, y: number, z: number} Offset vector
     */
    function stableOffset(node, salt, radius) {
        const angle = stableSeed(node, `${salt}:angle`) * Math.PI * 2;
        const spread = 0.3 + stableSeed(node, `${salt}:radius`) * 0.7;
        const zJitter = (stableSeed(node, `${salt}:z`) - 0.5) * radius * 0.6;
        const dist = radius * spread;
        return {
            x: Math.cos(angle) * dist,
            y: Math.sin(angle) * dist,
            z: zJitter
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STRING UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Escape HTML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML
     */
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Parse OKLCH color string
     * @param {string} value - OKLCH color string
     * @returns {L: number, C: number, H: number, A: number}|null} Parsed values or null
     */
    function parseOklchString(value) {
        if (typeof value !== 'string') return null;
        const match = value.trim().match(/^oklch\(\s*([\d.]+)%\s+([\d.]+)\s+([\d.]+)(?:\s*\/\s*([\d.]+))?\s*\)$/i);
        if (!match) return null;
        return {
            L: parseFloat(match[1]),
            C: parseFloat(match[2]),
            H: parseFloat(match[3]),
            A: match[4] !== undefined ? parseFloat(match[4]) : 1
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Resolve defaults against available values
     * @param {Array} defaults - Preferred defaults
     * @param {Array} available - Available values
     * @returns {Array} Resolved values
     */
    function resolveDefaults(defaults, available) {
        if (!Array.isArray(defaults) || defaults.length === 0) {
            return available;
        }
        const availableSet = new Set(available);
        const intersection = defaults.filter(value => availableSet.has(value));
        return intersection.length ? intersection : available;
    }

    /**
     * Build dataset key from data object
     * @param {Object} data - Data object with meta, nodes, links
     * @returns {string} Dataset key
     */
    function buildDatasetKey(data) {
        const meta = (data && data.meta) ? data.meta : {};
        const target = meta.target || meta.project || 'dataset';
        const version = meta.version || '';
        const nodeCount = Array.isArray(data?.nodes) ? data.nodes.length : 0;
        const edgeCount = Array.isArray(data?.links)
            ? data.links.length
            : (Array.isArray(data?.edges) ? data.edges.length : 0);
        const raw = `${target}|${nodeCount}|${edgeCount}|${version}`;
        return raw.replace(/[^a-zA-Z0-9_.-]/g, '_').slice(0, 180);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GEOMETRY UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Calculate bounding box from two points
     * @param {x: number, y: number} start - Start point
     * @param {x: number, y: number} end - End point
     * @returns {left: number, top: number, width: number, height: number, right: number, bottom: number} Box rect
     */
    function getBoxRect(start, end) {
        const left = Math.min(start.x, end.x);
        const top = Math.min(start.y, end.y);
        const width = Math.abs(start.x - end.x);
        const height = Math.abs(start.y - end.y);
        return {
            left,
            top,
            width,
            height,
            right: left + width,
            bottom: top + height
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Math
        clamp01,
        clampValue,
        normalize,
        normalizeMetric,
        quantile,

        // Hash & Seed
        hashToUnit,
        stableSeed,
        stableZ,
        stableOffset,

        // String
        escapeHtml,
        parseOklchString,

        // Data
        resolveDefaults,
        buildDatasetKey,

        // Geometry
        getBoxRect
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════
// These ensure existing code continues to work without modification

window.clamp01 = UTILS.clamp01;
window.clampValue = UTILS.clampValue;
window.normalize = UTILS.normalize;
window.normalizeMetric = UTILS.normalizeMetric;
window.quantile = UTILS.quantile;
window.hashToUnit = UTILS.hashToUnit;
window.stableSeed = UTILS.stableSeed;
window.stableZ = UTILS.stableZ;
window.stableOffset = UTILS.stableOffset;
window.escapeHtml = UTILS.escapeHtml;
window.parseOklchString = UTILS.parseOklchString;
window.resolveDefaults = UTILS.resolveDefaults;
window.buildDatasetKey = UTILS.buildDatasetKey;
window.getBoxRect = UTILS.getBoxRect;

console.log('[Module] UTILS loaded - 14 pure functions');


// ═══ MODULE: modules/registry.js ═══
/**
 * @module registry
 * @description Centralized UI and command registration system
 * @responsibility Manage DOM element and command handler registration
 */

const REGISTRY = (function() {
    'use strict';

    // Private state
    const _items = new Map();
    const _commands = new Map();

    /**
     * Register a command handler or DOM element
     * @param {string} id - The identifier
     * @param {Function|Element} item - Handler function or DOM element
     * @param {Object} options - Additional options
     */
    function register(id, item, options = {}) {
        // CASE 1: Registering a Command Identifier + Handler Function
        // e.g. REGISTRY.register('cmd-files', () => toggleFiles(), { desc: '...' })
        if (typeof item === 'function') {
            _commands.set(id, { handler: item, options });

            // Auto-wire if DOM element exists with this ID
            const btn = document.getElementById(id);
            if (btn) {
                btn.onclick = (e) => {
                    item(e);
                };
                btn.setAttribute('data-command-id', id);
            }
            return;
        }

        // CASE 2: Registering a DOM Element directly
        let element = item;
        let elementId = id;

        // Overload: register(element) -> id comes from element.id
        if ((item instanceof Element) && arguments.length === 1) {
            element = item;
            elementId = element.id;
        }
        // Overload: register(id, element)
        else if (item instanceof Element) {
            element = item;
        }
        // Fallback: mismatched args
        else if (!element && (typeof id === 'object' && id instanceof Element)) {
            element = id;
            elementId = element.id;
        }

        if (!element || !element.setAttribute) {
            return;
        }

        if (!elementId) {
            return;
        }

        _items.set(elementId, element);
        element.setAttribute('data-registry-id', elementId);
    }

    /**
     * Get a registered element by ID (falls back to document.getElementById)
     * @param {string} id - The element ID
     * @returns {Element|null}
     */
    function get(id) {
        return _items.get(id) || document.getElementById(id);
    }

    /**
     * Get a registered command handler
     * @param {string} id - The command ID
     * @returns {Object|undefined} - { handler, options }
     */
    function getCommand(id) {
        return _commands.get(id);
    }

    /**
     * Execute a registered command
     * @param {string} id - The command ID
     * @param {Event} event - Optional event object
     * @returns {*} - Result of handler execution
     */
    function execute(id, event) {
        const cmd = _commands.get(id);
        if (cmd && typeof cmd.handler === 'function') {
            return cmd.handler(event);
        }
        console.warn(`[Registry] Command not found: ${id}`);
        return undefined;
    }

    /**
     * Check if a command is registered
     * @param {string} id - The command ID
     * @returns {boolean}
     */
    function hasCommand(id) {
        return _commands.has(id);
    }

    /**
     * Check if an element is registered
     * @param {string} id - The element ID
     * @returns {boolean}
     */
    function hasElement(id) {
        return _items.has(id);
    }

    /**
     * Get all registered command IDs
     * @returns {string[]}
     */
    function listCommands() {
        return Array.from(_commands.keys());
    }

    /**
     * Get all registered element IDs
     * @returns {string[]}
     */
    function listElements() {
        return Array.from(_items.keys());
    }

    // Public API
    return {
        register,
        get,
        getCommand,
        execute,
        hasCommand,
        hasElement,
        listCommands,
        listElements,
        // Expose maps for backward compatibility (read-only access pattern)
        get items() { return _items; },
        get commands() { return _commands; }
    };
})();

// Expose globally for backward compatibility
window.REGISTRY = REGISTRY;


// ═══ MODULE: modules/perf-monitor.js ═══
/**
 * @module perf-monitor
 * @description Real-time performance monitoring and FPS diagnostics
 * @responsibility Track frame delivery, detect dropped frames, display HUD
 */

// NOTE: Named _PerfMonitorImpl to avoid conflict with performance.js PERF
const _PerfMonitorImpl = (function() {
    'use strict';

    // Configuration
    const _config = {
        enabled: true,
        maxFrames: 60,
        droppedFrameThreshold: 50  // ms (>50ms = <20fps)
    };

    // State
    const _state = {
        fps: 0,
        frameTime: 0,
        lastFrameTime: 0,
        frameTimes: [],
        renderCalls: 0,
        droppedFrames: 0,
        lastSecond: 0,
        framesThisSecond: 0,
        hudElement: null,
        monitoring: false
    };

    /**
     * Initialize the performance monitor
     */
    function init() {
        if (!_config.enabled) return;

        // Create HUD element
        _state.hudElement = document.createElement('div');
        _state.hudElement.id = 'perf-hud';
        _state.hudElement.style.cssText = `
            position: fixed; top: 10px; right: 10px; z-index: 99999;
            background: rgba(0,0,0,0.85); color: #0f0; font-family: monospace;
            font-size: 11px; padding: 8px 12px; border-radius: 4px;
            border: 1px solid #333; min-width: 140px; pointer-events: none;
        `;
        document.body.appendChild(_state.hudElement);
        _startMonitoring();
    }

    /**
     * Start the monitoring loop
     */
    function _startMonitoring() {
        if (_state.monitoring) return;
        _state.monitoring = true;

        const monitor = () => {
            if (!_state.monitoring) return;

            const now = performance.now();

            // Calculate frame time
            if (_state.lastFrameTime > 0) {
                _state.frameTime = now - _state.lastFrameTime;
                _state.frameTimes.push(_state.frameTime);
                if (_state.frameTimes.length > _config.maxFrames) {
                    _state.frameTimes.shift();
                }

                // Detect dropped frames
                if (_state.frameTime > _config.droppedFrameThreshold) {
                    _state.droppedFrames++;
                }
            }
            _state.lastFrameTime = now;

            // Calculate FPS every second
            const second = Math.floor(now / 1000);
            if (second !== _state.lastSecond) {
                _state.fps = _state.framesThisSecond;
                _state.framesThisSecond = 0;
                _state.lastSecond = second;
            }
            _state.framesThisSecond++;

            // Update HUD
            _updateHUD();
            requestAnimationFrame(monitor);
        };
        requestAnimationFrame(monitor);
    }

    /**
     * Update the HUD display
     */
    function _updateHUD() {
        if (!_state.hudElement) return;

        const avgFrameTime = _state.frameTimes.length > 0
            ? (_state.frameTimes.reduce((a, b) => a + b, 0) / _state.frameTimes.length).toFixed(1)
            : '0.0';

        // Color code FPS
        let fpsColor = '#0f0';  // Green = good
        if (_state.fps < 30) fpsColor = '#ff0';  // Yellow = warning
        if (_state.fps < 15) fpsColor = '#f00';  // Red = bad

        // Animation state - use ANIM module if available
        const isAnimating = typeof ANIM !== 'undefined' && ANIM.isAnimating;
        const animating = isAnimating ? '▶ ANIMATING' : '■ IDLE';
        const animColor = isAnimating ? '#0ff' : '#666';
        const staggerPattern = (typeof ANIM !== 'undefined' && ANIM.staggerPattern) || 'none';

        _state.hudElement.innerHTML = `
            <div style="color:${fpsColor};font-size:14px;font-weight:bold">${_state.fps} FPS</div>
            <div>Frame: ${avgFrameTime}ms</div>
            <div>Dropped: <span style="color:${_state.droppedFrames > 10 ? '#f00' : '#0f0'}">${_state.droppedFrames}</span></div>
            <div style="color:${animColor}">${animating}</div>
            <div style="font-size:9px;color:#666;margin-top:4px">Pattern: ${staggerPattern}</div>
        `;
    }

    /**
     * Log a performance resistance point
     * @param {string} location - Where the resistance occurred
     * @param {number} duration - Duration in milliseconds
     */
    function logResistance(location, duration) {
        if (duration > 16) {
            console.warn(`[PERF RESISTANCE] ${location}: ${duration.toFixed(1)}ms (>${Math.floor(duration / 16.67)} frames)`);
        }
    }

    /**
     * Stop monitoring
     */
    function stop() {
        _state.monitoring = false;
        if (_state.hudElement && _state.hudElement.parentNode) {
            _state.hudElement.parentNode.removeChild(_state.hudElement);
        }
        _state.hudElement = null;
    }

    /**
     * Reset statistics
     */
    function reset() {
        _state.fps = 0;
        _state.frameTime = 0;
        _state.frameTimes = [];
        _state.droppedFrames = 0;
        _state.framesThisSecond = 0;
    }

    /**
     * Toggle HUD visibility
     */
    function toggle() {
        if (_state.hudElement) {
            _state.hudElement.style.display =
                _state.hudElement.style.display === 'none' ? 'block' : 'none';
        }
    }

    /**
     * Enable/disable monitoring
     * @param {boolean} enabled
     */
    function setEnabled(enabled) {
        _config.enabled = enabled;
        if (!enabled) {
            stop();
        } else if (!_state.monitoring) {
            init();
        }
    }

    // Public API
    return {
        init,
        stop,
        reset,
        toggle,
        setEnabled,
        logResistance,
        // Read-only state access
        get fps() { return _state.fps; },
        get frameTime() { return _state.frameTime; },
        get droppedFrames() { return _state.droppedFrames; },
        get enabled() { return _config.enabled; },
        get monitoring() { return _state.monitoring; }
    };
})();

// Export as PERF_MONITOR (PERF is provided by performance.js)
const PERF_MONITOR = _PerfMonitorImpl;

// Expose globally - only PERF_MONITOR, PERF comes from performance.js
window.PERF_MONITOR = PERF_MONITOR;


// ═══ MODULE: modules/core.js ═══
/**
 * CORE MODULE
 *
 * Foundation constants and utility functions for the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   CORE.SELECTION_SIZE_MULT      // Node size multiplier when selected
 *   CORE.PENDULUM                 // OKLCH color oscillator state
 *   CORE.amplify(value, gamma)    // Power law amplification
 *   CORE.amplifyContrast(value)   // S-curve contrast expansion
 */

const CORE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

    // OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
    const PENDULUM = {
        hue: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,        // Set from appearance.tokens
            gravity: null,        // Set from appearance.tokens
            length: 1.0,
            rotationSpeed: null   // Set from appearance.tokens
        },
        chroma: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,
            gravity: null,
            length: 1.0,
            center: null,
            amplitude: null
        },
        lightness: {
            phase: 0,
            speed: null,
            center: null,
            amplitude: null
        },
        ripple: {
            speed: null,
            scale: null
        },
        currentHue: Math.random() * 360,
        lastTime: 0,
        running: false
    };

    // =========================================================================
    // AMPLIFICATION UTILITIES
    // =========================================================================

    /**
     * Amplification function using power law: f(x) = x^(1/gamma)
     * Maps normalized [0,1] input to amplified [0,1] output
     * @param {number} value - Input value (0-1)
     * @param {number} gamma - Amplification factor (default from APPEARANCE_STATE)
     * @returns {number} Amplified value (0-1)
     */
    function amplify(value, gamma) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const g = gamma !== undefined ? gamma :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (g === 1) return value;
        // Clamp to valid range
        const v = Math.max(0, Math.min(1, value));
        // Power law: v^(1/gamma) - when gamma>1, small diffs become larger
        // Using 1/gamma so that higher slider = more amplification
        return Math.pow(v, 1 / g);
    }

    /**
     * Contrast amplification: expands values away from midpoint
     * Uses S-curve (tanh) for smooth contrast expansion
     * @param {number} value - Input value (0-1)
     * @param {number} strength - Contrast strength (default from APPEARANCE_STATE)
     * @returns {number} Contrast-enhanced value (0-1)
     */
    function amplifyContrast(value, strength) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const s = strength !== undefined ? strength :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (s === 1) return value;
        const v = Math.max(0, Math.min(1, value));
        // S-curve using tanh for smooth contrast expansion
        const centered = (v - 0.5) * 2;  // [-1, 1]
        const amplified = Math.tanh(centered * s) / Math.tanh(s);
        return (amplified + 1) / 2;  // Back to [0, 1]
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Constants
        SELECTION_SIZE_MULT,
        PENDULUM,

        // Utilities
        amplify,
        amplifyContrast
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'SELECTION_SIZE_MULT', {
    get: () => CORE.SELECTION_SIZE_MULT,
    configurable: true
});
Object.defineProperty(window, 'PENDULUM', {
    get: () => CORE.PENDULUM,
    configurable: true
});
Object.defineProperty(window, 'amplify', {
    get: () => CORE.amplify,
    configurable: true
});
Object.defineProperty(window, 'amplifyContrast', {
    get: () => CORE.amplifyContrast,
    configurable: true
});


// ═══ MODULE: modules/theory.js ═══
/**
 * THEORY MODULE - Standard Model of Code Theory Constants
 *
 * Pure data representing the Standard Model topology.
 * No dependencies. This is the canonical source of truth.
 *
 * @module THEORY
 * @version 1.0.0
 */

window.THEORY = (function() {
    'use strict';

    // =========================================================================
    // THE 16 ABSTRACTION LEVELS (vertical axis: L-3 to L12)
    // =========================================================================

    const SCALE_16_LEVELS = {
        // COSMOLOGICAL (L8-L12) - Beyond scope, shown as outer haze
        'L12': { name: 'UNIVERSE', symbol: '🌐', zone: 'COSMOLOGICAL', y: 1.4, color: { h: 260, s: 30, l: 25 } },
        'L11': { name: 'DOMAIN', symbol: '🏛️', zone: 'COSMOLOGICAL', y: 1.3, color: { h: 250, s: 35, l: 30 } },
        'L10': { name: 'ORGANIZATION', symbol: '🏢', zone: 'COSMOLOGICAL', y: 1.2, color: { h: 240, s: 40, l: 35 } },
        'L9': { name: 'PLATFORM', symbol: '☁️', zone: 'COSMOLOGICAL', y: 1.1, color: { h: 230, s: 45, l: 40 } },
        'L8': { name: 'ECOSYSTEM', symbol: '🔗', zone: 'COSMOLOGICAL', y: 1.0, color: { h: 220, s: 50, l: 45 } },
        // ARCHITECTURAL (L4-L7) - Primary visible zone (teal - virtual depths)
        'L7': { name: 'SYSTEM', symbol: '⬡', zone: 'ARCHITECTURAL', y: 0.7, color: { h: 175, s: 60, l: 52 } },
        'L6': { name: 'PACKAGE', symbol: '📦', zone: 'ARCHITECTURAL', y: 0.5, color: { h: 178, s: 62, l: 48 } },
        'L5': { name: 'FILE', symbol: '📄', zone: 'ARCHITECTURAL', y: 0.3, color: { h: 180, s: 65, l: 44 } },
        'L4': { name: 'CONTAINER', symbol: '⬢', zone: 'ARCHITECTURAL', y: 0.1, color: { h: 182, s: 68, l: 40 } },
        // SEMANTIC (L1-L3) - The operational core (silver/white - surface light)
        'L3': { name: 'NODE', symbol: '★', zone: 'SEMANTIC', y: -0.1, color: { h: 210, s: 25, l: 92 } },  // Brightest - fundamental unit
        'L2': { name: 'BLOCK', symbol: '▣', zone: 'SEMANTIC', y: -0.3, color: { h: 210, s: 30, l: 85 } },
        'L1': { name: 'STATEMENT', symbol: '─', zone: 'SEMANTIC', y: -0.5, color: { h: 210, s: 35, l: 78 } },
        // SYNTACTIC (L0) - The event horizon between meaning and data
        'L0': { name: 'TOKEN', symbol: '·', zone: 'SYNTACTIC', y: -0.7, color: { h: 60, s: 90, l: 55 } },  // Bright yellow - event horizon
        // PHYSICAL (L-1 to L-3) - The substrate (deep blue - ocean floor)
        'L-1': { name: 'CHARACTER', symbol: 'a', zone: 'PHYSICAL', y: -0.9, color: { h: 220, s: 70, l: 42 } },
        'L-2': { name: 'BYTE', symbol: '01', zone: 'PHYSICAL', y: -1.1, color: { h: 220, s: 75, l: 35 } },
        'L-3': { name: 'BIT/QUBIT', symbol: '⚡', zone: 'PHYSICAL', y: -1.3, color: { h: 220, s: 80, l: 28 } }  // Deepest
    };

    // =========================================================================
    // THE THREE PARALLEL LAYERS (shells around the structure)
    // =========================================================================

    const THREE_LAYERS = {
        'PHYSICAL': { order: 0, radius: 1.8, opacity: 0.15, color: { h: 220, s: 75, l: 35 }, description: 'Hardware, bits, memory, I/O' },
        'VIRTUAL': { order: 1, radius: 1.4, opacity: 0.25, color: { h: 175, s: 65, l: 45 }, description: 'Code, structures, algorithms' },
        'SEMANTIC': { order: 2, radius: 1.0, opacity: 0.35, color: { h: 210, s: 30, l: 88 }, description: 'Meaning, business logic, intent' }
    };

    // =========================================================================
    // STANDARD MODEL THEORY CONTENT - Semantic descriptions for tooltips
    // =========================================================================

    const SMC_THEORY = {
        // THE THREE FUNDAMENTAL LAYERS
        layers: {
            'PHYSICAL': {
                icon: '⚡',
                title: 'Physical Layer',
                subtitle: 'The Substrate',
                body: 'The hardware reality: electrons, circuits, memory cells. Everything that exists in physical space-time.',
                theory: '"Matter is the canvas upon which computation paints its patterns."',
                examples: ['CPU registers', 'RAM cells', 'disk sectors', 'network signals']
            },
            'VIRTUAL': {
                icon: '💠',
                title: 'Virtual Layer',
                subtitle: 'The Structure',
                body: 'Pure information structures: code, data, algorithms. The mathematical forms that live in computational space.',
                theory: '"Between the physical and the meaningful lies the virtual — pure form without matter or purpose."',
                examples: ['variables', 'functions', 'classes', 'data structures']
            },
            'SEMANTIC': {
                icon: '🎯',
                title: 'Semantic Layer',
                subtitle: 'The Meaning',
                body: 'Intent and purpose: business logic, user goals, system behavior. The "why" behind the code.',
                theory: '"Semantics is where computation meets human intention — the bridge between bits and understanding."',
                examples: ['user stories', 'business rules', 'API contracts', 'domain models']
            }
        },

        // ATOM FAMILIES
        families: {
            'LOG': {
                icon: '📊',
                title: 'Logic Family',
                subtitle: 'The Reasoners',
                body: 'Elements that transform data through computation: conditionals, loops, calculations.',
                theory: '"Logic atoms are the decision-makers — they take inputs and produce outputs through transformation."',
                examples: ['if/else', 'for loops', 'calculations', 'validators']
            },
            'DAT': {
                icon: '📦',
                title: 'Data Family',
                subtitle: 'The Containers',
                body: 'Elements that hold and organize information: variables, structures, databases.',
                theory: '"Data atoms store state — they are the nouns in the grammar of code."',
                examples: ['variables', 'arrays', 'objects', 'databases']
            },
            'ORG': {
                icon: '🏗️',
                title: 'Organization Family',
                subtitle: 'The Architects',
                body: 'Elements that structure code: modules, classes, packages. They create boundaries.',
                theory: '"Organization atoms create order from chaos — the folders in the file system of abstraction."',
                examples: ['modules', 'classes', 'packages', 'namespaces']
            },
            'EXE': {
                icon: '⚙️',
                title: 'Execution Family',
                subtitle: 'The Doers',
                body: 'Elements that perform actions: function calls, I/O, system operations.',
                theory: '"Execution atoms are the verbs — where potential becomes actual."',
                examples: ['function calls', 'API requests', 'file writes', 'renders']
            },
            'EXT': {
                icon: '🔌',
                title: 'External Family',
                subtitle: 'The Connectors',
                body: 'Elements that interface with the outside: APIs, imports, system calls.',
                theory: '"External atoms are portals — they connect isolated systems into larger ecosystems."',
                examples: ['imports', 'API calls', 'env vars', 'dependencies']
            }
        },

        // TIERS
        tiers: {
            'T0': {
                icon: '🔬',
                title: 'Tier 0 — Foundation',
                subtitle: 'Low-level primitives',
                body: 'The atomic building blocks: individual statements, expressions, basic operations.',
                theory: '"T0 is where code meets silicon — the ground floor of abstraction."',
                examples: ['assignments', 'operators', 'literals', 'basic types']
            },
            'T1': {
                icon: '🔧',
                title: 'Tier 1 — Components',
                subtitle: 'Functional units',
                body: 'Grouped functionality: functions, methods, small modules.',
                theory: '"T1 is the sweet spot — complex enough to be useful, simple enough to understand."',
                examples: ['functions', 'methods', 'handlers', 'utilities']
            },
            'T2': {
                icon: '🏛️',
                title: 'Tier 2 — Architecture',
                subtitle: 'System structure',
                body: 'High-level organization: classes, modules, services. The skeleton of the codebase.',
                theory: '"T2 defines the shape of software — patterns emerge that echo through every line."',
                examples: ['classes', 'modules', 'services', 'controllers']
            }
        },

        // SPECIAL ELEMENTS
        special: {
            'core': {
                icon: '✨',
                title: 'The Nexus',
                subtitle: 'Singularity Point',
                body: 'The center of the topology: where all paths converge.',
                theory: '"Every codebase has a heart — the central modules that everything depends upon."',
                examples: ['main.js', 'app.py', 'index.ts', 'core.rs']
            },
            'elevator': {
                icon: '🚀',
                title: 'Data Elevator',
                subtitle: 'Cross-tier Highway',
                body: 'Vertical connections that move data between abstraction levels.',
                theory: '"Elevators are the call stacks of architecture."',
                examples: ['API layers', 'ORMs', 'serializers', 'adapters']
            },
            'hub-star': {
                icon: '⭐',
                title: 'Hub Node',
                subtitle: 'High-connectivity Center',
                body: 'A node with many incoming connections. Often a critical dependency.',
                theory: '"Hubs are the load-bearing walls — remove them and everything collapses."',
                examples: ['utils', 'config', 'logger', 'database']
            }
        }
    };

    // =========================================================================
    // LEVEL ZONES - Which levels belong to which visual band
    // =========================================================================

    const LEVEL_ZONES = {
        'COSMOLOGICAL': { levels: ['L12', 'L11', 'L10', 'L9', 'L8'], opacity: 0.2, blur: true },
        'ARCHITECTURAL': { levels: ['L7', 'L6', 'L5', 'L4'], opacity: 0.6, blur: false },
        'SEMANTIC': { levels: ['L3', 'L2', 'L1'], opacity: 1.0, blur: false },        // Primary focus
        'SYNTACTIC': { levels: ['L0'], opacity: 0.8, blur: false },                   // Event horizon
        'PHYSICAL': { levels: ['L-1', 'L-2', 'L-3'], opacity: 0.4, blur: true }
    };

    // =========================================================================
    // VISUALIZATION PRESETS - Different ways to see the topology
    // =========================================================================

    const VIS_PRESETS = {
        'tier': {
            name: 'By Tier (T0/T1/T2)',
            description: 'Core → Architecture → External',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'family': {
            name: 'By Atom Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'layer': {
            name: 'By Layer',
            description: 'Physical → Virtual → Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'ring': {
            name: 'By Ring (Domain)',
            description: 'Domain architecture layers',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'file': {
            name: 'By File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'flow': {
            name: 'Markov Flow',
            description: 'Edge width = transition probability',
            colorBy: 'tier',
            sizeBy: 'entropy',
            edgeBy: 'weight'
        },
        'depth': {
            name: 'By Depth (Call Distance)',
            description: 'Distance from entry points',
            colorBy: 'depth',
            sizeBy: 'fanout',
            edgeBy: 'type'
        }
        // NOTE: Color schemes (viridis, plasma, thermal, etc.) are now in color-engine.js schemePaths
        // Access via COLOR.listSchemes(), COLOR.applyScheme(), COLOR.getSchemeColor()
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        SCALE_16_LEVELS,
        THREE_LAYERS,
        SMC_THEORY,
        LEVEL_ZONES,
        VIS_PRESETS,

        // Convenience getters
        getLevel: (id) => SCALE_16_LEVELS[id],
        getLayer: (id) => THREE_LAYERS[id],
        getZone: (id) => LEVEL_ZONES[id],
        getPreset: (id) => VIS_PRESETS[id],

        // Theory content accessors (for tooltips)
        getTheoryContent: (category, key) => SMC_THEORY[category]?.[key],
        getLayerTheory: (key) => SMC_THEORY.layers[key],
        getFamilyTheory: (key) => SMC_THEORY.families[key],
        getTierTheory: (key) => SMC_THEORY.tiers[key],
        getSpecialTheory: (key) => SMC_THEORY.special[key]
    };
})();

// =========================================================================
// BACKWARD COMPATIBILITY SHIMS
// =========================================================================

window.SCALE_16_LEVELS = THEORY.SCALE_16_LEVELS;
window.THREE_LAYERS = THEORY.THREE_LAYERS;
window.SMC_THEORY = THEORY.SMC_THEORY;
window.LEVEL_ZONES = THEORY.LEVEL_ZONES;
window.VIS_PRESETS = THEORY.VIS_PRESETS;

console.log('[Module] THEORY loaded - 5 constants, 8 accessors');


// ═══ MODULE: modules/node-accessors.js ═══
/**
 * NODE ACCESSORS MODULE
 *
 * Provides standardized access to node properties across the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   NODE.getTier(node)       // Returns 'T0', 'T1', 'T2', or 'UNKNOWN'
 *   NODE.getFamily(node)     // Returns 'LOG', 'DAT', 'ORG', 'EXE', 'EXT', or 'UNKNOWN'
 *   NODE.getRing(node)       // Returns ring/layer value
 *   NODE.getLayer(node)      // Returns D2_LAYER value
 *   NODE.getEffect(node)     // Returns D6_EFFECT value
 */

const NODE = (function() {
    'use strict';

    // =========================================================================
    // TIER SYSTEM
    // =========================================================================

    // Tier aliases: legacy names -> canonical T0/T1/T2
    const TIER_ALIASES = {
        'CORE': 'T0', 'T0': 'T0',
        'ARCH': 'T1', 'T1': 'T1',
        'EXT': 'T2', 'T2': 'T2',
        'DISCOVERED': 'T2',  // EXT.DISCOVERED -> T2
        'UNKNOWN': 'UNKNOWN'
    };

    function normalizeTier(tier) {
        if (!tier) return 'UNKNOWN';
        const upper = String(tier).toUpperCase();
        return TIER_ALIASES[upper] || upper;
    }

    // Prefer canonical node.tier field; fallback to atom prefix inference
    function getTier(node) {
        // If node is a string (backward compat: called with atomId), infer from prefix
        if (typeof node === 'string') {
            const atomId = node;
            if (!atomId) return 'UNKNOWN';
            if (atomId.startsWith('CORE.')) return 'T0';
            if (atomId.startsWith('ARCH.')) return 'T1';
            if (atomId.startsWith('EXT.')) return 'T2';
            return 'UNKNOWN';
        }
        // Prefer canonical field
        if (node.tier) {
            return normalizeTier(node.tier);
        }
        // Fallback: infer from atom prefix
        const atomId = String(node.atom || '');
        if (atomId.startsWith('CORE.')) return 'T0';
        if (atomId.startsWith('ARCH.')) return 'T1';
        if (atomId.startsWith('EXT.')) return 'T2';
        return 'UNKNOWN';
    }

    // =========================================================================
    // FAMILY SYSTEM
    // =========================================================================

    // Get atom family from canonical field or infer from atom prefix
    function getFamily(node) {
        // Prefer canonical field
        if (node.atom_family) {
            return String(node.atom_family).toUpperCase();
        }
        // Fallback: infer from atom (e.g., "LOG.FNC.M" -> "LOG")
        const atomId = String(node.atom || '');
        const dotIdx = atomId.indexOf('.');
        if (dotIdx > 0) {
            return atomId.substring(0, dotIdx).toUpperCase();
        }
        return 'UNKNOWN';
    }

    // =========================================================================
    // RING SYSTEM
    // =========================================================================

    function normalizeRing(value) {
        if (value === null || value === undefined) return null;
        const ring = String(value).trim().toUpperCase();
        if (!ring) return null;
        const aliases = {
            TEST: 'TESTING'
        };
        return aliases[ring] || ring;
    }

    function getRing(node) {
        const ring = node.ring || node.layer || 'UNKNOWN';
        return normalizeRing(ring) || 'UNKNOWN';
    }

    // =========================================================================
    // LAYER SYSTEM (D2_LAYER)
    // =========================================================================

    function getLayer(node) {
        if (!node) return 'Unknown';
        return node.layer || node.dimensions?.D2_LAYER || 'Unknown';
    }

    // =========================================================================
    // EFFECT SYSTEM (D6_EFFECT)
    // =========================================================================

    function getEffect(node) {
        if (!node) return 'Unknown';
        return node.effect || node.dimensions?.D6_EFFECT || 'Unknown';
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Tier
        getTier,
        normalizeTier,
        TIER_ALIASES,

        // Family
        getFamily,

        // Ring
        getRing,
        normalizeRing,

        // Layer
        getLayer,

        // Effect
        getEffect
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'getNodeTier', { get: () => NODE.getTier, configurable: true });
Object.defineProperty(window, 'getNodeAtomFamily', { get: () => NODE.getFamily, configurable: true });
Object.defineProperty(window, 'getNodeRing', { get: () => NODE.getRing, configurable: true });
Object.defineProperty(window, 'getNodeLayer', { get: () => NODE.getLayer, configurable: true });
Object.defineProperty(window, 'getNodeEffect', { get: () => NODE.getEffect, configurable: true });
Object.defineProperty(window, 'normalizeTier', { get: () => NODE.normalizeTier, configurable: true });
Object.defineProperty(window, 'normalizeRingValue', { get: () => NODE.normalizeRing, configurable: true });
Object.defineProperty(window, 'TIER_ALIASES', { get: () => NODE.TIER_ALIASES, configurable: true });


// ═══ MODULE: modules/node-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * NODE-HELPERS MODULE - Node classification and color functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node color mode selection, data enrichment helpers, and tier grouping.
 * Depends on: COLOR (ColorOrchestrator), NODE (node-accessors), DM, Graph
 *
 * @module NODE_HELPERS
 * @version 1.0.0
 */

window.NODE_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR BY MODE
    // ═══════════════════════════════════════════════════════════════════════

    // =========================================================================
    // MODE_ACCESSORS: Declarative map replacing the mega-switch
    // Each mode maps to a function: (node, Color) => colorString
    // =========================================================================

    const MODE_ACCESSORS = {
        // 1. ARCHITECTURE
        tier:           (n, C) => C.get('tier', window.getNodeTier(n)),
        layer:          (n, C) => C.get('layer', (n.layer || n.dimensions?.D2_LAYER || 'UNKNOWN').toUpperCase()),
        subsystem:      (n, C) => C.get('subsystem', getSubsystem(n)),
        boundary_score: (n, C) => C.getInterval('boundary_score', window.normalize(n.rpbl?.boundary ?? 1, 9)),
        phase:          (n, C) => C.get('phase', getPhase(n)),

        // 2. TAXONOMY
        atom:           (n, C) => C.get('atom', (n.kind || n.type || 'unknown').toLowerCase()),
        family:         (n, C) => C.get('family', window.getNodeAtomFamily(n)),
        role:           (n, C) => C.get('roleCategory', n.role_cat || 'Unknown'),
        roleCategory:   (n, C) => C.get('roleCategory', n.role_cat || getRoleCategory(n)),
        fileType:       (n, C) => C.get('fileType', getFileType(n)),

        // 3. METRICS
        complexity:     (n, C) => C.getInterval('complexity', window.normalize(n.complexity || 0, 20)),
        loc:            (n, C) => C.getInterval('loc', window.normalize(n.lines_of_code || 0, 500)),
        fan_in:         (n, C) => C.getInterval('fan_in', window.normalize(n.in_degree || 0, 20)),
        fan_out:        (n, C) => C.getInterval('fan_out', window.normalize(n.out_degree || 0, 20)),
        trust:          (n, C) => C.getInterval('trust', n.trust || n.confidence || 0),

        // 4. RPBL DNA
        responsibility: (n, C) => C.getInterval('responsibility', window.normalize(n.rpbl?.responsibility ?? 1, 9)),
        purity:         (n, C) => C.getInterval('purity', window.normalize(n.rpbl?.purity ?? 1, 9)),
        lifecycle_score:(n, C) => C.getInterval('lifecycle_score', window.normalize(n.rpbl?.lifecycle ?? 1, 9)),
        state:          (n, C) => C.get('state', (n.dimensions?.D5_STATE === 'Stateful') ? 'Stateful' : 'Stateless'),
        visibility:     (n, C) => C.get('visibility', n.dimensions?.D4_BOUNDARY === 'External' ? 'Public' : 'Private'),

        // 5. TOPOLOGY
        centrality:     (n, C) => C.getInterval('centrality', n.centrality || 0),
        rank:           (n, C) => C.getInterval('centrality', n.pagerank || 0),
        ring:           (n, C) => C.get('ring', window.getNodeRing(n)),

        // 6. EVOLUTION (Placeholders)
        churn:          (n, C) => C.getInterval('churn', Math.random() * 0.5),
        age:            (n, C) => C.getInterval('churn', 0.2)
    };

    function getNodeColorByMode(node) {
        const Color = window.Color;
        const NODE_COLOR_MODE = window.NODE_COLOR_MODE;
        const DM = window.DM;

        // Special case: file coloring needs extra context
        if (NODE_COLOR_MODE === 'file') {
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx < 0) return Color.get('tier', 'UNKNOWN');
            const fileBoundaries = DM ? DM.getFileBoundaries() : [];
            const totalFiles = fileBoundaries.length;
            const fileInfo = fileBoundaries[fileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            return window.getFileColor(fileIdx, totalFiles, fileLabel);
        }

        // Use MODE_ACCESSORS map - O(1) lookup instead of if-chain
        const accessor = MODE_ACCESSORS[NODE_COLOR_MODE];
        if (accessor) return accessor(node, Color);

        // Default fallback
        return Color.get('tier', window.getNodeTier(node));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA ENRICHMENT HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getSubsystem(node) {
        if (!node.file_path) return 'Unknown';
        if (node.file_path.includes('/api/')) return 'Ingress';
        if (node.file_path.includes('/db/') || node.file_path.includes('repository')) return 'Persistence';
        if (node.file_path.includes('/core/') || node.file_path.includes('domain')) return 'Domain';
        if (node.file_path.includes('/ui/') || node.file_path.includes('frontend')) return 'Presentation';
        if (node.file_path.includes('config')) return 'Config';
        return 'Domain';
    }

    function getPhase(node) {
        const kind = (node.kind || '').toLowerCase();
        if (kind.includes('data') || kind.includes('entity') || kind.includes('schema')) return 'DATA';
        if (kind.includes('function') || kind.includes('logic')) return 'LOGIC';
        if (kind.includes('module') || kind.includes('package')) return 'ORGANIZATION';
        if (kind.includes('script') || kind.includes('main')) return 'EXECUTION';
        return 'LOGIC';
    }

    function getFileType(node) {
        const p = node.file_path || node.id || '';
        const ext = p.split('.').pop().toLowerCase();
        return ext || 'unknown';
    }

    function getRoleCategory(node) {
        const r = (node.role || '').toLowerCase();
        if (r.includes('service') || r.includes('manager')) return 'Orchestration';
        if (r.includes('repo') || r.includes('store')) return 'Storage';
        if (r.includes('controller') || r.includes('handler')) return 'Ingress';
        if (r.includes('util') || r.includes('helper')) return 'Utility';
        return 'Unknown';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR APPLICATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeColors(nodes) {
        const DM = window.DM;
        const fileBoundaries = DM ? DM.getFileBoundaries() : [];
        nodes.forEach(node => {
            if (node && node.isFileNode) {
                if (!node.color) {
                    const totalFiles = fileBoundaries.length;
                    const fileInfo = fileBoundaries[node.fileIdx] || {};
                    const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                    node.color = window.getFileColor(node.fileIdx, totalFiles, fileLabel);
                }
                return;
            }
            if (window.fileMode) {
                return;
            }
            node.color = getNodeColorByMode(node);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SIZE MODE
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeSizeMode(mode) {
        const Graph = window.Graph;
        if (!Graph) return;
        const scale = window.APPEARANCE_STATE?.nodeScale || 1;
        switch (mode) {
            case 'uniform':
                Graph.nodeVal(() => 1 * scale);
                break;
            case 'degree':
                Graph.nodeVal(n => Math.max(1, ((n.in_degree || 0) + (n.out_degree || 0)) * 0.5) * scale);
                break;
            case 'fanout':
                Graph.nodeVal(n => (n.val || n.fanout || 1) * scale);
                break;
            case 'complexity':
                Graph.nodeVal(n => Math.max(1, (n.complexity || n.loc || 10) * 0.05) * scale);
                break;
            default:
                Graph.nodeVal(n => (n.val || 1) * scale);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER/DEPTH/SIMILARITY HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNodeTierValue(node) {
        if (!node) return 1;
        const tier = window.getNodeTier(node);
        if (tier === 'T0') return 0;
        if (tier === 'T1') return 1;
        if (tier === 'T2') return 2;
        return 1;
    }

    function getNodeDepth(node) {
        if (node && typeof node.y === 'number') {
            return Math.abs(node.y) / 500;
        }
        return 0.5;
    }

    function getSemanticSimilarity(srcNode, tgtNode) {
        if (!srcNode || !tgtNode) return 0.5;
        let score = 0;
        if (srcNode.type === tgtNode.type) score += 0.4;
        if (srcNode.fileIdx === tgtNode.fileIdx) score += 0.3;
        if (window.getNodeTier(srcNode) === window.getNodeTier(tgtNode)) score += 0.2;
        if (srcNode.ring === tgtNode.ring) score += 0.1;
        return score;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER GROUPING
    // ═══════════════════════════════════════════════════════════════════════

    function groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = window.getNodeTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getColorByMode: getNodeColorByMode,
        getSubsystem: getSubsystem,
        getPhase: getPhase,
        getFileType: getFileType,
        getRoleCategory: getRoleCategory,
        applyColors: applyNodeColors,
        applySizeMode: applyNodeSizeMode,
        getTierValue: getNodeTierValue,
        getDepth: getNodeDepth,
        getSemanticSimilarity: getSemanticSimilarity,
        groupByTier: groupNodesByTier
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getNodeColorByMode = NODE_HELPERS.getColorByMode;
window.getSubsystem = NODE_HELPERS.getSubsystem;
window.getPhase = NODE_HELPERS.getPhase;
window.getFileType = NODE_HELPERS.getFileType;
window.getRoleCategory = NODE_HELPERS.getRoleCategory;
window.applyNodeColors = NODE_HELPERS.applyColors;
window.applyNodeSizeMode = NODE_HELPERS.applySizeMode;
window.getNodeTierValue = NODE_HELPERS.getTierValue;
window.getNodeDepth = NODE_HELPERS.getDepth;
window.getSemanticSimilarity = NODE_HELPERS.getSemanticSimilarity;
window.groupNodesByTier = NODE_HELPERS.groupByTier;

console.log('[Module] NODE_HELPERS loaded - 11 functions');


// ═══ MODULE: modules/color-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * COLOR-HELPERS MODULE - Color utilities and conversions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Topology colors, color normalization, file hue generation.
 * Depends on: UTILS (parseOklchString, hashToUnit, clampValue), COLOR (oklchColor)
 *
 * @module COLOR_HELPERS
 * @version 1.0.0
 */

window.COLOR_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // TOPOLOGY COLOR LOOKUP
    // ═══════════════════════════════════════════════════════════════════════

    function getTopoColor(category, key) {
        const APPEARANCE_CONFIG = window.APPEARANCE_CONFIG;
        if (!APPEARANCE_CONFIG || !APPEARANCE_CONFIG.color) return { l: 50, c: 0, h: 0 };

        let tokenKey = key;
        let section = 'atom-family'; // Default

        // Map legacy/UI keys to Token keys
        if (category === 'tiers') {
            section = 'atom';
            if (key === 'T0') tokenKey = 't0-core';
            else if (key === 'T1') tokenKey = 't1-arch';
            else if (key === 'T2') tokenKey = 't2-eco';
            else if (key === 'UNKNOWN') tokenKey = 'unknown';
        } else if (category === 'rings') {
            section = 'ring';
            if (key === 'KERNEL') tokenKey = 'DOMAIN';
            if (key === 'CORE') tokenKey = 'APPLICATION';
            if (key === 'SERVICE') tokenKey = 'PRESENTATION';
            if (key === 'ADAPTER') tokenKey = 'INTERFACE';
        } else if (category === 'families') {
            section = 'atom-family';
        }

        // Lookup token
        const tokenStr = APPEARANCE_CONFIG.color[section]?.[tokenKey] || APPEARANCE_CONFIG.color[section]?.['UNKNOWN'];

        // Parse OKLCH
        const parsed = window.parseOklchString(tokenStr);
        if (!parsed) return { l: 50, c: 0, h: 0 }; // Fallback gray

        // Normalize to internal l,c,h format (lowercase)
        return { l: parsed.L * 100, c: parsed.C, h: parsed.H };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLOR NORMALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeColorInput(color, fallback = 'rgb(128, 128, 128)') {
        if (color === null || color === undefined) {
            return fallback;
        }
        if (typeof color !== 'string') {
            return color;
        }
        const parsed = window.parseOklchString(color);
        if (parsed) {
            return window.oklchColor(parsed.L, parsed.C, parsed.H, parsed.A);
        }
        return color;
    }

    function toColorNumber(color, fallback = '#777777') {
        // Returns CSS hex string (polished-compatible) instead of JS hex int
        if (typeof color === 'number') {
            return '#' + color.toString(16).padStart(6, '0');
        }
        if (typeof color !== 'string') {
            return fallback;
        }
        const normalized = normalizeColorInput(color);
        if (typeof normalized === 'string') {
            color = normalized;
        }
        if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl')) {
            return color;  // Already valid CSS color
        }
        try {
            const hex = new THREE.Color(color).getHex();
            return '#' + hex.toString(16).padStart(6, '0');
        } catch (err) {
            return fallback;
        }
    }

    function dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILE COLOR GENERATION
    // ═══════════════════════════════════════════════════════════════════════

    function getFileHue(fileIdx, totalFiles, fileName) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const strategy = FILE_COLOR_CONFIG.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return window.hashToUnit(seed) * 360;
        }
        const angle = FILE_COLOR_CONFIG.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const COLOR_TWEAKS = window.COLOR_TWEAKS || {};
        const saturation = FILE_COLOR_CONFIG.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (FILE_COLOR_CONFIG.lightness ?? 50);
        const hue = getFileHue(fileIdx, totalFiles, fileName);
        if (typeof FILE_COLOR_CONFIG.chroma === 'number') {
            return window.oklchColor(lightness, FILE_COLOR_CONFIG.chroma, hue);
        }
        const adjustedHue = hue + (COLOR_TWEAKS.hueShift || 0);
        const adjustedLightness = window.clampValue(lightness + (COLOR_TWEAKS.lightnessShift || 0), 0, 100);
        return `hsl(${adjustedHue}, ${saturation}%, ${adjustedLightness}%)`;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getTopoColor: getTopoColor,
        normalizeInput: normalizeColorInput,
        toNumber: toColorNumber,
        dim: dimColor,
        getFileHue: getFileHue,
        getFileColor: getFileColor
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getTopoColor = COLOR_HELPERS.getTopoColor;
window.normalizeColorInput = COLOR_HELPERS.normalizeInput;
window.toColorNumber = COLOR_HELPERS.toNumber;
window.dimColor = COLOR_HELPERS.dim;
window.getFileHue = COLOR_HELPERS.getFileHue;
window.getFileColor = COLOR_HELPERS.getFileColor;

console.log('[Module] COLOR_HELPERS loaded - 6 functions');


// ═══ MODULE: modules/color-engine.js ═══
/**
 * COLOR ENGINE MODULE
 *
 * Centralized Color Intelligence System using OKLCH color space.
 * Single source of truth for ALL colors in the visualization.
 * Everything reads from here. OKLCH transforms apply here.
 *
 * Usage:
 *   COLOR.get('tier', 'T0')              // Get hex color for tier T0
 *   COLOR.getInterval('markov', 0.5)     // Get interpolated color
 *   COLOR.setTransform('hueShift', 30)   // Shift all hues by 30 degrees
 *   COLOR.subscribe(callback)            // React to transform changes
 */

const COLOR = (function () {
    'use strict';

    // =========================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =========================================================================

    const palette = {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        atom: {
            // Function-like (Green-Cyan)
            'function': { h: 160, c: 0.20, l: 0.65, label: 'Function', semantic: 'logic' },
            'method': { h: 175, c: 0.20, l: 0.62, label: 'Method', semantic: 'logic' },
            'closure': { h: 190, c: 0.20, l: 0.60, label: 'Closure', semantic: 'logic' },
            // Class-like (Blue-Purple)
            'class': { h: 260, c: 0.22, l: 0.60, label: 'Class', semantic: 'structure' },
            'interface': { h: 280, c: 0.20, l: 0.65, label: 'Interface', semantic: 'abstraction' },
            'struct': { h: 240, c: 0.20, l: 0.60, label: 'Struct', semantic: 'data' },
            // Module/Package (Orange-Yellow)
            'module': { h: 45, c: 0.22, l: 0.70, label: 'Module', semantic: 'container' },
            'package': { h: 30, c: 0.24, l: 0.65, label: 'Package', semantic: 'container' },
            // Variables/Fields (Pink-Red)
            'variable': { h: 340, c: 0.18, l: 0.65, label: 'Variable', semantic: 'state' },
            'field': { h: 350, c: 0.18, l: 0.62, label: 'Field', semantic: 'state' },
            // Unknown
            'unknown': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        roleCategory: {
            'Query': { h: 190, c: 0.20, l: 0.65, label: 'Query', semantic: 'read' },         // Cyan
            'Command': { h: 25, c: 0.24, l: 0.60, label: 'Command', semantic: 'write' },     // Orange/Red
            'Factory': { h: 280, c: 0.22, l: 0.60, label: 'Factory', semantic: 'create' },   // Purple
            'Storage': { h: 140, c: 0.20, l: 0.65, label: 'Storage', semantic: 'persist' },  // Green
            'Orchestration': { h: 240, c: 0.22, l: 0.60, label: 'Orchestration', semantic: 'manage' }, // Blue
            'Validation': { h: 45, c: 0.24, l: 0.70, label: 'Validation', semantic: 'check' }, // Yellow
            'Transform': { h: 320, c: 0.20, l: 0.60, label: 'Transform', semantic: 'change' }, // Pink
            'Event': { h: 260, c: 0.22, l: 0.65, label: 'Event', semantic: 'async' },        // Violet
            'Utility': { h: 200, c: 0.10, l: 0.70, label: 'Utility', semantic: 'helper' },   // Light Blue
            'Internal': { h: 0, c: 0.00, l: 0.60, label: 'Internal', semantic: 'private' },  // Gray
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        subsystem: {
            'Ingress': { h: 220, c: 0.24, l: 0.60, label: 'Ingress', semantic: 'entry' },
            'Egress': { h: 20, c: 0.24, l: 0.60, label: 'Egress', semantic: 'exit' },
            'Domain': { h: 260, c: 0.24, l: 0.55, label: 'Domain Core', semantic: 'core' },
            'Persistence': { h: 142, c: 0.22, l: 0.65, label: 'Persistence', semantic: 'store' },
            'Async': { h: 300, c: 0.22, l: 0.60, label: 'Async', semantic: 'bg' },
            'Presentation': { h: 190, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'ui' },
            'Security': { h: 0, c: 0.26, l: 0.55, label: 'Security', semantic: 'guard' },
            'Observability': { h: 60, c: 0.22, l: 0.75, label: 'Observability', semantic: 'monitor' },
            'Config': { h: 290, c: 0.18, l: 0.65, label: 'config', semantic: 'setup' },
            'Delivery': { h: 30, c: 0.20, l: 0.70, label: 'Delivery', semantic: 'ops' },
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        phase: {
            'DATA': { h: 142, c: 0.22, l: 0.65, label: 'Data', semantic: 'structure' },
            'LOGIC': { h: 240, c: 0.24, l: 0.60, label: 'Logic', semantic: 'flow' },
            'ORGANIZATION': { h: 280, c: 0.22, l: 0.60, label: 'Organization', semantic: 'arch' },
            'EXECUTION': { h: 20, c: 0.26, l: 0.60, label: 'Execution', semantic: 'run' }
        },
        state: {
            'Stateless': { h: 220, c: 0.20, l: 0.70, label: 'Stateless', semantic: 'pure' }, // Light Blue
            'Stateful': { h: 20, c: 0.24, l: 0.60, label: 'Stateful', semantic: 'impure' }   // Orange
        },
        effect: {
            'Pure': { h: 142, c: 0.22, l: 0.70, label: 'Pure', semantic: 'safe' },          // Green
            'SideEffect': { h: 340, c: 0.22, l: 0.60, label: 'Side Effect', semantic: 'risk' } // Pink/Red
        },
        visibility: {
            'Public': { h: 220, c: 0.20, l: 0.65, label: 'Public', semantic: 'open' },
            'Private': { h: 0, c: 0.05, l: 0.55, label: 'Private', semantic: 'closed' },
            'Internal': { h: 280, c: 0.15, l: 0.60, label: 'Internal', semantic: 'module' }
        },
        fileType: {
            'js': { h: 60, c: 0.24, l: 0.70, label: 'JavaScript', semantic: 'code' },    // Yellow
            'ts': { h: 240, c: 0.22, l: 0.60, label: 'TypeScript', semantic: 'code' },    // Blue
            'py': { h: 220, c: 0.20, l: 0.62, label: 'Python', semantic: 'code' },        // Blue
            'go': { h: 190, c: 0.22, l: 0.68, label: 'Go', semantic: 'code' },            // Cyan
            'rs': { h: 30, c: 0.24, l: 0.60, label: 'Rust', semantic: 'code' },           // Orange
            'java': { h: 40, c: 0.24, l: 0.62, label: 'Java', semantic: 'code' },         // Orange/Red
            'c': { h: 210, c: 0.18, l: 0.60, label: 'C', semantic: 'code' },             // Blue
            'cpp': { h: 210, c: 0.20, l: 0.55, label: 'C++', semantic: 'code' },          // Blue
            'h': { h: 280, c: 0.16, l: 0.60, label: 'Header', semantic: 'code' },         // Purple
            'html': { h: 20, c: 0.25, l: 0.60, label: 'HTML', semantic: 'markup' },       // Orange
            'css': { h: 230, c: 0.24, l: 0.60, label: 'CSS', semantic: 'style' },         // Blue
            'json': { h: 60, c: 0.18, l: 0.75, label: 'JSON', semantic: 'data' },         // Yellow
            'yaml': { h: 300, c: 0.18, l: 0.65, label: 'YAML', semantic: 'config' },      // Magenta
            'md': { h: 0, c: 0.04, l: 0.70, label: 'Markdown', semantic: 'doc' },         // Gray
            'unknown': { h: 0, c: 0.02, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    };

    // =========================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =========================================================================

    const transform = {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    };

    // =========================================================================
    // INTERVAL MAPPINGS: For numeric data -> color gradients
    // =========================================================================

    const intervals = {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        },
        complexity: {
            stops: [
                { value: 0.0, h: 142, c: 0.18, l: 0.70 },  // Low complexity (0) - Green
                { value: 0.3, h: 100, c: 0.18, l: 0.75 },  // Moderate (5-10) - Yellow-Green
                { value: 0.6, h: 50, c: 0.20, l: 0.70 },   // High (10-20) - Orange
                { value: 1.0, h: 15, c: 0.24, l: 0.60 }    // Very High (20+) - Red
            ]
        },
        churn: {
            stops: [
                { value: 0.0, h: 230, c: 0.10, l: 0.45 },  // Stale/Cold - Blue
                { value: 0.5, h: 300, c: 0.14, l: 0.60 },  // Active - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // Hot - Orange/Red
            ]
        },
        loc: {
            stops: [
                { value: 0.0, h: 200, c: 0.10, l: 0.75 },  // Small - Light Blue
                { value: 0.3, h: 240, c: 0.18, l: 0.60 },  // Medium - Blue
                { value: 0.7, h: 280, c: 0.20, l: 0.50 },  // Large - Purple
                { value: 1.0, h: 320, c: 0.22, l: 0.40 }   // Massive - Dark Purple
            ]
        },
        trust: {
            stops: [
                { value: 0.0, h: 0, c: 0.24, l: 0.50 },    // Untrusted - Red
                { value: 0.5, h: 60, c: 0.20, l: 0.70 },   // Warning - Yellow
                { value: 1.0, h: 142, c: 0.22, l: 0.65 }   // Trusted - Green
            ]
        },
        responsibility: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Single Purpose (1) - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.75 },   // Moderate (5) - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // God Object (9) - Red
            ]
        },
        purity: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Pure (1) - Green
                { value: 0.5, h: 220, c: 0.18, l: 0.65 },  // Mixed (5) - Blue
                { value: 1.0, h: 320, c: 0.24, l: 0.55 }   // I/O Heavy (9) - Purple/Red
            ]
        },
        boundary_score: {
            stops: [
                { value: 0.0, h: 240, c: 0.15, l: 0.65 },  // Internal (1) - Blue
                { value: 0.5, h: 280, c: 0.18, l: 0.60 },  // Module (5) - Purple
                { value: 1.0, h: 20, c: 0.24, l: 0.60 }    // External API (9) - Orange
            ]
        },
        lifecycle_score: {
            stops: [
                { value: 0.0, h: 180, c: 0.15, l: 0.70 },  // Ephemeral (1) - Cyan
                { value: 0.5, h: 220, c: 0.18, l: 0.60 },  // Managed (5) - Blue
                { value: 1.0, h: 280, c: 0.22, l: 0.50 }   // Singleton (9) - Purple
            ]
        },
        centrality: {
            stops: [
                { value: 0.0, h: 240, c: 0.05, l: 0.40 },  // Periphery - Gray/Blue
                { value: 0.5, h: 280, c: 0.20, l: 0.60 },  // Bridge - Purple
                { value: 1.0, h: 340, c: 0.25, l: 0.65 }   // Core - Pink/Red
            ]
        },
        fan_in: {
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.65 },  // Low - Blue
                { value: 0.5, h: 300, c: 0.18, l: 0.60 },  // Med - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // High - Orange
            ]
        },
        fan_out: {
            stops: [
                { value: 0.0, h: 142, c: 0.15, l: 0.65 },  // Low - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.70 },   // Med - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // High - Red
            ]
        }
    };

    // =========================================================================
    // SCHEME PATHS: 33 Named Color Gradients (OKLCH 3D Paths)
    // Each scheme is a path through OKLCH color space mapping normalized values to colors
    // =========================================================================

    const schemePaths = {
        // =====================================================================
        // PART A: FAMOUS SCIENTIFIC GRADIENTS (15 schemes)
        // Source: matplotlib/viridis family - perceptually uniform
        // =====================================================================

        // === SEQUENTIAL (monotonic lightness) ===
        viridis: {
            name: 'Viridis',
            semantic: 'The gold standard - blue→green→yellow',
            stops: [
                { value: 0.0, h: 280, c: 0.12, l: 0.25 },  // Dark purple
                { value: 0.25, h: 240, c: 0.16, l: 0.40 }, // Blue
                { value: 0.5, h: 170, c: 0.18, l: 0.55 },  // Teal
                { value: 0.75, h: 120, c: 0.20, l: 0.70 }, // Green
                { value: 1.0, h: 65, c: 0.22, l: 0.90 }    // Yellow
            ]
        },
        plasma: {
            name: 'Plasma',
            semantic: 'Purple→pink→orange→yellow arc',
            stops: [
                { value: 0.0, h: 280, c: 0.15, l: 0.20 },  // Deep purple
                { value: 0.25, h: 300, c: 0.22, l: 0.40 }, // Magenta
                { value: 0.5, h: 340, c: 0.25, l: 0.55 },  // Pink-red
                { value: 0.75, h: 30, c: 0.28, l: 0.72 },  // Orange
                { value: 1.0, h: 60, c: 0.24, l: 0.92 }    // Bright yellow
            ]
        },
        magma: {
            name: 'Magma',
            semantic: 'Black→purple→orange→white (lava)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.08 },  // Near black
                { value: 0.25, h: 300, c: 0.18, l: 0.30 }, // Deep purple
                { value: 0.5, h: 340, c: 0.24, l: 0.50 },  // Magenta
                { value: 0.75, h: 30, c: 0.26, l: 0.75 },  // Orange
                { value: 1.0, h: 60, c: 0.08, l: 0.98 }    // Near white
            ]
        },
        inferno: {
            name: 'Inferno',
            semantic: 'Black→purple→red→yellow (fire)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.05 },  // Black
                { value: 0.2, h: 300, c: 0.16, l: 0.25 },  // Purple
                { value: 0.4, h: 350, c: 0.24, l: 0.45 },  // Red-purple
                { value: 0.6, h: 20, c: 0.28, l: 0.60 },   // Red-orange
                { value: 0.8, h: 50, c: 0.26, l: 0.78 },   // Orange-yellow
                { value: 1.0, h: 65, c: 0.18, l: 0.95 }    // Bright yellow
            ]
        },
        cividis: {
            name: 'Cividis',
            semantic: 'Blue→yellow (colorblind optimized)',
            stops: [
                { value: 0.0, h: 240, c: 0.10, l: 0.25 },  // Dark blue
                { value: 0.33, h: 220, c: 0.08, l: 0.45 }, // Steel blue
                { value: 0.66, h: 80, c: 0.08, l: 0.65 },  // Olive
                { value: 1.0, h: 60, c: 0.14, l: 0.88 }    // Yellow
            ]
        },
        turbo: {
            name: 'Turbo',
            semantic: 'Improved rainbow (no banding)',
            stops: [
                { value: 0.0, h: 260, c: 0.18, l: 0.35 },  // Blue-purple
                { value: 0.2, h: 210, c: 0.22, l: 0.55 },  // Cyan-blue
                { value: 0.4, h: 150, c: 0.24, l: 0.65 },  // Green
                { value: 0.6, h: 60, c: 0.26, l: 0.75 },   // Yellow
                { value: 0.8, h: 30, c: 0.28, l: 0.65 },   // Orange
                { value: 1.0, h: 0, c: 0.24, l: 0.50 }     // Red
            ]
        },
        mako: {
            name: 'Mako',
            semantic: 'Deep ocean blue→teal',
            stops: [
                { value: 0.0, h: 260, c: 0.08, l: 0.12 },  // Abyss
                { value: 0.33, h: 240, c: 0.14, l: 0.35 }, // Deep blue
                { value: 0.66, h: 200, c: 0.18, l: 0.58 }, // Ocean blue
                { value: 1.0, h: 170, c: 0.16, l: 0.82 }   // Light teal
            ]
        },
        rocket: {
            name: 'Rocket',
            semantic: 'Dark→red→white (heat)',
            stops: [
                { value: 0.0, h: 280, c: 0.06, l: 0.10 },  // Dark
                { value: 0.33, h: 340, c: 0.20, l: 0.35 }, // Purple-red
                { value: 0.66, h: 15, c: 0.26, l: 0.60 },  // Red-orange
                { value: 1.0, h: 30, c: 0.08, l: 0.95 }    // Near white
            ]
        },

        // === DIVERGING (center-outward) ===
        coolwarm: {
            name: 'Coolwarm',
            semantic: 'Blue↔neutral↔red (diverging)',
            stops: [
                { value: 0.0, h: 230, c: 0.22, l: 0.45 },  // Cool blue
                { value: 0.25, h: 220, c: 0.12, l: 0.60 }, // Light blue
                { value: 0.5, h: 0, c: 0.02, l: 0.75 },    // Neutral gray
                { value: 0.75, h: 20, c: 0.14, l: 0.60 },  // Light red
                { value: 1.0, h: 15, c: 0.24, l: 0.45 }    // Warm red
            ]
        },
        spectral: {
            name: 'Spectral',
            semantic: 'Full rainbow diverging',
            stops: [
                { value: 0.0, h: 10, c: 0.22, l: 0.50 },   // Red
                { value: 0.25, h: 40, c: 0.24, l: 0.70 },  // Orange-yellow
                { value: 0.5, h: 60, c: 0.20, l: 0.85 },   // Yellow (center)
                { value: 0.75, h: 140, c: 0.20, l: 0.65 }, // Green
                { value: 1.0, h: 240, c: 0.18, l: 0.50 }   // Blue
            ]
        },

        // === APPLICATION-SPECIFIC ===
        thermal: {
            name: 'Thermal',
            semantic: 'Cold→hot temperature map',
            stops: [
                { value: 0.0, h: 240, c: 0.18, l: 0.30 },  // Cold blue
                { value: 0.25, h: 200, c: 0.20, l: 0.45 }, // Cool cyan
                { value: 0.5, h: 60, c: 0.22, l: 0.65 },   // Warm yellow
                { value: 0.75, h: 30, c: 0.26, l: 0.58 },  // Hot orange
                { value: 1.0, h: 0, c: 0.28, l: 0.50 }     // Burning red
            ]
        },
        nightvision: {
            name: 'Night Vision',
            semantic: 'Phosphor green display',
            stops: [
                { value: 0.0, h: 140, c: 0.02, l: 0.05 },  // Black
                { value: 0.33, h: 140, c: 0.12, l: 0.25 }, // Dark green
                { value: 0.66, h: 130, c: 0.22, l: 0.55 }, // Bright green
                { value: 1.0, h: 120, c: 0.28, l: 0.85 }   // Glowing green
            ]
        },
        ocean: {
            name: 'Ocean',
            semantic: 'Bathymetry depth map',
            stops: [
                { value: 0.0, h: 250, c: 0.12, l: 0.15 },  // Abyss
                { value: 0.33, h: 230, c: 0.18, l: 0.35 }, // Deep
                { value: 0.66, h: 200, c: 0.20, l: 0.55 }, // Mid-depth
                { value: 1.0, h: 180, c: 0.16, l: 0.80 }   // Shallow
            ]
        },
        terrain: {
            name: 'Terrain',
            semantic: 'Water→land→mountain',
            stops: [
                { value: 0.0, h: 220, c: 0.16, l: 0.40 },  // Water blue
                { value: 0.3, h: 140, c: 0.18, l: 0.55 },  // Lowland green
                { value: 0.5, h: 80, c: 0.16, l: 0.60 },   // Plains yellow-green
                { value: 0.7, h: 40, c: 0.14, l: 0.50 },   // Hills brown
                { value: 1.0, h: 0, c: 0.04, l: 0.90 }     // Snow white
            ]
        },
        electric: {
            name: 'Electric',
            semantic: 'Neon cyberpunk glow',
            stops: [
                { value: 0.0, h: 280, c: 0.25, l: 0.30 },  // Deep purple
                { value: 0.33, h: 320, c: 0.30, l: 0.50 }, // Hot pink
                { value: 0.66, h: 190, c: 0.28, l: 0.65 }, // Electric cyan
                { value: 1.0, h: 60, c: 0.26, l: 0.85 }    // Neon yellow
            ]
        },

        // =====================================================================
        // PART B: ROLE-SEMANTIC GRADIENTS (18 schemes)
        // Named after canonical roles with meaningful color journeys
        // =====================================================================

        // === GROUP 1: QUERIES & ACCESS (Cool blues/cyans - passive reads) ===
        query: {
            name: 'Query',
            semantic: 'Retrieve data calmly',
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },  // Deep blue - start
                { value: 0.5, h: 200, c: 0.15, l: 0.55 },  // Sky blue - middle
                { value: 1.0, h: 190, c: 0.20, l: 0.70 }   // Light cyan - found
            ]
        },
        finder: {
            name: 'Finder',
            semantic: 'Search and seek',
            stops: [
                { value: 0.0, h: 200, c: 0.05, l: 0.35 },  // Dim - searching
                { value: 0.3, h: 180, c: 0.12, l: 0.50 },  // Teal - hunting
                { value: 0.7, h: 160, c: 0.18, l: 0.65 },  // Cyan-green - close
                { value: 1.0, h: 140, c: 0.24, l: 0.75 }   // Bright green - found!
            ]
        },

        // === GROUP 2: COMMANDS & MUTATIONS (Warm - active writes) ===
        command: {
            name: 'Command',
            semantic: 'Execute with authority',
            stops: [
                { value: 0.0, h: 30, c: 0.15, l: 0.45 },   // Amber ready
                { value: 0.5, h: 20, c: 0.22, l: 0.58 },   // Orange active
                { value: 1.0, h: 10, c: 0.28, l: 0.65 }    // Red-orange fired
            ]
        },
        creator: {
            name: 'Creator',
            semantic: 'Bring into existence',
            stops: [
                { value: 0.0, h: 180, c: 0.10, l: 0.40 },  // Seed teal
                { value: 0.4, h: 150, c: 0.18, l: 0.55 },  // Sprout green
                { value: 0.8, h: 120, c: 0.24, l: 0.68 },  // Growth lime
                { value: 1.0, h: 90, c: 0.28, l: 0.75 }    // Full bloom yellow-green
            ]
        },
        destroyer: {
            name: 'Destroyer',
            semantic: 'Remove from existence',
            stops: [
                { value: 0.0, h: 0, c: 0.08, l: 0.60 },    // Pale warning
                { value: 0.4, h: 10, c: 0.18, l: 0.50 },   // Red alert
                { value: 0.7, h: 350, c: 0.26, l: 0.40 },  // Crimson
                { value: 1.0, h: 340, c: 0.20, l: 0.25 }   // Dark destruction
            ]
        },

        // === GROUP 3: FACTORIES (Construction - blue→green) ===
        factory: {
            name: 'Factory',
            semantic: 'Assembly line production',
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.45 },  // Blueprint blue
                { value: 0.3, h: 200, c: 0.16, l: 0.55 },  // Processing
                { value: 0.6, h: 170, c: 0.20, l: 0.62 },  // Assembly
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Product green
            ]
        },

        // === GROUP 4: STORAGE (Solid, grounded - deep blues/purples) ===
        repository: {
            name: 'Repository',
            semantic: 'Deep data vault',
            stops: [
                { value: 0.0, h: 240, c: 0.12, l: 0.30 },  // Database depths
                { value: 0.5, h: 230, c: 0.18, l: 0.45 },  // Data layer
                { value: 1.0, h: 220, c: 0.22, l: 0.60 }   // Accessible
            ]
        },
        cache: {
            name: 'Cache',
            semantic: 'Fast temporary',
            stops: [
                { value: 0.0, h: 300, c: 0.08, l: 0.50 },  // Magenta flash
                { value: 0.5, h: 320, c: 0.16, l: 0.62 },  // Pink speed
                { value: 1.0, h: 340, c: 0.22, l: 0.75 }   // Hot pink hit
            ]
        },

        // === GROUP 5: ORCHESTRATION (Purple/magenta - control flow) ===
        service: {
            name: 'Service',
            semantic: 'Coordinate operations',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Purple quiet
                { value: 0.5, h: 280, c: 0.16, l: 0.55 },  // Active violet
                { value: 1.0, h: 290, c: 0.22, l: 0.68 }   // Bright orchid
            ]
        },
        orchestrator: {
            name: 'Orchestrator',
            semantic: 'See all, conduct all',
            stops: [
                { value: 0.0, h: 200, c: 0.12, l: 0.40 },  // Start blue
                { value: 0.25, h: 270, c: 0.18, l: 0.50 }, // Through purple
                { value: 0.5, h: 330, c: 0.22, l: 0.58 },  // To pink
                { value: 0.75, h: 30, c: 0.24, l: 0.62 },  // Through orange
                { value: 1.0, h: 60, c: 0.26, l: 0.70 }    // End gold (full spectrum)
            ]
        },

        // === GROUP 6: VALIDATION (Yellow/green - pass/fail semantics) ===
        validator: {
            name: 'Validator',
            semantic: 'Check and verify',
            stops: [
                { value: 0.0, h: 0, c: 0.20, l: 0.50 },    // Red fail
                { value: 0.4, h: 45, c: 0.22, l: 0.65 },   // Yellow warning
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Green pass
            ]
        },
        guard: {
            name: 'Guard',
            semantic: 'Protect and defend',
            stops: [
                { value: 0.0, h: 350, c: 0.18, l: 0.40 },  // Dark red blocked
                { value: 0.5, h: 30, c: 0.20, l: 0.55 },   // Orange caution
                { value: 1.0, h: 120, c: 0.22, l: 0.65 }   // Green allowed
            ]
        },

        // === GROUP 7: TRANSFORMATION (Rainbow arc - any to any) ===
        transformer: {
            name: 'Transformer',
            semantic: 'Complete metamorphosis',
            stops: [
                { value: 0.0, h: 220, c: 0.14, l: 0.45 },  // Blue input
                { value: 0.3, h: 280, c: 0.18, l: 0.52 },  // Purple process
                { value: 0.6, h: 340, c: 0.22, l: 0.58 },  // Pink transition
                { value: 1.0, h: 30, c: 0.26, l: 0.65 }    // Orange output
            ]
        },
        parser: {
            name: 'Parser',
            semantic: 'Decode from wire',
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.85 },    // White wire
                { value: 0.5, h: 180, c: 0.10, l: 0.70 },  // Decoding
                { value: 1.0, h: 160, c: 0.20, l: 0.55 }   // Data teal
            ]
        },

        // === GROUP 8: EVENTS (Signals - purple/yellow pulses) ===
        handler: {
            name: 'Handler',
            semantic: 'React to event',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Waiting purple
                { value: 0.5, h: 290, c: 0.18, l: 0.55 },  // Triggered
                { value: 1.0, h: 310, c: 0.26, l: 0.68 }   // Handling pink
            ]
        },
        emitter: {
            name: 'Emitter',
            semantic: 'Broadcast signal',
            stops: [
                { value: 0.0, h: 50, c: 0.18, l: 0.55 },   // Yellow charge
                { value: 0.5, h: 45, c: 0.24, l: 0.68 },   // Bright emit
                { value: 1.0, h: 40, c: 0.30, l: 0.78 }    // Golden broadcast
            ]
        },

        // === GROUP 9: UTILITIES (Neutral supporting - grays/pastels) ===
        utility: {
            name: 'Utility',
            semantic: 'General tool',
            stops: [
                { value: 0.0, h: 220, c: 0.04, l: 0.45 },  // Gray-blue tool
                { value: 0.5, h: 200, c: 0.08, l: 0.58 },  // Soft cyan
                { value: 1.0, h: 180, c: 0.12, l: 0.72 }   // Light teal
            ]
        },
        lifecycle: {
            name: 'Lifecycle',
            semantic: 'Birth to death cycle',
            stops: [
                { value: 0.0, h: 120, c: 0.20, l: 0.65 },  // Birth green
                { value: 0.25, h: 60, c: 0.22, l: 0.70 },  // Youth yellow
                { value: 0.5, h: 30, c: 0.24, l: 0.60 },   // Maturity orange
                { value: 0.75, h: 0, c: 0.20, l: 0.50 },   // Aging red
                { value: 1.0, h: 280, c: 0.10, l: 0.35 }   // Death purple
            ]
        },

        // =====================================================================
        // PART C: OKLCH GEOMETRY GENERATORS (Function-based paths)
        // These use mathematical functions instead of discrete stops.
        // Each has a `generator` function: (t) => { h, c, l }
        // =====================================================================

        // === LOOPS (Full 360° hue cycles) ===
        'rainbow-loop': {
            name: 'Rainbow Loop',
            semantic: 'Full hue circle at constant L/C',
            generator: (t) => ({
                h: t * 360,           // Full hue rotation
                c: 0.20,              // Constant chroma
                l: 0.65               // Constant lightness
            })
        },
        'rainbow-bright': {
            name: 'Rainbow Bright',
            semantic: 'Vivid rainbow with high chroma',
            generator: (t) => ({
                h: t * 360,
                c: 0.28,              // High chroma for vivid colors
                l: 0.70
            })
        },
        'rainbow-dark': {
            name: 'Rainbow Dark',
            semantic: 'Subdued rainbow for dark themes',
            generator: (t) => ({
                h: t * 360,
                c: 0.18,
                l: 0.45               // Lower lightness
            })
        },

        // === ARCS (Partial hue sweeps) ===
        'arc-warm': {
            name: 'Warm Arc',
            semantic: 'Red→Yellow→Orange (warm sector)',
            generator: (t) => ({
                h: 0 + t * 60,        // 0° to 60° (red to yellow)
                c: 0.24,
                l: 0.55 + t * 0.15    // Slight lightness increase
            })
        },
        'arc-cool': {
            name: 'Cool Arc',
            semantic: 'Cyan→Blue→Purple (cool sector)',
            generator: (t) => ({
                h: 180 + t * 100,     // 180° to 280° (cyan to purple)
                c: 0.22,
                l: 0.50 + t * 0.15
            })
        },
        'arc-nature': {
            name: 'Nature Arc',
            semantic: 'Green→Teal→Cyan (nature)',
            generator: (t) => ({
                h: 120 + t * 60,      // 120° to 180° (green to cyan)
                c: 0.20,
                l: 0.60 + t * 0.10
            })
        },

        // === SPIRALS (Hue + varying L or C) ===
        'spiral-up': {
            name: 'Spiral Up',
            semantic: 'Hue rotates as lightness increases',
            generator: (t) => ({
                h: t * 270,           // 3/4 hue rotation
                c: 0.18,
                l: 0.30 + t * 0.55    // Dark to light
            })
        },
        'spiral-down': {
            name: 'Spiral Down',
            semantic: 'Hue rotates as lightness decreases',
            generator: (t) => ({
                h: t * 270,
                c: 0.20,
                l: 0.85 - t * 0.55    // Light to dark
            })
        },
        'spiral-chroma': {
            name: 'Spiral Chroma',
            semantic: 'Hue rotates as saturation increases',
            generator: (t) => ({
                h: t * 360,
                c: 0.06 + t * 0.22,   // Gray to vivid
                l: 0.60
            })
        },

        // === SINUSOIDAL (Wave patterns) ===
        'wave-lightness': {
            name: 'Wave Lightness',
            semantic: 'Sinusoidal lightness oscillation',
            generator: (t) => ({
                h: t * 180,           // Half hue rotation
                c: 0.20,
                l: 0.50 + Math.sin(t * Math.PI * 2) * 0.20  // Wave between 0.30 and 0.70
            })
        },
        'wave-chroma': {
            name: 'Wave Chroma',
            semantic: 'Sinusoidal saturation oscillation',
            generator: (t) => ({
                h: t * 180,
                c: 0.15 + Math.sin(t * Math.PI * 2) * 0.12, // Wave between 0.03 and 0.27
                l: 0.60
            })
        },
        'pulse': {
            name: 'Pulse',
            semantic: 'Both L and C oscillate together',
            generator: (t) => {
                const wave = Math.sin(t * Math.PI * 3); // 1.5 full waves
                return {
                    h: t * 120,       // Partial hue sweep
                    c: 0.15 + wave * 0.10,
                    l: 0.55 + wave * 0.15
                };
            }
        },

        // === LINEAR RAMPS (Simple mathematical paths) ===
        'ramp-hue': {
            name: 'Hue Ramp',
            semantic: 'Pure hue change, constant L/C',
            generator: (t) => ({
                h: 220 + t * 140,     // Blue to pink (220° to 360°)
                c: 0.22,
                l: 0.60
            })
        },
        'ramp-lightness': {
            name: 'Lightness Ramp',
            semantic: 'Dark to light, constant H/C',
            generator: (t) => ({
                h: 220,               // Fixed blue
                c: 0.18,
                l: 0.25 + t * 0.60    // 0.25 to 0.85
            })
        },
        'ramp-chroma': {
            name: 'Chroma Ramp',
            semantic: 'Gray to vivid, constant H/L',
            generator: (t) => ({
                h: 280,               // Fixed purple
                c: 0.02 + t * 0.26,   // 0.02 to 0.28
                l: 0.60
            })
        },

        // === SPECIAL GEOMETRIC PATHS ===
        'helix': {
            name: 'Helix',
            semantic: 'Full 3D path through OKLCH cylinder',
            generator: (t) => ({
                h: t * 540,           // 1.5 hue rotations
                c: 0.10 + t * 0.15,   // Increasing chroma
                l: 0.30 + t * 0.50    // Rising lightness
            })
        },
        'convergent': {
            name: 'Convergent',
            semantic: 'Colors converge toward gray',
            generator: (t) => ({
                h: t * 180,           // Half rotation
                c: 0.26 * (1 - t),    // Chroma decreases to 0
                l: 0.55
            })
        },
        'divergent': {
            name: 'Divergent',
            semantic: 'Colors diverge from gray',
            generator: (t) => ({
                h: 180 + t * 180,     // Second half of hue wheel
                c: 0.26 * t,          // Chroma increases from 0
                l: 0.55
            })
        },
        'bicone': {
            name: 'Bicone',
            semantic: 'Center peak, edges dark (HSL-like)',
            generator: (t) => {
                // Lightness peaks at center, dark at edges
                const l = t < 0.5 ? 0.30 + t * 0.70 : 0.65 - (t - 0.5) * 0.70;
                return {
                    h: t * 360,
                    c: 0.20,
                    l: Math.max(0.30, l)
                };
            }
        }
    };

    // Current active scheme
    let _activeScheme = null;

// =========================================================================
// SUBSCRIBERS: Reactive notifications
// =========================================================================

let _subscribers = [];

function subscribe(callback) {
    _subscribers.push(callback);
    return () => {
        _subscribers = _subscribers.filter(cb => cb !== callback);
    };
}

function _notifySubscribers(event, data) {
    _subscribers.forEach(cb => cb(event, data));
}

// =========================================================================
// OKLCH -> HEX CONVERSION
// =========================================================================

function _toHex(oklch) {
    const { h, c, l } = oklch;

    // Convert OKLCH to approximate RGB
    const hRad = h * Math.PI / 180;
    const a = c * Math.cos(hRad);
    const b = c * Math.sin(hRad);

    // Simplified OKLab to linear RGB (approximate)
    const L = l;
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    const l3 = l_ * l_ * l_;
    const m3 = m_ * m_ * m_;
    const s3 = s_ * s_ * s_;

    let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
    let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
    let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

    // Clamp and convert to sRGB
    const toSRGB = (x) => {
        x = Math.max(0, Math.min(1, x));
        return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
    };

    r = Math.round(toSRGB(r) * 255);
    g = Math.round(toSRGB(g) * 255);
    bl = Math.round(toSRGB(bl) * 255);

    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    bl = Math.max(0, Math.min(255, bl));

    return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
}

function _applyTransform(oklch) {
    const t = transform;

    // Apply transforms
    let h = (oklch.h + t.hueShift + 360) % 360;
    let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
    let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

    // Apply amplifier to chroma for contrast
    if (t.amplifier !== 1) {
        c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
    }

    return _toHex({ h, c, l });
}

// =========================================================================
// CORE API
// =========================================================================

/**
 * Get color with transforms applied
 * @param {string} dimension - Palette dimension (tier, family, ring, layer, edgeType)
 * @param {string} category - Category within dimension
 * @returns {string} Hex color string
 */
function get(dimension, category) {
    const base = palette[dimension]?.[category];
    if (!base) return _toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray
    return _applyTransform(base);
}

/**
 * Get color for a numeric value using interval mapping
 * @param {string} intervalName - Interval name (markov, weight, confidence)
 * @param {number} value - Value (0-1)
 * @returns {string} Hex color string
 */
function getInterval(intervalName, value) {
    const v = Math.max(0, Math.min(1, value));

    // =========================================================================
    // SCHEME OVERRIDE: If an active scheme is selected, use it for ALL intervals
    // This makes the 33 named schemes (viridis, plasma, thermal, etc.) work
    // =========================================================================
    if (_activeScheme && schemePaths[_activeScheme]) {
        return getSchemeColor(_activeScheme, v);
    }

    // Fall back to hardcoded interval if no scheme active
    const interval = intervals[intervalName];
    if (!interval) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const stops = interval.stops;

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const t = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * t,
        c: lower.c + (upper.c - lower.c) * t,
        l: lower.l + (upper.l - lower.l) * t
    };

    return _applyTransform(interpolated);
}

/**
 * Interpolate between two hex colors in OKLCH space
 * @param {string} color1 - Hex color 1
 * @param {string} color2 - Hex color 2
 * @param {number} t - Interpolation factor (0-1)
 * @returns {string} Hex result
 */
function interpolate(color1, color2, t) {
    // We assume input hexes can be approximated back to OKLCH or treated as sRGB->OKLCH
    // For simplicity in this engine which mostly generates from OKLCH, we'll assume
    // specific OKLCH-derived palettes unless provided raw hex.
    // If we really need robust hex->oklch, we need a converter.
    // BUT, for edge gradients in app.js, we often have raw HSL or OKLCH objects.
    // Let's support passing Objects {h,c,l} or hex strings (naive interpolation for hex if needed).
    // Best approach: app.js should use COLOR.get() to get objects if possible, or we expose a helper
    // that takes our internal palette objects.

    // Actually, let's keep it simple: assume app.js will partial refactoring.
    // We will accept object {h,c,l} inputs for maximum precision.
    const c1 = (typeof color1 === 'string') ? parseOklchString(color1) || { h: 0, c: 0, l: 0.5 } : color1;
    const c2 = (typeof color2 === 'string') ? parseOklchString(color2) || { h: 0, c: 0, l: 0.5 } : color2;

    t = Math.max(0, Math.min(1, t));

    // Shortest path hue interpolation
    let h1 = c1.h || c1.H || 0;
    let h2 = c2.h || c2.H || 0;
    let dh = h2 - h1;
    if (Math.abs(dh) > 180) {
        if (dh > 0) h1 += 360;
        else h2 += 360;
    }

    const h = (h1 + (h2 - h1) * t) % 360;
    const c = (c1.c !== undefined ? c1.c : c1.C) + ((c2.c !== undefined ? c2.c : c2.C) - (c1.c !== undefined ? c1.c : c1.C)) * t;
    const l = (c1.l !== undefined ? c1.l : c1.L) + ((c2.l !== undefined ? c2.l : c2.L) - (c1.l !== undefined ? c1.l : c1.L)) * t;

    return _applyTransform({ h, c, l });
}

/**
 * Get raw OKLCH values (for advanced use)
 */
function getRaw(dimension, category) {
    return palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
}

/**
 * Get all categories for a dimension
 */
function getCategories(dimension) {
    return Object.keys(palette[dimension] || {});
}

/**
 * Get label for a category
 */
function getLabel(dimension, category) {
    return palette[dimension]?.[category]?.label || category;
}

// =========================================================================
// TRANSFORM CONTROLS
// =========================================================================

function setTransform(key, value) {
    if (key in transform) {
        transform[key] = value;
        _notifySubscribers('transform-change', { key, value });
    }
}

function setAllTransforms(transforms) {
    Object.assign(transform, transforms);
    _notifySubscribers('transform-change', transforms);
}

function resetTransforms() {
    transform.hueShift = 0;
    transform.chromaScale = 1.0;
    transform.lightnessShift = 0;
    transform.amplifier = 1.0;
    _notifySubscribers('transform-change', transform);
}

function getTransform() {
    return { ...transform };
}

// =========================================================================
// SCHEME API: Named Color Gradients
// =========================================================================

/**
 * List all available scheme names
 * @returns {string[]} Array of scheme names
 */
function listSchemes() {
    return Object.keys(schemePaths);
}

/**
 * Get scheme definition
 * @param {string} schemeName - Name of the scheme
 * @returns {object|null} Scheme definition with name, semantic, and stops
 */
function getScheme(schemeName) {
    return schemePaths[schemeName] || null;
}

/**
 * Get color at position t (0-1) along a scheme path
 * Supports both:
 *   - stops: Array of discrete points (interpolated)
 *   - generator: Function (t) => { h, c, l } (direct mathematical path)
 *
 * @param {string} schemeName - Name of the scheme
 * @param {number} t - Position along path (0-1)
 * @returns {string} Hex color string
 */
function getSchemeColor(schemeName, t) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const v = Math.max(0, Math.min(1, t));

    // GENERATOR MODE: Mathematical function (OKLCH geometry)
    if (scheme.generator && typeof scheme.generator === 'function') {
        const oklch = scheme.generator(v);
        return _applyTransform(oklch);
    }

    // STOPS MODE: Discrete points with interpolation
    const stops = scheme.stops;
    if (!stops || stops.length === 0) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const interp = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * interp,
        c: lower.c + (upper.c - lower.c) * interp,
        l: lower.l + (upper.l - lower.l) * interp
    };

    return _applyTransform(interpolated);
}

/**
 * Apply a scheme as the active color scheme
 * This sets transforms and notifies subscribers
 * @param {string} schemeName - Name of the scheme
 */
function applyScheme(schemeName) {
    // Allow null/undefined to clear the active scheme
    if (!schemeName) {
        _activeScheme = null;
        _notifySubscribers('scheme-change', { scheme: null, definition: null });
        console.log('[COLOR] Cleared active scheme, using default intervals');
        return;
    }

    const scheme = schemePaths[schemeName];
    if (!scheme) {
        console.warn('[COLOR] Unknown scheme:', schemeName);
        return;
    }

    _activeScheme = schemeName;
    _notifySubscribers('scheme-change', { scheme: schemeName, definition: scheme });
    console.log('[COLOR] Applied scheme:', schemeName, '-', scheme.semantic);
}

/**
 * Get the currently active scheme name
 * @returns {string|null} Active scheme name or null
 */
function getActiveScheme() {
    return _activeScheme;
}

/**
 * Generate a CSS gradient string for a scheme (for UI previews)
 * @param {string} schemeName - Name of the scheme
 * @param {string} direction - CSS gradient direction (default: 'to right')
 * @returns {string} CSS linear-gradient string
 */
function getSchemeGradientCSS(schemeName, direction = 'to right') {
    const scheme = schemePaths[schemeName];
    if (!scheme) return 'linear-gradient(to right, #333, #666)';

    const colorStops = scheme.stops.map(stop => {
        const color = _applyTransform(stop);
        const percent = Math.round(stop.value * 100);
        return `${color} ${percent}%`;
    });

    return `linear-gradient(${direction}, ${colorStops.join(', ')})`;
}

/**
 * Get scheme metadata (name, semantic description)
 * @param {string} schemeName - Name of the scheme
 * @returns {object} {name, semantic}
 */
function getSchemeInfo(schemeName) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return { name: schemeName, semantic: 'Unknown' };
    return { name: scheme.name, semantic: scheme.semantic };
}

// =========================================================================
// DEBUG
// =========================================================================

function debug() {
    console.log('[COLOR] Transform state:', transform);
    console.log('[COLOR] Palette dimensions:', Object.keys(palette));
    console.log('[COLOR] Interval mappings:', Object.keys(intervals));
    console.log('[COLOR] Schemes:', Object.keys(schemePaths).length, 'available');
    console.log('[COLOR] Active scheme:', _activeScheme);
}

// =========================================================================
// PUBLIC API
// =========================================================================

return {
    // Core API
    get,
    getInterval,
    getRaw,
    getCategories,
    getLabel,
    interpolate,

    // Transform controls
    setTransform,
    setAllTransforms,
    resetTransforms,
    getTransform,

    // Scheme API (33 named color gradients)
    listSchemes,
    getScheme,
    getSchemeColor,
    applyScheme,
    getActiveScheme,
    getSchemeGradientCSS,
    getSchemeInfo,

    // Subscriptions
    subscribe,

    // Internal access (for migration)
    palette,
    intervals,
    transform,
    schemePaths,

    // Debug
    debug
};
}) ();

// Export to window for global access
window.COLOR = COLOR;

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'ColorOrchestrator', { get: () => COLOR, configurable: true });
Object.defineProperty(window, 'Color', { get: () => COLOR, configurable: true });

console.log('[Module] COLOR loaded - OKLCH color engine with', Object.keys(COLOR.schemePaths || {}).length, 'schemes');


// ═══ MODULE: modules/refresh-throttle.js ═══
/**
 * REFRESH THROTTLE MODULE
 *
 * Prevents excessive Graph.refresh() calls that can cause performance issues.
 * Implements frame-budget-aware throttling at 60fps max.
 *
 * Fixes ARCH-003: Unthrottled Graph.refresh() calls
 *
 * Usage:
 *   REFRESH.throttled()     // Request a throttled refresh
 *   REFRESH.force()         // Force immediate refresh (use sparingly)
 *   REFRESH.stats           // Get refresh statistics
 */

const REFRESH = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        minInterval: 16,      // 60fps max (1000ms / 60 = 16.67ms)
        maxPending: 3,        // Max queued refresh requests before forcing
        logThreshold: 100     // Log warning if more than N refreshes/second
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _pending = false;
    let _lastRefresh = 0;
    let _rafId = null;
    let _pendingCount = 0;

    // Statistics
    let _stats = {
        totalCalls: 0,
        throttledCalls: 0,
        actualRefreshes: 0,
        lastSecondRefreshes: 0,
        currentSecondRefreshes: 0,
        lastSecond: 0
    };

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Request a throttled graph refresh.
     * Multiple calls within the same frame are coalesced into one refresh.
     */
    function throttled() {
        _stats.totalCalls++;
        _pendingCount++;

        // Track calls per second for diagnostics
        const now = performance.now();
        const currentSecond = Math.floor(now / 1000);
        if (currentSecond !== _stats.lastSecond) {
            _stats.lastSecondRefreshes = _stats.currentSecondRefreshes;
            _stats.currentSecondRefreshes = 0;
            _stats.lastSecond = currentSecond;

            // Warn if too many refreshes
            if (_stats.lastSecondRefreshes > CONFIG.logThreshold) {
                console.warn(`[REFRESH] High refresh rate: ${_stats.lastSecondRefreshes}/s`);
            }
        }

        // If already pending, don't queue another
        if (_pending) {
            _stats.throttledCalls++;

            // Force refresh if too many pending
            if (_pendingCount >= CONFIG.maxPending) {
                _doRefresh();
            }
            return;
        }

        // Check if enough time has passed since last refresh
        const elapsed = now - _lastRefresh;
        if (elapsed >= CONFIG.minInterval) {
            // Enough time passed, refresh immediately
            _doRefresh();
        } else {
            // Schedule refresh for next frame
            _pending = true;
            _rafId = requestAnimationFrame(() => {
                _pending = false;
                _doRefresh();
            });
        }
    }

    /**
     * Force an immediate refresh, bypassing throttle.
     * Use sparingly - for critical updates only.
     */
    function force() {
        // Cancel any pending throttled refresh
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _doRefresh();
    }

    /**
     * Internal: Perform the actual refresh
     */
    function _doRefresh() {
        _lastRefresh = performance.now();
        _pendingCount = 0;
        _stats.actualRefreshes++;
        _stats.currentSecondRefreshes++;

        // Call the global Graph.refresh() if available
        if (typeof Graph !== 'undefined' && Graph && Graph.refresh) {
            Graph.refresh();
        }
    }

    /**
     * Cancel any pending refresh
     */
    function cancel() {
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _pendingCount = 0;
    }

    /**
     * Reset statistics
     */
    function resetStats() {
        _stats = {
            totalCalls: 0,
            throttledCalls: 0,
            actualRefreshes: 0,
            lastSecondRefreshes: 0,
            currentSecondRefreshes: 0,
            lastSecond: 0
        };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        throttled,
        force,
        cancel,
        resetStats,

        // Config (read-only access, can be modified via setConfig)
        get config() { return { ...CONFIG }; },
        setConfig(key, value) {
            if (key in CONFIG) {
                CONFIG[key] = value;
            }
        },

        // Statistics
        get stats() {
            return {
                ..._stats,
                throttleRatio: _stats.totalCalls > 0
                    ? (_stats.throttledCalls / _stats.totalCalls * 100).toFixed(1) + '%'
                    : '0%',
                pending: _pending,
                pendingCount: _pendingCount
            };
        },

        // Debug
        debug() {
            console.log('[REFRESH] Stats:', this.stats);
            console.log('[REFRESH] Config:', CONFIG);
        }
    };
})();


// ═══ MODULE: modules/legend-manager.js ═══
/**
 * LEGEND MANAGER MODULE
 *
 * Manages legend data, counts, and visibility for all visualization dimensions.
 * Delegates all color operations to the COLOR module.
 *
 * Depends on: COLOR, NODE
 *
 * Usage:
 *   LEGEND.init(nodes, links)           // Initialize with graph data
 *   LEGEND.getLegendData('tier')        // Get legend items for a dimension
 *   LEGEND.getColor('tier', 'T0')       // Get color (delegates to COLOR)
 *   LEGEND.subscribe(callback)          // React to legend changes
 */

const LEGEND = (function() {
    'use strict';

    // =========================================================================
    // DIMENSION METADATA
    // =========================================================================

    const dimensions = {
        tier: {
            name: 'TIERS',
            icon: '◐',
            extract: (node) => NODE.getTier(node)
        },
        family: {
            name: 'FAMILIES',
            icon: '⬡',
            extract: (node) => NODE.getFamily(node)
        },
        ring: {
            name: 'RINGS',
            icon: '◎',
            extract: (node) => NODE.getRing(node)
        },
        layer: {
            name: 'LAYERS',
            icon: '☰',
            extract: (node) => NODE.getLayer(node).toUpperCase()
        },
        effect: {
            name: 'EFFECTS',
            icon: '⚡',
            extract: (node) => NODE.getEffect(node)
        },
        edgeType: {
            name: 'EDGE TYPES',
            icon: '→',
            extract: (link) => (link.edge_type || link.type || 'unknown').toLowerCase()
        },
        edgeFamily: {
            name: 'EDGE FAMILIES',
            icon: '⇢',
            extract: (link) => (link.family || 'Dependency')
        }
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _counts = {};
    let _subscribers = [];

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Initialize legend with nodes and links data
     */
    function init(nodes, links) {
        _computeCounts(nodes, links);
        return LEGEND;
    }

    /**
     * Compute counts for all dimensions
     */
    function _computeCounts(nodes, links) {
        _counts = {};

        // Node dimensions
        ['tier', 'family', 'ring', 'layer', 'effect'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (nodes || []).forEach(node => {
                const cat = extract(node);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        // Edge dimensions
        ['edgeType', 'edgeFamily'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (links || []).forEach(link => {
                const cat = extract(link);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        console.log('[LEGEND] Counts computed:', Object.keys(_counts));
        _notifySubscribers('counts-updated', _counts);
    }

    /**
     * Get legend data for a dimension
     * Returns array of { id, label, color, count, dimension }
     */
    function getLegendData(dimension) {
        const counts = _counts[dimension] || {};

        return Object.keys(counts)
            .filter(cat => counts[cat] > 0)
            .sort((a, b) => (counts[b] || 0) - (counts[a] || 0))
            .map(cat => ({
                id: cat,
                label: COLOR.getLabel(dimension, cat),
                color: COLOR.get(dimension, cat),
                count: counts[cat] || 0,
                dimension: dimension
            }));
    }

    /**
     * Get color for a dimension/category (delegates to COLOR)
     */
    function getColor(dimension, category) {
        return COLOR.get(dimension, category);
    }

    /**
     * Get counts for a dimension
     */
    function getCounts(dimension) {
        return _counts[dimension] || {};
    }

    /**
     * Get all available dimensions
     */
    function getDimensions() {
        return Object.keys(dimensions);
    }

    /**
     * Get dimension metadata
     */
    function getDimensionMeta(dimension) {
        return dimensions[dimension] || null;
    }

    // =========================================================================
    // SUBSCRIPTIONS
    // =========================================================================

    function subscribe(callback) {
        _subscribers.push(callback);
        return () => {
            _subscribers = _subscribers.filter(cb => cb !== callback);
        };
    }

    function _notifySubscribers(event, data) {
        _subscribers.forEach(cb => cb(event, data));
    }

    // =========================================================================
    // DOM RENDERING
    // =========================================================================

    /**
     * Render a legend section to the DOM
     * @param {string} containerId - DOM container ID
     * @param {string} dimension - Dimension to render (tier, family, etc.)
     * @param {Set} stateSet - Filter state set (items to show)
     * @param {Function} onUpdate - Callback when filter changes
     */
    function renderSection(containerId, dimension, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        const legendData = getLegendData(dimension);
        if (!legendData || legendData.length === 0) return;

        // Build legend items
        legendData.forEach(item => {
            const el = document.createElement('div');
            el.className = 'topo-legend-item' + (stateSet && !stateSet.has(item.id) ? ' filtered' : '');
            el.dataset.category = item.id;
            el.dataset.dimension = dimension;

            // Color swatch
            const swatch = document.createElement('span');
            swatch.className = 'topo-legend-swatch';
            swatch.style.backgroundColor = item.color;

            // Label with count
            const label = document.createElement('span');
            label.className = 'topo-legend-label';
            label.textContent = item.id;

            const count = document.createElement('span');
            count.className = 'topo-legend-count';
            count.textContent = `(${item.count})`;

            el.appendChild(swatch);
            el.appendChild(label);
            el.appendChild(count);

            // Click to toggle filter
            if (stateSet) {
                el.addEventListener('click', () => {
                    if (stateSet.has(item.id)) {
                        stateSet.delete(item.id);
                        el.classList.add('filtered');
                    } else {
                        stateSet.add(item.id);
                        el.classList.remove('filtered');
                    }
                    if (onUpdate) onUpdate();
                });
            }

            container.appendChild(el);
        });

        console.log(`[Legend] Rendered ${dimension}: ${legendData.length} items`);
    }

    /**
     * Render all legend sections
     * @param {Object} filters - VIS_FILTERS object with filter Sets
     * @param {Function} onUpdate - Callback when any filter changes (typically refreshGraph)
     */
    function renderAll(filters, onUpdate) {
        // Render node legends
        renderSection('topo-tiers', 'tier', filters?.tiers, onUpdate);
        renderSection('topo-families', 'family', filters?.families, onUpdate);
        renderSection('topo-rings', 'ring', filters?.rings, onUpdate);
        renderSection('topo-layers', 'layer', filters?.layers, onUpdate);
        renderSection('topo-effects', 'effect', filters?.effects, onUpdate);

        // Render edge legends
        renderSection('topo-edges', 'edgeType', filters?.edges, onUpdate);
        renderSection('topo-edge-families', 'edgeFamily', filters?.edgeFamilies, onUpdate);

        console.log('[Legend] All sections rendered');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        getLegendData,
        getColor,
        getCounts,
        getDimensions,
        getDimensionMeta,
        subscribe,
        renderSection,
        renderAll,

        // Direct access to dimensions (for migration)
        dimensions,

        // Computed counts
        get counts() { return _counts; }
    };
})();

// Backward compatibility - LegendManager class wrapper
class LegendManager {
    constructor() {
        this.dimensions = LEGEND.dimensions;
        this.counts = {};
        this._subscribers = [];
    }

    init(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
        return this;
    }

    _computeCounts(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
    }

    getLegendData(dimension) {
        return LEGEND.getLegendData(dimension);
    }

    getColor(dimension, category) {
        return LEGEND.getColor(dimension, category);
    }

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    }

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    }
}

// Global Legend instance - defined by app.js (not duplicated here to avoid redeclaration)
// Legend is accessed as a global variable provided by app.js

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

// renderLegendSection calls LEGEND.renderSection with Legend (global) as source
window.renderLegendSection = function(containerId, dimension, stateSet, onUpdate) {
    LEGEND.renderSection(containerId, dimension, stateSet, onUpdate);
};

// renderAllLegends uses VIS_FILTERS and refreshGraph from app.js globals
// Includes 100ms debounce to prevent DOM thrashing during rapid updates
let _legendDebounceTimer = null;
window.renderAllLegends = function() {
    if (_legendDebounceTimer) clearTimeout(_legendDebounceTimer);
    _legendDebounceTimer = setTimeout(() => {
        _legendDebounceTimer = null;
        const VIS_FILTERS = window.VIS_FILTERS;
        const refreshGraph = window.refreshGraph;
        if (VIS_FILTERS && refreshGraph) {
            LEGEND.renderAll(VIS_FILTERS, refreshGraph);
        } else {
            console.warn('[Legend] VIS_FILTERS or refreshGraph not available');
        }
    }, 100);
};

console.log('[Module] LEGEND loaded - 10 functions');


// ═══ MODULE: modules/data-manager.js ═══
/**
 * DATA MANAGER MODULE
 *
 * Single gate for ALL data access in the visualization.
 * Replaces direct access to FULL_GRAPH and Graph.graphData().
 * Provides O(1) indexed lookups and cached aggregations.
 *
 * Depends on: NODE, COLOR, LEGEND
 *
 * Usage:
 *   DATA.init(graphData)                // Initialize with payload data
 *   DATA.getNodes()                     // Get all raw nodes
 *   DATA.getNode(id)                    // O(1) node lookup
 *   DATA.getNodesByTier('T0')           // O(1) tier lookup
 *   DATA.getEdgesFrom(nodeId)           // O(1) edge lookup
 *   DATA.getTierCounts()                // Cached aggregation
 */

const DATA = (function() {
    'use strict';

    // =========================================================================
    // RAW DATA (immutable after init)
    // =========================================================================

    const raw = {
        nodes: [],
        links: [],
        fileBoundaries: [],
        markov: {},
        kpis: {},
        meta: {},
        physics: {},
        config: {}
    };

    // =========================================================================
    // ANALYTICS DATA (all Collider sections)
    // =========================================================================

    const analytics = {
        counts: {},
        stats: {},
        coverage: {},
        performance: {},
        classification: {},
        auto_discovery: {},
        ecosystem_discovery: {},
        dependencies: {},
        architecture: {},
        topology: {},
        execution_flow: {},
        data_flow: {},
        knots: {},
        warnings: [],
        recommendations: [],
        theory_completeness: {},
        distributions: {},
        edge_types: {},
        rpbl_profile: {},
        purpose_field: {},
        top_hubs: [],
        orphans_list: [],
        files: [],
        semantics: {},
        llm_enrichment: {},
        brain_download: {},
        ai_insights: null
    };

    // =========================================================================
    // INDEXES (O(1) lookups - built once)
    // =========================================================================

    const index = {
        nodeById: new Map(),           // id -> node
        nodesByTier: new Map(),        // tier -> [nodes]
        nodesByFamily: new Map(),      // family -> [nodes]
        nodesByRing: new Map(),        // ring -> [nodes]
        nodesByLayer: new Map(),       // layer -> [nodes]
        nodesByEffect: new Map(),      // effect -> [nodes]
        nodesByFile: new Map(),        // fileIdx -> [nodes]
        edgesBySource: new Map(),      // nodeId -> [edges from]
        edgesByTarget: new Map(),      // nodeId -> [edges to]
        edgeByKey: new Map(),          // "src|tgt" -> edge
        fileByIndex: new Map(),        // idx -> fileBoundary
        markovBySource: new Map()      // nodeId -> sorted edges by weight
    };

    // =========================================================================
    // CACHED AGGREGATIONS (computed once, invalidated on filter)
    // =========================================================================

    const cache = {
        tierCounts: null,
        familyCounts: null,
        ringCounts: null,
        layerCounts: null,
        effectCounts: null,
        edgeTypeCounts: null,
        edgeFamilyCounts: null,
        edgeRanges: null
    };

    // =========================================================================
    // CURRENT STATE (filtered view)
    // =========================================================================

    const filtered = {
        nodes: [],
        links: []
    };

    // Legend manager instance
    let _legend = null;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function init(data) {
        // Store raw data
        raw.nodes = Array.isArray(data?.nodes) ? data.nodes : [];
        raw.links = Array.isArray(data?.links) ? data.links : [];
        raw.fileBoundaries = Array.isArray(data?.file_boundaries) ? data.file_boundaries : [];
        raw.markov = data?.markov || {};
        raw.kpis = data?.kpis || {};
        raw.meta = data?.meta || {};
        raw.physics = data?.physics || {};
        raw.config = data?.config || {};

        // Store analytics data
        Object.keys(analytics).forEach(key => {
            if (data?.[key] !== undefined) {
                analytics[key] = data[key];
            }
        });

        // Build all indexes
        _buildAllIndexes();

        // Initialize legend
        _legend = new LegendManager();
        _legend.init(raw.nodes, raw.links);

        // Set global Legend reference
        if (typeof Legend !== 'undefined') {
            Legend = _legend;
        }

        console.log('%c[DATA] Initialized', 'color: #4ade80; font-weight: bold',
            `${raw.nodes.length} nodes, ${raw.links.length} edges, ${raw.fileBoundaries.length} files`);

        return DATA;
    }

    // =========================================================================
    // INDEX BUILDING
    // =========================================================================

    function _buildAllIndexes() {
        _buildNodeIndex();
        _buildSemanticIndexes();
        _buildEdgeIndexes();
        _buildFileIndex();
        _buildMarkovIndex();
        _invalidateCache();
    }

    function _buildNodeIndex() {
        index.nodeById.clear();
        for (const node of raw.nodes) {
            if (node?.id) {
                index.nodeById.set(node.id, node);
            }
        }
    }

    function _buildSemanticIndexes() {
        index.nodesByTier.clear();
        index.nodesByFamily.clear();
        index.nodesByRing.clear();
        index.nodesByLayer.clear();
        index.nodesByEffect.clear();
        index.nodesByFile.clear();

        for (const node of raw.nodes) {
            if (!node) continue;

            // Tier index
            const tier = NODE.getTier(node);
            if (!index.nodesByTier.has(tier)) {
                index.nodesByTier.set(tier, []);
            }
            index.nodesByTier.get(tier).push(node);

            // Family index
            const family = NODE.getFamily(node);
            if (!index.nodesByFamily.has(family)) {
                index.nodesByFamily.set(family, []);
            }
            index.nodesByFamily.get(family).push(node);

            // Ring index
            const ring = NODE.getRing(node);
            if (!index.nodesByRing.has(ring)) {
                index.nodesByRing.set(ring, []);
            }
            index.nodesByRing.get(ring).push(node);

            // Layer index
            const layer = NODE.getLayer(node);
            if (!index.nodesByLayer.has(layer)) {
                index.nodesByLayer.set(layer, []);
            }
            index.nodesByLayer.get(layer).push(node);

            // Effect index
            const effect = NODE.getEffect(node);
            if (!index.nodesByEffect.has(effect)) {
                index.nodesByEffect.set(effect, []);
            }
            index.nodesByEffect.get(effect).push(node);

            // File index
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx >= 0) {
                if (!index.nodesByFile.has(fileIdx)) {
                    index.nodesByFile.set(fileIdx, []);
                }
                index.nodesByFile.get(fileIdx).push(node);
            }
        }
    }

    function _buildEdgeIndexes() {
        index.edgesBySource.clear();
        index.edgesByTarget.clear();
        index.edgeByKey.clear();

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');

            if (srcId) {
                if (!index.edgesBySource.has(srcId)) {
                    index.edgesBySource.set(srcId, []);
                }
                index.edgesBySource.get(srcId).push(link);
            }

            if (tgtId) {
                if (!index.edgesByTarget.has(tgtId)) {
                    index.edgesByTarget.set(tgtId, []);
                }
                index.edgesByTarget.get(tgtId).push(link);
            }

            if (srcId && tgtId) {
                index.edgeByKey.set(`${srcId}|${tgtId}`, link);
            }
        }
    }

    function _buildFileIndex() {
        index.fileByIndex.clear();
        for (let i = 0; i < raw.fileBoundaries.length; i++) {
            index.fileByIndex.set(i, raw.fileBoundaries[i]);
        }
    }

    function _buildMarkovIndex() {
        index.markovBySource.clear();
        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const mw = link.markov_weight || 0;
            if (srcId && mw > 0) {
                if (!index.markovBySource.has(srcId)) {
                    index.markovBySource.set(srcId, []);
                }
                index.markovBySource.get(srcId).push(link);
            }
        }
        // Sort each list by markov weight descending
        for (const [, edges] of index.markovBySource) {
            edges.sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0));
        }
    }

    function _invalidateCache() {
        Object.keys(cache).forEach(key => {
            cache[key] = null;
        });
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }

    // =========================================================================
    // RAW DATA ACCESSORS
    // =========================================================================

    function getNodes() { return raw.nodes; }
    function getLinks() { return raw.links; }
    function getFileBoundaries() { return raw.fileBoundaries; }
    function getMarkov() { return raw.markov; }
    function getKpis() { return raw.kpis; }
    function getMeta() { return raw.meta; }
    function getPhysics() { return raw.physics; }
    function getConfig() { return raw.config; }
    function getAnalytics(key) { return analytics[key]; }

    // =========================================================================
    // INDEXED LOOKUPS (O(1))
    // =========================================================================

    function getNode(id) {
        return index.nodeById.get(id) || null;
    }

    function getNodesByTier(tier) {
        return index.nodesByTier.get(tier) || [];
    }

    function getNodesByFamily(family) {
        return index.nodesByFamily.get(family) || [];
    }

    function getNodesByRing(ring) {
        return index.nodesByRing.get(ring) || [];
    }

    function getNodesByLayer(layer) {
        return index.nodesByLayer.get(layer) || [];
    }

    function getNodesByEffect(effect) {
        return index.nodesByEffect.get(effect) || [];
    }

    function getNodesByFile(fileIdx) {
        return index.nodesByFile.get(fileIdx) || [];
    }

    function getEdgesFrom(nodeId) {
        return index.edgesBySource.get(nodeId) || [];
    }

    function getEdgesTo(nodeId) {
        return index.edgesByTarget.get(nodeId) || [];
    }

    function getEdgeBetween(srcId, tgtId) {
        return index.edgeByKey.get(`${srcId}|${tgtId}`) || null;
    }

    function getFile(idx) {
        return index.fileByIndex.get(idx) || null;
    }

    function getTopMarkovEdges(nodeId, k = 5) {
        const edges = index.markovBySource.get(nodeId) || [];
        return edges.slice(0, k);
    }

    function isHighEntropyNode(nodeId) {
        const highEntropy = raw.markov?.high_entropy_nodes || [];
        return highEntropy.some(h => h.node === nodeId);
    }

    // =========================================================================
    // FILTERED DATA
    // =========================================================================

    function setFiltered(nodes, links) {
        filtered.nodes = nodes || [];
        filtered.links = links || [];
    }

    function getVisibleNodes() {
        if (filtered.nodes.length > 0) {
            return filtered.nodes;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().nodes || [])
            : [];
    }

    function getVisibleLinks() {
        if (filtered.links.length > 0) {
            return filtered.links;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().links || [])
            : [];
    }

    // =========================================================================
    // AGGREGATIONS (cached)
    // =========================================================================

    function getTierCounts() {
        if (!cache.tierCounts) {
            cache.tierCounts = new Map();
            for (const [tier, nodes] of index.nodesByTier) {
                cache.tierCounts.set(tier, nodes.length);
            }
        }
        return cache.tierCounts;
    }

    function getFamilyCounts() {
        if (!cache.familyCounts) {
            cache.familyCounts = new Map();
            for (const [family, nodes] of index.nodesByFamily) {
                cache.familyCounts.set(family, nodes.length);
            }
        }
        return cache.familyCounts;
    }

    function getRingCounts() {
        if (!cache.ringCounts) {
            cache.ringCounts = new Map();
            for (const [ring, nodes] of index.nodesByRing) {
                cache.ringCounts.set(ring, nodes.length);
            }
        }
        return cache.ringCounts;
    }

    function getLayerCounts() {
        if (!cache.layerCounts) {
            cache.layerCounts = new Map();
            for (const [layer, nodes] of index.nodesByLayer) {
                cache.layerCounts.set(layer, nodes.length);
            }
        }
        return cache.layerCounts;
    }

    function getEffectCounts() {
        if (!cache.effectCounts) {
            cache.effectCounts = new Map();
            for (const [effect, nodes] of index.nodesByEffect) {
                cache.effectCounts.set(effect, nodes.length);
            }
        }
        return cache.effectCounts;
    }

    function getEdgeTypeCounts() {
        if (!cache.edgeTypeCounts) {
            cache.edgeTypeCounts = new Map();
            for (const link of raw.links) {
                const type = link.edge_type || link.type || 'unknown';
                cache.edgeTypeCounts.set(type, (cache.edgeTypeCounts.get(type) || 0) + 1);
            }
        }
        return cache.edgeTypeCounts;
    }

    function getEdgeFamilyCounts() {
        if (!cache.edgeFamilyCounts) {
            cache.edgeFamilyCounts = new Map();
            for (const link of raw.links) {
                const family = link.family || 'Dependency';
                cache.edgeFamilyCounts.set(family, (cache.edgeFamilyCounts.get(family) || 0) + 1);
            }
        }
        return cache.edgeFamilyCounts;
    }

    function getEdgeRanges() {
        if (!cache.edgeRanges) {
            let minW = Infinity, maxW = -Infinity;
            let minC = Infinity, maxC = -Infinity;
            for (const link of raw.links) {
                const w = link.weight ?? 1;
                const c = link.confidence ?? 1;
                if (w < minW) minW = w;
                if (w > maxW) maxW = w;
                if (c < minC) minC = c;
                if (c > maxC) maxC = c;
            }
            cache.edgeRanges = {
                weight: { min: minW === Infinity ? 0 : minW, max: maxW === -Infinity ? 1 : maxW },
                confidence: { min: minC === Infinity ? 0 : minC, max: maxC === -Infinity ? 1 : maxC }
            };
        }
        return cache.edgeRanges;
    }

    // =========================================================================
    // SELF-TEST
    // =========================================================================

    function selfTest() {
        const errors = [];
        const warnings = [];
        const seenIds = new Set();

        for (const node of raw.nodes) {
            if (!node?.id) {
                errors.push('Node missing id');
                continue;
            }
            if (seenIds.has(node.id)) {
                errors.push(`Duplicate node id: ${node.id}`);
                continue;
            }
            seenIds.add(node.id);
        }

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');
            if (srcId && !index.nodeById.has(srcId)) {
                warnings.push(`Edge source not in graph: ${srcId}`);
            }
            if (tgtId && !index.nodeById.has(tgtId)) {
                warnings.push(`Edge target not in graph: ${tgtId}`);
            }
        }

        const status = errors.length === 0 ? 'PASS' : 'FAIL';
        const style = errors.length === 0
            ? 'color: #4ade80; font-weight: bold'
            : 'color: #f87171; font-weight: bold';

        console.log(`%c[DATA] Self-Test: ${status}`, style);
        console.log(`  Raw: ${raw.nodes.length} nodes, ${raw.links.length} edges`);
        console.log(`  Indexes: nodeById=${index.nodeById.size}, tiers=${index.nodesByTier.size}`);

        if (errors.length > 0) console.error('[DATA] Errors:', errors);
        if (warnings.length > 0) {
            console.warn('[DATA] Warnings:', warnings.slice(0, 5));
            if (warnings.length > 5) console.warn(`  ... and ${warnings.length - 5} more`);
        }

        return { errors, warnings, pass: errors.length === 0 };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Init
        init,

        // Raw data
        getNodes,
        getLinks,
        getFileBoundaries,
        getMarkov,
        getKpis,
        getMeta,
        getPhysics,
        getConfig,
        getAnalytics,

        // Indexed lookups
        getNode,
        getNodesByTier,
        getNodesByFamily,
        getNodesByRing,
        getNodesByLayer,
        getNodesByEffect,
        getNodesByFile,
        getEdgesFrom,
        getEdgesTo,
        getEdgeBetween,
        getFile,
        getTopMarkovEdges,
        isHighEntropyNode,

        // Filtered data
        setFiltered,
        getVisibleNodes,
        getVisibleLinks,

        // Aggregations
        getTierCounts,
        getFamilyCounts,
        getRingCounts,
        getLayerCounts,
        getEffectCounts,
        getEdgeTypeCounts,
        getEdgeFamilyCounts,
        getEdgeRanges,

        // Self-test
        selfTest,

        // Direct access (for migration)
        raw,
        index,
        cache,
        filtered,

        // Legend reference
        get legend() { return _legend; },

        // Color access (convenience)
        get color() { return COLOR; }
    };
})();

// Backward compatibility - DataManager class wrapper
class DataManager {
    constructor() {
        this.raw = DATA.raw;
        this.analytics = {};
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = null;
        this.color = COLOR;
    }

    init(data) {
        DATA.init(data);
        this.raw = DATA.raw;
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = DATA.legend;
        return this;
    }

    // Delegate all methods to DATA module
    getNodes() { return DATA.getNodes(); }
    getLinks() { return DATA.getLinks(); }
    getFileBoundaries() { return DATA.getFileBoundaries(); }
    getMarkov() { return DATA.getMarkov(); }
    getKpis() { return DATA.getKpis(); }
    getMeta() { return DATA.getMeta(); }
    getNode(id) { return DATA.getNode(id); }
    getNodesByTier(tier) { return DATA.getNodesByTier(tier); }
    getNodesByFamily(family) { return DATA.getNodesByFamily(family); }
    getNodesByRing(ring) { return DATA.getNodesByRing(ring); }
    getNodesByFile(fileIdx) { return DATA.getNodesByFile(fileIdx); }
    getEdgesFrom(nodeId) { return DATA.getEdgesFrom(nodeId); }
    getEdgesTo(nodeId) { return DATA.getEdgesTo(nodeId); }
    getEdgeBetween(srcId, tgtId) { return DATA.getEdgeBetween(srcId, tgtId); }
    getFile(idx) { return DATA.getFile(idx); }
    getTopMarkovEdges(nodeId, k) { return DATA.getTopMarkovEdges(nodeId, k); }
    isHighEntropyNode(nodeId) { return DATA.isHighEntropyNode(nodeId); }
    setFiltered(nodes, links) { DATA.setFiltered(nodes, links); }
    getVisibleNodes() { return DATA.getVisibleNodes(); }
    getVisibleLinks() { return DATA.getVisibleLinks(); }
    getTierCounts() { return DATA.getTierCounts(); }
    getFamilyCounts() { return DATA.getFamilyCounts(); }
    getRingCounts() { return DATA.getRingCounts(); }
    getLayerCounts() { return DATA.getLayerCounts(); }
    getEffectCounts() { return DATA.getEffectCounts(); }
    getEdgeTypeCounts() { return DATA.getEdgeTypeCounts(); }
    getEdgeFamilyCounts() { return DATA.getEdgeFamilyCounts(); }
    getEdgeRanges() { return DATA.getEdgeRanges(); }
    selfTest() { return DATA.selfTest(); }

    // Internal methods
    _buildAllIndexes() {}
    _buildNodeIndex() {}
    _buildSemanticIndexes() {}
    _buildEdgeIndexes() {}
    _buildFileIndex() {}
    _buildMarkovIndex() {}
    _invalidateCache() {}
    _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }
    _getNodeTier(node) { return NODE.getTier(node); }
    _getNodeFamily(node) { return NODE.getFamily(node); }
    _getNodeRing(node) { return NODE.getRing(node); }
    _getNodeLayer(node) { return NODE.getLayer(node); }
    _getNodeEffect(node) { return NODE.getEffect(node); }
}

// Global DM instance - defined by app.js (not duplicated here to avoid redeclaration)
// DM is accessed as a global variable provided by app.js

// Parity check function
function runDmParity(dm, data) {
    if (!dm) return;
    const checks = [];
    const rawNodes = Array.isArray(data?.nodes) ? data.nodes.length : 0;
    const rawEdges = Array.isArray(data?.links) ? data.links.length : 0;
    const dmNodes = dm.raw.nodes.length;
    const dmEdges = dm.raw.links.length;

    checks.push({ name: 'Node count', dm: dmNodes, old: rawNodes, pass: dmNodes === rawNodes });
    checks.push({ name: 'Edge count', dm: dmEdges, old: rawEdges, pass: dmEdges === rawEdges });
    checks.push({ name: 'Node index size', dm: dm.index.nodeById.size, old: rawNodes, pass: dm.index.nodeById.size === rawNodes });

    const allPass = checks.every(c => c.pass);
    const style = allPass ? 'color: #4ade80; font-weight: bold' : 'color: #f87171; font-weight: bold';
    console.log(`%c[DM Parity] ${allPass ? 'ALL PASS' : 'MISMATCH'}`, style);
    checks.forEach(c => {
        const icon = c.pass ? '✓' : '✗';
        console.log(`  ${icon} ${c.name}: DM=${c.dm}, Raw=${c.old}`);
    });
}


// ═══ MODULE: modules/vis-state.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VIS-STATE MODULE - Unified visualization state management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Single source of truth for visualization state. All controls funnel through
 * applyState() to ensure consistency.
 *
 * KEY DESIGN DECISIONS:
 * 1. Palette selection NEVER auto-switches colorBy mode
 * 2. Palette is "armed" - it applies when colorBy changes to interval mode
 * 3. Presets are macros that call applyState() with multiple properties
 * 4. syncUIFromState() updates all UI elements to match state
 *
 * @module VIS_STATE
 * @version 1.0.0
 */

window.VIS_STATE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CATEGORICAL vs INTERVAL MODE CLASSIFICATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Categorical modes use discrete color palettes (tier, family, atom...)
     * Interval modes use continuous gradients (complexity, fan_in, loc...)
     */
    const CATEGORICAL_MODES = new Set([
        'tier', 'family', 'atom', 'ring', 'layer', 'role', 'roleCategory',
        'subsystem', 'phase', 'fileType', 'file', 'state', 'visibility'
    ]);

    const INTERVAL_MODES = new Set([
        'complexity', 'loc', 'fan_in', 'fan_out', 'trust',
        'responsibility', 'purity', 'lifecycle_score', 'boundary_score',
        'centrality', 'rank', 'churn', 'age', 'depth'
    ]);

    function isIntervalMode(mode) {
        return INTERVAL_MODES.has(mode);
    }

    function isCategoricalMode(mode) {
        return CATEGORICAL_MODES.has(mode);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATE OBJECT - Single source of truth
    // ═══════════════════════════════════════════════════════════════════════

    const state = {
        colorBy: 'fan_in',         // Default to interval mode to show OKLCH schemes
        sizeBy: 'fanout',          // 'uniform', 'degree', 'fanout', 'complexity'
        edgeBy: 'type',            // 'type', 'resolution', 'weight', 'gradient-tier', etc.
        palette: 'helix',          // OKLCH helix path - visually striking default
        paletteType: 'interval'    // Derived: 'categorical' or 'interval'
    };

    // ═══════════════════════════════════════════════════════════════════════
    // VIEW PRESETS - Macros that set multiple properties at once
    // ═══════════════════════════════════════════════════════════════════════

    const VIEW_PRESETS = {
        tier: {
            label: 'Tier',
            description: 'T0/T1/T2 architectural height',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        family: {
            label: 'Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        layer: {
            label: 'Layer',
            description: 'Physical/Virtual/Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        ring: {
            label: 'Ring',
            description: 'Domain architecture rings',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        file: {
            label: 'File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        flow: {
            label: 'Flow',
            description: 'Markov transition probability',
            colorBy: 'fan_in',  // Use interval mode for flow
            sizeBy: 'degree',
            edgeBy: 'weight',
            special: 'flow'    // Triggers flow visualization
        }
    };

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY STATE - Central function all controls use
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply state changes. This is THE function all UI controls call.
     *
     * @param {Object} nextState - Partial state to merge
     * @param {string} reason - Debug label for console (e.g., 'preset:tier', 'control:colorBy')
     */
    function applyState(nextState, reason = 'unknown') {
        const prevColorBy = state.colorBy;
        const prevPalette = state.palette;

        // Merge new state
        if (nextState.colorBy !== undefined) state.colorBy = nextState.colorBy;
        if (nextState.sizeBy !== undefined) state.sizeBy = nextState.sizeBy;
        if (nextState.edgeBy !== undefined) state.edgeBy = nextState.edgeBy;
        if (nextState.palette !== undefined) state.palette = nextState.palette;

        // Derive paletteType from colorBy
        state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';

        console.log(`[VIS_STATE] applyState(${reason}):`, {
            colorBy: state.colorBy,
            sizeBy: state.sizeBy,
            edgeBy: state.edgeBy,
            palette: state.palette,
            paletteType: state.paletteType
        });

        // ─── Apply color mode ───
        if (nextState.colorBy !== undefined && nextState.colorBy !== prevColorBy) {
            _applyColorMode(state.colorBy);
        }

        // ─── Apply size mode ───
        if (nextState.sizeBy !== undefined) {
            _applySizeMode(state.sizeBy);
        }

        // ─── Apply edge mode ───
        if (nextState.edgeBy !== undefined) {
            _applyEdgeMode(state.edgeBy);
        }

        // ─── Apply palette (only if in interval mode) ───
        if (nextState.palette !== undefined || nextState.colorBy !== undefined) {
            _applyPalette();
        }

        // ─── Handle special modes (flow) ───
        if (nextState.special === 'flow') {
            _enableFlowMode();
        } else if (prevColorBy === 'flow' && nextState.colorBy !== 'flow') {
            _disableFlowMode();
        }

        // ─── Sync UI to match state ───
        syncUIFromState();

        // ─── Refresh visualization ───
        _refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INTERNAL APPLY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════

    function _applyColorMode(mode) {
        // Update globals for backward compatibility
        window.NODE_COLOR_MODE = mode;

        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.colorMode = mode;
            window.APPEARANCE_STATE.currentPreset = mode;
        }

        // Disable flow mode if switching away from flow
        if (mode !== 'flow' && typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _applySizeMode(mode) {
        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.sizeMode = mode;
        }

        if (typeof window.applyNodeSizeMode === 'function') {
            window.applyNodeSizeMode(mode);
        } else if (typeof window.NODE_HELPERS !== 'undefined') {
            window.NODE_HELPERS.applySizeMode(mode);
        }
    }

    function _applyEdgeMode(mode) {
        if (typeof window.EDGE_GRADIENT_MODE !== 'undefined') {
            // Edge gradient modes
            if (mode.startsWith('gradient-')) {
                window.EDGE_GRADIENT_MODE = mode.replace('gradient-', '');
            }
        }

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
    }

    function _applyPalette() {
        // Only apply scheme coloring if in interval mode
        if (state.paletteType === 'interval' && state.palette) {
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(state.palette);
            }
        } else {
            // In categorical mode, clear active scheme
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(null);
            }
        }
    }

    function _enableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && !window.flowMode) {
            if (typeof window.toggleFlowMode === 'function') {
                window.toggleFlowMode();
            }
        }
    }

    function _disableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _refreshGraph() {
        // Recompute node colors
        const DM = window.DM;
        const Graph = window.Graph;
        const nodes = DM ? DM.getNodes() : (Graph?.graphData ? Graph.graphData().nodes : []);

        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render with new function reference to force update
        if (Graph) {
            Graph.nodeColor(n => n.color);
        }

        // Refresh edge gradients
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        // Re-render legends
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SYNC UI FROM STATE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all UI elements to reflect current state.
     * Called after every applyState() and on initialization.
     */
    function syncUIFromState() {
        // ─── View Preset buttons ───
        document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
            const presetKey = btn.dataset.preset;
            const preset = VIEW_PRESETS[presetKey];
            const isActive = preset && preset.colorBy === state.colorBy;
            btn.classList.toggle('active', isActive);
        });

        // ─── Color Mode buttons (PRESET_CONFIG grid) ───
        document.querySelectorAll('.color-btn[data-preset]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.preset === state.colorBy);
        });

        // ─── Size Mode buttons ───
        document.querySelectorAll('[data-size-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.sizeMode === state.sizeBy);
        });

        // ─── Edge Mode buttons ───
        document.querySelectorAll('[data-edge-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.edgeMode === state.edgeBy);
        });

        // ─── Palette buttons ───
        document.querySelectorAll('.scheme-btn[data-scheme]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.scheme === state.palette);
        });

        // ─── Palette panel enabled/disabled state ───
        const schemesPanel = document.getElementById('section-schemes');
        if (schemesPanel) {
            const isDisabled = state.paletteType === 'categorical';
            schemesPanel.classList.toggle('disabled', isDisabled);

            // Update scheme buttons opacity/interactivity
            schemesPanel.querySelectorAll('.scheme-btn').forEach(btn => {
                btn.disabled = isDisabled;
                btn.style.opacity = isDisabled ? '0.4' : '1';
                btn.style.pointerEvents = isDisabled ? 'none' : 'auto';
            });

            // Show hint when disabled
            let hint = schemesPanel.querySelector('.scheme-hint');
            if (isDisabled) {
                if (!hint) {
                    hint = document.createElement('div');
                    hint.className = 'scheme-hint';
                    hint.style.cssText = 'padding: 8px; font-size: 10px; opacity: 0.6; text-align: center; font-style: italic;';
                    hint.textContent = 'Switch to a metric mode (Fan-In, Complexity, etc.) to enable color schemes';
                    schemesPanel.insertBefore(hint, schemesPanel.firstChild);
                }
            } else if (hint) {
                hint.remove();
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVENIENCE METHODS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply a view preset by name
     */
    function applyPreset(presetKey) {
        const preset = VIEW_PRESETS[presetKey];
        if (!preset) {
            console.warn('[VIS_STATE] Unknown preset:', presetKey);
            return;
        }

        applyState({
            colorBy: preset.colorBy,
            sizeBy: preset.sizeBy,
            edgeBy: preset.edgeBy,
            special: preset.special
        }, `preset:${presetKey}`);
    }

    /**
     * Set color mode only
     */
    function setColorBy(mode) {
        applyState({ colorBy: mode }, `colorBy:${mode}`);
    }

    /**
     * Set size mode only
     */
    function setSizeBy(mode) {
        applyState({ sizeBy: mode }, `sizeBy:${mode}`);
    }

    /**
     * Set edge mode only
     */
    function setEdgeBy(mode) {
        applyState({ edgeBy: mode }, `edgeBy:${mode}`);
    }

    /**
     * Set palette (arms the palette, applies if in interval mode)
     */
    function setPalette(schemeName) {
        applyState({ palette: schemeName }, `palette:${schemeName}`);
    }

    /**
     * Get current state (read-only copy)
     */
    function getState() {
        return { ...state };
    }

    /**
     * Initialize from saved preferences or defaults
     */
    function init() {
        try {
            const savedScheme = localStorage.getItem('collider_scheme');
            const savedColorMode = localStorage.getItem('collider_color_mode');

            if (savedScheme) state.palette = savedScheme;
            if (savedColorMode) state.colorBy = savedColorMode;

            state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';
        } catch (e) { /* ignore localStorage errors */ }

        // Apply initial state to globals (critical for NODE_COLOR_MODE)
        _applyColorMode(state.colorBy);
        _applyPalette();

        console.log('[VIS_STATE] Initialized:', state);
    }

    /**
     * Save current preferences
     */
    function savePreferences() {
        try {
            localStorage.setItem('collider_scheme', state.palette);
            localStorage.setItem('collider_color_mode', state.colorBy);
        } catch (e) { /* ignore */ }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // State access
        getState,
        isIntervalMode,
        isCategoricalMode,

        // Main API
        applyState,
        applyPreset,
        syncUIFromState,

        // Convenience setters
        setColorBy,
        setSizeBy,
        setEdgeBy,
        setPalette,

        // Lifecycle
        init,
        savePreferences,

        // Constants
        VIEW_PRESETS,
        CATEGORICAL_MODES,
        INTERVAL_MODES
    };
})();

console.log('[Module] VIS_STATE loaded - unified visualization state');


// ═══ MODULE: modules/ui-manager.js ═══
/**
 * @module ui-manager
 * @description Orchestrates the "One Dock" unified interface
 * @responsibility Manage sidebar, dock, modes, and filters UI
 * @depends_on vis-state, data-manager, refresh-throttle
 */

const UI_MANAGER = (function() {
    'use strict';

    // Private state
    let _data = null;
    let _initialized = false;

    /**
     * Initialize the UI Manager
     * @param {Object} data - Graph data object
     */
    function init(data) {
        _data = data;
        _setupSidebar();
        _setupDock();
        _setupModes();
        _populateFilters();
        _updateStatus();
        _initialized = true;
    }

    /**
     * Setup sidebar toggle and accordion behavior
     */
    function _setupSidebar() {
        const sidebar = document.getElementById('sidebar');
        const btnFilters = document.getElementById('btn-filters');
        const btnClose = document.getElementById('sidebar-close');

        const toggle = () => {
            sidebar.classList.toggle('open');
            _updateFilterBadge();
        };

        if (btnFilters) btnFilters.onclick = (e) => {
            e.stopPropagation();
            toggle();
        };
        if (btnClose) btnClose.onclick = () => sidebar.classList.remove('open');

        // Accordion Logic
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.onclick = () => {
                const accordion = header.parentElement;
                accordion.classList.toggle('open');
            };
        });
    }

    /**
     * Setup dock controls
     */
    function _setupDock() {
        // Reset Layout
        const btnReset = document.getElementById('btn-reset-layout');
        if (btnReset) btnReset.onclick = () => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.zoomToFit(1000);
            }
        };

        // Dimensions Toggle (2D/3D - stub)
        const btnDim = document.getElementById('btn-dimensions');
        if (btnDim) btnDim.onclick = () => {
            console.log("Dimension toggle requested");
        };

        // Report Button
        const btnReport = document.getElementById('btn-report');
        if (btnReport) btnReport.onclick = () => {
            const reportPanel = document.getElementById('report-panel');
            if (reportPanel) {
                const isHidden = reportPanel.style.display === 'none';
                reportPanel.style.display = isHidden ? 'block' : 'none';
                btnReport.classList.toggle('active', isHidden);
            }
        };
    }

    /**
     * Setup mode buttons (explore, files, flow)
     */
    function _setupModes() {
        const modes = ['explore', 'files', 'flow'];

        const setMode = (mode) => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.getElementById(`mode-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');

            document.querySelectorAll('.mode-control-group').forEach(g => g.style.display = 'none');
            const group = document.getElementById(`${mode}-controls`);
            if (group) group.style.display = 'flex';
        };

        modes.forEach(mode => {
            const btn = document.getElementById(`mode-${mode}`);
            if (btn) btn.onclick = () => setMode(mode);
        });

        // Files Sub-controls wiring
        const bindToggle = (id, onClick) => {
            const el = document.getElementById(id);
            if (el) el.onclick = (e) => {
                e.target.classList.toggle('active');
                if (onClick) onClick(e.target.classList.contains('active'));
            };
        };

        bindToggle('btn-file-hulls', (_active) => {
            // Toggle hull visibility
        });
    }

    /**
     * Populate filter chips for all categories
     */
    function _populateFilters() {
        if (!_data) return;

        // Helper: Create Filter Chips
        const createChips = (containerId, counts, activeSet) => {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            counts.forEach(([key, count]) => {
                const chip = document.createElement('div');
                const isActive = activeSet.has(key);
                chip.className = `filter-chip ${isActive ? 'active' : ''}`;
                chip.innerHTML = `${key} <span class="chip-count">${count}</span>`;
                chip.onclick = () => {
                    if (activeSet.has(key)) activeSet.delete(key);
                    else activeSet.add(key);

                    chip.classList.toggle('active');
                    _updateFilterBadge();
                    // Call refreshGraph if available
                    if (typeof refreshGraph === 'function') refreshGraph();
                };
                container.appendChild(chip);
            });

            const type = containerId.replace('filter-', '');
            const countEl = document.getElementById(`count-${type}`);
            if (countEl) countEl.innerText = activeSet.size;
        };

        // Get accessor functions
        const getNodeRing = typeof window.getNodeRing === 'function' ? window.getNodeRing :
            (typeof NODE !== 'undefined' ? NODE.getRing : (n => n.ring || 'Unknown'));
        const getNodeTier = typeof window.getNodeTier === 'function' ? window.getNodeTier :
            (typeof NODE !== 'undefined' ? NODE.getTier : (n => n.tier || 'Unknown'));
        const getNodeAtomFamily = typeof window.getNodeAtomFamily === 'function' ? window.getNodeAtomFamily :
            (typeof NODE !== 'undefined' ? NODE.getFamily : (n => n.atom_family || 'Unknown'));
        const normalizeRingValue = typeof window.normalizeRingValue === 'function' ? window.normalizeRingValue :
            (typeof NODE !== 'undefined' ? NODE.normalizeRing : (v => v));
        const collectCounts = typeof window.collectCounts === 'function' ? window.collectCounts :
            _defaultCollectCounts;

        // Get VIS_FILTERS
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set(), edges: new Set(), families: new Set() };

        // 1. LAYERS (Rings)
        const ringCounts = collectCounts(_data.nodes, getNodeRing);
        const rawRingDefaults = _data.controls?.filters?.rings || [];
        const ringDefaults = rawRingDefaults
            .map(v => normalizeRingValue(v))
            .filter(v => v !== null);

        if (VIS_FILTERS.rings.size === 0 && ringDefaults.length > 0) {
            const availableRings = new Set(ringCounts.map(([ring]) => ring));
            const matchedRings = ringDefaults.filter(r => availableRings.has(r));
            if (matchedRings.length > 0) {
                matchedRings.forEach(r => VIS_FILTERS.rings.add(r));
            } else {
                const familyCounts = collectCounts(_data.nodes, getNodeAtomFamily);
                const availableFamilies = new Set(familyCounts.map(([family]) => family));
                const matchedFamilies = ringDefaults.filter(f => availableFamilies.has(f));
                if (matchedFamilies.length > 0 && VIS_FILTERS.families.size === 0) {
                    matchedFamilies.forEach(f => VIS_FILTERS.families.add(f));
                    console.warn('[Filters] Ring defaults matched families; applying as family filters.');
                }
            }
        }
        createChips('filter-rings', ringCounts, VIS_FILTERS.rings);

        // 2. TIERS
        const tierCounts = collectCounts(_data.nodes, getNodeTier);
        createChips('filter-tiers', tierCounts, VIS_FILTERS.tiers);

        // 3. ROLES
        const roleCounts = collectCounts(_data.nodes, n => String(n.role || 'Unknown'));
        createChips('filter-roles', roleCounts, VIS_FILTERS.roles);

        // 4. EDGES
        const edgeCounts = collectCounts(_data.links, l => String(l.edge_type || l.type || 'default'));
        createChips('filter-edges', edgeCounts, VIS_FILTERS.edges);

        // 5. DATAMAPS
        _populateDatamaps();

        _updateFilterBadge();
    }

    /**
     * Default collectCounts implementation
     */
    function _defaultCollectCounts(items, accessor) {
        const counts = new Map();
        items.forEach(item => {
            const key = accessor(item);
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    /**
     * Populate datamap chips
     */
    function _populateDatamaps() {
        const container = document.getElementById('filter-datamaps');
        if (!container) return;
        container.innerHTML = '';

        const controls = _data.controls || {};
        const resolveDatamapConfigs = typeof window.resolveDatamapConfigs === 'function'
            ? window.resolveDatamapConfigs
            : () => [];
        const configs = resolveDatamapConfigs(controls);
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS || new Set();
        const setDatamap = typeof window.setDatamap === 'function' ? window.setDatamap : () => {};

        configs.forEach(cfg => {
            const chip = document.createElement('div');
            const isActive = ACTIVE_DATAMAPS.has(cfg.id);
            chip.className = `filter-chip ${isActive ? 'active' : ''}`;
            chip.style.width = '100%';
            chip.style.marginBottom = '4px';
            chip.innerHTML = `${cfg.label}`;

            chip.onclick = () => {
                setDatamap(cfg.id);
                Array.from(container.children).forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            };
            container.appendChild(chip);
        });

        const countEl = document.getElementById('count-datamaps');
        if (countEl) countEl.innerText = configs.length;
    }

    /**
     * Update filter badge count
     */
    function _updateFilterBadge() {
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set() };

        let total = 0;
        total += VIS_FILTERS.rings.size;
        total += VIS_FILTERS.tiers.size;
        total += VIS_FILTERS.roles.size;

        const badge = document.getElementById('filter-badge');
        const miniBadge = document.getElementById('filter-badge-mini');

        if (badge) badge.innerText = total;
        if (miniBadge) {
            miniBadge.innerText = total;
            miniBadge.classList.toggle('visible', total > 0);
        }

        const summary = document.getElementById('filter-summary');
        if (summary) {
            summary.innerText = total > 0 ? `${total} filters active` : "No filters active";
        }
    }

    /**
     * Update status display (node/edge counts)
     */
    function _updateStatus() {
        if (_data && _data.nodes) {
            const n = _data.nodes.length;
            const e = _data.links.length;
            const statusNodes = document.getElementById('status-nodes');
            const statusEdges = document.getElementById('status-edges');

            if (statusNodes) statusNodes.innerText = n;
            if (statusEdges) statusEdges.innerText = e;
        }
    }

    /**
     * Refresh filters (re-populate from current data)
     */
    function refreshFilters() {
        _populateFilters();
    }

    /**
     * Update badge count (public interface)
     */
    function updateFilterBadge() {
        _updateFilterBadge();
    }

    // Public API
    return {
        init,
        refreshFilters,
        updateFilterBadge,
        get data() { return _data; },
        get initialized() { return _initialized; }
    };
})();

// Backward compatibility - expose as UIManager
const UIManager = {
    data: null,
    init(data) {
        this.data = data;
        UI_MANAGER.init(data);
    },
    setupSidebar() { /* Now internal */ },
    setupDock() { /* Now internal */ },
    setupModes() { /* Now internal */ },
    populateFilters() { UI_MANAGER.refreshFilters(); },
    populateDatamaps() { UI_MANAGER.refreshFilters(); },
    updateFilterBadge() { UI_MANAGER.updateFilterBadge(); },
    updateStatus() { /* Now internal */ }
};

// Expose globally
window.UI_MANAGER = UI_MANAGER;
window.UIManager = UIManager;


// ═══ MODULE: modules/physics.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * PHYSICS MODULE - Force simulation controls
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Physics presets, sliders, and force parameter management.
 * Depends on: Graph, PHYSICS_STATE, PHYSICS_PRESETS (globals)
 *
 * @module PHYSICS
 * @version 1.0.0
 */

window.PHYSICS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS STATE
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsState() {
        const Graph = window.Graph;
        const PHYSICS_STATE = window.PHYSICS_STATE;
        if (!Graph) return;
        try {
            Graph.d3Force('charge')?.strength(PHYSICS_STATE.charge);
            Graph.d3Force('link')?.distance(PHYSICS_STATE.linkDistance);
            Graph.d3Force('center')?.strength(PHYSICS_STATE.centerStrength);
            Graph.d3VelocityDecay?.(PHYSICS_STATE.velocityDecay);
            Graph.d3ReheatSimulation();
        } catch (e) {
            console.warn('[Physics] Could not apply:', e.message);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS PRESET
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsPreset(presetName) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const preset = PHYSICS_PRESETS[presetName];
        if (!preset) return;
        Object.assign(PHYSICS_STATE, {
            charge: preset.charge,
            linkDistance: preset.linkDistance,
            centerStrength: preset.centerStrength,
            velocityDecay: preset.velocityDecay
        });
        applyPhysicsState();
        updatePhysicsSliders();
        window.showModeToast(`Physics: ${preset.label}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE PHYSICS SLIDERS
    // ═══════════════════════════════════════════════════════════════════════

    function updatePhysicsSliders() {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const sliders = {
            'physics-charge': PHYSICS_STATE.charge,
            'physics-link-distance': PHYSICS_STATE.linkDistance,
            'physics-center': PHYSICS_STATE.centerStrength,
            'physics-damping': PHYSICS_STATE.velocityDecay
        };
        for (const [id, value] of Object.entries(sliders)) {
            const input = document.getElementById(id);
            const display = document.getElementById(id + '-value');
            if (input) input.value = value;
            if (display) display.textContent = typeof value === 'number' && value % 1 !== 0 ? value.toFixed(2) : value;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // BUILD PHYSICS CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function buildPhysicsControls(containerId) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const container = document.getElementById(containerId);
        if (!container) return;

        // Preset buttons
        const presetRow = document.createElement('div');
        presetRow.className = 'physics-presets';
        presetRow.style.cssText = 'display:flex;gap:4px;margin-bottom:8px;flex-wrap:wrap;';
        Object.entries(PHYSICS_PRESETS).forEach(([key, preset]) => {
            const btn = document.createElement('button');
            btn.className = 'preset-btn physics-preset-btn';
            btn.textContent = preset.label;
            btn.style.cssText = 'font-size:9px;padding:2px 6px;';
            btn.onclick = () => applyPhysicsPreset(key);
            presetRow.appendChild(btn);
        });
        container.appendChild(presetRow);

        // Sliders
        const sliderDefs = [
            {
                id: 'physics-charge',
                label: 'REPULSION',
                min: -500,
                max: 50,
                step: 10,
                value: PHYSICS_STATE.charge,
                onChange: (val) => { PHYSICS_STATE.charge = val; applyPhysicsState(); }
            },
            {
                id: 'physics-link-distance',
                label: 'LINK DIST',
                min: 10,
                max: 200,
                step: 5,
                value: PHYSICS_STATE.linkDistance,
                onChange: (val) => { PHYSICS_STATE.linkDistance = val; applyPhysicsState(); }
            },
            {
                id: 'physics-center',
                label: 'CENTER PULL',
                min: 0,
                max: 0.3,
                step: 0.01,
                value: PHYSICS_STATE.centerStrength,
                onChange: (val) => { PHYSICS_STATE.centerStrength = val; applyPhysicsState(); }
            },
            {
                id: 'physics-damping',
                label: 'DAMPING',
                min: 0,
                max: 1,
                step: 0.05,
                value: PHYSICS_STATE.velocityDecay,
                onChange: (val) => { PHYSICS_STATE.velocityDecay = val; applyPhysicsState(); }
            }
        ];

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row';

            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            valueDisplay.textContent = def.step < 1 ? def.value.toFixed(2) : def.value;
            header.appendChild(label);
            header.appendChild(valueDisplay);

            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = def.value;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = def.step < 1 ? val.toFixed(2) : val;
                def.onChange(val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);
            container.appendChild(wrapper);
        });

        console.log('[Physics] Controls initialized');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        applyState: applyPhysicsState,
        applyPreset: applyPhysicsPreset,
        updateSliders: updatePhysicsSliders,
        buildControls: buildPhysicsControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.applyPhysicsState = PHYSICS.applyState;
window.applyPhysicsPreset = PHYSICS.applyPreset;
window.updatePhysicsSliders = PHYSICS.updateSliders;
window.buildPhysicsControls = PHYSICS.buildControls;

console.log('[Module] PHYSICS loaded - 4 functions');


// ═══ MODULE: modules/datamap.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DATAMAP MODULE - Data mapping and filtering
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Datamap configuration, matching, and UI control updates.
 * Depends on: DM, VIS_FILTERS, ACTIVE_DATAMAPS, NODE (node-accessors)
 *
 * @module DATAMAP
 * @version 1.0.0
 */

window.DATAMAP = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NORMALIZE DATAMAP CONFIG
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeDatamapConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const id = String(raw.id || raw.key || raw.label || '').trim();
        if (!id) return null;
        const normalizeList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => String(item).toUpperCase());
        };
        const normalizeTierList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => window.normalizeTier(item));
        };
        const match = raw.match || {};
        return {
            id: id.toUpperCase(),
            label: String(raw.label || raw.id || id).toUpperCase(),
            match: {
                atom_families: normalizeList(match.atom_families),
                atom_prefixes: normalizeList(match.atom_prefixes),
                tiers: normalizeTierList(match.tiers),
                rings: normalizeList(match.rings),
                roles: normalizeList(match.roles)
            },
            default: Boolean(raw.default)
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // RESOLVE DATAMAP CONFIGS
    // ═══════════════════════════════════════════════════════════════════════

    function resolveDatamapConfigs(controlsConfig) {
        const fromTokens = Array.isArray(controlsConfig.datamaps) ? controlsConfig.datamaps : [];
        const normalized = fromTokens
            .map(normalizeDatamapConfig)
            .filter(Boolean);
        if (normalized.length) return normalized;

        const fallback = controlsConfig.buttons?.datamaps || {};
        return Object.entries(fallback).map(([label, config]) => {
            const prefix = config.filter || null;
            return normalizeDatamapConfig({
                id: label.toUpperCase(),
                label: label.toUpperCase(),
                match: prefix ? { atom_prefixes: [prefix] } : {},
                default: false
            });
        }).filter(Boolean);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP MATCHING
    // ═══════════════════════════════════════════════════════════════════════

    function datamapMatches(node, config) {
        const match = config.match || {};
        const atomId = String(node.atom || '');
        const atomFamily = window.getNodeAtomFamily(node);
        const tier = window.getNodeTier(node);
        const ring = window.getNodeRing(node);
        const role = String(node.role || 'Unknown').toUpperCase();

        if (Array.isArray(match.atom_families) && match.atom_families.length) {
            if (!match.atom_families.includes(atomFamily)) return false;
        }

        if (Array.isArray(match.atom_prefixes) && match.atom_prefixes.length) {
            const matchesFamily = match.atom_prefixes.includes(atomFamily);
            const matchesPrefix = match.atom_prefixes.some(prefix => atomId.startsWith(prefix));
            if (!matchesFamily && !matchesPrefix) return false;
        }

        if (Array.isArray(match.tiers) && match.tiers.length) {
            if (!match.tiers.includes(tier)) return false;
        }

        if (Array.isArray(match.rings) && match.rings.length) {
            if (!match.rings.includes(ring)) return false;
        }

        if (Array.isArray(match.roles) && match.roles.length) {
            if (!match.roles.includes(role)) return false;
        }
        return true;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET DATAMAP
    // ═══════════════════════════════════════════════════════════════════════

    function setDatamap(prefix) {
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const nextSet = new Set(ACTIVE_DATAMAPS);
        if (!prefix) {
            nextSet.clear();
        } else if (nextSet.has(prefix)) {
            nextSet.delete(prefix);
        } else {
            nextSet.add(prefix);
        }

        if (!window.DM) {
            window.ACTIVE_DATAMAPS = nextSet;
            updateDatamapControls();
            return;
        }

        const subset = window.filterGraph(null, window.CURRENT_DENSITY, nextSet, window.VIS_FILTERS);
        if (!subset.nodes.length) {
            window.showToast('No nodes for that datamap selection.');
            updateDatamapControls();
            return;
        }

        window.ACTIVE_DATAMAPS = nextSet;
        updateDatamapControls();
        window.refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET NODE COLOR MODE
    // ═══════════════════════════════════════════════════════════════════════

    function setNodeColorMode(mode) {
        window.NODE_COLOR_MODE = mode;
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
        window.refreshGraph();
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY DATAMAP (ALIAS)
    // ═══════════════════════════════════════════════════════════════════════

    function applyDatamap(prefix) {
        setDatamap(prefix);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE DATAMAP CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function updateDatamapControls() {
        const DM = window.DM;
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const DATAMAP_UI = window.DATAMAP_UI;
        const DATAMAP_CONFIGS = window.DATAMAP_CONFIGS;
        const GRAPH_MODE = window.GRAPH_MODE;
        const VIS_FILTERS = window.VIS_FILTERS;

        if (!DM) return;
        const datamapEnabled = GRAPH_MODE === 'atoms';
        const base = window.filterGraph(null, window.CURRENT_DENSITY, new Set(), VIS_FILTERS);
        const nodes = base.nodes || [];
        const totalCount = nodes.length;

        const allUI = DATAMAP_UI.get('__ALL__');
        if (allUI) {
            allUI.input.checked = ACTIVE_DATAMAPS.size === 0;
            if (allUI.count) {
                allUI.count.textContent = datamapEnabled ? String(totalCount) : '--';
            }
            allUI.input.disabled = !datamapEnabled;
            allUI.wrapper.classList.toggle('disabled', !datamapEnabled);
            allUI.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.size === 0);
        }

        DATAMAP_CONFIGS.forEach((config) => {
            const count = nodes.reduce((acc, node) => acc + (datamapMatches(node, config) ? 1 : 0), 0);
            const ui = DATAMAP_UI.get(config.id);
            if (!ui) return;
            if (ui.count) {
                ui.count.textContent = datamapEnabled ? String(count) : '--';
            }
            ui.input.disabled = !datamapEnabled || count === 0;
            ui.wrapper.classList.toggle('disabled', !datamapEnabled || count === 0);
            ui.input.checked = ACTIVE_DATAMAPS.has(config.id);
            ui.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.has(config.id));
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        normalizeConfig: normalizeDatamapConfig,
        resolveConfigs: resolveDatamapConfigs,
        matches: datamapMatches,
        set: setDatamap,
        setColorMode: setNodeColorMode,
        apply: applyDatamap,
        updateControls: updateDatamapControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.normalizeDatamapConfig = DATAMAP.normalizeConfig;
window.resolveDatamapConfigs = DATAMAP.resolveConfigs;
window.datamapMatches = DATAMAP.matches;
window.setDatamap = DATAMAP.set;
window.setNodeColorMode = DATAMAP.setColorMode;
window.applyDatamap = DATAMAP.apply;
window.updateDatamapControls = DATAMAP.updateControls;

console.log('[Module] DATAMAP loaded - 7 functions');


// ═══ MODULE: modules/groups.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * GROUPS MODULE - Node grouping functionality
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Group creation, storage, rendering, and management.
 * Depends on: GROUPS, ACTIVE_GROUP_ID, SELECTED_NODE_IDS, GROUPS_STORAGE_KEY
 *
 * @module GROUPS_MODULE
 * @version 1.0.0
 */

window.GROUPS_MODULE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    function loadGroups() {
        window.GROUPS = [];
        try {
            const stored = localStorage.getItem(window.GROUPS_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    window.GROUPS = parsed;
                }
            }
        } catch (e) {
            // localStorage unavailable
        }
        window.GROUPS = window.GROUPS.filter(group => group && group.id && Array.isArray(group.node_ids));
        window.GROUPS.forEach(group => {
            if (group.visible === undefined) group.visible = true;
        });
    }

    function saveGroups() {
        try {
            localStorage.setItem(window.GROUPS_STORAGE_KEY, JSON.stringify(window.GROUPS));
        } catch (e) {
            // localStorage unavailable
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNextGroupColor() {
        const hue = (window.GROUPS.length * 137.5) % 360;
        return window.hslColor(hue, 65, 55);
    }

    function getGroupById(groupId) {
        return window.GROUPS.find(group => group.id === groupId) || null;
    }

    function getPrimaryGroupForNode(nodeId) {
        const visibleGroups = window.GROUPS.filter(group =>
            group.visible !== false && Array.isArray(group.node_ids) && group.node_ids.includes(nodeId)
        );
        if (!visibleGroups.length) return null;
        if (window.ACTIVE_GROUP_ID) {
            const active = visibleGroups.find(group => group.id === window.ACTIVE_GROUP_ID);
            if (active) return active;
        }
        return visibleGroups[0];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP LIST RENDERING
    // ═══════════════════════════════════════════════════════════════════════

    function renderGroupList() {
        const container = document.getElementById('group-list');
        if (!container) return;
        container.innerHTML = '';

        if (!window.GROUPS.length) {
            const empty = document.createElement('div');
            empty.style.fontSize = '9px';
            empty.style.color = 'rgba(255,255,255,0.4)';
            empty.textContent = 'No groups yet';
            container.appendChild(empty);
            return;
        }

        window.GROUPS.forEach(group => {
            const row = document.createElement('div');
            row.className = 'group-item';
            row.classList.toggle('active', group.id === window.ACTIVE_GROUP_ID);

            const dot = document.createElement('span');
            dot.className = 'group-color';
            dot.style.background = group.color || '#6fe8ff';

            const name = document.createElement('span');
            name.className = 'group-name';
            name.textContent = group.name || 'Group';

            const count = document.createElement('span');
            count.className = 'group-count';
            count.textContent = String((group.node_ids || []).length);

            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.className = 'group-toggle';
            toggle.checked = group.visible !== false;
            toggle.onchange = (e) => {
                e.stopPropagation();
                group.visible = toggle.checked;
                saveGroups();
                window.updateSelectionVisuals();
                renderGroupList();
            };

            row.onclick = (e) => {
                if (e.target === toggle) return;
                window.ACTIVE_GROUP_ID = group.id;
                renderGroupList();
                window.setSelection(group.node_ids || []);
                window.updateSelectionVisuals();
            };

            row.appendChild(dot);
            row.appendChild(name);
            row.appendChild(count);
            row.appendChild(toggle);
            container.appendChild(row);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP BUTTON STATE
    // ═══════════════════════════════════════════════════════════════════════

    function updateGroupButtonState() {
        const btn = document.getElementById('btn-create-group');
        if (!btn) return;
        const hasSelection = window.SELECTED_NODE_IDS.size > 0;
        btn.classList.toggle('disabled', !hasSelection);
        btn.disabled = !hasSelection;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CREATE GROUP FROM SELECTION
    // ═══════════════════════════════════════════════════════════════════════

    function createGroupFromSelection() {
        if (window.SELECTED_NODE_IDS.size === 0) return;
        const nodeIds = Array.from(window.SELECTED_NODE_IDS);
        const groupId = `group_${Date.now().toString(36)}`;
        const groupName = `Group ${window.GROUPS.length + 1}`;
        const groupColor = getNextGroupColor();
        window.GROUPS.push({
            id: groupId,
            name: groupName,
            color: groupColor,
            node_ids: nodeIds,
            visible: true
        });
        window.ACTIVE_GROUP_ID = groupId;
        saveGroups();
        renderGroupList();
        window.updateSelectionVisuals();
        window.showToast(`Created ${groupName} (${nodeIds.length})`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        load: loadGroups,
        save: saveGroups,
        getNextColor: getNextGroupColor,
        getById: getGroupById,
        getPrimaryForNode: getPrimaryGroupForNode,
        renderList: renderGroupList,
        updateButtonState: updateGroupButtonState,
        createFromSelection: createGroupFromSelection
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.loadGroups = GROUPS_MODULE.load;
window.saveGroups = GROUPS_MODULE.save;
window.getNextGroupColor = GROUPS_MODULE.getNextColor;
window.getGroupById = GROUPS_MODULE.getById;
window.getPrimaryGroupForNode = GROUPS_MODULE.getPrimaryForNode;
window.renderGroupList = GROUPS_MODULE.renderList;
window.updateGroupButtonState = GROUPS_MODULE.updateButtonState;
window.createGroupFromSelection = GROUPS_MODULE.createFromSelection;

console.log('[Module] GROUPS_MODULE loaded - 8 functions');


// ═══ MODULE: modules/hover.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HOVER MODULE - Node hover and click interactions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node hover panel updates, click handling, and interaction management.
 * Depends on: HOVERED_NODE, VIS_FILTERS, GRAPH_MODE, DM, Graph
 *
 * @module HOVER
 * @version 1.0.0
 */

window.HOVER = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE HOVER PANEL
    // ═══════════════════════════════════════════════════════════════════════

    function updateHoverPanel(node) {
        const hoverPanel = document.getElementById('hover-panel');
        const placeholder = document.getElementById('hover-placeholder');
        if (!hoverPanel) return;

        if (!node) {
            hoverPanel.classList.remove('has-node');
            if (placeholder) placeholder.style.display = '';
            return;
        }

        hoverPanel.classList.add('has-node');
        if (placeholder) placeholder.style.display = 'none';

        // Helper to set element text safely
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val ?? '--';
        };

        // Basic info
        setEl('hover-name', node.label || node.id || 'Unknown');
        setEl('hover-type', node.type || node.kind || '--');
        setEl('hover-file', node.file_path || '--');

        // Tier/Ring/Family
        setEl('hover-tier', window.getNodeTier ? window.getNodeTier(node) : (node.tier || '--'));
        setEl('hover-ring', window.getNodeRing ? window.getNodeRing(node) : (node.ring || '--'));
        setEl('hover-family', window.getNodeAtomFamily ? window.getNodeAtomFamily(node) : (node.atom_family || '--'));

        // Metrics
        setEl('hover-complexity', node.complexity ?? '--');
        setEl('hover-loc', node.lines_of_code ?? node.loc ?? '--');
        setEl('hover-fanin', node.in_degree ?? '--');
        setEl('hover-fanout', node.out_degree ?? '--');

        // Role
        setEl('hover-role', node.role || '--');

        // Code preview (if available)
        const codeEl = document.getElementById('hover-code');
        if (codeEl) {
            const code = node.body_source || node.body || '';
            codeEl.textContent = code ? code.substring(0, 500) : '// no source';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE HOVER
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeHover(node, data) {
        const filePanel = document.getElementById('file-panel');
        window.HOVERED_NODE = node || null;

        // Always update hover panel
        updateHoverPanel(node);

        // Guard: file-panel may not exist
        if (!filePanel) return;

        const VIS_FILTERS = window.VIS_FILTERS;
        if (!VIS_FILTERS.metadata.showFilePanel) {
            filePanel.classList.remove('visible');
            return;
        }

        if (!node) {
            setTimeout(() => {
                if (!window.fileMode) filePanel.classList.remove('visible');
            }, 300);
            return;
        }

        // Get file info from boundaries
        const boundaries = data.file_boundaries || [];
        const fileIdx = node.fileIdx;

        if (fileIdx < 0 || fileIdx >= boundaries.length) {
            return;
        }

        const fileInfo = boundaries[fileIdx];

        // Update panel content
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        };
        setEl('file-name', fileInfo.file_name || 'unknown');
        setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
        setEl('file-purpose', fileInfo.purpose || '--');
        setEl('file-atom-count', fileInfo.atom_count || 0);
        setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
        setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
        setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

        // Code preview from node body
        const code = node.body || '// no source available';
        setEl('file-code', code);

        // Show panel
        filePanel.classList.add('visible');
        if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE CLICK
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeClick(node, event) {
        if (!node) return;
        const additive = event && event.shiftKey;
        if (additive) {
            window.toggleSelection(node);
            return;
        }
        if (node.id) {
            window.setSelection([node.id]);
        }
        const GRAPH_MODE = window.GRAPH_MODE;
        if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
            window.toggleFileExpand(node.fileIdx);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updatePanel: updateHoverPanel,
        onNodeHover: handleNodeHover,
        onNodeClick: handleNodeClick
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateHoverPanel = HOVER.updatePanel;
window.handleNodeHover = HOVER.onNodeHover;
window.handleNodeClick = HOVER.onNodeClick;

console.log('[Module] HOVER loaded - 3 functions');


// ═══ MODULE: modules/flow.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * FLOW MODULE - Flow visualization mode with presets
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Flow mode highlights high-entropy nodes and edge transition probabilities.
 * Cycles through visual presets (EMBER, OCEAN, PLASMA, MATRIX, PULSE, AURORA).
 * Depends on: Graph, DM, THEME_CONFIG, APPEARANCE_CONFIG, FLOW_CONFIG
 *
 * @module FLOW
 * @version 1.0.0
 */

window.FLOW = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // PRESET COLOR/VALUE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getFlowPresetColor(presetName, property, fallback) {
        const schemes = (window.THEME_CONFIG && window.THEME_CONFIG.colors && window.THEME_CONFIG.colors.schemes) || {};
        const scheme = schemes[presetName.toLowerCase()] || {};
        return scheme[property] || fallback;
    }

    function getFlowPresetValue(presetName, property, fallback) {
        const presets = (typeof window.APPEARANCE_CONFIG !== 'undefined' && window.APPEARANCE_CONFIG && window.APPEARANCE_CONFIG['flow-presets']) || {};
        const preset = presets[presetName.toLowerCase()] || {};
        const value = preset[property];
        return (value !== undefined && value !== null) ? value : fallback;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FLOW PRESETS
    // ═══════════════════════════════════════════════════════════════════════

    const PRESETS = [
        {
            name: 'EMBER',
            highlightColor: getFlowPresetColor('EMBER', 'highlightColor', getFlowPresetValue('ember', 'highlightColor', '#ff8c00')),
            particleColor: getFlowPresetColor('EMBER', 'particleColor', getFlowPresetValue('ember', 'particleColor', '#ffaa00')),
            dimColor: getFlowPresetColor('EMBER', 'dimColor', getFlowPresetValue('ember', 'dimColor', '#331100')),
            edgeColor: getFlowPresetColor('EMBER', 'edgeColor', getFlowPresetValue('ember', 'edgeColor', '#ff6600')),
            particleCount: getFlowPresetValue('ember', 'particleCount', 3),
            particleWidth: getFlowPresetValue('ember', 'particleWidth', 2.5),
            particleSpeed: getFlowPresetValue('ember', 'particleSpeed', 0.008),
            edgeWidthScale: getFlowPresetValue('ember', 'edgeWidthScale', 3.0),
            sizeMultiplier: getFlowPresetValue('ember', 'sizeMultiplier', 1.8),
            edgeOpacityMin: getFlowPresetValue('ember', 'edgeOpacityMin', 0.3),
            dimOpacity: getFlowPresetValue('ember', 'dimOpacity', 0.05)
        },
        {
            name: 'OCEAN',
            highlightColor: getFlowPresetColor('OCEAN', 'highlightColor', getFlowPresetValue('ocean', 'highlightColor', '#00d4ff')),
            particleColor: getFlowPresetColor('OCEAN', 'particleColor', getFlowPresetValue('ocean', 'particleColor', '#4df0ff')),
            dimColor: getFlowPresetColor('OCEAN', 'dimColor', getFlowPresetValue('ocean', 'dimColor', '#001122')),
            edgeColor: getFlowPresetColor('OCEAN', 'edgeColor', getFlowPresetValue('ocean', 'edgeColor', '#0088cc')),
            particleCount: getFlowPresetValue('ocean', 'particleCount', 4),
            particleWidth: getFlowPresetValue('ocean', 'particleWidth', 2.0),
            particleSpeed: getFlowPresetValue('ocean', 'particleSpeed', 0.006),
            edgeWidthScale: getFlowPresetValue('ocean', 'edgeWidthScale', 2.5),
            sizeMultiplier: getFlowPresetValue('ocean', 'sizeMultiplier', 1.6),
            edgeOpacityMin: getFlowPresetValue('ocean', 'edgeOpacityMin', 0.25),
            dimOpacity: getFlowPresetValue('ocean', 'dimOpacity', 0.03)
        },
        {
            name: 'PLASMA',
            highlightColor: getFlowPresetColor('PLASMA', 'highlightColor', getFlowPresetValue('plasma', 'highlightColor', '#ff00ff')),
            particleColor: getFlowPresetColor('PLASMA', 'particleColor', getFlowPresetValue('plasma', 'particleColor', '#ff66ff')),
            dimColor: getFlowPresetColor('PLASMA', 'dimColor', getFlowPresetValue('plasma', 'dimColor', '#110011')),
            edgeColor: getFlowPresetColor('PLASMA', 'edgeColor', getFlowPresetValue('plasma', 'edgeColor', '#cc00cc')),
            particleCount: getFlowPresetValue('plasma', 'particleCount', 5),
            particleWidth: getFlowPresetValue('plasma', 'particleWidth', 3.0),
            particleSpeed: getFlowPresetValue('plasma', 'particleSpeed', 0.012),
            edgeWidthScale: getFlowPresetValue('plasma', 'edgeWidthScale', 4.0),
            sizeMultiplier: getFlowPresetValue('plasma', 'sizeMultiplier', 2.0),
            edgeOpacityMin: getFlowPresetValue('plasma', 'edgeOpacityMin', 0.35),
            dimOpacity: getFlowPresetValue('plasma', 'dimOpacity', 0.04)
        },
        {
            name: 'MATRIX',
            highlightColor: getFlowPresetColor('MATRIX', 'highlightColor', getFlowPresetValue('matrix', 'highlightColor', '#00ff00')),
            particleColor: getFlowPresetColor('MATRIX', 'particleColor', getFlowPresetValue('matrix', 'particleColor', '#88ff88')),
            dimColor: getFlowPresetColor('MATRIX', 'dimColor', getFlowPresetValue('matrix', 'dimColor', '#001100')),
            edgeColor: getFlowPresetColor('MATRIX', 'edgeColor', getFlowPresetValue('matrix', 'edgeColor', '#00cc00')),
            particleCount: getFlowPresetValue('matrix', 'particleCount', 6),
            particleWidth: getFlowPresetValue('matrix', 'particleWidth', 1.5),
            particleSpeed: getFlowPresetValue('matrix', 'particleSpeed', 0.015),
            edgeWidthScale: getFlowPresetValue('matrix', 'edgeWidthScale', 2.0),
            sizeMultiplier: getFlowPresetValue('matrix', 'sizeMultiplier', 1.4),
            edgeOpacityMin: getFlowPresetValue('matrix', 'edgeOpacityMin', 0.2),
            dimOpacity: getFlowPresetValue('matrix', 'dimOpacity', 0.02)
        },
        {
            name: 'PULSE',
            highlightColor: getFlowPresetColor('PULSE', 'highlightColor', getFlowPresetValue('pulse', 'highlightColor', '#ff4444')),
            particleColor: getFlowPresetColor('PULSE', 'particleColor', getFlowPresetValue('pulse', 'particleColor', '#ff8888')),
            dimColor: getFlowPresetColor('PULSE', 'dimColor', getFlowPresetValue('pulse', 'dimColor', '#110000')),
            edgeColor: getFlowPresetColor('PULSE', 'edgeColor', getFlowPresetValue('pulse', 'edgeColor', '#cc2222')),
            particleCount: getFlowPresetValue('pulse', 'particleCount', 2),
            particleWidth: getFlowPresetValue('pulse', 'particleWidth', 4.0),
            particleSpeed: getFlowPresetValue('pulse', 'particleSpeed', 0.004),
            edgeWidthScale: getFlowPresetValue('pulse', 'edgeWidthScale', 5.0),
            sizeMultiplier: getFlowPresetValue('pulse', 'sizeMultiplier', 2.2),
            edgeOpacityMin: getFlowPresetValue('pulse', 'edgeOpacityMin', 0.4),
            dimOpacity: getFlowPresetValue('pulse', 'dimOpacity', 0.06)
        },
        {
            name: 'AURORA',
            highlightColor: getFlowPresetColor('AURORA', 'highlightColor', getFlowPresetValue('aurora', 'highlightColor', '#33ccbb')),
            particleColor: getFlowPresetColor('AURORA', 'particleColor', getFlowPresetValue('aurora', 'particleColor', '#66ffee')),
            dimColor: getFlowPresetColor('AURORA', 'dimColor', getFlowPresetValue('aurora', 'dimColor', '#002222')),
            edgeColor: getFlowPresetColor('AURORA', 'edgeColor', getFlowPresetValue('aurora', 'edgeColor', '#22aa99')),
            particleCount: getFlowPresetValue('aurora', 'particleCount', 4),
            particleWidth: getFlowPresetValue('aurora', 'particleWidth', 2.2),
            particleSpeed: getFlowPresetValue('aurora', 'particleSpeed', 0.007),
            edgeWidthScale: getFlowPresetValue('aurora', 'edgeWidthScale', 3.5),
            sizeMultiplier: getFlowPresetValue('aurora', 'sizeMultiplier', 1.7),
            edgeOpacityMin: getFlowPresetValue('aurora', 'edgeOpacityMin', 0.28),
            dimOpacity: getFlowPresetValue('aurora', 'dimOpacity', 0.04)
        }
    ];

    let currentPresetIndex = 0;

    // ═══════════════════════════════════════════════════════════════════════
    // TOGGLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function toggle() {
        const flowMode = window.flowMode;

        // If already in flow mode, cycle to next preset
        if (flowMode) {
            currentPresetIndex = (currentPresetIndex + 1) % PRESETS.length;
            const preset = PRESETS[currentPresetIndex];
            console.log(`[Flow] Cycling to preset: ${preset.name}`);
            applyVisualization();
            window.showModeToast(`FLOW: ${preset.name}`);
            return;
        }

        window.flowMode = true;
        currentPresetIndex = 0;
        console.log('[Flow] Toggled to:', window.flowMode);

        // Sync BOTH potential buttons (Dock vs CommandBar)
        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.toggle('active', window.flowMode);

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.toggle('active', window.flowMode);

        // Show/hide flow legend
        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.toggle('visible', window.flowMode);

        // EXCLUSIVE MODE: Clear other visual noise
        if (typeof window.clearAllFileModes === 'function') {
            window.clearAllFileModes();
        }
        // Ensure standard file/hull buttons are off
        document.querySelectorAll('.file-mode-btn').forEach(b => b.classList.remove('active'));

        applyVisualization();
        const preset = PRESETS[currentPresetIndex];
        window.showModeToast(`FLOW: ${preset.name}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DISABLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function disable() {
        if (!window.flowMode) return;
        window.flowMode = false;
        currentPresetIndex = 0;

        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.remove('active');

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.remove('active');

        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.remove('visible');

        clearVisualization();
        window.showModeToast('Flow mode off');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyVisualization() {
        const Graph = window.Graph;
        const DM = window.DM;

        // Guard: Ensure Graph is ready
        if (!Graph || !DM) {
            console.warn('[Flow] Graph or DM not ready');
            return;
        }

        // Get current preset settings
        const preset = PRESETS[currentPresetIndex];
        const markov = DM.getMarkov ? DM.getMarkov() : {};
        const highEntropy = markov.high_entropy_nodes || [];

        // Use preset values (fallback to FLOW_CONFIG for topK/minWeight if not in preset)
        const flowCfg = window.FLOW_CONFIG || {};
        const highlightColor = preset.highlightColor;
        const particleColor = preset.particleColor;
        const sizeMult = preset.sizeMultiplier;
        const edgeScale = preset.edgeWidthScale;
        const particleCount = preset.particleCount;
        const particleWidth = preset.particleWidth;
        const particleSpeed = preset.particleSpeed;
        const edgeOpacityMin = preset.edgeOpacityMin;
        const dimOpacity = preset.dimOpacity;
        const topK = flowCfg.topKEdges || 3;
        const minWeight = flowCfg.minWeight || 0.01;

        // Build set of high entropy node names
        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();
        highEntropy.forEach(n => highEntropyNodes.add(n.node));
        window.highEntropyNodes = highEntropyNodes;

        const graphNodes = Graph.graphData().nodes;
        const graphLinks = Graph.graphData().links;

        // THRESHOLDING: Build a map of top-K outgoing edges per source node
        const edgesBySource = new Map();
        graphLinks.forEach(link => {
            const srcId = typeof link.source === 'object' ? link.source.id : link.source;
            if (!edgesBySource.has(srcId)) {
                edgesBySource.set(srcId, []);
            }
            edgesBySource.get(srcId).push(link);
        });

        // For each source, keep only top-K by markov_weight (transition probability)
        const visibleEdges = new Set();
        edgesBySource.forEach((edges, srcId) => {
            const sorted = edges
                .filter(e => (e.markov_weight || 0) >= minWeight)
                .sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0))
                .slice(0, topK);
            sorted.forEach(e => visibleEdges.add(e));
        });

        // Store original colors and sizes, then apply flow coloring
        const originalNodeColors = window.originalNodeColors || new Map();
        window.originalNodeColors = originalNodeColors;

        graphNodes.forEach(node => {
            if (!originalNodeColors.has(node.id)) {
                originalNodeColors.set(node.id, node.color);
            }
            // Restore original size first (in case switching presets)
            if (node._originalVal) {
                node.val = node._originalVal;
            } else {
                node._originalVal = node.val || 1;
            }
            // High entropy nodes highlighted (decision points)
            if (highEntropyNodes.has(node.name)) {
                node.color = highlightColor;
                node.val = node._originalVal * sizeMult;
            }
        });

        // Update link widths based on markov_weight (with amplification)
        const maxMarkov = Math.max(0.001, ...graphLinks.map(l => l.markov_weight || 0));
        const amplify = window.amplify || (x => x);

        Graph.linkWidth(link => {
            if (!visibleEdges.has(link)) return 0.1;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return 0.5 + amplified * edgeScale * 2;
        });

        // Update link opacity to emphasize important edges
        Graph.linkOpacity(link => {
            if (!visibleEdges.has(link)) return dimOpacity;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return edgeOpacityMin + amplified * (1.0 - edgeOpacityMin);
        });

        // Add directional particles only on visible edges
        Graph.linkDirectionalParticles(link => {
            if (!visibleEdges.has(link)) return 0;
            return particleCount;
        });
        Graph.linkDirectionalParticleWidth(particleWidth);
        Graph.linkDirectionalParticleSpeed(particleSpeed);
        Graph.linkDirectionalParticleColor(() => particleColor);

        // Update node coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }

        // Debug: count edges with markov weights
        const edgesWithMarkov = graphLinks.filter(l => l.markov_weight > 0).length;
        console.log(`[Flow] Preset: ${preset.name} | ${highEntropyNodes.size} high entropy nodes, ${visibleEdges.size} visible edges (top-${topK}), ${edgesWithMarkov}/${graphLinks.length} edges with markov`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CLEAR FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function clearVisualization() {
        const Graph = window.Graph;

        // Guard: Ensure Graph is ready
        if (!Graph) return;

        const graphNodes = Graph.graphData().nodes;
        const originalNodeColors = window.originalNodeColors || new Map();

        // Restore original node colors and sizes
        graphNodes.forEach(node => {
            if (originalNodeColors.has(node.id)) {
                node.color = originalNodeColors.get(node.id);
            }
            // Restore original size from saved value
            if (node._originalVal) {
                node.val = node._originalVal;
                delete node._originalVal;
            }
        });

        // Reset link widths
        Graph.linkWidth(1);

        // Reset link opacity
        Graph.linkOpacity(0.6);

        // Remove directional particles
        Graph.linkDirectionalParticles(0);

        // Update coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getPresetColor: getFlowPresetColor,
        getPresetValue: getFlowPresetValue,
        toggle: toggle,
        disable: disable,
        apply: applyVisualization,
        clear: clearVisualization,
        PRESETS: PRESETS,
        getCurrentPreset: () => PRESETS[currentPresetIndex],
        getCurrentPresetIndex: () => currentPresetIndex
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getFlowPresetColor = FLOW.getPresetColor;
window.getFlowPresetValue = FLOW.getPresetValue;
window.toggleFlowMode = FLOW.toggle;
window.disableFlowMode = FLOW.disable;
window.applyFlowVisualization = FLOW.apply;
window.clearFlowVisualization = FLOW.clear;
window.FLOW_PRESETS = FLOW.PRESETS;

console.log('[Module] FLOW loaded - 6 functions');


// ═══ MODULE: modules/ui-builders.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UI-BUILDERS MODULE - DOM element construction utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Factory functions for building common UI elements: checkboxes, toggles,
 * filter groups, and option selectors.
 *
 * @module UI_BUILDERS
 * @version 1.0.0
 */

window.UI_BUILDERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // COUNT COLLECTION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Collect counts by key from items
     * @param {Array} items - Items to count
     * @param {Function} keyFn - Function to extract key from item
     * @returns {Array} Array of [key, count] pairs sorted by count desc
     */
    function collectCounts(items, keyFn) {
        const counts = new Map();
        items.forEach(item => {
            const key = keyFn(item);
            if (!key) return;
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHECKBOX ROW
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a checkbox row element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Element ID
     * @param {string} label - Display label
     * @param {number|null} count - Optional count to display
     * @param {boolean} checked - Initial checked state
     * @param {Function} onChange - Callback when checkbox changes
     * @returns {HTMLInputElement} The checkbox input element
     */
    function buildCheckboxRow(container, id, label, count, checked, onChange) {
        const row = document.createElement('div');
        row.className = 'filter-item';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = id;
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('label');
        text.setAttribute('for', id);
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'filter-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        row.appendChild(input);
        row.appendChild(text);
        if (countEl.textContent) {
            row.appendChild(countEl);
        }
        container.appendChild(row);

        return input;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER GROUP
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a filter group with ALL checkbox and individual items
     * @param {string} containerId - Container element ID
     * @param {Array} items - Array of [value, count] pairs
     * @param {Set} stateSet - Set to track selected values
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildFilterGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const allId = `${containerId}-all`;
        let allCheckbox = null;

        allCheckbox = buildCheckboxRow(container, allId, 'ALL', null, true, (checked) => {
            stateSet.clear();
            if (checked) {
                items.forEach(([value]) => stateSet.add(value));
            }
            container.querySelectorAll('input[type="checkbox"]').forEach(box => {
                if (box.id !== allId) box.checked = checked;
            });
            onUpdate();
        });

        items.forEach(([value, count], index) => {
            const id = `${containerId}-${index}`;
            const checked = stateSet.has(value);
            buildCheckboxRow(container, id, value, count, checked, (isChecked) => {
                if (isChecked) {
                    stateSet.add(value);
                } else {
                    stateSet.delete(value);
                }
                const allChecked = items.every(([v]) => stateSet.has(v));
                allCheckbox.checked = allChecked;
                onUpdate();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a datamap toggle element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Toggle ID
     * @param {string} label - Display label
     * @param {boolean} checked - Initial checked state
     * @param {number|null} count - Optional count to display
     * @param {Function} onChange - Callback when toggle changes
     * @returns {Object} Object with wrapper, input, and count elements
     */
    function buildDatamapToggle(container, id, label, checked, count, onChange) {
        const wrapper = document.createElement('label');
        wrapper.className = 'datamap-toggle';
        wrapper.setAttribute('data-id', id);

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('span');
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'datamap-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        wrapper.appendChild(input);
        wrapper.appendChild(text);
        wrapper.appendChild(countEl);
        container.appendChild(wrapper);

        return { wrapper, input, count: countEl };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // EXCLUSIVE OPTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build exclusive (radio-like) options using checkboxes
     * @param {string} containerId - Container element ID
     * @param {Array} options - Array of {label, value} objects
     * @param {*} activeValue - Currently active value
     * @param {Function} onSelect - Callback when option is selected
     */
    function buildExclusiveOptions(containerId, options, activeValue, onSelect) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const inputs = [];
        options.forEach((option, index) => {
            const id = `${containerId}-${index}`;
            const input = buildCheckboxRow(
                container,
                id,
                option.label,
                null,
                option.value === activeValue,
                (checked) => {
                    if (!checked) {
                        input.checked = true;
                        return;
                    }
                    inputs.forEach(other => {
                        if (other !== input) other.checked = false;
                    });
                    onSelect(option.value);
                }
            );
            inputs.push(input);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHIP GROUP BUILDER - Filter chips with ALL toggle
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build chip buttons for filter groups
     * @param {string} containerId - Container element ID
     * @param {Map} items - Map of key -> count
     * @param {Set} stateSet - Set tracking selected items
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildChipGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        // "ALL" chip
        const allChip = document.createElement('button');
        allChip.className = 'chip active';
        allChip.textContent = 'ALL';
        allChip.addEventListener('click', () => {
            // Toggle all on/off
            const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
            if (allActive) {
                stateSet.clear();
                container.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
            } else {
                items.forEach((count, key) => stateSet.add(key));
                container.querySelectorAll('.chip').forEach(c => c.classList.add('active'));
            }
            if (onUpdate) onUpdate();
        });
        container.appendChild(allChip);

        // Individual chips
        items.forEach((count, key) => {
            const chip = document.createElement('button');
            chip.className = 'chip' + (stateSet.has(key) ? ' active' : '');
            chip.innerHTML = `${key}<span class="chip-count">${count}</span>`;
            chip.addEventListener('click', () => {
                if (stateSet.has(key)) {
                    stateSet.delete(key);
                    chip.classList.remove('active');
                } else {
                    stateSet.add(key);
                    chip.classList.add('active');
                }
                // Update "ALL" chip state
                const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
                allChip.classList.toggle('active', allActive);
                if (onUpdate) onUpdate();
            });
            container.appendChild(chip);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA CONTROLS - Visibility toggles
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build metadata visibility controls
     * @param {string} containerId - Container element ID
     * @param {Object} metadata - Metadata state object with boolean flags
     */
    function buildMetadataControls(containerId, metadata) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const toggles = [
            { id: 'meta-labels', label: 'LABELS', key: 'showLabels' },
            { id: 'meta-file-panel', label: 'FILE PANEL', key: 'showFilePanel' },
            { id: 'meta-report', label: 'REPORT', key: 'showReportPanel' },
            { id: 'meta-edges', label: 'EDGES', key: 'showEdges' }
        ];

        toggles.forEach((toggle) => {
            buildCheckboxRow(container, toggle.id, toggle.label, null, metadata[toggle.key], (checked) => {
                metadata[toggle.key] = checked;
                if (typeof applyMetadataVisibility === 'function') applyMetadataVisibility();
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPEARANCE SLIDERS - Pure UI builder (decoupled from global state)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build appearance sliders - PURE UI, no global dependencies
     *
     * @param {string} containerId - Container element ID
     * @param {Array} sliderDefs - Array of slider definitions:
     *   { id, label, min, max, step, value, onChange?, description?, className? }
     * @param {Function} globalOnChange - Optional global callback: (sliderId, newValue) => void
     *
     * Supports two patterns:
     * 1. Individual: Each sliderDef has its own onChange(value) handler
     * 2. Global: A single globalOnChange(sliderId, value) handles all
     */
    function buildAppearanceSliders(containerId, sliderDefs, globalOnChange) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row' + (def.className ? ' ' + def.className : '');

            // Header row with label and value
            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            const safeValue = def.value ?? def.min ?? 0;
            valueDisplay.textContent = safeValue.toFixed(def.step < 1 ? 2 : 0);
            header.appendChild(label);
            header.appendChild(valueDisplay);

            // The slider input
            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = safeValue;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = val.toFixed(def.step < 1 ? 2 : 0);
                // Support both patterns: individual onChange or global
                if (def.onChange) def.onChange(val);
                if (globalOnChange) globalOnChange(def.id, val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);

            // Optional description for meta-sliders
            if (def.description) {
                const desc = document.createElement('div');
                desc.className = 'slider-desc';
                desc.textContent = def.description;
                wrapper.appendChild(desc);
            }

            container.appendChild(wrapper);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        collectCounts: collectCounts,
        buildCheckboxRow: buildCheckboxRow,
        buildFilterGroup: buildFilterGroup,
        buildDatamapToggle: buildDatamapToggle,
        buildExclusiveOptions: buildExclusiveOptions,
        buildChipGroup: buildChipGroup,
        buildMetadataControls: buildMetadataControls,
        buildAppearanceSliders: buildAppearanceSliders
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.collectCounts = UI_BUILDERS.collectCounts;
window.buildCheckboxRow = UI_BUILDERS.buildCheckboxRow;
window.buildFilterGroup = UI_BUILDERS.buildFilterGroup;
window.buildDatamapToggle = UI_BUILDERS.buildDatamapToggle;
window.buildExclusiveOptions = UI_BUILDERS.buildExclusiveOptions;
window.buildChipGroup = UI_BUILDERS.buildChipGroup;
window.buildMetadataControls = UI_BUILDERS.buildMetadataControls;
// Note: buildAppearanceSliders shim is in app.js (orchestration layer)

console.log('[Module] UI_BUILDERS loaded - 8 functions (appearance sliders decoupled)');


// ═══ MODULE: modules/layout-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT-HELPERS MODULE - Layout stability and position utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Functions for saving/restoring node positions, freezing/unfreezing layout,
 * and calculating file positions.
 * Depends on: Graph, NODE_POSITION_CACHE, LAYOUT_FROZEN, IS_3D
 *
 * @module LAYOUT_HELPERS
 * @version 1.0.0
 */

window.LAYOUT_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // POSITION PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Save current node positions to cache
     */
    function saveNodePositions() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;
        if (!Graph || !cache) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined && node.y !== undefined) {
                cache.set(node.id, {
                    x: node.x, y: node.y, z: node.z || 0,
                    vx: node.vx || 0, vy: node.vy || 0, vz: node.vz || 0,
                    fx: node.fx, fy: node.fy, fz: node.fz
                });
            }
        });
    }

    /**
     * Restore node positions from cache
     * @param {Array} nodes - Nodes to restore positions for
     */
    function restoreNodePositions(nodes) {
        const cache = window.NODE_POSITION_CACHE;
        const frozen = window.LAYOUT_FROZEN;
        if (!cache) return;

        nodes.forEach(node => {
            const cached = cache.get(node.id);
            if (cached) {
                node.x = cached.x;
                node.y = cached.y;
                node.z = cached.z;
                node.vx = cached.vx;
                node.vy = cached.vy;
                node.vz = cached.vz;
                // Pin nodes in place when layout is frozen
                if (frozen) {
                    node.fx = cached.x;
                    node.fy = cached.y;
                    node.fz = cached.z;
                }
            }
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LAYOUT FREEZE/UNFREEZE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Freeze layout by pinning all nodes in place
     */
    function freezeLayout() {
        window.LAYOUT_FROZEN = true;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined) {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            }
        });
        Graph.cooldownTicks(0);  // Stop simulation immediately
    }

    /**
     * Unfreeze layout by unpinning all nodes
     */
    function unfreezeLayout() {
        window.LAYOUT_FROZEN = false;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            node.fx = undefined;
            node.fy = undefined;
            node.fz = undefined;
        });
    }

    /**
     * Reset layout - clear cache and reheat simulation
     */
    function resetLayout() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;

        // Clear position cache
        if (cache) cache.clear();

        // Unfreeze and restart simulation
        unfreezeLayout();

        if (Graph) {
            Graph.cooldownTicks(200);  // Allow simulation to run
            Graph.d3ReheatSimulation();
        }

        if (typeof window.showModeToast === 'function') {
            window.showModeToast('Layout reset - physics running');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LINK/FILE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get the ID of a link endpoint (source or target)
     * @param {Object} link - The link object
     * @param {string} side - 'source' or 'target'
     * @returns {string|undefined} The endpoint ID
     */
    function getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.id || endpoint;
        }
        return endpoint;
    }

    /**
     * Calculate target position for a file node in radial layout
     * @param {number} fileIdx - Index of the file
     * @param {number} totalFiles - Total number of files
     * @param {number} radius - Radius of the circle
     * @param {number} zSpacing - Z-axis spacing between files
     * @returns {Object} Position {x, y, z}
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpacing) {
        if (totalFiles <= 0) {
            return { x: 0, y: 0, z: 0 };
        }
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        const is3D = window.IS_3D;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: is3D ? (fileIdx - totalFiles / 2) * zSpacing : 0
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        savePositions: saveNodePositions,
        restorePositions: restoreNodePositions,
        freeze: freezeLayout,
        unfreeze: unfreezeLayout,
        reset: resetLayout,
        getLinkEndpointId: getLinkEndpointId,
        getFileTarget: getFileTarget
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.saveNodePositions = LAYOUT_HELPERS.savePositions;
window.restoreNodePositions = LAYOUT_HELPERS.restorePositions;
window.freezeLayout = LAYOUT_HELPERS.freeze;
window.unfreezeLayout = LAYOUT_HELPERS.unfreeze;
window.resetLayout = LAYOUT_HELPERS.reset;
window.getLinkEndpointId = LAYOUT_HELPERS.getLinkEndpointId;
window.getFileTarget = LAYOUT_HELPERS.getFileTarget;

console.log('[Module] LAYOUT_HELPERS loaded - 7 functions');


// ═══ MODULE: modules/spatial.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SPATIAL MODULE - Spatial algorithms and collision detection
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Spatial hashing for O(n) collision detection, convex hull calculation,
 * and node sampling utilities.
 * Depends on: IS_3D, FILE_CONTAINMENT, THREE
 *
 * @module SPATIAL
 * @version 1.0.0
 */

window.SPATIAL = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SAMPLING
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Sample nodes evenly if there are too many
     * @param {Array} nodes - Array of nodes
     * @param {number} maxPoints - Maximum number of points to return
     * @returns {Array} Sampled nodes
     */
    function sampleFileNodes(nodes, maxPoints) {
        if (nodes.length <= maxPoints) return nodes;
        const step = Math.ceil(nodes.length / maxPoints);
        return nodes.filter((_, idx) => idx % step === 0);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVEX HULL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build 2D convex hull using Andrew's monotone chain algorithm
     * @param {Array} points - Array of {x, y} points
     * @returns {Array|null} Hull points or null if insufficient points
     */
    function buildHull2D(points) {
        if (points.length < 3) return null;

        // Remove duplicates
        const unique = new Map();
        points.forEach(p => {
            const key = `${p.x.toFixed(4)},${p.y.toFixed(4)}`;
            if (!unique.has(key)) unique.set(key, p);
        });

        // Sort by x, then y
        const pts = Array.from(unique.values()).sort((a, b) => {
            if (a.x === b.x) return a.y - b.y;
            return a.x - b.x;
        });

        if (pts.length < 3) return null;

        // Cross product of vectors OA and OB
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

        // Build lower hull
        const lower = [];
        for (const p of pts) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                lower.pop();
            }
            lower.push(p);
        }

        // Build upper hull
        const upper = [];
        for (let i = pts.length - 1; i >= 0; i--) {
            const p = pts[i];
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                upper.pop();
            }
            upper.push(p);
        }

        // Remove last point of each half (it's the starting point of the other)
        upper.pop();
        lower.pop();

        return lower.concat(upper);
    }

    /**
     * Compute centroid of points
     * @param {Array} points - Array of THREE.Vector3-like objects
     * @returns {THREE.Vector3} Centroid
     */
    function computeCentroid(points) {
        const THREE = window.THREE;
        const centroid = new THREE.Vector3();
        points.forEach(p => centroid.add(p));
        return centroid.divideScalar(Math.max(1, points.length));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SPATIAL HASHING - O(n) collision detection
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build spatial hash grid for efficient neighbor queries
     * @param {Array} nodes - Array of nodes with x, y, z coordinates
     * @param {number} cellSize - Size of each grid cell
     * @returns {Map} Grid map with cell keys to node arrays
     */
    function buildSpatialGrid(nodes, cellSize) {
        const is3D = window.IS_3D;
        const grid = new Map();

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) grid.set(key, []);
            grid.get(key).push(node);
        });

        // Store for file containment
        if (window.FILE_CONTAINMENT) {
            window.FILE_CONTAINMENT.spatialGrid = grid;
        }

        return grid;
    }

    /**
     * Get keys for neighboring cells (3x3x3 in 3D, 3x3 in 2D)
     * @param {number} cellX - Cell X coordinate
     * @param {number} cellY - Cell Y coordinate
     * @param {number} cellZ - Cell Z coordinate
     * @returns {Array} Array of neighbor cell keys
     */
    function getNeighborCells(cellX, cellY, cellZ) {
        const is3D = window.IS_3D;
        const neighbors = [];

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = is3D ? -1 : 0; dz <= (is3D ? 1 : 0); dz++) {
                    neighbors.push(`${cellX + dx},${cellY + dy},${cellZ + dz}`);
                }
            }
        }

        return neighbors;
    }

    /**
     * Apply soft collision forces to push overlapping nodes apart
     * @param {Array} nodes - Array of nodes
     * @param {number} cellSize - Spatial grid cell size
     * @param {number} repulsionStrength - Strength of repulsion (0-1)
     */
    function applySoftCollisions(nodes, cellSize, repulsionStrength = 0.5) {
        const containment = window.FILE_CONTAINMENT;
        const is3D = window.IS_3D;

        if (!containment || !containment.collisionEnabled) return;

        const grid = buildSpatialGrid(nodes, cellSize);
        const minDist = 8;  // Minimum distance between particles
        const minDistSq = minDist * minDist;

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            if (!node.__physics) {
                node.__physics = { vx: 0, vy: 0, vz: 0 };
            }

            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const neighborKeys = getNeighborCells(cellX, cellY, cellZ);

            neighborKeys.forEach(key => {
                const cellNodes = grid.get(key);
                if (!cellNodes) return;

                cellNodes.forEach(other => {
                    if (other === node) return;

                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dz = is3D ? ((node.z || 0) - (other.z || 0)) : 0;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < minDistSq && distSq > 0.001) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        const force = (overlap / minDist) * repulsionStrength;

                        // Push apart along normal
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = is3D ? dz / dist : 0;

                        node.__physics.vx += nx * force;
                        node.__physics.vy += ny * force;
                        if (is3D) node.__physics.vz += nz * force;
                    }
                });
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        sampleFileNodes: sampleFileNodes,
        buildHull2D: buildHull2D,
        computeCentroid: computeCentroid,
        buildSpatialGrid: buildSpatialGrid,
        getNeighborCells: getNeighborCells,
        applySoftCollisions: applySoftCollisions
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.sampleFileNodes = SPATIAL.sampleFileNodes;
window.buildHull2D = SPATIAL.buildHull2D;
window.computeCentroid = SPATIAL.computeCentroid;
window.buildSpatialGrid = SPATIAL.buildSpatialGrid;
window.getNeighborCells = SPATIAL.getNeighborCells;
window.applySoftCollisions = SPATIAL.applySoftCollisions;

console.log('[Module] SPATIAL loaded - 6 functions');


// ═══ MODULE: modules/layout.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT MODULE - Unified UI Layout Engine
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * MIGRATED FROM: app.js HudLayoutManager (390 lines)
 * This is the SINGLE SOURCE OF TRUTH for UI layout intelligence.
 *
 * Features:
 *   - Panel placement with collision avoidance (from HudLayoutManager)
 *   - Component registration system (NEW)
 *   - Toast/control-bar collision detection (NEW)
 *   - Min-width graph validation (NEW)
 *   - Debug overlay with Ctrl+Shift+L (NEW)
 *
 * @module LAYOUT
 * @version 2.0.0
 * @confidence 94%
 */

window.LAYOUT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CONFIGURATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    const CONFIG = {
        MARGIN: 16,
        MIN_GRAPH_WIDTH: 320,
        REFLOW_THROTTLE_MS: 50,
        DEBUG_COLORS: {
            dock: 'rgba(100, 150, 255, 0.3)',
            overlay: 'rgba(255, 150, 100, 0.3)',
            floating: 'rgba(100, 255, 150, 0.3)',
            fixed: 'rgba(150, 150, 150, 0.3)'
        }
    };

    // Panels by priority (higher = more important, won't be moved)
    // MIGRATED from HudLayoutManager
    const FIXED_PANELS = ['top-left-header', 'stats-panel', 'metrics-panel', 'bottom-dock', 'report-panel', 'side-dock'];
    const DYNAMIC_PANELS = ['hover-panel', 'file-panel', 'selection-panel'];

    // ═══════════════════════════════════════════════════════════════════════
    // STATE
    // ═══════════════════════════════════════════════════════════════════════

    // Throttle state (from HudLayoutManager)
    let _rafPending = false;
    let _lastReflow = 0;

    // Mouse position for hover-panel placement (from HudLayoutManager)
    let _mouseX = 0;
    let _mouseY = 0;

    // Component registry (NEW)
    const _registry = new Map();

    // Debug overlay state (NEW)
    let _debugEnabled = false;
    let _debugOverlay = null;

    // ═══════════════════════════════════════════════════════════════════════
    // VIEWPORT & RECT UTILITIES (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get viewport rectangle with margins
     */
    function getViewport() {
        return {
            left: CONFIG.MARGIN,
            top: CONFIG.MARGIN,
            right: window.innerWidth - CONFIG.MARGIN,
            bottom: window.innerHeight - CONFIG.MARGIN,
            width: window.innerWidth - 2 * CONFIG.MARGIN,
            height: window.innerHeight - 2 * CONFIG.MARGIN
        };
    }

    /**
     * Check if sidebar is effectively "open" (occupying space)
     */
    function isSidebarOpen() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock) return false;
        const state = window.SIDEBAR_STATE;
        return (state && (state.locked || state.open)) ||
            sideDock.classList.contains('locked') ||
            sideDock.classList.contains('expanded') ||
            sideDock.matches(':hover');
    }

    /**
     * Get rectangle for an element (returns null if hidden/missing)
     */
    function getRect(el) {
        if (!el) return null;
        if (typeof el === 'string') {
            el = document.getElementById(el) || document.querySelector(el);
        }
        if (!el) return null;
        const style = window.getComputedStyle(el);
        if (style.display === 'none' || style.visibility === 'hidden') return null;
        const r = el.getBoundingClientRect();
        if (r.width === 0 && r.height === 0) return null;
        return { left: r.left, top: r.top, right: r.right, bottom: r.bottom, width: r.width, height: r.height };
    }

    /**
     * Get sidebar occupied region (full expanded width when open)
     */
    function getSidebarRect() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock || !isSidebarOpen()) return null;
        const sideWidth = parseInt(getComputedStyle(sideDock).getPropertyValue('--side-width')) || 260;
        return {
            left: 0,
            top: 0,
            right: 16 + sideWidth + 20,
            bottom: window.innerHeight,
            width: 16 + sideWidth + 20,
            height: window.innerHeight
        };
    }

    /**
     * Get all occupied rectangles (fixed panels + sidebar when open)
     */
    function getOccupiedRects() {
        const rects = [];

        // Sidebar takes priority when open
        const sidebarRect = getSidebarRect();
        if (sidebarRect) rects.push(sidebarRect);

        // Fixed panels
        FIXED_PANELS.forEach(id => {
            if (id === 'side-dock') return;
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (rect) rects.push(rect);
        });

        // Top-left header (special case - class-based)
        const topLeft = document.querySelector('.top-left');
        const topLeftRect = getRect(topLeft);
        if (topLeftRect) rects.push(topLeftRect);

        return rects;
    }

    /**
     * Calculate overlap area between two rectangles
     */
    function overlapArea(r1, r2) {
        if (!r1 || !r2) return 0;
        const xOverlap = Math.max(0, Math.min(r1.right, r2.right) - Math.max(r1.left, r2.left));
        const yOverlap = Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
        return xOverlap * yOverlap;
    }

    /**
     * Check if rect is fully inside viewport
     */
    function isInsideViewport(rect, viewport) {
        return rect.left >= viewport.left &&
            rect.top >= viewport.top &&
            rect.right <= viewport.right &&
            rect.bottom <= viewport.bottom;
    }

    /**
     * Clamp position to keep panel inside viewport
     */
    function clampToViewport(pos, panelWidth, panelHeight, viewport) {
        return {
            left: Math.max(viewport.left, Math.min(pos.left, viewport.right - panelWidth)),
            top: Math.max(viewport.top, Math.min(pos.top, viewport.bottom - panelHeight))
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CANDIDATE GENERATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Generate candidate positions for file panel
     */
    function getFilePanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Generate candidate positions for selection panel
     */
    function getSelectionPanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Get screen centroid of selected nodes
     */
    function getSelectionCentroid() {
        const Graph = window.Graph;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (!Graph || !Graph.graphData || !selectedIds || selectedIds.size === 0) return null;

        const nodes = Graph.graphData().nodes || [];
        const selectedNodes = nodes.filter(n => selectedIds.has(n.id));
        if (selectedNodes.length === 0) return null;

        let sumX = 0, sumY = 0, sumZ = 0;
        selectedNodes.forEach(n => {
            sumX += n.x || 0;
            sumY += n.y || 0;
            sumZ += n.z || 0;
        });
        const centroid3D = {
            x: sumX / selectedNodes.length,
            y: sumY / selectedNodes.length,
            z: sumZ / selectedNodes.length
        };

        const camera = Graph.camera();
        if (!camera || !window.THREE) return null;
        const vector = new window.THREE.Vector3(centroid3D.x, centroid3D.y, centroid3D.z);
        vector.project(camera);
        return {
            x: (vector.x * 0.5 + 0.5) * window.innerWidth,
            y: (-vector.y * 0.5 + 0.5) * window.innerHeight
        };
    }

    /**
     * Generate candidate positions for hover panel
     */
    function getHoverPanelCandidates(mouseX, mouseY, panelWidth, panelHeight) {
        const vp = getViewport();
        const offset = 16;

        let anchorX = mouseX;
        let anchorY = mouseY;

        const hoveredNode = window.HOVERED_NODE;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (hoveredNode && selectedIds && selectedIds.has(hoveredNode.id)) {
            const centroid = getSelectionCentroid();
            if (centroid) {
                anchorX = mouseX * 0.3 + centroid.x * 0.7;
                anchorY = mouseY * 0.3 + centroid.y * 0.7;
            }
        }

        const sidebarOpen = isSidebarOpen();
        const sidebarRect = sidebarOpen ? getSidebarRect() : null;
        const minLeft = sidebarRect ? sidebarRect.right + offset : vp.left;

        let candidates = [
            { left: anchorX + offset, top: anchorY - panelHeight - offset },
            { left: anchorX + offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY - panelHeight - offset }
        ];

        if (sidebarRect) {
            candidates = candidates.map(c => ({
                left: Math.max(c.left, minLeft),
                top: c.top
            }));
        }

        return candidates;
    }

    /**
     * Update mouse position
     */
    function updateMousePosition(x, y) {
        _mouseX = x;
        _mouseY = y;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PANEL PLACEMENT (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Place a panel at the best position (least overlap)
     */
    function placePanel(panelEl, candidates, occupiedRects) {
        if (!panelEl) return null;

        const rect = panelEl.getBoundingClientRect();
        const panelWidth = rect.width || 400;
        const panelHeight = rect.height || 350;
        const viewport = getViewport();

        let bestPos = candidates[0];
        let bestOverlap = Infinity;

        for (const pos of candidates) {
            const clampedPos = clampToViewport(pos, panelWidth, panelHeight, viewport);
            const panelRect = {
                left: clampedPos.left,
                top: clampedPos.top,
                right: clampedPos.left + panelWidth,
                bottom: clampedPos.top + panelHeight
            };

            let totalOverlap = 0;
            for (const occRect of occupiedRects) {
                totalOverlap += overlapArea(panelRect, occRect);
            }

            if (!isInsideViewport(panelRect, viewport)) {
                totalOverlap += 10000;
            }

            if (totalOverlap < bestOverlap) {
                bestOverlap = totalOverlap;
                bestPos = clampedPos;
                if (totalOverlap === 0) break;
            }
        }

        return bestPos;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST/CONTROL-BAR COLLISION (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Check and resolve toast/control-bar collision
     * Returns offset to apply to toast if collision detected
     */
    function resolveToastCollision() {
        const toast = document.getElementById('toast') ||
                      document.getElementById('hud-toast') ||
                      document.getElementById('mode-toast');
        const controlBar = document.querySelector('.control-bar');

        if (!toast || !controlBar) return 0;

        const toastRect = getRect(toast);
        const barRect = getRect(controlBar);

        if (!toastRect || !barRect) return 0;

        const overlap = overlapArea(toastRect, barRect);
        if (overlap > 0) {
            // Move toast above control bar
            const offset = barRect.height + CONFIG.MARGIN;
            console.log(`[LAYOUT] Toast/control-bar collision: ${overlap}px², offset: -${offset}px`);
            return -offset;
        }
        return 0;
    }

    /**
     * Apply toast offset if needed
     */
    function applyToastOffset() {
        const offset = resolveToastCollision();
        if (offset !== 0) {
            const toast = document.getElementById('toast') ||
                          document.getElementById('hud-toast');
            if (toast) {
                toast.style.transform = `translateX(-50%) translateY(${offset}px)`;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MIN-WIDTH VALIDATOR (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Validate graph has minimum width, adjust sidebars if needed
     */
    function validateGraphWidth() {
        const leftSidebar = document.getElementById('left-sidebar');
        const rightSidebar = document.getElementById('right-sidebar');
        const viewport = getViewport();

        const leftWidth = leftSidebar ? (getRect(leftSidebar)?.width || 0) : 0;
        const rightWidth = rightSidebar ? (getRect(rightSidebar)?.width || 0) : 0;
        const graphWidth = viewport.width - leftWidth - rightWidth;

        if (graphWidth < CONFIG.MIN_GRAPH_WIDTH) {
            const deficit = CONFIG.MIN_GRAPH_WIDTH - graphWidth;
            console.warn(`[LAYOUT] Graph width ${graphWidth}px < ${CONFIG.MIN_GRAPH_WIDTH}px minimum`);

            // Try to reduce right sidebar
            if (rightSidebar && rightWidth > 200) {
                const newWidth = Math.max(200, rightWidth - deficit);
                document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
                return { adjusted: true, component: 'right-sidebar', newWidth };
            }
        }
        return { adjusted: false };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // REFLOW (from HudLayoutManager, enhanced)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Reflow all dynamic panels
     */
    function reflow() {
        const now = Date.now();
        if (now - _lastReflow < CONFIG.REFLOW_THROTTLE_MS) {
            if (!_rafPending) {
                _rafPending = true;
                requestAnimationFrame(() => {
                    _rafPending = false;
                    reflow();
                });
            }
            return;
        }
        _lastReflow = now;

        const occupiedRects = getOccupiedRects();

        // Place hover panel first (higher priority)
        const hoverPanel = document.getElementById('hover-panel');
        let hoverPanelRect = null;
        if (hoverPanel && hoverPanel.classList.contains('visible')) {
            const hoverWidth = hoverPanel.offsetWidth || 280;
            const hoverHeight = hoverPanel.offsetHeight || 200;
            const candidates = getHoverPanelCandidates(_mouseX, _mouseY, hoverWidth, hoverHeight);
            const pos = placePanel(hoverPanel, candidates, occupiedRects);
            if (pos) {
                hoverPanel.style.left = pos.left + 'px';
                hoverPanel.style.top = pos.top + 'px';
                hoverPanel.style.right = 'auto';
                hoverPanelRect = {
                    left: pos.left, top: pos.top,
                    right: pos.left + hoverWidth, bottom: pos.top + hoverHeight
                };
            }
        }

        const filePanelOccupied = [...occupiedRects];
        if (hoverPanelRect) filePanelOccupied.push(hoverPanelRect);

        // Place selection panel
        const selectionPanel = document.getElementById('selection-panel');
        if (selectionPanel && selectionPanel.classList.contains('visible')) {
            const candidates = getSelectionPanelCandidates(
                selectionPanel.offsetWidth || 320,
                selectionPanel.offsetHeight || 280
            );
            const pos = placePanel(selectionPanel, candidates, filePanelOccupied);
            if (pos) {
                selectionPanel.style.left = pos.left + 'px';
                selectionPanel.style.top = pos.top + 'px';
                selectionPanel.style.right = 'auto';
                filePanelOccupied.push({
                    left: pos.left, top: pos.top,
                    right: pos.left + (selectionPanel.offsetWidth || 320),
                    bottom: pos.top + (selectionPanel.offsetHeight || 280)
                });
            }
        }

        // Place file panel
        const filePanel = document.getElementById('file-panel');
        if (filePanel && filePanel.classList.contains('visible')) {
            const candidates = getFilePanelCandidates(
                filePanel.offsetWidth || 400,
                filePanel.offsetHeight || 350
            );
            const pos = placePanel(filePanel, candidates, filePanelOccupied);
            if (pos) {
                filePanel.style.left = pos.left + 'px';
                filePanel.style.top = pos.top + 'px';
                filePanel.style.bottom = 'auto';
            }
        }

        // NEW: Check toast/control-bar collision
        applyToastOffset();

        // NEW: Validate graph width
        validateGraphWidth();

        // NEW: Update debug overlay
        if (_debugEnabled) updateDebugOverlay();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DEBUG OVERLAY (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle debug overlay
     */
    function toggleDebugOverlay() {
        _debugEnabled = !_debugEnabled;

        if (_debugEnabled) {
            if (!_debugOverlay) {
                _debugOverlay = document.createElement('div');
                _debugOverlay.id = 'layout-debug-overlay';
                _debugOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none; z-index: 10001;
                `;
                document.body.appendChild(_debugOverlay);
            }
            updateDebugOverlay();
            console.log('[LAYOUT] Debug overlay ON (Ctrl+Shift+L)');
        } else {
            if (_debugOverlay) {
                _debugOverlay.remove();
                _debugOverlay = null;
            }
            console.log('[LAYOUT] Debug overlay OFF');
        }
    }

    /**
     * Update debug overlay with current component bounds
     */
    function updateDebugOverlay() {
        if (!_debugOverlay) return;

        let html = '';
        const allPanels = [...FIXED_PANELS, ...DYNAMIC_PANELS, 'toast', 'control-bar', 'left-sidebar', 'right-sidebar'];

        allPanels.forEach(id => {
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (!rect) return;

            const kind = FIXED_PANELS.includes(id) ? 'fixed' :
                         DYNAMIC_PANELS.includes(id) ? 'floating' : 'overlay';
            const color = CONFIG.DEBUG_COLORS[kind] || 'rgba(128,128,128,0.3)';

            html += `
                <div style="
                    position: fixed;
                    left: ${rect.left}px; top: ${rect.top}px;
                    width: ${rect.width}px; height: ${rect.height}px;
                    background: ${color};
                    border: 1px solid ${color.replace('0.3', '0.8')};
                    font-size: 10px; color: white; text-shadow: 0 0 2px black;
                    padding: 2px 4px; box-sizing: border-box; overflow: hidden;
                ">${id}</div>
            `;
        });

        _debugOverlay.innerHTML = html;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COMPONENT REGISTRATION (NEW - for future explicit constraints)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Register a component (for explicit constraint tracking)
     */
    function register(descriptor) {
        const { id, selector, kind = 'dock' } = descriptor;
        if (!id) return null;

        let element = typeof selector === 'string' ?
            (document.getElementById(selector.replace('#', '')) || document.querySelector(selector)) :
            selector;

        _registry.set(id, { ...descriptor, element });
        console.log(`[LAYOUT] Registered: ${id} (${kind})`);
        return _registry.get(id);
    }

    /**
     * Get registered component
     */
    function get(id) {
        return _registry.get(id) || null;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize layout system
     */
    function init() {
        // Window resize
        window.addEventListener('resize', () => reflow());

        // Track mouse position
        window.addEventListener('mousemove', (e) => {
            updateMousePosition(e.clientX, e.clientY);
        }, { passive: true });

        // Sidebar state changes
        const sideDock = document.getElementById('side-dock');
        if (sideDock) {
            sideDock.addEventListener('mouseenter', () => reflow());
            sideDock.addEventListener('mouseleave', () => {
                setTimeout(() => reflow(), 200);
            });
        }

        // Debug overlay shortcut (Ctrl+Shift+L)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                e.preventDefault();
                toggleDebugOverlay();
            }
        });

        console.log('[LAYOUT] Initialized (replaces HudLayoutManager)');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Core utilities
        getViewport,
        getRect,
        overlapArea,
        isInsideViewport,
        clampToViewport,

        // Panel placement (backward compatible with HudLayoutManager)
        getOccupiedRects,
        placePanel,
        getFilePanelCandidates,
        getSelectionPanelCandidates,
        getHoverPanelCandidates,
        getSelectionCentroid,
        updateMousePosition,

        // Main entry points
        reflow,
        init,

        // NEW: Validation
        validateGraphWidth,
        resolveToastCollision,

        // NEW: Debug
        toggleDebugOverlay,

        // NEW: Registration
        register,
        get,

        // Config (read-only)
        CONFIG: Object.freeze({ ...CONFIG })
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY: HudLayoutManager alias
// ═══════════════════════════════════════════════════════════════════════════

window.HudLayoutManager = LAYOUT;
window.Layout = LAYOUT;

console.log('[Module] LAYOUT loaded - Unified Layout Engine v2.0.0');


// ═══ MODULE: modules/hud.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HUD MODULE - Heads-up display management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles HUD fade behavior and stats panel updates.
 * Depends on: DOM elements (stat-nodes, stat-edges, stat-entropy, etc.)
 *
 * @module HUD
 * @version 1.0.0
 */

window.HUD = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // HUD FADE BEHAVIOR
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup HUD auto-fade on idle
     * Fades HUD elements after period of inactivity
     */
    function setupFade() {
        const idleDelay = 2200;
        let timer = null;

        const activate = () => {
            document.body.classList.remove('hud-quiet');
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                document.body.classList.add('hud-quiet');
            }, idleDelay);
        };

        ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach((evt) => {
            window.addEventListener(evt, activate, { passive: true });
        });

        activate();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATS UPDATES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all HUD stats elements
     * @param {Object} data - Graph data with nodes, links, meta
     */
    function updateStats(data) {
        if (!data) return;

        // Stats panel: NODES, EDGES, ENTROPY
        const nodeCount = (data.nodes || []).length;
        const edgeCount = (data.links || []).length;

        const statNodes = document.getElementById('stat-nodes');
        const statEdges = document.getElementById('stat-edges');
        const statEntropy = document.getElementById('stat-entropy');

        if (statNodes) statNodes.textContent = nodeCount.toLocaleString();
        if (statEdges) statEdges.textContent = edgeCount.toLocaleString();
        if (statEntropy) {
            const entropy = data.meta?.entropy ?? data.entropy ?? '--';
            statEntropy.textContent = typeof entropy === 'number' ? entropy.toFixed(2) : entropy;
        }

        // Header panel: target name and timestamp
        const targetName = document.getElementById('target-name');
        const timestamp = document.getElementById('timestamp');

        if (targetName) {
            const target = data.meta?.target || data.target || 'Unknown';
            // Show just the last part of the path
            const shortTarget = target.split('/').pop() || target;
            targetName.textContent = shortTarget;
        }

        if (timestamp) {
            const ts = data.meta?.timestamp || data.timestamp || '';
            // Format: 2024-01-15T10:30:00 -> 2024-01-15 10:30
            const formatted = ts.replace('T', ' ').substring(0, 16);
            timestamp.textContent = formatted || 'Live';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupFade: setupFade,
        updateStats: updateStats
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupHudFade = HUD.setupFade;
window.updateHudStats = HUD.updateStats;

console.log('[Module] HUD loaded - 2 functions');


// ═══ MODULE: modules/dimension.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DIMENSION MODULE - 2D/3D dimension switching with animation
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles smooth animated transitions between 2D and 3D graph views.
 * Depends on: Graph, IS_3D, DIMENSION_TRANSITION, stableSeed, stableZ,
 *             fileMode, GRAPH_MODE, applyFileVizMode
 *
 * @module DIMENSION
 * @version 1.1.0
 */

window.DIMENSION = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // DIMENSION TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle between 2D and 3D dimensions
     */
    function toggle() {
        if (window.DIMENSION_TRANSITION) return;
        window.DIMENSION_TRANSITION = true;

        const target3d = !window.IS_3D;
        const button = document.getElementById('btn-2d');

        animateChange(target3d, () => {
            window.IS_3D = target3d;
            window.DIMENSION_TRANSITION = false;
            if (button) button.textContent = window.IS_3D ? '2D' : '3D';

            // Re-apply file viz mode if active
            if (window.fileMode && window.GRAPH_MODE === 'atoms') {
                if (typeof window.applyFileVizMode === 'function') {
                    window.applyFileVizMode();
                }
            }
        });
    }

    /**
     * Setup the dimension toggle button
     */
    function setup() {
        const button = document.getElementById('btn-2d');
        if (!button) return;

        const updateLabel = () => {
            button.textContent = window.IS_3D ? '2D' : '3D';
        };
        updateLabel();
        button.onclick = toggle;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ANIMATED TRANSITION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Animate transition between 2D and 3D
     * @param {boolean} target3d - Whether transitioning to 3D
     * @param {Function} done - Callback when animation completes
     */
    function animateChange(target3d, done) {
        const Graph = window.Graph;
        // STARFIELD & BLOOM removed - nodes ARE the stars, post-processing not in r149+ UMD builds
        const stableSeed = window.stableSeed;
        const stableZ = window.stableZ;

        const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
        const startTime = performance.now();
        const duration = 3000;
        const delayMin = 0;
        const delayMax = 2000;
        const lockPositionsAfterTransition = true;

        const easeInOutSine = (t) => 0.5 - 0.5 * Math.cos(Math.PI * t);

        // Store previous simulation settings
        const previousVelocityDecay = (Graph && Graph.d3VelocityDecay) ? Graph.d3VelocityDecay() : null;
        const previousAlphaTarget = (Graph && Graph.d3AlphaTarget) ? Graph.d3AlphaTarget() : null;
        const previousCooldownTicks = (Graph && Graph.cooldownTicks) ? Graph.cooldownTicks() : null;
        const previousCooldownTime = (Graph && Graph.cooldownTime) ? Graph.cooldownTime() : null;

        // Freeze simulation during transition
        if (Graph && Graph.cooldownTicks) Graph.cooldownTicks(Infinity);
        if (Graph && Graph.cooldownTime) Graph.cooldownTime(Infinity);
        if (Graph && Graph.d3VelocityDecay) Graph.d3VelocityDecay(1);
        if (Graph && Graph.d3AlphaTarget) Graph.d3AlphaTarget(0);
        if (Graph && Graph.d3ReheatSimulation) Graph.d3ReheatSimulation();

        // Initialize node animation state
        nodes.forEach((node) => {
            node.__xStart = node.x || 0;
            node.__yStart = node.y || 0;
            node.__zStart = node.z || 0;
            node.__delay = delayMin + (stableSeed(node, 'delay') * (delayMax - delayMin));
            node.fx = node.__xStart;
            node.fy = node.__yStart;
            node.vx = 0;
            node.vy = 0;
            node.vz = 0;

            if (target3d) {
                if (node.__z3d === undefined || node.__z3d === null) {
                    node.__z3d = node.__zStart || stableZ(node);
                }
            } else {
                node.__z3d = node.__zStart;
            }
        });

        const maxDistance = nodes.reduce((acc, node) => Math.max(acc, Math.abs(node.__zStart || 0)), 1);

        Graph.numDimensions(3);

        const animate = (now) => {
            const elapsed = now - startTime;
            const t = Math.min(1, elapsed / duration);

            // Animate each node's Z position
            nodes.forEach((node) => {
                const startZ = node.__zStart || 0;
                const targetZ = target3d ? (node.__z3d || 0) : 0;
                const delay = node.__delay || 0;
                const localDuration = Math.max(600, duration - delay);
                const localElapsed = Math.max(0, elapsed - delay);
                const localT = Math.min(1, localElapsed / localDuration);
                const localEase = easeInOutSine(localT);
                const distanceRatio = maxDistance > 0 ? Math.abs(startZ) / maxDistance : 0;
                const distanceCurve = 0.6 + (1 - distanceRatio) * 0.6;
                const progress = Math.pow(localEase, distanceCurve);
                const nextZ = startZ + (targetZ - startZ) * progress;
                node.z = nextZ;
                node.fz = nextZ;
                node.vz = 0;
            });

            if (t < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - clean up
                nodes.forEach((node) => {
                    delete node.fz;
                    delete node.__zStart;
                    delete node.__xStart;
                    delete node.__yStart;
                    delete node.__delay;

                    if (!target3d) {
                        node.z = 0;
                        node.fz = 0;
                    } else if (lockPositionsAfterTransition) {
                        node.z = node.__z3d || node.z || 0;
                        node.fz = node.z;
                    } else {
                        delete node.fx;
                        delete node.fy;
                    }
                });

                Graph.numDimensions(target3d ? 3 : 2);

                // Restore simulation settings
                if (Graph && Graph.d3VelocityDecay && previousVelocityDecay !== null) {
                    Graph.d3VelocityDecay(previousVelocityDecay);
                }
                if (Graph && Graph.d3AlphaTarget && previousAlphaTarget !== null) {
                    Graph.d3AlphaTarget(previousAlphaTarget);
                }
                if (Graph && Graph.cooldownTicks && previousCooldownTicks !== null) {
                    Graph.cooldownTicks(previousCooldownTicks);
                }
                if (Graph && Graph.cooldownTime && previousCooldownTime !== null) {
                    Graph.cooldownTime(previousCooldownTime);
                }

                if (done) done();
            }
        };

        requestAnimationFrame(animate);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        toggle: toggle,
        setup: setup,
        animateChange: animateChange
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.toggleDimensions = DIMENSION.toggle;
window.setupDimensionToggle = DIMENSION.setup;
window.animateDimensionChange = DIMENSION.animateChange;

console.log('[Module] DIMENSION loaded - 3 functions');


// ═══ MODULE: modules/report.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * REPORT MODULE - Report panel, AI insights, and metrics display
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles the brain download report, AI insights panel, and metrics/KPI display.
 * Depends on: escapeHtml (from utils.js), DOM elements
 *
 * @module REPORT
 * @version 1.0.0
 */

window.REPORT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BRAIN DOWNLOAD REPORT
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the brain download report panel
     * @param {Object} data - Data object with brain_download field
     */
    function setupReport(data) {
        const panel = document.getElementById('report-panel');
        const content = document.getElementById('report-content');
        // Guard: elements may not exist in minimal template
        if (!content) return;
        const report = (data && data.brain_download) ? data.brain_download : '';
        content.textContent = report || 'No report available.';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // AI INSIGHTS PANEL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the AI insights panel
     * @param {Object} data - Data object with ai_insights field
     */
    function setupAIInsights(data) {
        const escapeHtml = window.escapeHtml || ((s) => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])));

        const panel = document.getElementById('insights-panel');
        const content = document.getElementById('insights-content');
        const btn = document.getElementById('btn-insights');

        const insights = (data && data.ai_insights) ? data.ai_insights : null;

        if (!insights) {
            // Hide the button if no insights available
            if (btn) btn.style.display = 'none';
            return;
        }

        // Show the button
        if (btn) btn.style.display = 'inline-flex';

        // Render insights
        let html = '';

        // Executive Summary
        if (insights.executive_summary) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Executive Summary</div>
                <div class="insights-summary">${escapeHtml(insights.executive_summary)}</div>
            </div>`;
        }

        // Patterns Detected
        if (insights.patterns_detected && insights.patterns_detected.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Patterns Detected</div>`;
            for (const pattern of insights.patterns_detected) {
                const confidencePercent = Math.round((pattern.confidence || 0) * 100);
                html += `<div class="insights-pattern">
                    <div class="insights-pattern-header">
                        <span class="insights-pattern-name">${escapeHtml(pattern.pattern_name || 'Unknown')}</span>
                        <span class="insights-pattern-type ${pattern.pattern_type || ''}">${escapeHtml(pattern.pattern_type || '')}</span>
                    </div>
                    <div class="insights-confidence">
                        <div class="insights-confidence-bar">
                            <div class="insights-confidence-fill" style="width: ${confidencePercent}%"></div>
                        </div>
                        <span>${confidencePercent}%</span>
                    </div>
                    ${pattern.evidence ? `<div class="insights-pattern-evidence">${escapeHtml(pattern.evidence)}</div>` : ''}
                    ${pattern.recommendation ? `<div class="insights-pattern-evidence" style="color: var(--color-accent-secondary);">Tip: ${escapeHtml(pattern.recommendation)}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Refactoring Opportunities
        if (insights.refactoring_opportunities && insights.refactoring_opportunities.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Refactoring Opportunities</div>`;
            for (const refactor of insights.refactoring_opportunities) {
                html += `<div class="insights-refactor">
                    <div class="insights-refactor-title">
                        ${escapeHtml(refactor.title || 'Untitled')}
                        <span class="insights-refactor-priority ${refactor.priority || 'LOW'}">${refactor.priority || 'LOW'}</span>
                    </div>
                    ${refactor.description ? `<div class="insights-refactor-desc">${escapeHtml(refactor.description)}</div>` : ''}
                    ${refactor.affected_files && refactor.affected_files.length > 0 ?
                        `<div class="insights-refactor-desc" style="margin-top: 4px; color: var(--color-text-muted);">Files: ${refactor.affected_files.slice(0, 3).map(f => escapeHtml(f)).join(', ')}${refactor.affected_files.length > 3 ? '...' : ''}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Topology Analysis
        if (insights.topology_analysis) {
            const topo = insights.topology_analysis;
            html += `<div class="insights-section">
                <div class="insights-section-title">Topology Analysis</div>
                ${topo.shape_interpretation ? `<div class="insights-summary">${escapeHtml(topo.shape_interpretation)}</div>` : ''}
                ${topo.health_assessment ? `<div class="insights-pattern-evidence">Health: ${escapeHtml(topo.health_assessment)}</div>` : ''}
                ${topo.coupling_analysis ? `<div class="insights-pattern-evidence">Coupling: ${escapeHtml(topo.coupling_analysis)}</div>` : ''}
            </div>`;
        }

        // Risk Areas
        if (insights.risk_areas && insights.risk_areas.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Risk Areas</div>`;
            for (const risk of insights.risk_areas) {
                html += `<div class="insights-risk">
                    <span class="insights-risk-level ${risk.risk_level || 'LOW'}">${risk.risk_level || 'LOW'}</span>
                    <div class="insights-risk-content">
                        <div class="insights-risk-area">${escapeHtml(risk.area || 'Unknown')}</div>
                        ${risk.description ? `<div class="insights-risk-desc">${escapeHtml(risk.description)}</div>` : ''}
                        ${risk.mitigation ? `<div class="insights-risk-desc" style="color: var(--color-accent-secondary); margin-top: 4px;">Tip: ${escapeHtml(risk.mitigation)}</div>` : ''}
                    </div>
                </div>`;
            }
            html += '</div>';
        }

        // Meta information
        if (insights.meta) {
            const meta = insights.meta;
            html += `<div class="insights-meta">
                Generated: ${meta.generated_at ? new Date(meta.generated_at).toLocaleString() : 'Unknown'}
                | Model: ${escapeHtml(meta.model || 'Unknown')}
                ${meta.confidence ? ` | Confidence: ${Math.round(meta.confidence * 100)}%` : ''}
            </div>`;
        }

        content.innerHTML = html || '<div class="insights-placeholder">No insights data available.</div>';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METRICS / KPI DISPLAY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup metrics and health indicators
     * @param {Object} data - Data object with kpis field
     */
    function setupMetrics(data) {
        const kpis = (data && data.kpis) ? data.kpis : {};

        const setText = (id, value) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = value;
        };

        const asNumber = (val) => {
            const num = Number(val);
            return Number.isFinite(num) ? num : null;
        };

        const formatPercent = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}%`;
        };

        const formatCount = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${Math.round(num)}`;
        };

        const formatScore = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}/10`;
        };

        // Set metric values
        setText('metric-edge-resolution', formatPercent(kpis.edge_resolution_percent));
        setText('metric-call-ratio', formatPercent(kpis.call_ratio_percent));
        setText('metric-reachability', formatPercent(kpis.reachability_percent));
        setText('metric-dead-code', formatPercent(kpis.dead_code_percent));
        setText('metric-knot-score', formatScore(kpis.knot_score));
        setText('metric-topology', kpis.topology_shape || 'UNKNOWN');
        setText('metric-orphans', formatCount(kpis.orphan_count));
        setText('metric-top-hubs', formatCount(kpis.top_hub_count));

        // Set health indicators (traffic light bars)
        const setHealth = (id, level) => {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('good', 'medium', 'bad', 'neutral');
                el.classList.add(level);
            }
        };

        // Edge Resolution: >90% good, 70-90% medium, <70% bad
        const edgeRes = asNumber(kpis.edge_resolution_percent);
        setHealth('health-edge-resolution', edgeRes === null ? 'neutral' : edgeRes >= 90 ? 'good' : edgeRes >= 70 ? 'medium' : 'bad');

        // Call Ratio: >60% good, 40-60% medium, <40% bad
        const callRatio = asNumber(kpis.call_ratio_percent);
        setHealth('health-call-ratio', callRatio === null ? 'neutral' : callRatio >= 60 ? 'good' : callRatio >= 40 ? 'medium' : 'bad');

        // Reachability: >90% good, 70-90% medium, <70% bad
        const reach = asNumber(kpis.reachability_percent);
        setHealth('health-reachability', reach === null ? 'neutral' : reach >= 90 ? 'good' : reach >= 70 ? 'medium' : 'bad');

        // Dead Code: <5% good, 5-15% medium, >15% bad (INVERTED - lower is better)
        const dead = asNumber(kpis.dead_code_percent);
        setHealth('health-dead-code', dead === null ? 'neutral' : dead <= 5 ? 'good' : dead <= 15 ? 'medium' : 'bad');

        // Knot Score: <3 good, 3-6 medium, >6 bad (INVERTED - lower is better)
        const knot = asNumber(kpis.knot_score);
        setHealth('health-knot-score', knot === null ? 'neutral' : knot <= 3 ? 'good' : knot <= 6 ? 'medium' : 'bad');

        // Topology: neutral (informational only)
        setHealth('health-topology', 'neutral');

        // Orphans: <10 good, 10-50 medium, >50 bad (INVERTED - lower is better)
        const orphans = asNumber(kpis.orphan_count);
        setHealth('health-orphans', orphans === null ? 'neutral' : orphans <= 10 ? 'good' : orphans <= 50 ? 'medium' : 'bad');

        // Top Hubs: neutral (informational only)
        setHealth('health-top-hubs', 'neutral');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupReport: setupReport,
        setupAIInsights: setupAIInsights,
        setupMetrics: setupMetrics
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupReport = REPORT.setupReport;
window.setupAIInsights = REPORT.setupAIInsights;
window.setupMetrics = REPORT.setupMetrics;

console.log('[Module] REPORT loaded - 3 functions');


// ═══ MODULE: modules/visibility.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VISIBILITY MODULE - UI visibility controls and filter utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles background brightness, metadata visibility, filter clearing,
 * and collapsible section management.
 * Depends on: Graph, APPEARANCE_STATE, VIS_FILTERS, THREE
 *
 * @module VISIBILITY
 * @version 1.0.0
 */

window.VISIBILITY = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BACKGROUND CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update background brightness based on APPEARANCE_STATE
     */
    function updateBackgroundBrightness() {
        const Graph = window.Graph;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const THREE = window.THREE;

        if (!Graph || !APPEARANCE_STATE.backgroundBase) return;
        const baseColor = new THREE.Color(APPEARANCE_STATE.backgroundBase);
        const brightness = APPEARANCE_STATE.backgroundBrightness ?? 1;
        const adjusted = baseColor.clone().multiplyScalar(brightness);
        Graph.backgroundColor(`#${adjusted.getHexString()}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA VISIBILITY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply metadata visibility settings (report panel, file panel, etc.)
     */
    function applyMetadataVisibility() {
        const VIS_FILTERS = window.VIS_FILTERS;

        const reportPanel = document.getElementById('report-panel');
        const reportButton = document.getElementById('btn-report');
        const filePanel = document.getElementById('file-panel');

        // Guard: elements may not exist in minimal template
        if (!reportPanel && !reportButton) return;

        if (!VIS_FILTERS.metadata.showReportPanel) {
            if (reportPanel) reportPanel.style.display = 'none';
            if (reportButton) {
                reportButton.classList.remove('active');
                reportButton.style.display = 'none';
            }
        } else {
            if (reportButton) reportButton.style.display = 'inline-flex';
        }
        if (!VIS_FILTERS.metadata.showFilePanel && filePanel) {
            filePanel.classList.remove('visible');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clear all dimension filters (tier, ring, family, role, file, edge)
     * Used for zero-node recovery and manual reset
     */
    function clearAllFilters() {
        const VIS_FILTERS = window.VIS_FILTERS;

        VIS_FILTERS.tiers.clear();
        VIS_FILTERS.rings.clear();
        VIS_FILTERS.families.clear();
        VIS_FILTERS.roles.clear();
        VIS_FILTERS.files.clear();
        VIS_FILTERS.edges.clear();
        VIS_FILTERS.layers.clear();
        VIS_FILTERS.effects.clear();
        VIS_FILTERS.edgeFamilies.clear();

        // Update legend UI
        document.querySelectorAll('.topo-legend-item.filtered').forEach(el => el.classList.remove('filtered'));

        // Update chip UI
        document.querySelectorAll('.filter-chip.active').forEach(el => el.classList.remove('active'));

        console.log('[Filters] All filters cleared');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLLAPSIBLE SECTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup collapsible sections in sidebar and panels
     */
    function setupCollapsibleSections() {
        // Standard sidebar sections
        const titles = document.querySelectorAll('.side-title.collapsible');
        titles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('collapsed', isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });

        // Topology section collapsibles (GEOMETRY panel)
        const topoTitles = document.querySelectorAll('.topo-section-title.collapsible');
        topoTitles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('expanded', !isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updateBackgroundBrightness: updateBackgroundBrightness,
        applyMetadataVisibility: applyMetadataVisibility,
        clearAllFilters: clearAllFilters,
        setupCollapsibleSections: setupCollapsibleSections
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateBackgroundBrightness = VISIBILITY.updateBackgroundBrightness;
window.applyMetadataVisibility = VISIBILITY.applyMetadataVisibility;
window.clearAllFilters = VISIBILITY.clearAllFilters;
window.setupCollapsibleSections = VISIBILITY.setupCollapsibleSections;

console.log('[Module] VISIBILITY loaded - 4 functions');


// ═══ MODULE: modules/animation.js ═══
/**
 * ANIMATION MODULE
 *
 * Unified animation controller for all layout transitions and continuous motions.
 * Addresses ARCH-002 (O(n^2) flock), ARCH-003 (unthrottled refresh), ARCH-004 (conflicts).
 *
 * Key improvements:
 * - Single animation ownership prevents conflicts
 * - Spatial hashing reduces flock from O(n^2) to O(n)
 * - Integration with REFRESH module for throttled updates
 *
 * Usage:
 *   ANIM.applyLayout('orbital')           // Apply a layout preset
 *   ANIM.stop()                           // Stop all animations
 *   ANIM.setStaggerPattern('radial')      // Change wave pattern
 */

const ANIM = (function () {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        baseDuration: 1200,      // Base animation duration (ms)
        staggerSpread: 800,      // Stagger spread (ms)
        flockMaxNodes: 500,      // Max nodes for flock simulation
        spatialGridSize: 50,     // Grid cell size for spatial hashing
        motionFrameSkip: 0       // Skip frames for motion (0 = no skip)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _currentLayout = 'force';
    let _animationId = null;
    let _layoutTime = 0;
    let _currentStaggerPattern = 'tier';
    let _owner = 'none';  // Current animation owner

    // =========================================================================
    // STAGGER PATTERNS - Wave-based node transitions
    // =========================================================================

    const STAGGER_PATTERNS = {
        // Radial ripple: center nodes move first, ripples outward
        radial: (node, startPos, targetPos) => {
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2 + startPos.z ** 2);
            return Math.min(1, dist / 500);
        },
        // Tier cascade: T0 first, then T1, then T2
        tier: (node) => {
            const tier = NODE.getTier(node);
            const tierNum = tier === 'T0' ? 0 : tier === 'T1' ? 1 : 2;
            return tierNum / 2;
        },
        // Distance-based: shortest travel first
        distance: (node, startPos, targetPos) => {
            const dx = targetPos.x - startPos.x;
            const dy = targetPos.y - startPos.y;
            const dz = targetPos.z - startPos.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            return Math.min(1, dist / 400);
        },
        // File grouping: nodes in same file move together
        file: (node) => {
            const fileIdx = node.fileIdx ?? 0;
            return (fileIdx % 8) / 8;
        },
        // Spiral pattern
        spiral: (node, startPos) => {
            const angle = Math.atan2(startPos.y, startPos.x);
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2);
            return ((angle + Math.PI) / (2 * Math.PI) + dist / 1000) % 1;
        },
        // Random stagger
        random: () => Math.random() * 0.6
    };

    // =========================================================================
    // LAYOUT PRESETS
    // =========================================================================

    const LAYOUT_PRESETS = {
        'force': {
            name: 'FORCE', icon: '?', description: 'Physics-based clustering',
            motion: 'settle', cooldown: 300, warmupTicks: 40, getPosition: null
        },
        'orbital': {
            name: 'ORBITAL', icon: '?', description: 'Planetary orbit bands',
            motion: 'orbit', cooldown: Infinity, orbitSpeed: 0.002,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const r = { T0: 80, T1: 160, T2: 280, UNKNOWN: 200 }[tier] || 200;
                const fOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const angle = (fOff / 5) * Math.PI * 2 + (idx / Math.max(1, total)) * Math.PI * 0.3 + (time || 0) * (0.5 + r * 0.001);
                const wobble = Math.sin(idx * 0.7 + (time || 0) * 2) * 15;
                return {
                    x: Math.cos(angle) * (r + wobble),
                    y: Math.sin(idx * 0.3) * 40 + (tier === 'T0' ? -50 : tier === 'T2' ? 50 : 0),
                    z: Math.sin(angle) * (r + wobble)
                };
            }
        },
        'radial': {
            name: 'RADIAL', icon: '?', description: 'Concentric tier rings',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total, time, tierGroups) => {
                const tier = NODE.getTier(node);
                const r = { T0: 60, T1: 150, T2: 280, UNKNOWN: 220 }[tier] || 180;
                const tierNodes = tierGroups?.[tier] || [];
                const tierIdx = tierNodes.indexOf(node);
                const tierTotal = tierNodes.length || 1;
                const angle = (tierIdx / tierTotal) * Math.PI * 2;
                return { x: Math.cos(angle) * r, y: 0, z: Math.sin(angle) * r };
            }
        },
        'spiral': {
            name: 'SPIRAL', icon: '?', description: 'DNA-like helix',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.003,
            getPosition: (node, idx, total, time) => {
                const t = idx / Math.max(1, total);
                const angle = t * Math.PI * 2 * 4 + (time || 0);
                const r = 100 + t * 150;
                return { x: Math.cos(angle) * r, y: (t - 0.5) * 400, z: Math.sin(angle) * r };
            }
        },
        'sphere': {
            name: 'SPHERE', icon: '?', description: 'Globe surface',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const latBase = { T0: 0.8, T1: 0.5, T2: 0.2, UNKNOWN: 0.5 }[tier] || 0.5;
                const lat = (latBase + (idx % 10) * 0.02) * Math.PI;
                const lonBase = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 180 }[family] || 0;
                const lon = ((lonBase + idx * 3) % 360) * Math.PI / 180 + (time || 0);
                const r = 200;
                return {
                    x: Math.sin(lat) * Math.cos(lon) * r,
                    y: Math.cos(lat) * r,
                    z: Math.sin(lat) * Math.sin(lon) * r
                };
            }
        },
        'grid': {
            name: 'GRID', icon: '?', description: '3D lattice',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const tierX = { T0: -150, T1: 0, T2: 150, UNKNOWN: 0 }[tier] || 0;
                const famZ = { LOG: -120, DAT: -60, ORG: 0, EXE: 60, EXT: 120, UNKNOWN: 0 }[family] || 0;
                const row = Math.floor(idx / 15);
                const col = idx % 15;
                return { x: tierX + (col - 7) * 20, y: row * 25 - 100, z: famZ + Math.sin(idx * 0.5) * 20 };
            }
        },
        'flock': {
            name: 'FLOCK', icon: '?', description: 'Swarming birds',
            motion: 'flock', cooldown: Infinity,
            flockParams: { separation: 25, alignment: 0.05, cohesion: 0.01, maxSpeed: 2 },
            getPosition: null
        },
        'galaxy': {
            name: 'GALAXY', icon: '?', description: 'Spiral arms',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const family = NODE.getFamily(node);
                const tier = NODE.getTier(node);
                const armOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const baseAngle = (armOff / 5) * Math.PI * 2;
                const dist = 50 + (idx / total) * 250;
                const spiralAngle = baseAngle + dist * 0.015 + (time || 0);
                const tierY = { T0: -30, T1: 0, T2: 30, UNKNOWN: 0 }[tier] || 0;
                return {
                    x: Math.cos(spiralAngle) * dist,
                    y: tierY + Math.sin(idx * 0.5) * 20,
                    z: Math.sin(spiralAngle) * dist
                };
            }
        }
    };

    // =========================================================================
    // SPATIAL HASHING - O(n) neighbor lookup for flock simulation
    // =========================================================================

    function _buildSpatialGrid(nodes, cellSize) {
        const grid = new Map();

        nodes.forEach((node, idx) => {
            const x = node.x || 0;
            const y = node.y || 0;
            const z = node.z || 0;

            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) {
                grid.set(key, []);
            }
            grid.get(key).push({ node, idx });
        });

        return grid;
    }

    function _getNeighborsFromGrid(grid, node, cellSize, radius) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);

        const neighbors = [];
        const cellRadius = Math.ceil(radius / cellSize);

        // Check neighboring cells
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                    const key = `${cellX + dx},${cellY + dy},${cellZ + dz}`;
                    const cell = grid.get(key);
                    if (cell) {
                        cell.forEach(entry => {
                            if (entry.node !== node) {
                                neighbors.push(entry.node);
                            }
                        });
                    }
                }
            }
        }

        return neighbors;
    }

    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================

    function _groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = NODE.getTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    function _acquireOwnership(owner) {
        // Cancel any existing animation
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = owner;
        return true;
    }

    function _releaseOwnership(owner) {
        if (_owner === owner) {
            if (_animationId) {
                cancelAnimationFrame(_animationId);
                _animationId = null;
            }
            _owner = 'none';
        }
    }

    // =========================================================================
    // LAYOUT APPLICATION
    // =========================================================================

    function applyLayout(presetKey, animate = true) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset) return;

        _currentLayout = presetKey;
        _acquireOwnership('layout');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);

        // Handle force layout specially
        if (presetKey === 'force') {
            nodes.forEach(n => {
                n.fx = undefined;
                n.fy = undefined;
                n.fz = undefined;
            });
            Graph.cooldownTicks(preset.cooldown);
            Graph.d3ReheatSimulation();
            _releaseOwnership('layout');
            if (typeof showModeToast === 'function') {
                showModeToast('? FORCE layout');
            }
            return;
        }

        // Handle flock specially
        if (preset.motion === 'flock') {
            _startFlockSimulation(preset.flockParams);
            Graph.cooldownTicks(preset.cooldown);
            if (typeof showModeToast === 'function') {
                showModeToast(`${preset.icon} ${preset.name} layout`);
            }
            return;
        }

        // Position-based layouts
        if (preset.getPosition) {
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => preset.getPosition(n, i, total, 0, tierGroups));

            if (animate && total > 100) {
                // STAGGERED ANIMATION for large graphs
                _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey);
            } else if (animate) {
                // SIMPLE ANIMATION for small graphs
                _animateSimple(nodes, startPos, targetPos, preset, presetKey);
            } else {
                // INSTANT
                nodes.forEach((n, i) => {
                    const p = targetPos[i];
                    n.fx = p.x;
                    n.fy = p.y;
                    n.fz = p.z;
                });
                if (typeof REFRESH !== 'undefined') {
                    REFRESH.force();
                } else if (Graph) {
                    REFRESH.throttled();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                }
            }
        }

        Graph.cooldownTicks(preset.cooldown);
        if (typeof showModeToast === 'function') {
            showModeToast(`${preset.icon} ${preset.name} layout`);
        }
    }

    function _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey) {
        const baseDuration = CONFIG.baseDuration;
        const staggerSpread = CONFIG.staggerSpread;
        const startTime = Date.now();

        // Hide edges during animation for performance
        Graph.linkOpacity(0);

        // Calculate delay for each node
        const pattern = STAGGER_PATTERNS[_currentStaggerPattern] || STAGGER_PATTERNS.tier;
        const delays = nodes.map((n, i) => pattern(n, startPos[i], targetPos[i]) * staggerSpread);

        function animateFrame() {
            if (_owner !== 'layout') return;

            const elapsed = Date.now() - startTime;

            nodes.forEach((n, i) => {
                const nodeStart = delays[i];
                const nodeElapsed = elapsed - nodeStart;

                if (nodeElapsed <= 0) {
                    n.fx = startPos[i].x;
                    n.fy = startPos[i].y;
                    n.fz = startPos[i].z;
                } else if (nodeElapsed >= baseDuration) {
                    n.fx = targetPos[i].x;
                    n.fy = targetPos[i].y;
                    n.fz = targetPos[i].z;
                } else {
                    const progress = nodeElapsed / baseDuration;
                    const eased = progress * progress * (3 - 2 * progress);
                    n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                    n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                    n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
                }
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            const totalDuration = baseDuration + staggerSpread;
            if (elapsed < totalDuration) {
                _animationId = requestAnimationFrame(animateFrame);
            } else {
                // Restore edges
                if (typeof applyEdgeMode === 'function') {
                    applyEdgeMode();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                } else {
                    _releaseOwnership('layout');
                }
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _animateSimple(nodes, startPos, targetPos, preset, presetKey) {
        const duration = 1500;
        const startTime = Date.now();

        function animateFrame() {
            if (_owner !== 'layout') return;

            const progress = Math.min(1, (Date.now() - startTime) / duration);
            const eased = progress * progress * (3 - 2 * progress);

            nodes.forEach((n, i) => {
                n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            if (progress < 1) {
                _animationId = requestAnimationFrame(animateFrame);
            } else if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                _startLayoutMotion(presetKey);
            } else {
                _releaseOwnership('layout');
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _startLayoutMotion(presetKey) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset || !preset.getPosition) return;

        _acquireOwnership('motion');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);
        const speed = preset.rotateSpeed || preset.orbitSpeed || 0.002;

        function animate() {
            if (_owner !== 'motion') return;

            _layoutTime += speed;

            nodes.forEach((n, i) => {
                const pos = preset.getPosition(n, i, total, _layoutTime, tierGroups);
                n.fx = pos.x;
                n.fy = pos.y;
                n.fz = pos.z;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(animate);
        }

        _animationId = requestAnimationFrame(animate);
    }

    // =========================================================================
    // FLOCK SIMULATION - O(n) with spatial hashing
    // =========================================================================

    function _startFlockSimulation(params) {
        const nodes = Graph?.graphData()?.nodes || [];

        // Performance guard
        if (nodes.length > CONFIG.flockMaxNodes) {
            console.warn(`[ANIM] Flock disabled: ${nodes.length} nodes exceeds ${CONFIG.flockMaxNodes} limit`);
            if (typeof showModeToast === 'function') {
                showModeToast('Warning: Flock disabled (too many nodes)');
            }
            return;
        }

        _acquireOwnership('flock');

        const { separation, alignment, cohesion, maxSpeed } = params;

        // Initialize velocities
        nodes.forEach(n => {
            n._vx = (Math.random() - 0.5) * 2;
            n._vy = (Math.random() - 0.5) * 2;
            n._vz = (Math.random() - 0.5) * 2;
        });

        function flockStep() {
            if (_owner !== 'flock') return;

            // Build spatial grid for O(n) neighbor lookup
            const grid = _buildSpatialGrid(nodes, CONFIG.spatialGridSize);
            const neighborRadius = separation * 3;

            nodes.forEach(n => {
                // Get nearby neighbors from spatial grid (O(1) per node)
                const neighbors = _getNeighborsFromGrid(grid, n, CONFIG.spatialGridSize, neighborRadius);

                let sepX = 0, sepY = 0, sepZ = 0, sepCount = 0;
                let alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;

                const myFamily = NODE.getFamily(n);

                neighbors.forEach(other => {
                    const dx = (other.x || 0) - (n.x || 0);
                    const dy = (other.y || 0) - (n.y || 0);
                    const dz = (other.z || 0) - (n.z || 0);
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 0.001;

                    // Separation
                    if (dist < separation * 2) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                        sepZ -= dz / dist;
                        sepCount++;
                    }

                    // Alignment and cohesion (same family only)
                    if (NODE.getFamily(other) === myFamily && dist < 150) {
                        alignX += other._vx || 0;
                        alignY += other._vy || 0;
                        alignZ += other._vz || 0;
                        alignCount++;

                        cohX += other.x || 0;
                        cohY += other.y || 0;
                        cohZ += other.z || 0;
                        cohCount++;
                    }
                });

                // Apply forces
                if (sepCount > 0) {
                    n._vx += (sepX / sepCount) * separation * 0.05;
                    n._vy += (sepY / sepCount) * separation * 0.05;
                    n._vz += (sepZ / sepCount) * separation * 0.05;
                }
                if (alignCount > 0) {
                    n._vx += ((alignX / alignCount) - n._vx) * alignment;
                    n._vy += ((alignY / alignCount) - n._vy) * alignment;
                    n._vz += ((alignZ / alignCount) - n._vz) * alignment;
                }
                if (cohCount > 0) {
                    n._vx += (cohX / cohCount - (n.x || 0)) * cohesion;
                    n._vy += (cohY / cohCount - (n.y || 0)) * cohesion;
                    n._vz += (cohZ / cohCount - (n.z || 0)) * cohesion;
                }

                // Center attraction
                n._vx -= (n.x || 0) * 0.0005;
                n._vy -= (n.y || 0) * 0.0005;
                n._vz -= (n.z || 0) * 0.0005;

                // Speed limit
                const speed = Math.sqrt(n._vx * n._vx + n._vy * n._vy + n._vz * n._vz);
                if (speed > maxSpeed) {
                    n._vx = (n._vx / speed) * maxSpeed;
                    n._vy = (n._vy / speed) * maxSpeed;
                    n._vz = (n._vz / speed) * maxSpeed;
                }

                // Update position
                n.fx = (n.x || 0) + n._vx;
                n.fy = (n.y || 0) + n._vy;
                n.fz = (n.z || 0) + n._vz;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(flockStep);
        }

        _animationId = requestAnimationFrame(flockStep);
    }

    // =========================================================================
    // PULSE ANIMATION
    // =========================================================================

    let _pulseId = null;

    function togglePulse(active) {
        if (active) {
            _startPulse();
        } else {
            _stopPulse();
        }
    }

    function _startPulse() {
        if (_pulseId) return;
        const startTime = Date.now();

        function loop() {
            const elapsed = Date.now() - startTime;
            // Oscillate lightness +/- 10%
            const val = Math.sin(elapsed * 0.003) * 10;

            if (typeof COLOR !== 'undefined') {
                COLOR.setTransform('lightnessShift', val);
                // Also breathe chroma a bit
                COLOR.setTransform('chromaScale', 1.0 + Math.sin(elapsed * 0.003) * 0.2);
            }

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof Graph !== 'undefined' && Graph) {
                // Determine if we need to force re-coloring or if just re-rendering canvas is enough.
                // Since transforms affect color calculation, we likely need to re-apply colors.
                if (typeof window.applyNodeColors === 'function') {
                    const nodes = Graph.graphData().nodes;
                    window.applyNodeColors(nodes);
                    Graph.nodeColor(Graph.nodeColor()); // Trigger internal update
                }
            }

            _pulseId = requestAnimationFrame(loop);
        }
        _pulseId = requestAnimationFrame(loop);
        if (typeof showModeToast === 'function') showModeToast('Pulse Animation ON');
    }

    function _stopPulse() {
        if (_pulseId) {
            cancelAnimationFrame(_pulseId);
            _pulseId = null;
        }
        // Reset
        if (typeof COLOR !== 'undefined') {
            COLOR.setTransform('lightnessShift', 0);
            COLOR.setTransform('chromaScale', 1.0);
        }

        // Final refresh to clear artifacts
        if (typeof window.applyNodeColors === 'function' && typeof Graph !== 'undefined') {
            const nodes = Graph.graphData().nodes;
            window.applyNodeColors(nodes);
            Graph.nodeColor(Graph.nodeColor());
        }

        if (typeof showModeToast === 'function') showModeToast('Pulse Animation OFF');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function stop() {
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = 'none';
    }

    function setStaggerPattern(pattern) {
        if (STAGGER_PATTERNS[pattern]) {
            _currentStaggerPattern = pattern;
            if (typeof showModeToast === 'function') {
                showModeToast(`Wave pattern: ${pattern.toUpperCase()}`);
            }
        }
    }

    function cycleStaggerPattern() {
        const patterns = Object.keys(STAGGER_PATTERNS);
        const currentIdx = patterns.indexOf(_currentStaggerPattern);
        _currentStaggerPattern = patterns[(currentIdx + 1) % patterns.length];
        if (typeof showModeToast === 'function') {
            showModeToast(`Wave pattern: ${_currentStaggerPattern.toUpperCase()}`);
        }
        return _currentStaggerPattern;
    }

    return {
        // Layout control
        applyLayout,
        stop,

        // Stagger patterns
        setStaggerPattern,
        cycleStaggerPattern,
        togglePulse, // Added to public API
        get staggerPattern() { return _currentStaggerPattern; },
        get staggerPatterns() { return Object.keys(STAGGER_PATTERNS); },

        // State
        get currentLayout() { return _currentLayout; },
        get isAnimating() { return _animationId !== null; },
        get owner() { return _owner; },

        // Layout presets
        presets: LAYOUT_PRESETS,

        // Config
        config: CONFIG
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// Note: CURRENT_LAYOUT, LAYOUT_ANIMATION_ID, LAYOUT_TIME, CURRENT_STAGGER_PATTERN
// are managed by app.js (separate animation system) - not duplicated here
Object.defineProperty(window, 'LAYOUT_PRESETS', { get: () => ANIM.presets, configurable: true });
Object.defineProperty(window, 'STAGGER_PATTERNS', { get: () => ANIM.staggerPatterns, configurable: true });

function applyLayoutPreset(presetKey, animate) {
    ANIM.applyLayout(presetKey, animate);
}

function cycleStaggerPattern() {
    ANIM.cycleStaggerPattern();
}

function startFlockSimulation(params) {
    // Handled internally by ANIM
    ANIM.applyLayout('flock');
}

function groupNodesByTier(nodes) {
    const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
    nodes.forEach(n => {
        const tier = NODE.getTier(n);
        (groups[tier] || groups.UNKNOWN).push(n);
    });
    return groups;
}


// ═══ MODULE: modules/selection.js ═══
/**
 * SELECTION MODULE
 *
 * Manages node selection, multi-select, marquee selection, and selection visuals.
 * Includes animated selection colors using OKLCH pendulum system.
 *
 * Depends on: CORE (PENDULUM, SELECTION_SIZE_MULT), NODE, COLOR
 *
 * Usage:
 *   SELECT.set([id1, id2])              // Set selection
 *   SELECT.toggle(node)                 // Toggle node selection
 *   SELECT.clear()                      // Clear selection
 *   SELECT.getSelectedNodes()           // Get selected node objects
 *   SELECT.ids                          // Get Set of selected IDs
 */

const SELECT = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    const _ids = new Set();
    let _marqueeActive = false;
    let _marqueeStart = null;
    let _marqueeAdditive = false;
    let _lastMarqueeEndTs = 0;

    // Selection visuals state
    const _selectionOriginals = new Map();
    const _originalColorsForDim = new Map();

    // THREE.js geometries (created lazily)
    let _selectionHaloGeometry = null;
    let _groupHaloGeometry = null;

    // =========================================================================
    // CORE SELECTION FUNCTIONS
    // =========================================================================

    /**
     * Get currently selected nodes
     */
    function getSelectedNodes() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return [];
        const nodes = Graph.graphData().nodes || [];
        return nodes.filter(node => node && node.id && _ids.has(node.id));
    }

    /**
     * Set selection (optionally additive)
     */
    function set(ids, additive = false) {
        if (!additive) {
            _ids.clear();
        }
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        // Use app.js's updateSelectionVisuals if available (has group halo logic)
        // Otherwise fall back to internal _updateVisuals
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Toggle a node's selection state
     */
    function toggle(node) {
        if (!node || !node.id) return;
        if (_ids.has(node.id)) {
            _ids.delete(node.id);
        } else {
            _ids.add(node.id);
        }
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Clear all selection
     */
    function clear() {
        _ids.clear();
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Maybe clear selection (with marquee debounce)
     */
    function maybeClear() {
        const now = Date.now();
        if (_marqueeActive) return;
        if (now - _lastMarqueeEndTs < 250) return;
        clear();
    }

    /**
     * Add nodes to selection
     */
    function add(ids) {
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Remove nodes from selection
     */
    function remove(ids) {
        (ids || []).forEach(id => {
            _ids.delete(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    // =========================================================================
    // OKLCH COLOR UTILITIES
    // =========================================================================

    function _oklchToHex(L, C, H) {
        const hRad = H * Math.PI / 180;
        const a = C * Math.cos(hRad);
        const b = C * Math.sin(hRad);

        const l_ = L / 100 + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L / 100 - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L / 100 - 0.0894841775 * a - 1.2914855480 * b;

        const l = l_ * l_ * l_;
        const m = m_ * m_ * m_;
        const s = s_ * s_ * s_;

        let rLin = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
        let gLin = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
        let bLin = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

        const gamma = x => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;

        let rOut = Math.round(gamma(rLin) * 255);
        let gOut = Math.round(gamma(gLin) * 255);
        let bOut = Math.round(gamma(bLin) * 255);

        rOut = Math.max(0, Math.min(255, rOut));
        gOut = Math.max(0, Math.min(255, gOut));
        bOut = Math.max(0, Math.min(255, bOut));

        return '#' + [rOut, gOut, bOut].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function _dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // =========================================================================
    // PENDULUM ANIMATION
    // =========================================================================

    function _updatePendulums(dt) {
        const PENDULUM = CORE.PENDULUM;
        const p1 = PENDULUM.hue;
        const p2 = PENDULUM.chroma;

        // Pendulum 1: Modulates hue rotation speed
        const accel1 = -(p1.gravity / p1.length) * Math.sin(p1.angle);
        p1.velocity += accel1 * dt;
        p1.velocity *= p1.damping;
        p1.angle += p1.velocity * dt;

        // Continuous hue rotation
        const speedMod = 1 + Math.sin(p1.angle) * 0.5;
        PENDULUM.currentHue = (PENDULUM.currentHue + p1.rotationSpeed * speedMod * (dt / 16)) % 360;

        // Pendulum 2: Chroma with coupling
        const coupling = 0.00015 * Math.sin(p1.angle);
        const accel2 = -(p2.gravity / p2.length) * Math.sin(p2.angle) + coupling;
        p2.velocity += accel2 * dt;
        p2.velocity *= p2.damping;
        p2.angle += p2.velocity * dt;

        // Lightness phase
        PENDULUM.lightness.phase += PENDULUM.lightness.speed * dt;
    }

    function _getSelectionColor(phaseOffset = 0) {
        const PENDULUM = CORE.PENDULUM;
        const p2 = PENDULUM.chroma;
        const p3 = PENDULUM.lightness;

        const H = (PENDULUM.currentHue + phaseOffset * 45) % 360;
        const C = Math.max(0.18, p2.center + Math.sin(p2.angle + phaseOffset * Math.PI * 2) * p2.amplitude);
        const L = p3.center + Math.sin(p3.phase + phaseOffset * Math.PI * 4) * p3.amplitude;

        return _oklchToHex(L, C, H);
    }

    function _getNodeSpatialPhase(node) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const distance = Math.sqrt(x * x + y * y + z * z);
        const PENDULUM = CORE.PENDULUM;
        const scale = PENDULUM.ripple ? (PENDULUM.ripple.scale || 200) : 200;
        const ripplePhase = (distance / scale) % 1;

        const angle = Math.atan2(y, x);
        const angularOffset = Math.sin(angle * 3) * 0.1;

        return (ripplePhase + angularOffset + 1) % 1;
    }

    function _animateSelectionColors(timestamp) {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) return;

        const dt = PENDULUM.lastTime ? Math.min(timestamp - PENDULUM.lastTime, 50) : 16;
        PENDULUM.lastTime = timestamp;

        _updatePendulums(dt);

        if (_ids.size > 0 && typeof Graph !== 'undefined' && Graph?.graphData) {
            const nodes = Graph.graphData().nodes || [];

            nodes.forEach(node => {
                if (_ids.has(node.id)) {
                    const spatialPhase = _getNodeSpatialPhase(node);
                    node.color = _getSelectionColor(spatialPhase);
                }
            });

            if (typeof toColorNumber === 'function') {
                Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
            }
        }

        requestAnimationFrame(_animateSelectionColors);
    }

    function startAnimation() {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) {
            PENDULUM.running = true;
            PENDULUM.hue.velocity = 0.02 + Math.random() * 0.01;
            PENDULUM.chroma.velocity = 0.015 + Math.random() * 0.01;
            PENDULUM.lastTime = 0;
            requestAnimationFrame(_animateSelectionColors);
        }
    }

    function stopAnimation() {
        CORE.PENDULUM.running = false;
    }

    // =========================================================================
    // VISUAL UPDATES
    // =========================================================================

    function _updateVisuals() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;

        const nodes = Graph.graphData().nodes || [];
        const hasSelection = _ids.size > 0;
        const SELECTION_SIZE_MULT = CORE.SELECTION_SIZE_MULT;

        nodes.forEach(node => {
            const isSelected = _ids.has(node.id);

            // Save original for restoration
            if (hasSelection && !_originalColorsForDim.has(node.id)) {
                _originalColorsForDim.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            if (isSelected && !_selectionOriginals.has(node.id)) {
                _selectionOriginals.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            // Apply styling
            if (hasSelection) {
                if (isSelected) {
                    const orig = _selectionOriginals.get(node.id);
                    node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
                } else {
                    const orig = _originalColorsForDim.get(node.id);
                    if (orig) {
                        node.color = _dimColor(orig.color, 0.5);
                        node.val = orig.val * 0.7;
                    }
                }
            } else {
                // Restore originals
                const orig = _originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = orig.color;
                    node.val = orig.val;
                }
            }

            // Update halo visibility
            if (node.__selectionHalo) {
                node.__selectionHalo.visible = isSelected;
            }
        });

        // Handle animation state
        if (hasSelection) {
            startAnimation();
        } else {
            stopAnimation();
            _selectionOriginals.clear();
            _originalColorsForDim.clear();
        }

        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (Graph) {
            REFRESH.throttled();
        }
    }

    function _updatePanel() {
        if (typeof updateSelectionPanel === 'function') {
            updateSelectionPanel();
        }
    }

    function _updateGroupButtonState() {
        if (typeof updateGroupButtonState === 'function') {
            updateGroupButtonState();
        }
    }

    // =========================================================================
    // NODE OVERLAYS (3D halos)
    // =========================================================================

    function ensureOverlays(node) {
        if (!node) return null;
        if (node.__overlayGroup) return node.__overlayGroup;

        // Lazy init geometry
        if (!_selectionHaloGeometry) {
            _selectionHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
            _groupHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
        }

        const group = new THREE.Group();

        const selectionMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
        });
        const selectionHalo = new THREE.Mesh(_selectionHaloGeometry, selectionMaterial);
        selectionHalo.visible = false;
        selectionHalo.renderOrder = 3;

        const groupMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.45,
            depthWrite: false
        });
        const groupHalo = new THREE.Mesh(_groupHaloGeometry, groupMaterial);
        groupHalo.visible = false;
        groupHalo.renderOrder = 2;

        group.add(selectionHalo);
        group.add(groupHalo);

        node.__selectionHalo = selectionHalo;
        node.__groupHalo = groupHalo;
        node.__overlayGroup = group;

        return group;
    }

    function updateOverlayScale(node) {
        const APPEARANCE_STATE = typeof window !== 'undefined' ? window.APPEARANCE_STATE : { nodeScale: 1 };
        const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE?.nodeScale || 1));
        const selectionScale = base * 2.5;
        const groupScale = base * 1.8;

        if (node.__selectionHalo) {
            node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
        }
        if (node.__groupHalo) {
            node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
        }
    }

    // =========================================================================
    // MARQUEE STATE
    // =========================================================================

    function setMarqueeActive(active) {
        _marqueeActive = active;
        if (!active) {
            _lastMarqueeEndTs = Date.now();
        }
    }

    function setMarqueeStart(pos) {
        _marqueeStart = pos;
    }

    function setMarqueeAdditive(additive) {
        _marqueeAdditive = additive;
    }

    // =========================================================================
    // UI HELPERS
    // =========================================================================

    function formatCountList(items, limit = 4) {
        return items.slice(0, limit).map(([key, count]) => `${key} ${count}`).join(' · ') || '--';
    }

    function appendSelectionRow(container, label, value) {
        const row = document.createElement('div');
        row.className = 'selection-row';
        const labelEl = document.createElement('span');
        labelEl.className = 'label';
        labelEl.textContent = label;
        const valueEl = document.createElement('span');
        valueEl.textContent = value || '--';
        row.appendChild(labelEl);
        row.appendChild(valueEl);
        container.appendChild(row);
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel() {
        const panel = document.getElementById('selection-panel');
        const body = document.getElementById('selection-body');
        const title = document.getElementById('selection-title');
        if (!panel || !body) return;

        const nodes = getSelectedNodes();
        if (!nodes.length) {
            panel.classList.remove('visible');
            body.innerHTML = '';
            return;
        }

        panel.classList.add('visible');
        if (title) title.textContent = `SELECTION (${nodes.length})`;
        body.innerHTML = '';

        if (nodes.length <= 3) {
            nodes.forEach(node => {
                const item = document.createElement('div');
                item.className = 'selection-item';
                const name = document.createElement('div');
                name.className = 'selection-name';
                name.textContent = node.name || node.id || 'Unknown';
                item.appendChild(name);
                appendSelectionRow(item, 'Family', typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--');
                appendSelectionRow(item, 'Ring', typeof getNodeRing === 'function' ? getNodeRing(node) : '--');
                appendSelectionRow(item, 'Tier', typeof getNodeTier === 'function' ? getNodeTier(node) : '--');
                appendSelectionRow(item, 'Role', node.role || '--');
                const filePath = node.file_path || node.file || '';
                if (filePath) {
                    const shortPath = filePath.length > 48 ? '...' + filePath.slice(-45) : filePath;
                    appendSelectionRow(item, 'File', shortPath);
                }
                body.appendChild(item);
            });
        } else {
            const summary = document.createElement('div');
            summary.className = 'selection-summary';

            const families = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(n) : '--') : [];
            const rings = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeRing === 'function' ? getNodeRing(n) : '--') : [];
            const tiers = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeTier === 'function' ? getNodeTier(n) : '--') : [];

            const total = document.createElement('div');
            total.textContent = `Total: ${nodes.length} nodes`;
            summary.appendChild(total);

            const familyRow = document.createElement('div');
            familyRow.textContent = `Family: ${formatCountList(families)}`;
            summary.appendChild(familyRow);

            const ringRow = document.createElement('div');
            ringRow.textContent = `Ring: ${formatCountList(rings)}`;
            summary.appendChild(ringRow);

            const tierRow = document.createElement('div');
            tierRow.textContent = `Tier: ${formatCountList(tiers)}`;
            summary.appendChild(tierRow);

            const numericKeys = [
                ['tokens', 'TOKENS'],
                ['bytes', 'BYTES'],
                ['loc', 'LOC'],
                ['lines', 'LINES'],
                ['lines_of_code', 'LOC'],
                ['size', 'SIZE']
            ];
            const totals = {};
            nodes.forEach(node => {
                numericKeys.forEach(([key]) => {
                    const value = Number(node[key]);
                    if (Number.isFinite(value)) {
                        totals[key] = (totals[key] || 0) + value;
                    }
                });
            });
            numericKeys.forEach(([key, label]) => {
                if (totals[key]) {
                    const row = document.createElement('div');
                    row.textContent = `${label}: ${Math.round(totals[key])}`;
                    summary.appendChild(row);
                }
            });

            body.appendChild(summary);
        }

        if (typeof HudLayoutManager !== 'undefined' && HudLayoutManager.reflow) {
            HudLayoutManager.reflow();
        }
    }

    // =========================================================================
    // SELECTION MODAL
    // =========================================================================

    function showSelectionModal() {
        const nodes = getSelectedNodes();
        if (!nodes.length) {
            if (typeof showToast === 'function') showToast('No nodes selected');
            return;
        }

        const overlay = document.getElementById('selection-modal-overlay');
        const title = document.getElementById('selection-modal-title');
        const statsContainer = document.getElementById('selection-modal-stats');
        const body = document.getElementById('selection-modal-body');

        if (!overlay || !body) return;

        // Calculate aggregates
        let totalTokens = 0, totalBytes = 0, totalLoc = 0;
        const tierCounts = {};
        const ringCounts = {};
        const familyCounts = {};

        nodes.forEach(node => {
            totalTokens += Number(node.tokens) || 0;
            totalBytes += Number(node.bytes) || 0;
            totalLoc += Number(node.loc || node.lines || node.lines_of_code) || 0;

            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';

            tierCounts[tier] = (tierCounts[tier] || 0) + 1;
            ringCounts[ring] = (ringCounts[ring] || 0) + 1;
            familyCounts[family] = (familyCounts[family] || 0) + 1;
        });

        const maxVal = Math.max(...nodes.map(n => n.val || n.size || 1));

        title.textContent = `SELECTED NODES (${nodes.length})`;

        // Build stats bar
        statsContainer.innerHTML = '';
        const stats = [
            ['NODES', nodes.length.toLocaleString()],
            ['TOKENS', totalTokens.toLocaleString()],
            ['BYTES', totalBytes.toLocaleString()],
            ['LOC', totalLoc.toLocaleString()],
            ['TIERS', Object.keys(tierCounts).join(', ')],
            ['FAMILIES', Object.keys(familyCounts).length]
        ];
        stats.forEach(([label, value]) => {
            if (value && value !== '0') {
                const stat = document.createElement('div');
                stat.className = 'selection-modal-stat';
                stat.innerHTML = `
                    <span class="selection-modal-stat-label">${label}</span>
                    <span class="selection-modal-stat-value">${value}</span>
                `;
                statsContainer.appendChild(stat);
            }
        });

        // Build table
        const sortedNodes = [...nodes].sort((a, b) => (b.val || b.size || 1) - (a.val || a.size || 1));

        body.innerHTML = `
            <table class="selection-modal-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Tier</th>
                        <th>Ring</th>
                        <th>Family</th>
                        <th>Level</th>
                        <th>Tokens</th>
                        <th>LOC</th>
                        <th>Relevance</th>
                    </tr>
                </thead>
                <tbody id="selection-modal-tbody"></tbody>
            </table>
        `;

        const tbody = document.getElementById('selection-modal-tbody');
        sortedNodes.forEach(node => {
            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';
            const level = node.level || node.scale_level || 'L3';
            const tokens = Number(node.tokens) || '--';
            const loc = Number(node.loc || node.lines || node.lines_of_code) || '--';
            const relevance = ((node.val || node.size || 1) / maxVal * 100).toFixed(0);

            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="node-name" title="${node.name || node.id}">${node.name || node.id}</td>
                <td><span class="level-badge tier-badge">${tier}</span></td>
                <td><span class="level-badge ring-badge">${ring}</span></td>
                <td><span class="level-badge family-badge">${family}</span></td>
                <td>${level}</td>
                <td class="numeric">${typeof tokens === 'number' ? tokens.toLocaleString() : tokens}</td>
                <td class="numeric">${typeof loc === 'number' ? loc.toLocaleString() : loc}</td>
                <td>
                    <div class="relevance-bar">
                        <div class="relevance-fill" style="width: ${relevance}%"></div>
                    </div>
                </td>
            `;
            tbody.appendChild(row);
        });

        overlay.classList.add('visible');
    }

    function hideSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        if (overlay) overlay.classList.remove('visible');
    }

    function initSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        const closeBtn = document.getElementById('selection-modal-close');
        const selectionTitle = document.getElementById('selection-title');

        if (closeBtn) {
            closeBtn.addEventListener('click', hideSelectionModal);
        }

        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) hideSelectionModal();
            });
        }

        if (selectionTitle) {
            selectionTitle.style.cursor = 'pointer';
            selectionTitle.addEventListener('click', showSelectionModal);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey) {
                const activeEl = document.activeElement;
                if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
                if (getSelectedNodes().length > 0) {
                    e.preventDefault();
                    showSelectionModal();
                }
            }
            if (e.key === 'Escape') {
                hideSelectionModal();
            }
        });
    }

    // =========================================================================
    // SELECTION BOX / MARQUEE
    // =========================================================================

    let _selectionBox = null;

    function updateSelectionBox(rect) {
        if (!_selectionBox) _selectionBox = document.getElementById('selection-box');
        if (!_selectionBox) return;
        _selectionBox.style.display = 'block';
        _selectionBox.style.left = `${rect.left}px`;
        _selectionBox.style.top = `${rect.top}px`;
        _selectionBox.style.width = `${rect.width}px`;
        _selectionBox.style.height = `${rect.height}px`;
    }

    function getNodeScreenPosition(node) {
        if (typeof Graph === 'undefined' || !Graph?.camera || !node) return null;
        if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return null;
        const camera = Graph.camera();
        const vector = new THREE.Vector3(node.x, node.y, node.z || 0);
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        return { x, y };
    }

    function selectNodesInBox(rect, additive = true) {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const nodes = Graph.graphData().nodes || [];
        const selected = [];
        nodes.forEach(node => {
            const pos = getNodeScreenPosition(node);
            if (!pos) return;
            if (pos.x >= rect.left && pos.x <= rect.right &&
                pos.y >= rect.top && pos.y <= rect.bottom) {
                if (node.id) selected.push(node.id);
            }
        });
        if (selected.length) {
            set(selected, additive);
        }
    }

    function setupSelectionInteractions() {
        const clearBtn = document.getElementById('selection-clear');
        if (clearBtn) {
            clearBtn.onclick = () => clear();
        }

        const groupBtn = document.getElementById('btn-create-group');
        if (groupBtn && typeof createGroupFromSelection === 'function') {
            groupBtn.onclick = () => createGroupFromSelection();
        }

        _selectionBox = document.getElementById('selection-box');
        if (typeof Graph === 'undefined' || !Graph?.renderer || !_selectionBox) return;

        const canvas = Graph.renderer().domElement;
        if (!canvas) return;

        const onPointerDown = (e) => {
            if (e.button !== 0) return;
            if (typeof SPACE_PRESSED !== 'undefined' && SPACE_PRESSED) return;
            if (e.target !== canvas) return;
            if (typeof HOVERED_NODE !== 'undefined' && HOVERED_NODE) return;
            _marqueeActive = true;
            _marqueeAdditive = !!e.shiftKey;
            _marqueeStart = { x: e.clientX, y: e.clientY };
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, _marqueeStart) : { left: e.clientX, top: e.clientY, width: 0, height: 0 });
            if (Graph.controls()) {
                Graph.controls().enabled = false;
            }
            e.preventDefault();
        };

        const onPointerMove = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) });
        };

        const finishSelection = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            const rect = typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) };
            _selectionBox.style.display = 'none';
            const additive = _marqueeAdditive;
            _marqueeActive = false;
            _marqueeStart = null;
            _marqueeAdditive = false;
            _lastMarqueeEndTs = Date.now();
            if (Graph.controls()) {
                Graph.controls().enabled = true;
            }
            const didDrag = rect.width > 4 && rect.height > 4;
            if (didDrag) {
                selectNodesInBox(rect, additive);
            }
        };

        canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
        canvas.addEventListener('pointermove', onPointerMove, { passive: true });
        canvas.addEventListener('pointerup', finishSelection, { passive: true });
        canvas.addEventListener('pointerleave', finishSelection, { passive: true });
    }

    // =========================================================================
    // SYNC AND INIT
    // =========================================================================

    function syncSelectionAfterGraphUpdate() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const visibleIds = new Set((Graph.graphData().nodes || []).map(n => n.id));
        const idsToRemove = [];
        Array.from(_ids).forEach(id => {
            if (!visibleIds.has(id)) {
                idsToRemove.push(id);
            }
        });
        if (idsToRemove.length > 0) {
            remove(idsToRemove);
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    function initSelectionState(data) {
        if (typeof buildDatasetKey === 'function') {
            window.DATASET_KEY = buildDatasetKey(data);
            window.GROUPS_STORAGE_KEY = `collider_groups_${window.DATASET_KEY}`;
        }
        if (typeof loadGroups === 'function') loadGroups();
        if (typeof renderGroupList === 'function') renderGroupList();
        updateSelectionPanel();
        _updateGroupButtonState();
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core selection
        set,
        toggle,
        clear,
        maybeClear,
        add,
        remove,
        getSelectedNodes,

        // State access
        get ids() { return _ids; },
        get size() { return _ids.size; },
        has(id) { return _ids.has(id); },

        // Animation
        startAnimation,
        stopAnimation,

        // Overlays
        ensureOverlays,
        updateOverlayScale,

        // Marquee
        setMarqueeActive,
        setMarqueeStart,
        setMarqueeAdditive,
        get marqueeActive() { return _marqueeActive; },
        get marqueeStart() { return _marqueeStart; },
        get marqueeAdditive() { return _marqueeAdditive; },
        get lastMarqueeEndTs() { return _lastMarqueeEndTs; },

        // Internal access (for migration)
        _selectionOriginals,
        _originalColorsForDim,

        // UI (moved from app.js)
        updateSelectionPanel,
        showSelectionModal,
        hideSelectionModal,
        initSelectionModal,
        updateSelectionBox,
        getNodeScreenPosition,
        selectNodesInBox,
        setupSelectionInteractions,
        syncSelectionAfterGraphUpdate,
        initSelectionState
    };
})();

// Backward compatibility aliases - Using getters to ensure live updates
// Note: All variables use Object.defineProperty to avoid duplicate declarations with app.js
// SELECTED_NODE_IDS - selection.js is now the SINGLE SOURCE OF TRUTH (unified in modularization)
Object.defineProperty(window, 'SELECTED_NODE_IDS', { get: () => SELECT.ids, configurable: true });
Object.defineProperty(window, 'MARQUEE_ACTIVE', { get: () => SELECT.marqueeActive, configurable: true });
Object.defineProperty(window, 'MARQUEE_START', { get: () => SELECT.marqueeStart, configurable: true });
Object.defineProperty(window, 'MARQUEE_ADDITIVE', { get: () => SELECT.marqueeAdditive, configurable: true });
Object.defineProperty(window, 'LAST_MARQUEE_END_TS', { get: () => SELECT.lastMarqueeEndTs, configurable: true });
// selectionOriginals, originalColorsForDim - app.js owns these, not duplicated here

function getSelectedNodes() { return SELECT.getSelectedNodes(); }
function setSelection(ids, additive) { SELECT.set(ids, additive); }
function toggleSelection(node) { SELECT.toggle(node); }
function clearSelection() { SELECT.clear(); }
function maybeClearSelection() { SELECT.maybeClear(); }
function startSelectionAnimation() { SELECT.startAnimation(); }
function stopSelectionAnimation() { SELECT.stopAnimation(); }
function ensureNodeOverlays(node) { return SELECT.ensureOverlays(node); }
function updateOverlayScale(node) { SELECT.updateOverlayScale(node); }

// UI functions (moved from app.js)
function updateSelectionPanel() { SELECT.updateSelectionPanel(); }
function showSelectionModal() { SELECT.showSelectionModal(); }
function hideSelectionModal() { SELECT.hideSelectionModal(); }
function initSelectionModal() { SELECT.initSelectionModal(); }
function updateSelectionBox(rect) { SELECT.updateSelectionBox(rect); }
function getNodeScreenPosition(node) { return SELECT.getNodeScreenPosition(node); }
function selectNodesInBox(rect, additive) { SELECT.selectNodesInBox(rect, additive); }
function setupSelectionInteractions() { SELECT.setupSelectionInteractions(); }
function syncSelectionAfterGraphUpdate() { SELECT.syncSelectionAfterGraphUpdate(); }
function initSelectionState(data) { SELECT.initSelectionState(data); }

console.log('[Module] SELECT loaded - selection UI, modal, marquee, animation');


// ═══ MODULE: modules/panels.js ═══
/**
 * PANELS MODULE
 *
 * Manages floating panels and HUD layout for the visualization.
 * Handles panel open/close, command bar, and UI dimming.
 *
 * Usage:
 *   PANELS.open('view')       // Open a panel
 *   PANELS.close('view')      // Close a panel
 *   PANELS.toggle('view')     // Toggle panel visibility
 *   PANELS.initCommandBar()   // Wire up command bar buttons
 */

const PANELS = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _activePanelId = null;

    // =========================================================================
    // PANEL FUNCTIONS
    // =========================================================================

    /**
     * Open a panel by ID
     */
    function open(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        // Close any already-open panel
        if (_activePanelId && _activePanelId !== panelId) {
            close(_activePanelId);
        }

        if (panel) {
            panel.classList.add('visible');
            setTimeout(() => { panel.style.opacity = '1'; }, 10);
        }
        if (btn) btn.classList.add('active');
        _activePanelId = panelId;

        // Dim the universe when panel opens
        document.body.classList.add('ui-active');

        // Dim starfield via JS
        if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
            const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
            STARFIELD.material.opacity = baseOpacity * 0.3;
        }
    }

    /**
     * Close a panel by ID
     */
    function close(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        if (panel) {
            panel.classList.remove('visible');
        }
        if (btn) btn.classList.remove('active');
        if (_activePanelId === panelId) _activePanelId = null;

        // Restore universe when all panels closed
        if (!_activePanelId) {
            document.body.classList.remove('ui-active');

            // Restore starfield
            if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
                const starsBtn = document.getElementById('btn-stars');
                const starsVisible = starsBtn && starsBtn.classList.contains('active');
                const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
                STARFIELD.material.opacity = starsVisible ? baseOpacity : 0;
            }
        }
    }

    /**
     * Toggle a panel
     */
    function toggle(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        if (panel && panel.classList.contains('visible')) {
            close(panelId);
        } else {
            open(panelId);
        }
    }

    /**
     * Get active panel ID
     */
    function getActive() {
        return _activePanelId;
    }

    // =========================================================================
    // COMMAND BAR INITIALIZATION
    // =========================================================================

    function initCommandBar() {
        const cmdBtns = {
            'cmd-view': 'view',
            'cmd-filter': 'filter',
            'cmd-style': 'style',
            'cmd-settings': 'settings'
        };

        Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', () => toggle(panelId));
            }
        });

        // Settings panel: Oval margin slider
        _initOvalMarginSlider();
        _initOvalDebugToggle();

        // Style panel sliders (consolidated from app.js)
        _initStylePanelSliders();
        _initToggleSwitches();
        _initSegmentedControls();
        _initCommandBarActions();
    }

    // ═══════════════════════════════════════════════════════════════════
    // STYLE PANEL SLIDERS - Connected to appearance system
    // ═══════════════════════════════════════════════════════════════════

    function _initStylePanelSliders() {
        // Node Size Slider
        const nodeSizeSlider = document.getElementById('node-size-slider');
        const nodeSizeValue = document.getElementById('node-size-value');
        if (nodeSizeSlider) {
            nodeSizeSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (nodeSizeValue) nodeSizeValue.textContent = val.toFixed(1) + 'x';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.nodeVal(node => (node.val || node.size || 1) * val);
                }
            });
        }

        // Edge Opacity Slider
        const edgeOpacitySlider = document.getElementById('edge-opacity-slider');
        const edgeOpacityValue = document.getElementById('edge-opacity-value');
        if (edgeOpacitySlider) {
            edgeOpacitySlider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (edgeOpacityValue) edgeOpacityValue.textContent = val + '%';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val / 100;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
            });
        }

        // Density Slider (filter panel) - NOTE: #density-slider2 not in current HTML template
        // Code retained for future filter panel implementation
        const densitySlider2 = document.getElementById('density-slider2');
        const densityValue2 = document.getElementById('density-value2');
        if (densitySlider2) {
            densitySlider2.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (densityValue2) densityValue2.textContent = val + '%';
                if (typeof CURRENT_DENSITY !== 'undefined') window.CURRENT_DENSITY = val;
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        }
    }

    function _initToggleSwitches() {
        document.querySelectorAll('.toggle-switch').forEach(toggle => {
            toggle.addEventListener('click', () => {
                toggle.classList.toggle('active');
            });
        });
    }

    function _initSegmentedControls() {
        document.querySelectorAll('.segmented-control').forEach(control => {
            control.querySelectorAll('.segment').forEach(segment => {
                segment.addEventListener('click', () => {
                    control.querySelectorAll('.segment').forEach(s => s.classList.remove('active'));
                    segment.classList.add('active');

                    // Handle dimension change
                    if (control.id === 'dim-control') {
                        const dim = segment.dataset.dim;
                        if (typeof IS_3D !== 'undefined') {
                            window.IS_3D = (dim !== '2');
                            if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                        }
                    }

                    // Handle node color mode
                    if (control.id === 'node-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode && typeof setNodeColorMode === 'function') {
                            setNodeColorMode(mode);
                        }
                    }

                    // Handle edge color mode
                    if (control.id === 'edge-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode) {
                            if (typeof EDGE_MODE !== 'undefined') window.EDGE_MODE = mode;
                            if (typeof applyEdgeMode === 'function') applyEdgeMode();
                        }
                    }

                    // Handle panel layout
                    if (control.id === 'layout-control') {
                        const layout = segment.dataset.layout;
                        if (layout) {
                            document.body.setAttribute('data-layout', layout);
                        }
                    }
                });
            });
        });
    }

    function _initCommandBarActions() {
        // Skip if REGISTRY not available (defensive)
        if (typeof REGISTRY === 'undefined' || !REGISTRY.register) return;

        // File mode toggle
        REGISTRY.register('cmd-files2', () => {
            if (typeof setFileModeState === 'function') {
                const newState = typeof fileMode !== 'undefined' ? !fileMode : true;
                setFileModeState(newState);
                const btn = document.getElementById('cmd-files2');
                if (btn) btn.classList.toggle('active', newState);
            }
        }, { desc: 'Toggle File Boundaries Mode' });

        // Flow mode toggle
        REGISTRY.register('cmd-flow2', () => {
            if (typeof toggleFlowMode === 'function') {
                toggleFlowMode();
                const btn = document.getElementById('cmd-flow2');
                if (btn && typeof flowMode !== 'undefined') btn.classList.toggle('active', flowMode);
            }
        }, { desc: 'Toggle Flow Mode' });

        // 3D toggle
        REGISTRY.register('cmd-3d', () => {
            if (typeof toggleDimensions === 'function') {
                toggleDimensions();
            } else if (typeof IS_3D !== 'undefined') {
                window.IS_3D = !window.IS_3D;
                if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                const btnDim = document.getElementById('btn-dimensions');
                if (btnDim) btnDim.textContent = window.IS_3D ? '2D' : '3D';
            }
            const btn = document.getElementById('cmd-3d');
            if (btn && typeof IS_3D !== 'undefined') btn.classList.toggle('active', window.IS_3D);

            // Update dim-control if exists
            const dimControl = document.getElementById('dim-control');
            if (dimControl && typeof IS_3D !== 'undefined') {
                dimControl.querySelectorAll('.segment').forEach(s => {
                    s.classList.toggle('active', s.dataset.dim === (window.IS_3D ? '3' : '2'));
                });
            }
        }, { desc: 'Toggle 2D/3D View' });

        console.log('[PANELS] Command bar actions registered');
    }

    function _initOvalMarginSlider() {
        const ovalSlider = document.getElementById('oval-margin-slider');
        const ovalValue = document.getElementById('oval-margin-value');
        let ovalDebounceTimer = null;

        if (ovalSlider) {
            ovalSlider.addEventListener('input', (e) => {
                if (ovalValue) ovalValue.textContent = e.target.value + '%';
            });

            const applyOvalMargin = () => {
                clearTimeout(ovalDebounceTimer);
                ovalDebounceTimer = setTimeout(() => {
                    const val = ovalSlider.value;
                    document.documentElement.style.setProperty('--oval-margin', val + '%');
                }, 300);
            };

            ovalSlider.addEventListener('mouseup', applyOvalMargin);
            ovalSlider.addEventListener('touchend', applyOvalMargin);
            ovalSlider.addEventListener('change', applyOvalMargin);
        }
    }

    function _initOvalDebugToggle() {
        const toggleOvalDebug = document.getElementById('toggle-oval-debug');
        if (toggleOvalDebug) {
            toggleOvalDebug.addEventListener('click', () => {
                toggleOvalDebug.classList.toggle('active');
                const ovalDebug = document.querySelector('.oval-debug');
                if (ovalDebug) {
                    ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
                }
            });
        }
    }

    // =========================================================================
    // HUD LAYOUT MANAGER - REMOVED, USE LAYOUT MODULE
    // =========================================================================
    // The HudLayoutManager has been unified into modules/layout.js
    // Use LAYOUT.reflow() instead of PANELS.HudLayoutManager.reflow()

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        open,
        close,
        toggle,
        getActive,
        initCommandBar,

        // State access
        get activePanelId() { return _activePanelId; }
    };
})();

// Backward compatibility - _activePanelId is managed by app.js
function openPanel(panelId) { PANELS.open(panelId); }
function closePanel(panelId) { PANELS.close(panelId); }
function togglePanel(panelId) { PANELS.toggle(panelId); }
function initCommandBar() { PANELS.initCommandBar(); }
// HudLayoutManager - app.js owns this, not duplicated here

// ════════════════════════════════════════════════════════════════════════
// PANEL DRAG & RESIZE - Make panels movable and resizable
// ════════════════════════════════════════════════════════════════════════

const PANEL_DRAG = (function() {
    'use strict';

    const _panels = new Map();
    let _dragState = null;
    let _resizeState = null;
    const STORAGE_KEY = 'collider-panel-positions';

    function init() {
        // Initialize draggable/resizable panels (use actual element IDs)
        initPanel('side-dock', { draggable: true, resizable: true, minWidth: 150, maxWidth: 400 });
        initPanel('header-panel', { draggable: true, resizable: false });
        initPanel('stats-panel', { draggable: true, resizable: false });
        initPanel('metrics-panel', { draggable: true, resizable: true, minWidth: 180, maxWidth: 350 });

        // Restore saved positions
        restorePositions();

        // Global mouse handlers
        document.addEventListener('mousemove', (e) => _onMouseMove(e));
        document.addEventListener('mouseup', (e) => _onMouseUp(e));
    }

    function initPanel(id, options = {}) {
        const panel = document.getElementById(id) || document.querySelector('.' + id);
        if (!panel) return;

        const config = {
            el: panel,
            id: id,
            draggable: options.draggable !== false,
            resizable: options.resizable === true,
            minWidth: options.minWidth || 100,
            maxWidth: options.maxWidth || 600,
            minHeight: options.minHeight || 50,
            maxHeight: options.maxHeight || window.innerHeight - 100
        };

        _panels.set(id, config);

        // Make panel positioned if not already
        const style = window.getComputedStyle(panel);
        if (style.position === 'static') {
            panel.style.position = 'absolute';
        }

        // Add drag handle (the panel header or title)
        if (config.draggable) {
            const header = panel.querySelector('.side-title, .hud-title, .panel-header') || panel;
            header.style.cursor = 'move';
            header.addEventListener('mousedown', (e) => _startDrag(e, id));
        }

        // Add resize handle
        if (config.resizable) {
            const handle = document.createElement('div');
            handle.className = 'panel-resize-handle';
            handle.addEventListener('mousedown', (e) => _startResize(e, id));
            panel.appendChild(handle);
            panel.style.position = 'absolute';
        }
    }

    function _startDrag(e, panelId) {
        // Don't drag if clicking on interactive elements
        if (e.target.closest('input, button, select, .collapsible-content, .preset-btn, .layout-btn, .scheme-btn')) {
            return;
        }

        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        const rect = config.el.getBoundingClientRect();

        _dragState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startLeft: rect.left,
            startTop: rect.top
        };

        config.el.classList.add('panel-dragging');
    }

    function _startResize(e, panelId) {
        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        e.stopPropagation();

        const rect = config.el.getBoundingClientRect();

        _resizeState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startWidth: rect.width,
            startHeight: rect.height
        };

        config.el.classList.add('panel-resizing');
    }

    function _onMouseMove(e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (!config) return;

            const dx = e.clientX - _dragState.startX;
            const dy = e.clientY - _dragState.startY;

            let newLeft = _dragState.startLeft + dx;
            let newTop = _dragState.startTop + dy;

            // Keep within viewport
            newLeft = Math.max(0, Math.min(window.innerWidth - 50, newLeft));
            newTop = Math.max(0, Math.min(window.innerHeight - 50, newTop));

            config.el.style.left = newLeft + 'px';
            config.el.style.top = newTop + 'px';
            config.el.style.right = 'auto';
            config.el.style.bottom = 'auto';
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (!config) return;

            const dx = e.clientX - _resizeState.startX;
            const dy = e.clientY - _resizeState.startY;

            let newWidth = _resizeState.startWidth + dx;
            let newHeight = _resizeState.startHeight + dy;

            // Apply constraints
            newWidth = Math.max(config.minWidth, Math.min(config.maxWidth, newWidth));
            newHeight = Math.max(config.minHeight, Math.min(config.maxHeight, newHeight));

            config.el.style.width = newWidth + 'px';
            // Only resize height for certain panels
            if (config.el.classList.contains('side-dock') || config.el.classList.contains('side-content')) {
                // Don't change height for sidebar - it's auto
            } else {
                config.el.style.height = newHeight + 'px';
            }
        }
    }

    function _onMouseUp(_e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (config) {
                config.el.classList.remove('panel-dragging');
                savePositions();
            }
            _dragState = null;
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (config) {
                config.el.classList.remove('panel-resizing');
                savePositions();
            }
            _resizeState = null;
        }
    }

    function savePositions() {
        const positions = {};
        _panels.forEach((config, id) => {
            const rect = config.el.getBoundingClientRect();
            const style = config.el.style;
            positions[id] = {
                left: style.left || rect.left + 'px',
                top: style.top || rect.top + 'px',
                width: style.width || null,
                height: style.height || null
            };
        });
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not save positions:', e);
        }
    }

    function restorePositions() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;

            const positions = JSON.parse(saved);
            Object.entries(positions).forEach(([id, pos]) => {
                const config = _panels.get(id);
                if (!config) return;

                if (pos.left) config.el.style.left = pos.left;
                if (pos.top) config.el.style.top = pos.top;
                if (pos.width) config.el.style.width = pos.width;
                if (pos.height) config.el.style.height = pos.height;

                // Clear right/bottom if we're setting left/top
                if (pos.left) config.el.style.right = 'auto';
                if (pos.top) config.el.style.bottom = 'auto';
            });
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not restore positions:', e);
        }
    }

    function resetPositions() {
        try {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not reset positions:', e);
        }
    }

    return {
        init,
        initPanel,
        savePositions,
        restorePositions,
        resetPositions,
        get panels() { return _panels; }
    };
})();

// Backward compatibility wrapper
const PanelManager = {
    panels: PANEL_DRAG.panels,
    init() { PANEL_DRAG.init(); },
    initPanel(id, opts) { PANEL_DRAG.initPanel(id, opts); },
    savePositions() { PANEL_DRAG.savePositions(); },
    restorePositions() { PANEL_DRAG.restorePositions(); },
    resetPositions() { PANEL_DRAG.resetPositions(); }
};

// Initialize after DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => PANEL_DRAG.init());
} else {
    setTimeout(() => PANEL_DRAG.init(), 100);
}

// Expose globally
window.PANEL_DRAG = PANEL_DRAG;
window.PanelManager = PanelManager;


// ═══ MODULE: modules/sidebar.js ═══
/**
 * SIDEBAR MODULE
 *
 * Manages sidebar controls including color presets, layout presets,
 * physics controls, appearance controls, filters, and panel updates.
 *
 * Depends on: ANIM (for layouts), REFRESH (for throttled updates)
 *
 * Usage:
 *   SIDEBAR.init()                         // Initialize after DOM ready
 *   SIDEBAR.setColorMode('tier')           // Change color mode
 *   SIDEBAR.setLayout('force')             // Change layout
 *   SIDEBAR.setPhysicsPreset('tight')      // Apply physics preset
 *   SIDEBAR.updateStats(nodes, edges)      // Update stat displays
 */

// Note: Using window assignment instead of const to avoid duplicate declaration with app.js
window.SIDEBAR = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _refreshTimer = null;
    let _bound = false;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    /**
     * Initialize sidebar - call after DOM is ready
     */
    function init() {
        if (_bound) return;
        _bound = true;

        // Initialize unified state manager first
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.init();
        }

        _bindSectionHeaders();
        _bindColorPresets();
        _bindLayoutPresets();
        _bindPhysicsControls();
        _bindAppearanceControls();
        _bindActionButtons();
        initSchemeNavigator();
        initViewModeToggle();
        initSectionResize();   // Enable vertical section resizing
        initSidebarResize();   // Enable horizontal sidebar resizing

        // Sync UI to initial state
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.syncUIFromState();
        }

        console.log('[SIDEBAR] Initialized');
    }

    // =========================================================================
    // SECTION COLLAPSE/EXPAND
    // =========================================================================

    function _bindSectionHeaders() {
        document.querySelectorAll('.section-header[data-section]').forEach(header => {
            header.addEventListener('click', () => {
                const sectionId = header.dataset.section;
                const content = document.getElementById(`section-${sectionId}`);
                if (!content) return;

                const isCollapsed = header.classList.toggle('collapsed');
                content.classList.toggle('collapsed', isCollapsed);
            });
        });
    }

    // =========================================================================
    // COLOR PRESETS (TIER, FAMILY, LAYER, RING, FILE, FLOW)
    // =========================================================================

    // =========================================================================
    // COLOR PRESETS: SMART SIDEBAR CONFIGURATION
    // =========================================================================

    const PRESET_CONFIG = [
        {
            category: 'Architecture',
            presets: [
                { id: 'tier', label: 'Tier', desc: 'Auto-detected architectural height' },
                { id: 'layer', label: 'Layer', desc: 'Business logic strata' },
                { id: 'subsystem', label: 'Subsystem', desc: 'Functional domain grouping' },
                { id: 'boundary_score', label: 'Boundary', desc: 'Internal vs External (1-9)' },
                { id: 'phase', label: 'Phase', desc: 'Data-Logic-Org-Exec (MIPO)' }
            ]
        },
        {
            category: 'Taxonomy',
            presets: [
                { id: 'atom', label: 'Atom', desc: 'Function, Class, Module types' },
                { id: 'family', label: 'Family', desc: 'Logic, Data, Execution' },
                { id: 'role', label: 'Role', desc: 'Service, Repo, Controller' },
                { id: 'roleCategory', label: 'Role Cat', desc: 'Query, Command, Event' },
                { id: 'fileType', label: 'File Type', desc: 'Extension-based coloring' }
            ]
        },
        {
            category: 'Metrics',
            presets: [
                { id: 'complexity', label: 'Complexity', desc: 'Cyclomatic complexity' },
                { id: 'loc', label: 'LOC', desc: 'Lines of Code' },
                { id: 'fan_in', label: 'Fan-In', desc: 'Incoming dependencies' },
                { id: 'fan_out', label: 'Fan-Out', desc: 'Outgoing dependencies' },
                { id: 'trust', label: 'Trust', desc: 'Detection confidence' }
            ]
        },
        {
            category: 'RPBL DNA',
            presets: [
                { id: 'responsibility', label: 'Responsibility', desc: 'SRP alignment (1-9)' },
                { id: 'purity', label: 'Purity', desc: 'Side-effect profile (1-9)' },
                { id: 'lifecycle_score', label: 'Lifecycle', desc: 'Static vs Dynamic (1-9)' },
                { id: 'state', label: 'State', desc: 'Stateful vs Stateless' },
                { id: 'visibility', label: 'Visibility', desc: 'Public vs Private' }
            ]
        },
        {
            category: 'Topology',
            presets: [
                { id: 'centrality', label: 'Centrality', desc: 'Graph importance' },
                { id: 'rank', label: 'PageRank', desc: 'Algorithmic influence' }, // mapped to centrality logic or similar
                { id: 'ring', label: 'Ring', desc: 'Concentric architecture rings' },
                { id: 'flow', label: 'Flow', desc: 'Dependency direction' }
            ]
        },
        {
            category: 'Evolution',
            presets: [
                { id: 'churn', label: 'Churn', desc: 'Change frequency (Simulated)' },
                { id: 'age', label: 'Age', desc: 'Time since creation (Simulated)' }
            ]
        }
    ];

    // =========================================================================
    // SCHEME NAVIGATOR: 33 Named Color Schemes
    // =========================================================================

    const SCHEME_CONFIG = [
        // PART A: Famous Scientific (15)
        { category: 'Sequential', schemes: ['viridis', 'plasma', 'magma', 'inferno', 'cividis', 'turbo', 'mako', 'rocket'] },
        { category: 'Diverging', schemes: ['coolwarm', 'spectral'] },
        { category: 'Thematic', schemes: ['thermal', 'nightvision', 'ocean', 'terrain', 'electric'] },

        // PART B: Role-Semantic (18 key roles)
        { category: 'Access', schemes: ['query', 'finder'] },
        { category: 'Mutation', schemes: ['command', 'creator', 'destroyer'] },
        { category: 'Construction', schemes: ['factory'] },
        { category: 'Storage', schemes: ['repository', 'cache'] },
        { category: 'Control', schemes: ['service', 'orchestrator'] },
        { category: 'Validation', schemes: ['validator', 'guard'] },
        { category: 'Transform', schemes: ['transformer', 'parser'] },
        { category: 'Events', schemes: ['handler', 'emitter'] },
        { category: 'Support', schemes: ['utility', 'lifecycle'] },

        // PART C: OKLCH Geometry (Mathematical paths through color space)
        { category: 'Loops', schemes: ['rainbow-loop', 'rainbow-bright', 'rainbow-dark'] },
        { category: 'Arcs', schemes: ['arc-warm', 'arc-cool', 'arc-nature'] },
        { category: 'Spirals', schemes: ['spiral-up', 'spiral-down', 'spiral-chroma'] },
        { category: 'Waves', schemes: ['wave-lightness', 'wave-chroma', 'pulse'] },
        { category: 'Ramps', schemes: ['ramp-hue', 'ramp-lightness', 'ramp-chroma'] },
        { category: 'Paths', schemes: ['helix', 'convergent', 'divergent', 'bicone'] }
    ];

    function _bindColorPresets() {
        // Init Smart Sidebar
        const container = document.getElementById('section-color');
        if (!container) return;

        // Clear existing static buttons if any (except header)
        const contentDiv = container.querySelector('.section-content');
        if (contentDiv) {
            contentDiv.innerHTML = ''; // Rebuild from scratch
            renderSmartSidebar(contentDiv);
        }
    }

    function renderSmartSidebar(container) {
        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Presets...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.preset-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.btn').forEach(btn => {
                    const match = btn.textContent.toLowerCase().includes(term) || btn.title.toLowerCase().includes(term);
                    btn.style.display = match ? 'block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        searchContainer.appendChild(searchInput);
        container.appendChild(searchContainer);

        // Render Categories
        PRESET_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'preset-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'btn-grid btn-grid-3'; // Default to 3-col

            section.presets.forEach(p => {
                const btn = document.createElement('button');
                btn.className = 'btn color-btn';
                btn.textContent = p.label;
                btn.title = p.desc;
                btn.dataset.preset = p.id;

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    setColorMode(p.id);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    // =========================================================================
    // SCHEME NAVIGATOR RENDERER
    // =========================================================================

    function renderSchemeNavigator(container) {
        if (!container) return;
        container.innerHTML = '';

        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Schemes...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.scheme-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.scheme-btn').forEach(btn => {
                    const match = btn.dataset.scheme.toLowerCase().includes(term) ||
                        (btn.title && btn.title.toLowerCase().includes(term));
                    btn.style.display = match ? 'inline-block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear';
        clearBtn.title = 'Remove scheme, use default colors';
        clearBtn.style.cssText = 'margin-left: 8px; padding: 4px 8px; font-size: 9px; background: rgba(255,100,100,0.2); border: 1px solid rgba(255,100,100,0.3); color: var(--text); border-radius: 4px; cursor: pointer;';
        clearBtn.addEventListener('click', clearColorScheme);

        searchContainer.appendChild(searchInput);
        searchContainer.appendChild(clearBtn);
        container.appendChild(searchContainer);

        // Render Categories
        SCHEME_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'scheme-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'scheme-grid';
            grid.style.cssText = 'display: flex; flex-wrap: wrap; gap: 4px;';

            section.schemes.forEach(schemeName => {
                const btn = document.createElement('button');
                btn.className = 'scheme-btn';
                btn.dataset.scheme = schemeName;

                // Get scheme info from COLOR engine
                let info = { name: schemeName, semantic: '' };
                if (typeof COLOR !== 'undefined' && COLOR.getSchemeInfo) {
                    info = COLOR.getSchemeInfo(schemeName);
                }

                btn.title = info.semantic || schemeName;

                // Create clean color swatches (5 stops) instead of ugly gradient
                const swatchContainer = document.createElement('div');
                swatchContainer.className = 'scheme-swatches';

                if (typeof COLOR !== 'undefined' && COLOR.getSchemeColor) {
                    // Sample 5 colors from the scheme path
                    [0, 0.25, 0.5, 0.75, 1].forEach(t => {
                        const swatch = document.createElement('span');
                        swatch.className = 'scheme-swatch';
                        swatch.style.backgroundColor = COLOR.getSchemeColor(schemeName, t);
                        swatchContainer.appendChild(swatch);
                    });
                }

                btn.appendChild(swatchContainer);

                // Label below swatches
                const label = document.createElement('span');
                label.className = 'scheme-label';
                label.textContent = info.name;
                btn.appendChild(label);

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    applyColorScheme(schemeName);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    /**
     * Apply a named color scheme (palette)
     *
     * NEW BEHAVIOR (via VIS_STATE):
     * - Palette is "armed" but does NOT auto-switch colorBy mode
     * - Palette only visually applies when colorBy is an interval mode
     * - When user switches to interval mode, the armed palette becomes active
     */
    function applyColorScheme(schemeName) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(schemeName);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(schemeName);
        }

        try {
            localStorage.setItem('collider_scheme', schemeName);
        } catch (e) { /* ignore */ }

        _refreshGraphColors();
        console.log('[SIDEBAR] Applied scheme:', schemeName);
    }

    /**
     * Clear active scheme, return to default interval colors
     */
    function clearColorScheme() {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(null);
            return;
        }

        // Fallback
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(null);
        }

        try {
            localStorage.removeItem('collider_scheme');
        } catch (e) { /* ignore */ }

        document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));

        _refreshGraphColors();

        console.log('[SIDEBAR] Cleared color scheme');
    }

    /**
     * Internal: Refresh all node colors and re-render the graph
     */
    function _refreshGraphColors() {
        if (typeof Graph === 'undefined' || !Graph) return;

        // Get current nodes from DataManager or Graph
        const DM = window.DM;
        const nodes = DM ? DM.getNodes() : (Graph.graphData ? Graph.graphData().nodes : []);

        // Recompute colors using current mode
        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render
        Graph.nodeColor(Graph.nodeColor());

        // Also refresh edges if in gradient mode
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    /**
     * Initialize scheme navigator in sidebar
     */
    function initSchemeNavigator() {
        const container = document.getElementById('section-schemes');
        if (container) {
            renderSchemeNavigator(container);
        }

        // Setup collapsible header for schemes panel
        const collapsibleHeaders = document.querySelectorAll('.info-panel-header.collapsible');
        collapsibleHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    header.classList.toggle('collapsed', isCollapsed);
                }
            });
        });

        // Setup color mode buttons (for right sidebar)
        const colorBtns = document.querySelectorAll('.color-panel .color-btn');
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                if (!preset) return;

                // Apply color mode via VIS_STATE (handles UI sync)
                setColorMode(preset);
            });
        });

        // NOTE: Saved preferences are now loaded by VIS_STATE.init()
        // UI sync is handled by VIS_STATE.syncUIFromState()
    }

    // =========================================================================
    // VIEW MODE TOGGLE (ATOMS vs FILES)
    // =========================================================================

    let _currentViewMode = 'atoms';
    let _deferredViewMode = null;  // Stores mode to apply after data loads

    /**
     * Initialize the view mode toggle (Atoms vs Files)
     * Note: Only sets up event handlers and button visual state.
     * Actual mode application for 'files' is deferred until data is loaded.
     */
    function initViewModeToggle() {
        const toggle = document.getElementById('view-mode-toggle');
        if (!toggle) return;

        const buttons = toggle.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                if (!mode || mode === _currentViewMode) return;

                setViewMode(mode);
            });
        });

        // Load saved preference - but only update button state, defer actual mode switch
        try {
            const saved = localStorage.getItem('collider_view_mode');
            if (saved && (saved === 'atoms' || saved === 'files')) {
                // Update button visual state immediately
                buttons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === saved);
                });
                _currentViewMode = saved;

                // If files mode, defer application until data is loaded
                if (saved === 'files') {
                    _deferredViewMode = 'files';
                    console.log('[SIDEBAR] Files mode saved - deferring until data loads');
                }
            }
        } catch (e) { /* ignore */ }
    }

    /**
     * Apply deferred view mode after data is loaded
     * Call this from initGraph() after DM.init() completes
     */
    function applyDeferredViewMode() {
        if (_deferredViewMode === 'files') {
            console.log('[SIDEBAR] Applying deferred files mode now that data is loaded');
            _deferredViewMode = null;  // Clear to prevent re-application

            // Apply files mode (data is now available)
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
                console.log('[SIDEBAR] View mode: FILES - showing file nodes');

                if (typeof showToast === 'function') {
                    showToast('FILE VIEW: Each node is a file. Click to expand.');
                }
            }
        }
    }

    /**
     * Set the view mode (atoms or files)
     */
    function setViewMode(mode) {
        if (mode !== 'atoms' && mode !== 'files') return;
        _currentViewMode = mode;

        // Update button states
        const buttons = document.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });

        // Save preference
        try {
            localStorage.setItem('collider_view_mode', mode);
        } catch (e) { /* ignore */ }

        // Apply view mode via FILE_VIZ module
        if (mode === 'files') {
            // Switch to file-nodes view
            if (typeof FILE_VIZ !== 'undefined') {
                // Build the file graph first (required before switching mode)
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'files';
                if (typeof buildFileGraph === 'function') buildFileGraph(null);
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: FILES - showing file nodes');
        } else {
            // Switch to atoms view
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.graphMode = 'atoms';
                FILE_VIZ.setEnabled(false);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'atoms';
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: ATOMS - showing individual atoms');
        }

        // Show toast notification
        if (typeof showToast === 'function') {
            const msg = mode === 'files'
                ? 'FILE VIEW: Each node is a file. Click to expand.'
                : 'ATOM VIEW: Each node is a code element.';
            showToast(msg);
        }
    }

    /**
     * Get current view mode
     */
    function getViewMode() {
        return _currentViewMode;
    }

    function setColorMode(mode) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setColorBy(mode);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof APPEARANCE_STATE !== 'undefined') {
            APPEARANCE_STATE.colorMode = mode;
            APPEARANCE_STATE.currentPreset = mode;
        }

        if (typeof setNodeColorMode === 'function') {
            setNodeColorMode(mode);
        }

        // Handle flow mode specially
        if (mode === 'flow') {
            if (typeof flowMode !== 'undefined' && !flowMode && typeof toggleFlowMode === 'function') {
                toggleFlowMode();
            }
        } else if (typeof flowMode !== 'undefined' && flowMode && typeof disableFlowMode === 'function') {
            disableFlowMode();
        }

        if (typeof window !== 'undefined' && typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        console.log('[SIDEBAR] Color mode:', mode);
    }

    // =========================================================================
    // LAYOUT PRESETS (FORCE, RADIAL, ORBITAL, SPHERE, GRID, SPIRAL)
    // =========================================================================

    function _bindLayoutPresets() {
        const container = document.getElementById('section-layout');
        if (!container) return;

        container.querySelectorAll('.btn[data-layout]').forEach(btn => {
            btn.addEventListener('click', () => {
                const layout = btn.dataset.layout;
                setLayout(layout);

                // Update active state
                container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });
    }

    function setLayout(layout) {
        // Prefer ANIM module if available
        if (typeof ANIM !== 'undefined' && ANIM.applyLayout) {
            ANIM.applyLayout(layout, true);
        } else if (typeof applyLayoutPreset === 'function') {
            applyLayoutPreset(layout, true);
        }
        console.log('[SIDEBAR] Layout:', layout);
    }

    // =========================================================================
    // PHYSICS CONTROLS
    // =========================================================================

    const PHYSICS_PRESETS = {
        default: { charge: -120, link: 50, center: 0.05, damping: 0.4 },
        tight: { charge: -80, link: 30, center: 0.1, damping: 0.5 },
        loose: { charge: -200, link: 80, center: 0.02, damping: 0.3 },
        explosive: { charge: -400, link: 120, center: 0.01, damping: 0.2 }
    };

    function _bindPhysicsControls() {
        // Charge (repulsion)
        _bindSlider('physics-charge', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('charge').strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Link distance
        _bindSlider('physics-link', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('link').distance(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Center pull
        _bindSlider('physics-center', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                const center = Graph.d3Force('center');
                if (center && center.strength) center.strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Damping (velocity decay)
        _bindSlider('physics-damping', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3VelocityDecay(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Physics presets
        const container = document.getElementById('section-physics');
        if (container) {
            container.querySelectorAll('.btn[data-physics]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.physics;
                    setPhysicsPreset(preset);
                });
            });
        }
    }

    function setPhysicsPreset(preset) {
        const p = PHYSICS_PRESETS[preset];
        if (!p) return;

        // Update sliders
        _setSliderValue('physics-charge', p.charge);
        _setSliderValue('physics-link', p.link);
        _setSliderValue('physics-center', p.center);
        _setSliderValue('physics-damping', p.damping);

        // Apply to graph
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('charge').strength(p.charge);
            Graph.d3Force('link').distance(p.link);
            const center = Graph.d3Force('center');
            if (center && center.strength) center.strength(p.center);
            Graph.d3VelocityDecay(p.damping);
            Graph.d3ReheatSimulation();
        }

        console.log('[SIDEBAR] Physics preset:', preset);
    }

    // =========================================================================
    // APPEARANCE CONTROLS
    // =========================================================================

    function _bindAppearanceControls() {
        // Auto-bind all sliders that have a matching numeric input
        // This covers cfg-node-size, cfg-node-opacity, etc.
        const ranges = document.querySelectorAll('input[type="range"]');
        ranges.forEach(range => {
            if (range.id) {
                _bindSlider(range.id, (val) => {
                    // Dispatch to specific handlers based on ID
                    // This creates a centralized handler dispatch
                    _handleSliderChange(range.id, val);
                });
            }
        });

        // Toggles
        _bindToggle('cfg-toggle-labels', (active) => {
            if (typeof VIS_FILTERS !== 'undefined' && VIS_FILTERS.metadata) {
                VIS_FILTERS.metadata.showLabels = active;
            }
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.nodeLabel(n => active ? n.name : null);
            }
        });

        _bindToggle('cfg-toggle-highlight', (active) => {
            // Handled by VIS_STATE or interactions
        });

        _bindToggle('cfg-toggle-pulse', (active) => {
            if (typeof ANIM !== 'undefined') {
                ANIM.togglePulse(active);
            }
        });

        _bindToggle('cfg-toggle-depth', (active) => {
            // 3D shading toggle
        });

        _bindToggle('cfg-toggle-arrows', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.showArrows = active;
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.linkDirectionalArrowLength(active ? 6 : 0);
                Graph.linkDirectionalArrowRelPos(0.9);
            }
        });

        _bindToggle('cfg-toggle-gradient', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.gradientEdges = active;
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            window.refreshGradientEdgeColors && window.refreshGradientEdgeColors();
        });
    }

    // Centralized handler for all sliders
    function _handleSliderChange(id, val) {
        // Map ID to logic
        switch (id) {
            // Node Config
            case 'cfg-node-size':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeVal(n => (n.val || 1) * val);
                break;
            case 'cfg-node-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode(); // Re-apply colors with new alpha
                break;
            case 'cfg-node-res':
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeResolution(val);
                break;
            case 'cfg-label-size':
                // Note: 3d-force-graph doesn't have a direct dynamic label size multiplier, 
                // but we can trigger a re-render or update state.
                break;

            // Edge Config    
            case 'cfg-edge-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
                break;
            case 'cfg-edge-width':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeWidth = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkWidth(val);
                break;
            case 'cfg-edge-curve':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeCurvature = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkCurvature(val);
                break;
            case 'cfg-particle-speed':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticleSpeed(val);
                break;
            case 'cfg-particle-count':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticles(val);
                break;

            // Physics (Updated IDs)
            case 'physics-charge':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('charge').strength(val);
                    Graph.d3ReheatSimulation();
                }
                break;
            case 'physics-link':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('link').distance(val);
                    Graph.d3ReheatSimulation();
                }
                break;
        }
    }


    // =========================================================================
    // ACTION BUTTONS
    // =========================================================================

    function _bindActionButtons() {
        // Reset view
        const resetBtn = document.getElementById('btn-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
                }
            });
        }

        // Screenshot
        const screenshotBtn = document.getElementById('btn-screenshot');
        if (screenshotBtn) {
            screenshotBtn.addEventListener('click', () => {
                if (typeof takeScreenshot === 'function') {
                    takeScreenshot();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    const link = document.createElement('a');
                    link.download = 'collider-screenshot.png';
                    link.href = Graph.renderer().domElement.toDataURL('image/png');
                    link.click();
                }
            });
        }

        // Toggle 2D
        const toggle2dBtn = document.getElementById('btn-2d');
        if (toggle2dBtn) {
            toggle2dBtn.addEventListener('click', () => {
                if (typeof toggle2DMode === 'function') toggle2DMode();
            });
        }

        // Freeze simulation
        const freezeBtn = document.getElementById('btn-freeze');
        if (freezeBtn) {
            freezeBtn.addEventListener('click', () => {
                if (typeof toggleFreeze === 'function') {
                    toggleFreeze();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    // Simple freeze toggle
                    const alpha = Graph.d3AlphaTarget();
                    Graph.d3AlphaTarget(alpha === 0 ? 0.3 : 0);
                    freezeBtn.classList.toggle('active', alpha !== 0);
                }
            });
        }
    }

    // =========================================================================
    // FILTER CHIPS
    // =========================================================================

    function populateFilterChips(data) {
        if (!data || !data.nodes) return;

        // Tiers
        const tiers = [...new Set(data.nodes.map(n => n.tier).filter(Boolean))].sort();
        _populateChipGroup('filter-tiers', tiers, 'tiers');

        // Rings
        const rings = [...new Set(data.nodes.map(n => n.ring).filter(Boolean))].sort();
        _populateChipGroup('filter-rings', rings, 'rings');

        // Edge types
        const edgeTypes = [...new Set(data.links?.map(e => e.type).filter(Boolean) || [])].sort();
        _populateChipGroup('filter-edges', edgeTypes, 'edges');
    }

    function _populateChipGroup(containerId, items, filterKey) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';
        items.forEach(item => {
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = item;
            chip.addEventListener('click', () => {
                const isActive = chip.classList.toggle('active');
                setFilter(filterKey, item, !isActive); // active = filtered OUT
                _scheduleRefresh();
            });
            container.appendChild(chip);
        });
    }

    function setFilter(dimension, value, visible) {
        if (typeof VIS_FILTERS === 'undefined') return;
        const set = VIS_FILTERS[dimension];
        if (!set) return;

        if (visible) {
            set.delete(value); // Remove from filter = show
        } else {
            set.add(value);    // Add to filter = hide
        }
    }

    // =========================================================================
    // HOVER PANEL
    // =========================================================================

    function showHoverPanel(node) {
        const panel = document.getElementById('hover-panel');
        if (!panel || !node) return;

        const setField = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value || '--';
        };

        setField('hover-name', node.name);
        setField('hover-kind', node.kind || node.type || 'unknown');
        setField('hover-atom', node.atom);
        setField('hover-family', node.family || (node.atom ? node.atom.split('.')[0] : null));
        setField('hover-ring', node.ring);
        setField('hover-tier', node.tier);
        setField('hover-role', node.role);

        const fileEl = document.getElementById('hover-file');
        if (fileEl) fileEl.textContent = node.file_path || node.file || '';

        panel.classList.add('visible');
    }

    function hideHoverPanel() {
        const panel = document.getElementById('hover-panel');
        if (panel) panel.classList.remove('visible');
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel(selectedNodes) {
        const panel = document.getElementById('selection-panel');
        const title = document.getElementById('selection-title');
        const list = document.getElementById('selection-list');
        const clearBtn = document.getElementById('selection-clear');

        if (!panel || !list) return;

        if (!selectedNodes || selectedNodes.length === 0) {
            panel.classList.remove('visible');
            return;
        }

        if (title) title.textContent = `SELECTED (${selectedNodes.length})`;

        list.innerHTML = selectedNodes.slice(0, 20).map(n =>
            `<div class="selection-item">${n.name || n.id}</div>`
        ).join('');

        if (selectedNodes.length > 20) {
            list.innerHTML += `<div class="selection-item" style="opacity:0.5">...and ${selectedNodes.length - 20} more</div>`;
        }

        panel.classList.add('visible');

        // Bind clear button
        if (clearBtn) {
            clearBtn.onclick = () => {
                if (typeof SELECT !== 'undefined') {
                    SELECT.clear();
                } else if (typeof clearSelection === 'function') {
                    clearSelection();
                }
                panel.classList.remove('visible');
            };
        }
    }

    // =========================================================================
    // STATS DISPLAY
    // =========================================================================

    function updateStats(nodes, edges, entropy) {
        const nodeEl = document.getElementById('stat-nodes');
        const edgeEl = document.getElementById('stat-edges');
        const entropyEl = document.getElementById('stat-entropy');

        if (nodeEl) nodeEl.textContent = nodes?.toLocaleString() || '0';
        if (edgeEl) edgeEl.textContent = edges?.toLocaleString() || '0';
        if (entropyEl) entropyEl.textContent = entropy?.toFixed(2) || '--';
    }

    // =========================================================================
    // HELPER: SLIDERS
    // =========================================================================

    function _bindSlider(id, callback) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);

        // Handle deprecated value span if it exists (for backward compat)
        const valSpan = document.getElementById(`${id}-val`);

        if (!slider) return;

        // Slider -> Number
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (numberInput) numberInput.value = val;
            if (valSpan) valSpan.textContent = val;
            callback(val);
        });

        // Number -> Slider
        if (numberInput) {
            numberInput.addEventListener('change', () => { // Change triggers on enter/blur
                let val = parseFloat(numberInput.value);

                // Clamp
                if (slider.min) val = Math.max(parseFloat(slider.min), val);
                if (slider.max) val = Math.min(parseFloat(slider.max), val);

                numberInput.value = val;
                slider.value = val;
                if (valSpan) valSpan.textContent = val;
                callback(val);
            });

            // Optional: Live update while typing? Maybe too heavy. Use change for now.
        }
    }

    function _setSliderValue(id, value) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);
        const valSpan = document.getElementById(`${id}-val`);

        if (slider) slider.value = value;
        if (numberInput) numberInput.value = value;
        if (valSpan) valSpan.textContent = value;
    }

    // =========================================================================
    // HELPER: TOGGLES
    // =========================================================================

    function _bindToggle(id, callback) {
        const toggle = document.getElementById(id);
        if (!toggle) {
            console.warn('[SIDEBAR] _bindToggle: element not found:', id);
            return;
        }

        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            callback(isActive);
        });
    }

    // =========================================================================
    // DEBOUNCED REFRESH
    // =========================================================================

    function _scheduleRefresh() {
        clearTimeout(_refreshTimer);
        _refreshTimer = setTimeout(() => {
            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof refreshGraph === 'function') {
                refreshGraph();
            }
        }, 16); // ~1 frame
    }

    // =========================================================================
    // SECTION RESIZING - Vertical drag handles
    // =========================================================================

    const SECTION_HEIGHT_KEY = 'viz_section_heights';
    let _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };

    function initSectionResize() {
        // Add resize handles to each section
        document.querySelectorAll('.section-content').forEach(content => {
            const sectionId = content.id;
            if (!sectionId) return;

            // Make content resizable
            content.classList.add('resizable');

            // Create resize handle
            const handle = document.createElement('div');
            handle.className = 'section-resize-handle';
            handle.dataset.section = sectionId;

            // Insert after section-content (before next section)
            const section = content.closest('.section');
            if (section && section.nextElementSibling) {
                section.parentNode.insertBefore(handle, section.nextElementSibling);
            }

            // Bind drag events
            handle.addEventListener('mousedown', _startResize);
        });

        // Global mouse events
        document.addEventListener('mousemove', _onResize);
        document.addEventListener('mouseup', _endResize);

        // Restore saved heights
        _restoreSectionHeights();

        console.log('[SIDEBAR] Section resize initialized');
    }

    function _startResize(e) {
        const sectionId = e.target.dataset.section;
        const content = document.getElementById(sectionId);
        if (!content) return;

        _resizeState = {
            active: true,
            section: content,
            startY: e.clientY,
            startHeight: content.offsetHeight
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }

    function _onResize(e) {
        if (!_resizeState.active || !_resizeState.section) return;

        const delta = e.clientY - _resizeState.startY;
        const newHeight = Math.max(60, Math.min(400, _resizeState.startHeight + delta));

        _resizeState.section.style.maxHeight = newHeight + 'px';
    }

    function _endResize() {
        if (!_resizeState.active) return;

        // Save height
        if (_resizeState.section) {
            _saveSectionHeight(_resizeState.section.id, _resizeState.section.style.maxHeight);
        }

        // Cleanup
        document.querySelectorAll('.section-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };
    }

    function _saveSectionHeight(sectionId, height) {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            heights[sectionId] = height;
            localStorage.setItem(SECTION_HEIGHT_KEY, JSON.stringify(heights));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save section height:', e);
        }
    }

    function _restoreSectionHeights() {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            Object.entries(heights).forEach(([sectionId, height]) => {
                const content = document.getElementById(sectionId);
                if (content && height) {
                    content.style.maxHeight = height;
                }
            });
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore section heights:', e);
        }
    }

    // =========================================================================
    // SIDEBAR RESIZING - Horizontal drag handles
    // =========================================================================

    const SIDEBAR_WIDTH_KEY = 'viz_sidebar_widths';
    let _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };

    function initSidebarResize() {
        const leftHandle = document.getElementById('left-resize-handle');
        const rightHandle = document.getElementById('right-resize-handle');

        if (leftHandle) {
            leftHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'left'));
        }
        if (rightHandle) {
            rightHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'right'));
        }

        // Global mouse events
        document.addEventListener('mousemove', _onSidebarResize);
        document.addEventListener('mouseup', _endSidebarResize);

        // Restore saved widths
        _restoreSidebarWidths();

        console.log('[SIDEBAR] Sidebar resize initialized');
    }

    function _startSidebarResize(e, side) {
        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        const currentWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(cssVar)) || 280;

        _sidebarResizeState = {
            active: true,
            side: side,
            startX: e.clientX,
            startWidth: currentWidth
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        e.preventDefault();
    }

    function _onSidebarResize(e) {
        if (!_sidebarResizeState.active) return;

        const { side, startX, startWidth } = _sidebarResizeState;
        const delta = side === 'left' ? (e.clientX - startX) : (startX - e.clientX);
        const minWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-sidebar-width')) || 200;
        const maxWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-sidebar-width')) || 400;
        const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + delta));

        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        document.documentElement.style.setProperty(cssVar, newWidth + 'px');

        // Update handle position
        const handle = document.getElementById(`${side}-resize-handle`);
        if (handle) {
            if (side === 'left') {
                handle.style.left = (newWidth - 3) + 'px';
            } else {
                handle.style.right = (newWidth - 3) + 'px';
            }
        }
    }

    function _endSidebarResize() {
        if (!_sidebarResizeState.active) return;

        // Save widths
        _saveSidebarWidths();

        // Cleanup
        document.querySelectorAll('.sidebar-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };
    }

    function _saveSidebarWidths() {
        try {
            const left = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width');
            const right = getComputedStyle(document.documentElement).getPropertyValue('--right-panel-width');
            localStorage.setItem(SIDEBAR_WIDTH_KEY, JSON.stringify({ left, right }));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save sidebar widths:', e);
        }
    }

    function _restoreSidebarWidths() {
        try {
            const widths = JSON.parse(localStorage.getItem(SIDEBAR_WIDTH_KEY) || '{}');
            if (widths.left) {
                document.documentElement.style.setProperty('--sidebar-width', widths.left);
                const leftHandle = document.getElementById('left-resize-handle');
                if (leftHandle) leftHandle.style.left = `calc(${widths.left} - 3px)`;
            }
            if (widths.right) {
                document.documentElement.style.setProperty('--right-panel-width', widths.right);
                const rightHandle = document.getElementById('right-resize-handle');
                if (rightHandle) rightHandle.style.right = `calc(${widths.right} - 3px)`;
            }
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore sidebar widths:', e);
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Initialization
        init,
        initSectionResize,
        initSidebarResize,

        // Color modes
        setColorMode,

        // Color Schemes (33 named gradients)
        applyColorScheme,
        clearColorScheme,
        renderSchemeNavigator,
        initSchemeNavigator,
        SCHEME_CONFIG,

        // Layouts
        setLayout,

        // Physics
        setPhysicsPreset,
        PHYSICS_PRESETS,

        // Filters
        populateFilterChips,
        setFilter,
        renderSmartSidebar, // Export for debug/manual re-render

        // Panels
        showHoverPanel,
        hideHoverPanel,
        updateSelectionPanel,

        // Stats
        updateStats,

        // View Mode (ATOMS/FILES toggle)
        initViewModeToggle,
        setViewMode,
        getViewMode,
        applyDeferredViewMode
    };
})();

// Backward compatibility - SidebarManager class is defined in app.js, not duplicated here
// The SIDEBAR module provides all functionality via SIDEBAR.* calls


// ═══ MODULE: modules/edge-system.js ═══
/**
 * EDGE SYSTEM MODULE
 *
 * Manages edge coloring, width, modes, and gradient effects.
 * Includes gradient palettes for tier, file, flow, depth, and semantic modes.
 *
 * Depends on: COLOR (for type-based colors), NODE (for tier lookups)
 *
 * Usage:
 *   EDGE.getColor(link)           // Get color for a link
 *   EDGE.getWidth(link)           // Get width for a link
 *   EDGE.setMode('gradient-tier') // Change edge mode
 *   EDGE.apply()                  // Apply current mode to graph
 */

const EDGE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODE_ORDER = [
        'gradient-tier',      // Source→Target tier flow (architecture layers)
        'gradient-file',      // File boundaries (module regions)
        'gradient-flow',      // Markov probability (hot paths)
        'gradient-depth',     // Call depth progression
        'gradient-semantic',  // Semantic distance (type similarity)
        'type',               // Classic type-based
        'weight',             // Weight intensity
        'mono'                // Minimal monochrome
    ];

    const MODE_LABELS = {
        'gradient-tier': '▼ TIER FLOW',
        'gradient-file': '▼ FILE REGIONS',
        'gradient-flow': '▼ HOT PATHS',
        'gradient-depth': '▼ CALL DEPTH',
        'gradient-semantic': '▼ SEMANTIC',
        type: 'EDGE: TYPE',
        weight: 'EDGE: WEIGHT',
        mono: 'EDGE: MONO'
    };

    const MODE_HINTS = {
        'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
        'gradient-file': 'Color by file region - shows module boundaries',
        'gradient-flow': 'Hot paths - markov probability gradient',
        'gradient-depth': 'Color by call chain depth',
        'gradient-semantic': 'Color by semantic similarity of endpoints',
        type: 'Edge color by type (calls, imports, etc.)',
        weight: 'Edge width & color by weight',
        mono: 'Minimal monochrome'
    };

    // Gradient color palettes for different modes
    const PALETTES = {
        tier: {
            // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
            T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
            T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
            T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
            UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
        },
        file: {
            // Rainbow hues distributed across files
            saturation: 65,
            lightness: 48
        },
        flow: {
            // Cold (low prob) to Hot (high prob)
            cold: { h: 220, s: 60, l: 45 },   // Blue
            warm: { h: 45, s: 85, l: 50 },    // Yellow
            hot: { h: 0, s: 90, l: 55 }       // Red
        },
        depth: {
            // Shallow (bright) to Deep (dark, saturated)
            shallow: { h: 180, s: 50, l: 65 },  // Light cyan
            mid: { h: 260, s: 70, l: 50 },      // Purple
            deep: { h: 320, s: 80, l: 40 }      // Magenta
        },
        semantic: {
            // Similar (harmonious) to Different (contrasting)
            similar: { h: 150, s: 60, l: 50 },    // Green - same type
            related: { h: 200, s: 65, l: 48 },    // Cyan - related
            different: { h: 340, s: 75, l: 50 }   // Pink - different
        }
    };

    const DEFAULT_OPACITY = 0.08;
    const MIN_WIDTH = 0.6;
    const MAX_WIDTH = 2.2;
    const BASE_WIDTH = 1.0;

    // =========================================================================
    // STATE
    // =========================================================================

    let _mode = 'gradient-file';  // Default mode
    let _ranges = { weight: { min: 1, max: 1 }, confidence: { min: 1, max: 1 } };
    let _nodeFileIndex = new Map();
    let _fileHueMap = new Map();
    let _config = {
        opacity: DEFAULT_OPACITY,
        dim: { interfile_factor: 0.25 }
    };

    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================

    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function interpolateHSL(hsl1, hsl2, t) {
        t = clamp01(t);
        // Handle hue interpolation (shortest path on color wheel)
        let h1 = hsl1.h, h2 = hsl2.h;
        let dh = h2 - h1;
        if (Math.abs(dh) > 180) {
            if (dh > 0) h1 += 360;
            else h2 += 360;
        }
        const h = (h1 + (h2 - h1) * t) % 360;
        const s = hsl1.s + (hsl2.s - hsl1.s) * t;
        const l = hsl1.l + (hsl2.l - hsl1.l) * t;
        return hslColor(h, s, l);
    }

    /**
     * Normalize a metric value to [0,1] range.
     * NOW DELEGATES TO UPB_SCALES when available.
     */
    function normalizeMetric(value, range, scaleName) {
        // If range is degenerate (all same values), return based on absolute value
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }

        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(
                scaleName || 'linear',
                value,
                range.min,
                range.max
            );
        }

        // Fallback: inline linear normalization
        return clamp01((value - range.min) / (range.max - range.min));
    }

    // =========================================================================
    // NODE HELPERS (use canonical versions from node-helpers.js via window.*)
    // =========================================================================

    function getLinkFileIdx(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.fileIdx ?? -1;
        }
        if (endpoint) {
            return _nodeFileIndex.get(endpoint) ?? -1;
        }
        return -1;
    }

    // =========================================================================
    // FILE HUE MAP
    // =========================================================================

    function buildFileHueMap() {
        _fileHueMap.clear();
        // Try DATA module first, then DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
                   (typeof DM !== 'undefined' ? DM : null);
        if (!dm || !dm.getFileBoundaries) return;

        const files = dm.getFileBoundaries();
        const goldenAngle = 137.508;  // Golden angle for good distribution
        files.forEach((file, idx) => {
            const hue = (idx * goldenAngle) % 360;
            _fileHueMap.set(idx, hue);
        });
    }

    // =========================================================================
    // RANGE UPDATES
    // =========================================================================

    function updateRanges() {
        const links = (typeof Graph !== 'undefined' && Graph?.graphData()?.links) || [];
        let minWeight = Infinity, maxWeight = -Infinity;
        let minConf = Infinity, maxConf = -Infinity;

        links.forEach(link => {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            minWeight = Math.min(minWeight, weight);
            maxWeight = Math.max(maxWeight, weight);
            minConf = Math.min(minConf, confidence);
            maxConf = Math.max(maxConf, confidence);
        });

        _ranges = {
            weight: {
                min: isFinite(minWeight) ? minWeight : 1,
                max: isFinite(maxWeight) ? maxWeight : 1
            },
            confidence: {
                min: isFinite(minConf) ? minConf : 1,
                max: isFinite(maxConf) ? maxConf : 1
            }
        };
    }

    function refreshNodeFileIndex() {
        _nodeFileIndex.clear();
        const nodes = (typeof Graph !== 'undefined' && Graph?.graphData()?.nodes) || [];
        nodes.forEach(node => {
            if (node && node.id) {
                _nodeFileIndex.set(node.id, node.fileIdx ?? -1);
            }
        });
    }

    // =========================================================================
    // GRADIENT EDGE COLOR
    // =========================================================================

    function getGradientColor(link, mode) {
        const srcNode = typeof link.source === 'object' ? link.source :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.source) : null);
        const tgtNode = typeof link.target === 'object' ? link.target :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.target) : null);

        if (mode === 'gradient-tier') {
            const srcTier = window.getNodeTierValue(srcNode);
            const tgtTier = window.getNodeTierValue(tgtNode);
            const avgTier = (srcTier + tgtTier) / 2;

            const palette = PALETTES.tier;
            let color;
            if (avgTier < 0.5) {
                color = interpolateHSL(palette.T0, palette.T1, avgTier * 2);
            } else if (avgTier < 1.5) {
                color = interpolateHSL(palette.T0, palette.T1, (avgTier - 0.5));
            } else {
                color = interpolateHSL(palette.T1, palette.T2, (avgTier - 1) / 2);
            }

            // Highlight tier transitions (edges crossing tiers)
            if (srcTier !== tgtTier) {
                return hslColor(
                    parseInt(color.slice(4)),
                    75,  // Higher saturation
                    55   // Brighter
                );
            }
            return color;
        }

        if (mode === 'gradient-file') {
            const srcFile = srcNode?.fileIdx ?? -1;
            const tgtFile = tgtNode?.fileIdx ?? -1;
            const palette = PALETTES.file;

            if (srcFile === tgtFile && srcFile >= 0) {
                const hue = _fileHueMap.get(srcFile) ?? (srcFile * 37 % 360);
                return hslColor(hue, palette.saturation, palette.lightness);
            } else {
                const srcHue = _fileHueMap.get(srcFile) ?? 0;
                const tgtHue = _fileHueMap.get(tgtFile) ?? 180;
                let midHue = (srcHue + tgtHue) / 2;
                if (Math.abs(srcHue - tgtHue) > 180) {
                    midHue = (midHue + 180) % 360;
                }
                return hslColor(midHue, palette.saturation * 0.6, palette.lightness * 1.1);
            }
        }

        if (mode === 'gradient-flow') {
            const mw = link.markov_weight ?? link.weight ?? 0;
            const palette = PALETTES.flow;

            if (mw < 0.3) {
                return interpolateHSL(palette.cold, palette.warm, mw / 0.3);
            } else if (mw < 0.7) {
                return interpolateHSL(palette.warm, palette.hot, (mw - 0.3) / 0.4);
            } else {
                return hslColor(palette.hot.h, palette.hot.s + 10, palette.hot.l + 10);
            }
        }

        if (mode === 'gradient-depth') {
            const srcDepth = window.getNodeDepth(srcNode);
            const tgtDepth = window.getNodeDepth(tgtNode);
            const avgDepth = (srcDepth + tgtDepth) / 2;
            const palette = PALETTES.depth;

            if (avgDepth < 0.33) {
                return interpolateHSL(palette.shallow, palette.mid, avgDepth * 3);
            } else if (avgDepth < 0.66) {
                return interpolateHSL(palette.mid, palette.deep, (avgDepth - 0.33) * 3);
            } else {
                return hslColor(palette.deep.h, palette.deep.s, palette.deep.l - 10);
            }
        }

        if (mode === 'gradient-semantic') {
            const similarity = window.getSemanticSimilarity(srcNode, tgtNode);
            const palette = PALETTES.semantic;

            if (similarity > 0.7) {
                return interpolateHSL(palette.related, palette.similar, (similarity - 0.7) / 0.3);
            } else if (similarity > 0.3) {
                return interpolateHSL(palette.different, palette.related, (similarity - 0.3) / 0.4);
            } else {
                return hslColor(palette.different.h, palette.different.s + 10, palette.different.l);
            }
        }

        return '#444444';
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(link) {
        // Gradient modes
        if (_mode.startsWith('gradient-')) {
            return getGradientColor(link, _mode);
        }

        const edgeKey = String(link.edge_type || link.type || 'unknown').toLowerCase();

        if (_mode === 'type') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', edgeKey) : '#666666';
        }

        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const t = normalizeMetric(weight, _ranges.weight);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('weight', t) : hslColor(30, 70, 50 + t * 30);
        }

        if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            const t = normalizeMetric(confidence, _ranges.confidence);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('confidence', t) : hslColor(200, 70, 50 + t * 30);
        }

        if (_mode === 'mono') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', 'unknown') : '#555555';
        }

        // Default: type-based coloring
        return typeof COLOR !== 'undefined' ?
            COLOR.get('edgeType', edgeKey) : '#666666';
    }

    // =========================================================================
    // EDGE WIDTH
    // =========================================================================

    function getWidth(link) {
        // For most modes, return uniform width for visual consistency
        if (_mode !== 'weight' && _mode !== 'confidence') {
            return BASE_WIDTH;
        }

        // Weight/confidence modes: subtle variation within tight bounds
        let t = 0.5;
        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            t = normalizeMetric(weight, _ranges.weight);
        } else if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            t = normalizeMetric(confidence, _ranges.confidence);
        }

        return MIN_WIDTH + (t * (MAX_WIDTH - MIN_WIDTH));
    }

    // =========================================================================
    // APPLY MODE TO GRAPH
    // =========================================================================

    function apply() {
        updateRanges();
        refreshNodeFileIndex();
        buildFileHueMap();

        if (typeof Graph === 'undefined' || !Graph) return;

        Graph.linkColor(link => {
            const color = getColor(link);
            return typeof toColorNumber === 'function' ?
                toColorNumber(color, 0x222222) : color;
        });

        Graph.linkOpacity(link => {
            const overrideOpacity = (typeof APPEARANCE_STATE !== 'undefined' &&
                typeof APPEARANCE_STATE.edgeOpacity === 'number')
                ? APPEARANCE_STATE.edgeOpacity
                : null;
            const baseOpacity = (overrideOpacity !== null)
                ? overrideOpacity
                : (link.opacity ?? DEFAULT_OPACITY);

            // File mode dimming
            const fileMode = typeof window !== 'undefined' && window.fileMode;
            const graphMode = typeof GRAPH_MODE !== 'undefined' ? GRAPH_MODE : 'atoms';
            if (fileMode && graphMode === 'atoms') {
                const srcIdx = getLinkFileIdx(link, 'source');
                const tgtIdx = getLinkFileIdx(link, 'target');
                if (srcIdx >= 0 && tgtIdx >= 0 && srcIdx !== tgtIdx) {
                    const dimFactor = _config.dim?.interfile_factor ?? 0.25;
                    return baseOpacity * dimFactor;
                }
            }
            return baseOpacity;
        });

        // Don't override width in flow mode
        const flowMode = typeof window !== 'undefined' && window.flowMode;
        if (!flowMode) {
            Graph.linkWidth(link => {
                const baseWidth = getWidth(link);
                // Respect APPEARANCE_STATE.edgeWidth multiplier if set
                const widthMultiplier = (typeof APPEARANCE_STATE !== 'undefined' &&
                    typeof APPEARANCE_STATE.edgeWidth === 'number')
                    ? APPEARANCE_STATE.edgeWidth
                    : 1;
                return Math.max(0.5, baseWidth * widthMultiplier);
            });
        }
    }

    // =========================================================================
    // MODE MANAGEMENT
    // =========================================================================

    function setMode(mode) {
        if (!MODE_ORDER.includes(mode)) return;
        _mode = mode;

        const button = document.getElementById('btn-edge-mode');
        if (button) {
            button.textContent = MODE_LABELS[_mode] || 'EDGE';
        }

        apply();

        // Update legend to reflect edge mode colors
        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        // Show mode toast hint
        if (typeof showModeToast === 'function') {
            showModeToast(MODE_HINTS[mode] || `Edge mode: ${mode}`);
        }
    }

    function cycleMode() {
        const currentIndex = MODE_ORDER.indexOf(_mode);
        const nextIndex = (currentIndex + 1) % MODE_ORDER.length;
        setMode(MODE_ORDER[nextIndex]);
    }

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getWidth,
        apply,

        // Mode management
        setMode,
        cycleMode,
        get mode() { return _mode; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Constants
        MODE_ORDER,
        MODE_LABELS,
        MODE_HINTS,
        PALETTES,

        // Internal access (for migration)
        get ranges() { return _ranges; },
        get nodeFileIndex() { return _nodeFileIndex; },
        get fileHueMap() { return _fileHueMap; },

        // Utility exports
        buildFileHueMap,
        updateRanges,
        refreshNodeFileIndex
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// These create getters/setters that sync with EDGE module state
Object.defineProperty(window, 'EDGE_MODE', {
    get: () => EDGE.mode,
    set: (v) => EDGE.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'EDGE_RANGES', {
    get: () => EDGE.ranges,
    configurable: true
});
Object.defineProperty(window, 'NODE_FILE_INDEX', {
    get: () => EDGE.nodeFileIndex,
    configurable: true
});
Object.defineProperty(window, 'FILE_HUE_MAP', {
    get: () => EDGE.fileHueMap,
    configurable: true
});
// Static constants - app.js owns these, not duplicated here
// EDGE_MODE_ORDER, EDGE_MODE_LABELS, EDGE_MODE_HINTS, GRADIENT_PALETTES - defined in app.js

function getEdgeColor(link) { return EDGE.getColor(link); }
function getEdgeWidth(link) { return EDGE.getWidth(link); }
function applyEdgeMode() { EDGE.apply(); }
function setEdgeMode(mode) { EDGE.setMode(mode); }
function cycleEdgeMode() { EDGE.cycleMode(); }
function updateEdgeRanges() { EDGE.updateRanges(); }
function refreshNodeFileIndex() { EDGE.refreshNodeFileIndex(); }
function buildFileHueMap() { EDGE.buildFileHueMap(); }
function getGradientEdgeColor(link, mode) { return EDGE.getColor(link); }


// ═══ MODULE: modules/file-viz.js ═══
/**
 * FILE VIZ MODULE
 *
 * Manages file visualization modes: color, hulls, cluster, map, spheres.
 * Handles file coloring, boundaries, mode switching, and FILE GRAPH.
 *
 * FILE GRAPH: Shows repository structure as first-class nodes where each
 * file becomes a hoverable, selectable node. This provides:
 * - Clear view of the repository file system
 * - Hover to see file details (atom count, path, metrics)
 * - Click to expand and see atoms within
 * - Edge weights show inter-file dependencies
 *
 * Depends on: DATA (for file boundaries), COLOR (for transforms)
 *
 * Pattern: IIFE with State Unification (see docs/specs/VISUALIZATION_UI_SPEC.md)
 *
 * Usage:
 *   FILE_VIZ.setMode('map')          // Switch to file-nodes view
 *   FILE_VIZ.toggle()                // Toggle file mode on/off
 *   FILE_VIZ.getColor(idx, total)    // Get color for a file
 *   FILE_VIZ.buildFileGraph()        // Build file-level graph
 *   FILE_VIZ.apply()                 // Apply current mode
 */

const FILE_VIZ = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODES = ['color', 'hulls', 'cluster', 'map', 'spheres'];

    const MODE_HINTS = {
        color: 'Files colored by hue - each file gets unique color',
        hulls: 'Boundary hulls around file clusters',
        cluster: 'Force clustering groups files together',
        map: 'FILE NODES view - see repository structure as nodes! Click to expand.',
        spheres: 'Containment spheres with collision physics'
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _enabled = false;
    let _mode = 'color';
    let _config = {
        strategy: 'golden-angle',
        angle: 137.5,
        chroma: null,
        saturation: 70,
        lightness: 50
    };
    let _boundaryMeshes = [];
    let _hullRedrawTimer = null;
    let _hullRedrawAttempts = 0;

    // FILE GRAPH STATE - for file-as-nodes visualization
    let _fileGraph = null;          // { nodes: [], links: [] } for file-level view
    let _fileNodeIds = new Map();   // fileIdx -> nodeId mapping
    let _fileNodePositions = new Map(); // Preserve positions across mode switches
    let _expandedFiles = new Set(); // Files expanded to show atoms
    let _graphMode = 'atoms';       // atoms | files | hybrid
    let _expandMode = 'inline';     // inline | detach
    let _activeMapping = 'format';  // Current visual mapping mode

    // =========================================================================
    // VISUAL MAPPING SYSTEM - Map metadata to visual properties
    // =========================================================================

    /**
     * Visual dimension mappings - connect file metadata to visual properties.
     * Each mapping defines: source metadata field → visual property + scale
     */
    const VISUAL_MAPPINGS = {
        // Size-based mappings
        size_bytes: {
            property: 'nodeSize',
            scale: 'sqrt',
            min: 2,
            max: 20,
            label: 'File Size (bytes)'
        },
        token_estimate: {
            property: 'nodeSize',
            scale: 'log',
            min: 2,
            max: 18,
            label: 'Token Count'
        },
        line_count: {
            property: 'nodeSize',
            scale: 'sqrt',
            min: 2,
            max: 15,
            label: 'Line Count'
        },

        // Time-based mappings
        age_days: {
            property: 'opacity',
            scale: 'linear',
            invert: true,  // Older = more faded
            min: 0.3,
            max: 1.0,
            label: 'File Age'
        },

        // Categorical mappings (discrete colors)
        format_category: {
            property: 'hue',
            discrete: true,
            values: {
                code: 210,  // Blue - primary code
                config: 45,   // Orange - configuration
                doc: 120,  // Green - documentation
                data: 280,  // Purple - data files
                test: 340,  // Pink - test files
                style: 180,  // Cyan - stylesheets
                script: 30,   // Yellow-Orange - scripts
                build: 0,    // Red - build files
                other: 0     // Gray (handled by saturation)
            },
            label: 'File Format'
        },
        purpose: {
            property: 'hue',
            discrete: true,
            values: {
                test: 340,  // Pink
                config: 45,   // Orange
                model: 260,  // Purple
                service: 210,  // Blue
                controller: 180,  // Cyan
                utility: 90,   // Yellow-Green
                interface: 300,  // Magenta
                data: 30,   // Orange-Yellow
                general: 200   // Light Blue
            },
            label: 'File Purpose'
        },

        // Complexity mappings
        complexity_density: {
            property: 'saturation',
            scale: 'linear',
            min: 30,
            max: 90,
            label: 'Complexity'
        },
        cohesion: {
            property: 'lightness',
            scale: 'linear',
            min: 35,
            max: 65,
            label: 'Cohesion'
        },

        // Git mappings (if available)
        git_commits: {
            property: 'pulse',  // Animation intensity
            scale: 'log',
            min: 0,
            max: 1,
            label: 'Git Commits'
        }
    };

    /**
     * Apply a visual mapping to file nodes.
     * NOW DELEGATES TO UPB (Universal Property Binder)
     *
     * @param {string} mappingKey - Key from VISUAL_MAPPINGS (source property)
     * @param {Array} fileNodes - Array of file node objects
     */
    function applyVisualMapping(mappingKey, fileNodes) {
        const mapping = VISUAL_MAPPINGS[mappingKey];
        if (!mapping) {
            console.warn(`[FILE_VIZ] Unknown mapping: ${mappingKey}`);
            return;
        }

        _activeMapping = mappingKey;

        // Get data range for normalization
        const values = fileNodes.map(n => n[mappingKey]).filter(v => v !== undefined && v !== null);
        if (values.length === 0) {
            console.warn(`[FILE_VIZ] No data for mapping: ${mappingKey}`);
            return;
        }

        const dataMin = Math.min(...values);
        const dataMax = Math.max(...values);

        // === UPB INTEGRATION ===
        // Use UPB for scaling if available, with graceful fallback
        const useUPB = window.UPB && window.UPB_SCALES;

        fileNodes.forEach(node => {
            const rawValue = node[mappingKey];
            if (rawValue === undefined || rawValue === null) return;

            if (mapping.discrete) {
                // Categorical mapping - direct value lookup
                const discreteValue = mapping.values[rawValue] ?? mapping.values['other'] ?? 0;
                _applyVisualProperty(node, mapping.property, discreteValue);
            } else {
                // Continuous mapping - use UPB_SCALES
                let normalized;
                if (useUPB) {
                    // Delegate to UPB_SCALES
                    normalized = window.UPB_SCALES.applyScale(
                        mapping.scale || 'linear',
                        rawValue,
                        dataMin,
                        dataMax
                    );
                } else {
                    // Fallback to inline (for when UPB not loaded)
                    normalized = _normalizeValueFallback(rawValue, dataMin, dataMax, mapping.scale);
                }

                if (mapping.invert) normalized = 1 - normalized;

                const visualMin = mapping.min ?? 0;
                const visualMax = mapping.max ?? 1;
                const visualValue = visualMin + normalized * (visualMax - visualMin);

                _applyVisualProperty(node, mapping.property, visualValue);
            }
        });

        console.log(`[FILE_VIZ] Applied mapping: ${mappingKey} (${mapping.label})${useUPB ? ' [via UPB]' : ''}`);
    }

    /**
     * FALLBACK scale normalization - used when UPB_SCALES not available.
     * @deprecated Prefer UPB_SCALES.applyScale() when UPB is loaded.
     */
    function _normalizeValueFallback(value, min, max, scale) {
        if (max === min) return 0.5;

        let normalized;
        switch (scale) {
            case 'log':
                const logMin = Math.log10(Math.max(1, min));
                const logMax = Math.log10(Math.max(1, max));
                const logVal = Math.log10(Math.max(1, value));
                normalized = (logVal - logMin) / (logMax - logMin);
                break;
            case 'sqrt':
                const sqrtMin = Math.sqrt(min);
                const sqrtMax = Math.sqrt(max);
                const sqrtVal = Math.sqrt(value);
                normalized = (sqrtVal - sqrtMin) / (sqrtMax - sqrtMin);
                break;
            default: // linear
                normalized = (value - min) / (max - min);
        }
        return Math.max(0, Math.min(1, normalized));
    }

    function _applyVisualProperty(node, property, value) {
        switch (property) {
            case 'nodeSize':
                node.val = value;
                break;
            case 'hue':
                // Rebuild color with new hue
                const sat = _config.saturation ?? 70;
                const light = _config.lightness ?? 50;
                node.color = hslColor(value, sat, light);
                break;
            case 'saturation':
                // Would need to parse existing color - simplified approach
                node._saturation = value;
                break;
            case 'lightness':
                node._lightness = value;
                break;
            case 'opacity':
                node._opacity = value;
                break;
            case 'pulse':
                node._pulseIntensity = value;
                break;
        }
    }

    /**
     * Get color for file based on active mapping or default
     */
    function getColorForMapping(node) {
        const mapping = VISUAL_MAPPINGS[_activeMapping];
        if (!mapping || mapping.property !== 'hue') {
            // Use default golden angle coloring
            return getColor(node.fileIdx, 100, node.file_name);
        }

        const rawValue = node[_activeMapping];
        if (rawValue === undefined || !mapping.discrete) {
            return getColor(node.fileIdx, 100, node.file_name);
        }

        const hue = mapping.values[rawValue] ?? 200;
        const sat = node._saturation ?? (_config.saturation ?? 70);
        const light = node._lightness ?? (_config.lightness ?? 50);
        return hslColor(hue, sat, light);
    }

    // =========================================================================
    // COLOR UTILITIES
    // =========================================================================

    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function hashToUnit(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash;
        }
        return Math.abs(hash % 1000) / 1000;
    }

    function getHue(fileIdx, totalFiles, fileName) {
        const strategy = _config.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return hashToUnit(seed) * 360;
        }
        const angle = _config.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const saturation = _config.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (_config.lightness ?? 50);
        const hue = getHue(fileIdx, totalFiles, fileName);

        // Apply color tweaks if available
        const tweaks = typeof COLOR_TWEAKS !== 'undefined' ? COLOR_TWEAKS : {};

        if (typeof _config.chroma === 'number' && typeof oklchColor === 'function') {
            return oklchColor(lightness, _config.chroma, hue);
        }

        const adjustedHue = hue + (tweaks.hueShift || 0);
        const adjustedLightness = clampValue(lightness + (tweaks.lightnessShift || 0), 0, 100);
        return hslColor(adjustedHue, saturation, adjustedLightness);
    }

    // =========================================================================
    // APPLY COLORS TO NODES
    // =========================================================================

    function applyColors(graphNodes) {
        // Get file boundaries from DATA module or DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        const boundaries = dm?.getFileBoundaries ? dm.getFileBoundaries() : [];
        const totalFiles = boundaries.length;

        graphNodes.forEach(node => {
            if (node.fileIdx >= 0) {
                const fileInfo = boundaries[node.fileIdx] || {};
                const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                node.color = getColor(node.fileIdx, totalFiles, fileLabel);
            }
        });

        if (typeof Graph !== 'undefined' && Graph) {
            Graph.nodeColor(n => {
                return typeof toColorNumber === 'function' ?
                    toColorNumber(n.color, 0x888888) : n.color;
            });
        }
    }

    // =========================================================================
    // FILE GRAPH BUILDING - Repository as Nodes
    // =========================================================================

    /**
     * Build a file-level graph where each file is a node.
     * This creates a clear view of repository structure with:
     * - File nodes sized by atom count
     * - Edges weighted by inter-file dependencies
     * - Colors by file index (golden angle distribution)
     */
    function buildFileGraph() {
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        const boundaries = dm?.getFileBoundaries ? dm.getFileBoundaries() : [];
        const nodes = dm?.getNodes ? dm.getNodes() : [];
        const links = dm?.getLinks ? dm.getLinks() : [];

        // Get current atom positions from Graph for centroid calculation
        const currentGraphNodes = (typeof Graph !== 'undefined' && Graph)
            ? (Graph.graphData()?.nodes || [])
            : [];
        const atomPositions = new Map();
        currentGraphNodes.forEach(n => {
            if (n && n.id && Number.isFinite(n.x) && Number.isFinite(n.y)) {
                atomPositions.set(n.id, { x: n.x, y: n.y, z: n.z || 0 });
            }
        });

        const totalFiles = boundaries.length;
        const fileNodes = [];
        _fileNodeIds.clear();
        const nodeFileIdx = new Map();

        // Build node -> fileIdx mapping
        nodes.forEach(n => {
            if (n && n.id) {
                nodeFileIdx.set(n.id, n.fileIdx ?? -1);
            }
        });

        // Build file -> atoms mapping for centroid calculation
        const fileAtoms = new Map(); // fileIdx -> [atom positions]
        nodes.forEach(n => {
            if (n && n.id && n.fileIdx !== undefined && n.fileIdx >= 0) {
                const pos = atomPositions.get(n.id);
                if (pos) {
                    if (!fileAtoms.has(n.fileIdx)) fileAtoms.set(n.fileIdx, []);
                    fileAtoms.get(n.fileIdx).push(pos);
                }
            }
        });

        // Create file nodes with centroid positions
        boundaries.forEach((boundary, idx) => {
            const label = boundary.file_name || boundary.file || `file-${idx}`;
            const atomCount = boundary.atom_count || 1;
            const nodeId = `file:${idx}`;
            _fileNodeIds.set(idx, nodeId);

            // Calculate centroid from atom positions (SMOOTH TRANSITION)
            const atoms = fileAtoms.get(idx) || [];
            let cx = 0, cy = 0, cz = 0;
            if (atoms.length > 0) {
                atoms.forEach(p => { cx += p.x; cy += p.y; cz += p.z; });
                cx /= atoms.length;
                cy /= atoms.length;
                cz /= atoms.length;
            } else {
                // Fallback: radial layout for files with no positioned atoms
                const angle = (idx / totalFiles) * Math.PI * 2;
                const radius = 200;
                cx = Math.cos(angle) * radius;
                cy = Math.sin(angle) * radius;
                cz = (Math.random() - 0.5) * 50;
            }

            fileNodes.push({
                id: nodeId,
                name: label,
                fileIdx: idx,
                isFileNode: true,
                // POSITION: Initialize at centroid of atoms for smooth transition
                x: cx, y: cy, z: cz,
                fx: undefined, fy: undefined, fz: undefined, // Allow physics to relax
                val: Math.max(2, Math.sqrt(atomCount) * 1.5), // Size by atom count
                color: getColor(idx, totalFiles, label),
                file_path: boundary.file || '',
                atom_count: atomCount,
                // Enriched file metadata for hover panel and visual mappings
                tier: boundary.tier || 'UNKNOWN',
                ring: boundary.ring || 'UNKNOWN',
                internal_edges: boundary.internal_edges || 0,
                external_edges: boundary.external_edges || 0,
                // Physical metadata
                size_bytes: boundary.size_bytes ?? 0,
                size_kb: boundary.size_kb ?? 0,
                token_estimate: boundary.token_estimate ?? 0,
                line_count: boundary.line_count ?? 0,
                code_lines: boundary.code_lines ?? 0,
                // Temporal metadata
                age_days: boundary.age_days ?? 0,
                modified_date: boundary.modified_date || '',
                is_stale: boundary.is_stale ?? false,
                is_recent: boundary.is_recent ?? false,
                // Categorical metadata
                format_category: boundary.format_category || 'other',
                purpose: boundary.purpose || 'general',
                extension: boundary.extension || '',
                is_test: boundary.is_test ?? false,
                is_config: boundary.is_config ?? false,
                // Complexity metadata
                complexity_density: boundary.complexity_density ?? 0,
                cohesion: boundary.cohesion ?? 0.5,
                code_ratio: boundary.code_ratio ?? 0.5
            });
        });

        // Build inter-file edges with weights
        const edgeMap = new Map();
        links.forEach(link => {
            const srcId = _getLinkEndpointId(link, 'source');
            const tgtId = _getLinkEndpointId(link, 'target');
            const srcIdx = nodeFileIdx.get(srcId) ?? -1;
            const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;

            // Skip internal edges and invalid indices
            if (srcIdx < 0 || tgtIdx < 0 || srcIdx === tgtIdx) return;

            const key = `${srcIdx}->${tgtIdx}`;
            const existing = edgeMap.get(key) || {
                source: _fileNodeIds.get(srcIdx),
                target: _fileNodeIds.get(tgtIdx),
                weight: 0,
                edge_type: 'file-dependency',
                resolution: 'file'
            };
            existing.weight += 1;
            edgeMap.set(key, existing);
        });

        _fileGraph = {
            nodes: fileNodes,
            links: Array.from(edgeMap.values())
        };

        console.log(`[FILE_VIZ] Built file graph: ${fileNodes.length} files, ${edgeMap.size} inter-file edges`);
        return _fileGraph;
    }

    function _getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (!endpoint) return null;
        if (typeof endpoint === 'object') return endpoint.id;
        return endpoint;
    }

    /**
     * Save current file node positions for smooth transitions
     */
    function captureFileNodePositions() {
        _fileNodePositions.clear();
        if (typeof Graph === 'undefined' || !Graph) return;

        const nodes = Graph.graphData()?.nodes || [];
        nodes.forEach(node => {
            if (node && node.isFileNode && Number.isFinite(node.x) && Number.isFinite(node.y)) {
                _fileNodePositions.set(node.fileIdx, {
                    x: node.x,
                    y: node.y,
                    z: Number.isFinite(node.z) ? node.z : 0
                });
            }
        });
    }

    /**
     * Restore saved positions to file nodes
     */
    function restoreFileNodePositions(nodes) {
        nodes.forEach(node => {
            if (node.isFileNode && _fileNodePositions.has(node.fileIdx)) {
                const pos = _fileNodePositions.get(node.fileIdx);
                node.x = pos.x;
                node.y = pos.y;
                node.z = pos.z;
            }
        });
    }

    /**
     * Get file target position for radial layout
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpread) {
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: (Math.random() - 0.5) * zSpread
        };
    }

    /**
     * Expand a file to show its atoms
     */
    function expandFile(fileIdx) {
        _expandedFiles.add(fileIdx);
        _graphMode = 'hybrid';
        if (typeof refreshGraph === 'function') refreshGraph();
    }

    /**
     * Collapse a file to hide its atoms
     */
    function collapseFile(fileIdx) {
        _expandedFiles.delete(fileIdx);
        _graphMode = _expandedFiles.size > 0 ? 'hybrid' : 'files';
        if (typeof refreshGraph === 'function') refreshGraph();
    }

    /**
     * Toggle file expansion
     */
    function toggleFileExpansion(fileIdx) {
        if (_expandedFiles.has(fileIdx)) {
            collapseFile(fileIdx);
        } else {
            expandFile(fileIdx);
        }
    }

    /**
     * Apply the file graph to the visualization
     */
    function applyFileGraphMode() {
        if (!_fileGraph) {
            buildFileGraph();
        }
        if (!_fileGraph || typeof Graph === 'undefined' || !Graph) return;

        restoreFileNodePositions(_fileGraph.nodes);
        Graph.graphData(_fileGraph);
        applyColors(_fileGraph.nodes);

        // UPB Hook: Re-apply any active bindings to the new file nodes
        if (window.UPB && typeof window.UPB.apply === 'function') {
            // CRITICAL FIX: Recalculate ranges for FILE nodes because they track
            // much larger values (e.g. Total Tokens) than individual Atoms.
            // Without this, everything gets clamped to 1.0 (Max Size/Color).
            if (window.UPB.BINDINGS && window.UPB.BINDINGS.defaultGraph) {
                const activeBindings = window.UPB.BINDINGS.defaultGraph._bindings;
                const newRanges = {};

                Object.keys(activeBindings).forEach(targetKey => {
                    const bindings = activeBindings[targetKey];
                    bindings.forEach(b => {
                        const sourceKey = b.source;
                        // Extract values from file nodes for this source
                        const values = _fileGraph.nodes
                            .map(n => n[sourceKey])
                            .filter(v => typeof v === 'number');

                        if (values.length > 0) {
                            newRanges[sourceKey] = {
                                min: Math.min(...values),
                                max: Math.max(...values)
                            };
                        }
                    });
                });

                // Update graph ranges for this context
                window.UPB.init(newRanges);
            }

            const updates = window.UPB.apply(_fileGraph.nodes);

            // Apply updates to nodes
            updates.forEach(update => {
                const node = _fileGraph.nodes.find(n => n.id === update.id);
                if (node && update.visuals) {
                    Object.keys(update.visuals).forEach(key => {
                        if (typeof CONTROL_BAR !== 'undefined' && CONTROL_BAR.applyToNode) {
                            CONTROL_BAR.applyToNode(node, key, update.visuals[key]);
                        }
                    });
                }
            });
        }

        // Reheat simulation for nice spread
        Graph.d3ReheatSimulation();

        if (typeof showToast === 'function') {
            showToast(`File view: ${_fileGraph.nodes.length} files. Click to expand atoms.`);
        }
    }

    // =========================================================================
    // BOUNDARY MANAGEMENT
    // =========================================================================

    function clearBoundaries() {
        if (typeof Graph === 'undefined' || !Graph) return;
        const scene = Graph.scene();
        if (!scene) return;

        _boundaryMeshes.forEach(mesh => scene.remove(mesh));
        _boundaryMeshes = [];
    }

    function scheduleHullRedraw(delayMs = 1200) {
        if (_hullRedrawTimer) {
            clearTimeout(_hullRedrawTimer);
        }
        _hullRedrawTimer = setTimeout(() => {
            if (!(_enabled && _mode === 'hulls')) {
                _hullRedrawAttempts = 0;
                return;
            }

            // Call external drawFileBoundaries if available
            if (typeof drawFileBoundaries === 'function') {
                const drawn = drawFileBoundaries(null);
                if (drawn === 0 && _hullRedrawAttempts < 3) {
                    _hullRedrawAttempts += 1;
                    scheduleHullRedraw(1000);
                }
            }
        }, delayMs);
    }

    // =========================================================================
    // MODE CLEARING
    // =========================================================================

    function clearAllModes() {
        clearBoundaries();

        // Reset file cohesion force if active
        if (typeof clearFileCohesion === 'function') {
            clearFileCohesion();
        }

        // Reset cluster force if active
        if (typeof clusterForceActive !== 'undefined' && clusterForceActive &&
            typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('cluster', null);
            if (typeof DEFAULT_LINK_DISTANCE !== 'undefined' && DEFAULT_LINK_DISTANCE !== null) {
                Graph.d3Force('link').distance(DEFAULT_LINK_DISTANCE);
            }
            Graph.d3ReheatSimulation();
        }

        // Stop containment animation if active
        if (typeof stopContainmentAnimation === 'function') {
            stopContainmentAnimation();
        }

        // Clear containment spheres
        if (typeof FILE_CONTAINMENT !== 'undefined' && FILE_CONTAINMENT?.spheres) {
            const scene = typeof Graph !== 'undefined' ? Graph?.scene() : null;
            if (scene) {
                FILE_CONTAINMENT.spheres.forEach(s => {
                    if (s.mesh) scene.remove(s.mesh);
                });
            }
            FILE_CONTAINMENT.spheres = [];
            FILE_CONTAINMENT.boundariesPopped = false;
        }

        // Clear lingering filters
        if (typeof VIS_FILTERS !== 'undefined') {
            const filterSets = ['rings', 'tiers', 'families', 'files', 'roles', 'edges', 'layers', 'effects', 'edgeFamilies'];
            filterSets.forEach(key => {
                if (VIS_FILTERS[key]?.clear) VIS_FILTERS[key].clear();
            });
            document.querySelectorAll('.filter-chip.active').forEach(c => c.classList.remove('active'));
        }

        // Reset POP button state
        const popBtn = document.getElementById('btn-file-pop');
        if (popBtn) {
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
        }
    }

    // =========================================================================
    // SET FILE MODE STATE
    // =========================================================================

    function setEnabled(enabled) {
        _enabled = enabled;

        // Update UI buttons
        const cmdBtn = document.getElementById('cmd-files');
        if (cmdBtn) cmdBtn.classList.toggle('active', _enabled);
        const dockBtn = document.getElementById('btn-files');
        if (dockBtn) dockBtn.classList.toggle('active', _enabled);

        // Update panels
        const filePanel = document.getElementById('file-panel');
        const modeControls = document.getElementById('file-mode-controls');
        const expandControls = document.getElementById('file-expand-controls');

        if (_enabled) {
            if (filePanel) filePanel.classList.add('visible');
            if (modeControls) modeControls.classList.add('visible');
            if (expandControls) expandControls.classList.toggle('visible', _mode === 'map');
            apply();
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            // Use unified LAYOUT module for reflow
            if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
        } else {
            if (filePanel) filePanel.classList.remove('visible');
            if (modeControls) modeControls.classList.remove('visible');
            if (expandControls) expandControls.classList.remove('visible');

            // Clear expanded files
            if (typeof EXPANDED_FILES !== 'undefined') EXPANDED_FILES.clear();
            if (typeof GRAPH_MODE !== 'undefined') window.GRAPH_MODE = 'atoms';

            // Use unified LAYOUT module for reflow
            if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();

            clearAllModes();
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            if (typeof refreshGraph === 'function') refreshGraph();
        }
    }

    function toggle() {
        setEnabled(!_enabled);
    }

    // =========================================================================
    // SET VIZ MODE
    // =========================================================================

    function setMode(mode) {
        if (!MODES.includes(mode)) return;
        _mode = mode;

        // Update button states
        document.querySelectorAll('.file-mode-btn').forEach(btn => btn.classList.remove('active'));
        const modeBtn = document.getElementById('btn-file-' + mode);
        if (modeBtn) modeBtn.classList.add('active');

        // Toggle expand controls visibility
        const expandControls = document.getElementById('file-expand-controls');
        if (expandControls) expandControls.classList.toggle('visible', _mode === 'map');
        if (_mode === 'map' && typeof updateExpandButtons === 'function') {
            updateExpandButtons();
        }

        // Update graph mode
        if (_mode === 'map') {
            const hasExpanded = typeof EXPANDED_FILES !== 'undefined' && EXPANDED_FILES.size > 0;
            if (typeof GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = hasExpanded ? 'hybrid' : 'files';
            }
        } else {
            if (typeof EXPANDED_FILES !== 'undefined') EXPANDED_FILES.clear();
            if (typeof GRAPH_MODE !== 'undefined') window.GRAPH_MODE = 'atoms';
        }

        // Apply mode
        if (!_enabled) {
            setEnabled(true);
        } else if (_mode === 'map') {
            apply();
        } else {
            if (typeof refreshGraph === 'function') refreshGraph();
        }
    }

    // =========================================================================
    // APPLY CURRENT MODE
    // =========================================================================

    function apply() {
        if (!_enabled) return;

        // Clear previous state
        clearBoundaries();
        if (_mode !== 'hulls') {
            _hullRedrawAttempts = 0;
        }

        // Get graph nodes
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        const graphNodes = dm?.getVisibleNodes ?
            dm.getVisibleNodes() :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes || [] : []);

        // Apply file cohesion for color/hulls/cluster modes
        if (_mode === 'color' || _mode === 'hulls' || _mode === 'cluster') {
            if (typeof applyFileCohesion === 'function' && dm?.raw) {
                const physicsPayload = { physics: dm.raw.physics, config: dm.raw.config };
                applyFileCohesion(physicsPayload);
            }
        }

        if (_mode === 'color') {
            applyColors(graphNodes);
        }
        else if (_mode === 'hulls') {
            applyColors(graphNodes);
            scheduleHullRedraw(1500);
        }
        else if (_mode === 'cluster') {
            applyColors(graphNodes);
            if (typeof applyClusterForce === 'function' && dm?.raw) {
                applyClusterForce(dm.raw);
            }
        }
        else if (_mode === 'map') {
            const hasExpanded = typeof EXPANDED_FILES !== 'undefined' && EXPANDED_FILES.size > 0;
            if (typeof GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = hasExpanded ? 'hybrid' : 'files';
            }
            if (typeof refreshGraph === 'function') refreshGraph();
            if (typeof showToast === 'function') {
                showToast('File map active. Click a file node to expand.');
            }
        }
        else if (_mode === 'spheres') {
            applyColors(graphNodes);
            if (typeof buildDirectoryTree === 'function' && dm?.raw) {
                buildDirectoryTree(dm.raw);
            }
            if (typeof computeFileActivity === 'function' && dm?.raw) {
                computeFileActivity(dm.raw, graphNodes);
            }
            if (typeof drawContainmentSpheres === 'function' && dm?.raw) {
                drawContainmentSpheres(dm.raw, graphNodes);
            }
            if (typeof startContainmentAnimation === 'function') {
                startContainmentAnimation();
            }
            if (typeof showToast === 'function') {
                showToast('Containment spheres active. Files as force fields. Click POP! to release.');
            }
        }
    }

    // =========================================================================
    // FILE CLUSTERING FORCES - D3 force manipulation for file grouping
    // =========================================================================

    let _clusterForceActive = false;
    let _fileCohesionActive = false;

    /**
     * Apply cluster force to group nodes by file
     * Creates fixed target positions arranged in a circular pattern
     */
    function applyClusterForce(data) {
        const Graph = window.Graph;
        const DM = window.DM;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const IS_3D = window.IS_3D;

        const clusterConfig = data?.physics?.cluster || {};
        const modeStrength = (typeof clusterConfig.modes?.strong === 'number') ? clusterConfig.modes.strong : null;
        const sliderStrength = (typeof APPEARANCE_STATE?.clusterStrength === 'number') ? APPEARANCE_STATE.clusterStrength : null;
        const clusterStrength = (typeof sliderStrength === 'number')
            ? sliderStrength
            : ((typeof modeStrength === 'number')
                ? modeStrength
                : ((typeof clusterConfig.strength === 'number') ? clusterConfig.strength : 0.3));
        const clusterRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius : 150;
        const clusterZSpacing = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing : 30;
        const linkDistance = (typeof clusterConfig.linkDistance === 'number')
            ? clusterConfig.linkDistance
            : (data?.physics?.forces?.link?.distance || 50);

        const graphNodes = DM ? DM.getVisibleNodes() : (Graph?.graphData()?.nodes || []);
        const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
        const numFiles = boundaries.length;

        // Fixed target positions: arrange files in circular pattern
        const fileTargets = {};
        for (let i = 0; i < numFiles; i++) {
            fileTargets[i] = getFileTarget(i, numFiles, clusterRadius, clusterZSpacing);
        }

        // Reduce link distance to keep intra-file nodes tighter
        Graph.d3Force('link').distance(linkDistance);

        // Apply strong clustering force toward fixed targets
        Graph.d3Force('cluster', (alpha) => {
            const k = alpha * clusterStrength;
            graphNodes.forEach(node => {
                const target = fileTargets[node.fileIdx];
                if (target) {
                    node.vx = (node.vx || 0) + (target.x - node.x) * k;
                    node.vy = (node.vy || 0) + (target.y - node.y) * k;
                    if (IS_3D) {
                        node.vz = (node.vz || 0) + (target.z - node.z) * k;
                    }
                }
            });
        });

        _clusterForceActive = true;
        Graph.d3ReheatSimulation();
        scheduleHullRedraw(1500);
    }

    /**
     * Apply file cohesion force - nodes in same file attract each other
     * Also stretches inter-file links for better separation
     */
    function applyFileCohesion(data) {
        if (_fileCohesionActive) return;

        const Graph = window.Graph;
        const DM = window.DM;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const IS_3D = window.IS_3D;
        const DEFAULT_LINK_DISTANCE = window.DEFAULT_LINK_DISTANCE || 50;

        const config = data?.physics?.fileCohesion || {};
        const strength = (typeof APPEARANCE_STATE?.fileCohesionStrength === 'number')
            ? APPEARANCE_STATE.fileCohesionStrength
            : (config.strength ?? 0.15);
        const linkMult = config.interFileLinkMultiplier ?? 2.5;
        const minDist = config.minDistance ?? 20;

        const nodes = DM ? DM.getVisibleNodes() : (Graph?.graphData()?.nodes || []);
        if (!nodes.length) return;

        // Pre-compute file groups
        const groups = new Map();
        nodes.forEach(n => {
            const f = n.fileIdx ?? -1;
            if (f >= 0) (groups.get(f) || groups.set(f, []).get(f)).push(n);
        });

        // Intra-file centroid attraction
        Graph.d3Force('fileCohesion', (alpha) => {
            const k = strength * alpha;
            groups.forEach(g => {
                if (g.length < 2) return;
                let cx = 0, cy = 0, cz = 0;
                g.forEach(n => { cx += n.x || 0; cy += n.y || 0; cz += n.z || 0; });
                cx /= g.length; cy /= g.length; cz /= g.length;
                g.forEach(n => {
                    const dx = cx - (n.x || 0), dy = cy - (n.y || 0), dz = cz - (n.z || 0);
                    const d = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;
                    if (d > minDist) {
                        const f = k * Math.min(1, d / 100);
                        n.vx = (n.vx || 0) + dx * f;
                        n.vy = (n.vy || 0) + dy * f;
                        if (IS_3D) n.vz = (n.vz || 0) + dz * f;
                    }
                });
            });
        });

        // Inter-file links stretched
        const base = DEFAULT_LINK_DISTANCE;
        Graph.d3Force('link').distance(link => {
            const s = typeof link.source === 'object' ? link.source : nodes.find(n => n.id === link.source);
            const t = typeof link.target === 'object' ? link.target : nodes.find(n => n.id === link.target);
            if (!s || !t) return base;
            const sf = s.fileIdx ?? -1, tf = t.fileIdx ?? -1;
            return (sf >= 0 && tf >= 0 && sf !== tf) ? base * linkMult : base;
        });

        _fileCohesionActive = true;
        Graph.d3ReheatSimulation();
    }

    /**
     * Clear file cohesion force
     */
    function clearFileCohesion() {
        if (!_fileCohesionActive) return;

        const Graph = window.Graph;
        const DEFAULT_LINK_DISTANCE = window.DEFAULT_LINK_DISTANCE;

        Graph.d3Force('fileCohesion', null);
        if (DEFAULT_LINK_DISTANCE !== null) {
            Graph.d3Force('link').distance(DEFAULT_LINK_DISTANCE);
        }
        _fileCohesionActive = false;
        Graph.d3ReheatSimulation();
    }

    /**
     * Clear cluster force
     */
    function clearClusterForce() {
        if (!_clusterForceActive) return;

        const Graph = window.Graph;
        Graph.d3Force('cluster', null);
        _clusterForceActive = false;
        Graph.d3ReheatSimulation();
    }

    // =========================================================================
    // FILE CONTAINMENT SYSTEM - Spherical fields with particle physics
    // "Metaphysical force from another dimension" - holding particles together
    // =========================================================================

    const _containment = {
        spheres: [],              // Three.js sphere meshes
        directoryTree: null,      // Parsed directory hierarchy
        particleActivity: {},     // FileIdx → activity level (0-1)
        boundariesPopped: false,  // Animation state
        popProgress: 0,           // 0 = contained, 1 = fully free
        slowMotionFactor: 0.15,   // Time multiplier for dreamy slow motion
        collisionEnabled: true,   // Enable soft collisions
        spatialGrid: null,        // For efficient collision detection
        gridCellSize: 20,         // Size of spatial hash cells
        animationFrame: null,
        isAnimating: false
    };

    /**
     * Toggle file expansion for a single file
     */
    function toggleFileExpand(fileIdx) {
        if (!Number.isFinite(fileIdx)) return;
        captureFileNodePositions();
        const dm = typeof DATA !== 'undefined' ? DATA : (typeof DM !== 'undefined' ? DM : null);
        const fileInfo = dm ? dm.getFile(fileIdx) : {};
        const fileLabel = fileInfo?.file_name || fileInfo?.file || `file-${fileIdx}`;
        if (_expandedFiles.has(fileIdx)) {
            _expandedFiles.delete(fileIdx);
            if (typeof showToast === 'function') showToast(`Collapsed ${fileLabel}`);
        } else {
            _expandedFiles.clear();
            _expandedFiles.add(fileIdx);
            if (typeof showToast === 'function') showToast(`Expanded ${fileLabel}`);
        }
        window.GRAPH_MODE = (_expandedFiles.size > 0) ? 'hybrid' : 'files';
        if (typeof refreshGraph === 'function') refreshGraph();
    }

    /**
     * Draw file boundary hulls
     */
    function drawFileBoundaries(data) {
        const Graph = window.Graph;
        const IS_3D = window.IS_3D;
        const APPEARANCE_STATE = window.APPEARANCE_STATE || {};
        const dm = typeof DATA !== 'undefined' ? DATA : (typeof DM !== 'undefined' ? DM : null);

        let drawn = 0;
        const boundaryConfig = data?.appearance?.boundary || {};
        const fillOpacity =
            (typeof APPEARANCE_STATE.boundaryFill === 'number')
                ? APPEARANCE_STATE.boundaryFill
                : (boundaryConfig.fill_opacity || 0.05); // Reduced from 0.08
        const wireOpacity =
            (typeof APPEARANCE_STATE.boundaryWire === 'number')
                ? APPEARANCE_STATE.boundaryWire
                : (boundaryConfig.wire_opacity || 0.15); // Reduced from 0.3
        const padding = boundaryConfig.padding || 1.2;
        const minExtent = boundaryConfig.min_extent || 6;
        const quantileRange = boundaryConfig.quantile || 0.9;
        const lowQ = Math.max(0, (1 - quantileRange) / 2);
        const highQ = Math.min(1, 1 - lowQ);
        const boundaryPhysics = data?.physics?.boundary || {};
        const hullType = String(boundaryPhysics.hullType || 'convex').toLowerCase();
        const fileBoundaries = dm ? dm.getFileBoundaries() : (data?.file_boundaries || []);
        const totalFiles = fileBoundaries.length;

        const graphNodes = dm ? dm.getVisibleNodes() : (Graph?.graphData()?.nodes || []);
        const scene = Graph?.scene();
        if (!scene) return drawn;

        // Clear existing boundary meshes
        _boundaryMeshes.forEach(mesh => scene.remove(mesh));
        _boundaryMeshes = [];

        if (!_enabled) return drawn;

        // Group nodes by file (only use nodes with stable positions)
        const fileGroups = {};
        const validNodes = graphNodes.filter(node => {
            if (!node) return false;
            if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return false;
            if (IS_3D && !Number.isFinite(node.z)) return false;
            return true;
        });

        if (!validNodes.length) return drawn;

        validNodes.forEach(node => {
            const idx = node.fileIdx;
            if (idx >= 0) {
                if (!fileGroups[idx]) fileGroups[idx] = [];
                fileGroups[idx].push(node);
            }
        });

        // Draw boundary for each file group
        Object.entries(fileGroups).forEach(([fileIdx, nodes]) => {
            const sampled = typeof sampleFileNodes === 'function' ? sampleFileNodes(nodes, 180) : nodes.slice(0, 180);
            const xs = sampled.map(n => n.x || 0);
            const ys = sampled.map(n => n.y || 0);
            const zs = sampled.map(n => n.z || 0);

            const quantileFn = typeof quantile === 'function' ? quantile : (arr, q) => arr.sort((a, b) => a - b)[Math.floor(arr.length * q)] || 0;
            const minX = quantileFn(xs, lowQ);
            const maxX = quantileFn(xs, highQ);
            const minY = quantileFn(ys, lowQ);
            const maxY = quantileFn(ys, highQ);
            const minZ = quantileFn(zs, lowQ);
            const maxZ = quantileFn(zs, highQ);

            const filtered = sampled.filter(n => {
                const x = n.x || 0;
                const y = n.y || 0;
                const z = n.z || 0;
                return x >= minX && x <= maxX && y >= minY && y <= maxY && z >= minZ && z <= maxZ;
            });
            const hullNodes = filtered.length >= 3 ? filtered : sampled;
            const positions = hullNodes.map(n => new THREE.Vector3(n.x || 0, n.y || 0, n.z || 0));
            const centroid = typeof computeCentroid === 'function' ? computeCentroid(positions) :
                new THREE.Vector3(
                    positions.reduce((s, p) => s + p.x, 0) / positions.length,
                    positions.reduce((s, p) => s + p.y, 0) / positions.length,
                    positions.reduce((s, p) => s + p.z, 0) / positions.length
                );
            const zRange = maxZ - minZ;
            const extentX = Math.max(0.001, maxX - minX);
            const extentY = Math.max(0.001, maxY - minY);
            const extentZ = Math.max(0.001, maxZ - minZ);
            const scaleFixX = Math.max(1, minExtent / extentX);
            const scaleFixY = Math.max(1, minExtent / extentY);
            const scaleFixZ = IS_3D ? Math.max(1, minExtent / extentZ) : 1;
            const scaleX = padding * scaleFixX;
            const scaleY = padding * scaleFixY;
            const scaleZ = padding * scaleFixZ;
            const sizeX = extentX * scaleX;
            const sizeY = extentY * scaleY;
            const sizeZ = extentZ * scaleZ;

            const fileIndex = Number.parseInt(fileIdx, 10);
            const safeFileIdx = Number.isFinite(fileIndex) ? fileIndex : 0;
            const fileInfo = (fileBoundaries || [])[safeFileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            const color = new THREE.Color(getColor(safeFileIdx, totalFiles, fileLabel));

            let mesh = null;
            let wireMesh = null;

            if (nodes.length < 3) {
                const rawPositions = nodes.map(n => new THREE.Vector3(n.x || 0, n.y || 0, n.z || 0));
                const smallCentroid = typeof computeCentroid === 'function' ? computeCentroid(rawPositions) :
                    new THREE.Vector3(
                        rawPositions.reduce((s, p) => s + p.x, 0) / rawPositions.length,
                        rawPositions.reduce((s, p) => s + p.y, 0) / rawPositions.length,
                        rawPositions.reduce((s, p) => s + p.z, 0) / rawPositions.length
                    );
                const maxRadius = rawPositions.reduce((acc, p) => {
                    return Math.max(acc, p.distanceTo(smallCentroid));
                }, 0);
                const bubbleRadius = Math.max(minExtent * 0.5, maxRadius + minExtent * 0.35);
                const material = new THREE.MeshBasicMaterial({
                    color: color, transparent: true, opacity: fillOpacity,
                    wireframe: false, side: THREE.DoubleSide, depthWrite: false
                });
                if (IS_3D) {
                    const geometry = new THREE.SphereGeometry(bubbleRadius, 14, 10);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.copy(smallCentroid);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(geometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                } else {
                    const geometry = new THREE.CircleGeometry(bubbleRadius, 32);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(smallCentroid.x, smallCentroid.y, smallCentroid.z);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(geometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                }
            }

            if (!mesh && hullType === 'convex') {
                if (IS_3D && zRange > 0.001 && positions.length >= 4) {
                    const ConvexCtor =
                        (typeof ConvexGeometry !== 'undefined')
                            ? ConvexGeometry
                            : (THREE.ConvexGeometry || null);
                    const relPoints = positions.map(p => p.clone().sub(centroid));
                    let boundaryGeometry = null;
                    if (ConvexCtor) {
                        try { boundaryGeometry = new ConvexCtor(relPoints); }
                        catch (err) { boundaryGeometry = null; }
                    }
                    if (boundaryGeometry) {
                        const material = new THREE.MeshBasicMaterial({
                            color: color, transparent: true, opacity: fillOpacity,
                            wireframe: false, side: THREE.DoubleSide, depthWrite: false
                        });
                        mesh = new THREE.Mesh(boundaryGeometry, material);
                        mesh.position.copy(centroid);
                        mesh.scale.set(scaleX, scaleY, scaleZ);
                        const wireMaterial = new THREE.LineBasicMaterial({
                            color: color, transparent: true, opacity: wireOpacity
                        });
                        const edges = new THREE.EdgesGeometry(boundaryGeometry);
                        wireMesh = new THREE.LineSegments(edges, wireMaterial);
                        wireMesh.position.copy(centroid);
                        wireMesh.scale.copy(mesh.scale);
                    }
                }

                if (!mesh) {
                    const hull2d = typeof buildHull2D === 'function' ?
                        buildHull2D(positions.map(p => new THREE.Vector2(p.x, p.y))) : null;
                    if (!hull2d || hull2d.length < 3) return;
                    const localHull = hull2d.map(p => new THREE.Vector2(p.x - centroid.x, p.y - centroid.y));
                    const shape = new THREE.Shape(localHull);
                    const boundaryGeometry = new THREE.ShapeGeometry(shape);
                    const material = new THREE.MeshBasicMaterial({
                        color: color, transparent: true, opacity: fillOpacity,
                        wireframe: false, side: THREE.DoubleSide, depthWrite: false
                    });
                    mesh = new THREE.Mesh(boundaryGeometry, material);
                    mesh.position.set(centroid.x, centroid.y, centroid.z);
                    mesh.scale.set(scaleX, scaleY, 1);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const wireGeometry = new THREE.BufferGeometry().setFromPoints(
                        localHull.map(p => new THREE.Vector3(p.x, p.y, 0))
                    );
                    wireMesh = new THREE.LineLoop(wireGeometry, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                    wireMesh.scale.copy(mesh.scale);
                }
            } else if (!mesh && hullType === 'box') {
                const material = new THREE.MeshBasicMaterial({
                    color: color, transparent: true, opacity: fillOpacity,
                    wireframe: false, side: THREE.DoubleSide, depthWrite: false
                });
                if (IS_3D) {
                    const geometry = new THREE.BoxGeometry(sizeX, sizeY, sizeZ);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.copy(centroid);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(geometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                } else {
                    const geometry = new THREE.PlaneGeometry(sizeX, sizeY);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(centroid.x, centroid.y, centroid.z);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(geometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                }
            } else if (!mesh) {
                const radius = 0.5 * Math.max(sizeX, sizeY, IS_3D ? sizeZ : 0);
                const material = new THREE.MeshBasicMaterial({
                    color: color, transparent: true, opacity: fillOpacity,
                    wireframe: false, side: THREE.DoubleSide, depthWrite: false
                });
                if (IS_3D) {
                    const geometry = new THREE.SphereGeometry(radius, 18, 14);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.copy(centroid);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(geometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                } else {
                    const geometry = new THREE.CircleGeometry(radius, 40);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(centroid.x, centroid.y, centroid.z);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(geometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                }
            }

            if (!mesh) return;
            scene.add(mesh);
            _boundaryMeshes.push(mesh);
            drawn += 1;
            if (wireMesh) {
                scene.add(wireMesh);
                _boundaryMeshes.push(wireMesh);
            }
        });
        return drawn;
    }

    /**
     * Build directory tree from file paths
     */
    function buildDirectoryTree(data) {
        const fileBoundaries = data?.file_boundaries || [];
        const tree = { name: '/', path: '', depth: 0, children: {}, files: [], totalNodes: 0 };

        fileBoundaries.forEach((file, idx) => {
            const filePath = file.file || file.file_name || '';
            const parts = filePath.split('/').filter(p => p);
            let current = tree;

            parts.forEach((part, partIdx) => {
                const isFile = partIdx === parts.length - 1;
                if (isFile) {
                    current.files.push({
                        name: part, path: filePath, fileIdx: idx,
                        nodeCount: (file.atom_ids || []).length, activity: 0
                    });
                } else {
                    if (!current.children[part]) {
                        current.children[part] = {
                            name: part, path: parts.slice(0, partIdx + 1).join('/'),
                            depth: partIdx + 1, children: {}, files: [], totalNodes: 0
                        };
                    }
                    current = current.children[part];
                }
            });
        });

        _containment.directoryTree = tree;
        return tree;
    }

    /**
     * Compute activity levels from markov transitions
     */
    function computeFileActivity(data) {
        const markov = data?.markov || {};
        const highEntropy = markov.high_entropy_nodes || [];
        const transitions = markov.transitions || {};
        const fileActivity = {};

        (data?.file_boundaries || []).forEach((file, idx) => {
            const atomIds = file.atom_ids || [];
            let activity = 0;
            atomIds.forEach(atomId => {
                if (highEntropy.some(h => h.node === atomId)) activity += 0.3;
                const fanout = Object.keys(transitions[atomId] || {}).length;
                activity += Math.min(fanout / 10, 0.5);
            });
            fileActivity[idx] = Math.min(1, activity / Math.max(1, atomIds.length));
        });

        _containment.particleActivity = fileActivity;
        return fileActivity;
    }

    /**
     * Draw containment spheres/boxes
     */
    function drawContainmentSpheres(_data) {
        const Graph = window.Graph;
        const flowMode = window.flowMode;
        const dm = typeof DATA !== 'undefined' ? DATA : (typeof DM !== 'undefined' ? DM : null);

        const scene = Graph?.scene();
        if (!scene) return;
        const graphNodes = dm ? dm.getVisibleNodes() : (Graph?.graphData()?.nodes || []);

        // Clear existing
        _containment.spheres.forEach(s => {
            if (s.mesh) scene.remove(s.mesh);
            if (s.wireframe) scene.remove(s.wireframe);
            if (s.glow) scene.remove(s.glow);
        });
        _containment.spheres = [];

        const hullsActive = document.getElementById('btn-file-hulls')?.classList.contains('active');
        if (!_enabled || flowMode || !hullsActive || _containment.boundariesPopped) return;

        // Group nodes by file
        const fileGroups = {};
        graphNodes.filter(n => n && Number.isFinite(n.x)).forEach(node => {
            if (node.fileIdx >= 0) {
                if (!fileGroups[node.fileIdx]) fileGroups[node.fileIdx] = [];
                fileGroups[node.fileIdx].push(node);
            }
        });

        Object.entries(fileGroups).forEach(([fileIdx, nodes]) => {
            if (nodes.length < 3) return;

            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            nodes.forEach(n => {
                minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x);
                minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y);
                minZ = Math.min(minZ, n.z || 0); maxZ = Math.max(maxZ, n.z || 0);
            });

            const pad = 10;
            const width = (maxX - minX) + pad * 2;
            const height = (maxY - minY) + pad * 2;
            const depth = (maxZ - minZ) + pad * 2;

            if (width < 5 || height < 5 || depth < 5) return;

            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;
            const cz = (minZ + maxZ) / 2;

            const geometry = new THREE.BoxGeometry(width, height, depth);
            const color = new THREE.Color(nodes[0].color || '#4488ff');

            const material = new THREE.MeshLambertMaterial({
                color: color, transparent: true, opacity: 0.15,
                depthWrite: false, side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(cx, cy, cz);
            scene.add(mesh);

            const wireGeo = new THREE.EdgesGeometry(geometry);
            const wireMat = new THREE.LineBasicMaterial({
                color: color, transparent: true, opacity: 0.4,
                blending: THREE.AdditiveBlending
            });
            const wireframe = new THREE.LineSegments(wireGeo, wireMat);
            wireframe.position.set(cx, cy, cz);
            scene.add(wireframe);

            _containment.spheres.push({
                mesh, wireframe,
                fileIdx: parseInt(fileIdx),
                velocity: new THREE.Vector3(0, 0, 0),
                activity: _containment.particleActivity[fileIdx] || 0,
                nodes: nodes.map(n => n.id)
            });
        });
    }

    /**
     * Start containment animation loop
     */
    function startContainmentAnimation() {
        if (_containment.isAnimating) return;
        _containment.isAnimating = true;
        const Graph = window.Graph;
        const IS_3D = window.IS_3D;

        function animate() {
            if (!_containment.isAnimating) return;

            const time = Date.now() * 0.001 * _containment.slowMotionFactor;
            const graphNodes = Graph?.graphData()?.nodes || [];

            if (_containment.boundariesPopped) {
                if (typeof applySoftCollisions === 'function') {
                    applySoftCollisions(graphNodes, _containment.gridCellSize, 0.4);
                }

                graphNodes.forEach(node => {
                    if (!node || !node.__physics) return;
                    const p = node.__physics;
                    const wander = 0.08;
                    p.vx += (Math.sin(time * 0.7 + (node.__wanderPhase || 0)) - 0.5) * wander;
                    p.vy += (Math.cos(time * 0.5 + (node.__wanderPhase || 0) * 1.3) - 0.5) * wander;
                    if (IS_3D) p.vz += (Math.sin(time * 0.6 + (node.__wanderPhase || 0) * 0.7) - 0.5) * wander;
                    p.vx *= 0.985;
                    p.vy *= 0.985;
                    p.vz *= 0.985;
                    node.x += p.vx;
                    node.y += p.vy;
                    if (IS_3D) node.z = (node.z || 0) + p.vz;
                });
            } else {
                _containment.spheres.forEach(sphere => {
                    const activity = sphere.activity;
                    const pulse = Math.sin(time * 2 + sphere.fileIdx) * 0.5 + 0.5;
                    if (sphere.mesh?.material) {
                        sphere.mesh.material.opacity = 0.04 + activity * 0.12 * pulse;
                    }
                    if (sphere.wireframe?.material) {
                        sphere.wireframe.material.opacity = 0.08 + activity * 0.2 * pulse;
                    }
                    if (activity < 0.05) return;

                    sphere.nodes.forEach(nodeId => {
                        const node = graphNodes.find(n => n.id === nodeId);
                        if (!node || !Number.isFinite(node.x)) return;
                        if (!node.__activityPhase) {
                            node.__activityPhase = {
                                x: Math.random() * Math.PI * 2,
                                y: Math.random() * Math.PI * 2,
                                z: Math.random() * Math.PI * 2
                            };
                        }
                        const amp = activity * 0.4;
                        const freq = 0.5 + activity * 0.5;
                        const phase = node.__activityPhase;
                        node.__renderOffsetX = Math.sin(time * freq + phase.x) * amp;
                        node.__renderOffsetY = Math.sin(time * freq * 1.2 + phase.y) * amp;
                        if (IS_3D) node.__renderOffsetZ = Math.sin(time * freq * 0.9 + phase.z) * amp;
                    });
                });
            }

            if (Graph) REFRESH.throttled();
            _containment.animationFrame = requestAnimationFrame(animate);
        }

        animate();
    }

    /**
     * Stop containment animation
     */
    function stopContainmentAnimation() {
        _containment.isAnimating = false;
        if (_containment.animationFrame) {
            cancelAnimationFrame(_containment.animationFrame);
        }
    }

    /**
     * Pop boundaries - release particles into free Brownian motion
     */
    function popBoundaries(duration = 3000) {
        if (_containment.boundariesPopped) {
            restoreBoundaries(duration);
            return;
        }

        console.log('[Containment] Popping boundaries...');
        _containment.boundariesPopped = true;
        const startTime = Date.now();
        const Graph = window.Graph;
        const IS_3D = window.IS_3D;
        const scene = Graph?.scene();
        const graphNodes = Graph?.graphData()?.nodes || [];

        graphNodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            node.__physics = {
                vx: (Math.random() - 0.5) * 1.5,
                vy: (Math.random() - 0.5) * 1.5,
                vz: IS_3D ? (Math.random() - 0.5) * 1.5 : 0
            };
            node.__wanderPhase = Math.random() * Math.PI * 2;
        });

        function animatePop() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);
            _containment.popProgress = progress;
            const eased = 1 - Math.pow(1 - progress, 3);

            _containment.spheres.forEach(s => {
                if (s.mesh?.material) s.mesh.material.opacity = (1 - eased) * 0.1;
                if (s.wireframe?.material) s.wireframe.material.opacity = (1 - eased) * 0.25;
                if (s.glow?.material) s.glow.material.opacity = (1 - eased) * 0.08;
            });

            if (progress < 1) {
                requestAnimationFrame(animatePop);
            } else {
                _containment.spheres.forEach(s => {
                    if (s.mesh) scene.remove(s.mesh);
                    if (s.wireframe) scene.remove(s.wireframe);
                    if (s.glow) scene.remove(s.glow);
                });
                _containment.spheres = [];
                console.log('[Containment] Particles now FREE - Brownian motion with collisions');
            }

            if (Graph) REFRESH.throttled();
        }

        animatePop();
        startContainmentAnimation();
    }

    /**
     * Restore boundaries
     */
    function restoreBoundaries(duration = 2000) {
        if (!_containment.boundariesPopped) return;

        console.log('[Containment] Restoring boundaries...');
        const startTime = Date.now();
        const Graph = window.Graph;
        const IS_3D = window.IS_3D;
        const dm = typeof DATA !== 'undefined' ? DATA : (typeof DM !== 'undefined' ? DM : null);
        const graphNodes = Graph?.graphData()?.nodes || [];

        graphNodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            node.__freePos = { x: node.x, y: node.y, z: node.z || 0 };
        });

        function animateRestore() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);
            _containment.popProgress = 1 - progress;
            const eased = Math.pow(progress, 2);

            graphNodes.forEach(node => {
                if (!node || !node.__freePos || !node.__originalPos) return;
                node.x = node.__freePos.x + (node.__originalPos.x - node.__freePos.x) * eased;
                node.y = node.__freePos.y + (node.__originalPos.y - node.__freePos.y) * eased;
                if (IS_3D) node.z = node.__freePos.z + ((node.__originalPos.z || 0) - node.__freePos.z) * eased;
            });

            if (progress < 1) {
                requestAnimationFrame(animateRestore);
            } else {
                _containment.boundariesPopped = false;
                drawContainmentSpheres(null);
                console.log('[Containment] Boundaries restored');
            }

            if (Graph) REFRESH.throttled();
        }

        animateRestore();
    }

    /**
     * Update expand mode buttons
     */
    function updateExpandButtons() {
        const inlineBtn = document.getElementById('btn-expand-inline');
        const detachBtn = document.getElementById('btn-expand-detach');
        if (inlineBtn) inlineBtn.classList.toggle('active', _expandMode === 'inline');
        if (detachBtn) detachBtn.classList.toggle('active', _expandMode === 'detach');
    }

    /**
     * Handle cmd-files button click
     */
    function handleCmdFiles() {
        const btn = document.getElementById('cmd-files');
        const isActive = btn ? btn.classList.contains('active') : false;
        setEnabled(!isActive);
    }

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getHue,
        applyColors,

        // Mode management
        setMode,
        get mode() { return _mode; },
        MODES,
        MODE_HINTS,

        // Enable/disable
        setEnabled,
        toggle,
        get enabled() { return _enabled; },

        // Apply
        apply,

        // FILE GRAPH - Repository as Nodes
        buildFileGraph,
        applyFileGraphMode,
        expandFile,
        collapseFile,
        toggleFileExpansion,
        captureFileNodePositions,
        restoreFileNodePositions,
        getFileTarget,
        get fileGraph() { return _fileGraph; },
        get fileNodeIds() { return _fileNodeIds; },
        get expandedFiles() { return _expandedFiles; },
        get graphMode() { return _graphMode; },
        set graphMode(val) { _graphMode = val; },
        get expandMode() { return _expandMode; },
        set expandMode(val) { _expandMode = val; },

        // VISUAL MAPPING - Metadata to Visual Properties
        applyVisualMapping,
        getColorForMapping,
        VISUAL_MAPPINGS,
        get activeMapping() { return _activeMapping; },
        set activeMapping(val) { _activeMapping = val; },

        // Boundaries
        clearBoundaries,
        clearAllModes,
        scheduleHullRedraw,

        // File Clustering Forces
        applyClusterForce,
        clearClusterForce,
        applyFileCohesion,
        clearFileCohesion,
        get clusterForceActive() { return _clusterForceActive; },
        get fileCohesionActive() { return _fileCohesionActive; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Internal state access (for migration)
        get boundaryMeshes() { return _boundaryMeshes; },
        set boundaryMeshes(val) { _boundaryMeshes = val; },

        // FILE CONTAINMENT SYSTEM - Moved from app.js
        toggleFileExpand,
        drawFileBoundaries,
        buildDirectoryTree,
        computeFileActivity,
        drawContainmentSpheres,
        startContainmentAnimation,
        stopContainmentAnimation,
        popBoundaries,
        restoreBoundaries,
        updateExpandButtons,
        handleCmdFiles,
        get containment() { return _containment; }
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'fileMode', {
    get: () => FILE_VIZ.enabled,
    set: (v) => FILE_VIZ.setEnabled(v),
    configurable: true
});
Object.defineProperty(window, 'fileVizMode', {
    get: () => FILE_VIZ.mode,
    set: (v) => FILE_VIZ.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'FILE_COLOR_CONFIG', {
    get: () => FILE_VIZ.config,
    configurable: true
});
Object.defineProperty(window, 'fileBoundaryMeshes', {
    get: () => FILE_VIZ.boundaryMeshes,
    set: (v) => { FILE_VIZ.boundaryMeshes = v; },
    configurable: true
});
// hullRedrawTimer, hullRedrawAttempts - app.js owns these, not duplicated here

function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride) {
    return FILE_VIZ.getColor(fileIdx, totalFiles, fileName, lightnessOverride);
}
function getFileHue(fileIdx, totalFiles, fileName) {
    return FILE_VIZ.getHue(fileIdx, totalFiles, fileName);
}
function setFileModeState(enabled) {
    FILE_VIZ.setEnabled(enabled);
}
function setFileVizMode(mode) {
    FILE_VIZ.setMode(mode);
}
function applyFileVizMode() {
    FILE_VIZ.apply();
}
function applyFileColors(graphNodes) {
    FILE_VIZ.applyColors(graphNodes);
}
function clearFileBoundaries() {
    FILE_VIZ.clearBoundaries();
}
function clearAllFileModes() {
    FILE_VIZ.clearAllModes();
}
function scheduleHullRedraw(delayMs) {
    FILE_VIZ.scheduleHullRedraw(delayMs);
}

// File graph backward compatibility - Using getters for live updates
Object.defineProperty(window, 'FILE_GRAPH', {
    get: () => FILE_VIZ.fileGraph,
    set: (val) => { /* Ignore - module manages state */ },
    configurable: true
});
Object.defineProperty(window, 'FILE_NODE_IDS', {
    get: () => FILE_VIZ.fileNodeIds,
    configurable: true
});
// FILE_NODE_POSITIONS is managed by app.js (not in this module's scope)
Object.defineProperty(window, 'EXPANDED_FILES', {
    get: () => FILE_VIZ.expandedFiles,
    configurable: true
});
Object.defineProperty(window, 'FILE_EXPAND_MODE', {
    get: () => FILE_VIZ.expandMode,
    set: (val) => { FILE_VIZ.expandMode = val; },
    configurable: true
});

function buildFileGraph(data) {
    // Calls module's buildFileGraph - FILE_GRAPH getter will return the result
    FILE_VIZ.buildFileGraph();
    FILE_NODE_IDS = FILE_VIZ.fileNodeIds;
    return FILE_VIZ.fileGraph;  // Return directly from module
}
function captureFileNodePositions() {
    FILE_VIZ.captureFileNodePositions();
}
function restoreNodePositions(nodes) {
    FILE_VIZ.restoreFileNodePositions(nodes);
}
function getFileTarget(fileIdx, totalFiles, radius, zSpread) {
    return FILE_VIZ.getFileTarget(fileIdx, totalFiles, radius, zSpread);
}

// File clustering force shims
function applyClusterForce(data) {
    FILE_VIZ.applyClusterForce(data);
}
function clearClusterForce() {
    FILE_VIZ.clearClusterForce();
}
function applyFileCohesion(data) {
    FILE_VIZ.applyFileCohesion(data);
}
function clearFileCohesion() {
    FILE_VIZ.clearFileCohesion();
}
Object.defineProperty(window, 'clusterForceActive', {
    get: () => FILE_VIZ.clusterForceActive,
    configurable: true
});
Object.defineProperty(window, 'fileCohesionActive', {
    get: () => FILE_VIZ.fileCohesionActive,
    configurable: true
});

// File containment system shims - moved from app.js
function toggleFileExpand(fileIdx) { FILE_VIZ.toggleFileExpand(fileIdx); }
function drawFileBoundaries(data) { return FILE_VIZ.drawFileBoundaries(data); }
function buildDirectoryTree(data) { return FILE_VIZ.buildDirectoryTree(data); }
function computeFileActivity(data, graphNodes) { return FILE_VIZ.computeFileActivity(data, graphNodes); }
function drawContainmentSpheres(data) { FILE_VIZ.drawContainmentSpheres(data); }
function startContainmentAnimation() { FILE_VIZ.startContainmentAnimation(); }
function stopContainmentAnimation() { FILE_VIZ.stopContainmentAnimation(); }
function popBoundaries(duration) { FILE_VIZ.popBoundaries(duration); }
function restoreBoundaries(duration) { FILE_VIZ.restoreBoundaries(duration); }
function updateExpandButtons() { FILE_VIZ.updateExpandButtons(); }
function handleCmdFiles() { FILE_VIZ.handleCmdFiles(); }

// Expose to global for button bindings and backward compatibility
window.popBoundaries = popBoundaries;
window.restoreBoundaries = restoreBoundaries;
window.toggleFileExpand = toggleFileExpand;
window.drawFileBoundaries = drawFileBoundaries;
window.buildDirectoryTree = buildDirectoryTree;
window.computeFileActivity = computeFileActivity;
window.drawContainmentSpheres = drawContainmentSpheres;
window.startContainmentAnimation = startContainmentAnimation;
window.stopContainmentAnimation = stopContainmentAnimation;
window.updateExpandButtons = updateExpandButtons;
window.handleCmdFiles = handleCmdFiles;

// FILE_CONTAINMENT state exposed via module
Object.defineProperty(window, 'FILE_CONTAINMENT', {
    get: () => FILE_VIZ.containment,
    configurable: true
});

console.log('[Module] FILE_VIZ loaded - file visualization, boundaries, containment');


// ═══ MODULE: modules/tooltips.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * TOOLTIPS MODULE - Tooltip and Toast Notifications
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles topology tooltips and toast notifications.
 * Depends on: TOOLTIP_STATE, HINTS_ENABLED, SMC_THEORY (globals)
 *
 * @module TOOLTIPS
 * @version 1.0.0
 * @confidence 99%
 */

window.TOOLTIPS = (function() {
    'use strict';

    // Module-local timeout reference
    let _toastTimeout = null;

    // ═══════════════════════════════════════════════════════════════════════
    // TOOLTIP OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize tooltip elements
     */
    function initTooltips() {
        const state = window.TOOLTIP_STATE;
        if (state) {
            state.element = document.getElementById('topo-tooltip');
        }
    }

    /**
     * Show topology tooltip with theory content
     * @param {string} category - Theory category (tiers, rings, families, etc.)
     * @param {string} key - Item key within category
     * @param {number} x - Screen X position
     * @param {number} y - Screen Y position
     */
    function showTopoTooltip(category, key, x, y) {
        const state = window.TOOLTIP_STATE;
        if (!state) return;

        if (!state.element) initTooltips();
        if (!state.element) return;

        const theory = window.SMC_THEORY;
        const content = theory?.[category]?.[key];
        if (!content) return;

        clearTimeout(state.hideTimeout);

        // Populate tooltip content
        const iconEl = document.getElementById('tooltip-icon');
        const titleEl = document.getElementById('tooltip-title');
        const subtitleEl = document.getElementById('tooltip-subtitle');
        const bodyEl = document.getElementById('tooltip-body');
        const theoryEl = document.getElementById('tooltip-theory');
        const examplesEl = document.getElementById('tooltip-examples');

        if (iconEl) iconEl.textContent = content.icon || '';
        if (titleEl) titleEl.textContent = content.title || key;
        if (subtitleEl) subtitleEl.textContent = content.subtitle || '';
        if (bodyEl) bodyEl.textContent = content.body || '';
        if (theoryEl) theoryEl.textContent = content.theory || '';
        if (examplesEl) {
            examplesEl.innerHTML = (content.examples || [])
                .map(ex => `<span class="topo-tooltip-example">${ex}</span>`)
                .join('');
        }

        // Position tooltip
        const tooltip = state.element;
        let left = x + 15, top = y + 15;
        if (left + 280 > window.innerWidth) left = x - 295;
        if (top + 200 > window.innerHeight) top = y - 215;
        if (left < 0) left = 15;
        if (top < 0) top = 15;

        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.classList.add('visible');

        state.visible = true;
        state.currentKey = `${category}:${key}`;
    }

    /**
     * Hide topology tooltip
     * @param {boolean} immediate - Hide immediately without delay
     */
    function hideTopoTooltip(immediate = false) {
        const state = window.TOOLTIP_STATE;
        if (!state || !state.element) return;

        if (immediate) {
            state.element.classList.remove('visible');
            state.visible = false;
        } else {
            state.hideTimeout = setTimeout(() => {
                state.element.classList.remove('visible');
                state.visible = false;
            }, 150);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Show a toast notification
     * @param {string} message - Message to display
     */
    function showToast(message) {
        const toast = document.getElementById('hud-toast');
        if (!toast) return;

        toast.textContent = message;
        toast.classList.add('visible');

        clearTimeout(toast._timer);
        toast._timer = setTimeout(() => {
            toast.classList.remove('visible');
        }, 2200);
    }

    /**
     * Show mode change toast (respects hints setting)
     * @param {string} message - Message to display
     */
    function showModeToast(message) {
        if (!window.HINTS_ENABLED) return;

        let toast = document.getElementById('mode-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'mode-toast';
            toast.className = 'mode-toast';
            document.body.appendChild(toast);
        }

        toast.textContent = message;
        toast.classList.add('visible');

        if (_toastTimeout) clearTimeout(_toastTimeout);
        _toastTimeout = setTimeout(() => {
            toast.classList.remove('visible');
        }, 1200);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        init: initTooltips,
        showTopo: showTopoTooltip,
        hideTopo: hideTopoTooltip,
        toast: showToast,
        modeToast: showModeToast
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.initTooltips = TOOLTIPS.init;
window.showTopoTooltip = TOOLTIPS.showTopo;
window.hideTopoTooltip = TOOLTIPS.hideTopo;
window.showToast = TOOLTIPS.toast;
window.showModeToast = TOOLTIPS.modeToast;

console.log('[Module] TOOLTIPS loaded - 5 functions');


// ═══ MODULE: modules/theme.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * THEME MODULE - Runtime Theme Management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles theme switching, persistence, and initialization.
 * Depends on: THEME_CONFIG (global), Graph (global), THREE (global)
 *
 * @module THEME
 * @version 1.0.0
 * @confidence 99%
 */

window.THEME = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // THEME OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Set the active theme by name.
     * Updates document data-theme attribute and stores preference.
     * @param {string} themeName - Theme name: 'dark', 'light', or 'high-contrast'
     */
    function setTheme(themeName) {
        const config = window.THEME_CONFIG;
        if (!config || !config.available.includes(themeName)) {
            console.warn(`[Theme] Unknown theme: ${themeName}. Available: ${config?.available?.join(', ') || 'none'}`);
            return;
        }

        // Update document attribute for CSS variable switching
        document.documentElement.setAttribute('data-theme', themeName);

        // Update global state
        config.current = themeName;

        // Store preference in localStorage
        try {
            localStorage.setItem('collider-theme', themeName);
        } catch (e) {
            console.warn('[Theme] Could not save preference:', e);
        }

        // Update canvas background if WebGL renderer is active
        const Graph = window.Graph;
        if (Graph && Graph.scene && Graph.scene()) {
            const scene = Graph.scene();
            if (scene.background) {
                const vizColors = window.VIZ_COLORS || {};
                const bgColor = getComputedStyle(document.documentElement)
                    .getPropertyValue('--color-viz-canvas-bg')?.trim() || vizColors.canvasBg || '#0a0a0f';
                scene.background = new THREE.Color(bgColor);
            }
        }

        // Update theme toggle buttons
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.theme === themeName);
        });

        const consoleColors = window.CONSOLE_COLORS || { success: '#4caf50' };
        console.log(`%c[Theme] Switched to: ${themeName}`, `color: ${consoleColors.success}; font-weight: bold`);

        // Show toast if available
        if (typeof window.showToast === 'function') {
            window.showToast(`Theme: ${themeName}`);
        }
    }

    /**
     * Get the current theme name.
     * @returns {string} Current theme name
     */
    function getTheme() {
        const config = window.THEME_CONFIG;
        return config ? config.current : 'dark';
    }

    /**
     * Get list of available themes.
     * @returns {string[]} Array of theme names
     */
    function getAvailableThemes() {
        const config = window.THEME_CONFIG;
        return config ? config.available : ['dark'];
    }

    /**
     * Cycle to the next theme in the list.
     */
    function cycleTheme() {
        const config = window.THEME_CONFIG;
        if (!config) return;

        const current = config.current;
        const themes = config.available;
        const currentIndex = themes.indexOf(current);
        const nextIndex = (currentIndex + 1) % themes.length;
        setTheme(themes[nextIndex]);
    }

    /**
     * Initialize theme from saved preference or default.
     */
    function initTheme() {
        const config = window.THEME_CONFIG;
        if (!config) {
            console.warn('[Theme] THEME_CONFIG not available');
            return;
        }

        // Check for saved preference
        let savedTheme = null;
        try {
            savedTheme = localStorage.getItem('collider-theme');
        } catch (e) {
            // Ignore storage errors
        }

        // Use saved preference if valid
        if (savedTheme && config.available.includes(savedTheme)) {
            setTheme(savedTheme);
            return;
        }

        // Fall back to default theme
        setTheme(config.default || 'dark');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        set: setTheme,
        get: getTheme,
        available: getAvailableThemes,
        cycle: cycleTheme,
        init: initTheme
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setTheme = THEME.set;
window.getTheme = THEME.get;
window.getAvailableThemes = THEME.available;
window.cycleTheme = THEME.cycle;
window.initTheme = THEME.init;

console.log('[Module] THEME loaded - 5 functions');


// ═══ MODULE: modules/control-bar.js ═══
/**
 * CONTROL BAR MODULE - Visual Mapping Command Center
 *
 * A persistent control bar (like ChatGPT/Claude input) that allows dynamic
 * mapping of any data characteristic to any visual/physics property.
 *
 * Features:
 * - Always visible at bottom of screen
 * - Works with selected nodes or node groups
 * - Dropdown to choose data source (any field)
 * - Dropdown to choose visual target (size, color, position, physics...)
 * - Group comparison with numbered badges
 * - Real-time preview as you adjust
 *
 * Depends on: DATA, COLOR, ANIM, SELECT
 */

const CONTROL_BAR = (function () {
    'use strict';

    // =========================================================================
    // AVAILABLE DATA SOURCES (what we can map FROM)
    // =========================================================================

    // =========================================================================
    // AVAILABLE DATA SOURCES (Delegated to UPB)
    // =========================================================================
    const DATA_SOURCES = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.SOURCES) || {
        // Fallback for safety if UPB fails to load
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Delegated to UPB)
    // =========================================================================
    const VISUAL_TARGETS = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.TARGETS) || {
        // Fallback
        nodeSize: { label: 'Node Size', category: 'appearance', range: [1, 30] }
    };

    // =========================================================================
    // SCALE FUNCTIONS (Delegated to UPB)
    // =========================================================================
    const SCALES = (window.UPB && window.UPB.SCALES && window.UPB.SCALES.SCALES) || {
        linear: (v, min, max) => (v - min) / (max - min || 1)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _visible = false;
    let _container = null;
    let _activeMapping = null;
    let _groups = [];         // [{id, name, nodeIds, color}]
    let _groupCounter = 0;

    // Current mapping configuration
    let _config = {
        source: 'token_estimate',
        target: 'nodeSize',
        scale: 'sqrt',
        scope: 'selection',   // 'selection' | 'all' | 'group:X'
        invert: false
    };

    // =========================================================================
    // UI BUILDING
    // =========================================================================

    let _isDocked = false;

    function createUI() {
        if (_container) return _container;

        const dockContainer = document.getElementById('control-bar-container');
        _isDocked = !!dockContainer;

        _container = document.createElement('div');
        _container.id = 'control-bar';
        _container.className = _isDocked ? 'control-bar docked' : 'control-bar';

        // Scope Section
        const scopeHTML = `
            <div class="control-section scope-section">
                <label>SCOPE</label>
                <div class="row-group">
                    <select id="cb-scope" class="cb-select">
                        <option value="selection">Selected Nodes</option>
                        <option value="all">All Nodes</option>
                        <optgroup label="Groups" id="cb-groups-optgroup"></optgroup>
                    </select>
                    <button id="cb-add-group" class="cb-btn cb-btn-small" title="Create group from selection">+G</button>
                    <span id="cb-node-count" class="cb-badge">0</span>
                </div>
            </div>
        `;

        // Map FROM
        const sourceHTML = `
            <div class="control-section">
                <label>MAP DATA SOURCE</label>
                <select id="cb-source" class="cb-select full-width">
                    <optgroup label="Structural">
                        <option value="token_estimate">Token Count</option>
                        <option value="line_count">Line Count</option>
                        <option value="size_bytes">File Size</option>
                        <option value="code_lines">Code Lines</option>
                        <option value="complexity_density">Complexity</option>
                        <option value="cohesion">Cohesion</option>
                    </optgroup>
                    <optgroup label="Temporal">
                        <option value="age_days">Age (days)</option>
                    </optgroup>
                    <optgroup label="Graph">
                        <option value="in_degree">In-Degree</option>
                        <option value="out_degree">Out-Degree</option>
                    </optgroup>
                    <optgroup label="Categorical">
                        <option value="tier">Tier</option>
                        <option value="ring">Ring</option>
                        <option value="layer">Layer</option>
                        <option value="role">Role</option>
                        <option value="format_category">Format</option>
                        <option value="effect">Effect</option>
                    </optgroup>
                    <optgroup label="Boolean">
                        <option value="is_test">Is Test?</option>
                        <option value="is_config">Is Config?</option>
                        <option value="is_stale">Is Stale?</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Arrow (only for float mode, skip or style differently in dock)
        const arrowHTML = _isDocked ? '' : `
            <div class="control-section arrow-section">
                <span class="arrow">&#8594;</span>
            </div>
        `;

        // Map TO
        const targetHTML = `
            <div class="control-section">
                <label>TO VISUAL PROPERTY</label>
                <select id="cb-target" class="cb-select full-width">
                    <optgroup label="Appearance">
                        <option value="nodeSize">Node Size</option>
                        <option value="hue">Color Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="lightness">Lightness</option>
                        <option value="opacity">Opacity</option>
                    </optgroup>
                    <optgroup label="Position">
                        <option value="xPosition">X Position</option>
                        <option value="yPosition">Y Position</option>
                        <option value="zPosition">Z Depth</option>
                        <option value="radius">Radial Distance</option>
                    </optgroup>
                    <optgroup label="Physics">
                        <option value="charge">Charge (repel)</option>
                        <option value="mass">Mass</option>
                    </optgroup>
                    <optgroup label="Animation">
                        <option value="pulseSpeed">Pulse Speed</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Scale
        const scaleHTML = `
            <div class="control-section">
                <label>SCALING</label>
                <select id="cb-scale" class="cb-select full-width">
                    <option value="linear">Linear</option>
                    <option value="sqrt" selected>Sqrt</option>
                    <option value="log">Log</option>
                    <option value="inverse">Inverse</option>
                </select>
            </div>
        `;

        // Actions
        const actionsHTML = `
            <div class="control-section actions-section">
                <button id="cb-apply" class="cb-btn cb-btn-primary full-width">APPLY MAPPING</button>
                <button id="cb-reset" class="cb-btn full-width" style="margin-top:4px">Reset</button>
            </div>
        `;

        // Groups Display
        const groupsHTML = `
            <div class="control-section groups-section" id="cb-groups-display"></div>
        `;

        // Toggle (only for float mode)
        const toggleHTML = _isDocked ? '' : `
            <button id="cb-toggle" class="cb-toggle" title="Toggle Control Bar">
                <span class="chevron">&#9660;</span>
            </button>
        `;

        _container.innerHTML = `
            <div class="control-bar-inner">
                ${scopeHTML}
                ${sourceHTML}
                ${arrowHTML}
                ${targetHTML}
                ${scaleHTML}
                ${actionsHTML}
                ${groupsHTML}
                ${toggleHTML}
            </div>
        `;

        // Add styles
        addStyles();

        // Attach event listeners
        attachListeners();

        if (_isDocked) {
            dockContainer.appendChild(_container);
        } else {
            document.body.appendChild(_container);
        }

        _visible = true;

        return _container;
    }

    function addStyles() {
        if (document.getElementById('control-bar-styles')) return;

        const style = document.createElement('style');
        style.id = 'control-bar-styles';
        style.textContent = `
            /* BASE STYLES */
            .control-bar {
                font-family: 'SF Mono', 'Consolas', monospace;
            }

            /* FLOATING MODE */
            .control-bar:not(.docked) {
                position: fixed;
                bottom: 16px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 900px;
                width: calc(100% - 48px);
                z-index: 9999;
                background: linear-gradient(180deg, rgba(28, 30, 35, 0.95) 0%, rgba(22, 24, 28, 0.98) 100%);
                backdrop-filter: blur(12px);
                border: 1px solid rgba(100, 105, 115, 0.15);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.35);
                transition: transform 0.3s ease, opacity 0.3s ease;
            }

            .control-bar:not(.docked) .control-bar-inner {
                display: flex;
                align-items: center;
                gap: 16px;
                padding: 12px 20px;
                overflow-x: auto;
            }

            /* DOCKED MODE */
            .control-bar.docked {
                position: static;
                width: 100%;
                background: transparent;
                border: none;
                box-shadow: none;
                padding: 0;
            }

            .control-bar.docked .control-bar-inner {
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 0;
            }

            /* SHARED COMPONENTS */
            .control-section {
                display: flex;
                flex-direction: column;
                gap: 4px;
                width: 100%; /* Full width when docked */
            }

            .control-section label {
                font-size: 9px;
                font-weight: 600;
                color: rgba(140, 145, 155, 0.6);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .row-group {
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .cb-select {
                background: rgba(35, 38, 45, 0.85);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #c8ccd5;
                padding: 6px 10px;
                font-size: 11px;
                font-family: inherit;
                cursor: pointer;
                transition: all 0.2s;
                flex: 1;
            }

            .cb-select:hover {
                background: rgba(45, 48, 55, 0.9);
                border-color: rgba(120, 125, 135, 0.35);
            }
            
            .cb-select:focus {
                outline: none;
                border-color: var(--accent, #4a9eff);
            }

            .full-width {
                width: 100%;
            }

            .cb-btn {
                background: rgba(50, 55, 65, 0.6);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #b0b5c0;
                padding: 6px 12px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
            }
            .actions-section {
                width: 100%;
            }
            .cb-btn:hover {
                background: rgba(65, 70, 80, 0.75);
                color: #fff;
            }

            .cb-btn-primary {
                background: var(--accent-dim, rgba(74, 158, 255, 0.15));
                color: var(--accent, #4a9eff);
                border-color: var(--accent, #4a9eff);
            }

            .cb-btn-primary:hover {
                background: var(--accent, #4a9eff);
                color: #000;
            }

            .cb-btn-small {
                padding: 4px 8px;
                min-width: 30px;
            }

            .cb-badge {
                font-size: 10px;
                color: #666;
                min-width: 15px;
                text-align: center;
            }

            /* GROUP CHIPS */
            .groups-section {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 4px;
            }

            .group-chip {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
                padding: 2px 8px;
                font-size: 10px;
                cursor: default;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .group-color {
                width: 6px;
                height: 6px;
                border-radius: 50%;
            }

            .group-remove {
                margin-left: 4px;
                cursor: pointer;
                opacity: 0.5;
            }
            .group-remove:hover { opacity: 1; }
        `;

        document.head.appendChild(style);
    }

    function attachListeners() {
        // Toggle collapse
        const toggleBtn = document.getElementById('cb-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', toggle);
        }

        // Scope change
        const scopeSelect = document.getElementById('cb-scope');
        if (scopeSelect) {
            scopeSelect.addEventListener('change', (e) => {
                _config.scope = e.target.value;
                updateNodeCount();
            });
        }

        // Source change
        const sourceSelect = document.getElementById('cb-source');
        if (sourceSelect) {
            sourceSelect.addEventListener('change', (e) => {
                _config.source = e.target.value;
            });
        }

        // Target change
        const targetSelect = document.getElementById('cb-target');
        if (targetSelect) {
            targetSelect.addEventListener('change', (e) => {
                _config.target = e.target.value;
            });
        }

        // Scale change
        const scaleSelect = document.getElementById('cb-scale');
        if (scaleSelect) {
            scaleSelect.addEventListener('change', (e) => {
                _config.scale = e.target.value;
            });
        }

        // Apply button
        const applyBtn = document.getElementById('cb-apply');
        if (applyBtn) {
            applyBtn.addEventListener('click', applyMapping);
        }

        // Reset button
        const resetBtn = document.getElementById('cb-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', resetMapping);
        }

        // Add group button
        const addGroupBtn = document.getElementById('cb-add-group');
        if (addGroupBtn) {
            addGroupBtn.addEventListener('click', createGroupFromSelection);
        }

        // Update node count periodically
        setInterval(updateNodeCount, 1000);
    }

    // =========================================================================
    // GROUP MANAGEMENT
    // =========================================================================

    const GROUP_COLORS = [
        '#4a9eff', '#ff6b6b', '#51cf66', '#ffd43b',
        '#cc5de8', '#20c997', '#ff922b', '#748ffc'
    ];

    function createGroupFromSelection() {
        const selectedIds = getSelectedNodeIds();
        if (selectedIds.length === 0) {
            showToast('Select nodes first to create a group');
            return;
        }

        _groupCounter++;
        const groupId = `group-${_groupCounter}`;
        const color = GROUP_COLORS[(_groupCounter - 1) % GROUP_COLORS.length];

        const group = {
            id: groupId,
            name: `Group ${_groupCounter}`,
            nodeIds: [...selectedIds],
            color: color
        };

        _groups.push(group);
        updateGroupsUI();
        showToast(`Created ${group.name} with ${selectedIds.length} nodes`);
    }

    function removeGroup(groupId) {
        _groups = _groups.filter(g => g.id !== groupId);
        updateGroupsUI();
    }

    function updateGroupsUI() {
        // Update dropdown
        const optgroup = document.getElementById('cb-groups-optgroup');
        if (optgroup) {
            optgroup.innerHTML = _groups.map(g =>
                `<option value="group:${g.id}">${g.name} (${g.nodeIds.length})</option>`
            ).join('');
        }

        // Update chips display
        const display = document.getElementById('cb-groups-display');
        if (display) {
            display.innerHTML = _groups.map(g => `
                <div class="group-chip" data-group="${g.id}">
                    <span class="group-color" style="background: ${g.color}"></span>
                    <span class="group-name">${g.name}</span>
                    <span class="group-count">${g.nodeIds.length}</span>
                    <span class="group-remove" onclick="CONTROL_BAR.removeGroup('${g.id}')">&times;</span>
                </div>
            `).join('');
        }
    }

    // =========================================================================
    // MAPPING APPLICATION
    // =========================================================================

    function getTargetNodes() {
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        const allNodes = dm?.getNodes ? dm.getNodes() : (typeof graphNodes !== 'undefined' ? graphNodes : []);

        if (_config.scope === 'all') {
            return allNodes;
        }

        if (_config.scope === 'selection') {
            const selectedIds = getSelectedNodeIds();
            return allNodes.filter(n => selectedIds.includes(n.id));
        }

        if (_config.scope.startsWith('group:')) {
            const groupId = _config.scope.replace('group:', '');
            const group = _groups.find(g => g.id === groupId);
            if (group) {
                return allNodes.filter(n => group.nodeIds.includes(n.id));
            }
        }

        return [];
    }

    function applyMapping() {
        if (!window.UPB) {
            console.error('UPB not loaded');
            return;
        }

        const nodes = getTargetNodes();
        if (nodes.length === 0) {
            showToast('No nodes to map. Select nodes or change scope.');
            return;
        }

        const sourceKey = _config.source;
        const targetKey = _config.target;

        // 1. Create/Update Binding in UPB Graph
        window.UPB.bind(sourceKey, targetKey, {
            id: `cb-binding-${Date.now()}`,
            scale: _config.scale,
            range: VISUAL_TARGETS[targetKey]?.range
        });

        // 2. Refresh Data Ranges (if needed, usually DM handles this)
        // For now, we rely on the UPB Binding to calculate ranges per node or usage
        // But UPB.evaluate needs data ranges (min/max) for normalization.
        // We calculate them here ad-hoc for the current selection and push to UPB.
        const values = nodes.map(n => getNodeValue(n, sourceKey)).filter(v => typeof v === 'number');
        if (values.length > 0) {
            const min = Math.min(...values);
            const max = Math.max(...values);

            // Access the underlying graph to set range
            // TODO: Move this to a central DataManager
            if (window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = { min, max };
            }
        }

        // 3. Apply to Nodes
        const updates = window.UPB.apply(nodes);

        // 4. Render Updates
        updates.forEach(update => {
            const node = nodes.find(n => n.id === update.id);
            if (node) {
                Object.keys(update.visuals).forEach(key => {
                    applyToNode(node, key, update.visuals[key]);
                });
            }
        });

        // Refresh graph
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }

        showToast(`Bound ${sourceKey} -> ${targetKey} via UPB`);
        console.log(`[CONTROL_BAR] UPB Binding Active: ${sourceKey} -> ${targetKey}`);
    }

    function getNodeValue(node, key) {
        // Direct property
        if (node[key] !== undefined) return node[key];

        // Nested in dimensions
        if (node.dimensions && node.dimensions[key] !== undefined) {
            return node.dimensions[key];
        }

        // Check common dimension mappings
        const dimMap = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };

        if (dimMap[key] && node.dimensions) {
            return node.dimensions[dimMap[key]];
        }

        return null;
    }

    function applyToNode(node, targetKey, value) {
        switch (targetKey) {
            case 'nodeSize':
                node.val = value;
                break;

            case 'hue':
                const currentColor = node.color || 'hsl(200, 70%, 50%)';
                node.color = setHSLComponent(currentColor, 'h', value);
                break;

            case 'saturation':
                node.color = setHSLComponent(node.color || 'hsl(200, 70%, 50%)', 's', value);
                break;

            case 'lightness':
                node.color = setHSLComponent(node.color || 'hsl(200, 70%, 50%)', 'l', value);
                break;

            case 'opacity':
                node.opacity = value;
                // Update color alpha if using rgba
                if (node.color && !node.color.startsWith('hsl')) {
                    node.color = setAlpha(node.color, value);
                }
                break;

            case 'xPosition':
                node.fx = value;
                break;

            case 'yPosition':
                node.fy = value;
                break;

            case 'zPosition':
                node.fz = value;
                break;

            case 'radius':
                // Position on a circle at given radius
                const angle = (node.fileIdx || Math.random() * 100) * 0.618 * Math.PI * 2;
                node.fx = Math.cos(angle) * value;
                node.fy = Math.sin(angle) * value;
                break;

            case 'charge':
                node.__charge = value;
                break;

            case 'mass':
                node.__mass = value;
                break;

            case 'pulseSpeed':
                node.__pulseSpeed = value;
                break;

            default:
                node[targetKey] = value;
        }
    }

    function setHSLComponent(colorStr, component, value) {
        // Parse existing HSL or convert
        let h = 200, s = 70, l = 50;

        const hslMatch = colorStr.match(/hsl\((\d+),\s*(\d+)%?,\s*(\d+)%?\)/);
        if (hslMatch) {
            h = parseInt(hslMatch[1]);
            s = parseInt(hslMatch[2]);
            l = parseInt(hslMatch[3]);
        }

        switch (component) {
            case 'h': h = value; break;
            case 's': s = value; break;
            case 'l': l = value; break;
        }

        return `hsl(${Math.round(h)}, ${Math.round(s)}%, ${Math.round(l)}%)`;
    }

    function setAlpha(colorStr, alpha) {
        // Simple alpha injection
        if (colorStr.startsWith('rgba')) {
            return colorStr.replace(/[\d.]+\)$/, `${alpha})`);
        }
        if (colorStr.startsWith('rgb')) {
            return colorStr.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        }
        return colorStr;
    }

    function resetMapping() {
        // Clear fixed positions
        const nodes = getTargetNodes();
        nodes.forEach(n => {
            delete n.fx;
            delete n.fy;
            delete n.fz;
            delete n.__charge;
            delete n.__mass;
            delete n.__pulseSpeed;
        });

        // Reheat simulation
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3ReheatSimulation();
        }

        showToast('Reset node positions and custom properties');
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function getSelectedNodeIds() {
        if (typeof SELECT !== 'undefined' && SELECT.getSelectedNodes) {
            return SELECT.getSelectedNodes().map(n => n.id);
        }
        if (typeof SELECTED_NODE_IDS !== 'undefined') {
            return Array.from(SELECTED_NODE_IDS);
        }
        return [];
    }

    function updateNodeCount() {
        const badge = document.getElementById('cb-node-count');
        if (!badge) return;

        const nodes = getTargetNodes();
        badge.textContent = nodes.length;
    }

    function showToast(msg) {
        if (typeof window.showToast === 'function') {
            window.showToast(msg);
        } else {
            console.log(`[CONTROL_BAR] ${msg}`);
        }
    }

    function toggle() {
        if (_container) {
            _container.classList.toggle('collapsed');
            _visible = !_container.classList.contains('collapsed');
        }
    }

    function show() {
        if (_container) {
            _container.classList.remove('collapsed');
            _visible = true;
        }
    }

    function hide() {
        if (_container) {
            _container.classList.add('collapsed');
            _visible = false;
        }
    }

    // =========================================================================
    // INIT
    // =========================================================================

    function init() {
        createUI();
        updateNodeCount();
        console.log('[CONTROL_BAR] Initialized');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        toggle,
        show,
        hide,
        applyMapping,
        resetMapping,
        createGroupFromSelection,
        removeGroup,
        get visible() { return _visible; },
        get config() { return _config; },
        get groups() { return _groups; },
        DATA_SOURCES,
        VISUAL_TARGETS,
        SCALES
    };

})();

// Auto-init when DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => CONTROL_BAR.init());
} else {
    // Small delay to ensure other modules are loaded
    setTimeout(() => CONTROL_BAR.init(), 100);
}


// ═══ MODULE: modules/main.js ═══
/**
 * MAIN.JS - MODULE INTEGRATION ENTRY POINT
 *
 * This file wires up all modules and provides backward compatibility
 * for HTML onclick handlers and global function calls.
 *
 * Module Loading Order (already handled by visualize_graph_webgl.py):
 * 1. performance.js       - Performance subsystem
 * 2. core.js              - Constants & utilities
 * 3. node-accessors.js    - Node property functions
 * 4. color-engine.js      - OKLCH color system
 * 5. refresh-throttle.js  - Throttled graph updates
 * 6. legend-manager.js    - Legend system
 * 7. data-manager.js      - Data access layer
 * 8. animation.js         - Layout & animation controller
 * 9. selection.js         - Selection system
 * 10. panels.js           - Panel management
 * 11. sidebar.js          - Sidebar controls
 * 12. edge-system.js      - Edge coloring & modes
 * 13. file-viz.js         - File visualization modes
 * 14. control-bar.js      - Visual mapping command bar
 * 15. main.js             - This file (wiring)
 * 16. app.js              - Legacy monolith (shrinking)
 */

;(function() {
    'use strict';

    // =========================================================================
    // VERIFY MODULE LOADING
    // =========================================================================

    const REQUIRED_MODULES = [
        { name: 'CORE', module: typeof CORE !== 'undefined' ? CORE : null },
        { name: 'NODE', module: typeof NODE !== 'undefined' ? NODE : null },
        { name: 'COLOR', module: typeof COLOR !== 'undefined' ? COLOR : null },
        { name: 'REFRESH', module: typeof REFRESH !== 'undefined' ? REFRESH : null },
        { name: 'LEGEND', module: typeof LEGEND !== 'undefined' ? LEGEND : null },
        { name: 'DATA', module: typeof DATA !== 'undefined' ? DATA : null },
        { name: 'LAYOUT', module: typeof LAYOUT !== 'undefined' ? LAYOUT : null },  // UI Layout Engine
        { name: 'ANIM', module: typeof ANIM !== 'undefined' ? ANIM : null },
        { name: 'SELECT', module: typeof SELECT !== 'undefined' ? SELECT : null },
        { name: 'PANELS', module: typeof PANELS !== 'undefined' ? PANELS : null },
        { name: 'SIDEBAR', module: typeof SIDEBAR !== 'undefined' ? SIDEBAR : null },
        { name: 'EDGE', module: typeof EDGE !== 'undefined' ? EDGE : null },
        { name: 'FILE_VIZ', module: typeof FILE_VIZ !== 'undefined' ? FILE_VIZ : null },
        { name: 'CONTROL_BAR', module: typeof CONTROL_BAR !== 'undefined' ? CONTROL_BAR : null },
        // STARS module removed - nodes ARE the stars
        { name: 'HUD', module: typeof HUD !== 'undefined' ? HUD : null },
        { name: 'DIMENSION', module: typeof DIMENSION !== 'undefined' ? DIMENSION : null }
    ];

    const loaded = REQUIRED_MODULES.filter(m => m.module !== null);
    const missing = REQUIRED_MODULES.filter(m => m.module === null);

    console.log(`[MAIN] Modules loaded: ${loaded.length}/${REQUIRED_MODULES.length}`);
    if (missing.length > 0) {
        console.warn('[MAIN] Missing modules:', missing.map(m => m.name).join(', '));
    }

    // =========================================================================
    // WINDOW-LEVEL EXPORTS FOR HTML ONCLICK HANDLERS
    // =========================================================================

    // Selection functions
    if (typeof SELECT !== 'undefined') {
        window.clearSelection = SELECT.clear;
        window.setSelection = SELECT.set;
        window.toggleSelection = SELECT.toggle;
        window.getSelectedNodes = SELECT.getSelectedNodes;
    }

    // Animation functions
    if (typeof ANIM !== 'undefined') {
        window.applyLayoutPreset = ANIM.applyLayout;
        window.stopAnimation = ANIM.stop;
    }

    // Edge functions
    if (typeof EDGE !== 'undefined') {
        window.setEdgeMode = EDGE.setMode;
        window.cycleEdgeMode = EDGE.cycleMode;
        window.applyEdgeMode = EDGE.apply;
    }

    // File visualization functions
    if (typeof FILE_VIZ !== 'undefined') {
        window.setFileVizMode = FILE_VIZ.setMode;
        window.toggleFileMode = FILE_VIZ.toggle;
    }

    // Panel functions
    if (typeof PANELS !== 'undefined') {
        window.openPanel = PANELS.open;
        window.closePanel = PANELS.close;
        window.togglePanel = PANELS.toggle;
    }

    // Sidebar functions
    if (typeof SIDEBAR !== 'undefined') {
        window.setColorMode = SIDEBAR.setColorMode;
        window.setLayout = SIDEBAR.setLayout;
    }

    // Refresh function
    if (typeof REFRESH !== 'undefined') {
        window.throttledRefresh = REFRESH.throttled;
    }

    // Control bar functions
    if (typeof CONTROL_BAR !== 'undefined') {
        window.toggleControlBar = CONTROL_BAR.toggle;
        window.showControlBar = CONTROL_BAR.show;
        window.hideControlBar = CONTROL_BAR.hide;
        window.applyVisualMapping = CONTROL_BAR.applyMapping;
    }

    // =========================================================================
    // CROSS-MODULE INTEGRATION
    // =========================================================================

    /**
     * Initialize all modules with data
     * NOTE: Currently unused - app.js calls module inits directly in setupControls()
     * Kept for potential future centralization
     * @deprecated Use direct module init calls instead
     */
    window.initializeModules = function(data) {
        console.log('[MAIN] Initializing modules with data...');

        // Initialize DATA module
        if (typeof DATA !== 'undefined' && DATA.init) {
            DATA.init(data);
            console.log('[MAIN] DATA module initialized');
        }

        // Initialize LEGEND module
        if (typeof LEGEND !== 'undefined' && LEGEND.init) {
            LEGEND.init(data.nodes, data.links || data.edges);
            console.log('[MAIN] LEGEND module initialized');
        }

        // Initialize SIDEBAR
        if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
            SIDEBAR.init();
            console.log('[MAIN] SIDEBAR module initialized');
        }

        // Initialize PANELS command bar
        if (typeof PANELS !== 'undefined' && PANELS.initCommandBar) {
            PANELS.initCommandBar();
            console.log('[MAIN] PANELS module initialized');
        }

        // Initialize LAYOUT (replaces HudLayoutManager from app.js)
        if (typeof LAYOUT !== 'undefined' && LAYOUT.init) {
            LAYOUT.init();
            console.log('[MAIN] LAYOUT module initialized (Ctrl+Shift+L for debug overlay)');
        }

        // STARS module removed - nodes ARE the stars

        // Initialize HUD (fade behavior)
        if (typeof HUD !== 'undefined' && HUD.setupFade) {
            HUD.setupFade();
            console.log('[MAIN] HUD module initialized');
        }

        // Initialize DIMENSION toggle
        if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) {
            DIMENSION.setup();
            console.log('[MAIN] DIMENSION module initialized');
        }

        console.log('[MAIN] Module initialization complete');
    };

    /**
     * Global refresh function that uses the throttled refresher
     */
    window.moduleRefresh = function() {
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }
    };

    // =========================================================================
    // MODULE HEALTH CHECK
    // =========================================================================

    window.checkModuleHealth = function() {
        console.log('=== MODULE HEALTH CHECK ===');
        REQUIRED_MODULES.forEach(({ name, module }) => {
            const status = module ? 'OK' : 'MISSING';
            const color = module ? 'color: green' : 'color: red';
            console.log(`%c[${status}] ${name}`, color);
        });

        if (typeof REFRESH !== 'undefined') {
            console.log('REFRESH stats:', REFRESH.stats);
        }

        console.log('===========================');
    };

    // =========================================================================
    // INITIALIZATION MESSAGE
    // =========================================================================

    console.log('[MAIN] Entry point loaded. Modules ready for initialization.');

})();


// ═══ MODULE: modules/circuit-breaker.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * CIRCUIT BREAKER MODULE - UI Control Validator
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Runtime self-test system that validates all visualization UI controls.
 * Acts as a quality guardian - detects binding failures, state issues,
 * and provides actionable fix recommendations.
 *
 * @module CIRCUIT
 * @version 2.0.0
 *
 * ## API
 *
 * | Method | Returns | Description |
 * |--------|---------|-------------|
 * | `runAll()` | `{passed, failed, total, results}` | Run all tests |
 * | `test(name)` | `{passed, error, trace}` | Test single control |
 * | `report()` | `Map<name, result>` | Get all results |
 * | `listTests()` | `string[]` | List test names |
 * | `diagnose()` | `{category, failures}[]` | Get categorized fix recommendations |
 * | `inventory()` | `string` | Markdown table of all controls |
 * | `inventoryJSON()` | `object[]` | JSON array of control definitions |
 *
 * ## CLI Integration
 *
 * ```bash
 * python tools/validate_ui.py <html_path> --verbose
 * ```
 *
 * ## Browser Console
 *
 * ```javascript
 * CIRCUIT.runAll()        // Run all tests
 * CIRCUIT.inventory()     // Print control table
 * CIRCUIT.diagnose()      // Get fix recommendations
 * ```
 *
 * @see tools/validate_ui.py - Headless test runner
 * @see CLAUDE.md - UI Controls section
 */

const CIRCUIT = (function() {
    'use strict';

    // Test results storage
    const _results = new Map();
    let _running = false;

    // =========================================================================
    // DIAGNOSTIC HELPERS
    // =========================================================================

    function getStateValue(path) {
        try {
            const parts = path.split('.');
            let obj = window;
            for (const part of parts) {
                if (obj === undefined || obj === null) return { exists: false, value: undefined };
                obj = obj[part];
            }
            return { exists: true, value: obj };
        } catch (e) {
            return { exists: false, value: undefined, error: e.message };
        }
    }

    function traceBinding(elementId, statePath, graphMethod) {
        const trace = {
            element: { id: elementId, found: false, hasListeners: false },
            state: { path: statePath, exists: false, value: undefined },
            graph: { method: graphMethod, callable: false },
            chain: []
        };

        // Check element
        const el = document.getElementById(elementId);
        if (el) {
            trace.element.found = true;
            trace.element.tagName = el.tagName;
            trace.element.type = el.type || el.tagName;
            trace.element.value = el.value;
            trace.chain.push(`✓ DOM element #${elementId} exists`);
        } else {
            trace.chain.push(`✗ DOM element #${elementId} NOT FOUND`);
            return trace;
        }

        // Check state
        if (statePath) {
            const stateResult = getStateValue(statePath);
            trace.state.exists = stateResult.exists;
            trace.state.value = stateResult.value;
            if (stateResult.exists) {
                trace.chain.push(`✓ State ${statePath} = ${JSON.stringify(stateResult.value)}`);
            } else {
                trace.chain.push(`✗ State ${statePath} is undefined`);
            }
        }

        // Check Graph method
        if (graphMethod && typeof Graph !== 'undefined' && Graph) {
            const method = Graph[graphMethod];
            trace.graph.callable = typeof method === 'function';
            if (trace.graph.callable) {
                trace.chain.push(`✓ Graph.${graphMethod}() is callable`);
            } else {
                trace.chain.push(`✗ Graph.${graphMethod}() NOT a function`);
            }
        }

        return trace;
    }

    // =========================================================================
    // TEST DEFINITIONS - Enhanced with diagnostics
    // =========================================================================

    const TESTS = [
        // --- EDGE CONTROLS ---
        {
            name: 'edge-opacity',
            type: 'slider',
            elementId: 'cfg-edge-opacity',
            statePath: 'APPEARANCE_STATE.edgeOpacity',
            graphMethod: 'linkOpacity',
            expected: 0.8,
            trigger: (el) => {
                el.value = '0.8';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeOpacity');
                return {
                    passed: state.exists && state.value === 0.8,
                    expected: 0.8,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0.6';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Ensure bindSlider() in app.js updates APPEARANCE_STATE.edgeOpacity and calls applyEdgeMode()'
        },
        {
            name: 'edge-width',
            type: 'slider',
            elementId: 'cfg-edge-width',
            statePath: 'APPEARANCE_STATE.edgeWidth',
            graphMethod: 'linkWidth',
            expected: 'changed',
            trigger: (el) => {
                // Store initial value, then change it
                window._edgeWidthBefore = getStateValue('APPEARANCE_STATE.edgeWidth').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeWidth');
                const changed = state.exists && state.value !== window._edgeWidthBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeWidthBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeWidthBefore;
            },
            fix: 'Check if cfg-edge-width has oninput handler that updates APPEARANCE_STATE.edgeWidth'
        },
        {
            name: 'edge-curvature',
            type: 'slider',
            elementId: 'cfg-edge-curve',
            statePath: 'APPEARANCE_STATE.edgeCurvature',
            graphMethod: 'linkCurvature',
            expected: 'changed',
            trigger: (el) => {
                window._edgeCurveBefore = getStateValue('APPEARANCE_STATE.edgeCurvature').value;
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeCurvature');
                const changed = state.exists && state.value !== window._edgeCurveBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeCurveBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeCurveBefore;
            },
            fix: 'Check if cfg-edge-curve has oninput handler that updates APPEARANCE_STATE.edgeCurvature'
        },

        // --- NODE CONTROLS ---
        {
            name: 'node-size',
            type: 'slider',
            elementId: 'cfg-node-size',
            statePath: 'APPEARANCE_STATE.nodeScale',
            graphMethod: 'nodeRelSize',
            expected: 'changed',
            trigger: (el) => {
                // Slider has max=4, so use valid value
                window._nodeSizeBefore = getStateValue('APPEARANCE_STATE.nodeScale').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeScale');
                const changed = state.exists && state.value !== window._nodeSizeBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._nodeSizeBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._nodeSizeBefore;
            },
            fix: 'Check if cfg-node-size has oninput handler that updates APPEARANCE_STATE.nodeScale'
        },
        {
            name: 'node-opacity',
            type: 'slider',
            elementId: 'cfg-node-opacity',
            statePath: 'APPEARANCE_STATE.nodeOpacity',
            graphMethod: 'nodeOpacity',
            expected: 0.5,
            trigger: (el) => {
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeOpacity');
                return {
                    passed: state.exists && state.value === 0.5,
                    expected: 0.5,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Check if cfg-node-opacity has oninput handler that updates APPEARANCE_STATE.nodeOpacity'
        },

        // --- TOGGLES ---
        {
            name: 'toggle-arrows',
            type: 'toggle',
            elementId: 'cfg-toggle-arrows',
            statePath: null,
            graphMethod: 'linkDirectionalArrowLength',
            expected: 'toggled',
            trigger: (el) => {
                window._arrowsActiveBefore = el.classList.contains('active');
                el.click();
            },
            validate: () => {
                const el = document.getElementById('cfg-toggle-arrows');
                if (!el) return { passed: false, error: 'Element not found' };
                const isActiveNow = el.classList.contains('active');
                return {
                    passed: isActiveNow !== window._arrowsActiveBefore,
                    expected: !window._arrowsActiveBefore,
                    actual: isActiveNow,
                    stateExists: true
                };
            },
            cleanup: (el) => {
                el.click();
                delete window._arrowsActiveBefore;
            },
            fix: 'Ensure toggle click handler toggles .active class and calls Graph.linkDirectionalArrowLength()'
        },

        // --- PHYSICS CONTROLS ---
        {
            name: 'physics-charge',
            type: 'slider',
            elementId: 'physics-charge',
            statePath: null,  // Bypasses PHYSICS_STATE, goes direct to Graph
            graphMethod: 'd3Force',
            expected: -200,
            trigger: (el) => {
                window._originalChargeValue = el.value;
                el.value = '-200';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                // Use window.Graph explicitly (Graph is exposed at app.js:1111)
                const G = window.Graph;
                if (!G) {
                    return { passed: false, error: 'Graph not defined', stateExists: false };
                }
                if (!G.d3Force) {
                    return { passed: false, error: 'Graph.d3Force not available', stateExists: false };
                }
                try {
                    const chargeForce = G.d3Force('charge');
                    if (!chargeForce || !chargeForce.strength) {
                        return { passed: false, error: 'charge force not configured', stateExists: false };
                    }
                    // d3-force strength() returns accessor function, not value
                    // Call it with dummy node to get actual strength
                    const strengthFn = chargeForce.strength();
                    const strength = typeof strengthFn === 'function' ? strengthFn({}, 0, []) : strengthFn;
                    return {
                        passed: strength === -200,
                        expected: -200,
                        actual: strength,
                        stateExists: true
                    };
                } catch (e) {
                    return { passed: false, error: e.message, stateExists: false };
                }
            },
            cleanup: (el) => {
                if (window._originalChargeValue) {
                    el.value = window._originalChargeValue;
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    delete window._originalChargeValue;
                }
            },
            fix: 'Ensure physics-charge slider calls Graph.d3Force("charge").strength(value) - check sidebar.js binding'
        },

        // NOTE: btn-edge-mode test removed - button never existed in template.html
        // The EDGE module handles missing button gracefully (line 443-446 of edge-system.js)

        // --- DIMENSION TOGGLE ---
        {
            name: 'dimension-toggle',
            type: 'button',
            elementId: 'btn-2d',
            statePath: 'DIMENSION_TRANSITION',
            graphMethod: null,
            expected: 'transition started',
            trigger: (el) => {
                // Animation takes 3s, so we check DIMENSION_TRANSITION flag (set immediately)
                window._transitionBefore = window.DIMENSION_TRANSITION;
                el.click();
            },
            validate: () => {
                // DIMENSION_TRANSITION is set true immediately on click, then false after 3s animation
                // We check that clicking triggered the transition (flag went true or animation completed)
                const transitionStarted = window.DIMENSION_TRANSITION === true ||
                                         window.DIMENSION_TRANSITION !== window._transitionBefore;
                return {
                    passed: transitionStarted || window.DIMENSION_TRANSITION === true,
                    expected: 'DIMENSION_TRANSITION = true (animation in progress)',
                    actual: window.DIMENSION_TRANSITION,
                    stateExists: typeof window.DIMENSION_TRANSITION !== 'undefined'
                };
            },
            cleanup: () => {
                // Don't click again - let animation complete naturally
                delete window._transitionBefore;
            },
            fix: 'Check if btn-2d click handler sets DIMENSION_TRANSITION and calls DIMENSION.toggle() - see dimension.js'
        },

        // --- VIEW MODE ---
        {
            name: 'view-mode-files',
            type: 'button',
            elementId: null,
            selector: '[data-mode="files"]',
            statePath: 'GRAPH_MODE',
            graphMethod: null,
            expected: 'files',
            trigger: (el) => {
                el.click();
            },
            validate: () => {
                const state = getStateValue('GRAPH_MODE');
                return {
                    passed: state.exists && state.value === 'files',
                    expected: 'files',
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: () => {
                const atomsBtn = document.querySelector('[data-mode="atoms"]');
                if (atomsBtn) atomsBtn.click();
            },
            fix: 'Ensure [data-mode="files"] button sets GRAPH_MODE = "files" and rebuilds graph'
        }
    ];

    // =========================================================================
    // TEST RUNNER - Enhanced with diagnostics
    // =========================================================================

    async function runTest(testDef) {
        const result = {
            name: testDef.name,
            type: testDef.type,
            passed: false,
            error: null,
            elementFound: false,
            // Enhanced diagnostics
            expected: testDef.expected,
            actual: null,
            stateExists: false,
            trace: null,
            fix: testDef.fix || null
        };

        try {
            // Find element
            const el = testDef.elementId
                ? document.getElementById(testDef.elementId)
                : document.querySelector(testDef.selector);

            if (!el) {
                result.error = 'Element not found';
                result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);
                return result;
            }
            result.elementFound = true;

            // Trace binding chain before test
            result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);

            // Run trigger
            testDef.trigger(el);

            // Small delay for async effects
            await new Promise(r => setTimeout(r, 50));

            // Validate with enhanced result
            const validateResult = testDef.validate();
            if (typeof validateResult === 'object') {
                result.passed = validateResult.passed;
                result.expected = validateResult.expected !== undefined ? validateResult.expected : testDef.expected;
                result.actual = validateResult.actual;
                result.stateExists = validateResult.stateExists;
                if (validateResult.error) result.error = validateResult.error;
            } else {
                result.passed = validateResult;
            }

            // Cleanup
            if (testDef.cleanup) {
                await new Promise(r => setTimeout(r, 50));
                testDef.cleanup(el);
            }

        } catch (err) {
            result.error = err.message;
            result.passed = false;
        }

        return result;
    }

    async function runAll() {
        if (_running) {
            console.warn('[CIRCUIT] Already running');
            return;
        }
        _running = true;
        _results.clear();

        console.log('%c[CIRCUIT] Starting control validation...', 'color: #4dd4ff; font-weight: bold');

        const startTime = performance.now();
        let passed = 0;
        let failed = 0;

        for (const test of TESTS) {
            const result = await runTest(test);
            _results.set(test.name, result);

            if (result.passed) {
                passed++;
                console.log(`  %c✓ ${test.name}`, 'color: #4ade80');
            } else {
                failed++;
                const reason = result.error || (!result.elementFound ? 'Element not found' : 'Validation failed');
                console.log(`  %c✗ ${test.name}: ${reason}`, 'color: #f87171');
                if (result.expected !== undefined && result.actual !== undefined) {
                    console.log(`    Expected: ${JSON.stringify(result.expected)}, Got: ${JSON.stringify(result.actual)}`);
                }
            }

            // Small delay between tests
            await new Promise(r => setTimeout(r, 100));
        }

        const elapsed = (performance.now() - startTime).toFixed(0);
        const total = passed + failed;
        const pct = ((passed / total) * 100).toFixed(1);

        console.log('%c─────────────────────────────────────', 'color: #666');
        if (failed === 0) {
            console.log(`%c[CIRCUIT] ALL PASS: ${passed}/${total} controls (${elapsed}ms)`,
                'color: #4ade80; font-weight: bold');
        } else {
            console.log(`%c[CIRCUIT] ${passed}/${total} passed (${pct}%), ${failed} FAILED (${elapsed}ms)`,
                'color: #f87171; font-weight: bold');
        }

        _running = false;
        return { passed, failed, total, results: Object.fromEntries(_results) };
    }

    async function test(name) {
        const testDef = TESTS.find(t => t.name === name);
        if (!testDef) {
            console.error(`[CIRCUIT] Unknown test: ${name}`);
            return null;
        }
        const result = await runTest(testDef);
        _results.set(name, result);
        return result;
    }

    function report() {
        return Object.fromEntries(_results);
    }

    function listTests() {
        return TESTS.map(t => ({ name: t.name, type: t.type }));
    }

    /**
     * Get detailed fix recommendations for all failures
     */
    function diagnose() {
        const failures = [];
        for (const [name, result] of _results) {
            if (!result.passed) {
                failures.push({
                    control: name,
                    type: result.type,
                    error: result.error,
                    expected: result.expected,
                    actual: result.actual,
                    elementFound: result.elementFound,
                    stateExists: result.stateExists,
                    trace: result.trace ? result.trace.chain : [],
                    fix: result.fix
                });
            }
        }
        return failures;
    }

    // =========================================================================
    // INVENTORY - Generate control tables for documentation
    // =========================================================================

    /**
     * Generate markdown table of all tested controls
     * @returns {string} Markdown table
     */
    function inventory() {
        const lines = [
            '| Control | Type | Element ID | State Path | Purpose |',
            '|---------|------|------------|------------|---------|'
        ];
        TESTS.forEach(t => {
            const purpose = t.fix ? t.fix.split(' - ')[0].replace(/^(Check|Ensure) /, '') : t.name;
            lines.push(`| ${t.name} | ${t.type} | \`${t.elementId || '-'}\` | \`${t.statePath || '-'}\` | ${purpose.substring(0, 40)} |`);
        });
        return lines.join('\n');
    }

    /**
     * Generate JSON inventory of all controls
     * @returns {Array} Control definitions
     */
    function inventoryJSON() {
        return TESTS.map(t => ({
            name: t.name,
            type: t.type,
            elementId: t.elementId,
            statePath: t.statePath,
            graphMethod: t.graphMethod,
            expected: t.expected
        }));
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        runAll,
        test,
        report,
        listTests,
        diagnose,
        inventory,
        inventoryJSON,
        get isRunning() { return _running; },
        TESTS
    };
})();

// Global shortcut
window.CIRCUIT = CIRCUIT;

console.log('[Module] CIRCUIT loaded - UI control validator with diagnostics');


// ═══ MAIN APPLICATION ═══
window.process = window.process || { env: { NODE_ENV: "production" } };
window.global = window.global || window;
// UMD globals: THREE, ForceGraph3D, pako already loaded
// Three.js addons attach to THREE global: THREE.ConvexGeometry
const ConvexGeometry = THREE.ConvexGeometry;
// Note: Post-processing (bloom) removed for simplicity - addons not available in r149+ UMD builds

// COMPRESSED_PAYLOAD: Base64-encoded gzipped JSON data
const COMPRESSED_PAYLOAD = "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";

// --------------------------------------------------------------------
// WEB WORKER: JSON Parsing Only (Decompression in main thread)
// OPTIMIZED: Main thread uses already-loaded pako, no duplicate CDN fetch
// --------------------------------------------------------------------
const workerScript = `
        self.onmessage = function(e) {
            const jsonStr = e.data;
            try {
                self.postMessage({status: 'PARSING...'});
                const data = JSON.parse(jsonStr);
                self.postMessage({status: 'ANALYZING COSMOS...', result: data});
            } catch (err) {
                self.postMessage({error: err.message});
            }
        };
        `;

// Initialize Worker (minimal - no pako needed)
const blob = new Blob([workerScript], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));

// OPTIMIZED: Decompress in main thread using already-loaded pako
function decompressPayload(payload) {
    // Update status
    const statusEl = document.getElementById('loader-status');
    if (statusEl) statusEl.innerText = 'DECOMPRESSING...';

    // 1. Decode Base64
    const charData = atob(payload);
    const binData = new Uint8Array(charData.length);
    for (let i = 0; i < charData.length; i++) {
        binData[i] = charData.charCodeAt(i);
    }

    // 2. Inflate using main thread's pako (already loaded from CDN)
    if (statusEl) statusEl.innerText = 'INFLATING...';
    const jsonStr = pako.inflate(binData, { to: 'string' });

    return jsonStr;
}

let FULL_GRAPH = null;
let Graph = null;
let DM = null;  // DataManager instance - initialized in initGraph()
let Legend = null;  // LegendManager instance - initialized in initGraph()
let CURRENT_DENSITY = 1; // Default: show all nodes
let ACTIVE_DATAMAPS = new Set();
let DATAMAP_CONFIGS = [];
let DATAMAP_INDEX = {};
let DATAMAP_UI = new Map();
let HOVERED_NODE = null;
// SELECTED_NODE_IDS - provided by selection.js module (getter to SELECT.ids)
let DATASET_KEY = 'default';
let GROUPS_STORAGE_KEY = 'collider_groups_default';
let GROUPS = [];
let ACTIVE_GROUP_ID = null;
// MARQUEE_ACTIVE, MARQUEE_START, MARQUEE_ADDITIVE, LAST_MARQUEE_END_TS - provided by selection.js module
let SELECTION_BOX = null;
const SELECTION_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
const GROUP_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
let SPACE_PRESSED = false;
let IS_3D = true;
// Expose for circuit-breaker tests (dimension-toggle test checks window.IS_3D)
Object.defineProperty(window, 'IS_3D', {
    get: () => IS_3D,
    set: (v) => { IS_3D = v; },
    configurable: true
});
let DIMENSION_TRANSITION = false;
// Expose for dimension.js module and circuit-breaker tests
Object.defineProperty(window, 'DIMENSION_TRANSITION', {
    get: () => DIMENSION_TRANSITION,
    set: (v) => { DIMENSION_TRANSITION = v; },
    configurable: true
});
// STARFIELD & BLOOM - REMOVED (nodes ARE the stars, post-processing not in r149+ UMD builds)
// EDGE_MODE - provided by edge-system.js module
let EDGE_DEFAULT_OPACITY = null;  // Initialized from appearance.tokens at runtime (token value: 0.08)

// PERF_MONITOR - provided by perf-monitor.js module (window.PERF, window.PERF_MONITOR)

// Initialize after DOM ready
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => PERF_MONITOR.init(), 100);
    // Initialize SidebarManager facade for sidebar controls
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
        SIDEBAR.init();
    }
});
let DEFAULT_LINK_DISTANCE = null;

// =================================================================
// THEME CONFIGURATION: Loaded from payload at runtime
// =================================================================
let THEME_CONFIG = {
    available: ['dark'],
    default: 'dark',
    current: 'dark',
    colors: {
        edge: {},
        viz: {},
        console: {},
        schemes: {}
    }
};

// Default color configs - will be overridden by payload tokens
// Edge mode configuration - populated from appearance.tokens at runtime
// Fallback values are defined in appearance.tokens.json:131-204
let EDGE_MODE_CONFIG = {
    resolution: {},
    weight: {},
    confidence: {},
    width: {},
    dim: {},
    opacity: null
};
// Edge type colors - populated from theme.tokens.json:501-512 at runtime
let EDGE_COLOR_CONFIG = {};
// FILE_COLOR_CONFIG, EDGE_RANGES, NODE_FILE_INDEX - provided by modules (file-viz.js, edge-system.js)
let NODE_COLOR_CONFIG = { tier: {}, ring: {}, unknown: '#666666' };

// Console logging colors - populated from theme config
let CONSOLE_COLORS = {
    success: '#4ade80',
    error: '#f87171',
    warning: '#ffaa00',
    info: '#4dd4ff'
};

// Viz colors for canvas and fallbacks - populated from theme config
let VIZ_COLORS = {
    canvasBg: '#03040a',
    nodeFallback: '#888888',
    edgeFallback: '#333333',
    groupHalo: '#88d0ff'
};
let FLOW_CONFIG = {};  // Flow mode settings from THE REMOTE CONTROL
window.GRAPH_MODE = 'atoms'; // atoms | files | hybrid - on window for FILE_VIZ access

// Layout stability: cache node positions to prevent re-randomization on toggles
let NODE_POSITION_CACHE = new Map();
let LAYOUT_FROZEN = false;  // When true, don't reheat simulation
let HINTS_ENABLED = true;   // Show mode toasts

// FILE_GRAPH, FILE_NODE_IDS, EXPANDED_FILES, FILE_EXPAND_MODE - provided by file-viz.js module
let LAST_FILTER_SUMMARY = null;
let FILE_NODE_POSITIONS = new Map();
let NODE_COLOR_MODE = 'tier';
let COLOR_TWEAKS = {
    hueShift: 0,
    chromaScale: 1,
    lightnessShift: 0
};
let VIS_FILTERS = {
    tiers: new Set(),
    rings: new Set(),
    roles: new Set(),
    edges: new Set(),
    families: new Set(),  // Atom families: LOG, DAT, ORG, EXE, EXT
    files: new Set(),     // File-based filtering
    layers: new Set(),    // D2_LAYER: Interface, Application, Core, Infrastructure, Test
    effects: new Set(),   // D6_EFFECT: Pure, Read, Write, ReadWrite
    edgeFamilies: new Set(), // Edge families: Structural, Dependency, Inheritance, Semantic, Temporal
    metadata: {
        showLabels: true,
        showFilePanel: true,
        showReportPanel: true,
        showEdges: true
    }
};
let SIDEBAR_STATE = {
    open: false,
    locked: false
};
let APPEARANCE_STATE = {
    nodeScale: 1,
    nodeOpacity: 1,
    labelSize: 1,
    showLabels: true,
    highlightSelected: true,
    edgeOpacity: null,
    edgeWidth: 1,
    edgeCurvature: 0,
    showArrows: false,
    gradientEdges: true,
    boundaryFill: null,
    boundaryWire: null,
    backgroundBase: null,
    backgroundBrightness: 1,
    fileLightness: null,
    clusterStrength: null,
    currentPreset: 'tier',
    colorMode: 'tier',
    sizeMode: 'fanout',
    edgeMode: 'type',
    // Amplifier: Power law exponent for visual contrast
    // γ=1 linear, γ>1 amplifies differences, γ<1 compresses
    amplifier: 1.0,
    amplifierTarget: 'all'  // 'all', 'edges', 'nodes', 'opacity'
};
// Expose for modules and circuit-breaker tests
window.APPEARANCE_STATE = APPEARANCE_STATE;

// =====================================================================
// FILE BOUNDARY & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
// fileBoundaryMeshes, fileMode, fileVizMode - provided by file-viz.js module
let originalNodeColors = new Map();
let clusterForceActive = false;
let hullRedrawTimer = null;
let hullRedrawAttempts = 0;
const originalColorsForDim = new Map();
let flowMode = false; // Hoisted from line 7333

// REGISTRY - provided by registry.js module (window.REGISTRY)


// =================================================================
// GLOBAL CONSTANTS (Hoisted for safety)
// =================================================================
const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

// OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
const PENDULUM = {
    hue: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,        // Set from appearance.tokens
        gravity: null,        // Set from appearance.tokens
        length: 1.0,
        rotationSpeed: null   // Set from appearance.tokens
    },
    chroma: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,
        gravity: null,
        length: 1.0,
        center: null,
        amplitude: null
    },
    lightness: {
        phase: 0,
        speed: null,
        center: null,
        amplitude: null
    },
    ripple: {
        speed: null,
        scale: null
    },
    currentHue: Math.random() * 360,
    lastTime: 0,
    running: false
};
// =====================================================================
// HOVER & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
let _lastHoveredNodeId = null;
const selectionOriginals = new Map();

// amplify, amplifyContrast - provided by core.js module

// =====================================================================
// DATA MANAGER: Minimal runtime checks for deterministic self-test/parity
// =====================================================================

// =====================================================================
// COLOR ORCHESTRATOR: Centralized Color Intelligence System
// =====================================================================
// SINGLE SOURCE OF TRUTH for ALL colors in the visualization.
// Everything reads from here. OKLCH transforms apply here.
// =====================================================================
const ColorOrchestrator = {
    // =================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =================================================================
    palette: {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    },

    // =================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =================================================================
    transform: {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    },

    // =================================================================
    // INTERVAL MAPPINGS: For numeric data → color gradients
    // =================================================================
    intervals: {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        }
    },

    // =================================================================
    // CORE API: Get color with transforms applied
    // =================================================================
    get(dimension, category) {
        const base = this.palette[dimension]?.[category];
        if (!base) return this._toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray

        return this._applyTransform(base);
    },

    // Get color for a numeric value using interval mapping
    getInterval(intervalName, value) {
        const interval = this.intervals[intervalName];
        if (!interval) return this._toHex({ h: 0, c: 0.02, l: 0.40 });

        const stops = interval.stops;
        const v = Math.max(0, Math.min(1, value));

        // Find surrounding stops
        let lower = stops[0];
        let upper = stops[stops.length - 1];

        for (let i = 0; i < stops.length - 1; i++) {
            if (v >= stops[i].value && v <= stops[i + 1].value) {
                lower = stops[i];
                upper = stops[i + 1];
                break;
            }
        }

        // Interpolate between stops
        const range = upper.value - lower.value;
        const t = range > 0 ? (v - lower.value) / range : 0;

        const interpolated = {
            h: lower.h + (upper.h - lower.h) * t,
            c: lower.c + (upper.c - lower.c) * t,
            l: lower.l + (upper.l - lower.l) * t
        };

        return this._applyTransform(interpolated);
    },

    // Get raw OKLCH values (for advanced use)
    getRaw(dimension, category) {
        return this.palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
    },

    // Get all categories for a dimension
    getCategories(dimension) {
        return Object.keys(this.palette[dimension] || {});
    },

    // Get label for a category
    getLabel(dimension, category) {
        return this.palette[dimension]?.[category]?.label || category;
    },

    // =================================================================
    // TRANSFORM CONTROLS: Update OKLCH state
    // =================================================================
    setTransform(key, value) {
        if (key in this.transform) {
            this.transform[key] = value;
            this._notifySubscribers('transform-change', { key, value });
        }
    },

    setAllTransforms(transforms) {
        Object.assign(this.transform, transforms);
        this._notifySubscribers('transform-change', transforms);
    },

    resetTransforms() {
        this.transform = {
            hueShift: 0,
            chromaScale: 1.0,
            lightnessShift: 0,
            amplifier: 1.0
        };
        this._notifySubscribers('transform-change', this.transform);
    },

    // =================================================================
    // INTERNAL: Apply OKLCH transforms and convert to hex
    // =================================================================
    _applyTransform(oklch) {
        const t = this.transform;

        // Apply transforms
        let h = (oklch.h + t.hueShift + 360) % 360;
        let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
        let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

        // Apply amplifier to chroma for contrast
        if (t.amplifier !== 1) {
            c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
        }

        return this._toHex({ h, c, l });
    },

    _toHex(oklch) {
        // OKLCH to sRGB conversion (simplified)
        // Using CSS color conversion would be ideal, but this approximation works
        const { h, c, l } = oklch;

        // Convert OKLCH to approximate RGB
        const hRad = h * Math.PI / 180;
        const a = c * Math.cos(hRad);
        const b = c * Math.sin(hRad);

        // Simplified OKLab to linear RGB (approximate)
        const L = l;
        const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

        const l3 = l_ * l_ * l_;
        const m3 = m_ * m_ * m_;
        const s3 = s_ * s_ * s_;

        let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
        let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
        let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

        // Clamp and convert to sRGB
        const toSRGB = (x) => {
            x = Math.max(0, Math.min(1, x));
            return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
        };

        r = Math.round(toSRGB(r) * 255);
        g = Math.round(toSRGB(g) * 255);
        bl = Math.round(toSRGB(bl) * 255);

        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        bl = Math.max(0, Math.min(255, bl));

        return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
    },

    // =================================================================
    // REACTIVE SUBSCRIPTIONS
    // =================================================================
    _subscribers: [],

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    },

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    },

    // =================================================================
    // DEBUG: Log current state
    // =================================================================
    debug() {
        console.log('[ColorOrchestrator] Transform state:', this.transform);
        console.log('[ColorOrchestrator] Palette dimensions:', Object.keys(this.palette));
        console.log('[ColorOrchestrator] Interval mappings:', Object.keys(this.intervals));
    }
};

// Global alias for convenience
const Color = ColorOrchestrator;



// =====================================================================
// FLOATING PANEL CONTROL SYSTEM - CONSOLIDATED INTO modules/panels.js
// =====================================================================
// openPanel, closePanel, togglePanel, initCommandBar - ALL IN panels.js
// (backward compat shims in panels.js)


// Populate filter chips in floating panels
function populateFilterChips() {
    if (!DM) return;  // ALL DATA FROM DM

    // Use DM cached aggregations (O(1) lookups)
    const tierCounts = DM.getTierCounts();
    const ringCounts = DM.getRingCounts();
    const edgeCounts = DM.getEdgeTypeCounts();

    buildChipGroup('chips-tiers', tierCounts, VIS_FILTERS.tiers, refreshGraph);
    buildChipGroup('chips-rings', ringCounts, VIS_FILTERS.rings, refreshGraph);
    buildChipGroup('chips-edges', edgeCounts, VIS_FILTERS.edges, refreshGraph);
}

// renderLegendSection, renderAllLegends - MOVED TO modules/legend-manager.js
// (debounce is now built into legend-manager.js, no monkey-patching needed)

// =====================================================================
// HUD LAYOUT MANAGER: MIGRATED TO modules/layout.js
// =====================================================================
// HudLayoutManager (390 lines) has been migrated to modules/layout.js
// which provides the LAYOUT module with:
//   - All original panel placement functionality
//   - NEW: Toast/control-bar collision detection
//   - NEW: Min-width graph validation
//   - NEW: Debug overlay (Ctrl+Shift+L)
//   - NEW: Component registration system
//
// Backward compatibility: window.HudLayoutManager = LAYOUT (alias)
// =====================================================================

worker.onmessage = function (e) {
    if (e.data.status && !e.data.result) {
        document.getElementById('loader-status').innerText = e.data.status;
    } else if (e.data.error) {
        document.getElementById('loader-status').innerText = "ERROR: " + e.data.error;
        document.getElementById('loader-status').style.color = "red";
    } else if (e.data.result) {
        FULL_GRAPH = e.data.result;
        FILE_GRAPH = null;
        FILE_NODE_POSITIONS = new Map();
        EXPANDED_FILES.clear();
        window.GRAPH_MODE = 'atoms';
        document.getElementById('loader-status').innerText = "INITIALIZING VISUALIZATION...";
        initGraph(FULL_GRAPH);
    }
};

// Start Work: Decompress in main thread, then send JSON string to worker for parsing
try {
    const jsonStr = decompressPayload(COMPRESSED_PAYLOAD);
    worker.postMessage(jsonStr);
} catch (err) {
    document.getElementById('loader-status').innerText = "ERROR: " + err.message;
    document.getElementById('loader-status').style.color = "red";
    console.error('[Decompression] Failed:', err);
}

// =====================================================================
// 2D CANVAS FALLBACK: Used when WebGL is unavailable
// =====================================================================
function initFallback2D(container, graphData, fullData) {
    console.log('[2D Fallback] Initializing canvas renderer');
    showToast('WebGL unavailable - using 2D fallback');

    const loader = document.getElementById('loader');
    if (loader) loader.style.display = 'none';

    // Update HUD stats even in 2D fallback mode
    updateHudStats(fullData);

    container.innerHTML = '';
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.background = VIZ_COLORS.canvasBg;
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    let width = container.clientWidth || window.innerWidth;
    let height = container.clientHeight || window.innerHeight;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    // Layout: simple force-directed positions
    const nodes = graphData.nodes || [];
    const links = graphData.links || [];
    const nodeMap = new Map();

    nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        const radius = Math.min(width, height) * 0.35;
        n._x = width / 2 + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);
        n._y = height / 2 + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5);
        n._vx = 0;
        n._vy = 0;
        nodeMap.set(n.id, n);
    });

    // Camera state
    let camX = 0, camY = 0, zoom = 1;
    let dragging = false, lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mousemove', e => {
        if (!dragging) return;
        camX += (e.clientX - lastX) / zoom;
        camY += (e.clientY - lastY) / zoom;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        zoom = Math.max(0.1, Math.min(5, zoom * factor));
    }, { passive: false });

    function toScreen(x, y) {
        return {
            x: (x + camX - width / 2) * zoom + width / 2,
            y: (y + camY - height / 2) * zoom + height / 2
        };
    }

    function parseColor(c) {
        if (typeof c === 'number') {
            return '#' + c.toString(16).padStart(6, '0');
        }
        return c || VIZ_COLORS.nodeFallback;
    }

    function render() {
        ctx.fillStyle = VIZ_COLORS.canvasBg;
        ctx.fillRect(0, 0, width, height);

        // Draw edges
        ctx.strokeStyle = 'rgba(100,100,100,0.3)';
        ctx.lineWidth = 0.5;
        for (const link of links) {
            const src = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
            const tgt = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);
            if (!src || !tgt) continue;
            const p1 = toScreen(src._x, src._y);
            const p2 = toScreen(tgt._x, tgt._y);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // Draw nodes
        for (const node of nodes) {
            const p = toScreen(node._x, node._y);
            const r = Math.max(2, (node.val || 1) * zoom * 0.5);
            ctx.fillStyle = parseColor(node.color);
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Info overlay
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '11px monospace';
        ctx.fillText('2D Fallback Mode (WebGL unavailable)', 10, 20);
        ctx.fillText('Drag to pan, scroll to zoom', 10, 35);
        ctx.fillText(`Nodes: ${nodes.length} | Edges: ${links.length}`, 10, 50);

        requestAnimationFrame(render);
    }

    function resize() {
        width = container.clientWidth || window.innerWidth;
        height = container.clientHeight || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', resize);
    render();

    // Initialize DataManager (required for UI controls)
    DM = new DataManager();
    DM.init(fullData);
    window.DM = DM;

    // Setup UI controls (they work independently of 3D graph)
    setupControls(fullData);
    setupReport(fullData);
    setupAIInsights(fullData);
    setupMetrics(fullData);
    setupHudFade();
    setupDimensionToggle();

    // Update stats with actual node/edge counts
    updateHudStats(graphData);
}

function initGraph(data) {
    // =================================================================
    // DATA MANAGER: Self-test + parity checks
    // =================================================================
    DM = new DataManager();
    DM.init(data);
    window.DM = DM;
    DM.selfTest();
    runDmParity(DM, data);

    // =================================================================
    // HUD STATS: Populate header and stats panel with graph data
    // =================================================================
    updateHudStats(data);

    // =================================================================
    // SIDEBAR: Populate filter chips from loaded data
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.populateFilterChips) {
        SIDEBAR.populateFilterChips(data);
    }

    // =================================================================
    // SIDEBAR: Apply deferred view mode (files mode if saved in localStorage)
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.applyDeferredViewMode) {
        SIDEBAR.applyDeferredViewMode();
    }

    // =================================================================
    // TOKEN-DRIVEN CONFIG: Extract from payload
    // =================================================================
    const physicsConfig = data.physics || {};
    const appearanceConfig = data.appearance || {};
    window.APPEARANCE_CONFIG = appearanceConfig;

    // =================================================================
    // THEME CONFIG: Load theme configuration for runtime switching
    // =================================================================
    if (data.theme_config) {
        THEME_CONFIG = {
            ...THEME_CONFIG,
            available: data.theme_config.available || ['dark'],
            default: data.theme_config.default || 'dark',
            current: data.theme_config.default || 'dark',
            colors: data.theme_config.colors || THEME_CONFIG.colors
        };

        // Apply edge colors from theme config
        if (THEME_CONFIG.colors.edge) {
            EDGE_COLOR_CONFIG = { ...EDGE_COLOR_CONFIG, ...THEME_CONFIG.colors.edge };
        }

        // Apply viz colors from theme config
        if (THEME_CONFIG.colors.viz) {
            const viz = THEME_CONFIG.colors.viz;
            VIZ_COLORS = {
                canvasBg: viz['canvas-bg'] || VIZ_COLORS.canvasBg,
                nodeFallback: viz['node-fallback'] || VIZ_COLORS.nodeFallback,
                edgeFallback: viz['edge-fallback'] || VIZ_COLORS.edgeFallback,
                groupHalo: viz['group-halo'] || VIZ_COLORS.groupHalo
            };
        }

        // Apply console colors from theme config
        if (THEME_CONFIG.colors.console) {
            CONSOLE_COLORS = { ...CONSOLE_COLORS, ...THEME_CONFIG.colors.console };
        }

        console.log(`%c[Theme] Loaded: ${THEME_CONFIG.available.join(', ')}`, `color: ${CONSOLE_COLORS.info}; font-weight: bold`);
    }
    const simulation = physicsConfig.simulation || {};
    // background.bloom, background.stars - REMOVED (post-processing not available in r149+ UMD builds)
    // renderConfig, highlightConfig - REMOVED (unused, features not implemented)
    FLOW_CONFIG = appearanceConfig.flow_mode || {};

    // Merge animation tokens into PENDULUM (T004)
    const animationConfig = appearanceConfig.animation || {};
    if (animationConfig.hue) {
        PENDULUM.hue.damping = animationConfig.hue.damping ?? 0.9995;
        PENDULUM.hue.gravity = animationConfig.hue.speed ?? 0.0008;
        PENDULUM.hue.rotationSpeed = animationConfig.hue.rotation ?? 0.8;
    }
    if (animationConfig.chroma) {
        PENDULUM.chroma.damping = animationConfig.chroma.damping ?? 0.998;
        PENDULUM.chroma.gravity = animationConfig.chroma.gravity ?? 0.0004;
        PENDULUM.chroma.center = animationConfig.chroma.center ?? 0.32;
        PENDULUM.chroma.amplitude = animationConfig.chroma.amplitude ?? 0.08;
    }
    if (animationConfig.lightness) {
        PENDULUM.lightness.speed = animationConfig.lightness.speed ?? 0.02;
        PENDULUM.lightness.center = animationConfig.lightness.center ?? 82;
        PENDULUM.lightness.amplitude = animationConfig.lightness.amplitude ?? 10;
    }
    if (animationConfig.ripple) {
        PENDULUM.ripple.speed = animationConfig.ripple.speed ?? 0.035;
        PENDULUM.ripple.scale = animationConfig.ripple.scale ?? 200;
    }
    const edgeModes = appearanceConfig.edge_modes || {};
    EDGE_MODE_CONFIG = {
        resolution: edgeModes.resolution || { internal: '#4dd4ff', external: '#ff6b6b', unresolved: '#9aa0a6', unknown: '#666666' },
        weight: edgeModes.weight || { hue_min: 210, hue_max: 50, saturation: 45, lightness: 42 },
        confidence: edgeModes.confidence || { hue_min: 20, hue_max: 120, saturation: 45, lightness: 44 },
        width: edgeModes.width || { base: 0.6, weight_scale: 2.0, confidence_scale: 1.5 },
        dim: edgeModes.dim || { interfile_factor: 0.25 },
        opacity: (typeof edgeModes.opacity === 'number') ? edgeModes.opacity : 0.08
    };

    FILE_COLOR_CONFIG = Object.assign({}, FILE_COLOR_CONFIG, appearanceConfig.file_color || {});
    // Token value 0.08 from appearance.tokens.json:202, fallback only if token system fails
    EDGE_DEFAULT_OPACITY =
        (typeof EDGE_MODE_CONFIG.opacity === 'number') ? EDGE_MODE_CONFIG.opacity : 0.08;
    const boundaryConfig = appearanceConfig.boundary || {};
    APPEARANCE_STATE.edgeOpacity = EDGE_DEFAULT_OPACITY;
    APPEARANCE_STATE.boundaryFill = boundaryConfig.fill_opacity ?? APPEARANCE_STATE.boundaryFill;
    APPEARANCE_STATE.boundaryWire = boundaryConfig.wire_opacity ?? APPEARANCE_STATE.boundaryWire;
    const background = appearanceConfig.background || {};
    APPEARANCE_STATE.backgroundBase = background.color || '#000000';
    APPEARANCE_STATE.fileLightness = FILE_COLOR_CONFIG.lightness ?? APPEARANCE_STATE.fileLightness;
    const nodeColor = appearanceConfig.node_color || {};
    NODE_COLOR_CONFIG = {
        tier: nodeColor.tier || {},
        ring: nodeColor.ring || {},
        unknown: nodeColor.unknown || '#666666'
    };
    const edgeColor = appearanceConfig.edge_color || {};
    EDGE_COLOR_CONFIG = {
        default: edgeColor.default || '#333333',
        calls: edgeColor.calls || '#4dd4ff',
        contains: edgeColor.contains || '#00ff9d',
        uses: edgeColor.uses || '#ffb800',
        imports: edgeColor.imports || '#9aa0a6',
        inherits: edgeColor.inherits || '#ff6b6b'
    };

    // Initial Filter: show full graph
    const filtered = filterGraph(data, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);

    // ═══════════════════════════════════════════════════════════════════
    // DATA PREP FOR ANIMATIONS: Assign file indices for wave patterns
    // ═══════════════════════════════════════════════════════════════════
    const fileMap = new Map();
    let nextFileIdx = 0;
    filtered.nodes.forEach(node => {
        // Extract filename from ID (assuming file path is in ID or explicit file prop)
        const file = node.file || (node.id.includes('/') ? node.id.split(':')[0] : 'unknown');
        if (!fileMap.has(file)) fileMap.set(file, nextFileIdx++);
        node.file_idx = fileMap.get(file);
    });

    const div = document.getElementById('3d-graph');

    // ═══════════════════════════════════════════════════════════════════
    // GRADIENT EDGES: Custom THREE.js lines with vertex colors
    // Creates beautiful gradients from source to target node colors
    // ═══════════════════════════════════════════════════════════════════
    let GRADIENT_EDGES_ENABLED = true;  // Toggle for gradient edges

    function hexToRgb(hex) {
        // Convert hex color to RGB array [0-1, 0-1, 0-1]
        if (typeof hex === 'number') {
            return [
                ((hex >> 16) & 255) / 255,
                ((hex >> 8) & 255) / 255,
                (hex & 255) / 255
            ];
        }
        if (typeof hex === 'string') {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                ((num >> 16) & 255) / 255,
                ((num >> 8) & 255) / 255,
                (num & 255) / 255
            ];
        }
        return [0.5, 0.5, 0.5];  // Default gray
    }

    function createGradientEdge(link) {
        // Get source and target nodes
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        // Get colors from nodes (using current color mode)
        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        // Create geometry with 2 vertices
        const geometry = new THREE.BufferGeometry();

        // Positions will be updated by linkPositionUpdate
        const positions = new Float32Array([0, 0, 0, 0, 0, 0]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Vertex colors: source color at start, target color at end
        const colors = new Float32Array([
            srcRgb[0], srcRgb[1], srcRgb[2],  // Source vertex color
            tgtRgb[0], tgtRgb[1], tgtRgb[2]   // Target vertex color
        ]);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Material with vertex colors
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: link.opacity ?? EDGE_DEFAULT_OPACITY,
            linewidth: 1  // Note: linewidth > 1 only works on some platforms
        });

        return new THREE.Line(geometry, material);
    }

    function updateGradientEdge(line, link, coords) {
        // Update line positions
        const posArr = line.geometry.attributes.position.array;
        posArr[0] = coords.start.x || 0;
        posArr[1] = coords.start.y || 0;
        posArr[2] = coords.start.z || 0;
        posArr[3] = coords.end.x || 0;
        posArr[4] = coords.end.y || 0;
        posArr[5] = coords.end.z || 0;
        line.geometry.attributes.position.needsUpdate = true;

        // Update colors based on current node colors
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        const colArr = line.geometry.attributes.color.array;
        colArr[0] = srcRgb[0]; colArr[1] = srcRgb[1]; colArr[2] = srcRgb[2];
        colArr[3] = tgtRgb[0]; colArr[4] = tgtRgb[1]; colArr[5] = tgtRgb[2];
        line.geometry.attributes.color.needsUpdate = true;
    }

    // Refresh all gradient edge colors (call when node color mode changes)
    function refreshGradientEdgeColors() {
        if (!GRADIENT_EDGES_ENABLED || !Graph) return;
        // Force rebuild of all link objects to update colors
        Graph.linkThreeObject(link => createGradientEdge(link));
    }

    // Make it globally accessible for color mode changes
    window.refreshGradientEdgeColors = refreshGradientEdgeColors;

    // TOKEN-DRIVEN: Read render config from THE REMOTE CONTROL
    const renderConfig = appearanceConfig.render || {};
    const dimensions = renderConfig.dimensions || 3;
    const nodeRes = renderConfig.nodeResolution || 8;

    try {
        Graph = ForceGraph3D({
            rendererConfig: {
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            }
        })
            (div)
            .graphData(filtered)
            .numDimensions(dimensions)
            .backgroundColor(toColorNumber(background.color, 0x000000))
            .nodeLabel('name')
            .nodeColor(node => toColorNumber(node.color, 0x888888))
            .nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale)
            // ═══════════════════════════════════════════════════════════════════
            // GRADIENT EDGES: Custom THREE.Line with vertex colors
            // Each edge smoothly transitions from source node color to target node color
            // ═══════════════════════════════════════════════════════════════════
            .linkThreeObject(link => GRADIENT_EDGES_ENABLED ? createGradientEdge(link) : null)
            .linkPositionUpdate((line, coords, link) => {
                if (GRADIENT_EDGES_ENABLED && line) {
                    updateGradientEdge(line, link, coords);
                }
                return true;  // Keep default behavior for non-gradient
            })
            .linkColor(link => GRADIENT_EDGES_ENABLED ? null : toColorNumber(getEdgeColor(link), 0x222222))
            .linkOpacity(link => GRADIENT_EDGES_ENABLED ? 0 : (link.opacity ?? EDGE_DEFAULT_OPACITY))
            .nodeThreeObjectExtend(true)
            .nodeThreeObject(node => ensureNodeOverlays(node))
            .nodeResolution(Math.max(nodeRes, 16))
            .linkResolution(6)
            .showNavInfo(false)
            .warmupTicks(simulation.warmupTicks || 30)
            .cooldownTicks(simulation.cooldownTicks || 0)
            .onNodeHover(node => handleNodeHover(node, data))
            .onNodeClick((node, event) => handleNodeClick(node, event))
            .onBackgroundClick(() => maybeClearSelection())
            // ═══════════════════════════════════════════════════════════════════
            // GROUP DRAG: Move all selected nodes together, maintaining offsets
            // Note: onNodeDragStart doesn't exist - detect start via flag
            // ═══════════════════════════════════════════════════════════════════
            .onNodeDrag((node, _translate) => {
                // Only handle group drag if multiple nodes selected and this node is selected
                if (SELECTED_NODE_IDS.size > 1 && SELECTED_NODE_IDS.has(node.id)) {
                    // First drag frame: store relative offsets
                    if (!window._groupDragActive) {
                        window._groupDragActive = true;
                        window._groupDragOffsets = new Map();
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            if (SELECTED_NODE_IDS.has(n.id) && n.id !== node.id) {
                                window._groupDragOffsets.set(n.id, {
                                    dx: (n.x || 0) - (node.x || 0),
                                    dy: (n.y || 0) - (node.y || 0),
                                    dz: (n.z || 0) - (node.z || 0)
                                });
                            }
                        });
                    }
                    // Move all other selected nodes with their offsets
                    if (window._groupDragOffsets) {
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            const offset = window._groupDragOffsets.get(n.id);
                            if (offset) {
                                n.fx = node.x + offset.dx;
                                n.fy = node.y + offset.dy;
                                n.fz = node.z + offset.dz;
                            }
                        });
                    }
                }
            })
            .onNodeDragEnd(_node => {
                // Clear group drag state
                window._groupDragActive = false;
                window._groupDragOffsets = null;
                // Fix all selected nodes at their final positions
                if (SELECTED_NODE_IDS.size > 0) {
                    const nodes = Graph.graphData().nodes;
                    nodes.forEach(n => {
                        if (SELECTED_NODE_IDS.has(n.id)) {
                            n.fx = n.x; n.fy = n.y; n.fz = n.z;
                        }
                    });
                }
            })
            .onEngineStop(() => {
                // Physics-dependent operations (run after simulation stabilizes)
                drawFileBoundaries(data);
                // LAYOUT STABILITY: Freeze layout after initial simulation completes
                if (!LAYOUT_FROZEN) {
                    saveNodePositions();
                    freezeLayout();
                }
            });
    } catch (err) {
        console.error('[WebGL] Failed to initialize 3D graph:', err);
        initFallback2D(div, filtered, data);
        return;
    }

    window.Graph = Graph;

    // FIX: Drift on resize
    // Updates Graph renderer size when window creates
    window.addEventListener('resize', () => {
        if (Graph) {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        }
    });

    // OPTIMIZATION: Hide loader immediately after Graph creation (don't wait for physics)
    // This makes the visualization appear 200-500ms faster
    document.getElementById('loader').style.display = 'none';

    // =================================================================
    // RENDERER QUALITY: Enable anti-aliasing and high DPI
    // =================================================================
    const renderer = Graph.renderer();
    if (renderer) {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Enable high quality rendering
        renderer.antialias = true;
        renderer.alpha = true;
        renderer.powerPreference = 'high-performance';
    }

    initSelectionState(data);
    setupSelectionInteractions();
    // updateSelectionVisuals is in selection.js (window scope), may not be loaded yet
    if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();

    // =================================================================
    // CONTROLS: keep default camera behavior, enable damping
    // =================================================================
    const controls = Graph.controls();
    if (controls) {
        // TOKEN-DRIVEN: Read from payload (if available), else use defaults
        // Allow remote configuration of mouse buttons and damping
        const navConfig = data.config?.controls || data.controls || {};

        controls.enableDamping = navConfig.enableDamping !== undefined ? navConfig.enableDamping : true;
        controls.dampingFactor = navConfig.dampingFactor || 0.1;
        controls.enableRotate = navConfig.enableRotate !== undefined ? navConfig.enableRotate : true;
        controls.enablePan = navConfig.enablePan !== undefined ? navConfig.enablePan : true;

        // Mouse Buttons: Map generic names to integer constants
        // 0: ROTATE, 1: DOLLY (Zoom), 2: PAN
        const defaultButtons = {
            LEFT: 2, // PAN
            MIDDLE: 1, // DOLLY
            RIGHT: 0 // ROTATE
        };

        if (navConfig.mouseButtons) {
            controls.mouseButtons = {
                LEFT: navConfig.mouseButtons.LEFT ?? defaultButtons.LEFT,
                MIDDLE: navConfig.mouseButtons.MIDDLE ?? defaultButtons.MIDDLE,
                RIGHT: navConfig.mouseButtons.RIGHT ?? defaultButtons.RIGHT
            };
        } else {
            controls.mouseButtons = defaultButtons;
        }

        // Spacebar toggling disabled to ensure stability
    }

    // =================================================================
    // TOKEN-DRIVEN: Force Configuration
    // =================================================================
    const forces = physicsConfig.forces || {};
    if (forces.charge?.enabled) {
        Graph.d3Force('charge').strength(forces.charge.strength || -120);
        Graph.d3Force('charge').distanceMax(forces.charge.distanceMax || 500);
    }
    if (forces.link?.enabled) {
        const linkDistance = forces.link.distance || 50;
        Graph.d3Force('link').distance(linkDistance);
        DEFAULT_LINK_DISTANCE = linkDistance;
    }
    if (forces.center?.enabled) {
        Graph.d3Force('center').strength(forces.center.strength || 0.05);
    }

    // =================================================================
    // STARFIELD REMOVED - Nodes ARE the stars
    // Rationale: Adding background dots creates visual confusion with actual data nodes.
    // The cosmos metaphor works better when the data itself forms the starfield.
    // =================================================================

    // =================================================================
    // TOKEN-DRIVEN: Bloom Post-Processing (DISABLED - UMD build compatibility)
    // Post-processing addons require ES modules; using UMD for file:// support
    // =================================================================
    // Bloom disabled for compatibility - visualization works without it

    // Setup Hud Controls (TOKEN-DRIVEN)
    // OPTIMIZATION: Defer UI setup to next frame so graph renders first
    // This makes the visualization appear 150-200ms faster
    Promise.resolve().then(() => {
        setupControls(data);
        setupReport(data);
        setupAIInsights(data);
        setupMetrics(data);
        setupHudFade();
        setupDimensionToggle();
        applyEdgeMode();

        // SELF-TEST: Deterministic validation of UI controls (deferred)
        runSelfTest(data);
    });
}

function runSelfTest(data) {
    const results = {
        timestamp: new Date().toISOString(),
        passed: [],
        failed: []
    };

    const test = (name, condition) => {
        if (condition) {
            results.passed.push(name);
        } else {
            results.failed.push(name);
        }
    };

    // Test 1: Core UI structure (dual-sidebar layout)

    // Main layout containers
    test('header-exists', !!document.getElementById('header'));
    test('left-sidebar-exists', !!document.getElementById('left-sidebar'));
    test('right-sidebar-exists', !!document.getElementById('right-sidebar'));
    test('graph-container-exists', !!document.getElementById('3d-graph'));

    // Header stats
    test('stat-nodes-exists', !!document.getElementById('stat-nodes'));
    test('stat-edges-exists', !!document.getElementById('stat-edges'));
    test('target-name-exists', !!document.getElementById('target-name'));

    // Left sidebar configuration sections
    test('section-node-config-exists', !!document.getElementById('section-node-config'));
    test('section-edge-config-exists', !!document.getElementById('section-edge-config'));
    test('section-layout-exists', !!document.getElementById('section-layout'));
    test('section-physics-exists', !!document.getElementById('section-physics'));
    test('section-filters-exists', !!document.getElementById('section-filters'));
    test('section-actions-exists', !!document.getElementById('section-actions'));

    // Left sidebar action buttons
    test('btn-reset-exists', !!document.getElementById('btn-reset'));
    test('btn-screenshot-exists', !!document.getElementById('btn-screenshot'));
    test('btn-2d-exists', !!document.getElementById('btn-2d'));
    test('btn-freeze-exists', !!document.getElementById('btn-freeze'));

    // Right sidebar panels
    test('hover-panel-exists', !!document.getElementById('hover-panel'));
    test('section-schemes-exists', !!document.getElementById('section-schemes'));
    test('section-color-exists', !!document.getElementById('section-color'));

    // Selection elements
    test('selection-count-exists', !!document.getElementById('selection-count'));
    test('selection-list-exists', !!document.getElementById('selection-list'));

    // Stats panel
    test('stats-nodes-exists', !!document.getElementById('stats-nodes'));
    test('stats-edges-exists', !!document.getElementById('stats-edges'));

    // Performance HUD
    test('perf-hud-exists', !!document.getElementById('perf-hud'));
    test('perf-fps-exists', !!document.getElementById('perf-fps'));

    // Test 1b: Color mode buttons exist
    const colorButtons = document.querySelectorAll('.color-btn[data-preset]');
    test('color-mode-buttons-exist', colorButtons.length >= 4);

    // Test 1c: HUD Layout Manager tests
    test('hud-layout-manager-exists', typeof HudLayoutManager === 'object' && HudLayoutManager !== null);
    test('hud-layout-manager-has-reflow', typeof HudLayoutManager.reflow === 'function');
    test('hud-layout-manager-has-placePanel', typeof HudLayoutManager.placePanel === 'function');

    // Test 1d: HUD placement with synthetic rects (collision avoidance)
    if (typeof HudLayoutManager.placePanel === 'function') {
        // Create a test scenario: occupied rect on top-left, panel should avoid it
        const fakeOccupied = [{ left: 0, top: 0, right: 300, bottom: 200 }];
        const fakeCandidates = [
            { left: 20, top: 100 },   // Would overlap with occupied
            { left: 400, top: 100 }   // Should be clear
        ];
        // Create a mock panel element
        const mockPanel = document.createElement('div');
        mockPanel.style.width = '200px';
        mockPanel.style.height = '150px';
        mockPanel.style.position = 'fixed';
        document.body.appendChild(mockPanel);

        const result = HudLayoutManager.placePanel(mockPanel, fakeCandidates, fakeOccupied);
        // Should choose the second candidate (no overlap)
        const pickedNonOverlapping = result && result.left >= 300;
        test('hud-placement-avoids-overlap', pickedNonOverlapping);

        document.body.removeChild(mockPanel);
    }

    // Test 1e: Canonical taxonomy field tests
    // Test that node.tier is preferred over atom prefix inference
    const mockNodeWithTier = { tier: 'T2', atom: 'CORE.001', ring: 'DOMAIN' };
    const tierResult = getNodeTier(mockNodeWithTier);
    test('node-tier-prefers-field', tierResult === 'T2');  // Should use tier field, not infer T0 from CORE.

    // Test that node.ring is used when present
    const mockNodeWithRing = { ring: 'PRESENTATION', layer: 'APPLICATION' };
    const ringResult = getNodeRing(mockNodeWithRing);
    test('node-ring-prefers-field', ringResult === 'PRESENTATION');  // Should use ring, not layer

    // Test tier aliases work (CORE → T0, EXT → T2)
    test('tier-alias-core-to-t0', normalizeTier('CORE') === 'T0');
    test('tier-alias-ext-to-t2', normalizeTier('EXT') === 'T2');

    // Test atom_family extraction
    const mockNodeWithFamily = { atom_family: 'LOG', atom: 'ORG.AGG.M' };
    const familyResult = getNodeAtomFamily(mockNodeWithFamily);
    test('node-atom-family-prefers-field', familyResult === 'LOG');  // Should use atom_family, not infer ORG

    // Test 1f: Hover panel tests
    test('hover-panel-exists', document.getElementById('hover-panel') !== null);

    // Test hover panel uses canonical fields
    const mockCanonicalNode = {
        name: 'TestNode',
        atom_family: 'LOG',
        ring: 'PRESENTATION',
        tier: 'T2',
        atom: 'ORG.AGG.M',
        kind: 'function',
        role: 'Utility'
    };
    // Simulate updateHoverPanel with mock node
    if (typeof updateHoverPanel === 'function') {
        updateHoverPanel(mockCanonicalNode);
        const hoverFamily = document.getElementById('hover-family')?.textContent;
        const hoverRing = document.getElementById('hover-ring')?.textContent;
        const hoverTier = document.getElementById('hover-tier')?.textContent;
        // Verify canonical fields are used (LOG not ORG, PRESENTATION, T2)
        test('hover-panel-uses-canonical-fields',
            hoverFamily === 'LOG' && hoverRing === 'PRESENTATION' && hoverTier === 'T2');
        // Clean up: hide panel
        updateHoverPanel(null);
    }

    // Test 2: Header stats populated (stat-* elements - these are set early)
    const headerNodes = document.getElementById('stat-nodes');
    const headerEdges = document.getElementById('stat-edges');
    test('header-nodes-populated', headerNodes && headerNodes.textContent !== '0');
    test('header-edges-populated', headerEdges && headerEdges.textContent !== '0');

    // Test 3: Data integrity
    test('nodes-count-positive', data.nodes && data.nodes.length > 0);
    test('links-count-positive', data.links && data.links.length > 0);
    test('graph-initialized', !!window.Graph);

    // Test 4: Controls config loaded
    test('controls-config-exists', !!data.controls);
    test('appearance-config-exists', !!data.appearance);
    test('physics-config-exists', !!data.physics);

    // Test 5: Initial state correct
    const physicsCharge = document.getElementById('physics-charge');
    test('physics-slider-has-value', physicsCharge && physicsCharge.value !== undefined);
    test('3d-mode-default', IS_3D === true);

    // Test 6: VIS_STATE module loaded
    test('vis-state-module-exists', typeof VIS_STATE !== 'undefined');
    test('vis-state-has-applyState', typeof VIS_STATE?.applyState === 'function');
    test('vis-state-has-getState', typeof VIS_STATE?.getState === 'function');

    // Expose results to window for external testing
    window.SELF_TEST_RESULTS = results;

    // Log summary
    const total = results.passed.length + results.failed.length;
    const passRate = ((results.passed.length / total) * 100).toFixed(1);

    if (results.failed.length === 0) {
        console.log(`%c✅ SELF-TEST PASSED: ${results.passed.length}/${total} tests (${passRate}%)`, 'color: #00ff00; font-weight: bold');
    } else {
        console.warn(`%c⚠️ SELF-TEST: ${results.passed.length}/${total} passed (${passRate}%)`, 'color: #ffaa00; font-weight: bold');
        console.warn('Failed tests:', results.failed);
    }

    return results;
}

// TIER_ALIASES, normalizeTier, getNodeTier, getNodeAtomFamily, normalizeRingValue,
// getNodeRing, getNodeLayer, getNodeEffect - provided by node-accessors.js module

// getNodeColorByMode, getSubsystem, getPhase, getFileType, getRoleCategory, applyNodeColors - MOVED TO modules/node-helpers.js
// normalize - MOVED TO modules/utils.js

function filterGraph(data, minVal, datamapSet, filters) {
    // ALL DATA FROM DM - the processing pipeline
    const allNodes = DM ? DM.getNodes() : (data?.nodes || []);
    const allLinks = DM ? DM.getLinks() : (data?.links || []);

    const tierFilter = filters?.tiers || new Set();
    const ringFilter = filters?.rings || new Set();
    const roleFilter = filters?.roles || new Set();
    const edgeFilter = filters?.edges || new Set();
    const familyFilter = filters?.families || new Set();
    const layerFilter = filters?.layers || new Set();
    const effectFilter = filters?.effects || new Set();
    const edgeFamilyFilter = filters?.edgeFamilies || new Set();
    const showEdges = filters?.metadata?.showEdges !== false;

    const availableRings = Array.from(new Set(allNodes.map(n => getNodeRing(n)))).sort();
    let ringFilterValues = Array.from(ringFilter);
    let ringIntersection = ringFilterValues.filter(r => availableRings.includes(r));
    if (ringFilterValues.length > 0 && ringIntersection.length === 0) {
        console.warn('[Filters] Ring filter values not present in dataset; clearing.', {
            ringValues: ringFilterValues,
            availableRings
        });
        ringFilter.clear();
        ringFilterValues = [];
        ringIntersection = [];
    }

    // Filter nodes by size/importance
    let visibleNodes = allNodes.filter(n => (n.val ?? 1) >= minVal);

    if (datamapSet && datamapSet.size > 0) {
        visibleNodes = visibleNodes.filter(n => {
            for (const id of datamapSet) {
                const config = DATAMAP_INDEX[id];
                if (config && datamapMatches(n, config)) return true;
            }
            return false;
        });
    }

    const tierFilterActive = tierFilter.size > 0;
    const ringFilterActive = ringFilter.size > 0;
    const roleFilterActive = roleFilter.size > 0;
    const familyFilterActive = familyFilter.size > 0;
    const layerFilterActive = layerFilter.size > 0;
    const effectFilterActive = effectFilter.size > 0;

    const filterSummary = {
        active: {
            tier: tierFilter.size,
            ring: ringFilter.size,
            role: roleFilter.size,
            family: familyFilter.size,
            layer: layerFilter.size,
            effect: effectFilter.size
        },
        ringValues: ringFilterValues.slice().sort(),
        availableRings,
        ringIntersectionSize: ringIntersection.length
    };
    const filterSummaryKey = JSON.stringify(filterSummary);
    if (filterSummaryKey !== LAST_FILTER_SUMMARY) {
        console.log('[Filters] summary', filterSummary);
        LAST_FILTER_SUMMARY = filterSummaryKey;
    }

    visibleNodes = visibleNodes.filter(n => {
        if (tierFilterActive && !tierFilter.has(getNodeTier(n))) return false;
        if (ringFilterActive && !ringFilter.has(getNodeRing(n))) return false;
        if (roleFilterActive && !roleFilter.has(String(n.role || 'Unknown'))) return false;
        if (familyFilterActive && !familyFilter.has(getNodeAtomFamily(n))) return false;
        if (layerFilterActive && !layerFilter.has(getNodeLayer(n))) return false;
        if (effectFilterActive && !effectFilter.has(getNodeEffect(n))) return false;
        return true;
    });



    // Zero-node protection: warn when dimension filters result in empty graph
    if (visibleNodes.length === 0 && (tierFilterActive || ringFilterActive || roleFilterActive || familyFilterActive || layerFilterActive || effectFilterActive)) {
        const activeFilters = [];
        if (tierFilterActive) activeFilters.push(`tiers: [${Array.from(tierFilter).join(', ')}]`);
        if (ringFilterActive) activeFilters.push(`rings: [${Array.from(ringFilter).join(', ')}]`);
        if (roleFilterActive) activeFilters.push(`roles: [${Array.from(roleFilter).join(', ')}]`);
        if (familyFilterActive) activeFilters.push(`families: [${Array.from(familyFilter).join(', ')}]`);
        if (layerFilterActive) activeFilters.push(`layers: [${Array.from(layerFilter).join(', ')}]`);
        if (effectFilterActive) activeFilters.push(`effects: [${Array.from(effectFilter).join(', ')}]`);
        console.warn('[filterGraph] Zero nodes match filters:', activeFilters.join(', '));
    }

    const visibleIds = new Set(visibleNodes.map(n => n.id));

    // Keep edges only between visible nodes
    let visibleLinks = allLinks.filter(l =>
        visibleIds.has(l.source.id || l.source) &&
        visibleIds.has(l.target.id || l.target)
    );

    if (edgeFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFilter.has(String(l.edge_type || l.type || 'default')));
    }

    if (edgeFamilyFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFamilyFilter.has(l.family || 'Dependency'));
    }

    if (!showEdges) {
        visibleLinks = [];
    }

    return { nodes: visibleNodes, links: visibleLinks };
}

// ====================================================================
// LAYOUT STABILITY: saveNodePositions, restoreNodePositions, freezeLayout, unfreezeLayout, resetLayout - MOVED TO modules/layout-helpers.js
// showModeToast - MOVED TO modules/tooltips.js
// getLinkEndpointId, getFileTarget - MOVED TO modules/layout-helpers.js
// stableOffset - MOVED TO modules/utils.js

// buildFileGraph - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.buildFileGraph)
// captureFileNodePositions - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.captureFileNodePositions)

function buildHybridGraph(data) {
    // ALL DATA FROM DM - the reaction chamber for data chemistry
    if (!FILE_GRAPH) {
        FILE_GRAPH = buildFileGraph(data);
    }
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const nodes = DM ? DM.getNodes() : (data?.nodes || []);
    const links = DM ? DM.getLinks() : (data?.links || []);

    const totalFiles = boundaries.length;
    const clusterConfig = data?.physics?.cluster || {};
    const detachRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius * 1.3 : 200;
    const detachZ = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing * 2 : 80;
    const expandRadius = 30;
    const expandedSet = new Set(EXPANDED_FILES);

    const fileNodes = FILE_GRAPH.nodes.map(node => {
        const copy = Object.assign({}, node);
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach' && expandedSet.has(node.fileIdx))
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        copy.x = anchor.x + detachOffset.x;
        copy.y = anchor.y + detachOffset.y;
        copy.z = (anchor.z || 0) + detachOffset.z;
        return copy;
    });

    const nodeFileIdx = new Map();
    nodes.forEach(n => {
        if (n && n.id) {
            nodeFileIdx.set(n.id, n.fileIdx ?? -1);
        }
    });

    const childNodes = [];
    nodes.forEach(node => {
        if (!expandedSet.has(node.fileIdx)) return;
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach')
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        const local = stableOffset(node, `file-${node.fileIdx}`, expandRadius);
        const copy = Object.assign({}, node);
        copy.x = anchor.x + detachOffset.x + local.x;
        copy.y = anchor.y + detachOffset.y + local.y;
        copy.z = (anchor.z || 0) + detachOffset.z + (IS_3D ? local.z : 0);
        childNodes.push(copy);
    });

    const childLinks = [];
    links.forEach(link => {
        const srcId = getLinkEndpointId(link, 'source');
        const tgtId = getLinkEndpointId(link, 'target');
        const srcIdx = nodeFileIdx.get(srcId) ?? -1;
        const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;
        if (srcIdx < 0 || tgtIdx < 0 || srcIdx !== tgtIdx) return;
        if (!expandedSet.has(srcIdx)) return;
        childLinks.push({
            source: srcId,
            target: tgtId,
            color: link.color,
            opacity: link.opacity,
            edge_type: link.edge_type,
            weight: link.weight,
            confidence: link.confidence,
            resolution: link.resolution
        });
    });

    return {
        nodes: fileNodes.concat(childNodes),
        links: FILE_GRAPH.links.concat(childLinks)
    };
}

function setupControls(data) {
    // Initialize the Unified UI Manager
    UIManager.init(data);

    // Initialize modules that require data/DOM to be ready
    // (SIDEBAR.init() is called earlier in DOMContentLoaded)
    if (typeof LAYOUT !== 'undefined' && LAYOUT.init) LAYOUT.init();
    if (typeof HUD !== 'undefined' && HUD.setupFade) HUD.setupFade();
    if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) DIMENSION.setup();

    // Initialize Command Bar and Floating Panels
    initCommandBar();

    // Initialize Selection Detail Modal
    initSelectionModal();

    // Initialize Node & Edge Config Controls (PRIME SECTIONS)
    setupConfigControls();

    // Render color-coded legends with counts
    renderAllLegends();

    // Flow mode button (attached here for proper DOM timing)
    const btnFlow = document.getElementById('btn-flow');
    if (btnFlow) btnFlow.onclick = () => toggleFlowMode();
}

/**
 * =================================================================
 * setupConfigControls: Initialize NODE CONFIG and EDGE CONFIG panels
 * =================================================================
 * These are the "prime position" controls at the top of the sidebar
 */
function setupConfigControls() {
    // Helper: Bind slider with value display
    const bindSlider = (id, valueId, onChange, decimals = 1) => {
        const slider = document.getElementById(id);
        const valueEl = document.getElementById(valueId);
        if (!slider) return;
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (valueEl) valueEl.textContent = decimals === 0 ? val.toString() : val.toFixed(decimals);
            onChange(val);
        });
    };

    // Helper: Bind toggle switch
    const bindToggle = (id, initialState, onChange) => {
        const toggle = document.getElementById(id);
        if (!toggle) return;
        if (initialState) toggle.classList.add('active');
        else toggle.classList.remove('active');
        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            onChange(isActive);
        });
    };

    // Helper: Bind button group (radio-like selection)
    const bindButtonGroup = (container, dataAttr, onChange) => {
        const buttons = container.querySelectorAll(`[${dataAttr}]`);
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                onChange(btn.getAttribute(dataAttr));
            });
        });
    };

    // ═══════════════════════════════════════════════════════════════════
    // NODE CONFIG
    // ═══════════════════════════════════════════════════════════════════

    // Size Mode Selector
    const nodeCfg = document.getElementById('section-node-config');
    if (nodeCfg) {
        bindButtonGroup(nodeCfg, 'data-size-mode', (mode) => {
            APPEARANCE_STATE.sizeMode = mode;
            applyNodeSizeMode(mode);
            console.log('[CONFIG] Size mode:', mode);
        });
    }

    // Node Base Size
    bindSlider('cfg-node-size', 'cfg-node-size-val', (val) => {
        APPEARANCE_STATE.nodeScale = val;
        applyNodeSizeMode(APPEARANCE_STATE.sizeMode || 'uniform');
    });

    // Node Opacity
    bindSlider('cfg-node-opacity', 'cfg-node-opacity-val', (val) => {
        APPEARANCE_STATE.nodeOpacity = val;
        if (Graph) Graph.nodeOpacity(val);
    });

    // Node Resolution (sphere segments)
    bindSlider('cfg-node-res', 'cfg-node-res-val', (val) => {
        APPEARANCE_STATE.nodeResolution = Math.round(val);
        if (Graph) Graph.nodeResolution(Math.round(val));
    }, 0);

    // Label Size
    bindSlider('cfg-label-size', 'cfg-label-size-val', (val) => {
        APPEARANCE_STATE.labelSize = val;
        if (Graph && APPEARANCE_STATE.showLabels) {
            Graph.nodeLabel(node => val > 0.2 ? (node.name || node.id) : null);
        }
    });

    // Show Labels Toggle
    bindToggle('cfg-toggle-labels', APPEARANCE_STATE.showLabels, (active) => {
        APPEARANCE_STATE.showLabels = active;
        if (Graph) Graph.nodeLabel(node => active ? (node.name || node.id) : null);
    });

    // Highlight Selected Toggle
    bindToggle('cfg-toggle-highlight', APPEARANCE_STATE.highlightSelected, (active) => {
        APPEARANCE_STATE.highlightSelected = active;
        if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();
    });

    // Pulse Animation Toggle
    bindToggle('cfg-toggle-pulse', false, (active) => {
        APPEARANCE_STATE.pulseAnimation = active;
        console.log('[CONFIG] Pulse animation:', active ? 'ON' : 'OFF');
    });

    // 3D Depth Shading Toggle
    bindToggle('cfg-toggle-depth', true, (active) => {
        APPEARANCE_STATE.depthShading = active;
        console.log('[CONFIG] Depth shading:', active ? 'ON' : 'OFF');
    });

    // ═══════════════════════════════════════════════════════════════════
    // EDGE CONFIG - Enhanced with better visibility and flow animation
    // ═══════════════════════════════════════════════════════════════════

    // Edge Style Selector
    const edgeCfg = document.getElementById('section-edge-config');
    if (edgeCfg) {
        bindButtonGroup(edgeCfg, 'data-edge-style', (style) => {
            APPEARANCE_STATE.edgeStyle = style;
            applyEdgeStyle(style);
            console.log('[CONFIG] Edge style:', style);
        });
    }

    // Edge Opacity - ENHANCED: Higher default for visibility
    bindSlider('cfg-edge-opacity', 'cfg-edge-opacity-val', (val) => {
        APPEARANCE_STATE.edgeOpacity = val;
        // Use applyEdgeMode to ensure consistent function-based opacity
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Width - ENHANCED: Thicker default
    bindSlider('cfg-edge-width', 'cfg-edge-width-val', (val) => {
        APPEARANCE_STATE.edgeWidth = val;
        // Use applyEdgeMode to ensure consistent function-based width
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Curvature - Direct Graph API (not handled by EDGE module)
    bindSlider('cfg-edge-curve', 'cfg-edge-curve-val', (val) => {
        APPEARANCE_STATE.edgeCurvature = val;
        if (Graph) Graph.linkCurvature(val);
    });

    // Particle Speed - For FLOW visualization
    bindSlider('cfg-particle-speed', 'cfg-particle-speed-val', (val) => {
        APPEARANCE_STATE.particleSpeed = val;
        if (Graph) Graph.linkDirectionalParticleSpeed(val);
    }, 3);

    // Particle Density - For FLOW visualization
    bindSlider('cfg-particle-count', 'cfg-particle-count-val', (val) => {
        APPEARANCE_STATE.particleCount = Math.round(val);
        if (Graph) Graph.linkDirectionalParticles(Math.round(val));
    }, 0);

    // NOTE: Toggle bindings moved to sidebar.js (_bindAppearanceControls)
    // Keeping only initial state sync here
    const arrowToggle = document.getElementById('cfg-toggle-arrows');
    if (arrowToggle && APPEARANCE_STATE.showArrows) arrowToggle.classList.add('active');

    const gradientToggle = document.getElementById('cfg-toggle-gradient');
    if (gradientToggle && APPEARANCE_STATE.gradientEdges) gradientToggle.classList.add('active');

    // Highlight Edges on Hover Toggle
    bindToggle('cfg-toggle-edge-hover', true, (active) => {
        APPEARANCE_STATE.edgeHoverHighlight = active;
    });

    // ═══════════════════════════════════════════════════════════════════
    // Section Collapse Handlers
    // ═══════════════════════════════════════════════════════════════════
    document.querySelectorAll('.section-header[data-section]').forEach(header => {
        header.addEventListener('click', () => {
            const sectionId = header.dataset.section;
            const content = document.getElementById(`section-${sectionId}`);
            if (!content) return;
            const isCollapsed = header.classList.toggle('collapsed');
            content.classList.toggle('collapsed', isCollapsed);
        });
    });

    console.log('[CONFIG] Node & Edge config controls initialized');
}

// applyNodeSizeMode - MOVED TO modules/node-helpers.js

/**
 * Apply edge style - controls edge rendering mode
 */
function applyEdgeStyle(style) {
    if (!Graph) return;
    const opacity = APPEARANCE_STATE.edgeOpacity || 0.4;
    const speed = APPEARANCE_STATE.particleSpeed || 0.01;
    const count = APPEARANCE_STATE.particleCount || 0;

    switch (style) {
        case 'solid':
            Graph.linkLineDash(null);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'dashed':
            Graph.linkLineDash([4, 4]);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'particle':
            // Particle mode: dim lines, bright particles for flow effect
            Graph.linkLineDash(null);
            Graph.linkOpacity(Math.max(0.1, opacity * 0.3));
            Graph.linkDirectionalParticles(Math.max(4, count));
            Graph.linkDirectionalParticleSpeed(speed);
            Graph.linkDirectionalParticleWidth(3);
            Graph.linkDirectionalParticleColor(link => {
                // Use source node color for particles
                if (link.source && typeof link.source === 'object') {
                    return link.source.__threeObj?.material?.color?.getStyle() || '#00d4ff';
                }
                return '#00d4ff';
            });
            break;
    }
}

// UIManager - provided by ui-manager.js module (window.UI_MANAGER, window.UIManager)

function refreshGraph() {
    if (!DM || !Graph) return;  // ALL DATA FROM DM

    // LAYOUT STABILITY: Save current positions before any graph update
    saveNodePositions();

    if (GRAPH_MODE === 'files') {
        if (!FILE_GRAPH) {
            FILE_GRAPH = buildFileGraph(null);  // Uses DM internally
        }
        restoreNodePositions(FILE_GRAPH.nodes);
        Graph.graphData(FILE_GRAPH);
        applyFileColors(FILE_GRAPH.nodes);
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel('name');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    if (GRAPH_MODE === 'hybrid') {
        const hybrid = buildHybridGraph(null);  // Uses DM internally
        restoreNodePositions(hybrid.nodes);
        Graph.graphData(hybrid);
        applyFileColors(hybrid.nodes);
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    const subset = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);  // Uses DM internally
    if (ACTIVE_DATAMAPS.size > 0 && subset.nodes.length === 0) {
        showToast('No nodes for that datamap selection.');
        ACTIVE_DATAMAPS.clear();
        const fallback = filterGraph(null, CURRENT_DENSITY, new Set(), VIS_FILTERS);  // Uses DM internally
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        // Force re-evaluation of accessors
        Graph.nodeColor(Graph.nodeColor());
        Graph.nodeRelSize(Graph.nodeRelSize());
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        if (fileMode && GRAPH_MODE === 'atoms') {
            applyFileVizMode();
        }
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    // Zero-node protection for VIS_FILTERS (tier/ring/family/role)
    const hasActiveFilters = VIS_FILTERS.tiers.size > 0 || VIS_FILTERS.rings.size > 0 ||
        VIS_FILTERS.families.size > 0 || VIS_FILTERS.roles.size > 0;
    if (subset.nodes.length === 0 && hasActiveFilters) {
        showToast('No nodes match current filters. Clearing filters.');
        clearAllFilters();
        const fallback = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    applyNodeColors(subset.nodes);
    restoreNodePositions(subset.nodes);
    Graph.graphData(subset);
    Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
    Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
    applyEdgeMode();
    if (fileMode && GRAPH_MODE === 'atoms') {
        applyFileVizMode();
    }
    updateDatamapControls();
    syncSelectionAfterGraphUpdate();
    if (LAYOUT_FROZEN) freezeLayout();
}

// ═══════════════════════════════════════════════════════════════════════
// THEORY CONSTANTS - MOVED TO modules/theory.js
// ═══════════════════════════════════════════════════════════════════════
// SCALE_16_LEVELS, THREE_LAYERS, SMC_THEORY, LEVEL_ZONES, VIS_PRESETS
// Now provided by THEORY module with backward-compat shims

// Tooltip state - shared with modules/tooltips.js
const TOOLTIP_STATE = { visible: false, currentKey: null, element: null, hideTimeout: null };

// initTooltips, showTopoTooltip, hideTopoTooltip - MOVED TO modules/tooltips.js

// ═══════════════════════════════════════════════════════════════════════
// getTopoColor - MOVED TO modules/color-helpers.js

// ═══════════════════════════════════════════════════════════════════════
// LAYOUT PRESETS - MOVED TO modules/animation.js
// ═══════════════════════════════════════════════════════════════════════
// LAYOUT_PRESETS, STAGGER_PATTERNS, CURRENT_LAYOUT, LAYOUT_ANIMATION_ID,
// LAYOUT_TIME, CURRENT_STAGGER_PATTERN, applyLayoutPreset, cycleStaggerPattern,
// startLayoutMotion, startFlockSimulation, groupNodesByTier
// All now provided by ANIM module with O(n) spatial hashing (fixes ARCH-002)








// Count nodes by tier and family







// Hermite basis functions for C¹ continuous color interpolation




// ═══════════════════════════════════════════════════════════════









// OKLCH-inspired colors (converted to linear RGB for Three.js)
// Chaos (bottom): OKLCH(0.25, 0.12, 240) ≈ deep cosmic blue




// ═══════════════════════════════════════════════════════════════


























// clearAllFilters - MOVED TO modules/visibility.js







// collectCounts, buildCheckboxRow, buildFilterGroup - MOVED TO modules/ui-builders.js
// resolveDefaults - MOVED TO modules/utils.js
// normalizeDatamapConfig, resolveDatamapConfigs, datamapMatches - MOVED TO modules/datamap.js
// buildDatamapToggle, buildExclusiveOptions - MOVED TO modules/ui-builders.js

// ═══════════════════════════════════════════════════════════════════════════
// APPEARANCE SLIDERS - Orchestration layer (uses UI_BUILDERS for pure UI)
// This function owns the business logic: what sliders exist, their values,
// and what happens when they change. UI_BUILDERS.buildAppearanceSliders
// handles the DOM creation.
// ═══════════════════════════════════════════════════════════════════════════

function buildAppearanceSliders(containerId, sliderConfigs) {

    const resolveSlider = (key, fallback) => {
        const config = (sliderConfigs && sliderConfigs[key]) ? sliderConfigs[key] : {};
        return {
            label: config.label || fallback.label,
            min: (config.min !== undefined) ? config.min : fallback.min,
            max: (config.max !== undefined) ? config.max : fallback.max,
            step: (config.step !== undefined) ? config.step : fallback.step,
            default: (config.default !== undefined) ? config.default : fallback.value
        };
    };

    const sliderDefs = [
        (() => {
            const config = resolveSlider('edgeOpacity', {
                label: 'EDGE OPACITY',
                min: 0.02,
                max: 0.4,
                step: 0.01,
                value: EDGE_DEFAULT_OPACITY
            });
            return {
                id: 'edge-opacity',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.edgeOpacity ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.edgeOpacity = val;
                    applyEdgeMode();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('nodeScale', {
                label: 'NODE SCALE',
                min: 0.6,
                max: 2.5,
                step: 0.1,
                value: 1
            });
            return {
                id: 'node-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.nodeScale ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.nodeScale = val;
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('backgroundBrightness', {
                label: 'BACKGROUND',
                min: 0,
                max: 1,
                step: 0.05,
                value: 1
            });
            return {
                id: 'bg-brightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.backgroundBrightness ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.backgroundBrightness = val;
                    updateBackgroundBrightness();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('fileLightness', {
                label: 'FILE LIGHT',
                min: 20,
                max: 80,
                step: 1,
                value: 50
            });
            return {
                id: 'file-lightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.fileLightness ?? config.default,
                onChange: (val) => {
                    FILE_COLOR_CONFIG.lightness = val;
                    APPEARANCE_STATE.fileLightness = val;
                    if (fileMode) {
                        applyFileVizMode();
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hueShift', {
                label: 'HUE SHIFT',
                min: -180,
                max: 180,
                step: 1,
                value: 0
            });
            return {
                id: 'hue-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.hueShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.hueShift = val;
                    Color.setTransform('hueShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('chromaScale', {
                label: 'CHROMA SCALE',
                min: 0,
                max: 2,
                step: 0.05,
                value: 1
            });
            return {
                id: 'chroma-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.chromaScale ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.chromaScale = val;
                    Color.setTransform('chromaScale', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('lightnessShift', {
                label: 'LIGHT SHIFT',
                min: -20,
                max: 20,
                step: 1,
                value: 0
            });
            return {
                id: 'lightness-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.lightnessShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.lightnessShift = val;
                    Color.setTransform('lightnessShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('boundaryOpacity', {
                label: 'HULL OPACITY',
                min: 0.02,
                max: 0.25,
                step: 0.01,
                value: 0.1
            });
            return {
                id: 'boundary-fill',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryFill ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryFill = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hullWireOpacity', {
                label: 'HULL WIRE',
                min: 0.05,
                max: 0.6,
                step: 0.02,
                value: 0.35
            });
            return {
                id: 'boundary-wire',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryWire ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryWire = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('clusterStrength', {
                label: 'CLUSTER FORCE',
                min: 0,
                max: 1,
                step: 0.1,
                value: 0.45
            });
            return {
                id: 'cluster-strength',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.clusterStrength ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.clusterStrength = val;
                    if (fileMode && fileVizMode === 'cluster') {
                        applyClusterForce(null);  // Uses DM internally
                    }
                }
            };
        })(),
        // ═══════════════════════════════════════════════════════════
        // AMPLIFIER SLIDER - Power law exponent for visual contrast
        // γ=1 linear, γ>1 amplifies small differences, γ<1 compresses
        // Formula: amplified = value^(1/γ)
        // ═══════════════════════════════════════════════════════════
        (() => {
            const config = resolveSlider('amplifier', {
                label: 'AMPLIFIER (γ)',
                min: 0.3,
                max: 5.0,
                step: 0.1,
                value: 1.0
            });
            return {
                id: 'amplifier',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.amplifier ?? config.default,
                className: 'meta-amplifier',  // Special styling for meta-slider
                description: 'γ>1 amplifies differences, γ<1 compresses',
                onChange: (val) => {
                    APPEARANCE_STATE.amplifier = val;
                    // Re-apply edge mode to update widths with new amplification
                    applyEdgeMode();
                    // If in flow mode, re-apply flow visualization
                    if (flowMode) {
                        applyFlowVisualization();
                    }
                }
            };
        })()
    ];

    // Use UI_BUILDERS for pure DOM creation (decoupled architecture)
    // Each sliderDef has its own onChange handler - business logic stays here
    UI_BUILDERS.buildAppearanceSliders(containerId, sliderDefs);
}

// ═══════════════════════════════════════════════════════════════════════
// PHYSICS CONTROLS - Real-time force simulation adjustment
// ═══════════════════════════════════════════════════════════════════════
const PHYSICS_STATE = {
    charge: -120,
    linkDistance: 50,
    centerStrength: 0.05,
    velocityDecay: 0.4
};

const PHYSICS_PRESETS = {
    default: { charge: -120, linkDistance: 50, centerStrength: 0.05, velocityDecay: 0.4, label: 'DEFAULT' },
    tight: { charge: -80, linkDistance: 30, centerStrength: 0.1, velocityDecay: 0.5, label: 'TIGHT' },
    loose: { charge: -200, linkDistance: 80, centerStrength: 0.02, velocityDecay: 0.3, label: 'LOOSE' },
    explosive: { charge: -400, linkDistance: 120, centerStrength: 0.01, velocityDecay: 0.2, label: 'EXPLOSIVE' }
};

// applyPhysicsState, applyPhysicsPreset, updatePhysicsSliders, buildPhysicsControls - MOVED TO modules/physics.js

// updateBackgroundBrightness, applyMetadataVisibility - MOVED TO modules/visibility.js

// Deprecated setupSidebar - replaced by UIManager
// Deprecated buildDatamapControls - replaced by UIManager


// ═══════════════════════════════════════════════════════════════
// PRESET BUTTONS - Quick visualization mode selection (Tier, Family, etc.)
// Uses VIS_STATE for unified state management
// ═══════════════════════════════════════════════════════════════
const presetGrid = document.getElementById('dock-presets');
const presetBtnGrid = document.getElementById('preset-grid');
if (presetBtnGrid) {
    presetBtnGrid.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const presetKey = btn.dataset.preset;

            // Use VIS_STATE for unified state management
            if (typeof VIS_STATE !== 'undefined') {
                VIS_STATE.applyPreset(presetKey);
                return;
            }

            // Fallback for when VIS_STATE not loaded
            const preset = VIS_PRESETS[presetKey];
            if (!preset) return;

            presetBtnGrid.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            APPEARANCE_STATE.currentPreset = presetKey;
            APPEARANCE_STATE.colorMode = preset.colorBy;

            setNodeColorMode(preset.colorBy);

            const edgeModes = { 'type': 'gradient-tier', 'weight': 'weight', 'resolution': 'gradient-file' };
            EDGE_MODE = edgeModes[preset.edgeBy] || preset.edgeBy || 'gradient-tier';
            applyEdgeMode();

            if (presetKey === 'flow') {
                if (!flowMode && typeof toggleFlowMode === 'function') toggleFlowMode();
            } else if (flowMode && typeof disableFlowMode === 'function') {
                disableFlowMode();
            }

            if (typeof window.refreshGradientEdgeColors === 'function') {
                window.refreshGradientEdgeColors();
            }

            if (typeof renderAllLegends === 'function') {
                renderAllLegends();
            }

            console.log('[Preset] Applied:', preset.name, '| colorBy:', preset.colorBy, '| edgeBy:', preset.edgeBy);
        });
    });
}

// ═══════════════════════════════════════════════════════════════
// NOTE: Color scheme buttons are now handled by sidebar.js via SIDEBAR.initSchemeNavigator()
// The 33 named schemes (viridis, plasma, thermal, etc.) are defined in color-engine.js schemePaths
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// LAYOUT BUTTONS - Graph layout presets with perpetual motion
// ═══════════════════════════════════════════════════════════════
const layoutGrid = document.getElementById('layout-grid');
if (layoutGrid) {
    layoutGrid.querySelectorAll('.layout-btn').forEach(btn => {
        const layoutKey = btn.dataset.layout;
        // Assign ID if missing for Registry
        if (!btn.id) btn.id = `layout-btn-${layoutKey}`;

        REGISTRY.register(btn.id, () => {
            if (!layoutKey || !LAYOUT_PRESETS[layoutKey]) return;

            // Update active state
            layoutGrid.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Apply the layout
            applyLayoutPreset(layoutKey, true);

            console.log('[Layout] Applied:', LAYOUT_PRESETS[layoutKey].name);
        }, { desc: `Activate ${layoutKey} layout` });
    });
}

// VIEW section controls
buildExclusiveOptions('filter-node-color', [
    { label: 'TIER', value: 'tier' },
    { label: 'RING', value: 'ring' },
    { label: 'FAMILY', value: 'family' },
    { label: 'LAYER', value: 'layer' },
    { label: 'FILE', value: 'file' },
    { label: 'ATOM', value: 'atom' },
    { label: 'COMPLEXITY', value: 'complexity' },
    { label: 'CHURN', value: 'churn' }
], NODE_COLOR_MODE, setNodeColorMode);
buildExclusiveOptions('filter-edge-mode', [
    { label: 'GRAD-FILE', value: 'gradient-file' },
    { label: 'GRAD-TIER', value: 'gradient-tier' },
    { label: 'GRAD-FLOW', value: 'gradient-flow' },
    { label: 'TYPE', value: 'type' },
    { label: 'WEIGHT', value: 'weight' },
    { label: 'MONO', value: 'mono' }
], EDGE_MODE, setEdgeMode);
buildMetadataControls('filter-metadata', VIS_FILTERS.metadata);
buildAppearanceSliders('appearance-sliders', {}); // controlsConfig removed - sliders built dynamically
buildPhysicsControls('physics-sliders');  // Physics/forces controls

applyMetadataVisibility();
updateBackgroundBrightness();
refreshGraph();

// setupCollapsibleSections - MOVED TO modules/visibility.js

// setupReport, setupAIInsights, setupMetrics - MOVED TO modules/report.js

// escapeHtml - MOVED TO modules/utils.js

// setupHudFade, updateHudStats - MOVED TO modules/hud.js

// showToast - MOVED TO modules/tooltips.js
// updateDatamapControls - MOVED TO modules/datamap.js

// toggleDimensions, setupDimensionToggle, animateDimensionChange - MOVED TO modules/dimension.js

// stableSeed, stableZ - MOVED TO modules/utils.js

// ====================================================================
// EDGE VISUALIZATION MODES - GRADIENT & DATA-DRIVEN SYSTEM
// ====================================================================
// NEW: Edge modes with gradients showing data progression & regions
const EDGE_MODE_ORDER = [
    'gradient-tier',      // Source→Target tier flow (architecture layers)
    'gradient-file',      // File boundaries (module regions)
    'gradient-flow',      // Markov probability (hot paths)
    'gradient-depth',     // Call depth progression
    'gradient-semantic',  // Semantic distance (type similarity)
    'type',               // Classic type-based
    'weight',             // Weight intensity
    'mono'                // Minimal monochrome
];
const EDGE_MODE_LABELS = {
    'gradient-tier': '▼ TIER FLOW',
    'gradient-file': '▼ FILE REGIONS',
    'gradient-flow': '▼ HOT PATHS',
    'gradient-depth': '▼ CALL DEPTH',
    'gradient-semantic': '▼ SEMANTIC',
    type: 'EDGE: TYPE',
    weight: 'EDGE: WEIGHT',
    mono: 'EDGE: MONO'
};
const EDGE_MODE_HINTS = {
    'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
    'gradient-file': 'Color by file region - shows module boundaries',
    'gradient-flow': 'Hot paths - markov probability gradient',
    'gradient-depth': 'Color by call chain depth',
    'gradient-semantic': 'Color by semantic similarity of endpoints',
    type: 'Edge color by type (calls, imports, etc.)',
    weight: 'Edge width & color by weight',
    mono: 'Minimal monochrome'
};

// Gradient color palettes for different modes
const GRADIENT_PALETTES = {
    tier: {
        // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
        T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
        T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
        T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
        UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
    },
    file: {
        // Rainbow hues distributed across files
        saturation: 65,
        lightness: 48
    },
    flow: {
        // Cold (low prob) to Hot (high prob)
        cold: { h: 220, s: 60, l: 45 },   // Blue
        warm: { h: 45, s: 85, l: 50 },    // Yellow
        hot: { h: 0, s: 90, l: 55 }       // Red
    },
    depth: {
        // Shallow (bright) to Deep (dark, saturated)
        shallow: { h: 180, s: 50, l: 65 },  // Light cyan
        mid: { h: 260, s: 70, l: 50 },      // Purple
        deep: { h: 320, s: 80, l: 40 }      // Magenta
    },
    semantic: {
        // Similar (harmonious) to Different (contrasting)
        similar: { h: 150, s: 60, l: 50 },    // Green - same type
        related: { h: 200, s: 65, l: 48 },    // Cyan - related
        different: { h: 340, s: 75, l: 50 }   // Pink - different
    }
};

// FILE_HUE_MAP, buildFileHueMap - provided by edge-system.js module

// Get node tier value (0=T0, 1=T1, 2=T2)
// getNodeTierValue, getNodeDepth, getSemanticSimilarity - MOVED TO modules/node-helpers.js

// interpolateColor, applyColorTweaks, oklchToSrgb, oklchColor - MOVED TO modules/color-engine.js
// Use COLOR.interpolate() and COLOR.get() instead

// getGradientEdgeColor - MOVED TO modules/edge-system.js
// clamp01, clampValue - MOVED TO modules/utils.js
// hslColor REMOVED - Using OKLCH Native via Color.interpolate
// parseOklchString - MOVED TO modules/utils.js
// normalizeColorInput, toColorNumber - MOVED TO modules/color-helpers.js

// updateEdgeRanges, refreshNodeFileIndex, getLinkFileIdx - MOVED TO modules/edge-system.js
// (shims delegate to EDGE.updateRanges, EDGE.refreshNodeFileIndex; getLinkFileIdx is internal)

// normalizeMetric - MOVED TO modules/utils.js
// getEdgeColor, getEdgeWidth, applyEdgeMode, cycleEdgeMode, setEdgeMode - MOVED TO modules/edge-system.js
// (backward compat shims in edge-system.js)

// Datamap toggles are wired in buildDatamapControls().
const btnReport = document.getElementById('btn-report');
if (btnReport) {
    btnReport.onclick = () => {
        const panel = document.getElementById('report-panel');
        const btn = document.getElementById('btn-report');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// AI INSIGHTS PANEL TOGGLE
const btnInsights = document.getElementById('btn-insights');
if (btnInsights) {
    btnInsights.onclick = () => {
        const panel = document.getElementById('insights-panel');
        const btn = document.getElementById('btn-insights');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// setStarsVisible, STARS_STORAGE_KEY, stars toggle binding - MOVED TO modules/stars.js
// Call STARS.init() to initialize (done in modules/main.js)

// Reset Layout button - explicitly re-run physics
const btnResetLayout = document.getElementById('btn-reset-layout');
if (btnResetLayout) {
    btnResetLayout.onclick = () => resetLayout();
}

// Hints toggle - enable/disable mode toasts
const btnHints = document.getElementById('btn-hints');
if (btnHints) {
    btnHints.onclick = () => {
        HINTS_ENABLED = !HINTS_ENABLED;
        btnHints.classList.toggle('active', HINTS_ENABLED);
        if (HINTS_ENABLED) {
            showModeToast('Hints enabled');
        }
    };
}

const btnEdgeMode = document.getElementById('btn-edge-mode');
if (btnEdgeMode) {
    btnEdgeMode.onclick = () => cycleEdgeMode();
}

// ====================================================================
// FLOW MODE: Markov Chain Visualization (Token-Driven)
// ====================================================================
// flowMode hoisted to top
let originalLinkWidths = new Map();
let highEntropyNodes = new Set();
// FLOW_CONFIG is set in initGraph() from THE REMOTE CONTROL tokens

// getFlowPresetColor, getFlowPresetValue - MOVED TO modules/flow.js

// FLOW_PRESETS, currentFlowPreset - MOVED TO modules/flow.js

// toggleFlowMode, disableFlowMode, applyFlowVisualization, clearFlowVisualization - MOVED TO modules/flow.js

// setDatamap, setNodeColorMode, applyDatamap - MOVED TO modules/datamap.js

// ====================================================================
// FILE BOUNDARIES & HOVER SYSTEM
// ====================================================================
// NOTE: fileBoundaryMeshes, fileMode, fileVizMode, etc. declared at top of file

// hashToUnit - MOVED TO modules/utils.js
// getFileHue, getFileColor - MOVED TO modules/color-helpers.js
// updateHoverPanel, handleNodeHover, handleNodeClick - MOVED TO modules/hover.js
// buildDatasetKey - MOVED TO modules/utils.js
// loadGroups, saveGroups, getNextGroupColor, getGroupById, getPrimaryGroupForNode - MOVED TO modules/groups.js
// renderGroupList, updateGroupButtonState, createGroupFromSelection - MOVED TO modules/groups.js

// getSelectedNodes, setSelection, toggleSelection, clearSelection, maybeClearSelection - MOVED TO modules/selection.js
// Use SELECT.getSelectedNodes(), SELECT.set(), SELECT.toggle(), SELECT.clear(), SELECT.maybeClear()
// Shims in selection.js provide global function names for backward compatibility


function handleNodeHover(node, data) {
    const filePanel = document.getElementById('file-panel');
    HOVERED_NODE = node || null;

    // Always update hover panel (separate from file panel)
    updateHoverPanel(node);

    // Guard: file-panel may not exist in minimal template
    if (!filePanel) return;

    if (!VIS_FILTERS.metadata.showFilePanel) {
        filePanel.classList.remove('visible');
        return;
    }

    if (!node) {
        // Mouse left node - hide panel after delay
        setTimeout(() => {
            if (!fileMode) filePanel.classList.remove('visible');
        }, 300);
        return;
    }

    // Get file info from boundaries
    const boundaries = data.file_boundaries || [];
    const fileIdx = node.fileIdx;

    if (fileIdx < 0 || fileIdx >= boundaries.length) {
        return;
    }

    const fileInfo = boundaries[fileIdx];

    // Update panel content (with null checks for minimal template)
    const setEl = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.textContent = val;
    };
    setEl('file-name', fileInfo.file_name || 'unknown');
    setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
    setEl('file-purpose', fileInfo.purpose || '--');
    setEl('file-atom-count', fileInfo.atom_count || 0);
    setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
    setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
    setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

    // Show code preview from node body
    const code = node.body || '// no source available';
    setEl('file-code', code);

    // Show panel and trigger smart placement
    filePanel.classList.add('visible');
    HudLayoutManager.reflow();
}

function handleNodeClick(node, event) {
    if (!node) return;
    const additive = event && event.shiftKey;
    if (additive) {
        toggleSelection(node);
        return;
    }
    if (node.id) {
        setSelection([node.id]);
    }
    if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
        toggleFileExpand(node.fileIdx);
    }
}


// ====================================================================
// FILE MODE HANDLERS
// ====================================================================

// setFileModeState - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setEnabled)

const btnFiles = document.getElementById('btn-files');
if (btnFiles) btnFiles.onclick = () => setFileModeState(!fileMode);

// COLOR mode - atoms colored by file
const btnFileColor = document.getElementById('btn-file-color');
if (btnFileColor) btnFileColor.onclick = () => setFileVizMode('color');

// HULLS mode - draw boundary spheres
const btnFileHulls = document.getElementById('btn-file-hulls');
if (btnFileHulls) btnFileHulls.onclick = () => setFileVizMode('hulls');

// CLUSTER mode - force clustering by file
const btnFileCluster = document.getElementById('btn-file-cluster');
if (btnFileCluster) btnFileCluster.onclick = () => setFileVizMode('cluster');

// MAP mode - show file nodes
const btnFileMap = document.getElementById('btn-file-map');
if (btnFileMap) btnFileMap.onclick = () => setFileVizMode('map');

// SPHERES mode - show containment spheres (button may be hidden)
const spheresBtn = document.getElementById('btn-file-spheres');
if (spheresBtn) spheresBtn.onclick = () => setFileVizMode('spheres');

// POP button - toggle boundary pop/restore (button may be hidden)
const popBtn = document.getElementById('btn-file-pop');
if (popBtn) {
    popBtn.onclick = () => {
        if (!FILE_CONTAINMENT.boundariesPopped) {
            popBoundaries(3000);
            popBtn.classList.add('active');
            popBtn.textContent = 'RESTORE';
            showToast('Boundaries popped! Particles in slow-motion chaos...');
        } else {
            restoreBoundaries(2000);
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
            showToast('Boundaries restored. Order from chaos.');
        }
    };
}

// Expand mode toggles (only relevant in MAP mode)
const btnExpandInline = document.getElementById('btn-expand-inline');
if (btnExpandInline) {
    btnExpandInline.onclick = () => {
        FILE_EXPAND_MODE = 'inline';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}

const btnExpandDetach = document.getElementById('btn-expand-detach');
if (btnExpandDetach) {
    btnExpandDetach.onclick = () => {
        FILE_EXPAND_MODE = 'detach';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}


// setFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setMode)

// applyFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.apply)

// scheduleHullRedraw - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.scheduleHullRedraw)

// applyFileColors - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.applyColors)

// clearFileBoundaries - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearBoundaries)

// Moved here to avoid temporal dead zone issue
let fileCohesionActive = false;

// clearAllFileModes - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearAllModes)

// applyClusterForce, applyFileCohesion, clearFileCohesion - MOVED TO modules/file-viz.js

// ════════════════════════════════════════════════════════════════════════
// SURFACE PARITY HANDLERS - Architectural Enforcements
// ════════════════════════════════════════════════════════════════════════

// Panel Handlers - use togglePanel('view') etc. or PANELS.toggle('view')
// togglePanelView/Filter/Style/Settings - simplified via modules/panels.js


// Action Handlers
function handleCmdFlow() { toggleFlowMode(); }
function handleCmd3d() { toggleDimensions(); }

// PanelManager - provided by panels.js module (window.PANEL_DRAG, window.PanelManager)

// =================================================================
// THEME SWITCHING - MOVED TO modules/theme.js
// setTheme, getTheme, getAvailableThemes, cycleTheme, initTheme

// Initialize theme on DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        // Small delay to ensure CSS vars are loaded
        setTimeout(initTheme, 50);
    });
} else {
    setTimeout(initTheme, 50);
}

// Expose theme functions globally
window.setTheme = setTheme;
window.getTheme = getTheme;
window.getAvailableThemes = getAvailableThemes;
window.cycleTheme = cycleTheme;
window.THEME_CONFIG = THEME_CONFIG;

// Expose filtering/graph globals for module access
window.VIS_FILTERS = VIS_FILTERS;
window.refreshGraph = refreshGraph;

    </script>
</body>

</html>