<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Collider v4.0.0</title>
    <style>
        /* ═══════════════════════════════════════════════════════════════════
           COLLIDER UI - Dual Sidebar Layout
           ═══════════════════════════════════════════════════════════════════ */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --surface: rgba(15, 15, 22, 0.85);
            --surface-hover: rgba(25, 25, 35, 0.9);
            --border: rgba(255, 255, 255, 0.08);
            --border-accent: rgba(74, 158, 255, 0.3);
            --text: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.5);
            --text-muted: rgba(255, 255, 255, 0.3);
            --accent: #4a9eff;
            --accent-dim: rgba(74, 158, 255, 0.15);
            --accent-glow: rgba(74, 158, 255, 0.25);
            --green: #5a9a70;
            --yellow: #a09060;
            --red: #b07070;
            --cyan: #7090a0;
            --sidebar-width: 300px;
            --right-panel-width: 280px;
            --min-sidebar-width: 240px;
            --max-sidebar-width: 500px;
            --header-height: 48px;
            --radius: 8px;
            --radius-sm: 4px;
            --glass: blur(12px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            font-size: 12px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LOADER
           ═══════════════════════════════════════════════════════════════════ */
        #loader {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 9999;
            font-size: 14px;
            letter-spacing: 2px;
        }

        #loader-status {
            font-size: 11px;
            opacity: 0.5;
        }

        /* ═══════════════════════════════════════════════════════════════════
           HEADER - Top bar spanning full width
           ═══════════════════════════════════════════════════════════════════ */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 24px;
            z-index: 200;
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 1px;
            color: var(--accent);
        }

        .logo span {
            opacity: 0.5;
            font-size: 10px;
            margin-left: 6px;
            color: var(--text);
        }

        .header-stats {
            display: flex;
            gap: 20px;
            font-size: 11px;
        }

        .stat {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .stat-label {
            opacity: 0.4;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            color: var(--cyan);
        }

        .target-name {
            margin-left: auto;
            font-size: 11px;
            opacity: 0.5;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ═══════════════════════════════════════════════════════════════════
           MAIN LAYOUT - Graph container
           ═══════════════════════════════════════════════════════════════════ */
        #3d-graph {
            position: fixed;
            top: var(--header-height);
            left: var(--sidebar-width);
            right: var(--right-panel-width);
            bottom: 0;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LEFT SIDEBAR - Controls & Filters
           ═══════════════════════════════════════════════════════════════════ */
        #left-sidebar {
            position: fixed;
            top: var(--header-height);
            left: 0;
            bottom: 0;
            width: var(--sidebar-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
        }

        #left-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #left-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #left-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           RIGHT SIDEBAR - Info Panels
           ═══════════════════════════════════════════════════════════════════ */
        #right-sidebar {
            position: fixed;
            top: var(--header-height);
            right: 0;
            bottom: 0;
            width: var(--right-panel-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #right-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #right-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #right-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SIDEBAR RESIZE DIVIDERS - Horizontal drag handles
           ═══════════════════════════════════════════════════════════════════ */
        .sidebar-resize-handle {
            position: fixed;
            top: var(--header-height);
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 101;
            background: transparent;
            transition: background 0.15s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.25);
        }

        .sidebar-resize-handle.left {
            left: calc(var(--sidebar-width) - 3px);
        }

        .sidebar-resize-handle.right {
            right: calc(var(--right-panel-width) - 3px);
        }

        /* Visual indicator line */
        .sidebar-resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 40px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .sidebar-resize-handle:hover::after {
            opacity: 1;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION - Collapsible sections
           ═══════════════════════════════════════════════════════════════════ */
        .section {
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            padding: 12px 14px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.15s;
        }

        .section-header:hover {
            opacity: 0.9;
            background: var(--surface-hover);
        }

        .section-header .arrow {
            transition: transform 0.2s;
            font-size: 8px;
        }

        .section-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        /* PRIME SECTIONS - Highlighted config sections (muted) */
        .section.prime {
            background: linear-gradient(180deg, rgba(100, 110, 130, 0.03) 0%, transparent 100%);
            border-left: 2px solid rgba(100, 110, 130, 0.3);
        }

        .section.prime .section-header {
            opacity: 0.75;
            color: var(--text-secondary);
        }

        .section.prime .section-header:hover {
            opacity: 0.9;
        }

        .section-content {
            padding: 8px 14px 14px;
            overflow-y: auto;
            transition: max-height 0.2s ease;
        }

        .section-content.collapsed {
            display: none;
        }

        /* RESIZABLE SECTIONS - Vertical drag handles */
        .section-resize-handle {
            height: 4px;
            cursor: ns-resize;
            background: transparent;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
            position: relative;
        }

        .section-resize-handle:hover,
        .section-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.2);
        }

        .section-resize-handle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 2px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .section-resize-handle:hover::after {
            opacity: 1;
        }

        /* Section content height constraints when resizing */
        .section-content.resizable {
            min-height: 60px;
            max-height: 400px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           VIEW MODE TOGGLE - ATOMS vs FILES (top of left sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            padding: 8px 10px;
            background: linear-gradient(180deg, rgba(74, 158, 255, 0.08) 0%, rgba(74, 158, 255, 0.02) 100%);
            border-bottom: 2px solid var(--accent);
        }

        .view-mode-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .view-mode-btn:first-child {
            border-radius: var(--radius-sm) 0 0 var(--radius-sm);
            border-right: none;
        }

        .view-mode-btn:last-child {
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        }

        .view-mode-btn:hover {
            background: rgba(74, 158, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        .view-mode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
        }

        .view-mode-icon {
            font-size: 14px;
        }

        .view-mode-label {
            font-size: 10px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════════════
           BUTTON GRID - For presets and actions
           ═══════════════════════════════════════════════════════════════════ */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .btn-grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .btn-grid-4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .btn-grid-6 {
            grid-template-columns: repeat(6, 1fr);
        }

        .btn {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            font-size: 9px;
            font-weight: 500;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: var(--border-accent);
        }

        .btn.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        /* Icon buttons */
        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SLIDERS
           ═══════════════════════════════════════════════════════════════════ */
        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .slider-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .slider-label {
            opacity: 0.6;
        }

        .slider-value {
            display: none;
            /* Replaced by input */
        }

        .number-input {
            width: 48px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--cyan);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 10px;
            padding: 2px 4px;
            text-align: right;
            -moz-appearance: textfield;
        }

        .number-input::-webkit-outer-spin-button,
        .number-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.4);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px var(--accent-glow);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }

        /* ═══════════════════════════════════════════════════════════════════
           FILTER CHIPS
           ═══════════════════════════════════════════════════════════════════ */
        .filter-group {
            margin-bottom: 12px;
        }

        .filter-group:last-child {
            margin-bottom: 0;
        }

        .filter-label {
            font-size: 9px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .chip {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 14px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .chip.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
        }

        .chip .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOGGLE SWITCHES
           ═══════════════════════════════════════════════════════════════════ */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            padding: 6px 0;
        }

        .toggle-row .toggle-label {
            opacity: 0.7;
        }

        .toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text);
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle.active::after {
            transform: translateX(16px);
        }

        /* ═══════════════════════════════════════════════════════════════════
           INFO PANEL - Right sidebar node info
           ═══════════════════════════════════════════════════════════════════ */
        .info-panel {
            padding: 14px;
            border-bottom: 1px solid var(--border);
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .info-panel-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .node-info {
            display: none;
        }

        .node-info.visible {
            display: block;
        }

        .node-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
            word-break: break-all;
            color: var(--cyan);
        }

        .node-kind {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row .label {
            opacity: 0.4;
        }

        .info-row .value {
            text-align: right;
        }

        .node-file {
            font-size: 9px;
            opacity: 0.3;
            margin-top: 10px;
            word-break: break-all;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .placeholder-text {
            font-size: 10px;
            opacity: 0.3;
            text-align: center;
            padding: 20px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SELECTION PANEL
           ═══════════════════════════════════════════════════════════════════ */
        .selection-panel {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
        }

        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .selection-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .selection-count {
            font-size: 9px;
            padding: 2px 8px;
            background: var(--accent-dim);
            border-radius: 10px;
            color: var(--accent);
        }

        .selection-clear {
            font-size: 9px;
            padding: 4px 8px;
            background: none;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            cursor: pointer;
        }

        .selection-clear:hover {
            color: var(--text);
            border-color: var(--text-dim);
        }

        .selection-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .selection-item {
            font-size: 10px;
            padding: 6px 8px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            margin-bottom: 2px;
            background: rgba(255, 255, 255, 0.02);
        }

        .selection-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--accent);
        }

        /* ═══════════════════════════════════════════════════════════════════
           STATS PANEL (bottom of right sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .stats-panel {
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid var(--border);
            margin-top: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stats-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-sm);
        }

        .stats-item .value {
            font-size: 16px;
            font-weight: 600;
            color: var(--cyan);
            font-variant-numeric: tabular-nums;
        }

        .stats-item .label {
            font-size: 8px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           COLOR PANELS (right sidebar color controls)
           ═══════════════════════════════════════════════════════════════════ */
        .color-panel,
        .schemes-panel {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
        }

        .color-panel .section-content,
        .schemes-panel .section-content {
            padding: 0;
            margin-top: 10px;
        }

        .color-panel .btn-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .color-panel .btn {
            padding: 6px 8px;
            font-size: 9px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .color-panel .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .color-panel .btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        /* Collapsible header for schemes panel */
        .info-panel-header.collapsible {
            cursor: pointer;
            user-select: none;
        }

        .info-panel-header.collapsible:hover {
            opacity: 0.9;
        }

        .info-panel-header .collapse-icon {
            font-size: 8px;
            transition: transform 0.2s;
        }

        .info-panel-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .schemes-panel .section-content {
            max-height: 250px;
            overflow-y: auto;
        }

        .schemes-panel .section-content::-webkit-scrollbar {
            width: 4px;
        }

        .schemes-panel .section-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .schemes-panel .section-content.collapsed {
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           PERFORMANCE HUD (optional overlay)
           ═══════════════════════════════════════════════════════════════════ */
        #perf-hud {
            position: fixed;
            top: calc(var(--header-height) + 8px);
            left: calc(var(--sidebar-width) + 8px);
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-family: 'SF Mono', Monaco, monospace;
            z-index: 150;
            display: none;
        }

        #perf-hud.visible {
            display: block;
        }

        .perf-row {
            display: flex;
            gap: 12px;
        }

        .perf-label {
            opacity: 0.5;
        }

        .perf-value {
            font-variant-numeric: tabular-nums;
        }

        .perf-good {
            color: var(--green);
        }

        .perf-warn {
            color: var(--yellow);
        }

        .perf-bad {
            color: var(--red);
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════════════ */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--surface);
            border: 1px solid var(--border-accent);
            padding: 12px 24px;
            border-radius: var(--radius);
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Selection box for drag select */
        #selection-box {
            position: fixed;
            border: 1px solid var(--accent);
            background: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION-SPECIFIC STYLING
           ═══════════════════════════════════════════════════════════════════ */

        /* Color mode buttons with color indicators */
        .color-btn {
            position: relative;
        }

        .color-btn::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .color-btn[data-preset="tier"]::before {
            background: #ff6b6b;
        }

        .color-btn[data-preset="family"]::before {
            background: #4ecdc4;
        }

        .color-btn[data-preset="layer"]::before {
            background: #95e1d3;
        }

        .color-btn[data-preset="ring"]::before {
            background: #f9ed69;
        }

        .color-btn[data-preset="file"]::before {
            background: #a8e6cf;
        }

        .color-btn[data-preset="flow"]::before {
            background: #dcd6f7;
        }

        /* Layout buttons with mini icons */
        .layout-btn {
            height: 32px;
        }
    </style>

    <script>
        window.process = window.process || { env: { NODE_ENV: "production" } };
        window.global = window.global || window;
    </script>
    <!-- THREE.js r149 (last version without deprecation warning) + 3d-force-graph -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
</head>

<body>
    <!-- Loader -->
    <div id="loader">
        <div>INITIALIZING...</div>
        <div id="loader-status">Loading data...</div>
    </div>

    <!-- Header -->
    <div id="header">
        <div class="logo">COLLIDER <span>v4.0.0</span></div>
        <div class="header-stats">
            <div class="stat">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="stat-nodes">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="stat-edges">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Entropy</span>
                <span class="stat-value" id="stat-entropy">--</span>
            </div>
        </div>
        <div class="target-name" id="target-name"></div>
    </div>

    <!-- Left Sidebar -->
    <div id="left-sidebar">
        <!-- VIEW MODE TOGGLE - TOP PRIORITY -->
        <div class="view-mode-toggle" id="view-mode-toggle">
            <button class="view-mode-btn active" data-mode="atoms">
                <span class="view-mode-icon">◉</span>
                <span class="view-mode-label">ATOMS</span>
            </button>
            <button class="view-mode-btn" data-mode="files">
                <span class="view-mode-icon">◫</span>
                <span class="view-mode-label">FILES</span>
            </button>
        </div>

        <!-- MAPPING CONTROL (Docked) -->
        <div class="section prime" id="control-bar-container">
            <!-- Injected by control-bar.js -->
        </div>

        <!-- NODE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="node-config">
                <span>⬢ Node Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-node-config">
                <!-- Size Mode Selector -->
                <div class="filter-group">
                    <div class="filter-label">Size Mode</div>
                    <div class="btn-grid btn-grid-4">
                        <button class="btn active" data-size-mode="uniform">Uniform</button>
                        <button class="btn" data-size-mode="degree">Degree</button>
                        <button class="btn" data-size-mode="fanout">Fanout</button>
                        <button class="btn" data-size-mode="complexity">Complex</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Base Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-size" min="0.2" max="4" step="0.1" value="1">
                        <input type="number" id="cfg-node-size-num" class="number-input" min="0.2" max="4" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-opacity" min="0.1" max="1" step="0.05" value="1">
                        <input type="number" id="cfg-node-opacity-num" class="number-input" min="0.1" max="1"
                            step="0.05" value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Resolution</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-res" min="4" max="32" step="4" value="8">
                        <input type="number" id="cfg-node-res-num" class="number-input" min="4" max="32" step="4"
                            value="8">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Label Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-label-size" min="0" max="3" step="0.1" value="1">
                        <input type="number" id="cfg-label-size-num" class="number-input" min="0" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="cfg-toggle-labels"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight Selected</span>
                    <div class="toggle active" id="cfg-toggle-highlight"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Pulse Animation</span>
                    <div class="toggle" id="cfg-toggle-pulse"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">3D Depth Shading</span>
                    <div class="toggle active" id="cfg-toggle-depth"></div>
                </div>
            </div>
        </div>

        <!-- EDGE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="edge-config">
                <span>⟷ Edge Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-edge-config">
                <!-- Edge Style Selector -->
                <div class="filter-group">
                    <div class="filter-label">Edge Style</div>
                    <div class="btn-grid">
                        <button class="btn active" data-edge-style="solid">Solid</button>
                        <button class="btn" data-edge-style="dashed">Dashed</button>
                        <button class="btn" data-edge-style="particle">Particle</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-opacity" min="0" max="1" step="0.05" value="0.6">
                        <input type="number" id="cfg-edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.6">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Width</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-width" min="0.2" max="5" step="0.2" value="1.5">
                        <input type="number" id="cfg-edge-width-num" class="number-input" min="0.2" max="5" step="0.1"
                            value="1.5">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Curvature</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-curve" min="0" max="1" step="0.05" value="0">
                        <input type="number" id="cfg-edge-curve-num" class="number-input" min="0" max="1" step="0.05"
                            value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Speed</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-speed" min="0" max="0.05" step="0.005" value="0.01">
                        <input type="number" id="cfg-particle-speed-num" class="number-input" min="0" max="0.05"
                            step="0.005" value="0.01">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Density</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-count" min="0" max="10" step="1" value="0">
                        <input type="number" id="cfg-particle-count-num" class="number-input" min="0" max="10" step="1"
                            value="0">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Arrows</span>
                    <div class="toggle" id="cfg-toggle-arrows"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Gradient Colors</span>
                    <div class="toggle active" id="cfg-toggle-gradient"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight on Hover</span>
                    <div class="toggle active" id="cfg-toggle-edge-hover"></div>
                </div>
            </div>
        </div>

        <!-- LAYOUT -->
        <div class="section">
            <div class="section-header" data-section="layout">
                <span>Layout</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-layout">
                <div class="btn-grid">
                    <button class="btn layout-btn active" data-layout="force">Force</button>
                    <button class="btn layout-btn" data-layout="radial">Radial</button>
                    <button class="btn layout-btn" data-layout="orbital">Orbital</button>
                    <button class="btn layout-btn" data-layout="sphere">Sphere</button>
                    <button class="btn layout-btn" data-layout="grid">Grid</button>
                    <button class="btn layout-btn" data-layout="spiral">Spiral</button>
                </div>
            </div>
        </div>

        <!-- PHYSICS -->
        <div class="section">
            <div class="section-header" data-section="physics">
                <span>Physics</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-physics">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Repulsion</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-charge" min="-500" max="0" value="-120">
                        <input type="number" id="physics-charge-num" class="number-input" min="-500" max="0"
                            value="-120">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Link Distance</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-link" min="10" max="200" value="50">
                        <input type="number" id="physics-link-num" class="number-input" min="10" max="200" value="50">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Center Pull</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-center" min="0" max="0.5" step="0.01" value="0.05">
                        <input type="number" id="physics-center-num" class="number-input" min="0" max="0.5" step="0.01"
                            value="0.05">
                    </div>
                </div>
                <div class="btn-grid btn-grid-4" style="margin-top: 8px;">
                    <button class="btn" data-physics="default">Def</button>
                    <button class="btn" data-physics="tight">Tight</button>
                    <button class="btn" data-physics="loose">Loose</button>
                    <button class="btn" data-physics="explosive">Boom</button>
                </div>
            </div>
        </div>

        <!-- APPEARANCE -->
        <div class="section">
            <div class="section-header" data-section="appearance">
                <span>Appearance</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-appearance">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Node Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="node-size" min="0.2" max="3" step="0.1" value="1">
                        <input type="number" id="node-size-num" class="number-input" min="0.2" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Edge Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="edge-opacity" min="0" max="1" step="0.05" value="0.4">
                        <input type="number" id="edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.4">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="toggle-labels"></div>
                </div>
                <!-- Starfield toggle REMOVED - nodes ARE the stars -->
            </div>
        </div>

        <!-- FILTERS -->
        <div class="section">
            <div class="section-header" data-section="filters">
                <span>Filters</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-filters">
                <div class="filter-group">
                    <div class="filter-label">Tiers</div>
                    <div class="chips" id="filter-tiers"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Rings</div>
                    <div class="chips" id="filter-rings"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Edge Types</div>
                    <div class="chips" id="filter-edges"></div>
                </div>
            </div>
        </div>

        <!-- ACTIONS -->
        <div class="section">
            <div class="section-header collapsed" data-section="actions">
                <span>Actions</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content collapsed" id="section-actions">
                <div class="btn-grid btn-grid-2">
                    <button class="btn" id="btn-reset">Reset View</button>
                    <button class="btn" id="btn-screenshot">Screenshot</button>
                    <button class="btn" id="btn-2d">Toggle 2D</button>
                    <button class="btn" id="btn-freeze">Freeze</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Graph Container -->
    <div id="3d-graph"></div>

    <!-- Sidebar Resize Handles -->
    <div class="sidebar-resize-handle left" id="left-resize-handle"></div>
    <div class="sidebar-resize-handle right" id="right-resize-handle"></div>

    <!-- Right Sidebar -->
    <div id="right-sidebar">
        <!-- Hover Info Panel -->
        <div class="info-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Node Info</span>
            </div>
            <div class="node-info" id="hover-panel">
                <div class="node-name" id="hover-name">Node Name</div>
                <div class="node-kind" id="hover-kind">function</div>
                <div class="info-row"><span class="label">Atom</span><span class="value" id="hover-atom">--</span></div>
                <div class="info-row"><span class="label">Family</span><span class="value" id="hover-family">--</span>
                </div>
                <div class="info-row"><span class="label">Ring</span><span class="value" id="hover-ring">--</span></div>
                <div class="info-row"><span class="label">Tier</span><span class="value" id="hover-tier">--</span></div>
                <div class="info-row"><span class="label">Role</span><span class="value" id="hover-role">--</span></div>
                <div class="node-file" id="hover-file"></div>
            </div>
            <div class="placeholder-text" id="hover-placeholder">Hover over a node to see details</div>
        </div>

        <!-- Selection Panel -->
        <div class="selection-panel">
            <div class="selection-header">
                <span class="selection-title">Selection</span>
                <span class="selection-count" id="selection-count">0</span>
            </div>
            <div id="selection-actions" style="display: none; margin-bottom: 10px;">
                <button class="selection-clear" id="selection-clear">Clear</button>
            </div>
            <div class="selection-list" id="selection-list">
                <div class="placeholder-text">Click nodes to select</div>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="value" id="stats-nodes">0</div>
                    <div class="label">Visible</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-edges">0</div>
                    <div class="label">Edges</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-files">0</div>
                    <div class="label">Files</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-density">--</div>
                    <div class="label">Density</div>
                </div>
            </div>
        </div>

        <!-- COLOR SCHEMES (33 Named Gradients) - Primary color selection -->
        <div class="info-panel schemes-panel">
            <div class="info-panel-header collapsible" data-target="section-schemes">
                <span class="info-panel-title">Color Schemes</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="section-content" id="section-schemes">
                <!-- Populated dynamically by sidebar.js -->
            </div>
        </div>

        <!-- COLOR MODE (Presets) - What dimension to color by -->
        <div class="info-panel color-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Color Mode</span>
            </div>
            <div class="section-content" id="section-color">
                <div class="btn-grid btn-grid-3">
                    <button class="btn color-btn active" data-preset="tier">Tier</button>
                    <button class="btn color-btn" data-preset="family">Family</button>
                    <button class="btn color-btn" data-preset="layer">Layer</button>
                    <button class="btn color-btn" data-preset="ring">Ring</button>
                    <button class="btn color-btn" data-preset="file">File</button>
                    <button class="btn color-btn" data-preset="flow">Flow</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance HUD -->
    <div id="perf-hud">
        <div class="perf-row">
            <span class="perf-label">FPS:</span>
            <span class="perf-value" id="perf-fps">60</span>
            <span class="perf-label">Frame:</span>
            <span class="perf-value" id="perf-frame">0ms</span>
        </div>
    </div>

    <!-- UPB Module (Universal Property Binder) -->
    <script src="assets/modules/upb/scales.js"></script>
    <script src="assets/modules/upb/endpoints.js"></script>
    <script src="assets/modules/upb/blenders.js"></script>
    <script src="assets/modules/upb/bindings.js"></script>
    <script src="assets/modules/upb/index.js"></script>

    <!-- Modules -->
    <script src="assets/modules/control-bar.js"></script>

    <!-- Toast -->
    <div id="toast"></div>

    <!-- Core Application Injection -->
    <div id="selection-box"></div>
    <script>
        // ═══ MODULE: performance.js ═══
/**
 * COLLIDER PERFORMANCE SUBSYSTEM
 *
 * Provides frame-budget-aware animation scheduling, adaptive quality management,
 * and real-time performance monitoring for the WebGL visualization.
 *
 * Architecture:
 *   PerformanceMonitor  → measures frame times, detects stuttering
 *   AnimationScheduler  → manages animation queue, enforces frame budget
 *   AdaptiveQuality     → degrades/upgrades quality based on performance
 *   PositionOwnership   → enforces single-owner invariant for node positions
 *
 * Usage:
 *   PERF.monitor.start()
 *   PERF.scheduler.requestTransition(nodes, targetPositions, duration)
 *   PERF.quality.current  // 'ultra' | 'high' | 'medium' | 'low' | 'minimal'
 */

const PERF = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION (loaded from performance.tokens.json or defaults)
    // =========================================================================

    const CONFIG = {
        frameBudget: {
            targetFps: 60,
            targetFrameMs: 16.67,
            warningThreshold: 0.8,   // 80% of budget
            criticalThreshold: 1.5   // 150% of budget
        },
        nodeThresholds: {
            small: 100,
            medium: 500,
            large: 1000,
            massive: 5000
        },
        monitoring: {
            sampleWindowMs: 1000,
            sampleCount: 60,
            degradeAfterConsecutiveDrops: 10,
            upgradeAfterConsecutiveGood: 30
        }
    };

    // =========================================================================
    // PERFORMANCE MONITOR
    // Tracks frame times using a rolling window
    // =========================================================================

    const PerformanceMonitor = {
        _frameTimes: [],
        _lastFrameTime: 0,
        _frameCount: 0,
        _droppedFrames: 0,
        _consecutiveDrops: 0,
        _consecutiveGood: 0,
        _isRunning: false,
        _rafId: null,

        start() {
            if (this._isRunning) return;
            this._isRunning = true;
            this._lastFrameTime = performance.now();
            this._tick();
        },

        stop() {
            this._isRunning = false;
            if (this._rafId) {
                cancelAnimationFrame(this._rafId);
                this._rafId = null;
            }
        },

        _tick() {
            if (!this._isRunning) return;

            const now = performance.now();
            const frameTime = now - this._lastFrameTime;
            this._lastFrameTime = now;

            // Record frame time
            this._frameTimes.push(frameTime);
            if (this._frameTimes.length > CONFIG.monitoring.sampleCount) {
                this._frameTimes.shift();
            }

            this._frameCount++;

            // Check for dropped frame
            const budget = CONFIG.frameBudget.targetFrameMs;
            if (frameTime > budget * CONFIG.frameBudget.criticalThreshold) {
                this._droppedFrames++;
                this._consecutiveDrops++;
                this._consecutiveGood = 0;

                // Trigger quality degradation check
                if (this._consecutiveDrops >= CONFIG.monitoring.degradeAfterConsecutiveDrops) {
                    AdaptiveQuality.degrade();
                    this._consecutiveDrops = 0;
                }
            } else if (frameTime < budget * CONFIG.frameBudget.warningThreshold) {
                this._consecutiveGood++;
                this._consecutiveDrops = 0;

                // Trigger quality upgrade check
                if (this._consecutiveGood >= CONFIG.monitoring.upgradeAfterConsecutiveGood) {
                    AdaptiveQuality.upgrade();
                    this._consecutiveGood = 0;
                }
            }

            this._rafId = requestAnimationFrame(() => this._tick());
        },

        get fps() {
            if (this._frameTimes.length < 2) return 0;
            const avg = this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
            return Math.round(1000 / avg);
        },

        get avgFrameTime() {
            if (this._frameTimes.length === 0) return 0;
            return this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
        },

        get lastFrameTime() {
            return this._frameTimes[this._frameTimes.length - 1] || 0;
        },

        get droppedFramePercent() {
            if (this._frameCount === 0) return 0;
            return Math.round((this._droppedFrames / this._frameCount) * 100);
        },

        get stats() {
            return {
                fps: this.fps,
                avgFrameTime: this.avgFrameTime.toFixed(2),
                lastFrameTime: this.lastFrameTime.toFixed(2),
                droppedPercent: this.droppedFramePercent,
                quality: AdaptiveQuality.current,
                owner: PositionOwnership.current
            };
        },

        reset() {
            this._frameTimes = [];
            this._frameCount = 0;
            this._droppedFrames = 0;
            this._consecutiveDrops = 0;
            this._consecutiveGood = 0;
        }
    };

    // =========================================================================
    // ADAPTIVE QUALITY MANAGER
    // Adjusts rendering quality based on performance
    // =========================================================================

    const QUALITY_TIERS = ['minimal', 'low', 'medium', 'high', 'ultra'];

    const QUALITY_SETTINGS = {
        ultra:   { refreshEvery: 1, flockEnabled: true,  labelDensity: 1.0, animDuration: 1500 },
        high:    { refreshEvery: 1, flockEnabled: false, labelDensity: 0.8, animDuration: 1200 },
        medium:  { refreshEvery: 2, flockEnabled: false, labelDensity: 0.5, animDuration: 800  },
        low:     { refreshEvery: 3, flockEnabled: false, labelDensity: 0.2, animDuration: 500  },
        minimal: { refreshEvery: 5, flockEnabled: false, labelDensity: 0.1, animDuration: 200  }
    };

    const AdaptiveQuality = {
        _current: 'high',
        _locked: false,
        _nodeCount: 0,
        _callbacks: [],

        init(nodeCount) {
            this._nodeCount = nodeCount;
            // Auto-select initial tier based on node count
            if (nodeCount <= CONFIG.nodeThresholds.small) {
                this._current = 'ultra';
            } else if (nodeCount <= CONFIG.nodeThresholds.medium) {
                this._current = 'high';
            } else if (nodeCount <= CONFIG.nodeThresholds.large) {
                this._current = 'medium';
            } else if (nodeCount <= CONFIG.nodeThresholds.massive) {
                this._current = 'low';
            } else {
                this._current = 'minimal';
            }
            console.log(`[PERF] Quality auto-set to '${this._current}' for ${nodeCount} nodes`);
            this._notify();
        },

        get current() { return this._current; },

        get settings() { return QUALITY_SETTINGS[this._current]; },

        set(tier) {
            if (!QUALITY_TIERS.includes(tier)) {
                console.warn(`[PERF] Unknown quality tier: ${tier}`);
                return;
            }
            this._current = tier;
            console.log(`[PERF] Quality set to '${tier}'`);
            this._notify();
        },

        degrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            if (idx > 0) {
                this._current = QUALITY_TIERS[idx - 1];
                console.log(`[PERF] Quality degraded to '${this._current}'`);
                this._notify();
            }
        },

        upgrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            // Don't upgrade beyond what node count allows
            const maxTier = this._getMaxTierForNodeCount();
            const maxIdx = QUALITY_TIERS.indexOf(maxTier);
            if (idx < maxIdx) {
                this._current = QUALITY_TIERS[idx + 1];
                console.log(`[PERF] Quality upgraded to '${this._current}'`);
                this._notify();
            }
        },

        lock() { this._locked = true; },
        unlock() { this._locked = false; },

        _getMaxTierForNodeCount() {
            const n = this._nodeCount;
            if (n <= CONFIG.nodeThresholds.small) return 'ultra';
            if (n <= CONFIG.nodeThresholds.medium) return 'high';
            if (n <= CONFIG.nodeThresholds.large) return 'medium';
            if (n <= CONFIG.nodeThresholds.massive) return 'low';
            return 'minimal';
        },

        onChange(callback) {
            this._callbacks.push(callback);
        },

        _notify() {
            this._callbacks.forEach(cb => cb(this._current, this.settings));
        }
    };

    // =========================================================================
    // POSITION OWNERSHIP
    // Enforces single-owner invariant for node positions (fx/fy/fz)
    // =========================================================================

    const OWNERS = ['none', 'transition', 'motion', 'flock', 'force'];

    const PositionOwnership = {
        _current: 'none',
        _animationId: null,

        get current() { return this._current; },

        acquire(owner, animationId = null) {
            if (!OWNERS.includes(owner)) {
                console.warn(`[PERF] Unknown position owner: ${owner}`);
                return false;
            }

            // Cancel any existing animation
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }

            this._current = owner;
            this._animationId = animationId;
            console.log(`[PERF] Position ownership: ${owner}`);
            return true;
        },

        release(owner) {
            if (this._current === owner) {
                if (this._animationId) {
                    cancelAnimationFrame(this._animationId);
                    this._animationId = null;
                }
                this._current = 'none';
                console.log(`[PERF] Position ownership released by ${owner}`);
            }
        },

        setAnimationId(id) {
            this._animationId = id;
        },

        cancelAnimation() {
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }
        }
    };

    // =========================================================================
    // ANIMATION SCHEDULER
    // Frame-budget-aware animation with throttling
    // =========================================================================

    const AnimationScheduler = {
        _refreshFrameCounter: 0,

        /**
         * Run a layout transition with frame budget awareness
         * @param {Object} options
         * @param {Array} options.nodes - Array of node objects
         * @param {Function} options.getTargetPosition - (node, index, total) => {x, y, z}
         * @param {number} options.duration - Animation duration in ms
         * @param {Function} options.onFrame - Called each frame with progress (0-1)
         * @param {Function} options.onComplete - Called when animation finishes
         * @param {Function} options.refresh - Function to call to refresh the graph
         */
        runTransition(options) {
            const { nodes, getTargetPosition, duration, onFrame, onComplete, refresh } = options;

            // Acquire ownership
            PositionOwnership.acquire('transition');

            const total = nodes.length;
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => getTargetPosition(n, i, total));

            const startTime = performance.now();
            const settings = AdaptiveQuality.settings;
            const actualDuration = Math.min(duration, settings.animDuration);

            this._refreshFrameCounter = 0;

            const animate = () => {
                // Check if we still own positions
                if (PositionOwnership.current !== 'transition') {
                    console.log('[PERF] Transition interrupted - lost ownership');
                    return;
                }

                const now = performance.now();
                const elapsed = now - startTime;
                const progress = Math.min(1, elapsed / actualDuration);

                // Smoothstep easing
                const eased = progress * progress * (3 - 2 * progress);

                // Update positions
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];
                    const s = startPos[i];
                    const t = targetPos[i];
                    n.fx = s.x + (t.x - s.x) * eased;
                    n.fy = s.y + (t.y - s.y) * eased;
                    n.fz = s.z + (t.z - s.z) * eased;
                }

                // Throttled refresh based on quality settings
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                if (onFrame) onFrame(progress);

                if (progress < 1) {
                    const id = requestAnimationFrame(animate);
                    PositionOwnership.setAnimationId(id);
                } else {
                    PositionOwnership.release('transition');
                    if (onComplete) onComplete();
                }
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Run continuous motion (rotate/orbit) with throttling
         */
        runMotion(options) {
            const { nodes, getPosition, speed, refresh } = options;

            PositionOwnership.acquire('motion');

            const total = nodes.length;
            const settings = AdaptiveQuality.settings;
            let time = 0;

            this._refreshFrameCounter = 0;

            const animate = () => {
                if (PositionOwnership.current !== 'motion') {
                    console.log('[PERF] Motion interrupted - lost ownership');
                    return;
                }

                time += speed;

                for (let i = 0; i < nodes.length; i++) {
                    const pos = getPosition(nodes[i], i, total, time);
                    nodes[i].fx = pos.x;
                    nodes[i].fy = pos.y;
                    nodes[i].fz = pos.z;
                }

                // Throttled refresh
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                const id = requestAnimationFrame(animate);
                PositionOwnership.setAnimationId(id);
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Stop any running animation
         */
        stop() {
            PositionOwnership.cancelAnimation();
            PositionOwnership._current = 'none';
        }
    };

    // =========================================================================
    // HUD OVERLAY
    // Real-time performance display (toggleable)
    // =========================================================================

    const HUD = {
        _element: null,
        _visible: false,
        _updateInterval: null,

        init() {
            this._element = document.createElement('div');
            this._element.id = 'perf-hud';
            this._element.style.cssText = `
                position: fixed;
                bottom: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.8);
                color: #0f0;
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
                padding: 8px 12px;
                border-radius: 4px;
                z-index: 10000;
                display: none;
                min-width: 140px;
                border: 1px solid #333;
            `;
            document.body.appendChild(this._element);
        },

        show() {
            if (!this._element) this.init();
            this._element.style.display = 'block';
            this._visible = true;
            this._startUpdates();
        },

        hide() {
            if (this._element) {
                this._element.style.display = 'none';
            }
            this._visible = false;
            this._stopUpdates();
        },

        toggle() {
            if (this._visible) this.hide();
            else this.show();
        },

        _startUpdates() {
            if (this._updateInterval) return;
            this._updateInterval = setInterval(() => this._update(), 100);
        },

        _stopUpdates() {
            if (this._updateInterval) {
                clearInterval(this._updateInterval);
                this._updateInterval = null;
            }
        },

        _update() {
            if (!this._element || !this._visible) return;

            const stats = PerformanceMonitor.stats;
            const fpsColor = stats.fps >= 55 ? '#0f0' : stats.fps >= 30 ? '#ff0' : '#f00';

            this._element.innerHTML = `
                <div style="color: ${fpsColor}; font-weight: bold;">${stats.fps} FPS</div>
                <div style="color: #888;">Frame: ${stats.lastFrameTime}ms</div>
                <div style="color: #888;">Avg: ${stats.avgFrameTime}ms</div>
                <div style="color: #888;">Drops: ${stats.droppedPercent}%</div>
                <div style="color: #0af;">Quality: ${stats.quality}</div>
                <div style="color: #a0f;">Owner: ${stats.owner}</div>
            `;
        }
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        monitor: PerformanceMonitor,
        quality: AdaptiveQuality,
        ownership: PositionOwnership,
        scheduler: AnimationScheduler,
        hud: HUD,
        config: CONFIG,

        /**
         * Initialize the performance subsystem
         * @param {number} nodeCount - Number of nodes in the graph
         * @param {Object} tokens - Optional performance tokens from JSON
         */
        init(nodeCount, tokens = null) {
            if (tokens) {
                Object.assign(CONFIG, tokens);
            }
            AdaptiveQuality.init(nodeCount);
            PerformanceMonitor.start();
            HUD.init();
            console.log('[PERF] Performance subsystem initialized');
        },

        /**
         * Check if flock simulation should be enabled
         */
        isFlockAllowed() {
            return AdaptiveQuality.settings.flockEnabled;
        },

        /**
         * Get current animation duration (adjusted for quality)
         */
        getAnimationDuration(requested) {
            return Math.min(requested, AdaptiveQuality.settings.animDuration);
        }
    };
})();

// Export for module systems if available
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PERF;
}


// ═══ MODULE: modules/utils.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UTILS MODULE - Pure Utility Functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Zero-dependency pure functions for math, string, and data operations.
 * These functions have NO external state dependencies and can be used anywhere.
 *
 * @module UTILS
 * @version 1.0.0
 * @confidence 99%
 */

window.UTILS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // MATH UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clamp value to [0, 1] range
     * @param {number} value - Value to clamp
     * @returns {number} Clamped value
     */
    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    /**
     * Clamp value to [min, max] range
     * @param {number} value - Value to clamp
     * @param {number} min - Minimum bound
     * @param {number} max - Maximum bound
     * @returns {number} Clamped value
     */
    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Normalize value to [0, 1] based on max.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} val - Value to normalize
     * @param {number} max - Maximum value
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value
     */
    function normalize(val, max, scaleName) {
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', val, 0, max);
        }
        // Fallback
        return Math.min(1, Math.max(0, val / max));
    }

    /**
     * Normalize metric value based on range.
     * NOW DELEGATES TO UPB_SCALES when available.
     *
     * @param {number} value - Value to normalize
     * @param {min: number, max: number} range - Range object
     * @param {string} [scaleName] - Optional scale name (linear, log, sqrt)
     * @returns {number} Normalized value in [0, 1]
     */
    function normalizeMetric(value, range, scaleName) {
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }
        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(scaleName || 'linear', value, range.min, range.max);
        }
        // Fallback
        return clamp01((value - range.min) / (range.max - range.min));
    }

    /**
     * Calculate quantile from sorted values
     * @param {number[]} values - Array of numbers
     * @param {number} q - Quantile (0-1)
     * @returns {number} Quantile value
     */
    function quantile(values, q) {
        if (!values.length) return 0;
        const sorted = values.slice().sort((a, b) => a - b);
        const pos = (sorted.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;
        if (sorted[base + 1] !== undefined) {
            return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
        }
        return sorted[base];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HASH & SEED UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Convert any value to a unit float [0, 1] via hashing
     * @param {*} value - Any value to hash
     * @returns {number} Hash as unit float
     */
    function hashToUnit(value) {
        const str = String(value || '');
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return (hash >>> 0) / 0xffffffff;
    }

    /**
     * Generate stable seed from node and salt
     * @param {Object} node - Node object with id/name
     * @param {string} salt - Salt string
     * @returns {number} Stable seed in [0, 1]
     */
    function stableSeed(node, salt) {
        const id = String(node.id || node.name || '');
        const combined = `${id}|${salt}`;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
            hash = ((hash << 5) - hash + combined.charCodeAt(i)) | 0;
        }
        return ((hash >>> 0) % 1000) / 1000;
    }

    /**
     * Generate stable Z offset for node
     * @param {Object} node - Node object
     * @returns {number} Z offset
     */
    function stableZ(node) {
        const normalized = stableSeed(node, 'z');
        return (normalized - 0.5) * 60;
    }

    /**
     * Generate stable offset vector for node positioning
     * @param {Object} node - Node object
     * @param {string} salt - Salt string
     * @param {number} radius - Base radius
     * @returns {x: number, y: number, z: number} Offset vector
     */
    function stableOffset(node, salt, radius) {
        const angle = stableSeed(node, `${salt}:angle`) * Math.PI * 2;
        const spread = 0.3 + stableSeed(node, `${salt}:radius`) * 0.7;
        const zJitter = (stableSeed(node, `${salt}:z`) - 0.5) * radius * 0.6;
        const dist = radius * spread;
        return {
            x: Math.cos(angle) * dist,
            y: Math.sin(angle) * dist,
            z: zJitter
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STRING UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Escape HTML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML
     */
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Parse OKLCH color string
     * @param {string} value - OKLCH color string
     * @returns {L: number, C: number, H: number, A: number}|null} Parsed values or null
     */
    function parseOklchString(value) {
        if (typeof value !== 'string') return null;
        const match = value.trim().match(/^oklch\(\s*([\d.]+)%\s+([\d.]+)\s+([\d.]+)(?:\s*\/\s*([\d.]+))?\s*\)$/i);
        if (!match) return null;
        return {
            L: parseFloat(match[1]),
            C: parseFloat(match[2]),
            H: parseFloat(match[3]),
            A: match[4] !== undefined ? parseFloat(match[4]) : 1
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Resolve defaults against available values
     * @param {Array} defaults - Preferred defaults
     * @param {Array} available - Available values
     * @returns {Array} Resolved values
     */
    function resolveDefaults(defaults, available) {
        if (!Array.isArray(defaults) || defaults.length === 0) {
            return available;
        }
        const availableSet = new Set(available);
        const intersection = defaults.filter(value => availableSet.has(value));
        return intersection.length ? intersection : available;
    }

    /**
     * Build dataset key from data object
     * @param {Object} data - Data object with meta, nodes, links
     * @returns {string} Dataset key
     */
    function buildDatasetKey(data) {
        const meta = (data && data.meta) ? data.meta : {};
        const target = meta.target || meta.project || 'dataset';
        const version = meta.version || '';
        const nodeCount = Array.isArray(data?.nodes) ? data.nodes.length : 0;
        const edgeCount = Array.isArray(data?.links)
            ? data.links.length
            : (Array.isArray(data?.edges) ? data.edges.length : 0);
        const raw = `${target}|${nodeCount}|${edgeCount}|${version}`;
        return raw.replace(/[^a-zA-Z0-9_.-]/g, '_').slice(0, 180);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GEOMETRY UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Calculate bounding box from two points
     * @param {x: number, y: number} start - Start point
     * @param {x: number, y: number} end - End point
     * @returns {left: number, top: number, width: number, height: number, right: number, bottom: number} Box rect
     */
    function getBoxRect(start, end) {
        const left = Math.min(start.x, end.x);
        const top = Math.min(start.y, end.y);
        const width = Math.abs(start.x - end.x);
        const height = Math.abs(start.y - end.y);
        return {
            left,
            top,
            width,
            height,
            right: left + width,
            bottom: top + height
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Math
        clamp01,
        clampValue,
        normalize,
        normalizeMetric,
        quantile,

        // Hash & Seed
        hashToUnit,
        stableSeed,
        stableZ,
        stableOffset,

        // String
        escapeHtml,
        parseOklchString,

        // Data
        resolveDefaults,
        buildDatasetKey,

        // Geometry
        getBoxRect
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════
// These ensure existing code continues to work without modification

window.clamp01 = UTILS.clamp01;
window.clampValue = UTILS.clampValue;
window.normalize = UTILS.normalize;
window.normalizeMetric = UTILS.normalizeMetric;
window.quantile = UTILS.quantile;
window.hashToUnit = UTILS.hashToUnit;
window.stableSeed = UTILS.stableSeed;
window.stableZ = UTILS.stableZ;
window.stableOffset = UTILS.stableOffset;
window.escapeHtml = UTILS.escapeHtml;
window.parseOklchString = UTILS.parseOklchString;
window.resolveDefaults = UTILS.resolveDefaults;
window.buildDatasetKey = UTILS.buildDatasetKey;
window.getBoxRect = UTILS.getBoxRect;

console.log('[Module] UTILS loaded - 14 pure functions');


// ═══ MODULE: modules/registry.js ═══
/**
 * @module registry
 * @description Centralized UI and command registration system
 * @responsibility Manage DOM element and command handler registration
 */

const REGISTRY = (function() {
    'use strict';

    // Private state
    const _items = new Map();
    const _commands = new Map();

    /**
     * Register a command handler or DOM element
     * @param {string} id - The identifier
     * @param {Function|Element} item - Handler function or DOM element
     * @param {Object} options - Additional options
     */
    function register(id, item, options = {}) {
        // CASE 1: Registering a Command Identifier + Handler Function
        // e.g. REGISTRY.register('cmd-files', () => toggleFiles(), { desc: '...' })
        if (typeof item === 'function') {
            _commands.set(id, { handler: item, options });

            // Auto-wire if DOM element exists with this ID
            const btn = document.getElementById(id);
            if (btn) {
                btn.onclick = (e) => {
                    item(e);
                };
                btn.setAttribute('data-command-id', id);
            }
            return;
        }

        // CASE 2: Registering a DOM Element directly
        let element = item;
        let elementId = id;

        // Overload: register(element) -> id comes from element.id
        if ((item instanceof Element) && arguments.length === 1) {
            element = item;
            elementId = element.id;
        }
        // Overload: register(id, element)
        else if (item instanceof Element) {
            element = item;
        }
        // Fallback: mismatched args
        else if (!element && (typeof id === 'object' && id instanceof Element)) {
            element = id;
            elementId = element.id;
        }

        if (!element || !element.setAttribute) {
            return;
        }

        if (!elementId) {
            return;
        }

        _items.set(elementId, element);
        element.setAttribute('data-registry-id', elementId);
    }

    /**
     * Get a registered element by ID (falls back to document.getElementById)
     * @param {string} id - The element ID
     * @returns {Element|null}
     */
    function get(id) {
        return _items.get(id) || document.getElementById(id);
    }

    /**
     * Get a registered command handler
     * @param {string} id - The command ID
     * @returns {Object|undefined} - { handler, options }
     */
    function getCommand(id) {
        return _commands.get(id);
    }

    /**
     * Execute a registered command
     * @param {string} id - The command ID
     * @param {Event} event - Optional event object
     * @returns {*} - Result of handler execution
     */
    function execute(id, event) {
        const cmd = _commands.get(id);
        if (cmd && typeof cmd.handler === 'function') {
            return cmd.handler(event);
        }
        console.warn(`[Registry] Command not found: ${id}`);
        return undefined;
    }

    /**
     * Check if a command is registered
     * @param {string} id - The command ID
     * @returns {boolean}
     */
    function hasCommand(id) {
        return _commands.has(id);
    }

    /**
     * Check if an element is registered
     * @param {string} id - The element ID
     * @returns {boolean}
     */
    function hasElement(id) {
        return _items.has(id);
    }

    /**
     * Get all registered command IDs
     * @returns {string[]}
     */
    function listCommands() {
        return Array.from(_commands.keys());
    }

    /**
     * Get all registered element IDs
     * @returns {string[]}
     */
    function listElements() {
        return Array.from(_items.keys());
    }

    // Public API
    return {
        register,
        get,
        getCommand,
        execute,
        hasCommand,
        hasElement,
        listCommands,
        listElements,
        // Expose maps for backward compatibility (read-only access pattern)
        get items() { return _items; },
        get commands() { return _commands; }
    };
})();

// Expose globally for backward compatibility
window.REGISTRY = REGISTRY;


// ═══ MODULE: modules/perf-monitor.js ═══
/**
 * @module perf-monitor
 * @description Real-time performance monitoring and FPS diagnostics
 * @responsibility Track frame delivery, detect dropped frames, display HUD
 */

// NOTE: Named _PerfMonitorImpl to avoid conflict with performance.js PERF
const _PerfMonitorImpl = (function() {
    'use strict';

    // Configuration
    const _config = {
        enabled: true,
        maxFrames: 60,
        droppedFrameThreshold: 50  // ms (>50ms = <20fps)
    };

    // State
    const _state = {
        fps: 0,
        frameTime: 0,
        lastFrameTime: 0,
        frameTimes: [],
        renderCalls: 0,
        droppedFrames: 0,
        lastSecond: 0,
        framesThisSecond: 0,
        hudElement: null,
        monitoring: false
    };

    /**
     * Initialize the performance monitor
     */
    function init() {
        if (!_config.enabled) return;

        // Create HUD element
        _state.hudElement = document.createElement('div');
        _state.hudElement.id = 'perf-hud';
        _state.hudElement.style.cssText = `
            position: fixed; top: 10px; right: 10px; z-index: 99999;
            background: rgba(0,0,0,0.85); color: #0f0; font-family: monospace;
            font-size: 11px; padding: 8px 12px; border-radius: 4px;
            border: 1px solid #333; min-width: 140px; pointer-events: none;
        `;
        document.body.appendChild(_state.hudElement);
        _startMonitoring();
    }

    /**
     * Start the monitoring loop
     */
    function _startMonitoring() {
        if (_state.monitoring) return;
        _state.monitoring = true;

        const monitor = () => {
            if (!_state.monitoring) return;

            const now = performance.now();

            // Calculate frame time
            if (_state.lastFrameTime > 0) {
                _state.frameTime = now - _state.lastFrameTime;
                _state.frameTimes.push(_state.frameTime);
                if (_state.frameTimes.length > _config.maxFrames) {
                    _state.frameTimes.shift();
                }

                // Detect dropped frames
                if (_state.frameTime > _config.droppedFrameThreshold) {
                    _state.droppedFrames++;
                }
            }
            _state.lastFrameTime = now;

            // Calculate FPS every second
            const second = Math.floor(now / 1000);
            if (second !== _state.lastSecond) {
                _state.fps = _state.framesThisSecond;
                _state.framesThisSecond = 0;
                _state.lastSecond = second;
            }
            _state.framesThisSecond++;

            // Update HUD
            _updateHUD();
            requestAnimationFrame(monitor);
        };
        requestAnimationFrame(monitor);
    }

    /**
     * Update the HUD display
     */
    function _updateHUD() {
        if (!_state.hudElement) return;

        const avgFrameTime = _state.frameTimes.length > 0
            ? (_state.frameTimes.reduce((a, b) => a + b, 0) / _state.frameTimes.length).toFixed(1)
            : '0.0';

        // Color code FPS
        let fpsColor = '#0f0';  // Green = good
        if (_state.fps < 30) fpsColor = '#ff0';  // Yellow = warning
        if (_state.fps < 15) fpsColor = '#f00';  // Red = bad

        // Animation state - use ANIM module if available
        const isAnimating = typeof ANIM !== 'undefined' && ANIM.isAnimating;
        const animating = isAnimating ? '▶ ANIMATING' : '■ IDLE';
        const animColor = isAnimating ? '#0ff' : '#666';
        const staggerPattern = (typeof ANIM !== 'undefined' && ANIM.staggerPattern) || 'none';

        _state.hudElement.innerHTML = `
            <div style="color:${fpsColor};font-size:14px;font-weight:bold">${_state.fps} FPS</div>
            <div>Frame: ${avgFrameTime}ms</div>
            <div>Dropped: <span style="color:${_state.droppedFrames > 10 ? '#f00' : '#0f0'}">${_state.droppedFrames}</span></div>
            <div style="color:${animColor}">${animating}</div>
            <div style="font-size:9px;color:#666;margin-top:4px">Pattern: ${staggerPattern}</div>
        `;
    }

    /**
     * Log a performance resistance point
     * @param {string} location - Where the resistance occurred
     * @param {number} duration - Duration in milliseconds
     */
    function logResistance(location, duration) {
        if (duration > 16) {
            console.warn(`[PERF RESISTANCE] ${location}: ${duration.toFixed(1)}ms (>${Math.floor(duration / 16.67)} frames)`);
        }
    }

    /**
     * Stop monitoring
     */
    function stop() {
        _state.monitoring = false;
        if (_state.hudElement && _state.hudElement.parentNode) {
            _state.hudElement.parentNode.removeChild(_state.hudElement);
        }
        _state.hudElement = null;
    }

    /**
     * Reset statistics
     */
    function reset() {
        _state.fps = 0;
        _state.frameTime = 0;
        _state.frameTimes = [];
        _state.droppedFrames = 0;
        _state.framesThisSecond = 0;
    }

    /**
     * Toggle HUD visibility
     */
    function toggle() {
        if (_state.hudElement) {
            _state.hudElement.style.display =
                _state.hudElement.style.display === 'none' ? 'block' : 'none';
        }
    }

    /**
     * Enable/disable monitoring
     * @param {boolean} enabled
     */
    function setEnabled(enabled) {
        _config.enabled = enabled;
        if (!enabled) {
            stop();
        } else if (!_state.monitoring) {
            init();
        }
    }

    // Public API
    return {
        init,
        stop,
        reset,
        toggle,
        setEnabled,
        logResistance,
        // Read-only state access
        get fps() { return _state.fps; },
        get frameTime() { return _state.frameTime; },
        get droppedFrames() { return _state.droppedFrames; },
        get enabled() { return _config.enabled; },
        get monitoring() { return _state.monitoring; }
    };
})();

// Export as PERF_MONITOR (PERF is provided by performance.js)
const PERF_MONITOR = _PerfMonitorImpl;

// Expose globally - only PERF_MONITOR, PERF comes from performance.js
window.PERF_MONITOR = PERF_MONITOR;


// ═══ MODULE: modules/core.js ═══
/**
 * CORE MODULE
 *
 * Foundation constants and utility functions for the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   CORE.SELECTION_SIZE_MULT      // Node size multiplier when selected
 *   CORE.PENDULUM                 // OKLCH color oscillator state
 *   CORE.amplify(value, gamma)    // Power law amplification
 *   CORE.amplifyContrast(value)   // S-curve contrast expansion
 */

const CORE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

    // OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
    const PENDULUM = {
        hue: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,        // Set from appearance.tokens
            gravity: null,        // Set from appearance.tokens
            length: 1.0,
            rotationSpeed: null   // Set from appearance.tokens
        },
        chroma: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,
            gravity: null,
            length: 1.0,
            center: null,
            amplitude: null
        },
        lightness: {
            phase: 0,
            speed: null,
            center: null,
            amplitude: null
        },
        ripple: {
            speed: null,
            scale: null
        },
        currentHue: Math.random() * 360,
        lastTime: 0,
        running: false
    };

    // =========================================================================
    // AMPLIFICATION UTILITIES
    // =========================================================================

    /**
     * Amplification function using power law: f(x) = x^(1/gamma)
     * Maps normalized [0,1] input to amplified [0,1] output
     * @param {number} value - Input value (0-1)
     * @param {number} gamma - Amplification factor (default from APPEARANCE_STATE)
     * @returns {number} Amplified value (0-1)
     */
    function amplify(value, gamma) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const g = gamma !== undefined ? gamma :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (g === 1) return value;
        // Clamp to valid range
        const v = Math.max(0, Math.min(1, value));
        // Power law: v^(1/gamma) - when gamma>1, small diffs become larger
        // Using 1/gamma so that higher slider = more amplification
        return Math.pow(v, 1 / g);
    }

    /**
     * Contrast amplification: expands values away from midpoint
     * Uses S-curve (tanh) for smooth contrast expansion
     * @param {number} value - Input value (0-1)
     * @param {number} strength - Contrast strength (default from APPEARANCE_STATE)
     * @returns {number} Contrast-enhanced value (0-1)
     */
    function amplifyContrast(value, strength) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const s = strength !== undefined ? strength :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (s === 1) return value;
        const v = Math.max(0, Math.min(1, value));
        // S-curve using tanh for smooth contrast expansion
        const centered = (v - 0.5) * 2;  // [-1, 1]
        const amplified = Math.tanh(centered * s) / Math.tanh(s);
        return (amplified + 1) / 2;  // Back to [0, 1]
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Constants
        SELECTION_SIZE_MULT,
        PENDULUM,

        // Utilities
        amplify,
        amplifyContrast
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'SELECTION_SIZE_MULT', {
    get: () => CORE.SELECTION_SIZE_MULT,
    configurable: true
});
Object.defineProperty(window, 'PENDULUM', {
    get: () => CORE.PENDULUM,
    configurable: true
});
Object.defineProperty(window, 'amplify', {
    get: () => CORE.amplify,
    configurable: true
});
Object.defineProperty(window, 'amplifyContrast', {
    get: () => CORE.amplifyContrast,
    configurable: true
});


// ═══ MODULE: modules/theory.js ═══
/**
 * THEORY MODULE - Standard Model of Code Theory Constants
 *
 * Pure data representing the Standard Model topology.
 * No dependencies. This is the canonical source of truth.
 *
 * @module THEORY
 * @version 1.0.0
 */

window.THEORY = (function() {
    'use strict';

    // =========================================================================
    // THE 16 ABSTRACTION LEVELS (vertical axis: L-3 to L12)
    // =========================================================================

    const SCALE_16_LEVELS = {
        // COSMOLOGICAL (L8-L12) - Beyond scope, shown as outer haze
        'L12': { name: 'UNIVERSE', symbol: '🌐', zone: 'COSMOLOGICAL', y: 1.4, color: { h: 260, s: 30, l: 25 } },
        'L11': { name: 'DOMAIN', symbol: '🏛️', zone: 'COSMOLOGICAL', y: 1.3, color: { h: 250, s: 35, l: 30 } },
        'L10': { name: 'ORGANIZATION', symbol: '🏢', zone: 'COSMOLOGICAL', y: 1.2, color: { h: 240, s: 40, l: 35 } },
        'L9': { name: 'PLATFORM', symbol: '☁️', zone: 'COSMOLOGICAL', y: 1.1, color: { h: 230, s: 45, l: 40 } },
        'L8': { name: 'ECOSYSTEM', symbol: '🔗', zone: 'COSMOLOGICAL', y: 1.0, color: { h: 220, s: 50, l: 45 } },
        // ARCHITECTURAL (L4-L7) - Primary visible zone (teal - virtual depths)
        'L7': { name: 'SYSTEM', symbol: '⬡', zone: 'ARCHITECTURAL', y: 0.7, color: { h: 175, s: 60, l: 52 } },
        'L6': { name: 'PACKAGE', symbol: '📦', zone: 'ARCHITECTURAL', y: 0.5, color: { h: 178, s: 62, l: 48 } },
        'L5': { name: 'FILE', symbol: '📄', zone: 'ARCHITECTURAL', y: 0.3, color: { h: 180, s: 65, l: 44 } },
        'L4': { name: 'CONTAINER', symbol: '⬢', zone: 'ARCHITECTURAL', y: 0.1, color: { h: 182, s: 68, l: 40 } },
        // SEMANTIC (L1-L3) - The operational core (silver/white - surface light)
        'L3': { name: 'NODE', symbol: '★', zone: 'SEMANTIC', y: -0.1, color: { h: 210, s: 25, l: 92 } },  // Brightest - fundamental unit
        'L2': { name: 'BLOCK', symbol: '▣', zone: 'SEMANTIC', y: -0.3, color: { h: 210, s: 30, l: 85 } },
        'L1': { name: 'STATEMENT', symbol: '─', zone: 'SEMANTIC', y: -0.5, color: { h: 210, s: 35, l: 78 } },
        // SYNTACTIC (L0) - The event horizon between meaning and data
        'L0': { name: 'TOKEN', symbol: '·', zone: 'SYNTACTIC', y: -0.7, color: { h: 60, s: 90, l: 55 } },  // Bright yellow - event horizon
        // PHYSICAL (L-1 to L-3) - The substrate (deep blue - ocean floor)
        'L-1': { name: 'CHARACTER', symbol: 'a', zone: 'PHYSICAL', y: -0.9, color: { h: 220, s: 70, l: 42 } },
        'L-2': { name: 'BYTE', symbol: '01', zone: 'PHYSICAL', y: -1.1, color: { h: 220, s: 75, l: 35 } },
        'L-3': { name: 'BIT/QUBIT', symbol: '⚡', zone: 'PHYSICAL', y: -1.3, color: { h: 220, s: 80, l: 28 } }  // Deepest
    };

    // =========================================================================
    // THE THREE PARALLEL LAYERS (shells around the structure)
    // =========================================================================

    const THREE_LAYERS = {
        'PHYSICAL': { order: 0, radius: 1.8, opacity: 0.15, color: { h: 220, s: 75, l: 35 }, description: 'Hardware, bits, memory, I/O' },
        'VIRTUAL': { order: 1, radius: 1.4, opacity: 0.25, color: { h: 175, s: 65, l: 45 }, description: 'Code, structures, algorithms' },
        'SEMANTIC': { order: 2, radius: 1.0, opacity: 0.35, color: { h: 210, s: 30, l: 88 }, description: 'Meaning, business logic, intent' }
    };

    // =========================================================================
    // STANDARD MODEL THEORY CONTENT - Semantic descriptions for tooltips
    // =========================================================================

    const SMC_THEORY = {
        // THE THREE FUNDAMENTAL LAYERS
        layers: {
            'PHYSICAL': {
                icon: '⚡',
                title: 'Physical Layer',
                subtitle: 'The Substrate',
                body: 'The hardware reality: electrons, circuits, memory cells. Everything that exists in physical space-time.',
                theory: '"Matter is the canvas upon which computation paints its patterns."',
                examples: ['CPU registers', 'RAM cells', 'disk sectors', 'network signals']
            },
            'VIRTUAL': {
                icon: '💠',
                title: 'Virtual Layer',
                subtitle: 'The Structure',
                body: 'Pure information structures: code, data, algorithms. The mathematical forms that live in computational space.',
                theory: '"Between the physical and the meaningful lies the virtual — pure form without matter or purpose."',
                examples: ['variables', 'functions', 'classes', 'data structures']
            },
            'SEMANTIC': {
                icon: '🎯',
                title: 'Semantic Layer',
                subtitle: 'The Meaning',
                body: 'Intent and purpose: business logic, user goals, system behavior. The "why" behind the code.',
                theory: '"Semantics is where computation meets human intention — the bridge between bits and understanding."',
                examples: ['user stories', 'business rules', 'API contracts', 'domain models']
            }
        },

        // ATOM FAMILIES
        families: {
            'LOG': {
                icon: '📊',
                title: 'Logic Family',
                subtitle: 'The Reasoners',
                body: 'Elements that transform data through computation: conditionals, loops, calculations.',
                theory: '"Logic atoms are the decision-makers — they take inputs and produce outputs through transformation."',
                examples: ['if/else', 'for loops', 'calculations', 'validators']
            },
            'DAT': {
                icon: '📦',
                title: 'Data Family',
                subtitle: 'The Containers',
                body: 'Elements that hold and organize information: variables, structures, databases.',
                theory: '"Data atoms store state — they are the nouns in the grammar of code."',
                examples: ['variables', 'arrays', 'objects', 'databases']
            },
            'ORG': {
                icon: '🏗️',
                title: 'Organization Family',
                subtitle: 'The Architects',
                body: 'Elements that structure code: modules, classes, packages. They create boundaries.',
                theory: '"Organization atoms create order from chaos — the folders in the file system of abstraction."',
                examples: ['modules', 'classes', 'packages', 'namespaces']
            },
            'EXE': {
                icon: '⚙️',
                title: 'Execution Family',
                subtitle: 'The Doers',
                body: 'Elements that perform actions: function calls, I/O, system operations.',
                theory: '"Execution atoms are the verbs — where potential becomes actual."',
                examples: ['function calls', 'API requests', 'file writes', 'renders']
            },
            'EXT': {
                icon: '🔌',
                title: 'External Family',
                subtitle: 'The Connectors',
                body: 'Elements that interface with the outside: APIs, imports, system calls.',
                theory: '"External atoms are portals — they connect isolated systems into larger ecosystems."',
                examples: ['imports', 'API calls', 'env vars', 'dependencies']
            }
        },

        // TIERS
        tiers: {
            'T0': {
                icon: '🔬',
                title: 'Tier 0 — Foundation',
                subtitle: 'Low-level primitives',
                body: 'The atomic building blocks: individual statements, expressions, basic operations.',
                theory: '"T0 is where code meets silicon — the ground floor of abstraction."',
                examples: ['assignments', 'operators', 'literals', 'basic types']
            },
            'T1': {
                icon: '🔧',
                title: 'Tier 1 — Components',
                subtitle: 'Functional units',
                body: 'Grouped functionality: functions, methods, small modules.',
                theory: '"T1 is the sweet spot — complex enough to be useful, simple enough to understand."',
                examples: ['functions', 'methods', 'handlers', 'utilities']
            },
            'T2': {
                icon: '🏛️',
                title: 'Tier 2 — Architecture',
                subtitle: 'System structure',
                body: 'High-level organization: classes, modules, services. The skeleton of the codebase.',
                theory: '"T2 defines the shape of software — patterns emerge that echo through every line."',
                examples: ['classes', 'modules', 'services', 'controllers']
            }
        },

        // SPECIAL ELEMENTS
        special: {
            'core': {
                icon: '✨',
                title: 'The Nexus',
                subtitle: 'Singularity Point',
                body: 'The center of the topology: where all paths converge.',
                theory: '"Every codebase has a heart — the central modules that everything depends upon."',
                examples: ['main.js', 'app.py', 'index.ts', 'core.rs']
            },
            'elevator': {
                icon: '🚀',
                title: 'Data Elevator',
                subtitle: 'Cross-tier Highway',
                body: 'Vertical connections that move data between abstraction levels.',
                theory: '"Elevators are the call stacks of architecture."',
                examples: ['API layers', 'ORMs', 'serializers', 'adapters']
            },
            'hub-star': {
                icon: '⭐',
                title: 'Hub Node',
                subtitle: 'High-connectivity Center',
                body: 'A node with many incoming connections. Often a critical dependency.',
                theory: '"Hubs are the load-bearing walls — remove them and everything collapses."',
                examples: ['utils', 'config', 'logger', 'database']
            }
        }
    };

    // =========================================================================
    // LEVEL ZONES - Which levels belong to which visual band
    // =========================================================================

    const LEVEL_ZONES = {
        'COSMOLOGICAL': { levels: ['L12', 'L11', 'L10', 'L9', 'L8'], opacity: 0.2, blur: true },
        'ARCHITECTURAL': { levels: ['L7', 'L6', 'L5', 'L4'], opacity: 0.6, blur: false },
        'SEMANTIC': { levels: ['L3', 'L2', 'L1'], opacity: 1.0, blur: false },        // Primary focus
        'SYNTACTIC': { levels: ['L0'], opacity: 0.8, blur: false },                   // Event horizon
        'PHYSICAL': { levels: ['L-1', 'L-2', 'L-3'], opacity: 0.4, blur: true }
    };

    // =========================================================================
    // VISUALIZATION PRESETS - Different ways to see the topology
    // =========================================================================

    const VIS_PRESETS = {
        'tier': {
            name: 'By Tier (T0/T1/T2)',
            description: 'Core → Architecture → External',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'family': {
            name: 'By Atom Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'layer': {
            name: 'By Layer',
            description: 'Physical → Virtual → Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'ring': {
            name: 'By Ring (Domain)',
            description: 'Domain architecture layers',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        'file': {
            name: 'By File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        'flow': {
            name: 'Markov Flow',
            description: 'Edge width = transition probability',
            colorBy: 'tier',
            sizeBy: 'entropy',
            edgeBy: 'weight'
        },
        'depth': {
            name: 'By Depth (Call Distance)',
            description: 'Distance from entry points',
            colorBy: 'depth',
            sizeBy: 'fanout',
            edgeBy: 'type'
        }
        // NOTE: Color schemes (viridis, plasma, thermal, etc.) are now in color-engine.js schemePaths
        // Access via COLOR.listSchemes(), COLOR.applyScheme(), COLOR.getSchemeColor()
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        SCALE_16_LEVELS,
        THREE_LAYERS,
        SMC_THEORY,
        LEVEL_ZONES,
        VIS_PRESETS,

        // Convenience getters
        getLevel: (id) => SCALE_16_LEVELS[id],
        getLayer: (id) => THREE_LAYERS[id],
        getZone: (id) => LEVEL_ZONES[id],
        getPreset: (id) => VIS_PRESETS[id],

        // Theory content accessors (for tooltips)
        getTheoryContent: (category, key) => SMC_THEORY[category]?.[key],
        getLayerTheory: (key) => SMC_THEORY.layers[key],
        getFamilyTheory: (key) => SMC_THEORY.families[key],
        getTierTheory: (key) => SMC_THEORY.tiers[key],
        getSpecialTheory: (key) => SMC_THEORY.special[key]
    };
})();

// =========================================================================
// BACKWARD COMPATIBILITY SHIMS
// =========================================================================

window.SCALE_16_LEVELS = THEORY.SCALE_16_LEVELS;
window.THREE_LAYERS = THEORY.THREE_LAYERS;
window.SMC_THEORY = THEORY.SMC_THEORY;
window.LEVEL_ZONES = THEORY.LEVEL_ZONES;
window.VIS_PRESETS = THEORY.VIS_PRESETS;

console.log('[Module] THEORY loaded - 5 constants, 8 accessors');


// ═══ MODULE: modules/node-accessors.js ═══
/**
 * NODE ACCESSORS MODULE
 *
 * Provides standardized access to node properties across the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   NODE.getTier(node)       // Returns 'T0', 'T1', 'T2', or 'UNKNOWN'
 *   NODE.getFamily(node)     // Returns 'LOG', 'DAT', 'ORG', 'EXE', 'EXT', or 'UNKNOWN'
 *   NODE.getRing(node)       // Returns ring/layer value
 *   NODE.getLayer(node)      // Returns D2_LAYER value
 *   NODE.getEffect(node)     // Returns D6_EFFECT value
 */

const NODE = (function() {
    'use strict';

    // =========================================================================
    // TIER SYSTEM
    // =========================================================================

    // Tier aliases: legacy names -> canonical T0/T1/T2
    const TIER_ALIASES = {
        'CORE': 'T0', 'T0': 'T0',
        'ARCH': 'T1', 'T1': 'T1',
        'EXT': 'T2', 'T2': 'T2',
        'DISCOVERED': 'T2',  // EXT.DISCOVERED -> T2
        'UNKNOWN': 'UNKNOWN'
    };

    function normalizeTier(tier) {
        if (!tier) return 'UNKNOWN';
        const upper = String(tier).toUpperCase();
        return TIER_ALIASES[upper] || upper;
    }

    // Prefer canonical node.tier field; fallback to atom prefix inference
    function getTier(node) {
        // If node is a string (backward compat: called with atomId), infer from prefix
        if (typeof node === 'string') {
            const atomId = node;
            if (!atomId) return 'UNKNOWN';
            if (atomId.startsWith('CORE.')) return 'T0';
            if (atomId.startsWith('ARCH.')) return 'T1';
            if (atomId.startsWith('EXT.')) return 'T2';
            return 'UNKNOWN';
        }
        // Prefer canonical field
        if (node.tier) {
            return normalizeTier(node.tier);
        }
        // Fallback: infer from atom prefix
        const atomId = String(node.atom || '');
        if (atomId.startsWith('CORE.')) return 'T0';
        if (atomId.startsWith('ARCH.')) return 'T1';
        if (atomId.startsWith('EXT.')) return 'T2';
        return 'UNKNOWN';
    }

    // =========================================================================
    // FAMILY SYSTEM
    // =========================================================================

    // Get atom family from canonical field or infer from atom prefix
    function getFamily(node) {
        // Prefer canonical field
        if (node.atom_family) {
            return String(node.atom_family).toUpperCase();
        }
        // Fallback: infer from atom (e.g., "LOG.FNC.M" -> "LOG")
        const atomId = String(node.atom || '');
        const dotIdx = atomId.indexOf('.');
        if (dotIdx > 0) {
            return atomId.substring(0, dotIdx).toUpperCase();
        }
        return 'UNKNOWN';
    }

    // =========================================================================
    // RING SYSTEM
    // =========================================================================

    function normalizeRing(value) {
        if (value === null || value === undefined) return null;
        const ring = String(value).trim().toUpperCase();
        if (!ring) return null;
        const aliases = {
            TEST: 'TESTING'
        };
        return aliases[ring] || ring;
    }

    function getRing(node) {
        const ring = node.ring || node.layer || 'UNKNOWN';
        return normalizeRing(ring) || 'UNKNOWN';
    }

    // =========================================================================
    // LAYER SYSTEM (D2_LAYER)
    // =========================================================================

    function getLayer(node) {
        if (!node) return 'Unknown';
        return node.layer || node.dimensions?.D2_LAYER || 'Unknown';
    }

    // =========================================================================
    // EFFECT SYSTEM (D6_EFFECT)
    // =========================================================================

    function getEffect(node) {
        if (!node) return 'Unknown';
        return node.effect || node.dimensions?.D6_EFFECT || 'Unknown';
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Tier
        getTier,
        normalizeTier,
        TIER_ALIASES,

        // Family
        getFamily,

        // Ring
        getRing,
        normalizeRing,

        // Layer
        getLayer,

        // Effect
        getEffect
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'getNodeTier', { get: () => NODE.getTier, configurable: true });
Object.defineProperty(window, 'getNodeAtomFamily', { get: () => NODE.getFamily, configurable: true });
Object.defineProperty(window, 'getNodeRing', { get: () => NODE.getRing, configurable: true });
Object.defineProperty(window, 'getNodeLayer', { get: () => NODE.getLayer, configurable: true });
Object.defineProperty(window, 'getNodeEffect', { get: () => NODE.getEffect, configurable: true });
Object.defineProperty(window, 'normalizeTier', { get: () => NODE.normalizeTier, configurable: true });
Object.defineProperty(window, 'normalizeRingValue', { get: () => NODE.normalizeRing, configurable: true });
Object.defineProperty(window, 'TIER_ALIASES', { get: () => NODE.TIER_ALIASES, configurable: true });


// ═══ MODULE: modules/node-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * NODE-HELPERS MODULE - Node classification and color functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node color mode selection, data enrichment helpers, and tier grouping.
 * Depends on: COLOR (ColorOrchestrator), NODE (node-accessors), DM, Graph
 *
 * @module NODE_HELPERS
 * @version 1.0.0
 */

window.NODE_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR BY MODE
    // ═══════════════════════════════════════════════════════════════════════

    // =========================================================================
    // MODE_ACCESSORS: Declarative map replacing the mega-switch
    // Each mode maps to a function: (node, Color) => colorString
    // =========================================================================

    const MODE_ACCESSORS = {
        // 1. ARCHITECTURE
        tier:           (n, C) => C.get('tier', window.getNodeTier(n)),
        layer:          (n, C) => C.get('layer', (n.layer || n.dimensions?.D2_LAYER || 'UNKNOWN').toUpperCase()),
        subsystem:      (n, C) => C.get('subsystem', getSubsystem(n)),
        boundary_score: (n, C) => C.getInterval('boundary_score', window.normalize(n.rpbl?.boundary ?? 1, 9)),
        phase:          (n, C) => C.get('phase', getPhase(n)),

        // 2. TAXONOMY
        atom:           (n, C) => C.get('atom', (n.kind || n.type || 'unknown').toLowerCase()),
        family:         (n, C) => C.get('family', window.getNodeAtomFamily(n)),
        role:           (n, C) => C.get('roleCategory', n.role_cat || 'Unknown'),
        roleCategory:   (n, C) => C.get('roleCategory', n.role_cat || getRoleCategory(n)),
        fileType:       (n, C) => C.get('fileType', getFileType(n)),

        // 3. METRICS
        complexity:     (n, C) => C.getInterval('complexity', window.normalize(n.complexity || 0, 20)),
        loc:            (n, C) => C.getInterval('loc', window.normalize(n.lines_of_code || 0, 500)),
        fan_in:         (n, C) => C.getInterval('fan_in', window.normalize(n.in_degree || 0, 20)),
        fan_out:        (n, C) => C.getInterval('fan_out', window.normalize(n.out_degree || 0, 20)),
        trust:          (n, C) => C.getInterval('trust', n.trust || n.confidence || 0),

        // 4. RPBL DNA
        responsibility: (n, C) => C.getInterval('responsibility', window.normalize(n.rpbl?.responsibility ?? 1, 9)),
        purity:         (n, C) => C.getInterval('purity', window.normalize(n.rpbl?.purity ?? 1, 9)),
        lifecycle_score:(n, C) => C.getInterval('lifecycle_score', window.normalize(n.rpbl?.lifecycle ?? 1, 9)),
        state:          (n, C) => C.get('state', (n.dimensions?.D5_STATE === 'Stateful') ? 'Stateful' : 'Stateless'),
        visibility:     (n, C) => C.get('visibility', n.dimensions?.D4_BOUNDARY === 'External' ? 'Public' : 'Private'),

        // 5. TOPOLOGY
        centrality:     (n, C) => C.getInterval('centrality', n.centrality || 0),
        rank:           (n, C) => C.getInterval('centrality', n.pagerank || 0),
        ring:           (n, C) => C.get('ring', window.getNodeRing(n)),

        // 6. EVOLUTION (Placeholders)
        churn:          (n, C) => C.getInterval('churn', Math.random() * 0.5),
        age:            (n, C) => C.getInterval('churn', 0.2)
    };

    function getNodeColorByMode(node) {
        const Color = window.Color;
        const NODE_COLOR_MODE = window.NODE_COLOR_MODE;
        const DM = window.DM;

        // Special case: file coloring needs extra context
        if (NODE_COLOR_MODE === 'file') {
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx < 0) return Color.get('tier', 'UNKNOWN');
            const fileBoundaries = DM ? DM.getFileBoundaries() : [];
            const totalFiles = fileBoundaries.length;
            const fileInfo = fileBoundaries[fileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            return window.getFileColor(fileIdx, totalFiles, fileLabel);
        }

        // Use MODE_ACCESSORS map - O(1) lookup instead of if-chain
        const accessor = MODE_ACCESSORS[NODE_COLOR_MODE];
        if (accessor) return accessor(node, Color);

        // Default fallback
        return Color.get('tier', window.getNodeTier(node));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA ENRICHMENT HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getSubsystem(node) {
        if (!node.file_path) return 'Unknown';
        if (node.file_path.includes('/api/')) return 'Ingress';
        if (node.file_path.includes('/db/') || node.file_path.includes('repository')) return 'Persistence';
        if (node.file_path.includes('/core/') || node.file_path.includes('domain')) return 'Domain';
        if (node.file_path.includes('/ui/') || node.file_path.includes('frontend')) return 'Presentation';
        if (node.file_path.includes('config')) return 'Config';
        return 'Domain';
    }

    function getPhase(node) {
        const kind = (node.kind || '').toLowerCase();
        if (kind.includes('data') || kind.includes('entity') || kind.includes('schema')) return 'DATA';
        if (kind.includes('function') || kind.includes('logic')) return 'LOGIC';
        if (kind.includes('module') || kind.includes('package')) return 'ORGANIZATION';
        if (kind.includes('script') || kind.includes('main')) return 'EXECUTION';
        return 'LOGIC';
    }

    function getFileType(node) {
        const p = node.file_path || node.id || '';
        const ext = p.split('.').pop().toLowerCase();
        return ext || 'unknown';
    }

    function getRoleCategory(node) {
        const r = (node.role || '').toLowerCase();
        if (r.includes('service') || r.includes('manager')) return 'Orchestration';
        if (r.includes('repo') || r.includes('store')) return 'Storage';
        if (r.includes('controller') || r.includes('handler')) return 'Ingress';
        if (r.includes('util') || r.includes('helper')) return 'Utility';
        return 'Unknown';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR APPLICATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeColors(nodes) {
        const DM = window.DM;
        const fileBoundaries = DM ? DM.getFileBoundaries() : [];
        nodes.forEach(node => {
            if (node && node.isFileNode) {
                if (!node.color) {
                    const totalFiles = fileBoundaries.length;
                    const fileInfo = fileBoundaries[node.fileIdx] || {};
                    const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                    node.color = window.getFileColor(node.fileIdx, totalFiles, fileLabel);
                }
                return;
            }
            if (window.fileMode) {
                return;
            }
            node.color = getNodeColorByMode(node);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SIZE MODE
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeSizeMode(mode) {
        const Graph = window.Graph;
        if (!Graph) return;
        const scale = window.APPEARANCE_STATE?.nodeScale || 1;
        switch (mode) {
            case 'uniform':
                Graph.nodeVal(() => 1 * scale);
                break;
            case 'degree':
                Graph.nodeVal(n => Math.max(1, ((n.in_degree || 0) + (n.out_degree || 0)) * 0.5) * scale);
                break;
            case 'fanout':
                Graph.nodeVal(n => (n.val || n.fanout || 1) * scale);
                break;
            case 'complexity':
                Graph.nodeVal(n => Math.max(1, (n.complexity || n.loc || 10) * 0.05) * scale);
                break;
            default:
                Graph.nodeVal(n => (n.val || 1) * scale);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER/DEPTH/SIMILARITY HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNodeTierValue(node) {
        if (!node) return 1;
        const tier = window.getNodeTier(node);
        if (tier === 'T0') return 0;
        if (tier === 'T1') return 1;
        if (tier === 'T2') return 2;
        return 1;
    }

    function getNodeDepth(node) {
        if (node && typeof node.y === 'number') {
            return Math.abs(node.y) / 500;
        }
        return 0.5;
    }

    function getSemanticSimilarity(srcNode, tgtNode) {
        if (!srcNode || !tgtNode) return 0.5;
        let score = 0;
        if (srcNode.type === tgtNode.type) score += 0.4;
        if (srcNode.fileIdx === tgtNode.fileIdx) score += 0.3;
        if (window.getNodeTier(srcNode) === window.getNodeTier(tgtNode)) score += 0.2;
        if (srcNode.ring === tgtNode.ring) score += 0.1;
        return score;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER GROUPING
    // ═══════════════════════════════════════════════════════════════════════

    function groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = window.getNodeTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getColorByMode: getNodeColorByMode,
        getSubsystem: getSubsystem,
        getPhase: getPhase,
        getFileType: getFileType,
        getRoleCategory: getRoleCategory,
        applyColors: applyNodeColors,
        applySizeMode: applyNodeSizeMode,
        getTierValue: getNodeTierValue,
        getDepth: getNodeDepth,
        getSemanticSimilarity: getSemanticSimilarity,
        groupByTier: groupNodesByTier
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getNodeColorByMode = NODE_HELPERS.getColorByMode;
window.getSubsystem = NODE_HELPERS.getSubsystem;
window.getPhase = NODE_HELPERS.getPhase;
window.getFileType = NODE_HELPERS.getFileType;
window.getRoleCategory = NODE_HELPERS.getRoleCategory;
window.applyNodeColors = NODE_HELPERS.applyColors;
window.applyNodeSizeMode = NODE_HELPERS.applySizeMode;
window.getNodeTierValue = NODE_HELPERS.getTierValue;
window.getNodeDepth = NODE_HELPERS.getDepth;
window.getSemanticSimilarity = NODE_HELPERS.getSemanticSimilarity;
window.groupNodesByTier = NODE_HELPERS.groupByTier;

console.log('[Module] NODE_HELPERS loaded - 11 functions');


// ═══ MODULE: modules/color-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * COLOR-HELPERS MODULE - Color utilities and conversions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Topology colors, color normalization, file hue generation.
 * Depends on: UTILS (parseOklchString, hashToUnit, clampValue), COLOR (oklchColor)
 *
 * @module COLOR_HELPERS
 * @version 1.0.0
 */

window.COLOR_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // TOPOLOGY COLOR LOOKUP
    // ═══════════════════════════════════════════════════════════════════════

    function getTopoColor(category, key) {
        const APPEARANCE_CONFIG = window.APPEARANCE_CONFIG;
        if (!APPEARANCE_CONFIG || !APPEARANCE_CONFIG.color) return { l: 50, c: 0, h: 0 };

        let tokenKey = key;
        let section = 'atom-family'; // Default

        // Map legacy/UI keys to Token keys
        if (category === 'tiers') {
            section = 'atom';
            if (key === 'T0') tokenKey = 't0-core';
            else if (key === 'T1') tokenKey = 't1-arch';
            else if (key === 'T2') tokenKey = 't2-eco';
            else if (key === 'UNKNOWN') tokenKey = 'unknown';
        } else if (category === 'rings') {
            section = 'ring';
            if (key === 'KERNEL') tokenKey = 'DOMAIN';
            if (key === 'CORE') tokenKey = 'APPLICATION';
            if (key === 'SERVICE') tokenKey = 'PRESENTATION';
            if (key === 'ADAPTER') tokenKey = 'INTERFACE';
        } else if (category === 'families') {
            section = 'atom-family';
        }

        // Lookup token
        const tokenStr = APPEARANCE_CONFIG.color[section]?.[tokenKey] || APPEARANCE_CONFIG.color[section]?.['UNKNOWN'];

        // Parse OKLCH
        const parsed = window.parseOklchString(tokenStr);
        if (!parsed) return { l: 50, c: 0, h: 0 }; // Fallback gray

        // Normalize to internal l,c,h format (lowercase)
        return { l: parsed.L * 100, c: parsed.C, h: parsed.H };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLOR NORMALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeColorInput(color, fallback = 'rgb(128, 128, 128)') {
        if (color === null || color === undefined) {
            return fallback;
        }
        if (typeof color !== 'string') {
            return color;
        }
        const parsed = window.parseOklchString(color);
        if (parsed) {
            return window.oklchColor(parsed.L, parsed.C, parsed.H, parsed.A);
        }
        return color;
    }

    function toColorNumber(color, fallback = '#777777') {
        // Returns CSS hex string (polished-compatible) instead of JS hex int
        if (typeof color === 'number') {
            return '#' + color.toString(16).padStart(6, '0');
        }
        if (typeof color !== 'string') {
            return fallback;
        }
        const normalized = normalizeColorInput(color);
        if (typeof normalized === 'string') {
            color = normalized;
        }
        if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl')) {
            return color;  // Already valid CSS color
        }
        try {
            const hex = new THREE.Color(color).getHex();
            return '#' + hex.toString(16).padStart(6, '0');
        } catch (err) {
            return fallback;
        }
    }

    function dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILE COLOR GENERATION
    // ═══════════════════════════════════════════════════════════════════════

    function getFileHue(fileIdx, totalFiles, fileName) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const strategy = FILE_COLOR_CONFIG.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return window.hashToUnit(seed) * 360;
        }
        const angle = FILE_COLOR_CONFIG.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const COLOR_TWEAKS = window.COLOR_TWEAKS || {};
        const saturation = FILE_COLOR_CONFIG.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (FILE_COLOR_CONFIG.lightness ?? 50);
        const hue = getFileHue(fileIdx, totalFiles, fileName);
        if (typeof FILE_COLOR_CONFIG.chroma === 'number') {
            return window.oklchColor(lightness, FILE_COLOR_CONFIG.chroma, hue);
        }
        const adjustedHue = hue + (COLOR_TWEAKS.hueShift || 0);
        const adjustedLightness = window.clampValue(lightness + (COLOR_TWEAKS.lightnessShift || 0), 0, 100);
        return `hsl(${adjustedHue}, ${saturation}%, ${adjustedLightness}%)`;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getTopoColor: getTopoColor,
        normalizeInput: normalizeColorInput,
        toNumber: toColorNumber,
        dim: dimColor,
        getFileHue: getFileHue,
        getFileColor: getFileColor
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getTopoColor = COLOR_HELPERS.getTopoColor;
window.normalizeColorInput = COLOR_HELPERS.normalizeInput;
window.toColorNumber = COLOR_HELPERS.toNumber;
window.dimColor = COLOR_HELPERS.dim;
window.getFileHue = COLOR_HELPERS.getFileHue;
window.getFileColor = COLOR_HELPERS.getFileColor;

console.log('[Module] COLOR_HELPERS loaded - 6 functions');


// ═══ MODULE: modules/color-engine.js ═══
/**
 * COLOR ENGINE MODULE
 *
 * Centralized Color Intelligence System using OKLCH color space.
 * Single source of truth for ALL colors in the visualization.
 * Everything reads from here. OKLCH transforms apply here.
 *
 * Usage:
 *   COLOR.get('tier', 'T0')              // Get hex color for tier T0
 *   COLOR.getInterval('markov', 0.5)     // Get interpolated color
 *   COLOR.setTransform('hueShift', 30)   // Shift all hues by 30 degrees
 *   COLOR.subscribe(callback)            // React to transform changes
 */

const COLOR = (function () {
    'use strict';

    // =========================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =========================================================================

    const palette = {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        atom: {
            // Function-like (Green-Cyan)
            'function': { h: 160, c: 0.20, l: 0.65, label: 'Function', semantic: 'logic' },
            'method': { h: 175, c: 0.20, l: 0.62, label: 'Method', semantic: 'logic' },
            'closure': { h: 190, c: 0.20, l: 0.60, label: 'Closure', semantic: 'logic' },
            // Class-like (Blue-Purple)
            'class': { h: 260, c: 0.22, l: 0.60, label: 'Class', semantic: 'structure' },
            'interface': { h: 280, c: 0.20, l: 0.65, label: 'Interface', semantic: 'abstraction' },
            'struct': { h: 240, c: 0.20, l: 0.60, label: 'Struct', semantic: 'data' },
            // Module/Package (Orange-Yellow)
            'module': { h: 45, c: 0.22, l: 0.70, label: 'Module', semantic: 'container' },
            'package': { h: 30, c: 0.24, l: 0.65, label: 'Package', semantic: 'container' },
            // Variables/Fields (Pink-Red)
            'variable': { h: 340, c: 0.18, l: 0.65, label: 'Variable', semantic: 'state' },
            'field': { h: 350, c: 0.18, l: 0.62, label: 'Field', semantic: 'state' },
            // Unknown
            'unknown': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        roleCategory: {
            'Query': { h: 190, c: 0.20, l: 0.65, label: 'Query', semantic: 'read' },         // Cyan
            'Command': { h: 25, c: 0.24, l: 0.60, label: 'Command', semantic: 'write' },     // Orange/Red
            'Factory': { h: 280, c: 0.22, l: 0.60, label: 'Factory', semantic: 'create' },   // Purple
            'Storage': { h: 140, c: 0.20, l: 0.65, label: 'Storage', semantic: 'persist' },  // Green
            'Orchestration': { h: 240, c: 0.22, l: 0.60, label: 'Orchestration', semantic: 'manage' }, // Blue
            'Validation': { h: 45, c: 0.24, l: 0.70, label: 'Validation', semantic: 'check' }, // Yellow
            'Transform': { h: 320, c: 0.20, l: 0.60, label: 'Transform', semantic: 'change' }, // Pink
            'Event': { h: 260, c: 0.22, l: 0.65, label: 'Event', semantic: 'async' },        // Violet
            'Utility': { h: 200, c: 0.10, l: 0.70, label: 'Utility', semantic: 'helper' },   // Light Blue
            'Internal': { h: 0, c: 0.00, l: 0.60, label: 'Internal', semantic: 'private' },  // Gray
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        subsystem: {
            'Ingress': { h: 220, c: 0.24, l: 0.60, label: 'Ingress', semantic: 'entry' },
            'Egress': { h: 20, c: 0.24, l: 0.60, label: 'Egress', semantic: 'exit' },
            'Domain': { h: 260, c: 0.24, l: 0.55, label: 'Domain Core', semantic: 'core' },
            'Persistence': { h: 142, c: 0.22, l: 0.65, label: 'Persistence', semantic: 'store' },
            'Async': { h: 300, c: 0.22, l: 0.60, label: 'Async', semantic: 'bg' },
            'Presentation': { h: 190, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'ui' },
            'Security': { h: 0, c: 0.26, l: 0.55, label: 'Security', semantic: 'guard' },
            'Observability': { h: 60, c: 0.22, l: 0.75, label: 'Observability', semantic: 'monitor' },
            'Config': { h: 290, c: 0.18, l: 0.65, label: 'config', semantic: 'setup' },
            'Delivery': { h: 30, c: 0.20, l: 0.70, label: 'Delivery', semantic: 'ops' },
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        phase: {
            'DATA': { h: 142, c: 0.22, l: 0.65, label: 'Data', semantic: 'structure' },
            'LOGIC': { h: 240, c: 0.24, l: 0.60, label: 'Logic', semantic: 'flow' },
            'ORGANIZATION': { h: 280, c: 0.22, l: 0.60, label: 'Organization', semantic: 'arch' },
            'EXECUTION': { h: 20, c: 0.26, l: 0.60, label: 'Execution', semantic: 'run' }
        },
        state: {
            'Stateless': { h: 220, c: 0.20, l: 0.70, label: 'Stateless', semantic: 'pure' }, // Light Blue
            'Stateful': { h: 20, c: 0.24, l: 0.60, label: 'Stateful', semantic: 'impure' }   // Orange
        },
        effect: {
            'Pure': { h: 142, c: 0.22, l: 0.70, label: 'Pure', semantic: 'safe' },          // Green
            'SideEffect': { h: 340, c: 0.22, l: 0.60, label: 'Side Effect', semantic: 'risk' } // Pink/Red
        },
        visibility: {
            'Public': { h: 220, c: 0.20, l: 0.65, label: 'Public', semantic: 'open' },
            'Private': { h: 0, c: 0.05, l: 0.55, label: 'Private', semantic: 'closed' },
            'Internal': { h: 280, c: 0.15, l: 0.60, label: 'Internal', semantic: 'module' }
        },
        fileType: {
            'js': { h: 60, c: 0.24, l: 0.70, label: 'JavaScript', semantic: 'code' },    // Yellow
            'ts': { h: 240, c: 0.22, l: 0.60, label: 'TypeScript', semantic: 'code' },    // Blue
            'py': { h: 220, c: 0.20, l: 0.62, label: 'Python', semantic: 'code' },        // Blue
            'go': { h: 190, c: 0.22, l: 0.68, label: 'Go', semantic: 'code' },            // Cyan
            'rs': { h: 30, c: 0.24, l: 0.60, label: 'Rust', semantic: 'code' },           // Orange
            'java': { h: 40, c: 0.24, l: 0.62, label: 'Java', semantic: 'code' },         // Orange/Red
            'c': { h: 210, c: 0.18, l: 0.60, label: 'C', semantic: 'code' },             // Blue
            'cpp': { h: 210, c: 0.20, l: 0.55, label: 'C++', semantic: 'code' },          // Blue
            'h': { h: 280, c: 0.16, l: 0.60, label: 'Header', semantic: 'code' },         // Purple
            'html': { h: 20, c: 0.25, l: 0.60, label: 'HTML', semantic: 'markup' },       // Orange
            'css': { h: 230, c: 0.24, l: 0.60, label: 'CSS', semantic: 'style' },         // Blue
            'json': { h: 60, c: 0.18, l: 0.75, label: 'JSON', semantic: 'data' },         // Yellow
            'yaml': { h: 300, c: 0.18, l: 0.65, label: 'YAML', semantic: 'config' },      // Magenta
            'md': { h: 0, c: 0.04, l: 0.70, label: 'Markdown', semantic: 'doc' },         // Gray
            'unknown': { h: 0, c: 0.02, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    };

    // =========================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =========================================================================

    const transform = {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    };

    // =========================================================================
    // INTERVAL MAPPINGS: For numeric data -> color gradients
    // =========================================================================

    const intervals = {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        },
        complexity: {
            stops: [
                { value: 0.0, h: 142, c: 0.18, l: 0.70 },  // Low complexity (0) - Green
                { value: 0.3, h: 100, c: 0.18, l: 0.75 },  // Moderate (5-10) - Yellow-Green
                { value: 0.6, h: 50, c: 0.20, l: 0.70 },   // High (10-20) - Orange
                { value: 1.0, h: 15, c: 0.24, l: 0.60 }    // Very High (20+) - Red
            ]
        },
        churn: {
            stops: [
                { value: 0.0, h: 230, c: 0.10, l: 0.45 },  // Stale/Cold - Blue
                { value: 0.5, h: 300, c: 0.14, l: 0.60 },  // Active - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // Hot - Orange/Red
            ]
        },
        loc: {
            stops: [
                { value: 0.0, h: 200, c: 0.10, l: 0.75 },  // Small - Light Blue
                { value: 0.3, h: 240, c: 0.18, l: 0.60 },  // Medium - Blue
                { value: 0.7, h: 280, c: 0.20, l: 0.50 },  // Large - Purple
                { value: 1.0, h: 320, c: 0.22, l: 0.40 }   // Massive - Dark Purple
            ]
        },
        trust: {
            stops: [
                { value: 0.0, h: 0, c: 0.24, l: 0.50 },    // Untrusted - Red
                { value: 0.5, h: 60, c: 0.20, l: 0.70 },   // Warning - Yellow
                { value: 1.0, h: 142, c: 0.22, l: 0.65 }   // Trusted - Green
            ]
        },
        responsibility: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Single Purpose (1) - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.75 },   // Moderate (5) - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // God Object (9) - Red
            ]
        },
        purity: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Pure (1) - Green
                { value: 0.5, h: 220, c: 0.18, l: 0.65 },  // Mixed (5) - Blue
                { value: 1.0, h: 320, c: 0.24, l: 0.55 }   // I/O Heavy (9) - Purple/Red
            ]
        },
        boundary_score: {
            stops: [
                { value: 0.0, h: 240, c: 0.15, l: 0.65 },  // Internal (1) - Blue
                { value: 0.5, h: 280, c: 0.18, l: 0.60 },  // Module (5) - Purple
                { value: 1.0, h: 20, c: 0.24, l: 0.60 }    // External API (9) - Orange
            ]
        },
        lifecycle_score: {
            stops: [
                { value: 0.0, h: 180, c: 0.15, l: 0.70 },  // Ephemeral (1) - Cyan
                { value: 0.5, h: 220, c: 0.18, l: 0.60 },  // Managed (5) - Blue
                { value: 1.0, h: 280, c: 0.22, l: 0.50 }   // Singleton (9) - Purple
            ]
        },
        centrality: {
            stops: [
                { value: 0.0, h: 240, c: 0.05, l: 0.40 },  // Periphery - Gray/Blue
                { value: 0.5, h: 280, c: 0.20, l: 0.60 },  // Bridge - Purple
                { value: 1.0, h: 340, c: 0.25, l: 0.65 }   // Core - Pink/Red
            ]
        },
        fan_in: {
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.65 },  // Low - Blue
                { value: 0.5, h: 300, c: 0.18, l: 0.60 },  // Med - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // High - Orange
            ]
        },
        fan_out: {
            stops: [
                { value: 0.0, h: 142, c: 0.15, l: 0.65 },  // Low - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.70 },   // Med - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // High - Red
            ]
        }
    };

    // =========================================================================
    // SCHEME PATHS: 33 Named Color Gradients (OKLCH 3D Paths)
    // Each scheme is a path through OKLCH color space mapping normalized values to colors
    // =========================================================================

    const schemePaths = {
        // =====================================================================
        // PART A: FAMOUS SCIENTIFIC GRADIENTS (15 schemes)
        // Source: matplotlib/viridis family - perceptually uniform
        // =====================================================================

        // === SEQUENTIAL (monotonic lightness) ===
        viridis: {
            name: 'Viridis',
            semantic: 'The gold standard - blue→green→yellow',
            stops: [
                { value: 0.0, h: 280, c: 0.12, l: 0.25 },  // Dark purple
                { value: 0.25, h: 240, c: 0.16, l: 0.40 }, // Blue
                { value: 0.5, h: 170, c: 0.18, l: 0.55 },  // Teal
                { value: 0.75, h: 120, c: 0.20, l: 0.70 }, // Green
                { value: 1.0, h: 65, c: 0.22, l: 0.90 }    // Yellow
            ]
        },
        plasma: {
            name: 'Plasma',
            semantic: 'Purple→pink→orange→yellow arc',
            stops: [
                { value: 0.0, h: 280, c: 0.15, l: 0.20 },  // Deep purple
                { value: 0.25, h: 300, c: 0.22, l: 0.40 }, // Magenta
                { value: 0.5, h: 340, c: 0.25, l: 0.55 },  // Pink-red
                { value: 0.75, h: 30, c: 0.28, l: 0.72 },  // Orange
                { value: 1.0, h: 60, c: 0.24, l: 0.92 }    // Bright yellow
            ]
        },
        magma: {
            name: 'Magma',
            semantic: 'Black→purple→orange→white (lava)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.08 },  // Near black
                { value: 0.25, h: 300, c: 0.18, l: 0.30 }, // Deep purple
                { value: 0.5, h: 340, c: 0.24, l: 0.50 },  // Magenta
                { value: 0.75, h: 30, c: 0.26, l: 0.75 },  // Orange
                { value: 1.0, h: 60, c: 0.08, l: 0.98 }    // Near white
            ]
        },
        inferno: {
            name: 'Inferno',
            semantic: 'Black→purple→red→yellow (fire)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.05 },  // Black
                { value: 0.2, h: 300, c: 0.16, l: 0.25 },  // Purple
                { value: 0.4, h: 350, c: 0.24, l: 0.45 },  // Red-purple
                { value: 0.6, h: 20, c: 0.28, l: 0.60 },   // Red-orange
                { value: 0.8, h: 50, c: 0.26, l: 0.78 },   // Orange-yellow
                { value: 1.0, h: 65, c: 0.18, l: 0.95 }    // Bright yellow
            ]
        },
        cividis: {
            name: 'Cividis',
            semantic: 'Blue→yellow (colorblind optimized)',
            stops: [
                { value: 0.0, h: 240, c: 0.10, l: 0.25 },  // Dark blue
                { value: 0.33, h: 220, c: 0.08, l: 0.45 }, // Steel blue
                { value: 0.66, h: 80, c: 0.08, l: 0.65 },  // Olive
                { value: 1.0, h: 60, c: 0.14, l: 0.88 }    // Yellow
            ]
        },
        turbo: {
            name: 'Turbo',
            semantic: 'Improved rainbow (no banding)',
            stops: [
                { value: 0.0, h: 260, c: 0.18, l: 0.35 },  // Blue-purple
                { value: 0.2, h: 210, c: 0.22, l: 0.55 },  // Cyan-blue
                { value: 0.4, h: 150, c: 0.24, l: 0.65 },  // Green
                { value: 0.6, h: 60, c: 0.26, l: 0.75 },   // Yellow
                { value: 0.8, h: 30, c: 0.28, l: 0.65 },   // Orange
                { value: 1.0, h: 0, c: 0.24, l: 0.50 }     // Red
            ]
        },
        mako: {
            name: 'Mako',
            semantic: 'Deep ocean blue→teal',
            stops: [
                { value: 0.0, h: 260, c: 0.08, l: 0.12 },  // Abyss
                { value: 0.33, h: 240, c: 0.14, l: 0.35 }, // Deep blue
                { value: 0.66, h: 200, c: 0.18, l: 0.58 }, // Ocean blue
                { value: 1.0, h: 170, c: 0.16, l: 0.82 }   // Light teal
            ]
        },
        rocket: {
            name: 'Rocket',
            semantic: 'Dark→red→white (heat)',
            stops: [
                { value: 0.0, h: 280, c: 0.06, l: 0.10 },  // Dark
                { value: 0.33, h: 340, c: 0.20, l: 0.35 }, // Purple-red
                { value: 0.66, h: 15, c: 0.26, l: 0.60 },  // Red-orange
                { value: 1.0, h: 30, c: 0.08, l: 0.95 }    // Near white
            ]
        },

        // === DIVERGING (center-outward) ===
        coolwarm: {
            name: 'Coolwarm',
            semantic: 'Blue↔neutral↔red (diverging)',
            stops: [
                { value: 0.0, h: 230, c: 0.22, l: 0.45 },  // Cool blue
                { value: 0.25, h: 220, c: 0.12, l: 0.60 }, // Light blue
                { value: 0.5, h: 0, c: 0.02, l: 0.75 },    // Neutral gray
                { value: 0.75, h: 20, c: 0.14, l: 0.60 },  // Light red
                { value: 1.0, h: 15, c: 0.24, l: 0.45 }    // Warm red
            ]
        },
        spectral: {
            name: 'Spectral',
            semantic: 'Full rainbow diverging',
            stops: [
                { value: 0.0, h: 10, c: 0.22, l: 0.50 },   // Red
                { value: 0.25, h: 40, c: 0.24, l: 0.70 },  // Orange-yellow
                { value: 0.5, h: 60, c: 0.20, l: 0.85 },   // Yellow (center)
                { value: 0.75, h: 140, c: 0.20, l: 0.65 }, // Green
                { value: 1.0, h: 240, c: 0.18, l: 0.50 }   // Blue
            ]
        },

        // === APPLICATION-SPECIFIC ===
        thermal: {
            name: 'Thermal',
            semantic: 'Cold→hot temperature map',
            stops: [
                { value: 0.0, h: 240, c: 0.18, l: 0.30 },  // Cold blue
                { value: 0.25, h: 200, c: 0.20, l: 0.45 }, // Cool cyan
                { value: 0.5, h: 60, c: 0.22, l: 0.65 },   // Warm yellow
                { value: 0.75, h: 30, c: 0.26, l: 0.58 },  // Hot orange
                { value: 1.0, h: 0, c: 0.28, l: 0.50 }     // Burning red
            ]
        },
        nightvision: {
            name: 'Night Vision',
            semantic: 'Phosphor green display',
            stops: [
                { value: 0.0, h: 140, c: 0.02, l: 0.05 },  // Black
                { value: 0.33, h: 140, c: 0.12, l: 0.25 }, // Dark green
                { value: 0.66, h: 130, c: 0.22, l: 0.55 }, // Bright green
                { value: 1.0, h: 120, c: 0.28, l: 0.85 }   // Glowing green
            ]
        },
        ocean: {
            name: 'Ocean',
            semantic: 'Bathymetry depth map',
            stops: [
                { value: 0.0, h: 250, c: 0.12, l: 0.15 },  // Abyss
                { value: 0.33, h: 230, c: 0.18, l: 0.35 }, // Deep
                { value: 0.66, h: 200, c: 0.20, l: 0.55 }, // Mid-depth
                { value: 1.0, h: 180, c: 0.16, l: 0.80 }   // Shallow
            ]
        },
        terrain: {
            name: 'Terrain',
            semantic: 'Water→land→mountain',
            stops: [
                { value: 0.0, h: 220, c: 0.16, l: 0.40 },  // Water blue
                { value: 0.3, h: 140, c: 0.18, l: 0.55 },  // Lowland green
                { value: 0.5, h: 80, c: 0.16, l: 0.60 },   // Plains yellow-green
                { value: 0.7, h: 40, c: 0.14, l: 0.50 },   // Hills brown
                { value: 1.0, h: 0, c: 0.04, l: 0.90 }     // Snow white
            ]
        },
        electric: {
            name: 'Electric',
            semantic: 'Neon cyberpunk glow',
            stops: [
                { value: 0.0, h: 280, c: 0.25, l: 0.30 },  // Deep purple
                { value: 0.33, h: 320, c: 0.30, l: 0.50 }, // Hot pink
                { value: 0.66, h: 190, c: 0.28, l: 0.65 }, // Electric cyan
                { value: 1.0, h: 60, c: 0.26, l: 0.85 }    // Neon yellow
            ]
        },

        // =====================================================================
        // PART B: ROLE-SEMANTIC GRADIENTS (18 schemes)
        // Named after canonical roles with meaningful color journeys
        // =====================================================================

        // === GROUP 1: QUERIES & ACCESS (Cool blues/cyans - passive reads) ===
        query: {
            name: 'Query',
            semantic: 'Retrieve data calmly',
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },  // Deep blue - start
                { value: 0.5, h: 200, c: 0.15, l: 0.55 },  // Sky blue - middle
                { value: 1.0, h: 190, c: 0.20, l: 0.70 }   // Light cyan - found
            ]
        },
        finder: {
            name: 'Finder',
            semantic: 'Search and seek',
            stops: [
                { value: 0.0, h: 200, c: 0.05, l: 0.35 },  // Dim - searching
                { value: 0.3, h: 180, c: 0.12, l: 0.50 },  // Teal - hunting
                { value: 0.7, h: 160, c: 0.18, l: 0.65 },  // Cyan-green - close
                { value: 1.0, h: 140, c: 0.24, l: 0.75 }   // Bright green - found!
            ]
        },

        // === GROUP 2: COMMANDS & MUTATIONS (Warm - active writes) ===
        command: {
            name: 'Command',
            semantic: 'Execute with authority',
            stops: [
                { value: 0.0, h: 30, c: 0.15, l: 0.45 },   // Amber ready
                { value: 0.5, h: 20, c: 0.22, l: 0.58 },   // Orange active
                { value: 1.0, h: 10, c: 0.28, l: 0.65 }    // Red-orange fired
            ]
        },
        creator: {
            name: 'Creator',
            semantic: 'Bring into existence',
            stops: [
                { value: 0.0, h: 180, c: 0.10, l: 0.40 },  // Seed teal
                { value: 0.4, h: 150, c: 0.18, l: 0.55 },  // Sprout green
                { value: 0.8, h: 120, c: 0.24, l: 0.68 },  // Growth lime
                { value: 1.0, h: 90, c: 0.28, l: 0.75 }    // Full bloom yellow-green
            ]
        },
        destroyer: {
            name: 'Destroyer',
            semantic: 'Remove from existence',
            stops: [
                { value: 0.0, h: 0, c: 0.08, l: 0.60 },    // Pale warning
                { value: 0.4, h: 10, c: 0.18, l: 0.50 },   // Red alert
                { value: 0.7, h: 350, c: 0.26, l: 0.40 },  // Crimson
                { value: 1.0, h: 340, c: 0.20, l: 0.25 }   // Dark destruction
            ]
        },

        // === GROUP 3: FACTORIES (Construction - blue→green) ===
        factory: {
            name: 'Factory',
            semantic: 'Assembly line production',
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.45 },  // Blueprint blue
                { value: 0.3, h: 200, c: 0.16, l: 0.55 },  // Processing
                { value: 0.6, h: 170, c: 0.20, l: 0.62 },  // Assembly
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Product green
            ]
        },

        // === GROUP 4: STORAGE (Solid, grounded - deep blues/purples) ===
        repository: {
            name: 'Repository',
            semantic: 'Deep data vault',
            stops: [
                { value: 0.0, h: 240, c: 0.12, l: 0.30 },  // Database depths
                { value: 0.5, h: 230, c: 0.18, l: 0.45 },  // Data layer
                { value: 1.0, h: 220, c: 0.22, l: 0.60 }   // Accessible
            ]
        },
        cache: {
            name: 'Cache',
            semantic: 'Fast temporary',
            stops: [
                { value: 0.0, h: 300, c: 0.08, l: 0.50 },  // Magenta flash
                { value: 0.5, h: 320, c: 0.16, l: 0.62 },  // Pink speed
                { value: 1.0, h: 340, c: 0.22, l: 0.75 }   // Hot pink hit
            ]
        },

        // === GROUP 5: ORCHESTRATION (Purple/magenta - control flow) ===
        service: {
            name: 'Service',
            semantic: 'Coordinate operations',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Purple quiet
                { value: 0.5, h: 280, c: 0.16, l: 0.55 },  // Active violet
                { value: 1.0, h: 290, c: 0.22, l: 0.68 }   // Bright orchid
            ]
        },
        orchestrator: {
            name: 'Orchestrator',
            semantic: 'See all, conduct all',
            stops: [
                { value: 0.0, h: 200, c: 0.12, l: 0.40 },  // Start blue
                { value: 0.25, h: 270, c: 0.18, l: 0.50 }, // Through purple
                { value: 0.5, h: 330, c: 0.22, l: 0.58 },  // To pink
                { value: 0.75, h: 30, c: 0.24, l: 0.62 },  // Through orange
                { value: 1.0, h: 60, c: 0.26, l: 0.70 }    // End gold (full spectrum)
            ]
        },

        // === GROUP 6: VALIDATION (Yellow/green - pass/fail semantics) ===
        validator: {
            name: 'Validator',
            semantic: 'Check and verify',
            stops: [
                { value: 0.0, h: 0, c: 0.20, l: 0.50 },    // Red fail
                { value: 0.4, h: 45, c: 0.22, l: 0.65 },   // Yellow warning
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Green pass
            ]
        },
        guard: {
            name: 'Guard',
            semantic: 'Protect and defend',
            stops: [
                { value: 0.0, h: 350, c: 0.18, l: 0.40 },  // Dark red blocked
                { value: 0.5, h: 30, c: 0.20, l: 0.55 },   // Orange caution
                { value: 1.0, h: 120, c: 0.22, l: 0.65 }   // Green allowed
            ]
        },

        // === GROUP 7: TRANSFORMATION (Rainbow arc - any to any) ===
        transformer: {
            name: 'Transformer',
            semantic: 'Complete metamorphosis',
            stops: [
                { value: 0.0, h: 220, c: 0.14, l: 0.45 },  // Blue input
                { value: 0.3, h: 280, c: 0.18, l: 0.52 },  // Purple process
                { value: 0.6, h: 340, c: 0.22, l: 0.58 },  // Pink transition
                { value: 1.0, h: 30, c: 0.26, l: 0.65 }    // Orange output
            ]
        },
        parser: {
            name: 'Parser',
            semantic: 'Decode from wire',
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.85 },    // White wire
                { value: 0.5, h: 180, c: 0.10, l: 0.70 },  // Decoding
                { value: 1.0, h: 160, c: 0.20, l: 0.55 }   // Data teal
            ]
        },

        // === GROUP 8: EVENTS (Signals - purple/yellow pulses) ===
        handler: {
            name: 'Handler',
            semantic: 'React to event',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Waiting purple
                { value: 0.5, h: 290, c: 0.18, l: 0.55 },  // Triggered
                { value: 1.0, h: 310, c: 0.26, l: 0.68 }   // Handling pink
            ]
        },
        emitter: {
            name: 'Emitter',
            semantic: 'Broadcast signal',
            stops: [
                { value: 0.0, h: 50, c: 0.18, l: 0.55 },   // Yellow charge
                { value: 0.5, h: 45, c: 0.24, l: 0.68 },   // Bright emit
                { value: 1.0, h: 40, c: 0.30, l: 0.78 }    // Golden broadcast
            ]
        },

        // === GROUP 9: UTILITIES (Neutral supporting - grays/pastels) ===
        utility: {
            name: 'Utility',
            semantic: 'General tool',
            stops: [
                { value: 0.0, h: 220, c: 0.04, l: 0.45 },  // Gray-blue tool
                { value: 0.5, h: 200, c: 0.08, l: 0.58 },  // Soft cyan
                { value: 1.0, h: 180, c: 0.12, l: 0.72 }   // Light teal
            ]
        },
        lifecycle: {
            name: 'Lifecycle',
            semantic: 'Birth to death cycle',
            stops: [
                { value: 0.0, h: 120, c: 0.20, l: 0.65 },  // Birth green
                { value: 0.25, h: 60, c: 0.22, l: 0.70 },  // Youth yellow
                { value: 0.5, h: 30, c: 0.24, l: 0.60 },   // Maturity orange
                { value: 0.75, h: 0, c: 0.20, l: 0.50 },   // Aging red
                { value: 1.0, h: 280, c: 0.10, l: 0.35 }   // Death purple
            ]
        },

        // =====================================================================
        // PART C: OKLCH GEOMETRY GENERATORS (Function-based paths)
        // These use mathematical functions instead of discrete stops.
        // Each has a `generator` function: (t) => { h, c, l }
        // =====================================================================

        // === LOOPS (Full 360° hue cycles) ===
        'rainbow-loop': {
            name: 'Rainbow Loop',
            semantic: 'Full hue circle at constant L/C',
            generator: (t) => ({
                h: t * 360,           // Full hue rotation
                c: 0.20,              // Constant chroma
                l: 0.65               // Constant lightness
            })
        },
        'rainbow-bright': {
            name: 'Rainbow Bright',
            semantic: 'Vivid rainbow with high chroma',
            generator: (t) => ({
                h: t * 360,
                c: 0.28,              // High chroma for vivid colors
                l: 0.70
            })
        },
        'rainbow-dark': {
            name: 'Rainbow Dark',
            semantic: 'Subdued rainbow for dark themes',
            generator: (t) => ({
                h: t * 360,
                c: 0.18,
                l: 0.45               // Lower lightness
            })
        },

        // === ARCS (Partial hue sweeps) ===
        'arc-warm': {
            name: 'Warm Arc',
            semantic: 'Red→Yellow→Orange (warm sector)',
            generator: (t) => ({
                h: 0 + t * 60,        // 0° to 60° (red to yellow)
                c: 0.24,
                l: 0.55 + t * 0.15    // Slight lightness increase
            })
        },
        'arc-cool': {
            name: 'Cool Arc',
            semantic: 'Cyan→Blue→Purple (cool sector)',
            generator: (t) => ({
                h: 180 + t * 100,     // 180° to 280° (cyan to purple)
                c: 0.22,
                l: 0.50 + t * 0.15
            })
        },
        'arc-nature': {
            name: 'Nature Arc',
            semantic: 'Green→Teal→Cyan (nature)',
            generator: (t) => ({
                h: 120 + t * 60,      // 120° to 180° (green to cyan)
                c: 0.20,
                l: 0.60 + t * 0.10
            })
        },

        // === SPIRALS (Hue + varying L or C) ===
        'spiral-up': {
            name: 'Spiral Up',
            semantic: 'Hue rotates as lightness increases',
            generator: (t) => ({
                h: t * 270,           // 3/4 hue rotation
                c: 0.18,
                l: 0.30 + t * 0.55    // Dark to light
            })
        },
        'spiral-down': {
            name: 'Spiral Down',
            semantic: 'Hue rotates as lightness decreases',
            generator: (t) => ({
                h: t * 270,
                c: 0.20,
                l: 0.85 - t * 0.55    // Light to dark
            })
        },
        'spiral-chroma': {
            name: 'Spiral Chroma',
            semantic: 'Hue rotates as saturation increases',
            generator: (t) => ({
                h: t * 360,
                c: 0.06 + t * 0.22,   // Gray to vivid
                l: 0.60
            })
        },

        // === SINUSOIDAL (Wave patterns) ===
        'wave-lightness': {
            name: 'Wave Lightness',
            semantic: 'Sinusoidal lightness oscillation',
            generator: (t) => ({
                h: t * 180,           // Half hue rotation
                c: 0.20,
                l: 0.50 + Math.sin(t * Math.PI * 2) * 0.20  // Wave between 0.30 and 0.70
            })
        },
        'wave-chroma': {
            name: 'Wave Chroma',
            semantic: 'Sinusoidal saturation oscillation',
            generator: (t) => ({
                h: t * 180,
                c: 0.15 + Math.sin(t * Math.PI * 2) * 0.12, // Wave between 0.03 and 0.27
                l: 0.60
            })
        },
        'pulse': {
            name: 'Pulse',
            semantic: 'Both L and C oscillate together',
            generator: (t) => {
                const wave = Math.sin(t * Math.PI * 3); // 1.5 full waves
                return {
                    h: t * 120,       // Partial hue sweep
                    c: 0.15 + wave * 0.10,
                    l: 0.55 + wave * 0.15
                };
            }
        },

        // === LINEAR RAMPS (Simple mathematical paths) ===
        'ramp-hue': {
            name: 'Hue Ramp',
            semantic: 'Pure hue change, constant L/C',
            generator: (t) => ({
                h: 220 + t * 140,     // Blue to pink (220° to 360°)
                c: 0.22,
                l: 0.60
            })
        },
        'ramp-lightness': {
            name: 'Lightness Ramp',
            semantic: 'Dark to light, constant H/C',
            generator: (t) => ({
                h: 220,               // Fixed blue
                c: 0.18,
                l: 0.25 + t * 0.60    // 0.25 to 0.85
            })
        },
        'ramp-chroma': {
            name: 'Chroma Ramp',
            semantic: 'Gray to vivid, constant H/L',
            generator: (t) => ({
                h: 280,               // Fixed purple
                c: 0.02 + t * 0.26,   // 0.02 to 0.28
                l: 0.60
            })
        },

        // === SPECIAL GEOMETRIC PATHS ===
        'helix': {
            name: 'Helix',
            semantic: 'Full 3D path through OKLCH cylinder',
            generator: (t) => ({
                h: t * 540,           // 1.5 hue rotations
                c: 0.10 + t * 0.15,   // Increasing chroma
                l: 0.30 + t * 0.50    // Rising lightness
            })
        },
        'convergent': {
            name: 'Convergent',
            semantic: 'Colors converge toward gray',
            generator: (t) => ({
                h: t * 180,           // Half rotation
                c: 0.26 * (1 - t),    // Chroma decreases to 0
                l: 0.55
            })
        },
        'divergent': {
            name: 'Divergent',
            semantic: 'Colors diverge from gray',
            generator: (t) => ({
                h: 180 + t * 180,     // Second half of hue wheel
                c: 0.26 * t,          // Chroma increases from 0
                l: 0.55
            })
        },
        'bicone': {
            name: 'Bicone',
            semantic: 'Center peak, edges dark (HSL-like)',
            generator: (t) => {
                // Lightness peaks at center, dark at edges
                const l = t < 0.5 ? 0.30 + t * 0.70 : 0.65 - (t - 0.5) * 0.70;
                return {
                    h: t * 360,
                    c: 0.20,
                    l: Math.max(0.30, l)
                };
            }
        }
    };

    // Current active scheme
    let _activeScheme = null;

// =========================================================================
// SUBSCRIBERS: Reactive notifications
// =========================================================================

let _subscribers = [];

function subscribe(callback) {
    _subscribers.push(callback);
    return () => {
        _subscribers = _subscribers.filter(cb => cb !== callback);
    };
}

function _notifySubscribers(event, data) {
    _subscribers.forEach(cb => cb(event, data));
}

// =========================================================================
// OKLCH -> HEX CONVERSION
// =========================================================================

function _toHex(oklch) {
    const { h, c, l } = oklch;

    // Convert OKLCH to approximate RGB
    const hRad = h * Math.PI / 180;
    const a = c * Math.cos(hRad);
    const b = c * Math.sin(hRad);

    // Simplified OKLab to linear RGB (approximate)
    const L = l;
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    const l3 = l_ * l_ * l_;
    const m3 = m_ * m_ * m_;
    const s3 = s_ * s_ * s_;

    let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
    let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
    let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

    // Clamp and convert to sRGB
    const toSRGB = (x) => {
        x = Math.max(0, Math.min(1, x));
        return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
    };

    r = Math.round(toSRGB(r) * 255);
    g = Math.round(toSRGB(g) * 255);
    bl = Math.round(toSRGB(bl) * 255);

    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    bl = Math.max(0, Math.min(255, bl));

    return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
}

function _applyTransform(oklch) {
    const t = transform;

    // Apply transforms
    let h = (oklch.h + t.hueShift + 360) % 360;
    let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
    let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

    // Apply amplifier to chroma for contrast
    if (t.amplifier !== 1) {
        c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
    }

    return _toHex({ h, c, l });
}

// =========================================================================
// CORE API
// =========================================================================

/**
 * Get color with transforms applied
 * @param {string} dimension - Palette dimension (tier, family, ring, layer, edgeType)
 * @param {string} category - Category within dimension
 * @returns {string} Hex color string
 */
function get(dimension, category) {
    const base = palette[dimension]?.[category];
    if (!base) return _toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray
    return _applyTransform(base);
}

/**
 * Get color for a numeric value using interval mapping
 * @param {string} intervalName - Interval name (markov, weight, confidence)
 * @param {number} value - Value (0-1)
 * @returns {string} Hex color string
 */
function getInterval(intervalName, value) {
    const v = Math.max(0, Math.min(1, value));

    // =========================================================================
    // SCHEME OVERRIDE: If an active scheme is selected, use it for ALL intervals
    // This makes the 33 named schemes (viridis, plasma, thermal, etc.) work
    // =========================================================================
    if (_activeScheme && schemePaths[_activeScheme]) {
        return getSchemeColor(_activeScheme, v);
    }

    // Fall back to hardcoded interval if no scheme active
    const interval = intervals[intervalName];
    if (!interval) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const stops = interval.stops;

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const t = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * t,
        c: lower.c + (upper.c - lower.c) * t,
        l: lower.l + (upper.l - lower.l) * t
    };

    return _applyTransform(interpolated);
}

/**
 * Interpolate between two hex colors in OKLCH space
 * @param {string} color1 - Hex color 1
 * @param {string} color2 - Hex color 2
 * @param {number} t - Interpolation factor (0-1)
 * @returns {string} Hex result
 */
function interpolate(color1, color2, t) {
    // We assume input hexes can be approximated back to OKLCH or treated as sRGB->OKLCH
    // For simplicity in this engine which mostly generates from OKLCH, we'll assume
    // specific OKLCH-derived palettes unless provided raw hex.
    // If we really need robust hex->oklch, we need a converter.
    // BUT, for edge gradients in app.js, we often have raw HSL or OKLCH objects.
    // Let's support passing Objects {h,c,l} or hex strings (naive interpolation for hex if needed).
    // Best approach: app.js should use COLOR.get() to get objects if possible, or we expose a helper
    // that takes our internal palette objects.

    // Actually, let's keep it simple: assume app.js will partial refactoring.
    // We will accept object {h,c,l} inputs for maximum precision.
    const c1 = (typeof color1 === 'string') ? parseOklchString(color1) || { h: 0, c: 0, l: 0.5 } : color1;
    const c2 = (typeof color2 === 'string') ? parseOklchString(color2) || { h: 0, c: 0, l: 0.5 } : color2;

    t = Math.max(0, Math.min(1, t));

    // Shortest path hue interpolation
    let h1 = c1.h || c1.H || 0;
    let h2 = c2.h || c2.H || 0;
    let dh = h2 - h1;
    if (Math.abs(dh) > 180) {
        if (dh > 0) h1 += 360;
        else h2 += 360;
    }

    const h = (h1 + (h2 - h1) * t) % 360;
    const c = (c1.c !== undefined ? c1.c : c1.C) + ((c2.c !== undefined ? c2.c : c2.C) - (c1.c !== undefined ? c1.c : c1.C)) * t;
    const l = (c1.l !== undefined ? c1.l : c1.L) + ((c2.l !== undefined ? c2.l : c2.L) - (c1.l !== undefined ? c1.l : c1.L)) * t;

    return _applyTransform({ h, c, l });
}

/**
 * Get raw OKLCH values (for advanced use)
 */
function getRaw(dimension, category) {
    return palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
}

/**
 * Get all categories for a dimension
 */
function getCategories(dimension) {
    return Object.keys(palette[dimension] || {});
}

/**
 * Get label for a category
 */
function getLabel(dimension, category) {
    return palette[dimension]?.[category]?.label || category;
}

// =========================================================================
// TRANSFORM CONTROLS
// =========================================================================

function setTransform(key, value) {
    if (key in transform) {
        transform[key] = value;
        _notifySubscribers('transform-change', { key, value });
    }
}

function setAllTransforms(transforms) {
    Object.assign(transform, transforms);
    _notifySubscribers('transform-change', transforms);
}

function resetTransforms() {
    transform.hueShift = 0;
    transform.chromaScale = 1.0;
    transform.lightnessShift = 0;
    transform.amplifier = 1.0;
    _notifySubscribers('transform-change', transform);
}

function getTransform() {
    return { ...transform };
}

// =========================================================================
// SCHEME API: Named Color Gradients
// =========================================================================

/**
 * List all available scheme names
 * @returns {string[]} Array of scheme names
 */
function listSchemes() {
    return Object.keys(schemePaths);
}

/**
 * Get scheme definition
 * @param {string} schemeName - Name of the scheme
 * @returns {object|null} Scheme definition with name, semantic, and stops
 */
function getScheme(schemeName) {
    return schemePaths[schemeName] || null;
}

/**
 * Get color at position t (0-1) along a scheme path
 * Supports both:
 *   - stops: Array of discrete points (interpolated)
 *   - generator: Function (t) => { h, c, l } (direct mathematical path)
 *
 * @param {string} schemeName - Name of the scheme
 * @param {number} t - Position along path (0-1)
 * @returns {string} Hex color string
 */
function getSchemeColor(schemeName, t) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const v = Math.max(0, Math.min(1, t));

    // GENERATOR MODE: Mathematical function (OKLCH geometry)
    if (scheme.generator && typeof scheme.generator === 'function') {
        const oklch = scheme.generator(v);
        return _applyTransform(oklch);
    }

    // STOPS MODE: Discrete points with interpolation
    const stops = scheme.stops;
    if (!stops || stops.length === 0) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const interp = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * interp,
        c: lower.c + (upper.c - lower.c) * interp,
        l: lower.l + (upper.l - lower.l) * interp
    };

    return _applyTransform(interpolated);
}

/**
 * Apply a scheme as the active color scheme
 * This sets transforms and notifies subscribers
 * @param {string} schemeName - Name of the scheme
 */
function applyScheme(schemeName) {
    // Allow null/undefined to clear the active scheme
    if (!schemeName) {
        _activeScheme = null;
        _notifySubscribers('scheme-change', { scheme: null, definition: null });
        console.log('[COLOR] Cleared active scheme, using default intervals');
        return;
    }

    const scheme = schemePaths[schemeName];
    if (!scheme) {
        console.warn('[COLOR] Unknown scheme:', schemeName);
        return;
    }

    _activeScheme = schemeName;
    _notifySubscribers('scheme-change', { scheme: schemeName, definition: scheme });
    console.log('[COLOR] Applied scheme:', schemeName, '-', scheme.semantic);
}

/**
 * Get the currently active scheme name
 * @returns {string|null} Active scheme name or null
 */
function getActiveScheme() {
    return _activeScheme;
}

/**
 * Generate a CSS gradient string for a scheme (for UI previews)
 * @param {string} schemeName - Name of the scheme
 * @param {string} direction - CSS gradient direction (default: 'to right')
 * @returns {string} CSS linear-gradient string
 */
function getSchemeGradientCSS(schemeName, direction = 'to right') {
    const scheme = schemePaths[schemeName];
    if (!scheme) return 'linear-gradient(to right, #333, #666)';

    const colorStops = scheme.stops.map(stop => {
        const color = _applyTransform(stop);
        const percent = Math.round(stop.value * 100);
        return `${color} ${percent}%`;
    });

    return `linear-gradient(${direction}, ${colorStops.join(', ')})`;
}

/**
 * Get scheme metadata (name, semantic description)
 * @param {string} schemeName - Name of the scheme
 * @returns {object} {name, semantic}
 */
function getSchemeInfo(schemeName) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return { name: schemeName, semantic: 'Unknown' };
    return { name: scheme.name, semantic: scheme.semantic };
}

// =========================================================================
// DEBUG
// =========================================================================

function debug() {
    console.log('[COLOR] Transform state:', transform);
    console.log('[COLOR] Palette dimensions:', Object.keys(palette));
    console.log('[COLOR] Interval mappings:', Object.keys(intervals));
    console.log('[COLOR] Schemes:', Object.keys(schemePaths).length, 'available');
    console.log('[COLOR] Active scheme:', _activeScheme);
}

// =========================================================================
// PUBLIC API
// =========================================================================

return {
    // Core API
    get,
    getInterval,
    getRaw,
    getCategories,
    getLabel,
    interpolate,

    // Transform controls
    setTransform,
    setAllTransforms,
    resetTransforms,
    getTransform,

    // Scheme API (33 named color gradients)
    listSchemes,
    getScheme,
    getSchemeColor,
    applyScheme,
    getActiveScheme,
    getSchemeGradientCSS,
    getSchemeInfo,

    // Subscriptions
    subscribe,

    // Internal access (for migration)
    palette,
    intervals,
    transform,
    schemePaths,

    // Debug
    debug
};
}) ();

// Export to window for global access
window.COLOR = COLOR;

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'ColorOrchestrator', { get: () => COLOR, configurable: true });
Object.defineProperty(window, 'Color', { get: () => COLOR, configurable: true });

console.log('[Module] COLOR loaded - OKLCH color engine with', Object.keys(COLOR.schemePaths || {}).length, 'schemes');


// ═══ MODULE: modules/refresh-throttle.js ═══
/**
 * REFRESH THROTTLE MODULE
 *
 * Prevents excessive Graph.refresh() calls that can cause performance issues.
 * Implements frame-budget-aware throttling at 60fps max.
 *
 * Fixes ARCH-003: Unthrottled Graph.refresh() calls
 *
 * Usage:
 *   REFRESH.throttled()     // Request a throttled refresh
 *   REFRESH.force()         // Force immediate refresh (use sparingly)
 *   REFRESH.stats           // Get refresh statistics
 */

const REFRESH = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        minInterval: 16,      // 60fps max (1000ms / 60 = 16.67ms)
        maxPending: 3,        // Max queued refresh requests before forcing
        logThreshold: 100     // Log warning if more than N refreshes/second
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _pending = false;
    let _lastRefresh = 0;
    let _rafId = null;
    let _pendingCount = 0;

    // Statistics
    let _stats = {
        totalCalls: 0,
        throttledCalls: 0,
        actualRefreshes: 0,
        lastSecondRefreshes: 0,
        currentSecondRefreshes: 0,
        lastSecond: 0
    };

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Request a throttled graph refresh.
     * Multiple calls within the same frame are coalesced into one refresh.
     */
    function throttled() {
        _stats.totalCalls++;
        _pendingCount++;

        // Track calls per second for diagnostics
        const now = performance.now();
        const currentSecond = Math.floor(now / 1000);
        if (currentSecond !== _stats.lastSecond) {
            _stats.lastSecondRefreshes = _stats.currentSecondRefreshes;
            _stats.currentSecondRefreshes = 0;
            _stats.lastSecond = currentSecond;

            // Warn if too many refreshes
            if (_stats.lastSecondRefreshes > CONFIG.logThreshold) {
                console.warn(`[REFRESH] High refresh rate: ${_stats.lastSecondRefreshes}/s`);
            }
        }

        // If already pending, don't queue another
        if (_pending) {
            _stats.throttledCalls++;

            // Force refresh if too many pending
            if (_pendingCount >= CONFIG.maxPending) {
                _doRefresh();
            }
            return;
        }

        // Check if enough time has passed since last refresh
        const elapsed = now - _lastRefresh;
        if (elapsed >= CONFIG.minInterval) {
            // Enough time passed, refresh immediately
            _doRefresh();
        } else {
            // Schedule refresh for next frame
            _pending = true;
            _rafId = requestAnimationFrame(() => {
                _pending = false;
                _doRefresh();
            });
        }
    }

    /**
     * Force an immediate refresh, bypassing throttle.
     * Use sparingly - for critical updates only.
     */
    function force() {
        // Cancel any pending throttled refresh
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _doRefresh();
    }

    /**
     * Internal: Perform the actual refresh
     */
    function _doRefresh() {
        _lastRefresh = performance.now();
        _pendingCount = 0;
        _stats.actualRefreshes++;
        _stats.currentSecondRefreshes++;

        // Call the global Graph.refresh() if available
        if (typeof Graph !== 'undefined' && Graph && Graph.refresh) {
            Graph.refresh();
        }
    }

    /**
     * Cancel any pending refresh
     */
    function cancel() {
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _pendingCount = 0;
    }

    /**
     * Reset statistics
     */
    function resetStats() {
        _stats = {
            totalCalls: 0,
            throttledCalls: 0,
            actualRefreshes: 0,
            lastSecondRefreshes: 0,
            currentSecondRefreshes: 0,
            lastSecond: 0
        };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        throttled,
        force,
        cancel,
        resetStats,

        // Config (read-only access, can be modified via setConfig)
        get config() { return { ...CONFIG }; },
        setConfig(key, value) {
            if (key in CONFIG) {
                CONFIG[key] = value;
            }
        },

        // Statistics
        get stats() {
            return {
                ..._stats,
                throttleRatio: _stats.totalCalls > 0
                    ? (_stats.throttledCalls / _stats.totalCalls * 100).toFixed(1) + '%'
                    : '0%',
                pending: _pending,
                pendingCount: _pendingCount
            };
        },

        // Debug
        debug() {
            console.log('[REFRESH] Stats:', this.stats);
            console.log('[REFRESH] Config:', CONFIG);
        }
    };
})();


// ═══ MODULE: modules/legend-manager.js ═══
/**
 * LEGEND MANAGER MODULE
 *
 * Manages legend data, counts, and visibility for all visualization dimensions.
 * Delegates all color operations to the COLOR module.
 *
 * Depends on: COLOR, NODE
 *
 * Usage:
 *   LEGEND.init(nodes, links)           // Initialize with graph data
 *   LEGEND.getLegendData('tier')        // Get legend items for a dimension
 *   LEGEND.getColor('tier', 'T0')       // Get color (delegates to COLOR)
 *   LEGEND.subscribe(callback)          // React to legend changes
 */

const LEGEND = (function() {
    'use strict';

    // =========================================================================
    // DIMENSION METADATA
    // =========================================================================

    const dimensions = {
        tier: {
            name: 'TIERS',
            icon: '◐',
            extract: (node) => NODE.getTier(node)
        },
        family: {
            name: 'FAMILIES',
            icon: '⬡',
            extract: (node) => NODE.getFamily(node)
        },
        ring: {
            name: 'RINGS',
            icon: '◎',
            extract: (node) => NODE.getRing(node)
        },
        layer: {
            name: 'LAYERS',
            icon: '☰',
            extract: (node) => NODE.getLayer(node).toUpperCase()
        },
        effect: {
            name: 'EFFECTS',
            icon: '⚡',
            extract: (node) => NODE.getEffect(node)
        },
        edgeType: {
            name: 'EDGE TYPES',
            icon: '→',
            extract: (link) => (link.edge_type || link.type || 'unknown').toLowerCase()
        },
        edgeFamily: {
            name: 'EDGE FAMILIES',
            icon: '⇢',
            extract: (link) => (link.family || 'Dependency')
        }
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _counts = {};
    let _subscribers = [];

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Initialize legend with nodes and links data
     */
    function init(nodes, links) {
        _computeCounts(nodes, links);
        return LEGEND;
    }

    /**
     * Compute counts for all dimensions
     */
    function _computeCounts(nodes, links) {
        _counts = {};

        // Node dimensions
        ['tier', 'family', 'ring', 'layer', 'effect'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (nodes || []).forEach(node => {
                const cat = extract(node);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        // Edge dimensions
        ['edgeType', 'edgeFamily'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (links || []).forEach(link => {
                const cat = extract(link);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        console.log('[LEGEND] Counts computed:', Object.keys(_counts));
        _notifySubscribers('counts-updated', _counts);
    }

    /**
     * Get legend data for a dimension
     * Returns array of { id, label, color, count, dimension }
     */
    function getLegendData(dimension) {
        const counts = _counts[dimension] || {};

        return Object.keys(counts)
            .filter(cat => counts[cat] > 0)
            .sort((a, b) => (counts[b] || 0) - (counts[a] || 0))
            .map(cat => ({
                id: cat,
                label: COLOR.getLabel(dimension, cat),
                color: COLOR.get(dimension, cat),
                count: counts[cat] || 0,
                dimension: dimension
            }));
    }

    /**
     * Get color for a dimension/category (delegates to COLOR)
     */
    function getColor(dimension, category) {
        return COLOR.get(dimension, category);
    }

    /**
     * Get counts for a dimension
     */
    function getCounts(dimension) {
        return _counts[dimension] || {};
    }

    /**
     * Get all available dimensions
     */
    function getDimensions() {
        return Object.keys(dimensions);
    }

    /**
     * Get dimension metadata
     */
    function getDimensionMeta(dimension) {
        return dimensions[dimension] || null;
    }

    // =========================================================================
    // SUBSCRIPTIONS
    // =========================================================================

    function subscribe(callback) {
        _subscribers.push(callback);
        return () => {
            _subscribers = _subscribers.filter(cb => cb !== callback);
        };
    }

    function _notifySubscribers(event, data) {
        _subscribers.forEach(cb => cb(event, data));
    }

    // =========================================================================
    // DOM RENDERING
    // =========================================================================

    /**
     * Render a legend section to the DOM
     * @param {string} containerId - DOM container ID
     * @param {string} dimension - Dimension to render (tier, family, etc.)
     * @param {Set} stateSet - Filter state set (items to show)
     * @param {Function} onUpdate - Callback when filter changes
     */
    function renderSection(containerId, dimension, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        const legendData = getLegendData(dimension);
        if (!legendData || legendData.length === 0) return;

        // Build legend items
        legendData.forEach(item => {
            const el = document.createElement('div');
            el.className = 'topo-legend-item' + (stateSet && !stateSet.has(item.id) ? ' filtered' : '');
            el.dataset.category = item.id;
            el.dataset.dimension = dimension;

            // Color swatch
            const swatch = document.createElement('span');
            swatch.className = 'topo-legend-swatch';
            swatch.style.backgroundColor = item.color;

            // Label with count
            const label = document.createElement('span');
            label.className = 'topo-legend-label';
            label.textContent = item.id;

            const count = document.createElement('span');
            count.className = 'topo-legend-count';
            count.textContent = `(${item.count})`;

            el.appendChild(swatch);
            el.appendChild(label);
            el.appendChild(count);

            // Click to toggle filter
            if (stateSet) {
                el.addEventListener('click', () => {
                    if (stateSet.has(item.id)) {
                        stateSet.delete(item.id);
                        el.classList.add('filtered');
                    } else {
                        stateSet.add(item.id);
                        el.classList.remove('filtered');
                    }
                    if (onUpdate) onUpdate();
                });
            }

            container.appendChild(el);
        });

        console.log(`[Legend] Rendered ${dimension}: ${legendData.length} items`);
    }

    /**
     * Render all legend sections
     * @param {Object} filters - VIS_FILTERS object with filter Sets
     * @param {Function} onUpdate - Callback when any filter changes (typically refreshGraph)
     */
    function renderAll(filters, onUpdate) {
        // Render node legends
        renderSection('topo-tiers', 'tier', filters?.tiers, onUpdate);
        renderSection('topo-families', 'family', filters?.families, onUpdate);
        renderSection('topo-rings', 'ring', filters?.rings, onUpdate);
        renderSection('topo-layers', 'layer', filters?.layers, onUpdate);
        renderSection('topo-effects', 'effect', filters?.effects, onUpdate);

        // Render edge legends
        renderSection('topo-edges', 'edgeType', filters?.edges, onUpdate);
        renderSection('topo-edge-families', 'edgeFamily', filters?.edgeFamilies, onUpdate);

        console.log('[Legend] All sections rendered');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        getLegendData,
        getColor,
        getCounts,
        getDimensions,
        getDimensionMeta,
        subscribe,
        renderSection,
        renderAll,

        // Direct access to dimensions (for migration)
        dimensions,

        // Computed counts
        get counts() { return _counts; }
    };
})();

// Backward compatibility - LegendManager class wrapper
class LegendManager {
    constructor() {
        this.dimensions = LEGEND.dimensions;
        this.counts = {};
        this._subscribers = [];
    }

    init(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
        return this;
    }

    _computeCounts(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
    }

    getLegendData(dimension) {
        return LEGEND.getLegendData(dimension);
    }

    getColor(dimension, category) {
        return LEGEND.getColor(dimension, category);
    }

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    }

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    }
}

// Global Legend instance - defined by app.js (not duplicated here to avoid redeclaration)
// Legend is accessed as a global variable provided by app.js

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

// renderLegendSection calls LEGEND.renderSection with Legend (global) as source
window.renderLegendSection = function(containerId, dimension, stateSet, onUpdate) {
    LEGEND.renderSection(containerId, dimension, stateSet, onUpdate);
};

// renderAllLegends uses VIS_FILTERS and refreshGraph from app.js globals
// Includes 100ms debounce to prevent DOM thrashing during rapid updates
let _legendDebounceTimer = null;
window.renderAllLegends = function() {
    if (_legendDebounceTimer) clearTimeout(_legendDebounceTimer);
    _legendDebounceTimer = setTimeout(() => {
        _legendDebounceTimer = null;
        const VIS_FILTERS = window.VIS_FILTERS;
        const refreshGraph = window.refreshGraph;
        if (VIS_FILTERS && refreshGraph) {
            LEGEND.renderAll(VIS_FILTERS, refreshGraph);
        } else {
            console.warn('[Legend] VIS_FILTERS or refreshGraph not available');
        }
    }, 100);
};

console.log('[Module] LEGEND loaded - 10 functions');


// ═══ MODULE: modules/data-manager.js ═══
/**
 * DATA MANAGER MODULE
 *
 * Single gate for ALL data access in the visualization.
 * Replaces direct access to FULL_GRAPH and Graph.graphData().
 * Provides O(1) indexed lookups and cached aggregations.
 *
 * Depends on: NODE, COLOR, LEGEND
 *
 * Usage:
 *   DATA.init(graphData)                // Initialize with payload data
 *   DATA.getNodes()                     // Get all raw nodes
 *   DATA.getNode(id)                    // O(1) node lookup
 *   DATA.getNodesByTier('T0')           // O(1) tier lookup
 *   DATA.getEdgesFrom(nodeId)           // O(1) edge lookup
 *   DATA.getTierCounts()                // Cached aggregation
 */

const DATA = (function() {
    'use strict';

    // =========================================================================
    // RAW DATA (immutable after init)
    // =========================================================================

    const raw = {
        nodes: [],
        links: [],
        fileBoundaries: [],
        markov: {},
        kpis: {},
        meta: {},
        physics: {},
        config: {}
    };

    // =========================================================================
    // ANALYTICS DATA (all Collider sections)
    // =========================================================================

    const analytics = {
        counts: {},
        stats: {},
        coverage: {},
        performance: {},
        classification: {},
        auto_discovery: {},
        ecosystem_discovery: {},
        dependencies: {},
        architecture: {},
        topology: {},
        execution_flow: {},
        data_flow: {},
        knots: {},
        warnings: [],
        recommendations: [],
        theory_completeness: {},
        distributions: {},
        edge_types: {},
        rpbl_profile: {},
        purpose_field: {},
        top_hubs: [],
        orphans_list: [],
        files: [],
        semantics: {},
        llm_enrichment: {},
        brain_download: {},
        ai_insights: null
    };

    // =========================================================================
    // INDEXES (O(1) lookups - built once)
    // =========================================================================

    const index = {
        nodeById: new Map(),           // id -> node
        nodesByTier: new Map(),        // tier -> [nodes]
        nodesByFamily: new Map(),      // family -> [nodes]
        nodesByRing: new Map(),        // ring -> [nodes]
        nodesByLayer: new Map(),       // layer -> [nodes]
        nodesByEffect: new Map(),      // effect -> [nodes]
        nodesByFile: new Map(),        // fileIdx -> [nodes]
        edgesBySource: new Map(),      // nodeId -> [edges from]
        edgesByTarget: new Map(),      // nodeId -> [edges to]
        edgeByKey: new Map(),          // "src|tgt" -> edge
        fileByIndex: new Map(),        // idx -> fileBoundary
        markovBySource: new Map()      // nodeId -> sorted edges by weight
    };

    // =========================================================================
    // CACHED AGGREGATIONS (computed once, invalidated on filter)
    // =========================================================================

    const cache = {
        tierCounts: null,
        familyCounts: null,
        ringCounts: null,
        layerCounts: null,
        effectCounts: null,
        edgeTypeCounts: null,
        edgeFamilyCounts: null,
        edgeRanges: null
    };

    // =========================================================================
    // CURRENT STATE (filtered view)
    // =========================================================================

    const filtered = {
        nodes: [],
        links: []
    };

    // Legend manager instance
    let _legend = null;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function init(data) {
        // Store raw data
        raw.nodes = Array.isArray(data?.nodes) ? data.nodes : [];
        raw.links = Array.isArray(data?.links) ? data.links : [];
        raw.fileBoundaries = Array.isArray(data?.file_boundaries) ? data.file_boundaries : [];
        raw.markov = data?.markov || {};
        raw.kpis = data?.kpis || {};
        raw.meta = data?.meta || {};
        raw.physics = data?.physics || {};
        raw.config = data?.config || {};

        // Store analytics data
        Object.keys(analytics).forEach(key => {
            if (data?.[key] !== undefined) {
                analytics[key] = data[key];
            }
        });

        // Build all indexes
        _buildAllIndexes();

        // Initialize legend
        _legend = new LegendManager();
        _legend.init(raw.nodes, raw.links);

        // Set global Legend reference
        if (typeof Legend !== 'undefined') {
            Legend = _legend;
        }

        console.log('%c[DATA] Initialized', 'color: #4ade80; font-weight: bold',
            `${raw.nodes.length} nodes, ${raw.links.length} edges, ${raw.fileBoundaries.length} files`);

        return DATA;
    }

    // =========================================================================
    // INDEX BUILDING
    // =========================================================================

    function _buildAllIndexes() {
        _buildNodeIndex();
        _buildSemanticIndexes();
        _buildEdgeIndexes();
        _buildFileIndex();
        _buildMarkovIndex();
        _invalidateCache();
    }

    function _buildNodeIndex() {
        index.nodeById.clear();
        for (const node of raw.nodes) {
            if (node?.id) {
                index.nodeById.set(node.id, node);
            }
        }
    }

    function _buildSemanticIndexes() {
        index.nodesByTier.clear();
        index.nodesByFamily.clear();
        index.nodesByRing.clear();
        index.nodesByLayer.clear();
        index.nodesByEffect.clear();
        index.nodesByFile.clear();

        for (const node of raw.nodes) {
            if (!node) continue;

            // Tier index
            const tier = NODE.getTier(node);
            if (!index.nodesByTier.has(tier)) {
                index.nodesByTier.set(tier, []);
            }
            index.nodesByTier.get(tier).push(node);

            // Family index
            const family = NODE.getFamily(node);
            if (!index.nodesByFamily.has(family)) {
                index.nodesByFamily.set(family, []);
            }
            index.nodesByFamily.get(family).push(node);

            // Ring index
            const ring = NODE.getRing(node);
            if (!index.nodesByRing.has(ring)) {
                index.nodesByRing.set(ring, []);
            }
            index.nodesByRing.get(ring).push(node);

            // Layer index
            const layer = NODE.getLayer(node);
            if (!index.nodesByLayer.has(layer)) {
                index.nodesByLayer.set(layer, []);
            }
            index.nodesByLayer.get(layer).push(node);

            // Effect index
            const effect = NODE.getEffect(node);
            if (!index.nodesByEffect.has(effect)) {
                index.nodesByEffect.set(effect, []);
            }
            index.nodesByEffect.get(effect).push(node);

            // File index
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx >= 0) {
                if (!index.nodesByFile.has(fileIdx)) {
                    index.nodesByFile.set(fileIdx, []);
                }
                index.nodesByFile.get(fileIdx).push(node);
            }
        }
    }

    function _buildEdgeIndexes() {
        index.edgesBySource.clear();
        index.edgesByTarget.clear();
        index.edgeByKey.clear();

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');

            if (srcId) {
                if (!index.edgesBySource.has(srcId)) {
                    index.edgesBySource.set(srcId, []);
                }
                index.edgesBySource.get(srcId).push(link);
            }

            if (tgtId) {
                if (!index.edgesByTarget.has(tgtId)) {
                    index.edgesByTarget.set(tgtId, []);
                }
                index.edgesByTarget.get(tgtId).push(link);
            }

            if (srcId && tgtId) {
                index.edgeByKey.set(`${srcId}|${tgtId}`, link);
            }
        }
    }

    function _buildFileIndex() {
        index.fileByIndex.clear();
        for (let i = 0; i < raw.fileBoundaries.length; i++) {
            index.fileByIndex.set(i, raw.fileBoundaries[i]);
        }
    }

    function _buildMarkovIndex() {
        index.markovBySource.clear();
        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const mw = link.markov_weight || 0;
            if (srcId && mw > 0) {
                if (!index.markovBySource.has(srcId)) {
                    index.markovBySource.set(srcId, []);
                }
                index.markovBySource.get(srcId).push(link);
            }
        }
        // Sort each list by markov weight descending
        for (const [, edges] of index.markovBySource) {
            edges.sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0));
        }
    }

    function _invalidateCache() {
        Object.keys(cache).forEach(key => {
            cache[key] = null;
        });
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }

    // =========================================================================
    // RAW DATA ACCESSORS
    // =========================================================================

    function getNodes() { return raw.nodes; }
    function getLinks() { return raw.links; }
    function getFileBoundaries() { return raw.fileBoundaries; }
    function getMarkov() { return raw.markov; }
    function getKpis() { return raw.kpis; }
    function getMeta() { return raw.meta; }
    function getPhysics() { return raw.physics; }
    function getConfig() { return raw.config; }
    function getAnalytics(key) { return analytics[key]; }

    // =========================================================================
    // INDEXED LOOKUPS (O(1))
    // =========================================================================

    function getNode(id) {
        return index.nodeById.get(id) || null;
    }

    function getNodesByTier(tier) {
        return index.nodesByTier.get(tier) || [];
    }

    function getNodesByFamily(family) {
        return index.nodesByFamily.get(family) || [];
    }

    function getNodesByRing(ring) {
        return index.nodesByRing.get(ring) || [];
    }

    function getNodesByLayer(layer) {
        return index.nodesByLayer.get(layer) || [];
    }

    function getNodesByEffect(effect) {
        return index.nodesByEffect.get(effect) || [];
    }

    function getNodesByFile(fileIdx) {
        return index.nodesByFile.get(fileIdx) || [];
    }

    function getEdgesFrom(nodeId) {
        return index.edgesBySource.get(nodeId) || [];
    }

    function getEdgesTo(nodeId) {
        return index.edgesByTarget.get(nodeId) || [];
    }

    function getEdgeBetween(srcId, tgtId) {
        return index.edgeByKey.get(`${srcId}|${tgtId}`) || null;
    }

    function getFile(idx) {
        return index.fileByIndex.get(idx) || null;
    }

    function getTopMarkovEdges(nodeId, k = 5) {
        const edges = index.markovBySource.get(nodeId) || [];
        return edges.slice(0, k);
    }

    function isHighEntropyNode(nodeId) {
        const highEntropy = raw.markov?.high_entropy_nodes || [];
        return highEntropy.some(h => h.node === nodeId);
    }

    // =========================================================================
    // FILTERED DATA
    // =========================================================================

    function setFiltered(nodes, links) {
        filtered.nodes = nodes || [];
        filtered.links = links || [];
    }

    function getVisibleNodes() {
        if (filtered.nodes.length > 0) {
            return filtered.nodes;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().nodes || [])
            : [];
    }

    function getVisibleLinks() {
        if (filtered.links.length > 0) {
            return filtered.links;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().links || [])
            : [];
    }

    // =========================================================================
    // AGGREGATIONS (cached)
    // =========================================================================

    function getTierCounts() {
        if (!cache.tierCounts) {
            cache.tierCounts = new Map();
            for (const [tier, nodes] of index.nodesByTier) {
                cache.tierCounts.set(tier, nodes.length);
            }
        }
        return cache.tierCounts;
    }

    function getFamilyCounts() {
        if (!cache.familyCounts) {
            cache.familyCounts = new Map();
            for (const [family, nodes] of index.nodesByFamily) {
                cache.familyCounts.set(family, nodes.length);
            }
        }
        return cache.familyCounts;
    }

    function getRingCounts() {
        if (!cache.ringCounts) {
            cache.ringCounts = new Map();
            for (const [ring, nodes] of index.nodesByRing) {
                cache.ringCounts.set(ring, nodes.length);
            }
        }
        return cache.ringCounts;
    }

    function getLayerCounts() {
        if (!cache.layerCounts) {
            cache.layerCounts = new Map();
            for (const [layer, nodes] of index.nodesByLayer) {
                cache.layerCounts.set(layer, nodes.length);
            }
        }
        return cache.layerCounts;
    }

    function getEffectCounts() {
        if (!cache.effectCounts) {
            cache.effectCounts = new Map();
            for (const [effect, nodes] of index.nodesByEffect) {
                cache.effectCounts.set(effect, nodes.length);
            }
        }
        return cache.effectCounts;
    }

    function getEdgeTypeCounts() {
        if (!cache.edgeTypeCounts) {
            cache.edgeTypeCounts = new Map();
            for (const link of raw.links) {
                const type = link.edge_type || link.type || 'unknown';
                cache.edgeTypeCounts.set(type, (cache.edgeTypeCounts.get(type) || 0) + 1);
            }
        }
        return cache.edgeTypeCounts;
    }

    function getEdgeFamilyCounts() {
        if (!cache.edgeFamilyCounts) {
            cache.edgeFamilyCounts = new Map();
            for (const link of raw.links) {
                const family = link.family || 'Dependency';
                cache.edgeFamilyCounts.set(family, (cache.edgeFamilyCounts.get(family) || 0) + 1);
            }
        }
        return cache.edgeFamilyCounts;
    }

    function getEdgeRanges() {
        if (!cache.edgeRanges) {
            let minW = Infinity, maxW = -Infinity;
            let minC = Infinity, maxC = -Infinity;
            for (const link of raw.links) {
                const w = link.weight ?? 1;
                const c = link.confidence ?? 1;
                if (w < minW) minW = w;
                if (w > maxW) maxW = w;
                if (c < minC) minC = c;
                if (c > maxC) maxC = c;
            }
            cache.edgeRanges = {
                weight: { min: minW === Infinity ? 0 : minW, max: maxW === -Infinity ? 1 : maxW },
                confidence: { min: minC === Infinity ? 0 : minC, max: maxC === -Infinity ? 1 : maxC }
            };
        }
        return cache.edgeRanges;
    }

    // =========================================================================
    // SELF-TEST
    // =========================================================================

    function selfTest() {
        const errors = [];
        const warnings = [];
        const seenIds = new Set();

        for (const node of raw.nodes) {
            if (!node?.id) {
                errors.push('Node missing id');
                continue;
            }
            if (seenIds.has(node.id)) {
                errors.push(`Duplicate node id: ${node.id}`);
                continue;
            }
            seenIds.add(node.id);
        }

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');
            if (srcId && !index.nodeById.has(srcId)) {
                warnings.push(`Edge source not in graph: ${srcId}`);
            }
            if (tgtId && !index.nodeById.has(tgtId)) {
                warnings.push(`Edge target not in graph: ${tgtId}`);
            }
        }

        const status = errors.length === 0 ? 'PASS' : 'FAIL';
        const style = errors.length === 0
            ? 'color: #4ade80; font-weight: bold'
            : 'color: #f87171; font-weight: bold';

        console.log(`%c[DATA] Self-Test: ${status}`, style);
        console.log(`  Raw: ${raw.nodes.length} nodes, ${raw.links.length} edges`);
        console.log(`  Indexes: nodeById=${index.nodeById.size}, tiers=${index.nodesByTier.size}`);

        if (errors.length > 0) console.error('[DATA] Errors:', errors);
        if (warnings.length > 0) {
            console.warn('[DATA] Warnings:', warnings.slice(0, 5));
            if (warnings.length > 5) console.warn(`  ... and ${warnings.length - 5} more`);
        }

        return { errors, warnings, pass: errors.length === 0 };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Init
        init,

        // Raw data
        getNodes,
        getLinks,
        getFileBoundaries,
        getMarkov,
        getKpis,
        getMeta,
        getPhysics,
        getConfig,
        getAnalytics,

        // Indexed lookups
        getNode,
        getNodesByTier,
        getNodesByFamily,
        getNodesByRing,
        getNodesByLayer,
        getNodesByEffect,
        getNodesByFile,
        getEdgesFrom,
        getEdgesTo,
        getEdgeBetween,
        getFile,
        getTopMarkovEdges,
        isHighEntropyNode,

        // Filtered data
        setFiltered,
        getVisibleNodes,
        getVisibleLinks,

        // Aggregations
        getTierCounts,
        getFamilyCounts,
        getRingCounts,
        getLayerCounts,
        getEffectCounts,
        getEdgeTypeCounts,
        getEdgeFamilyCounts,
        getEdgeRanges,

        // Self-test
        selfTest,

        // Direct access (for migration)
        raw,
        index,
        cache,
        filtered,

        // Legend reference
        get legend() { return _legend; },

        // Color access (convenience)
        get color() { return COLOR; }
    };
})();

// Backward compatibility - DataManager class wrapper
class DataManager {
    constructor() {
        this.raw = DATA.raw;
        this.analytics = {};
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = null;
        this.color = COLOR;
    }

    init(data) {
        DATA.init(data);
        this.raw = DATA.raw;
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = DATA.legend;
        return this;
    }

    // Delegate all methods to DATA module
    getNodes() { return DATA.getNodes(); }
    getLinks() { return DATA.getLinks(); }
    getFileBoundaries() { return DATA.getFileBoundaries(); }
    getMarkov() { return DATA.getMarkov(); }
    getKpis() { return DATA.getKpis(); }
    getMeta() { return DATA.getMeta(); }
    getNode(id) { return DATA.getNode(id); }
    getNodesByTier(tier) { return DATA.getNodesByTier(tier); }
    getNodesByFamily(family) { return DATA.getNodesByFamily(family); }
    getNodesByRing(ring) { return DATA.getNodesByRing(ring); }
    getNodesByFile(fileIdx) { return DATA.getNodesByFile(fileIdx); }
    getEdgesFrom(nodeId) { return DATA.getEdgesFrom(nodeId); }
    getEdgesTo(nodeId) { return DATA.getEdgesTo(nodeId); }
    getEdgeBetween(srcId, tgtId) { return DATA.getEdgeBetween(srcId, tgtId); }
    getFile(idx) { return DATA.getFile(idx); }
    getTopMarkovEdges(nodeId, k) { return DATA.getTopMarkovEdges(nodeId, k); }
    isHighEntropyNode(nodeId) { return DATA.isHighEntropyNode(nodeId); }
    setFiltered(nodes, links) { DATA.setFiltered(nodes, links); }
    getVisibleNodes() { return DATA.getVisibleNodes(); }
    getVisibleLinks() { return DATA.getVisibleLinks(); }
    getTierCounts() { return DATA.getTierCounts(); }
    getFamilyCounts() { return DATA.getFamilyCounts(); }
    getRingCounts() { return DATA.getRingCounts(); }
    getLayerCounts() { return DATA.getLayerCounts(); }
    getEffectCounts() { return DATA.getEffectCounts(); }
    getEdgeTypeCounts() { return DATA.getEdgeTypeCounts(); }
    getEdgeFamilyCounts() { return DATA.getEdgeFamilyCounts(); }
    getEdgeRanges() { return DATA.getEdgeRanges(); }
    selfTest() { return DATA.selfTest(); }

    // Internal methods
    _buildAllIndexes() {}
    _buildNodeIndex() {}
    _buildSemanticIndexes() {}
    _buildEdgeIndexes() {}
    _buildFileIndex() {}
    _buildMarkovIndex() {}
    _invalidateCache() {}
    _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }
    _getNodeTier(node) { return NODE.getTier(node); }
    _getNodeFamily(node) { return NODE.getFamily(node); }
    _getNodeRing(node) { return NODE.getRing(node); }
    _getNodeLayer(node) { return NODE.getLayer(node); }
    _getNodeEffect(node) { return NODE.getEffect(node); }
}

// Global DM instance - defined by app.js (not duplicated here to avoid redeclaration)
// DM is accessed as a global variable provided by app.js

// Parity check function
function runDmParity(dm, data) {
    if (!dm) return;
    const checks = [];
    const rawNodes = Array.isArray(data?.nodes) ? data.nodes.length : 0;
    const rawEdges = Array.isArray(data?.links) ? data.links.length : 0;
    const dmNodes = dm.raw.nodes.length;
    const dmEdges = dm.raw.links.length;

    checks.push({ name: 'Node count', dm: dmNodes, old: rawNodes, pass: dmNodes === rawNodes });
    checks.push({ name: 'Edge count', dm: dmEdges, old: rawEdges, pass: dmEdges === rawEdges });
    checks.push({ name: 'Node index size', dm: dm.index.nodeById.size, old: rawNodes, pass: dm.index.nodeById.size === rawNodes });

    const allPass = checks.every(c => c.pass);
    const style = allPass ? 'color: #4ade80; font-weight: bold' : 'color: #f87171; font-weight: bold';
    console.log(`%c[DM Parity] ${allPass ? 'ALL PASS' : 'MISMATCH'}`, style);
    checks.forEach(c => {
        const icon = c.pass ? '✓' : '✗';
        console.log(`  ${icon} ${c.name}: DM=${c.dm}, Raw=${c.old}`);
    });
}


// ═══ MODULE: modules/vis-state.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VIS-STATE MODULE - Unified visualization state management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Single source of truth for visualization state. All controls funnel through
 * applyState() to ensure consistency.
 *
 * KEY DESIGN DECISIONS:
 * 1. Palette selection NEVER auto-switches colorBy mode
 * 2. Palette is "armed" - it applies when colorBy changes to interval mode
 * 3. Presets are macros that call applyState() with multiple properties
 * 4. syncUIFromState() updates all UI elements to match state
 *
 * @module VIS_STATE
 * @version 1.0.0
 */

window.VIS_STATE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CATEGORICAL vs INTERVAL MODE CLASSIFICATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Categorical modes use discrete color palettes (tier, family, atom...)
     * Interval modes use continuous gradients (complexity, fan_in, loc...)
     */
    const CATEGORICAL_MODES = new Set([
        'tier', 'family', 'atom', 'ring', 'layer', 'role', 'roleCategory',
        'subsystem', 'phase', 'fileType', 'file', 'state', 'visibility'
    ]);

    const INTERVAL_MODES = new Set([
        'complexity', 'loc', 'fan_in', 'fan_out', 'trust',
        'responsibility', 'purity', 'lifecycle_score', 'boundary_score',
        'centrality', 'rank', 'churn', 'age', 'depth'
    ]);

    function isIntervalMode(mode) {
        return INTERVAL_MODES.has(mode);
    }

    function isCategoricalMode(mode) {
        return CATEGORICAL_MODES.has(mode);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATE OBJECT - Single source of truth
    // ═══════════════════════════════════════════════════════════════════════

    const state = {
        colorBy: 'fan_in',         // Default to interval mode to show OKLCH schemes
        sizeBy: 'fanout',          // 'uniform', 'degree', 'fanout', 'complexity'
        edgeBy: 'type',            // 'type', 'resolution', 'weight', 'gradient-tier', etc.
        palette: 'helix',          // OKLCH helix path - visually striking default
        paletteType: 'interval'    // Derived: 'categorical' or 'interval'
    };

    // ═══════════════════════════════════════════════════════════════════════
    // VIEW PRESETS - Macros that set multiple properties at once
    // ═══════════════════════════════════════════════════════════════════════

    const VIEW_PRESETS = {
        tier: {
            label: 'Tier',
            description: 'T0/T1/T2 architectural height',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        family: {
            label: 'Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        layer: {
            label: 'Layer',
            description: 'Physical/Virtual/Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        ring: {
            label: 'Ring',
            description: 'Domain architecture rings',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        file: {
            label: 'File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        flow: {
            label: 'Flow',
            description: 'Markov transition probability',
            colorBy: 'fan_in',  // Use interval mode for flow
            sizeBy: 'degree',
            edgeBy: 'weight',
            special: 'flow'    // Triggers flow visualization
        }
    };

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY STATE - Central function all controls use
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply state changes. This is THE function all UI controls call.
     *
     * @param {Object} nextState - Partial state to merge
     * @param {string} reason - Debug label for console (e.g., 'preset:tier', 'control:colorBy')
     */
    function applyState(nextState, reason = 'unknown') {
        const prevColorBy = state.colorBy;
        const prevPalette = state.palette;

        // Merge new state
        if (nextState.colorBy !== undefined) state.colorBy = nextState.colorBy;
        if (nextState.sizeBy !== undefined) state.sizeBy = nextState.sizeBy;
        if (nextState.edgeBy !== undefined) state.edgeBy = nextState.edgeBy;
        if (nextState.palette !== undefined) state.palette = nextState.palette;

        // Derive paletteType from colorBy
        state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';

        console.log(`[VIS_STATE] applyState(${reason}):`, {
            colorBy: state.colorBy,
            sizeBy: state.sizeBy,
            edgeBy: state.edgeBy,
            palette: state.palette,
            paletteType: state.paletteType
        });

        // ─── Apply color mode ───
        if (nextState.colorBy !== undefined && nextState.colorBy !== prevColorBy) {
            _applyColorMode(state.colorBy);
        }

        // ─── Apply size mode ───
        if (nextState.sizeBy !== undefined) {
            _applySizeMode(state.sizeBy);
        }

        // ─── Apply edge mode ───
        if (nextState.edgeBy !== undefined) {
            _applyEdgeMode(state.edgeBy);
        }

        // ─── Apply palette (only if in interval mode) ───
        if (nextState.palette !== undefined || nextState.colorBy !== undefined) {
            _applyPalette();
        }

        // ─── Handle special modes (flow) ───
        if (nextState.special === 'flow') {
            _enableFlowMode();
        } else if (prevColorBy === 'flow' && nextState.colorBy !== 'flow') {
            _disableFlowMode();
        }

        // ─── Sync UI to match state ───
        syncUIFromState();

        // ─── Refresh visualization ───
        _refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INTERNAL APPLY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════

    function _applyColorMode(mode) {
        // Update globals for backward compatibility
        window.NODE_COLOR_MODE = mode;

        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.colorMode = mode;
            window.APPEARANCE_STATE.currentPreset = mode;
        }

        // Disable flow mode if switching away from flow
        if (mode !== 'flow' && typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _applySizeMode(mode) {
        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.sizeMode = mode;
        }

        if (typeof window.applyNodeSizeMode === 'function') {
            window.applyNodeSizeMode(mode);
        } else if (typeof window.NODE_HELPERS !== 'undefined') {
            window.NODE_HELPERS.applySizeMode(mode);
        }
    }

    function _applyEdgeMode(mode) {
        if (typeof window.EDGE_GRADIENT_MODE !== 'undefined') {
            // Edge gradient modes
            if (mode.startsWith('gradient-')) {
                window.EDGE_GRADIENT_MODE = mode.replace('gradient-', '');
            }
        }

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
    }

    function _applyPalette() {
        // Only apply scheme coloring if in interval mode
        if (state.paletteType === 'interval' && state.palette) {
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(state.palette);
            }
        } else {
            // In categorical mode, clear active scheme
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(null);
            }
        }
    }

    function _enableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && !window.flowMode) {
            if (typeof window.toggleFlowMode === 'function') {
                window.toggleFlowMode();
            }
        }
    }

    function _disableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _refreshGraph() {
        // Recompute node colors
        const DM = window.DM;
        const Graph = window.Graph;
        const nodes = DM ? DM.getNodes() : (Graph?.graphData ? Graph.graphData().nodes : []);

        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render with new function reference to force update
        if (Graph) {
            Graph.nodeColor(n => n.color);
        }

        // Refresh edge gradients
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        // Re-render legends
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SYNC UI FROM STATE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all UI elements to reflect current state.
     * Called after every applyState() and on initialization.
     */
    function syncUIFromState() {
        // ─── View Preset buttons ───
        document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
            const presetKey = btn.dataset.preset;
            const preset = VIEW_PRESETS[presetKey];
            const isActive = preset && preset.colorBy === state.colorBy;
            btn.classList.toggle('active', isActive);
        });

        // ─── Color Mode buttons (PRESET_CONFIG grid) ───
        document.querySelectorAll('.color-btn[data-preset]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.preset === state.colorBy);
        });

        // ─── Size Mode buttons ───
        document.querySelectorAll('[data-size-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.sizeMode === state.sizeBy);
        });

        // ─── Edge Mode buttons ───
        document.querySelectorAll('[data-edge-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.edgeMode === state.edgeBy);
        });

        // ─── Palette buttons ───
        document.querySelectorAll('.scheme-btn[data-scheme]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.scheme === state.palette);
        });

        // ─── Palette panel enabled/disabled state ───
        const schemesPanel = document.getElementById('section-schemes');
        if (schemesPanel) {
            const isDisabled = state.paletteType === 'categorical';
            schemesPanel.classList.toggle('disabled', isDisabled);

            // Update scheme buttons opacity/interactivity
            schemesPanel.querySelectorAll('.scheme-btn').forEach(btn => {
                btn.disabled = isDisabled;
                btn.style.opacity = isDisabled ? '0.4' : '1';
                btn.style.pointerEvents = isDisabled ? 'none' : 'auto';
            });

            // Show hint when disabled
            let hint = schemesPanel.querySelector('.scheme-hint');
            if (isDisabled) {
                if (!hint) {
                    hint = document.createElement('div');
                    hint.className = 'scheme-hint';
                    hint.style.cssText = 'padding: 8px; font-size: 10px; opacity: 0.6; text-align: center; font-style: italic;';
                    hint.textContent = 'Switch to a metric mode (Fan-In, Complexity, etc.) to enable color schemes';
                    schemesPanel.insertBefore(hint, schemesPanel.firstChild);
                }
            } else if (hint) {
                hint.remove();
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVENIENCE METHODS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply a view preset by name
     */
    function applyPreset(presetKey) {
        const preset = VIEW_PRESETS[presetKey];
        if (!preset) {
            console.warn('[VIS_STATE] Unknown preset:', presetKey);
            return;
        }

        applyState({
            colorBy: preset.colorBy,
            sizeBy: preset.sizeBy,
            edgeBy: preset.edgeBy,
            special: preset.special
        }, `preset:${presetKey}`);
    }

    /**
     * Set color mode only
     */
    function setColorBy(mode) {
        applyState({ colorBy: mode }, `colorBy:${mode}`);
    }

    /**
     * Set size mode only
     */
    function setSizeBy(mode) {
        applyState({ sizeBy: mode }, `sizeBy:${mode}`);
    }

    /**
     * Set edge mode only
     */
    function setEdgeBy(mode) {
        applyState({ edgeBy: mode }, `edgeBy:${mode}`);
    }

    /**
     * Set palette (arms the palette, applies if in interval mode)
     */
    function setPalette(schemeName) {
        applyState({ palette: schemeName }, `palette:${schemeName}`);
    }

    /**
     * Get current state (read-only copy)
     */
    function getState() {
        return { ...state };
    }

    /**
     * Initialize from saved preferences or defaults
     */
    function init() {
        try {
            const savedScheme = localStorage.getItem('collider_scheme');
            const savedColorMode = localStorage.getItem('collider_color_mode');

            if (savedScheme) state.palette = savedScheme;
            if (savedColorMode) state.colorBy = savedColorMode;

            state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';
        } catch (e) { /* ignore localStorage errors */ }

        // Apply initial state to globals (critical for NODE_COLOR_MODE)
        _applyColorMode(state.colorBy);
        _applyPalette();

        console.log('[VIS_STATE] Initialized:', state);
    }

    /**
     * Save current preferences
     */
    function savePreferences() {
        try {
            localStorage.setItem('collider_scheme', state.palette);
            localStorage.setItem('collider_color_mode', state.colorBy);
        } catch (e) { /* ignore */ }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // State access
        getState,
        isIntervalMode,
        isCategoricalMode,

        // Main API
        applyState,
        applyPreset,
        syncUIFromState,

        // Convenience setters
        setColorBy,
        setSizeBy,
        setEdgeBy,
        setPalette,

        // Lifecycle
        init,
        savePreferences,

        // Constants
        VIEW_PRESETS,
        CATEGORICAL_MODES,
        INTERVAL_MODES
    };
})();

console.log('[Module] VIS_STATE loaded - unified visualization state');


// ═══ MODULE: modules/ui-manager.js ═══
/**
 * @module ui-manager
 * @description Orchestrates the "One Dock" unified interface
 * @responsibility Manage sidebar, dock, modes, and filters UI
 * @depends_on vis-state, data-manager, refresh-throttle
 */

const UI_MANAGER = (function() {
    'use strict';

    // Private state
    let _data = null;
    let _initialized = false;

    /**
     * Initialize the UI Manager
     * @param {Object} data - Graph data object
     */
    function init(data) {
        _data = data;
        _setupSidebar();
        _setupDock();
        _setupModes();
        _populateFilters();
        _updateStatus();
        _initialized = true;
    }

    /**
     * Setup sidebar toggle and accordion behavior
     */
    function _setupSidebar() {
        const sidebar = document.getElementById('sidebar');
        const btnFilters = document.getElementById('btn-filters');
        const btnClose = document.getElementById('sidebar-close');

        const toggle = () => {
            sidebar.classList.toggle('open');
            _updateFilterBadge();
        };

        if (btnFilters) btnFilters.onclick = (e) => {
            e.stopPropagation();
            toggle();
        };
        if (btnClose) btnClose.onclick = () => sidebar.classList.remove('open');

        // Accordion Logic
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.onclick = () => {
                const accordion = header.parentElement;
                accordion.classList.toggle('open');
            };
        });
    }

    /**
     * Setup dock controls
     */
    function _setupDock() {
        // Reset Layout
        const btnReset = document.getElementById('btn-reset-layout');
        if (btnReset) btnReset.onclick = () => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.zoomToFit(1000);
            }
        };

        // Dimensions Toggle (2D/3D - stub)
        const btnDim = document.getElementById('btn-dimensions');
        if (btnDim) btnDim.onclick = () => {
            console.log("Dimension toggle requested");
        };

        // Report Button
        const btnReport = document.getElementById('btn-report');
        if (btnReport) btnReport.onclick = () => {
            const reportPanel = document.getElementById('report-panel');
            if (reportPanel) {
                const isHidden = reportPanel.style.display === 'none';
                reportPanel.style.display = isHidden ? 'block' : 'none';
                btnReport.classList.toggle('active', isHidden);
            }
        };
    }

    /**
     * Setup mode buttons (explore, files, flow)
     */
    function _setupModes() {
        const modes = ['explore', 'files', 'flow'];

        const setMode = (mode) => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.getElementById(`mode-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');

            document.querySelectorAll('.mode-control-group').forEach(g => g.style.display = 'none');
            const group = document.getElementById(`${mode}-controls`);
            if (group) group.style.display = 'flex';
        };

        modes.forEach(mode => {
            const btn = document.getElementById(`mode-${mode}`);
            if (btn) btn.onclick = () => setMode(mode);
        });

        // Files Sub-controls wiring
        const bindToggle = (id, onClick) => {
            const el = document.getElementById(id);
            if (el) el.onclick = (e) => {
                e.target.classList.toggle('active');
                if (onClick) onClick(e.target.classList.contains('active'));
            };
        };

        bindToggle('btn-file-hulls', (_active) => {
            // Toggle hull visibility
        });
    }

    /**
     * Populate filter chips for all categories
     */
    function _populateFilters() {
        if (!_data) return;

        // Helper: Create Filter Chips
        const createChips = (containerId, counts, activeSet) => {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            counts.forEach(([key, count]) => {
                const chip = document.createElement('div');
                const isActive = activeSet.has(key);
                chip.className = `filter-chip ${isActive ? 'active' : ''}`;
                chip.innerHTML = `${key} <span class="chip-count">${count}</span>`;
                chip.onclick = () => {
                    if (activeSet.has(key)) activeSet.delete(key);
                    else activeSet.add(key);

                    chip.classList.toggle('active');
                    _updateFilterBadge();
                    // Call refreshGraph if available
                    if (typeof refreshGraph === 'function') refreshGraph();
                };
                container.appendChild(chip);
            });

            const type = containerId.replace('filter-', '');
            const countEl = document.getElementById(`count-${type}`);
            if (countEl) countEl.innerText = activeSet.size;
        };

        // Get accessor functions
        const getNodeRing = typeof window.getNodeRing === 'function' ? window.getNodeRing :
            (typeof NODE !== 'undefined' ? NODE.getRing : (n => n.ring || 'Unknown'));
        const getNodeTier = typeof window.getNodeTier === 'function' ? window.getNodeTier :
            (typeof NODE !== 'undefined' ? NODE.getTier : (n => n.tier || 'Unknown'));
        const getNodeAtomFamily = typeof window.getNodeAtomFamily === 'function' ? window.getNodeAtomFamily :
            (typeof NODE !== 'undefined' ? NODE.getFamily : (n => n.atom_family || 'Unknown'));
        const normalizeRingValue = typeof window.normalizeRingValue === 'function' ? window.normalizeRingValue :
            (typeof NODE !== 'undefined' ? NODE.normalizeRing : (v => v));
        const collectCounts = typeof window.collectCounts === 'function' ? window.collectCounts :
            _defaultCollectCounts;

        // Get VIS_FILTERS
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set(), edges: new Set(), families: new Set() };

        // 1. LAYERS (Rings)
        const ringCounts = collectCounts(_data.nodes, getNodeRing);
        const rawRingDefaults = _data.controls?.filters?.rings || [];
        const ringDefaults = rawRingDefaults
            .map(v => normalizeRingValue(v))
            .filter(v => v !== null);

        if (VIS_FILTERS.rings.size === 0 && ringDefaults.length > 0) {
            const availableRings = new Set(ringCounts.map(([ring]) => ring));
            const matchedRings = ringDefaults.filter(r => availableRings.has(r));
            if (matchedRings.length > 0) {
                matchedRings.forEach(r => VIS_FILTERS.rings.add(r));
            } else {
                const familyCounts = collectCounts(_data.nodes, getNodeAtomFamily);
                const availableFamilies = new Set(familyCounts.map(([family]) => family));
                const matchedFamilies = ringDefaults.filter(f => availableFamilies.has(f));
                if (matchedFamilies.length > 0 && VIS_FILTERS.families.size === 0) {
                    matchedFamilies.forEach(f => VIS_FILTERS.families.add(f));
                    console.warn('[Filters] Ring defaults matched families; applying as family filters.');
                }
            }
        }
        createChips('filter-rings', ringCounts, VIS_FILTERS.rings);

        // 2. TIERS
        const tierCounts = collectCounts(_data.nodes, getNodeTier);
        createChips('filter-tiers', tierCounts, VIS_FILTERS.tiers);

        // 3. ROLES
        const roleCounts = collectCounts(_data.nodes, n => String(n.role || 'Unknown'));
        createChips('filter-roles', roleCounts, VIS_FILTERS.roles);

        // 4. EDGES
        const edgeCounts = collectCounts(_data.links, l => String(l.edge_type || l.type || 'default'));
        createChips('filter-edges', edgeCounts, VIS_FILTERS.edges);

        // 5. DATAMAPS
        _populateDatamaps();

        _updateFilterBadge();
    }

    /**
     * Default collectCounts implementation
     */
    function _defaultCollectCounts(items, accessor) {
        const counts = new Map();
        items.forEach(item => {
            const key = accessor(item);
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    /**
     * Populate datamap chips
     */
    function _populateDatamaps() {
        const container = document.getElementById('filter-datamaps');
        if (!container) return;
        container.innerHTML = '';

        const controls = _data.controls || {};
        const resolveDatamapConfigs = typeof window.resolveDatamapConfigs === 'function'
            ? window.resolveDatamapConfigs
            : () => [];
        const configs = resolveDatamapConfigs(controls);
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS || new Set();
        const setDatamap = typeof window.setDatamap === 'function' ? window.setDatamap : () => {};

        configs.forEach(cfg => {
            const chip = document.createElement('div');
            const isActive = ACTIVE_DATAMAPS.has(cfg.id);
            chip.className = `filter-chip ${isActive ? 'active' : ''}`;
            chip.style.width = '100%';
            chip.style.marginBottom = '4px';
            chip.innerHTML = `${cfg.label}`;

            chip.onclick = () => {
                setDatamap(cfg.id);
                Array.from(container.children).forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            };
            container.appendChild(chip);
        });

        const countEl = document.getElementById('count-datamaps');
        if (countEl) countEl.innerText = configs.length;
    }

    /**
     * Update filter badge count
     */
    function _updateFilterBadge() {
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set() };

        let total = 0;
        total += VIS_FILTERS.rings.size;
        total += VIS_FILTERS.tiers.size;
        total += VIS_FILTERS.roles.size;

        const badge = document.getElementById('filter-badge');
        const miniBadge = document.getElementById('filter-badge-mini');

        if (badge) badge.innerText = total;
        if (miniBadge) {
            miniBadge.innerText = total;
            miniBadge.classList.toggle('visible', total > 0);
        }

        const summary = document.getElementById('filter-summary');
        if (summary) {
            summary.innerText = total > 0 ? `${total} filters active` : "No filters active";
        }
    }

    /**
     * Update status display (node/edge counts)
     */
    function _updateStatus() {
        if (_data && _data.nodes) {
            const n = _data.nodes.length;
            const e = _data.links.length;
            const statusNodes = document.getElementById('status-nodes');
            const statusEdges = document.getElementById('status-edges');

            if (statusNodes) statusNodes.innerText = n;
            if (statusEdges) statusEdges.innerText = e;
        }
    }

    /**
     * Refresh filters (re-populate from current data)
     */
    function refreshFilters() {
        _populateFilters();
    }

    /**
     * Update badge count (public interface)
     */
    function updateFilterBadge() {
        _updateFilterBadge();
    }

    // Public API
    return {
        init,
        refreshFilters,
        updateFilterBadge,
        get data() { return _data; },
        get initialized() { return _initialized; }
    };
})();

// Backward compatibility - expose as UIManager
const UIManager = {
    data: null,
    init(data) {
        this.data = data;
        UI_MANAGER.init(data);
    },
    setupSidebar() { /* Now internal */ },
    setupDock() { /* Now internal */ },
    setupModes() { /* Now internal */ },
    populateFilters() { UI_MANAGER.refreshFilters(); },
    populateDatamaps() { UI_MANAGER.refreshFilters(); },
    updateFilterBadge() { UI_MANAGER.updateFilterBadge(); },
    updateStatus() { /* Now internal */ }
};

// Expose globally
window.UI_MANAGER = UI_MANAGER;
window.UIManager = UIManager;


// ═══ MODULE: modules/physics.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * PHYSICS MODULE - Force simulation controls
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Physics presets, sliders, and force parameter management.
 * Depends on: Graph, PHYSICS_STATE, PHYSICS_PRESETS (globals)
 *
 * @module PHYSICS
 * @version 1.0.0
 */

window.PHYSICS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS STATE
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsState() {
        const Graph = window.Graph;
        const PHYSICS_STATE = window.PHYSICS_STATE;
        if (!Graph) return;
        try {
            Graph.d3Force('charge')?.strength(PHYSICS_STATE.charge);
            Graph.d3Force('link')?.distance(PHYSICS_STATE.linkDistance);
            Graph.d3Force('center')?.strength(PHYSICS_STATE.centerStrength);
            Graph.d3VelocityDecay?.(PHYSICS_STATE.velocityDecay);
            Graph.d3ReheatSimulation();
        } catch (e) {
            console.warn('[Physics] Could not apply:', e.message);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS PRESET
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsPreset(presetName) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const preset = PHYSICS_PRESETS[presetName];
        if (!preset) return;
        Object.assign(PHYSICS_STATE, {
            charge: preset.charge,
            linkDistance: preset.linkDistance,
            centerStrength: preset.centerStrength,
            velocityDecay: preset.velocityDecay
        });
        applyPhysicsState();
        updatePhysicsSliders();
        window.showModeToast(`Physics: ${preset.label}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE PHYSICS SLIDERS
    // ═══════════════════════════════════════════════════════════════════════

    function updatePhysicsSliders() {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const sliders = {
            'physics-charge': PHYSICS_STATE.charge,
            'physics-link-distance': PHYSICS_STATE.linkDistance,
            'physics-center': PHYSICS_STATE.centerStrength,
            'physics-damping': PHYSICS_STATE.velocityDecay
        };
        for (const [id, value] of Object.entries(sliders)) {
            const input = document.getElementById(id);
            const display = document.getElementById(id + '-value');
            if (input) input.value = value;
            if (display) display.textContent = typeof value === 'number' && value % 1 !== 0 ? value.toFixed(2) : value;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // BUILD PHYSICS CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function buildPhysicsControls(containerId) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const container = document.getElementById(containerId);
        if (!container) return;

        // Preset buttons
        const presetRow = document.createElement('div');
        presetRow.className = 'physics-presets';
        presetRow.style.cssText = 'display:flex;gap:4px;margin-bottom:8px;flex-wrap:wrap;';
        Object.entries(PHYSICS_PRESETS).forEach(([key, preset]) => {
            const btn = document.createElement('button');
            btn.className = 'preset-btn physics-preset-btn';
            btn.textContent = preset.label;
            btn.style.cssText = 'font-size:9px;padding:2px 6px;';
            btn.onclick = () => applyPhysicsPreset(key);
            presetRow.appendChild(btn);
        });
        container.appendChild(presetRow);

        // Sliders
        const sliderDefs = [
            {
                id: 'physics-charge',
                label: 'REPULSION',
                min: -500,
                max: 50,
                step: 10,
                value: PHYSICS_STATE.charge,
                onChange: (val) => { PHYSICS_STATE.charge = val; applyPhysicsState(); }
            },
            {
                id: 'physics-link-distance',
                label: 'LINK DIST',
                min: 10,
                max: 200,
                step: 5,
                value: PHYSICS_STATE.linkDistance,
                onChange: (val) => { PHYSICS_STATE.linkDistance = val; applyPhysicsState(); }
            },
            {
                id: 'physics-center',
                label: 'CENTER PULL',
                min: 0,
                max: 0.3,
                step: 0.01,
                value: PHYSICS_STATE.centerStrength,
                onChange: (val) => { PHYSICS_STATE.centerStrength = val; applyPhysicsState(); }
            },
            {
                id: 'physics-damping',
                label: 'DAMPING',
                min: 0,
                max: 1,
                step: 0.05,
                value: PHYSICS_STATE.velocityDecay,
                onChange: (val) => { PHYSICS_STATE.velocityDecay = val; applyPhysicsState(); }
            }
        ];

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row';

            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            valueDisplay.textContent = def.step < 1 ? def.value.toFixed(2) : def.value;
            header.appendChild(label);
            header.appendChild(valueDisplay);

            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = def.value;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = def.step < 1 ? val.toFixed(2) : val;
                def.onChange(val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);
            container.appendChild(wrapper);
        });

        console.log('[Physics] Controls initialized');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        applyState: applyPhysicsState,
        applyPreset: applyPhysicsPreset,
        updateSliders: updatePhysicsSliders,
        buildControls: buildPhysicsControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.applyPhysicsState = PHYSICS.applyState;
window.applyPhysicsPreset = PHYSICS.applyPreset;
window.updatePhysicsSliders = PHYSICS.updateSliders;
window.buildPhysicsControls = PHYSICS.buildControls;

console.log('[Module] PHYSICS loaded - 4 functions');


// ═══ MODULE: modules/datamap.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DATAMAP MODULE - Data mapping and filtering
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Datamap configuration, matching, and UI control updates.
 * Depends on: DM, VIS_FILTERS, ACTIVE_DATAMAPS, NODE (node-accessors)
 *
 * @module DATAMAP
 * @version 1.0.0
 */

window.DATAMAP = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NORMALIZE DATAMAP CONFIG
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeDatamapConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const id = String(raw.id || raw.key || raw.label || '').trim();
        if (!id) return null;
        const normalizeList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => String(item).toUpperCase());
        };
        const normalizeTierList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => window.normalizeTier(item));
        };
        const match = raw.match || {};
        return {
            id: id.toUpperCase(),
            label: String(raw.label || raw.id || id).toUpperCase(),
            match: {
                atom_families: normalizeList(match.atom_families),
                atom_prefixes: normalizeList(match.atom_prefixes),
                tiers: normalizeTierList(match.tiers),
                rings: normalizeList(match.rings),
                roles: normalizeList(match.roles)
            },
            default: Boolean(raw.default)
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // RESOLVE DATAMAP CONFIGS
    // ═══════════════════════════════════════════════════════════════════════

    function resolveDatamapConfigs(controlsConfig) {
        const fromTokens = Array.isArray(controlsConfig.datamaps) ? controlsConfig.datamaps : [];
        const normalized = fromTokens
            .map(normalizeDatamapConfig)
            .filter(Boolean);
        if (normalized.length) return normalized;

        const fallback = controlsConfig.buttons?.datamaps || {};
        return Object.entries(fallback).map(([label, config]) => {
            const prefix = config.filter || null;
            return normalizeDatamapConfig({
                id: label.toUpperCase(),
                label: label.toUpperCase(),
                match: prefix ? { atom_prefixes: [prefix] } : {},
                default: false
            });
        }).filter(Boolean);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP MATCHING
    // ═══════════════════════════════════════════════════════════════════════

    function datamapMatches(node, config) {
        const match = config.match || {};
        const atomId = String(node.atom || '');
        const atomFamily = window.getNodeAtomFamily(node);
        const tier = window.getNodeTier(node);
        const ring = window.getNodeRing(node);
        const role = String(node.role || 'Unknown').toUpperCase();

        if (Array.isArray(match.atom_families) && match.atom_families.length) {
            if (!match.atom_families.includes(atomFamily)) return false;
        }

        if (Array.isArray(match.atom_prefixes) && match.atom_prefixes.length) {
            const matchesFamily = match.atom_prefixes.includes(atomFamily);
            const matchesPrefix = match.atom_prefixes.some(prefix => atomId.startsWith(prefix));
            if (!matchesFamily && !matchesPrefix) return false;
        }

        if (Array.isArray(match.tiers) && match.tiers.length) {
            if (!match.tiers.includes(tier)) return false;
        }

        if (Array.isArray(match.rings) && match.rings.length) {
            if (!match.rings.includes(ring)) return false;
        }

        if (Array.isArray(match.roles) && match.roles.length) {
            if (!match.roles.includes(role)) return false;
        }
        return true;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET DATAMAP
    // ═══════════════════════════════════════════════════════════════════════

    function setDatamap(prefix) {
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const nextSet = new Set(ACTIVE_DATAMAPS);
        if (!prefix) {
            nextSet.clear();
        } else if (nextSet.has(prefix)) {
            nextSet.delete(prefix);
        } else {
            nextSet.add(prefix);
        }

        if (!window.DM) {
            window.ACTIVE_DATAMAPS = nextSet;
            updateDatamapControls();
            return;
        }

        const subset = window.filterGraph(null, window.CURRENT_DENSITY, nextSet, window.VIS_FILTERS);
        if (!subset.nodes.length) {
            window.showToast('No nodes for that datamap selection.');
            updateDatamapControls();
            return;
        }

        window.ACTIVE_DATAMAPS = nextSet;
        updateDatamapControls();
        window.refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET NODE COLOR MODE
    // ═══════════════════════════════════════════════════════════════════════

    function setNodeColorMode(mode) {
        window.NODE_COLOR_MODE = mode;
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
        window.refreshGraph();
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY DATAMAP (ALIAS)
    // ═══════════════════════════════════════════════════════════════════════

    function applyDatamap(prefix) {
        setDatamap(prefix);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE DATAMAP CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function updateDatamapControls() {
        const DM = window.DM;
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const DATAMAP_UI = window.DATAMAP_UI;
        const DATAMAP_CONFIGS = window.DATAMAP_CONFIGS;
        const GRAPH_MODE = window.GRAPH_MODE;
        const VIS_FILTERS = window.VIS_FILTERS;

        if (!DM) return;
        const datamapEnabled = GRAPH_MODE === 'atoms';
        const base = window.filterGraph(null, window.CURRENT_DENSITY, new Set(), VIS_FILTERS);
        const nodes = base.nodes || [];
        const totalCount = nodes.length;

        const allUI = DATAMAP_UI.get('__ALL__');
        if (allUI) {
            allUI.input.checked = ACTIVE_DATAMAPS.size === 0;
            if (allUI.count) {
                allUI.count.textContent = datamapEnabled ? String(totalCount) : '--';
            }
            allUI.input.disabled = !datamapEnabled;
            allUI.wrapper.classList.toggle('disabled', !datamapEnabled);
            allUI.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.size === 0);
        }

        DATAMAP_CONFIGS.forEach((config) => {
            const count = nodes.reduce((acc, node) => acc + (datamapMatches(node, config) ? 1 : 0), 0);
            const ui = DATAMAP_UI.get(config.id);
            if (!ui) return;
            if (ui.count) {
                ui.count.textContent = datamapEnabled ? String(count) : '--';
            }
            ui.input.disabled = !datamapEnabled || count === 0;
            ui.wrapper.classList.toggle('disabled', !datamapEnabled || count === 0);
            ui.input.checked = ACTIVE_DATAMAPS.has(config.id);
            ui.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.has(config.id));
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        normalizeConfig: normalizeDatamapConfig,
        resolveConfigs: resolveDatamapConfigs,
        matches: datamapMatches,
        set: setDatamap,
        setColorMode: setNodeColorMode,
        apply: applyDatamap,
        updateControls: updateDatamapControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.normalizeDatamapConfig = DATAMAP.normalizeConfig;
window.resolveDatamapConfigs = DATAMAP.resolveConfigs;
window.datamapMatches = DATAMAP.matches;
window.setDatamap = DATAMAP.set;
window.setNodeColorMode = DATAMAP.setColorMode;
window.applyDatamap = DATAMAP.apply;
window.updateDatamapControls = DATAMAP.updateControls;

console.log('[Module] DATAMAP loaded - 7 functions');


// ═══ MODULE: modules/groups.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * GROUPS MODULE - Node grouping functionality
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Group creation, storage, rendering, and management.
 * Depends on: GROUPS, ACTIVE_GROUP_ID, SELECTED_NODE_IDS, GROUPS_STORAGE_KEY
 *
 * @module GROUPS_MODULE
 * @version 1.0.0
 */

window.GROUPS_MODULE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    function loadGroups() {
        window.GROUPS = [];
        try {
            const stored = localStorage.getItem(window.GROUPS_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    window.GROUPS = parsed;
                }
            }
        } catch (e) {
            // localStorage unavailable
        }
        window.GROUPS = window.GROUPS.filter(group => group && group.id && Array.isArray(group.node_ids));
        window.GROUPS.forEach(group => {
            if (group.visible === undefined) group.visible = true;
        });
    }

    function saveGroups() {
        try {
            localStorage.setItem(window.GROUPS_STORAGE_KEY, JSON.stringify(window.GROUPS));
        } catch (e) {
            // localStorage unavailable
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNextGroupColor() {
        const hue = (window.GROUPS.length * 137.5) % 360;
        return window.hslColor(hue, 65, 55);
    }

    function getGroupById(groupId) {
        return window.GROUPS.find(group => group.id === groupId) || null;
    }

    function getPrimaryGroupForNode(nodeId) {
        const visibleGroups = window.GROUPS.filter(group =>
            group.visible !== false && Array.isArray(group.node_ids) && group.node_ids.includes(nodeId)
        );
        if (!visibleGroups.length) return null;
        if (window.ACTIVE_GROUP_ID) {
            const active = visibleGroups.find(group => group.id === window.ACTIVE_GROUP_ID);
            if (active) return active;
        }
        return visibleGroups[0];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP LIST RENDERING
    // ═══════════════════════════════════════════════════════════════════════

    function renderGroupList() {
        const container = document.getElementById('group-list');
        if (!container) return;
        container.innerHTML = '';

        if (!window.GROUPS.length) {
            const empty = document.createElement('div');
            empty.style.fontSize = '9px';
            empty.style.color = 'rgba(255,255,255,0.4)';
            empty.textContent = 'No groups yet';
            container.appendChild(empty);
            return;
        }

        window.GROUPS.forEach(group => {
            const row = document.createElement('div');
            row.className = 'group-item';
            row.classList.toggle('active', group.id === window.ACTIVE_GROUP_ID);

            const dot = document.createElement('span');
            dot.className = 'group-color';
            dot.style.background = group.color || '#6fe8ff';

            const name = document.createElement('span');
            name.className = 'group-name';
            name.textContent = group.name || 'Group';

            const count = document.createElement('span');
            count.className = 'group-count';
            count.textContent = String((group.node_ids || []).length);

            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.className = 'group-toggle';
            toggle.checked = group.visible !== false;
            toggle.onchange = (e) => {
                e.stopPropagation();
                group.visible = toggle.checked;
                saveGroups();
                window.updateSelectionVisuals();
                renderGroupList();
            };

            row.onclick = (e) => {
                if (e.target === toggle) return;
                window.ACTIVE_GROUP_ID = group.id;
                renderGroupList();
                window.setSelection(group.node_ids || []);
                window.updateSelectionVisuals();
            };

            row.appendChild(dot);
            row.appendChild(name);
            row.appendChild(count);
            row.appendChild(toggle);
            container.appendChild(row);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP BUTTON STATE
    // ═══════════════════════════════════════════════════════════════════════

    function updateGroupButtonState() {
        const btn = document.getElementById('btn-create-group');
        if (!btn) return;
        const hasSelection = window.SELECTED_NODE_IDS.size > 0;
        btn.classList.toggle('disabled', !hasSelection);
        btn.disabled = !hasSelection;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CREATE GROUP FROM SELECTION
    // ═══════════════════════════════════════════════════════════════════════

    function createGroupFromSelection() {
        if (window.SELECTED_NODE_IDS.size === 0) return;
        const nodeIds = Array.from(window.SELECTED_NODE_IDS);
        const groupId = `group_${Date.now().toString(36)}`;
        const groupName = `Group ${window.GROUPS.length + 1}`;
        const groupColor = getNextGroupColor();
        window.GROUPS.push({
            id: groupId,
            name: groupName,
            color: groupColor,
            node_ids: nodeIds,
            visible: true
        });
        window.ACTIVE_GROUP_ID = groupId;
        saveGroups();
        renderGroupList();
        window.updateSelectionVisuals();
        window.showToast(`Created ${groupName} (${nodeIds.length})`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        load: loadGroups,
        save: saveGroups,
        getNextColor: getNextGroupColor,
        getById: getGroupById,
        getPrimaryForNode: getPrimaryGroupForNode,
        renderList: renderGroupList,
        updateButtonState: updateGroupButtonState,
        createFromSelection: createGroupFromSelection
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.loadGroups = GROUPS_MODULE.load;
window.saveGroups = GROUPS_MODULE.save;
window.getNextGroupColor = GROUPS_MODULE.getNextColor;
window.getGroupById = GROUPS_MODULE.getById;
window.getPrimaryGroupForNode = GROUPS_MODULE.getPrimaryForNode;
window.renderGroupList = GROUPS_MODULE.renderList;
window.updateGroupButtonState = GROUPS_MODULE.updateButtonState;
window.createGroupFromSelection = GROUPS_MODULE.createFromSelection;

console.log('[Module] GROUPS_MODULE loaded - 8 functions');


// ═══ MODULE: modules/hover.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HOVER MODULE - Node hover and click interactions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node hover panel updates, click handling, and interaction management.
 * Depends on: HOVERED_NODE, VIS_FILTERS, GRAPH_MODE, DM, Graph
 *
 * @module HOVER
 * @version 1.0.0
 */

window.HOVER = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE HOVER PANEL
    // ═══════════════════════════════════════════════════════════════════════

    function updateHoverPanel(node) {
        const hoverPanel = document.getElementById('hover-panel');
        const placeholder = document.getElementById('hover-placeholder');
        if (!hoverPanel) return;

        if (!node) {
            hoverPanel.classList.remove('has-node');
            if (placeholder) placeholder.style.display = '';
            return;
        }

        hoverPanel.classList.add('has-node');
        if (placeholder) placeholder.style.display = 'none';

        // Helper to set element text safely
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val ?? '--';
        };

        // Basic info
        setEl('hover-name', node.label || node.id || 'Unknown');
        setEl('hover-type', node.type || node.kind || '--');
        setEl('hover-file', node.file_path || '--');

        // Tier/Ring/Family
        setEl('hover-tier', window.getNodeTier ? window.getNodeTier(node) : (node.tier || '--'));
        setEl('hover-ring', window.getNodeRing ? window.getNodeRing(node) : (node.ring || '--'));
        setEl('hover-family', window.getNodeAtomFamily ? window.getNodeAtomFamily(node) : (node.atom_family || '--'));

        // Metrics
        setEl('hover-complexity', node.complexity ?? '--');
        setEl('hover-loc', node.lines_of_code ?? node.loc ?? '--');
        setEl('hover-fanin', node.in_degree ?? '--');
        setEl('hover-fanout', node.out_degree ?? '--');

        // Role
        setEl('hover-role', node.role || '--');

        // Code preview (if available)
        const codeEl = document.getElementById('hover-code');
        if (codeEl) {
            const code = node.body_source || node.body || '';
            codeEl.textContent = code ? code.substring(0, 500) : '// no source';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE HOVER
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeHover(node, data) {
        const filePanel = document.getElementById('file-panel');
        window.HOVERED_NODE = node || null;

        // Always update hover panel
        updateHoverPanel(node);

        // Guard: file-panel may not exist
        if (!filePanel) return;

        const VIS_FILTERS = window.VIS_FILTERS;
        if (!VIS_FILTERS.metadata.showFilePanel) {
            filePanel.classList.remove('visible');
            return;
        }

        if (!node) {
            setTimeout(() => {
                if (!window.fileMode) filePanel.classList.remove('visible');
            }, 300);
            return;
        }

        // Get file info from boundaries
        const boundaries = data.file_boundaries || [];
        const fileIdx = node.fileIdx;

        if (fileIdx < 0 || fileIdx >= boundaries.length) {
            return;
        }

        const fileInfo = boundaries[fileIdx];

        // Update panel content
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        };
        setEl('file-name', fileInfo.file_name || 'unknown');
        setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
        setEl('file-purpose', fileInfo.purpose || '--');
        setEl('file-atom-count', fileInfo.atom_count || 0);
        setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
        setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
        setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

        // Code preview from node body
        const code = node.body || '// no source available';
        setEl('file-code', code);

        // Show panel
        filePanel.classList.add('visible');
        if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE CLICK
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeClick(node, event) {
        if (!node) return;
        const additive = event && event.shiftKey;
        if (additive) {
            window.toggleSelection(node);
            return;
        }
        if (node.id) {
            window.setSelection([node.id]);
        }
        const GRAPH_MODE = window.GRAPH_MODE;
        if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
            window.toggleFileExpand(node.fileIdx);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updatePanel: updateHoverPanel,
        onNodeHover: handleNodeHover,
        onNodeClick: handleNodeClick
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateHoverPanel = HOVER.updatePanel;
window.handleNodeHover = HOVER.onNodeHover;
window.handleNodeClick = HOVER.onNodeClick;

console.log('[Module] HOVER loaded - 3 functions');


// ═══ MODULE: modules/flow.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * FLOW MODULE - Flow visualization mode with presets
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Flow mode highlights high-entropy nodes and edge transition probabilities.
 * Cycles through visual presets (EMBER, OCEAN, PLASMA, MATRIX, PULSE, AURORA).
 * Depends on: Graph, DM, THEME_CONFIG, APPEARANCE_CONFIG, FLOW_CONFIG
 *
 * @module FLOW
 * @version 1.0.0
 */

window.FLOW = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // PRESET COLOR/VALUE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getFlowPresetColor(presetName, property, fallback) {
        const schemes = (window.THEME_CONFIG && window.THEME_CONFIG.colors && window.THEME_CONFIG.colors.schemes) || {};
        const scheme = schemes[presetName.toLowerCase()] || {};
        return scheme[property] || fallback;
    }

    function getFlowPresetValue(presetName, property, fallback) {
        const presets = (typeof window.APPEARANCE_CONFIG !== 'undefined' && window.APPEARANCE_CONFIG && window.APPEARANCE_CONFIG['flow-presets']) || {};
        const preset = presets[presetName.toLowerCase()] || {};
        const value = preset[property];
        return (value !== undefined && value !== null) ? value : fallback;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FLOW PRESETS
    // ═══════════════════════════════════════════════════════════════════════

    const PRESETS = [
        {
            name: 'EMBER',
            highlightColor: getFlowPresetColor('EMBER', 'highlightColor', getFlowPresetValue('ember', 'highlightColor', '#ff8c00')),
            particleColor: getFlowPresetColor('EMBER', 'particleColor', getFlowPresetValue('ember', 'particleColor', '#ffaa00')),
            dimColor: getFlowPresetColor('EMBER', 'dimColor', getFlowPresetValue('ember', 'dimColor', '#331100')),
            edgeColor: getFlowPresetColor('EMBER', 'edgeColor', getFlowPresetValue('ember', 'edgeColor', '#ff6600')),
            particleCount: getFlowPresetValue('ember', 'particleCount', 3),
            particleWidth: getFlowPresetValue('ember', 'particleWidth', 2.5),
            particleSpeed: getFlowPresetValue('ember', 'particleSpeed', 0.008),
            edgeWidthScale: getFlowPresetValue('ember', 'edgeWidthScale', 3.0),
            sizeMultiplier: getFlowPresetValue('ember', 'sizeMultiplier', 1.8),
            edgeOpacityMin: getFlowPresetValue('ember', 'edgeOpacityMin', 0.3),
            dimOpacity: getFlowPresetValue('ember', 'dimOpacity', 0.05)
        },
        {
            name: 'OCEAN',
            highlightColor: getFlowPresetColor('OCEAN', 'highlightColor', getFlowPresetValue('ocean', 'highlightColor', '#00d4ff')),
            particleColor: getFlowPresetColor('OCEAN', 'particleColor', getFlowPresetValue('ocean', 'particleColor', '#4df0ff')),
            dimColor: getFlowPresetColor('OCEAN', 'dimColor', getFlowPresetValue('ocean', 'dimColor', '#001122')),
            edgeColor: getFlowPresetColor('OCEAN', 'edgeColor', getFlowPresetValue('ocean', 'edgeColor', '#0088cc')),
            particleCount: getFlowPresetValue('ocean', 'particleCount', 4),
            particleWidth: getFlowPresetValue('ocean', 'particleWidth', 2.0),
            particleSpeed: getFlowPresetValue('ocean', 'particleSpeed', 0.006),
            edgeWidthScale: getFlowPresetValue('ocean', 'edgeWidthScale', 2.5),
            sizeMultiplier: getFlowPresetValue('ocean', 'sizeMultiplier', 1.6),
            edgeOpacityMin: getFlowPresetValue('ocean', 'edgeOpacityMin', 0.25),
            dimOpacity: getFlowPresetValue('ocean', 'dimOpacity', 0.03)
        },
        {
            name: 'PLASMA',
            highlightColor: getFlowPresetColor('PLASMA', 'highlightColor', getFlowPresetValue('plasma', 'highlightColor', '#ff00ff')),
            particleColor: getFlowPresetColor('PLASMA', 'particleColor', getFlowPresetValue('plasma', 'particleColor', '#ff66ff')),
            dimColor: getFlowPresetColor('PLASMA', 'dimColor', getFlowPresetValue('plasma', 'dimColor', '#110011')),
            edgeColor: getFlowPresetColor('PLASMA', 'edgeColor', getFlowPresetValue('plasma', 'edgeColor', '#cc00cc')),
            particleCount: getFlowPresetValue('plasma', 'particleCount', 5),
            particleWidth: getFlowPresetValue('plasma', 'particleWidth', 3.0),
            particleSpeed: getFlowPresetValue('plasma', 'particleSpeed', 0.012),
            edgeWidthScale: getFlowPresetValue('plasma', 'edgeWidthScale', 4.0),
            sizeMultiplier: getFlowPresetValue('plasma', 'sizeMultiplier', 2.0),
            edgeOpacityMin: getFlowPresetValue('plasma', 'edgeOpacityMin', 0.35),
            dimOpacity: getFlowPresetValue('plasma', 'dimOpacity', 0.04)
        },
        {
            name: 'MATRIX',
            highlightColor: getFlowPresetColor('MATRIX', 'highlightColor', getFlowPresetValue('matrix', 'highlightColor', '#00ff00')),
            particleColor: getFlowPresetColor('MATRIX', 'particleColor', getFlowPresetValue('matrix', 'particleColor', '#88ff88')),
            dimColor: getFlowPresetColor('MATRIX', 'dimColor', getFlowPresetValue('matrix', 'dimColor', '#001100')),
            edgeColor: getFlowPresetColor('MATRIX', 'edgeColor', getFlowPresetValue('matrix', 'edgeColor', '#00cc00')),
            particleCount: getFlowPresetValue('matrix', 'particleCount', 6),
            particleWidth: getFlowPresetValue('matrix', 'particleWidth', 1.5),
            particleSpeed: getFlowPresetValue('matrix', 'particleSpeed', 0.015),
            edgeWidthScale: getFlowPresetValue('matrix', 'edgeWidthScale', 2.0),
            sizeMultiplier: getFlowPresetValue('matrix', 'sizeMultiplier', 1.4),
            edgeOpacityMin: getFlowPresetValue('matrix', 'edgeOpacityMin', 0.2),
            dimOpacity: getFlowPresetValue('matrix', 'dimOpacity', 0.02)
        },
        {
            name: 'PULSE',
            highlightColor: getFlowPresetColor('PULSE', 'highlightColor', getFlowPresetValue('pulse', 'highlightColor', '#ff4444')),
            particleColor: getFlowPresetColor('PULSE', 'particleColor', getFlowPresetValue('pulse', 'particleColor', '#ff8888')),
            dimColor: getFlowPresetColor('PULSE', 'dimColor', getFlowPresetValue('pulse', 'dimColor', '#110000')),
            edgeColor: getFlowPresetColor('PULSE', 'edgeColor', getFlowPresetValue('pulse', 'edgeColor', '#cc2222')),
            particleCount: getFlowPresetValue('pulse', 'particleCount', 2),
            particleWidth: getFlowPresetValue('pulse', 'particleWidth', 4.0),
            particleSpeed: getFlowPresetValue('pulse', 'particleSpeed', 0.004),
            edgeWidthScale: getFlowPresetValue('pulse', 'edgeWidthScale', 5.0),
            sizeMultiplier: getFlowPresetValue('pulse', 'sizeMultiplier', 2.2),
            edgeOpacityMin: getFlowPresetValue('pulse', 'edgeOpacityMin', 0.4),
            dimOpacity: getFlowPresetValue('pulse', 'dimOpacity', 0.06)
        },
        {
            name: 'AURORA',
            highlightColor: getFlowPresetColor('AURORA', 'highlightColor', getFlowPresetValue('aurora', 'highlightColor', '#33ccbb')),
            particleColor: getFlowPresetColor('AURORA', 'particleColor', getFlowPresetValue('aurora', 'particleColor', '#66ffee')),
            dimColor: getFlowPresetColor('AURORA', 'dimColor', getFlowPresetValue('aurora', 'dimColor', '#002222')),
            edgeColor: getFlowPresetColor('AURORA', 'edgeColor', getFlowPresetValue('aurora', 'edgeColor', '#22aa99')),
            particleCount: getFlowPresetValue('aurora', 'particleCount', 4),
            particleWidth: getFlowPresetValue('aurora', 'particleWidth', 2.2),
            particleSpeed: getFlowPresetValue('aurora', 'particleSpeed', 0.007),
            edgeWidthScale: getFlowPresetValue('aurora', 'edgeWidthScale', 3.5),
            sizeMultiplier: getFlowPresetValue('aurora', 'sizeMultiplier', 1.7),
            edgeOpacityMin: getFlowPresetValue('aurora', 'edgeOpacityMin', 0.28),
            dimOpacity: getFlowPresetValue('aurora', 'dimOpacity', 0.04)
        }
    ];

    let currentPresetIndex = 0;

    // ═══════════════════════════════════════════════════════════════════════
    // TOGGLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function toggle() {
        const flowMode = window.flowMode;

        // If already in flow mode, cycle to next preset
        if (flowMode) {
            currentPresetIndex = (currentPresetIndex + 1) % PRESETS.length;
            const preset = PRESETS[currentPresetIndex];
            console.log(`[Flow] Cycling to preset: ${preset.name}`);
            applyVisualization();
            window.showModeToast(`FLOW: ${preset.name}`);
            return;
        }

        window.flowMode = true;
        currentPresetIndex = 0;
        console.log('[Flow] Toggled to:', window.flowMode);

        // Sync BOTH potential buttons (Dock vs CommandBar)
        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.toggle('active', window.flowMode);

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.toggle('active', window.flowMode);

        // Show/hide flow legend
        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.toggle('visible', window.flowMode);

        // EXCLUSIVE MODE: Clear other visual noise
        if (typeof window.clearAllFileModes === 'function') {
            window.clearAllFileModes();
        }
        // Ensure standard file/hull buttons are off
        document.querySelectorAll('.file-mode-btn').forEach(b => b.classList.remove('active'));

        applyVisualization();
        const preset = PRESETS[currentPresetIndex];
        window.showModeToast(`FLOW: ${preset.name}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DISABLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function disable() {
        if (!window.flowMode) return;
        window.flowMode = false;
        currentPresetIndex = 0;

        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.remove('active');

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.remove('active');

        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.remove('visible');

        clearVisualization();
        window.showModeToast('Flow mode off');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyVisualization() {
        const Graph = window.Graph;
        const DM = window.DM;

        // Guard: Ensure Graph is ready
        if (!Graph || !DM) {
            console.warn('[Flow] Graph or DM not ready');
            return;
        }

        // Get current preset settings
        const preset = PRESETS[currentPresetIndex];
        const markov = DM.getMarkov ? DM.getMarkov() : {};
        const highEntropy = markov.high_entropy_nodes || [];

        // Use preset values (fallback to FLOW_CONFIG for topK/minWeight if not in preset)
        const flowCfg = window.FLOW_CONFIG || {};
        const highlightColor = preset.highlightColor;
        const particleColor = preset.particleColor;
        const sizeMult = preset.sizeMultiplier;
        const edgeScale = preset.edgeWidthScale;
        const particleCount = preset.particleCount;
        const particleWidth = preset.particleWidth;
        const particleSpeed = preset.particleSpeed;
        const edgeOpacityMin = preset.edgeOpacityMin;
        const dimOpacity = preset.dimOpacity;
        const topK = flowCfg.topKEdges || 3;
        const minWeight = flowCfg.minWeight || 0.01;

        // Build set of high entropy node names
        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();
        highEntropy.forEach(n => highEntropyNodes.add(n.node));
        window.highEntropyNodes = highEntropyNodes;

        const graphNodes = Graph.graphData().nodes;
        const graphLinks = Graph.graphData().links;

        // THRESHOLDING: Build a map of top-K outgoing edges per source node
        const edgesBySource = new Map();
        graphLinks.forEach(link => {
            const srcId = typeof link.source === 'object' ? link.source.id : link.source;
            if (!edgesBySource.has(srcId)) {
                edgesBySource.set(srcId, []);
            }
            edgesBySource.get(srcId).push(link);
        });

        // For each source, keep only top-K by markov_weight (transition probability)
        const visibleEdges = new Set();
        edgesBySource.forEach((edges, srcId) => {
            const sorted = edges
                .filter(e => (e.markov_weight || 0) >= minWeight)
                .sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0))
                .slice(0, topK);
            sorted.forEach(e => visibleEdges.add(e));
        });

        // Store original colors and sizes, then apply flow coloring
        const originalNodeColors = window.originalNodeColors || new Map();
        window.originalNodeColors = originalNodeColors;

        graphNodes.forEach(node => {
            if (!originalNodeColors.has(node.id)) {
                originalNodeColors.set(node.id, node.color);
            }
            // Restore original size first (in case switching presets)
            if (node._originalVal) {
                node.val = node._originalVal;
            } else {
                node._originalVal = node.val || 1;
            }
            // High entropy nodes highlighted (decision points)
            if (highEntropyNodes.has(node.name)) {
                node.color = highlightColor;
                node.val = node._originalVal * sizeMult;
            }
        });

        // Update link widths based on markov_weight (with amplification)
        const maxMarkov = Math.max(0.001, ...graphLinks.map(l => l.markov_weight || 0));
        const amplify = window.amplify || (x => x);

        Graph.linkWidth(link => {
            if (!visibleEdges.has(link)) return 0.1;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return 0.5 + amplified * edgeScale * 2;
        });

        // Update link opacity to emphasize important edges
        Graph.linkOpacity(link => {
            if (!visibleEdges.has(link)) return dimOpacity;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return edgeOpacityMin + amplified * (1.0 - edgeOpacityMin);
        });

        // Add directional particles only on visible edges
        Graph.linkDirectionalParticles(link => {
            if (!visibleEdges.has(link)) return 0;
            return particleCount;
        });
        Graph.linkDirectionalParticleWidth(particleWidth);
        Graph.linkDirectionalParticleSpeed(particleSpeed);
        Graph.linkDirectionalParticleColor(() => particleColor);

        // Update node coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }

        // Debug: count edges with markov weights
        const edgesWithMarkov = graphLinks.filter(l => l.markov_weight > 0).length;
        console.log(`[Flow] Preset: ${preset.name} | ${highEntropyNodes.size} high entropy nodes, ${visibleEdges.size} visible edges (top-${topK}), ${edgesWithMarkov}/${graphLinks.length} edges with markov`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CLEAR FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function clearVisualization() {
        const Graph = window.Graph;

        // Guard: Ensure Graph is ready
        if (!Graph) return;

        const graphNodes = Graph.graphData().nodes;
        const originalNodeColors = window.originalNodeColors || new Map();

        // Restore original node colors and sizes
        graphNodes.forEach(node => {
            if (originalNodeColors.has(node.id)) {
                node.color = originalNodeColors.get(node.id);
            }
            // Restore original size from saved value
            if (node._originalVal) {
                node.val = node._originalVal;
                delete node._originalVal;
            }
        });

        // Reset link widths
        Graph.linkWidth(1);

        // Reset link opacity
        Graph.linkOpacity(0.6);

        // Remove directional particles
        Graph.linkDirectionalParticles(0);

        // Update coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getPresetColor: getFlowPresetColor,
        getPresetValue: getFlowPresetValue,
        toggle: toggle,
        disable: disable,
        apply: applyVisualization,
        clear: clearVisualization,
        PRESETS: PRESETS,
        getCurrentPreset: () => PRESETS[currentPresetIndex],
        getCurrentPresetIndex: () => currentPresetIndex
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getFlowPresetColor = FLOW.getPresetColor;
window.getFlowPresetValue = FLOW.getPresetValue;
window.toggleFlowMode = FLOW.toggle;
window.disableFlowMode = FLOW.disable;
window.applyFlowVisualization = FLOW.apply;
window.clearFlowVisualization = FLOW.clear;
window.FLOW_PRESETS = FLOW.PRESETS;

console.log('[Module] FLOW loaded - 6 functions');


// ═══ MODULE: modules/ui-builders.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UI-BUILDERS MODULE - DOM element construction utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Factory functions for building common UI elements: checkboxes, toggles,
 * filter groups, and option selectors.
 *
 * @module UI_BUILDERS
 * @version 1.0.0
 */

window.UI_BUILDERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // COUNT COLLECTION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Collect counts by key from items
     * @param {Array} items - Items to count
     * @param {Function} keyFn - Function to extract key from item
     * @returns {Array} Array of [key, count] pairs sorted by count desc
     */
    function collectCounts(items, keyFn) {
        const counts = new Map();
        items.forEach(item => {
            const key = keyFn(item);
            if (!key) return;
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHECKBOX ROW
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a checkbox row element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Element ID
     * @param {string} label - Display label
     * @param {number|null} count - Optional count to display
     * @param {boolean} checked - Initial checked state
     * @param {Function} onChange - Callback when checkbox changes
     * @returns {HTMLInputElement} The checkbox input element
     */
    function buildCheckboxRow(container, id, label, count, checked, onChange) {
        const row = document.createElement('div');
        row.className = 'filter-item';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = id;
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('label');
        text.setAttribute('for', id);
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'filter-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        row.appendChild(input);
        row.appendChild(text);
        if (countEl.textContent) {
            row.appendChild(countEl);
        }
        container.appendChild(row);

        return input;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER GROUP
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a filter group with ALL checkbox and individual items
     * @param {string} containerId - Container element ID
     * @param {Array} items - Array of [value, count] pairs
     * @param {Set} stateSet - Set to track selected values
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildFilterGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const allId = `${containerId}-all`;
        let allCheckbox = null;

        allCheckbox = buildCheckboxRow(container, allId, 'ALL', null, true, (checked) => {
            stateSet.clear();
            if (checked) {
                items.forEach(([value]) => stateSet.add(value));
            }
            container.querySelectorAll('input[type="checkbox"]').forEach(box => {
                if (box.id !== allId) box.checked = checked;
            });
            onUpdate();
        });

        items.forEach(([value, count], index) => {
            const id = `${containerId}-${index}`;
            const checked = stateSet.has(value);
            buildCheckboxRow(container, id, value, count, checked, (isChecked) => {
                if (isChecked) {
                    stateSet.add(value);
                } else {
                    stateSet.delete(value);
                }
                const allChecked = items.every(([v]) => stateSet.has(v));
                allCheckbox.checked = allChecked;
                onUpdate();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a datamap toggle element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Toggle ID
     * @param {string} label - Display label
     * @param {boolean} checked - Initial checked state
     * @param {number|null} count - Optional count to display
     * @param {Function} onChange - Callback when toggle changes
     * @returns {Object} Object with wrapper, input, and count elements
     */
    function buildDatamapToggle(container, id, label, checked, count, onChange) {
        const wrapper = document.createElement('label');
        wrapper.className = 'datamap-toggle';
        wrapper.setAttribute('data-id', id);

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('span');
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'datamap-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        wrapper.appendChild(input);
        wrapper.appendChild(text);
        wrapper.appendChild(countEl);
        container.appendChild(wrapper);

        return { wrapper, input, count: countEl };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // EXCLUSIVE OPTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build exclusive (radio-like) options using checkboxes
     * @param {string} containerId - Container element ID
     * @param {Array} options - Array of {label, value} objects
     * @param {*} activeValue - Currently active value
     * @param {Function} onSelect - Callback when option is selected
     */
    function buildExclusiveOptions(containerId, options, activeValue, onSelect) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const inputs = [];
        options.forEach((option, index) => {
            const id = `${containerId}-${index}`;
            const input = buildCheckboxRow(
                container,
                id,
                option.label,
                null,
                option.value === activeValue,
                (checked) => {
                    if (!checked) {
                        input.checked = true;
                        return;
                    }
                    inputs.forEach(other => {
                        if (other !== input) other.checked = false;
                    });
                    onSelect(option.value);
                }
            );
            inputs.push(input);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHIP GROUP BUILDER - Filter chips with ALL toggle
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build chip buttons for filter groups
     * @param {string} containerId - Container element ID
     * @param {Map} items - Map of key -> count
     * @param {Set} stateSet - Set tracking selected items
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildChipGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        // "ALL" chip
        const allChip = document.createElement('button');
        allChip.className = 'chip active';
        allChip.textContent = 'ALL';
        allChip.addEventListener('click', () => {
            // Toggle all on/off
            const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
            if (allActive) {
                stateSet.clear();
                container.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
            } else {
                items.forEach((count, key) => stateSet.add(key));
                container.querySelectorAll('.chip').forEach(c => c.classList.add('active'));
            }
            if (onUpdate) onUpdate();
        });
        container.appendChild(allChip);

        // Individual chips
        items.forEach((count, key) => {
            const chip = document.createElement('button');
            chip.className = 'chip' + (stateSet.has(key) ? ' active' : '');
            chip.innerHTML = `${key}<span class="chip-count">${count}</span>`;
            chip.addEventListener('click', () => {
                if (stateSet.has(key)) {
                    stateSet.delete(key);
                    chip.classList.remove('active');
                } else {
                    stateSet.add(key);
                    chip.classList.add('active');
                }
                // Update "ALL" chip state
                const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
                allChip.classList.toggle('active', allActive);
                if (onUpdate) onUpdate();
            });
            container.appendChild(chip);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA CONTROLS - Visibility toggles
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build metadata visibility controls
     * @param {string} containerId - Container element ID
     * @param {Object} metadata - Metadata state object with boolean flags
     */
    function buildMetadataControls(containerId, metadata) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const toggles = [
            { id: 'meta-labels', label: 'LABELS', key: 'showLabels' },
            { id: 'meta-file-panel', label: 'FILE PANEL', key: 'showFilePanel' },
            { id: 'meta-report', label: 'REPORT', key: 'showReportPanel' },
            { id: 'meta-edges', label: 'EDGES', key: 'showEdges' }
        ];

        toggles.forEach((toggle) => {
            buildCheckboxRow(container, toggle.id, toggle.label, null, metadata[toggle.key], (checked) => {
                metadata[toggle.key] = checked;
                if (typeof applyMetadataVisibility === 'function') applyMetadataVisibility();
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPEARANCE SLIDERS - Pure UI builder (decoupled from global state)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build appearance sliders - PURE UI, no global dependencies
     *
     * @param {string} containerId - Container element ID
     * @param {Array} sliderDefs - Array of slider definitions:
     *   { id, label, min, max, step, value, onChange?, description?, className? }
     * @param {Function} globalOnChange - Optional global callback: (sliderId, newValue) => void
     *
     * Supports two patterns:
     * 1. Individual: Each sliderDef has its own onChange(value) handler
     * 2. Global: A single globalOnChange(sliderId, value) handles all
     */
    function buildAppearanceSliders(containerId, sliderDefs, globalOnChange) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row' + (def.className ? ' ' + def.className : '');

            // Header row with label and value
            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            const safeValue = def.value ?? def.min ?? 0;
            valueDisplay.textContent = safeValue.toFixed(def.step < 1 ? 2 : 0);
            header.appendChild(label);
            header.appendChild(valueDisplay);

            // The slider input
            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = safeValue;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = val.toFixed(def.step < 1 ? 2 : 0);
                // Support both patterns: individual onChange or global
                if (def.onChange) def.onChange(val);
                if (globalOnChange) globalOnChange(def.id, val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);

            // Optional description for meta-sliders
            if (def.description) {
                const desc = document.createElement('div');
                desc.className = 'slider-desc';
                desc.textContent = def.description;
                wrapper.appendChild(desc);
            }

            container.appendChild(wrapper);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        collectCounts: collectCounts,
        buildCheckboxRow: buildCheckboxRow,
        buildFilterGroup: buildFilterGroup,
        buildDatamapToggle: buildDatamapToggle,
        buildExclusiveOptions: buildExclusiveOptions,
        buildChipGroup: buildChipGroup,
        buildMetadataControls: buildMetadataControls,
        buildAppearanceSliders: buildAppearanceSliders
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.collectCounts = UI_BUILDERS.collectCounts;
window.buildCheckboxRow = UI_BUILDERS.buildCheckboxRow;
window.buildFilterGroup = UI_BUILDERS.buildFilterGroup;
window.buildDatamapToggle = UI_BUILDERS.buildDatamapToggle;
window.buildExclusiveOptions = UI_BUILDERS.buildExclusiveOptions;
window.buildChipGroup = UI_BUILDERS.buildChipGroup;
window.buildMetadataControls = UI_BUILDERS.buildMetadataControls;
// Note: buildAppearanceSliders shim is in app.js (orchestration layer)

console.log('[Module] UI_BUILDERS loaded - 8 functions (appearance sliders decoupled)');


// ═══ MODULE: modules/layout-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT-HELPERS MODULE - Layout stability and position utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Functions for saving/restoring node positions, freezing/unfreezing layout,
 * and calculating file positions.
 * Depends on: Graph, NODE_POSITION_CACHE, LAYOUT_FROZEN, IS_3D
 *
 * @module LAYOUT_HELPERS
 * @version 1.0.0
 */

window.LAYOUT_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // POSITION PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Save current node positions to cache
     */
    function saveNodePositions() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;
        if (!Graph || !cache) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined && node.y !== undefined) {
                cache.set(node.id, {
                    x: node.x, y: node.y, z: node.z || 0,
                    vx: node.vx || 0, vy: node.vy || 0, vz: node.vz || 0,
                    fx: node.fx, fy: node.fy, fz: node.fz
                });
            }
        });
    }

    /**
     * Restore node positions from cache
     * @param {Array} nodes - Nodes to restore positions for
     */
    function restoreNodePositions(nodes) {
        const cache = window.NODE_POSITION_CACHE;
        const frozen = window.LAYOUT_FROZEN;
        if (!cache) return;

        nodes.forEach(node => {
            const cached = cache.get(node.id);
            if (cached) {
                node.x = cached.x;
                node.y = cached.y;
                node.z = cached.z;
                node.vx = cached.vx;
                node.vy = cached.vy;
                node.vz = cached.vz;
                // Pin nodes in place when layout is frozen
                if (frozen) {
                    node.fx = cached.x;
                    node.fy = cached.y;
                    node.fz = cached.z;
                }
            }
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LAYOUT FREEZE/UNFREEZE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Freeze layout by pinning all nodes in place
     */
    function freezeLayout() {
        window.LAYOUT_FROZEN = true;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined) {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            }
        });
        Graph.cooldownTicks(0);  // Stop simulation immediately
    }

    /**
     * Unfreeze layout by unpinning all nodes
     */
    function unfreezeLayout() {
        window.LAYOUT_FROZEN = false;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            node.fx = undefined;
            node.fy = undefined;
            node.fz = undefined;
        });
    }

    /**
     * Reset layout - clear cache and reheat simulation
     */
    function resetLayout() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;

        // Clear position cache
        if (cache) cache.clear();

        // Unfreeze and restart simulation
        unfreezeLayout();

        if (Graph) {
            Graph.cooldownTicks(200);  // Allow simulation to run
            Graph.d3ReheatSimulation();
        }

        if (typeof window.showModeToast === 'function') {
            window.showModeToast('Layout reset - physics running');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LINK/FILE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get the ID of a link endpoint (source or target)
     * @param {Object} link - The link object
     * @param {string} side - 'source' or 'target'
     * @returns {string|undefined} The endpoint ID
     */
    function getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.id || endpoint;
        }
        return endpoint;
    }

    /**
     * Calculate target position for a file node in radial layout
     * @param {number} fileIdx - Index of the file
     * @param {number} totalFiles - Total number of files
     * @param {number} radius - Radius of the circle
     * @param {number} zSpacing - Z-axis spacing between files
     * @returns {Object} Position {x, y, z}
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpacing) {
        if (totalFiles <= 0) {
            return { x: 0, y: 0, z: 0 };
        }
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        const is3D = window.IS_3D;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: is3D ? (fileIdx - totalFiles / 2) * zSpacing : 0
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        savePositions: saveNodePositions,
        restorePositions: restoreNodePositions,
        freeze: freezeLayout,
        unfreeze: unfreezeLayout,
        reset: resetLayout,
        getLinkEndpointId: getLinkEndpointId,
        getFileTarget: getFileTarget
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.saveNodePositions = LAYOUT_HELPERS.savePositions;
window.restoreNodePositions = LAYOUT_HELPERS.restorePositions;
window.freezeLayout = LAYOUT_HELPERS.freeze;
window.unfreezeLayout = LAYOUT_HELPERS.unfreeze;
window.resetLayout = LAYOUT_HELPERS.reset;
window.getLinkEndpointId = LAYOUT_HELPERS.getLinkEndpointId;
window.getFileTarget = LAYOUT_HELPERS.getFileTarget;

console.log('[Module] LAYOUT_HELPERS loaded - 7 functions');


// ═══ MODULE: modules/spatial.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SPATIAL MODULE - Spatial algorithms and collision detection
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Spatial hashing for O(n) collision detection, convex hull calculation,
 * and node sampling utilities.
 * Depends on: IS_3D, FILE_CONTAINMENT, THREE
 *
 * @module SPATIAL
 * @version 1.0.0
 */

window.SPATIAL = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SAMPLING
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Sample nodes evenly if there are too many
     * @param {Array} nodes - Array of nodes
     * @param {number} maxPoints - Maximum number of points to return
     * @returns {Array} Sampled nodes
     */
    function sampleFileNodes(nodes, maxPoints) {
        if (nodes.length <= maxPoints) return nodes;
        const step = Math.ceil(nodes.length / maxPoints);
        return nodes.filter((_, idx) => idx % step === 0);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVEX HULL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build 2D convex hull using Andrew's monotone chain algorithm
     * @param {Array} points - Array of {x, y} points
     * @returns {Array|null} Hull points or null if insufficient points
     */
    function buildHull2D(points) {
        if (points.length < 3) return null;

        // Remove duplicates
        const unique = new Map();
        points.forEach(p => {
            const key = `${p.x.toFixed(4)},${p.y.toFixed(4)}`;
            if (!unique.has(key)) unique.set(key, p);
        });

        // Sort by x, then y
        const pts = Array.from(unique.values()).sort((a, b) => {
            if (a.x === b.x) return a.y - b.y;
            return a.x - b.x;
        });

        if (pts.length < 3) return null;

        // Cross product of vectors OA and OB
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

        // Build lower hull
        const lower = [];
        for (const p of pts) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                lower.pop();
            }
            lower.push(p);
        }

        // Build upper hull
        const upper = [];
        for (let i = pts.length - 1; i >= 0; i--) {
            const p = pts[i];
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                upper.pop();
            }
            upper.push(p);
        }

        // Remove last point of each half (it's the starting point of the other)
        upper.pop();
        lower.pop();

        return lower.concat(upper);
    }

    /**
     * Compute centroid of points
     * @param {Array} points - Array of THREE.Vector3-like objects
     * @returns {THREE.Vector3} Centroid
     */
    function computeCentroid(points) {
        const THREE = window.THREE;
        const centroid = new THREE.Vector3();
        points.forEach(p => centroid.add(p));
        return centroid.divideScalar(Math.max(1, points.length));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SPATIAL HASHING - O(n) collision detection
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build spatial hash grid for efficient neighbor queries
     * @param {Array} nodes - Array of nodes with x, y, z coordinates
     * @param {number} cellSize - Size of each grid cell
     * @returns {Map} Grid map with cell keys to node arrays
     */
    function buildSpatialGrid(nodes, cellSize) {
        const is3D = window.IS_3D;
        const grid = new Map();

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) grid.set(key, []);
            grid.get(key).push(node);
        });

        // Store for file containment
        if (window.FILE_CONTAINMENT) {
            window.FILE_CONTAINMENT.spatialGrid = grid;
        }

        return grid;
    }

    /**
     * Get keys for neighboring cells (3x3x3 in 3D, 3x3 in 2D)
     * @param {number} cellX - Cell X coordinate
     * @param {number} cellY - Cell Y coordinate
     * @param {number} cellZ - Cell Z coordinate
     * @returns {Array} Array of neighbor cell keys
     */
    function getNeighborCells(cellX, cellY, cellZ) {
        const is3D = window.IS_3D;
        const neighbors = [];

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = is3D ? -1 : 0; dz <= (is3D ? 1 : 0); dz++) {
                    neighbors.push(`${cellX + dx},${cellY + dy},${cellZ + dz}`);
                }
            }
        }

        return neighbors;
    }

    /**
     * Apply soft collision forces to push overlapping nodes apart
     * @param {Array} nodes - Array of nodes
     * @param {number} cellSize - Spatial grid cell size
     * @param {number} repulsionStrength - Strength of repulsion (0-1)
     */
    function applySoftCollisions(nodes, cellSize, repulsionStrength = 0.5) {
        const containment = window.FILE_CONTAINMENT;
        const is3D = window.IS_3D;

        if (!containment || !containment.collisionEnabled) return;

        const grid = buildSpatialGrid(nodes, cellSize);
        const minDist = 8;  // Minimum distance between particles
        const minDistSq = minDist * minDist;

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            if (!node.__physics) {
                node.__physics = { vx: 0, vy: 0, vz: 0 };
            }

            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const neighborKeys = getNeighborCells(cellX, cellY, cellZ);

            neighborKeys.forEach(key => {
                const cellNodes = grid.get(key);
                if (!cellNodes) return;

                cellNodes.forEach(other => {
                    if (other === node) return;

                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dz = is3D ? ((node.z || 0) - (other.z || 0)) : 0;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < minDistSq && distSq > 0.001) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        const force = (overlap / minDist) * repulsionStrength;

                        // Push apart along normal
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = is3D ? dz / dist : 0;

                        node.__physics.vx += nx * force;
                        node.__physics.vy += ny * force;
                        if (is3D) node.__physics.vz += nz * force;
                    }
                });
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        sampleFileNodes: sampleFileNodes,
        buildHull2D: buildHull2D,
        computeCentroid: computeCentroid,
        buildSpatialGrid: buildSpatialGrid,
        getNeighborCells: getNeighborCells,
        applySoftCollisions: applySoftCollisions
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.sampleFileNodes = SPATIAL.sampleFileNodes;
window.buildHull2D = SPATIAL.buildHull2D;
window.computeCentroid = SPATIAL.computeCentroid;
window.buildSpatialGrid = SPATIAL.buildSpatialGrid;
window.getNeighborCells = SPATIAL.getNeighborCells;
window.applySoftCollisions = SPATIAL.applySoftCollisions;

console.log('[Module] SPATIAL loaded - 6 functions');


// ═══ MODULE: modules/layout.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT MODULE - Unified UI Layout Engine
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * MIGRATED FROM: app.js HudLayoutManager (390 lines)
 * This is the SINGLE SOURCE OF TRUTH for UI layout intelligence.
 *
 * Features:
 *   - Panel placement with collision avoidance (from HudLayoutManager)
 *   - Component registration system (NEW)
 *   - Toast/control-bar collision detection (NEW)
 *   - Min-width graph validation (NEW)
 *   - Debug overlay with Ctrl+Shift+L (NEW)
 *
 * @module LAYOUT
 * @version 2.0.0
 * @confidence 94%
 */

window.LAYOUT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CONFIGURATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    const CONFIG = {
        MARGIN: 16,
        MIN_GRAPH_WIDTH: 320,
        REFLOW_THROTTLE_MS: 50,
        DEBUG_COLORS: {
            dock: 'rgba(100, 150, 255, 0.3)',
            overlay: 'rgba(255, 150, 100, 0.3)',
            floating: 'rgba(100, 255, 150, 0.3)',
            fixed: 'rgba(150, 150, 150, 0.3)'
        }
    };

    // Panels by priority (higher = more important, won't be moved)
    // MIGRATED from HudLayoutManager
    const FIXED_PANELS = ['top-left-header', 'stats-panel', 'metrics-panel', 'bottom-dock', 'report-panel', 'side-dock'];
    const DYNAMIC_PANELS = ['hover-panel', 'file-panel', 'selection-panel'];

    // ═══════════════════════════════════════════════════════════════════════
    // STATE
    // ═══════════════════════════════════════════════════════════════════════

    // Throttle state (from HudLayoutManager)
    let _rafPending = false;
    let _lastReflow = 0;

    // Mouse position for hover-panel placement (from HudLayoutManager)
    let _mouseX = 0;
    let _mouseY = 0;

    // Component registry (NEW)
    const _registry = new Map();

    // Debug overlay state (NEW)
    let _debugEnabled = false;
    let _debugOverlay = null;

    // ═══════════════════════════════════════════════════════════════════════
    // VIEWPORT & RECT UTILITIES (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get viewport rectangle with margins
     */
    function getViewport() {
        return {
            left: CONFIG.MARGIN,
            top: CONFIG.MARGIN,
            right: window.innerWidth - CONFIG.MARGIN,
            bottom: window.innerHeight - CONFIG.MARGIN,
            width: window.innerWidth - 2 * CONFIG.MARGIN,
            height: window.innerHeight - 2 * CONFIG.MARGIN
        };
    }

    /**
     * Check if sidebar is effectively "open" (occupying space)
     */
    function isSidebarOpen() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock) return false;
        const state = window.SIDEBAR_STATE;
        return (state && (state.locked || state.open)) ||
            sideDock.classList.contains('locked') ||
            sideDock.classList.contains('expanded') ||
            sideDock.matches(':hover');
    }

    /**
     * Get rectangle for an element (returns null if hidden/missing)
     */
    function getRect(el) {
        if (!el) return null;
        if (typeof el === 'string') {
            el = document.getElementById(el) || document.querySelector(el);
        }
        if (!el) return null;
        const style = window.getComputedStyle(el);
        if (style.display === 'none' || style.visibility === 'hidden') return null;
        const r = el.getBoundingClientRect();
        if (r.width === 0 && r.height === 0) return null;
        return { left: r.left, top: r.top, right: r.right, bottom: r.bottom, width: r.width, height: r.height };
    }

    /**
     * Get sidebar occupied region (full expanded width when open)
     */
    function getSidebarRect() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock || !isSidebarOpen()) return null;
        const sideWidth = parseInt(getComputedStyle(sideDock).getPropertyValue('--side-width')) || 260;
        return {
            left: 0,
            top: 0,
            right: 16 + sideWidth + 20,
            bottom: window.innerHeight,
            width: 16 + sideWidth + 20,
            height: window.innerHeight
        };
    }

    /**
     * Get all occupied rectangles (fixed panels + sidebar when open)
     */
    function getOccupiedRects() {
        const rects = [];

        // Sidebar takes priority when open
        const sidebarRect = getSidebarRect();
        if (sidebarRect) rects.push(sidebarRect);

        // Fixed panels
        FIXED_PANELS.forEach(id => {
            if (id === 'side-dock') return;
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (rect) rects.push(rect);
        });

        // Top-left header (special case - class-based)
        const topLeft = document.querySelector('.top-left');
        const topLeftRect = getRect(topLeft);
        if (topLeftRect) rects.push(topLeftRect);

        return rects;
    }

    /**
     * Calculate overlap area between two rectangles
     */
    function overlapArea(r1, r2) {
        if (!r1 || !r2) return 0;
        const xOverlap = Math.max(0, Math.min(r1.right, r2.right) - Math.max(r1.left, r2.left));
        const yOverlap = Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
        return xOverlap * yOverlap;
    }

    /**
     * Check if rect is fully inside viewport
     */
    function isInsideViewport(rect, viewport) {
        return rect.left >= viewport.left &&
            rect.top >= viewport.top &&
            rect.right <= viewport.right &&
            rect.bottom <= viewport.bottom;
    }

    /**
     * Clamp position to keep panel inside viewport
     */
    function clampToViewport(pos, panelWidth, panelHeight, viewport) {
        return {
            left: Math.max(viewport.left, Math.min(pos.left, viewport.right - panelWidth)),
            top: Math.max(viewport.top, Math.min(pos.top, viewport.bottom - panelHeight))
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CANDIDATE GENERATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Generate candidate positions for file panel
     */
    function getFilePanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Generate candidate positions for selection panel
     */
    function getSelectionPanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Get screen centroid of selected nodes
     */
    function getSelectionCentroid() {
        const Graph = window.Graph;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (!Graph || !Graph.graphData || !selectedIds || selectedIds.size === 0) return null;

        const nodes = Graph.graphData().nodes || [];
        const selectedNodes = nodes.filter(n => selectedIds.has(n.id));
        if (selectedNodes.length === 0) return null;

        let sumX = 0, sumY = 0, sumZ = 0;
        selectedNodes.forEach(n => {
            sumX += n.x || 0;
            sumY += n.y || 0;
            sumZ += n.z || 0;
        });
        const centroid3D = {
            x: sumX / selectedNodes.length,
            y: sumY / selectedNodes.length,
            z: sumZ / selectedNodes.length
        };

        const camera = Graph.camera();
        if (!camera || !window.THREE) return null;
        const vector = new window.THREE.Vector3(centroid3D.x, centroid3D.y, centroid3D.z);
        vector.project(camera);
        return {
            x: (vector.x * 0.5 + 0.5) * window.innerWidth,
            y: (-vector.y * 0.5 + 0.5) * window.innerHeight
        };
    }

    /**
     * Generate candidate positions for hover panel
     */
    function getHoverPanelCandidates(mouseX, mouseY, panelWidth, panelHeight) {
        const vp = getViewport();
        const offset = 16;

        let anchorX = mouseX;
        let anchorY = mouseY;

        const hoveredNode = window.HOVERED_NODE;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (hoveredNode && selectedIds && selectedIds.has(hoveredNode.id)) {
            const centroid = getSelectionCentroid();
            if (centroid) {
                anchorX = mouseX * 0.3 + centroid.x * 0.7;
                anchorY = mouseY * 0.3 + centroid.y * 0.7;
            }
        }

        const sidebarOpen = isSidebarOpen();
        const sidebarRect = sidebarOpen ? getSidebarRect() : null;
        const minLeft = sidebarRect ? sidebarRect.right + offset : vp.left;

        let candidates = [
            { left: anchorX + offset, top: anchorY - panelHeight - offset },
            { left: anchorX + offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY - panelHeight - offset }
        ];

        if (sidebarRect) {
            candidates = candidates.map(c => ({
                left: Math.max(c.left, minLeft),
                top: c.top
            }));
        }

        return candidates;
    }

    /**
     * Update mouse position
     */
    function updateMousePosition(x, y) {
        _mouseX = x;
        _mouseY = y;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PANEL PLACEMENT (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Place a panel at the best position (least overlap)
     */
    function placePanel(panelEl, candidates, occupiedRects) {
        if (!panelEl) return null;

        const rect = panelEl.getBoundingClientRect();
        const panelWidth = rect.width || 400;
        const panelHeight = rect.height || 350;
        const viewport = getViewport();

        let bestPos = candidates[0];
        let bestOverlap = Infinity;

        for (const pos of candidates) {
            const clampedPos = clampToViewport(pos, panelWidth, panelHeight, viewport);
            const panelRect = {
                left: clampedPos.left,
                top: clampedPos.top,
                right: clampedPos.left + panelWidth,
                bottom: clampedPos.top + panelHeight
            };

            let totalOverlap = 0;
            for (const occRect of occupiedRects) {
                totalOverlap += overlapArea(panelRect, occRect);
            }

            if (!isInsideViewport(panelRect, viewport)) {
                totalOverlap += 10000;
            }

            if (totalOverlap < bestOverlap) {
                bestOverlap = totalOverlap;
                bestPos = clampedPos;
                if (totalOverlap === 0) break;
            }
        }

        return bestPos;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST/CONTROL-BAR COLLISION (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Check and resolve toast/control-bar collision
     * Returns offset to apply to toast if collision detected
     */
    function resolveToastCollision() {
        const toast = document.getElementById('toast') ||
                      document.getElementById('hud-toast') ||
                      document.getElementById('mode-toast');
        const controlBar = document.querySelector('.control-bar');

        if (!toast || !controlBar) return 0;

        const toastRect = getRect(toast);
        const barRect = getRect(controlBar);

        if (!toastRect || !barRect) return 0;

        const overlap = overlapArea(toastRect, barRect);
        if (overlap > 0) {
            // Move toast above control bar
            const offset = barRect.height + CONFIG.MARGIN;
            console.log(`[LAYOUT] Toast/control-bar collision: ${overlap}px², offset: -${offset}px`);
            return -offset;
        }
        return 0;
    }

    /**
     * Apply toast offset if needed
     */
    function applyToastOffset() {
        const offset = resolveToastCollision();
        if (offset !== 0) {
            const toast = document.getElementById('toast') ||
                          document.getElementById('hud-toast');
            if (toast) {
                toast.style.transform = `translateX(-50%) translateY(${offset}px)`;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MIN-WIDTH VALIDATOR (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Validate graph has minimum width, adjust sidebars if needed
     */
    function validateGraphWidth() {
        const leftSidebar = document.getElementById('left-sidebar');
        const rightSidebar = document.getElementById('right-sidebar');
        const viewport = getViewport();

        const leftWidth = leftSidebar ? (getRect(leftSidebar)?.width || 0) : 0;
        const rightWidth = rightSidebar ? (getRect(rightSidebar)?.width || 0) : 0;
        const graphWidth = viewport.width - leftWidth - rightWidth;

        if (graphWidth < CONFIG.MIN_GRAPH_WIDTH) {
            const deficit = CONFIG.MIN_GRAPH_WIDTH - graphWidth;
            console.warn(`[LAYOUT] Graph width ${graphWidth}px < ${CONFIG.MIN_GRAPH_WIDTH}px minimum`);

            // Try to reduce right sidebar
            if (rightSidebar && rightWidth > 200) {
                const newWidth = Math.max(200, rightWidth - deficit);
                document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
                return { adjusted: true, component: 'right-sidebar', newWidth };
            }
        }
        return { adjusted: false };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // REFLOW (from HudLayoutManager, enhanced)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Reflow all dynamic panels
     */
    function reflow() {
        const now = Date.now();
        if (now - _lastReflow < CONFIG.REFLOW_THROTTLE_MS) {
            if (!_rafPending) {
                _rafPending = true;
                requestAnimationFrame(() => {
                    _rafPending = false;
                    reflow();
                });
            }
            return;
        }
        _lastReflow = now;

        const occupiedRects = getOccupiedRects();

        // Place hover panel first (higher priority)
        const hoverPanel = document.getElementById('hover-panel');
        let hoverPanelRect = null;
        if (hoverPanel && hoverPanel.classList.contains('visible')) {
            const hoverWidth = hoverPanel.offsetWidth || 280;
            const hoverHeight = hoverPanel.offsetHeight || 200;
            const candidates = getHoverPanelCandidates(_mouseX, _mouseY, hoverWidth, hoverHeight);
            const pos = placePanel(hoverPanel, candidates, occupiedRects);
            if (pos) {
                hoverPanel.style.left = pos.left + 'px';
                hoverPanel.style.top = pos.top + 'px';
                hoverPanel.style.right = 'auto';
                hoverPanelRect = {
                    left: pos.left, top: pos.top,
                    right: pos.left + hoverWidth, bottom: pos.top + hoverHeight
                };
            }
        }

        const filePanelOccupied = [...occupiedRects];
        if (hoverPanelRect) filePanelOccupied.push(hoverPanelRect);

        // Place selection panel
        const selectionPanel = document.getElementById('selection-panel');
        if (selectionPanel && selectionPanel.classList.contains('visible')) {
            const candidates = getSelectionPanelCandidates(
                selectionPanel.offsetWidth || 320,
                selectionPanel.offsetHeight || 280
            );
            const pos = placePanel(selectionPanel, candidates, filePanelOccupied);
            if (pos) {
                selectionPanel.style.left = pos.left + 'px';
                selectionPanel.style.top = pos.top + 'px';
                selectionPanel.style.right = 'auto';
                filePanelOccupied.push({
                    left: pos.left, top: pos.top,
                    right: pos.left + (selectionPanel.offsetWidth || 320),
                    bottom: pos.top + (selectionPanel.offsetHeight || 280)
                });
            }
        }

        // Place file panel
        const filePanel = document.getElementById('file-panel');
        if (filePanel && filePanel.classList.contains('visible')) {
            const candidates = getFilePanelCandidates(
                filePanel.offsetWidth || 400,
                filePanel.offsetHeight || 350
            );
            const pos = placePanel(filePanel, candidates, filePanelOccupied);
            if (pos) {
                filePanel.style.left = pos.left + 'px';
                filePanel.style.top = pos.top + 'px';
                filePanel.style.bottom = 'auto';
            }
        }

        // NEW: Check toast/control-bar collision
        applyToastOffset();

        // NEW: Validate graph width
        validateGraphWidth();

        // NEW: Update debug overlay
        if (_debugEnabled) updateDebugOverlay();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DEBUG OVERLAY (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle debug overlay
     */
    function toggleDebugOverlay() {
        _debugEnabled = !_debugEnabled;

        if (_debugEnabled) {
            if (!_debugOverlay) {
                _debugOverlay = document.createElement('div');
                _debugOverlay.id = 'layout-debug-overlay';
                _debugOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none; z-index: 10001;
                `;
                document.body.appendChild(_debugOverlay);
            }
            updateDebugOverlay();
            console.log('[LAYOUT] Debug overlay ON (Ctrl+Shift+L)');
        } else {
            if (_debugOverlay) {
                _debugOverlay.remove();
                _debugOverlay = null;
            }
            console.log('[LAYOUT] Debug overlay OFF');
        }
    }

    /**
     * Update debug overlay with current component bounds
     */
    function updateDebugOverlay() {
        if (!_debugOverlay) return;

        let html = '';
        const allPanels = [...FIXED_PANELS, ...DYNAMIC_PANELS, 'toast', 'control-bar', 'left-sidebar', 'right-sidebar'];

        allPanels.forEach(id => {
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (!rect) return;

            const kind = FIXED_PANELS.includes(id) ? 'fixed' :
                         DYNAMIC_PANELS.includes(id) ? 'floating' : 'overlay';
            const color = CONFIG.DEBUG_COLORS[kind] || 'rgba(128,128,128,0.3)';

            html += `
                <div style="
                    position: fixed;
                    left: ${rect.left}px; top: ${rect.top}px;
                    width: ${rect.width}px; height: ${rect.height}px;
                    background: ${color};
                    border: 1px solid ${color.replace('0.3', '0.8')};
                    font-size: 10px; color: white; text-shadow: 0 0 2px black;
                    padding: 2px 4px; box-sizing: border-box; overflow: hidden;
                ">${id}</div>
            `;
        });

        _debugOverlay.innerHTML = html;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COMPONENT REGISTRATION (NEW - for future explicit constraints)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Register a component (for explicit constraint tracking)
     */
    function register(descriptor) {
        const { id, selector, kind = 'dock' } = descriptor;
        if (!id) return null;

        let element = typeof selector === 'string' ?
            (document.getElementById(selector.replace('#', '')) || document.querySelector(selector)) :
            selector;

        _registry.set(id, { ...descriptor, element });
        console.log(`[LAYOUT] Registered: ${id} (${kind})`);
        return _registry.get(id);
    }

    /**
     * Get registered component
     */
    function get(id) {
        return _registry.get(id) || null;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize layout system
     */
    function init() {
        // Window resize
        window.addEventListener('resize', () => reflow());

        // Track mouse position
        window.addEventListener('mousemove', (e) => {
            updateMousePosition(e.clientX, e.clientY);
        }, { passive: true });

        // Sidebar state changes
        const sideDock = document.getElementById('side-dock');
        if (sideDock) {
            sideDock.addEventListener('mouseenter', () => reflow());
            sideDock.addEventListener('mouseleave', () => {
                setTimeout(() => reflow(), 200);
            });
        }

        // Debug overlay shortcut (Ctrl+Shift+L)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                e.preventDefault();
                toggleDebugOverlay();
            }
        });

        console.log('[LAYOUT] Initialized (replaces HudLayoutManager)');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Core utilities
        getViewport,
        getRect,
        overlapArea,
        isInsideViewport,
        clampToViewport,

        // Panel placement (backward compatible with HudLayoutManager)
        getOccupiedRects,
        placePanel,
        getFilePanelCandidates,
        getSelectionPanelCandidates,
        getHoverPanelCandidates,
        getSelectionCentroid,
        updateMousePosition,

        // Main entry points
        reflow,
        init,

        // NEW: Validation
        validateGraphWidth,
        resolveToastCollision,

        // NEW: Debug
        toggleDebugOverlay,

        // NEW: Registration
        register,
        get,

        // Config (read-only)
        CONFIG: Object.freeze({ ...CONFIG })
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY: HudLayoutManager alias
// ═══════════════════════════════════════════════════════════════════════════

window.HudLayoutManager = LAYOUT;
window.Layout = LAYOUT;

console.log('[Module] LAYOUT loaded - Unified Layout Engine v2.0.0');


// ═══ MODULE: modules/hud.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HUD MODULE - Heads-up display management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles HUD fade behavior and stats panel updates.
 * Depends on: DOM elements (stat-nodes, stat-edges, stat-entropy, etc.)
 *
 * @module HUD
 * @version 1.0.0
 */

window.HUD = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // HUD FADE BEHAVIOR
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup HUD auto-fade on idle
     * Fades HUD elements after period of inactivity
     */
    function setupFade() {
        const idleDelay = 2200;
        let timer = null;

        const activate = () => {
            document.body.classList.remove('hud-quiet');
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                document.body.classList.add('hud-quiet');
            }, idleDelay);
        };

        ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach((evt) => {
            window.addEventListener(evt, activate, { passive: true });
        });

        activate();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATS UPDATES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all HUD stats elements
     * @param {Object} data - Graph data with nodes, links, meta
     */
    function updateStats(data) {
        if (!data) return;

        // Stats panel: NODES, EDGES, ENTROPY
        const nodeCount = (data.nodes || []).length;
        const edgeCount = (data.links || []).length;

        const statNodes = document.getElementById('stat-nodes');
        const statEdges = document.getElementById('stat-edges');
        const statEntropy = document.getElementById('stat-entropy');

        if (statNodes) statNodes.textContent = nodeCount.toLocaleString();
        if (statEdges) statEdges.textContent = edgeCount.toLocaleString();
        if (statEntropy) {
            const entropy = data.meta?.entropy ?? data.entropy ?? '--';
            statEntropy.textContent = typeof entropy === 'number' ? entropy.toFixed(2) : entropy;
        }

        // Header panel: target name and timestamp
        const targetName = document.getElementById('target-name');
        const timestamp = document.getElementById('timestamp');

        if (targetName) {
            const target = data.meta?.target || data.target || 'Unknown';
            // Show just the last part of the path
            const shortTarget = target.split('/').pop() || target;
            targetName.textContent = shortTarget;
        }

        if (timestamp) {
            const ts = data.meta?.timestamp || data.timestamp || '';
            // Format: 2024-01-15T10:30:00 -> 2024-01-15 10:30
            const formatted = ts.replace('T', ' ').substring(0, 16);
            timestamp.textContent = formatted || 'Live';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupFade: setupFade,
        updateStats: updateStats
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupHudFade = HUD.setupFade;
window.updateHudStats = HUD.updateStats;

console.log('[Module] HUD loaded - 2 functions');


// ═══ MODULE: modules/dimension.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DIMENSION MODULE - 2D/3D dimension switching with animation
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles smooth animated transitions between 2D and 3D graph views.
 * Depends on: Graph, IS_3D, DIMENSION_TRANSITION, stableSeed, stableZ,
 *             fileMode, GRAPH_MODE, applyFileVizMode
 *
 * @module DIMENSION
 * @version 1.1.0
 */

window.DIMENSION = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // DIMENSION TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle between 2D and 3D dimensions
     */
    function toggle() {
        if (window.DIMENSION_TRANSITION) return;
        window.DIMENSION_TRANSITION = true;

        const target3d = !window.IS_3D;
        const button = document.getElementById('btn-2d');

        animateChange(target3d, () => {
            window.IS_3D = target3d;
            window.DIMENSION_TRANSITION = false;
            if (button) button.textContent = window.IS_3D ? '2D' : '3D';

            // Re-apply file viz mode if active
            if (window.fileMode && window.GRAPH_MODE === 'atoms') {
                if (typeof window.applyFileVizMode === 'function') {
                    window.applyFileVizMode();
                }
            }
        });
    }

    /**
     * Setup the dimension toggle button
     */
    function setup() {
        const button = document.getElementById('btn-2d');
        if (!button) return;

        const updateLabel = () => {
            button.textContent = window.IS_3D ? '2D' : '3D';
        };
        updateLabel();
        button.onclick = toggle;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ANIMATED TRANSITION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Animate transition between 2D and 3D
     * @param {boolean} target3d - Whether transitioning to 3D
     * @param {Function} done - Callback when animation completes
     */
    function animateChange(target3d, done) {
        const Graph = window.Graph;
        // STARFIELD & BLOOM removed - nodes ARE the stars, post-processing not in r149+ UMD builds
        const stableSeed = window.stableSeed;
        const stableZ = window.stableZ;

        const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
        const startTime = performance.now();
        const duration = 3000;
        const delayMin = 0;
        const delayMax = 2000;
        const lockPositionsAfterTransition = true;

        const easeInOutSine = (t) => 0.5 - 0.5 * Math.cos(Math.PI * t);

        // Store previous simulation settings
        const previousVelocityDecay = (Graph && Graph.d3VelocityDecay) ? Graph.d3VelocityDecay() : null;
        const previousAlphaTarget = (Graph && Graph.d3AlphaTarget) ? Graph.d3AlphaTarget() : null;
        const previousCooldownTicks = (Graph && Graph.cooldownTicks) ? Graph.cooldownTicks() : null;
        const previousCooldownTime = (Graph && Graph.cooldownTime) ? Graph.cooldownTime() : null;

        // Freeze simulation during transition
        if (Graph && Graph.cooldownTicks) Graph.cooldownTicks(Infinity);
        if (Graph && Graph.cooldownTime) Graph.cooldownTime(Infinity);
        if (Graph && Graph.d3VelocityDecay) Graph.d3VelocityDecay(1);
        if (Graph && Graph.d3AlphaTarget) Graph.d3AlphaTarget(0);
        if (Graph && Graph.d3ReheatSimulation) Graph.d3ReheatSimulation();

        // Initialize node animation state
        nodes.forEach((node) => {
            node.__xStart = node.x || 0;
            node.__yStart = node.y || 0;
            node.__zStart = node.z || 0;
            node.__delay = delayMin + (stableSeed(node, 'delay') * (delayMax - delayMin));
            node.fx = node.__xStart;
            node.fy = node.__yStart;
            node.vx = 0;
            node.vy = 0;
            node.vz = 0;

            if (target3d) {
                if (node.__z3d === undefined || node.__z3d === null) {
                    node.__z3d = node.__zStart || stableZ(node);
                }
            } else {
                node.__z3d = node.__zStart;
            }
        });

        const maxDistance = nodes.reduce((acc, node) => Math.max(acc, Math.abs(node.__zStart || 0)), 1);

        Graph.numDimensions(3);

        const animate = (now) => {
            const elapsed = now - startTime;
            const t = Math.min(1, elapsed / duration);

            // Animate each node's Z position
            nodes.forEach((node) => {
                const startZ = node.__zStart || 0;
                const targetZ = target3d ? (node.__z3d || 0) : 0;
                const delay = node.__delay || 0;
                const localDuration = Math.max(600, duration - delay);
                const localElapsed = Math.max(0, elapsed - delay);
                const localT = Math.min(1, localElapsed / localDuration);
                const localEase = easeInOutSine(localT);
                const distanceRatio = maxDistance > 0 ? Math.abs(startZ) / maxDistance : 0;
                const distanceCurve = 0.6 + (1 - distanceRatio) * 0.6;
                const progress = Math.pow(localEase, distanceCurve);
                const nextZ = startZ + (targetZ - startZ) * progress;
                node.z = nextZ;
                node.fz = nextZ;
                node.vz = 0;
            });

            if (t < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - clean up
                nodes.forEach((node) => {
                    delete node.fz;
                    delete node.__zStart;
                    delete node.__xStart;
                    delete node.__yStart;
                    delete node.__delay;

                    if (!target3d) {
                        node.z = 0;
                        node.fz = 0;
                    } else if (lockPositionsAfterTransition) {
                        node.z = node.__z3d || node.z || 0;
                        node.fz = node.z;
                    } else {
                        delete node.fx;
                        delete node.fy;
                    }
                });

                Graph.numDimensions(target3d ? 3 : 2);

                // Restore simulation settings
                if (Graph && Graph.d3VelocityDecay && previousVelocityDecay !== null) {
                    Graph.d3VelocityDecay(previousVelocityDecay);
                }
                if (Graph && Graph.d3AlphaTarget && previousAlphaTarget !== null) {
                    Graph.d3AlphaTarget(previousAlphaTarget);
                }
                if (Graph && Graph.cooldownTicks && previousCooldownTicks !== null) {
                    Graph.cooldownTicks(previousCooldownTicks);
                }
                if (Graph && Graph.cooldownTime && previousCooldownTime !== null) {
                    Graph.cooldownTime(previousCooldownTime);
                }

                if (done) done();
            }
        };

        requestAnimationFrame(animate);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        toggle: toggle,
        setup: setup,
        animateChange: animateChange
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.toggleDimensions = DIMENSION.toggle;
window.setupDimensionToggle = DIMENSION.setup;
window.animateDimensionChange = DIMENSION.animateChange;

console.log('[Module] DIMENSION loaded - 3 functions');


// ═══ MODULE: modules/report.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * REPORT MODULE - Report panel, AI insights, and metrics display
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles the brain download report, AI insights panel, and metrics/KPI display.
 * Depends on: escapeHtml (from utils.js), DOM elements
 *
 * @module REPORT
 * @version 1.0.0
 */

window.REPORT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BRAIN DOWNLOAD REPORT
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the brain download report panel
     * @param {Object} data - Data object with brain_download field
     */
    function setupReport(data) {
        const panel = document.getElementById('report-panel');
        const content = document.getElementById('report-content');
        // Guard: elements may not exist in minimal template
        if (!content) return;
        const report = (data && data.brain_download) ? data.brain_download : '';
        content.textContent = report || 'No report available.';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // AI INSIGHTS PANEL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the AI insights panel
     * @param {Object} data - Data object with ai_insights field
     */
    function setupAIInsights(data) {
        const escapeHtml = window.escapeHtml || ((s) => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])));

        const panel = document.getElementById('insights-panel');
        const content = document.getElementById('insights-content');
        const btn = document.getElementById('btn-insights');

        const insights = (data && data.ai_insights) ? data.ai_insights : null;

        if (!insights) {
            // Hide the button if no insights available
            if (btn) btn.style.display = 'none';
            return;
        }

        // Show the button
        if (btn) btn.style.display = 'inline-flex';

        // Render insights
        let html = '';

        // Executive Summary
        if (insights.executive_summary) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Executive Summary</div>
                <div class="insights-summary">${escapeHtml(insights.executive_summary)}</div>
            </div>`;
        }

        // Patterns Detected
        if (insights.patterns_detected && insights.patterns_detected.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Patterns Detected</div>`;
            for (const pattern of insights.patterns_detected) {
                const confidencePercent = Math.round((pattern.confidence || 0) * 100);
                html += `<div class="insights-pattern">
                    <div class="insights-pattern-header">
                        <span class="insights-pattern-name">${escapeHtml(pattern.pattern_name || 'Unknown')}</span>
                        <span class="insights-pattern-type ${pattern.pattern_type || ''}">${escapeHtml(pattern.pattern_type || '')}</span>
                    </div>
                    <div class="insights-confidence">
                        <div class="insights-confidence-bar">
                            <div class="insights-confidence-fill" style="width: ${confidencePercent}%"></div>
                        </div>
                        <span>${confidencePercent}%</span>
                    </div>
                    ${pattern.evidence ? `<div class="insights-pattern-evidence">${escapeHtml(pattern.evidence)}</div>` : ''}
                    ${pattern.recommendation ? `<div class="insights-pattern-evidence" style="color: var(--color-accent-secondary);">Tip: ${escapeHtml(pattern.recommendation)}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Refactoring Opportunities
        if (insights.refactoring_opportunities && insights.refactoring_opportunities.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Refactoring Opportunities</div>`;
            for (const refactor of insights.refactoring_opportunities) {
                html += `<div class="insights-refactor">
                    <div class="insights-refactor-title">
                        ${escapeHtml(refactor.title || 'Untitled')}
                        <span class="insights-refactor-priority ${refactor.priority || 'LOW'}">${refactor.priority || 'LOW'}</span>
                    </div>
                    ${refactor.description ? `<div class="insights-refactor-desc">${escapeHtml(refactor.description)}</div>` : ''}
                    ${refactor.affected_files && refactor.affected_files.length > 0 ?
                        `<div class="insights-refactor-desc" style="margin-top: 4px; color: var(--color-text-muted);">Files: ${refactor.affected_files.slice(0, 3).map(f => escapeHtml(f)).join(', ')}${refactor.affected_files.length > 3 ? '...' : ''}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Topology Analysis
        if (insights.topology_analysis) {
            const topo = insights.topology_analysis;
            html += `<div class="insights-section">
                <div class="insights-section-title">Topology Analysis</div>
                ${topo.shape_interpretation ? `<div class="insights-summary">${escapeHtml(topo.shape_interpretation)}</div>` : ''}
                ${topo.health_assessment ? `<div class="insights-pattern-evidence">Health: ${escapeHtml(topo.health_assessment)}</div>` : ''}
                ${topo.coupling_analysis ? `<div class="insights-pattern-evidence">Coupling: ${escapeHtml(topo.coupling_analysis)}</div>` : ''}
            </div>`;
        }

        // Risk Areas
        if (insights.risk_areas && insights.risk_areas.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Risk Areas</div>`;
            for (const risk of insights.risk_areas) {
                html += `<div class="insights-risk">
                    <span class="insights-risk-level ${risk.risk_level || 'LOW'}">${risk.risk_level || 'LOW'}</span>
                    <div class="insights-risk-content">
                        <div class="insights-risk-area">${escapeHtml(risk.area || 'Unknown')}</div>
                        ${risk.description ? `<div class="insights-risk-desc">${escapeHtml(risk.description)}</div>` : ''}
                        ${risk.mitigation ? `<div class="insights-risk-desc" style="color: var(--color-accent-secondary); margin-top: 4px;">Tip: ${escapeHtml(risk.mitigation)}</div>` : ''}
                    </div>
                </div>`;
            }
            html += '</div>';
        }

        // Meta information
        if (insights.meta) {
            const meta = insights.meta;
            html += `<div class="insights-meta">
                Generated: ${meta.generated_at ? new Date(meta.generated_at).toLocaleString() : 'Unknown'}
                | Model: ${escapeHtml(meta.model || 'Unknown')}
                ${meta.confidence ? ` | Confidence: ${Math.round(meta.confidence * 100)}%` : ''}
            </div>`;
        }

        content.innerHTML = html || '<div class="insights-placeholder">No insights data available.</div>';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METRICS / KPI DISPLAY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup metrics and health indicators
     * @param {Object} data - Data object with kpis field
     */
    function setupMetrics(data) {
        const kpis = (data && data.kpis) ? data.kpis : {};

        const setText = (id, value) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = value;
        };

        const asNumber = (val) => {
            const num = Number(val);
            return Number.isFinite(num) ? num : null;
        };

        const formatPercent = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}%`;
        };

        const formatCount = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${Math.round(num)}`;
        };

        const formatScore = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}/10`;
        };

        // Set metric values
        setText('metric-edge-resolution', formatPercent(kpis.edge_resolution_percent));
        setText('metric-call-ratio', formatPercent(kpis.call_ratio_percent));
        setText('metric-reachability', formatPercent(kpis.reachability_percent));
        setText('metric-dead-code', formatPercent(kpis.dead_code_percent));
        setText('metric-knot-score', formatScore(kpis.knot_score));
        setText('metric-topology', kpis.topology_shape || 'UNKNOWN');
        setText('metric-orphans', formatCount(kpis.orphan_count));
        setText('metric-top-hubs', formatCount(kpis.top_hub_count));

        // Set health indicators (traffic light bars)
        const setHealth = (id, level) => {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('good', 'medium', 'bad', 'neutral');
                el.classList.add(level);
            }
        };

        // Edge Resolution: >90% good, 70-90% medium, <70% bad
        const edgeRes = asNumber(kpis.edge_resolution_percent);
        setHealth('health-edge-resolution', edgeRes === null ? 'neutral' : edgeRes >= 90 ? 'good' : edgeRes >= 70 ? 'medium' : 'bad');

        // Call Ratio: >60% good, 40-60% medium, <40% bad
        const callRatio = asNumber(kpis.call_ratio_percent);
        setHealth('health-call-ratio', callRatio === null ? 'neutral' : callRatio >= 60 ? 'good' : callRatio >= 40 ? 'medium' : 'bad');

        // Reachability: >90% good, 70-90% medium, <70% bad
        const reach = asNumber(kpis.reachability_percent);
        setHealth('health-reachability', reach === null ? 'neutral' : reach >= 90 ? 'good' : reach >= 70 ? 'medium' : 'bad');

        // Dead Code: <5% good, 5-15% medium, >15% bad (INVERTED - lower is better)
        const dead = asNumber(kpis.dead_code_percent);
        setHealth('health-dead-code', dead === null ? 'neutral' : dead <= 5 ? 'good' : dead <= 15 ? 'medium' : 'bad');

        // Knot Score: <3 good, 3-6 medium, >6 bad (INVERTED - lower is better)
        const knot = asNumber(kpis.knot_score);
        setHealth('health-knot-score', knot === null ? 'neutral' : knot <= 3 ? 'good' : knot <= 6 ? 'medium' : 'bad');

        // Topology: neutral (informational only)
        setHealth('health-topology', 'neutral');

        // Orphans: <10 good, 10-50 medium, >50 bad (INVERTED - lower is better)
        const orphans = asNumber(kpis.orphan_count);
        setHealth('health-orphans', orphans === null ? 'neutral' : orphans <= 10 ? 'good' : orphans <= 50 ? 'medium' : 'bad');

        // Top Hubs: neutral (informational only)
        setHealth('health-top-hubs', 'neutral');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupReport: setupReport,
        setupAIInsights: setupAIInsights,
        setupMetrics: setupMetrics
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupReport = REPORT.setupReport;
window.setupAIInsights = REPORT.setupAIInsights;
window.setupMetrics = REPORT.setupMetrics;

console.log('[Module] REPORT loaded - 3 functions');


// ═══ MODULE: modules/visibility.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VISIBILITY MODULE - UI visibility controls and filter utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles background brightness, metadata visibility, filter clearing,
 * and collapsible section management.
 * Depends on: Graph, APPEARANCE_STATE, VIS_FILTERS, THREE
 *
 * @module VISIBILITY
 * @version 1.0.0
 */

window.VISIBILITY = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BACKGROUND CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update background brightness based on APPEARANCE_STATE
     */
    function updateBackgroundBrightness() {
        const Graph = window.Graph;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const THREE = window.THREE;

        if (!Graph || !APPEARANCE_STATE.backgroundBase) return;
        const baseColor = new THREE.Color(APPEARANCE_STATE.backgroundBase);
        const brightness = APPEARANCE_STATE.backgroundBrightness ?? 1;
        const adjusted = baseColor.clone().multiplyScalar(brightness);
        Graph.backgroundColor(`#${adjusted.getHexString()}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA VISIBILITY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply metadata visibility settings (report panel, file panel, etc.)
     */
    function applyMetadataVisibility() {
        const VIS_FILTERS = window.VIS_FILTERS;

        const reportPanel = document.getElementById('report-panel');
        const reportButton = document.getElementById('btn-report');
        const filePanel = document.getElementById('file-panel');

        // Guard: elements may not exist in minimal template
        if (!reportPanel && !reportButton) return;

        if (!VIS_FILTERS.metadata.showReportPanel) {
            if (reportPanel) reportPanel.style.display = 'none';
            if (reportButton) {
                reportButton.classList.remove('active');
                reportButton.style.display = 'none';
            }
        } else {
            if (reportButton) reportButton.style.display = 'inline-flex';
        }
        if (!VIS_FILTERS.metadata.showFilePanel && filePanel) {
            filePanel.classList.remove('visible');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clear all dimension filters (tier, ring, family, role, file, edge)
     * Used for zero-node recovery and manual reset
     */
    function clearAllFilters() {
        const VIS_FILTERS = window.VIS_FILTERS;

        VIS_FILTERS.tiers.clear();
        VIS_FILTERS.rings.clear();
        VIS_FILTERS.families.clear();
        VIS_FILTERS.roles.clear();
        VIS_FILTERS.files.clear();
        VIS_FILTERS.edges.clear();
        VIS_FILTERS.layers.clear();
        VIS_FILTERS.effects.clear();
        VIS_FILTERS.edgeFamilies.clear();

        // Update legend UI
        document.querySelectorAll('.topo-legend-item.filtered').forEach(el => el.classList.remove('filtered'));

        // Update chip UI
        document.querySelectorAll('.filter-chip.active').forEach(el => el.classList.remove('active'));

        console.log('[Filters] All filters cleared');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLLAPSIBLE SECTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup collapsible sections in sidebar and panels
     */
    function setupCollapsibleSections() {
        // Standard sidebar sections
        const titles = document.querySelectorAll('.side-title.collapsible');
        titles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('collapsed', isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });

        // Topology section collapsibles (GEOMETRY panel)
        const topoTitles = document.querySelectorAll('.topo-section-title.collapsible');
        topoTitles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('expanded', !isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updateBackgroundBrightness: updateBackgroundBrightness,
        applyMetadataVisibility: applyMetadataVisibility,
        clearAllFilters: clearAllFilters,
        setupCollapsibleSections: setupCollapsibleSections
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateBackgroundBrightness = VISIBILITY.updateBackgroundBrightness;
window.applyMetadataVisibility = VISIBILITY.applyMetadataVisibility;
window.clearAllFilters = VISIBILITY.clearAllFilters;
window.setupCollapsibleSections = VISIBILITY.setupCollapsibleSections;

console.log('[Module] VISIBILITY loaded - 4 functions');


// ═══ MODULE: modules/animation.js ═══
/**
 * ANIMATION MODULE
 *
 * Unified animation controller for all layout transitions and continuous motions.
 * Addresses ARCH-002 (O(n^2) flock), ARCH-003 (unthrottled refresh), ARCH-004 (conflicts).
 *
 * Key improvements:
 * - Single animation ownership prevents conflicts
 * - Spatial hashing reduces flock from O(n^2) to O(n)
 * - Integration with REFRESH module for throttled updates
 *
 * Usage:
 *   ANIM.applyLayout('orbital')           // Apply a layout preset
 *   ANIM.stop()                           // Stop all animations
 *   ANIM.setStaggerPattern('radial')      // Change wave pattern
 */

const ANIM = (function () {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        baseDuration: 1200,      // Base animation duration (ms)
        staggerSpread: 800,      // Stagger spread (ms)
        flockMaxNodes: 500,      // Max nodes for flock simulation
        spatialGridSize: 50,     // Grid cell size for spatial hashing
        motionFrameSkip: 0       // Skip frames for motion (0 = no skip)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _currentLayout = 'force';
    let _animationId = null;
    let _layoutTime = 0;
    let _currentStaggerPattern = 'tier';
    let _owner = 'none';  // Current animation owner

    // =========================================================================
    // STAGGER PATTERNS - Wave-based node transitions
    // =========================================================================

    const STAGGER_PATTERNS = {
        // Radial ripple: center nodes move first, ripples outward
        radial: (node, startPos, targetPos) => {
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2 + startPos.z ** 2);
            return Math.min(1, dist / 500);
        },
        // Tier cascade: T0 first, then T1, then T2
        tier: (node) => {
            const tier = NODE.getTier(node);
            const tierNum = tier === 'T0' ? 0 : tier === 'T1' ? 1 : 2;
            return tierNum / 2;
        },
        // Distance-based: shortest travel first
        distance: (node, startPos, targetPos) => {
            const dx = targetPos.x - startPos.x;
            const dy = targetPos.y - startPos.y;
            const dz = targetPos.z - startPos.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            return Math.min(1, dist / 400);
        },
        // File grouping: nodes in same file move together
        file: (node) => {
            const fileIdx = node.fileIdx ?? 0;
            return (fileIdx % 8) / 8;
        },
        // Spiral pattern
        spiral: (node, startPos) => {
            const angle = Math.atan2(startPos.y, startPos.x);
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2);
            return ((angle + Math.PI) / (2 * Math.PI) + dist / 1000) % 1;
        },
        // Random stagger
        random: () => Math.random() * 0.6
    };

    // =========================================================================
    // LAYOUT PRESETS
    // =========================================================================

    const LAYOUT_PRESETS = {
        'force': {
            name: 'FORCE', icon: '?', description: 'Physics-based clustering',
            motion: 'settle', cooldown: 300, warmupTicks: 40, getPosition: null
        },
        'orbital': {
            name: 'ORBITAL', icon: '?', description: 'Planetary orbit bands',
            motion: 'orbit', cooldown: Infinity, orbitSpeed: 0.002,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const r = { T0: 80, T1: 160, T2: 280, UNKNOWN: 200 }[tier] || 200;
                const fOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const angle = (fOff / 5) * Math.PI * 2 + (idx / Math.max(1, total)) * Math.PI * 0.3 + (time || 0) * (0.5 + r * 0.001);
                const wobble = Math.sin(idx * 0.7 + (time || 0) * 2) * 15;
                return {
                    x: Math.cos(angle) * (r + wobble),
                    y: Math.sin(idx * 0.3) * 40 + (tier === 'T0' ? -50 : tier === 'T2' ? 50 : 0),
                    z: Math.sin(angle) * (r + wobble)
                };
            }
        },
        'radial': {
            name: 'RADIAL', icon: '?', description: 'Concentric tier rings',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total, time, tierGroups) => {
                const tier = NODE.getTier(node);
                const r = { T0: 60, T1: 150, T2: 280, UNKNOWN: 220 }[tier] || 180;
                const tierNodes = tierGroups?.[tier] || [];
                const tierIdx = tierNodes.indexOf(node);
                const tierTotal = tierNodes.length || 1;
                const angle = (tierIdx / tierTotal) * Math.PI * 2;
                return { x: Math.cos(angle) * r, y: 0, z: Math.sin(angle) * r };
            }
        },
        'spiral': {
            name: 'SPIRAL', icon: '?', description: 'DNA-like helix',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.003,
            getPosition: (node, idx, total, time) => {
                const t = idx / Math.max(1, total);
                const angle = t * Math.PI * 2 * 4 + (time || 0);
                const r = 100 + t * 150;
                return { x: Math.cos(angle) * r, y: (t - 0.5) * 400, z: Math.sin(angle) * r };
            }
        },
        'sphere': {
            name: 'SPHERE', icon: '?', description: 'Globe surface',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const latBase = { T0: 0.8, T1: 0.5, T2: 0.2, UNKNOWN: 0.5 }[tier] || 0.5;
                const lat = (latBase + (idx % 10) * 0.02) * Math.PI;
                const lonBase = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 180 }[family] || 0;
                const lon = ((lonBase + idx * 3) % 360) * Math.PI / 180 + (time || 0);
                const r = 200;
                return {
                    x: Math.sin(lat) * Math.cos(lon) * r,
                    y: Math.cos(lat) * r,
                    z: Math.sin(lat) * Math.sin(lon) * r
                };
            }
        },
        'grid': {
            name: 'GRID', icon: '?', description: '3D lattice',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const tierX = { T0: -150, T1: 0, T2: 150, UNKNOWN: 0 }[tier] || 0;
                const famZ = { LOG: -120, DAT: -60, ORG: 0, EXE: 60, EXT: 120, UNKNOWN: 0 }[family] || 0;
                const row = Math.floor(idx / 15);
                const col = idx % 15;
                return { x: tierX + (col - 7) * 20, y: row * 25 - 100, z: famZ + Math.sin(idx * 0.5) * 20 };
            }
        },
        'flock': {
            name: 'FLOCK', icon: '?', description: 'Swarming birds',
            motion: 'flock', cooldown: Infinity,
            flockParams: { separation: 25, alignment: 0.05, cohesion: 0.01, maxSpeed: 2 },
            getPosition: null
        },
        'galaxy': {
            name: 'GALAXY', icon: '?', description: 'Spiral arms',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const family = NODE.getFamily(node);
                const tier = NODE.getTier(node);
                const armOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const baseAngle = (armOff / 5) * Math.PI * 2;
                const dist = 50 + (idx / total) * 250;
                const spiralAngle = baseAngle + dist * 0.015 + (time || 0);
                const tierY = { T0: -30, T1: 0, T2: 30, UNKNOWN: 0 }[tier] || 0;
                return {
                    x: Math.cos(spiralAngle) * dist,
                    y: tierY + Math.sin(idx * 0.5) * 20,
                    z: Math.sin(spiralAngle) * dist
                };
            }
        }
    };

    // =========================================================================
    // SPATIAL HASHING - O(n) neighbor lookup for flock simulation
    // =========================================================================

    function _buildSpatialGrid(nodes, cellSize) {
        const grid = new Map();

        nodes.forEach((node, idx) => {
            const x = node.x || 0;
            const y = node.y || 0;
            const z = node.z || 0;

            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) {
                grid.set(key, []);
            }
            grid.get(key).push({ node, idx });
        });

        return grid;
    }

    function _getNeighborsFromGrid(grid, node, cellSize, radius) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);

        const neighbors = [];
        const cellRadius = Math.ceil(radius / cellSize);

        // Check neighboring cells
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                    const key = `${cellX + dx},${cellY + dy},${cellZ + dz}`;
                    const cell = grid.get(key);
                    if (cell) {
                        cell.forEach(entry => {
                            if (entry.node !== node) {
                                neighbors.push(entry.node);
                            }
                        });
                    }
                }
            }
        }

        return neighbors;
    }

    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================

    function _groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = NODE.getTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    function _acquireOwnership(owner) {
        // Cancel any existing animation
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = owner;
        return true;
    }

    function _releaseOwnership(owner) {
        if (_owner === owner) {
            if (_animationId) {
                cancelAnimationFrame(_animationId);
                _animationId = null;
            }
            _owner = 'none';
        }
    }

    // =========================================================================
    // LAYOUT APPLICATION
    // =========================================================================

    function applyLayout(presetKey, animate = true) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset) return;

        _currentLayout = presetKey;
        _acquireOwnership('layout');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);

        // Handle force layout specially
        if (presetKey === 'force') {
            nodes.forEach(n => {
                n.fx = undefined;
                n.fy = undefined;
                n.fz = undefined;
            });
            Graph.cooldownTicks(preset.cooldown);
            Graph.d3ReheatSimulation();
            _releaseOwnership('layout');
            if (typeof showModeToast === 'function') {
                showModeToast('? FORCE layout');
            }
            return;
        }

        // Handle flock specially
        if (preset.motion === 'flock') {
            _startFlockSimulation(preset.flockParams);
            Graph.cooldownTicks(preset.cooldown);
            if (typeof showModeToast === 'function') {
                showModeToast(`${preset.icon} ${preset.name} layout`);
            }
            return;
        }

        // Position-based layouts
        if (preset.getPosition) {
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => preset.getPosition(n, i, total, 0, tierGroups));

            if (animate && total > 100) {
                // STAGGERED ANIMATION for large graphs
                _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey);
            } else if (animate) {
                // SIMPLE ANIMATION for small graphs
                _animateSimple(nodes, startPos, targetPos, preset, presetKey);
            } else {
                // INSTANT
                nodes.forEach((n, i) => {
                    const p = targetPos[i];
                    n.fx = p.x;
                    n.fy = p.y;
                    n.fz = p.z;
                });
                if (typeof REFRESH !== 'undefined') {
                    REFRESH.force();
                } else if (Graph) {
                    REFRESH.throttled();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                }
            }
        }

        Graph.cooldownTicks(preset.cooldown);
        if (typeof showModeToast === 'function') {
            showModeToast(`${preset.icon} ${preset.name} layout`);
        }
    }

    function _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey) {
        const baseDuration = CONFIG.baseDuration;
        const staggerSpread = CONFIG.staggerSpread;
        const startTime = Date.now();

        // Hide edges during animation for performance
        Graph.linkOpacity(0);

        // Calculate delay for each node
        const pattern = STAGGER_PATTERNS[_currentStaggerPattern] || STAGGER_PATTERNS.tier;
        const delays = nodes.map((n, i) => pattern(n, startPos[i], targetPos[i]) * staggerSpread);

        function animateFrame() {
            if (_owner !== 'layout') return;

            const elapsed = Date.now() - startTime;

            nodes.forEach((n, i) => {
                const nodeStart = delays[i];
                const nodeElapsed = elapsed - nodeStart;

                if (nodeElapsed <= 0) {
                    n.fx = startPos[i].x;
                    n.fy = startPos[i].y;
                    n.fz = startPos[i].z;
                } else if (nodeElapsed >= baseDuration) {
                    n.fx = targetPos[i].x;
                    n.fy = targetPos[i].y;
                    n.fz = targetPos[i].z;
                } else {
                    const progress = nodeElapsed / baseDuration;
                    const eased = progress * progress * (3 - 2 * progress);
                    n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                    n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                    n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
                }
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            const totalDuration = baseDuration + staggerSpread;
            if (elapsed < totalDuration) {
                _animationId = requestAnimationFrame(animateFrame);
            } else {
                // Restore edges
                if (typeof applyEdgeMode === 'function') {
                    applyEdgeMode();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                } else {
                    _releaseOwnership('layout');
                }
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _animateSimple(nodes, startPos, targetPos, preset, presetKey) {
        const duration = 1500;
        const startTime = Date.now();

        function animateFrame() {
            if (_owner !== 'layout') return;

            const progress = Math.min(1, (Date.now() - startTime) / duration);
            const eased = progress * progress * (3 - 2 * progress);

            nodes.forEach((n, i) => {
                n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            if (progress < 1) {
                _animationId = requestAnimationFrame(animateFrame);
            } else if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                _startLayoutMotion(presetKey);
            } else {
                _releaseOwnership('layout');
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _startLayoutMotion(presetKey) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset || !preset.getPosition) return;

        _acquireOwnership('motion');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);
        const speed = preset.rotateSpeed || preset.orbitSpeed || 0.002;

        function animate() {
            if (_owner !== 'motion') return;

            _layoutTime += speed;

            nodes.forEach((n, i) => {
                const pos = preset.getPosition(n, i, total, _layoutTime, tierGroups);
                n.fx = pos.x;
                n.fy = pos.y;
                n.fz = pos.z;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(animate);
        }

        _animationId = requestAnimationFrame(animate);
    }

    // =========================================================================
    // FLOCK SIMULATION - O(n) with spatial hashing
    // =========================================================================

    function _startFlockSimulation(params) {
        const nodes = Graph?.graphData()?.nodes || [];

        // Performance guard
        if (nodes.length > CONFIG.flockMaxNodes) {
            console.warn(`[ANIM] Flock disabled: ${nodes.length} nodes exceeds ${CONFIG.flockMaxNodes} limit`);
            if (typeof showModeToast === 'function') {
                showModeToast('Warning: Flock disabled (too many nodes)');
            }
            return;
        }

        _acquireOwnership('flock');

        const { separation, alignment, cohesion, maxSpeed } = params;

        // Initialize velocities
        nodes.forEach(n => {
            n._vx = (Math.random() - 0.5) * 2;
            n._vy = (Math.random() - 0.5) * 2;
            n._vz = (Math.random() - 0.5) * 2;
        });

        function flockStep() {
            if (_owner !== 'flock') return;

            // Build spatial grid for O(n) neighbor lookup
            const grid = _buildSpatialGrid(nodes, CONFIG.spatialGridSize);
            const neighborRadius = separation * 3;

            nodes.forEach(n => {
                // Get nearby neighbors from spatial grid (O(1) per node)
                const neighbors = _getNeighborsFromGrid(grid, n, CONFIG.spatialGridSize, neighborRadius);

                let sepX = 0, sepY = 0, sepZ = 0, sepCount = 0;
                let alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;

                const myFamily = NODE.getFamily(n);

                neighbors.forEach(other => {
                    const dx = (other.x || 0) - (n.x || 0);
                    const dy = (other.y || 0) - (n.y || 0);
                    const dz = (other.z || 0) - (n.z || 0);
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 0.001;

                    // Separation
                    if (dist < separation * 2) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                        sepZ -= dz / dist;
                        sepCount++;
                    }

                    // Alignment and cohesion (same family only)
                    if (NODE.getFamily(other) === myFamily && dist < 150) {
                        alignX += other._vx || 0;
                        alignY += other._vy || 0;
                        alignZ += other._vz || 0;
                        alignCount++;

                        cohX += other.x || 0;
                        cohY += other.y || 0;
                        cohZ += other.z || 0;
                        cohCount++;
                    }
                });

                // Apply forces
                if (sepCount > 0) {
                    n._vx += (sepX / sepCount) * separation * 0.05;
                    n._vy += (sepY / sepCount) * separation * 0.05;
                    n._vz += (sepZ / sepCount) * separation * 0.05;
                }
                if (alignCount > 0) {
                    n._vx += ((alignX / alignCount) - n._vx) * alignment;
                    n._vy += ((alignY / alignCount) - n._vy) * alignment;
                    n._vz += ((alignZ / alignCount) - n._vz) * alignment;
                }
                if (cohCount > 0) {
                    n._vx += (cohX / cohCount - (n.x || 0)) * cohesion;
                    n._vy += (cohY / cohCount - (n.y || 0)) * cohesion;
                    n._vz += (cohZ / cohCount - (n.z || 0)) * cohesion;
                }

                // Center attraction
                n._vx -= (n.x || 0) * 0.0005;
                n._vy -= (n.y || 0) * 0.0005;
                n._vz -= (n.z || 0) * 0.0005;

                // Speed limit
                const speed = Math.sqrt(n._vx * n._vx + n._vy * n._vy + n._vz * n._vz);
                if (speed > maxSpeed) {
                    n._vx = (n._vx / speed) * maxSpeed;
                    n._vy = (n._vy / speed) * maxSpeed;
                    n._vz = (n._vz / speed) * maxSpeed;
                }

                // Update position
                n.fx = (n.x || 0) + n._vx;
                n.fy = (n.y || 0) + n._vy;
                n.fz = (n.z || 0) + n._vz;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                REFRESH.throttled();
            }

            _animationId = requestAnimationFrame(flockStep);
        }

        _animationId = requestAnimationFrame(flockStep);
    }

    // =========================================================================
    // PULSE ANIMATION
    // =========================================================================

    let _pulseId = null;

    function togglePulse(active) {
        if (active) {
            _startPulse();
        } else {
            _stopPulse();
        }
    }

    function _startPulse() {
        if (_pulseId) return;
        const startTime = Date.now();

        function loop() {
            const elapsed = Date.now() - startTime;
            // Oscillate lightness +/- 10%
            const val = Math.sin(elapsed * 0.003) * 10;

            if (typeof COLOR !== 'undefined') {
                COLOR.setTransform('lightnessShift', val);
                // Also breathe chroma a bit
                COLOR.setTransform('chromaScale', 1.0 + Math.sin(elapsed * 0.003) * 0.2);
            }

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof Graph !== 'undefined' && Graph) {
                // Determine if we need to force re-coloring or if just re-rendering canvas is enough.
                // Since transforms affect color calculation, we likely need to re-apply colors.
                if (typeof window.applyNodeColors === 'function') {
                    const nodes = Graph.graphData().nodes;
                    window.applyNodeColors(nodes);
                    Graph.nodeColor(Graph.nodeColor()); // Trigger internal update
                }
            }

            _pulseId = requestAnimationFrame(loop);
        }
        _pulseId = requestAnimationFrame(loop);
        if (typeof showModeToast === 'function') showModeToast('Pulse Animation ON');
    }

    function _stopPulse() {
        if (_pulseId) {
            cancelAnimationFrame(_pulseId);
            _pulseId = null;
        }
        // Reset
        if (typeof COLOR !== 'undefined') {
            COLOR.setTransform('lightnessShift', 0);
            COLOR.setTransform('chromaScale', 1.0);
        }

        // Final refresh to clear artifacts
        if (typeof window.applyNodeColors === 'function' && typeof Graph !== 'undefined') {
            const nodes = Graph.graphData().nodes;
            window.applyNodeColors(nodes);
            Graph.nodeColor(Graph.nodeColor());
        }

        if (typeof showModeToast === 'function') showModeToast('Pulse Animation OFF');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function stop() {
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = 'none';
    }

    function setStaggerPattern(pattern) {
        if (STAGGER_PATTERNS[pattern]) {
            _currentStaggerPattern = pattern;
            if (typeof showModeToast === 'function') {
                showModeToast(`Wave pattern: ${pattern.toUpperCase()}`);
            }
        }
    }

    function cycleStaggerPattern() {
        const patterns = Object.keys(STAGGER_PATTERNS);
        const currentIdx = patterns.indexOf(_currentStaggerPattern);
        _currentStaggerPattern = patterns[(currentIdx + 1) % patterns.length];
        if (typeof showModeToast === 'function') {
            showModeToast(`Wave pattern: ${_currentStaggerPattern.toUpperCase()}`);
        }
        return _currentStaggerPattern;
    }

    return {
        // Layout control
        applyLayout,
        stop,

        // Stagger patterns
        setStaggerPattern,
        cycleStaggerPattern,
        togglePulse, // Added to public API
        get staggerPattern() { return _currentStaggerPattern; },
        get staggerPatterns() { return Object.keys(STAGGER_PATTERNS); },

        // State
        get currentLayout() { return _currentLayout; },
        get isAnimating() { return _animationId !== null; },
        get owner() { return _owner; },

        // Layout presets
        presets: LAYOUT_PRESETS,

        // Config
        config: CONFIG
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// Note: CURRENT_LAYOUT, LAYOUT_ANIMATION_ID, LAYOUT_TIME, CURRENT_STAGGER_PATTERN
// are managed by app.js (separate animation system) - not duplicated here
Object.defineProperty(window, 'LAYOUT_PRESETS', { get: () => ANIM.presets, configurable: true });
Object.defineProperty(window, 'STAGGER_PATTERNS', { get: () => ANIM.staggerPatterns, configurable: true });

function applyLayoutPreset(presetKey, animate) {
    ANIM.applyLayout(presetKey, animate);
}

function cycleStaggerPattern() {
    ANIM.cycleStaggerPattern();
}

function startFlockSimulation(params) {
    // Handled internally by ANIM
    ANIM.applyLayout('flock');
}

function groupNodesByTier(nodes) {
    const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
    nodes.forEach(n => {
        const tier = NODE.getTier(n);
        (groups[tier] || groups.UNKNOWN).push(n);
    });
    return groups;
}


// ═══ MODULE: modules/selection.js ═══
/**
 * SELECTION MODULE
 *
 * Manages node selection, multi-select, marquee selection, and selection visuals.
 * Includes animated selection colors using OKLCH pendulum system.
 *
 * Depends on: CORE (PENDULUM, SELECTION_SIZE_MULT), NODE, COLOR
 *
 * Usage:
 *   SELECT.set([id1, id2])              // Set selection
 *   SELECT.toggle(node)                 // Toggle node selection
 *   SELECT.clear()                      // Clear selection
 *   SELECT.getSelectedNodes()           // Get selected node objects
 *   SELECT.ids                          // Get Set of selected IDs
 */

const SELECT = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    const _ids = new Set();
    let _marqueeActive = false;
    let _marqueeStart = null;
    let _marqueeAdditive = false;
    let _lastMarqueeEndTs = 0;

    // Selection visuals state
    const _selectionOriginals = new Map();
    const _originalColorsForDim = new Map();

    // THREE.js geometries (created lazily)
    let _selectionHaloGeometry = null;
    let _groupHaloGeometry = null;

    // =========================================================================
    // CORE SELECTION FUNCTIONS
    // =========================================================================

    /**
     * Get currently selected nodes
     */
    function getSelectedNodes() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return [];
        const nodes = Graph.graphData().nodes || [];
        return nodes.filter(node => node && node.id && _ids.has(node.id));
    }

    /**
     * Set selection (optionally additive)
     */
    function set(ids, additive = false) {
        if (!additive) {
            _ids.clear();
        }
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        // Use app.js's updateSelectionVisuals if available (has group halo logic)
        // Otherwise fall back to internal _updateVisuals
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Toggle a node's selection state
     */
    function toggle(node) {
        if (!node || !node.id) return;
        if (_ids.has(node.id)) {
            _ids.delete(node.id);
        } else {
            _ids.add(node.id);
        }
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Clear all selection
     */
    function clear() {
        _ids.clear();
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Maybe clear selection (with marquee debounce)
     */
    function maybeClear() {
        const now = Date.now();
        if (_marqueeActive) return;
        if (now - _lastMarqueeEndTs < 250) return;
        clear();
    }

    /**
     * Add nodes to selection
     */
    function add(ids) {
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Remove nodes from selection
     */
    function remove(ids) {
        (ids || []).forEach(id => {
            _ids.delete(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    // =========================================================================
    // OKLCH COLOR UTILITIES
    // =========================================================================

    function _oklchToHex(L, C, H) {
        const hRad = H * Math.PI / 180;
        const a = C * Math.cos(hRad);
        const b = C * Math.sin(hRad);

        const l_ = L / 100 + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L / 100 - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L / 100 - 0.0894841775 * a - 1.2914855480 * b;

        const l = l_ * l_ * l_;
        const m = m_ * m_ * m_;
        const s = s_ * s_ * s_;

        let rLin = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
        let gLin = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
        let bLin = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

        const gamma = x => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;

        let rOut = Math.round(gamma(rLin) * 255);
        let gOut = Math.round(gamma(gLin) * 255);
        let bOut = Math.round(gamma(bLin) * 255);

        rOut = Math.max(0, Math.min(255, rOut));
        gOut = Math.max(0, Math.min(255, gOut));
        bOut = Math.max(0, Math.min(255, bOut));

        return '#' + [rOut, gOut, bOut].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function _dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // =========================================================================
    // PENDULUM ANIMATION
    // =========================================================================

    function _updatePendulums(dt) {
        const PENDULUM = CORE.PENDULUM;
        const p1 = PENDULUM.hue;
        const p2 = PENDULUM.chroma;

        // Pendulum 1: Modulates hue rotation speed
        const accel1 = -(p1.gravity / p1.length) * Math.sin(p1.angle);
        p1.velocity += accel1 * dt;
        p1.velocity *= p1.damping;
        p1.angle += p1.velocity * dt;

        // Continuous hue rotation
        const speedMod = 1 + Math.sin(p1.angle) * 0.5;
        PENDULUM.currentHue = (PENDULUM.currentHue + p1.rotationSpeed * speedMod * (dt / 16)) % 360;

        // Pendulum 2: Chroma with coupling
        const coupling = 0.00015 * Math.sin(p1.angle);
        const accel2 = -(p2.gravity / p2.length) * Math.sin(p2.angle) + coupling;
        p2.velocity += accel2 * dt;
        p2.velocity *= p2.damping;
        p2.angle += p2.velocity * dt;

        // Lightness phase
        PENDULUM.lightness.phase += PENDULUM.lightness.speed * dt;
    }

    function _getSelectionColor(phaseOffset = 0) {
        const PENDULUM = CORE.PENDULUM;
        const p2 = PENDULUM.chroma;
        const p3 = PENDULUM.lightness;

        const H = (PENDULUM.currentHue + phaseOffset * 45) % 360;
        const C = Math.max(0.18, p2.center + Math.sin(p2.angle + phaseOffset * Math.PI * 2) * p2.amplitude);
        const L = p3.center + Math.sin(p3.phase + phaseOffset * Math.PI * 4) * p3.amplitude;

        return _oklchToHex(L, C, H);
    }

    function _getNodeSpatialPhase(node) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const distance = Math.sqrt(x * x + y * y + z * z);
        const PENDULUM = CORE.PENDULUM;
        const scale = PENDULUM.ripple ? (PENDULUM.ripple.scale || 200) : 200;
        const ripplePhase = (distance / scale) % 1;

        const angle = Math.atan2(y, x);
        const angularOffset = Math.sin(angle * 3) * 0.1;

        return (ripplePhase + angularOffset + 1) % 1;
    }

    function _animateSelectionColors(timestamp) {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) return;

        const dt = PENDULUM.lastTime ? Math.min(timestamp - PENDULUM.lastTime, 50) : 16;
        PENDULUM.lastTime = timestamp;

        _updatePendulums(dt);

        if (_ids.size > 0 && typeof Graph !== 'undefined' && Graph?.graphData) {
            const nodes = Graph.graphData().nodes || [];

            nodes.forEach(node => {
                if (_ids.has(node.id)) {
                    const spatialPhase = _getNodeSpatialPhase(node);
                    node.color = _getSelectionColor(spatialPhase);
                }
            });

            if (typeof toColorNumber === 'function') {
                Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
            }
        }

        requestAnimationFrame(_animateSelectionColors);
    }

    function startAnimation() {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) {
            PENDULUM.running = true;
            PENDULUM.hue.velocity = 0.02 + Math.random() * 0.01;
            PENDULUM.chroma.velocity = 0.015 + Math.random() * 0.01;
            PENDULUM.lastTime = 0;
            requestAnimationFrame(_animateSelectionColors);
        }
    }

    function stopAnimation() {
        CORE.PENDULUM.running = false;
    }

    // =========================================================================
    // VISUAL UPDATES
    // =========================================================================

    function _updateVisuals() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;

        const nodes = Graph.graphData().nodes || [];
        const hasSelection = _ids.size > 0;
        const SELECTION_SIZE_MULT = CORE.SELECTION_SIZE_MULT;

        nodes.forEach(node => {
            const isSelected = _ids.has(node.id);

            // Save original for restoration
            if (hasSelection && !_originalColorsForDim.has(node.id)) {
                _originalColorsForDim.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            if (isSelected && !_selectionOriginals.has(node.id)) {
                _selectionOriginals.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            // Apply styling
            if (hasSelection) {
                if (isSelected) {
                    const orig = _selectionOriginals.get(node.id);
                    node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
                } else {
                    const orig = _originalColorsForDim.get(node.id);
                    if (orig) {
                        node.color = _dimColor(orig.color, 0.5);
                        node.val = orig.val * 0.7;
                    }
                }
            } else {
                // Restore originals
                const orig = _originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = orig.color;
                    node.val = orig.val;
                }
            }

            // Update halo visibility
            if (node.__selectionHalo) {
                node.__selectionHalo.visible = isSelected;
            }
        });

        // Handle animation state
        if (hasSelection) {
            startAnimation();
        } else {
            stopAnimation();
            _selectionOriginals.clear();
            _originalColorsForDim.clear();
        }

        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (Graph) {
            REFRESH.throttled();
        }
    }

    function _updatePanel() {
        if (typeof updateSelectionPanel === 'function') {
            updateSelectionPanel();
        }
    }

    function _updateGroupButtonState() {
        if (typeof updateGroupButtonState === 'function') {
            updateGroupButtonState();
        }
    }

    // =========================================================================
    // NODE OVERLAYS (3D halos)
    // =========================================================================

    function ensureOverlays(node) {
        if (!node) return null;
        if (node.__overlayGroup) return node.__overlayGroup;

        // Lazy init geometry
        if (!_selectionHaloGeometry) {
            _selectionHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
            _groupHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
        }

        const group = new THREE.Group();

        const selectionMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
        });
        const selectionHalo = new THREE.Mesh(_selectionHaloGeometry, selectionMaterial);
        selectionHalo.visible = false;
        selectionHalo.renderOrder = 3;

        const groupMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.45,
            depthWrite: false
        });
        const groupHalo = new THREE.Mesh(_groupHaloGeometry, groupMaterial);
        groupHalo.visible = false;
        groupHalo.renderOrder = 2;

        group.add(selectionHalo);
        group.add(groupHalo);

        node.__selectionHalo = selectionHalo;
        node.__groupHalo = groupHalo;
        node.__overlayGroup = group;

        return group;
    }

    function updateOverlayScale(node) {
        const APPEARANCE_STATE = typeof window !== 'undefined' ? window.APPEARANCE_STATE : { nodeScale: 1 };
        const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE?.nodeScale || 1));
        const selectionScale = base * 2.5;
        const groupScale = base * 1.8;

        if (node.__selectionHalo) {
            node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
        }
        if (node.__groupHalo) {
            node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
        }
    }

    // =========================================================================
    // MARQUEE STATE
    // =========================================================================

    function setMarqueeActive(active) {
        _marqueeActive = active;
        if (!active) {
            _lastMarqueeEndTs = Date.now();
        }
    }

    function setMarqueeStart(pos) {
        _marqueeStart = pos;
    }

    function setMarqueeAdditive(additive) {
        _marqueeAdditive = additive;
    }

    // =========================================================================
    // UI HELPERS
    // =========================================================================

    function formatCountList(items, limit = 4) {
        return items.slice(0, limit).map(([key, count]) => `${key} ${count}`).join(' · ') || '--';
    }

    function appendSelectionRow(container, label, value) {
        const row = document.createElement('div');
        row.className = 'selection-row';
        const labelEl = document.createElement('span');
        labelEl.className = 'label';
        labelEl.textContent = label;
        const valueEl = document.createElement('span');
        valueEl.textContent = value || '--';
        row.appendChild(labelEl);
        row.appendChild(valueEl);
        container.appendChild(row);
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel() {
        const panel = document.getElementById('selection-panel');
        const body = document.getElementById('selection-body');
        const title = document.getElementById('selection-title');
        if (!panel || !body) return;

        const nodes = getSelectedNodes();
        if (!nodes.length) {
            panel.classList.remove('visible');
            body.innerHTML = '';
            return;
        }

        panel.classList.add('visible');
        if (title) title.textContent = `SELECTION (${nodes.length})`;
        body.innerHTML = '';

        if (nodes.length <= 3) {
            nodes.forEach(node => {
                const item = document.createElement('div');
                item.className = 'selection-item';
                const name = document.createElement('div');
                name.className = 'selection-name';
                name.textContent = node.name || node.id || 'Unknown';
                item.appendChild(name);
                appendSelectionRow(item, 'Family', typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--');
                appendSelectionRow(item, 'Ring', typeof getNodeRing === 'function' ? getNodeRing(node) : '--');
                appendSelectionRow(item, 'Tier', typeof getNodeTier === 'function' ? getNodeTier(node) : '--');
                appendSelectionRow(item, 'Role', node.role || '--');
                const filePath = node.file_path || node.file || '';
                if (filePath) {
                    const shortPath = filePath.length > 48 ? '...' + filePath.slice(-45) : filePath;
                    appendSelectionRow(item, 'File', shortPath);
                }
                body.appendChild(item);
            });
        } else {
            const summary = document.createElement('div');
            summary.className = 'selection-summary';

            const families = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(n) : '--') : [];
            const rings = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeRing === 'function' ? getNodeRing(n) : '--') : [];
            const tiers = typeof collectCounts === 'function' ? collectCounts(nodes, n => typeof getNodeTier === 'function' ? getNodeTier(n) : '--') : [];

            const total = document.createElement('div');
            total.textContent = `Total: ${nodes.length} nodes`;
            summary.appendChild(total);

            const familyRow = document.createElement('div');
            familyRow.textContent = `Family: ${formatCountList(families)}`;
            summary.appendChild(familyRow);

            const ringRow = document.createElement('div');
            ringRow.textContent = `Ring: ${formatCountList(rings)}`;
            summary.appendChild(ringRow);

            const tierRow = document.createElement('div');
            tierRow.textContent = `Tier: ${formatCountList(tiers)}`;
            summary.appendChild(tierRow);

            const numericKeys = [
                ['tokens', 'TOKENS'],
                ['bytes', 'BYTES'],
                ['loc', 'LOC'],
                ['lines', 'LINES'],
                ['lines_of_code', 'LOC'],
                ['size', 'SIZE']
            ];
            const totals = {};
            nodes.forEach(node => {
                numericKeys.forEach(([key]) => {
                    const value = Number(node[key]);
                    if (Number.isFinite(value)) {
                        totals[key] = (totals[key] || 0) + value;
                    }
                });
            });
            numericKeys.forEach(([key, label]) => {
                if (totals[key]) {
                    const row = document.createElement('div');
                    row.textContent = `${label}: ${Math.round(totals[key])}`;
                    summary.appendChild(row);
                }
            });

            body.appendChild(summary);
        }

        if (typeof HudLayoutManager !== 'undefined' && HudLayoutManager.reflow) {
            HudLayoutManager.reflow();
        }
    }

    // =========================================================================
    // SELECTION MODAL
    // =========================================================================

    function showSelectionModal() {
        const nodes = getSelectedNodes();
        if (!nodes.length) {
            if (typeof showToast === 'function') showToast('No nodes selected');
            return;
        }

        const overlay = document.getElementById('selection-modal-overlay');
        const title = document.getElementById('selection-modal-title');
        const statsContainer = document.getElementById('selection-modal-stats');
        const body = document.getElementById('selection-modal-body');

        if (!overlay || !body) return;

        // Calculate aggregates
        let totalTokens = 0, totalBytes = 0, totalLoc = 0;
        const tierCounts = {};
        const ringCounts = {};
        const familyCounts = {};

        nodes.forEach(node => {
            totalTokens += Number(node.tokens) || 0;
            totalBytes += Number(node.bytes) || 0;
            totalLoc += Number(node.loc || node.lines || node.lines_of_code) || 0;

            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';

            tierCounts[tier] = (tierCounts[tier] || 0) + 1;
            ringCounts[ring] = (ringCounts[ring] || 0) + 1;
            familyCounts[family] = (familyCounts[family] || 0) + 1;
        });

        const maxVal = Math.max(...nodes.map(n => n.val || n.size || 1));

        title.textContent = `SELECTED NODES (${nodes.length})`;

        // Build stats bar
        statsContainer.innerHTML = '';
        const stats = [
            ['NODES', nodes.length.toLocaleString()],
            ['TOKENS', totalTokens.toLocaleString()],
            ['BYTES', totalBytes.toLocaleString()],
            ['LOC', totalLoc.toLocaleString()],
            ['TIERS', Object.keys(tierCounts).join(', ')],
            ['FAMILIES', Object.keys(familyCounts).length]
        ];
        stats.forEach(([label, value]) => {
            if (value && value !== '0') {
                const stat = document.createElement('div');
                stat.className = 'selection-modal-stat';
                stat.innerHTML = `
                    <span class="selection-modal-stat-label">${label}</span>
                    <span class="selection-modal-stat-value">${value}</span>
                `;
                statsContainer.appendChild(stat);
            }
        });

        // Build table
        const sortedNodes = [...nodes].sort((a, b) => (b.val || b.size || 1) - (a.val || a.size || 1));

        body.innerHTML = `
            <table class="selection-modal-table">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Tier</th>
                        <th>Ring</th>
                        <th>Family</th>
                        <th>Level</th>
                        <th>Tokens</th>
                        <th>LOC</th>
                        <th>Relevance</th>
                    </tr>
                </thead>
                <tbody id="selection-modal-tbody"></tbody>
            </table>
        `;

        const tbody = document.getElementById('selection-modal-tbody');
        sortedNodes.forEach(node => {
            const tier = typeof getNodeTier === 'function' ? getNodeTier(node) : '--';
            const ring = typeof getNodeRing === 'function' ? getNodeRing(node) : '--';
            const family = typeof getNodeAtomFamily === 'function' ? getNodeAtomFamily(node) : '--';
            const level = node.level || node.scale_level || 'L3';
            const tokens = Number(node.tokens) || '--';
            const loc = Number(node.loc || node.lines || node.lines_of_code) || '--';
            const relevance = ((node.val || node.size || 1) / maxVal * 100).toFixed(0);

            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="node-name" title="${node.name || node.id}">${node.name || node.id}</td>
                <td><span class="level-badge tier-badge">${tier}</span></td>
                <td><span class="level-badge ring-badge">${ring}</span></td>
                <td><span class="level-badge family-badge">${family}</span></td>
                <td>${level}</td>
                <td class="numeric">${typeof tokens === 'number' ? tokens.toLocaleString() : tokens}</td>
                <td class="numeric">${typeof loc === 'number' ? loc.toLocaleString() : loc}</td>
                <td>
                    <div class="relevance-bar">
                        <div class="relevance-fill" style="width: ${relevance}%"></div>
                    </div>
                </td>
            `;
            tbody.appendChild(row);
        });

        overlay.classList.add('visible');
    }

    function hideSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        if (overlay) overlay.classList.remove('visible');
    }

    function initSelectionModal() {
        const overlay = document.getElementById('selection-modal-overlay');
        const closeBtn = document.getElementById('selection-modal-close');
        const selectionTitle = document.getElementById('selection-title');

        if (closeBtn) {
            closeBtn.addEventListener('click', hideSelectionModal);
        }

        if (overlay) {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) hideSelectionModal();
            });
        }

        if (selectionTitle) {
            selectionTitle.style.cursor = 'pointer';
            selectionTitle.addEventListener('click', showSelectionModal);
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey) {
                const activeEl = document.activeElement;
                if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
                if (getSelectedNodes().length > 0) {
                    e.preventDefault();
                    showSelectionModal();
                }
            }
            if (e.key === 'Escape') {
                hideSelectionModal();
            }
        });
    }

    // =========================================================================
    // SELECTION BOX / MARQUEE
    // =========================================================================

    let _selectionBox = null;

    function updateSelectionBox(rect) {
        if (!_selectionBox) _selectionBox = document.getElementById('selection-box');
        if (!_selectionBox) return;
        _selectionBox.style.display = 'block';
        _selectionBox.style.left = `${rect.left}px`;
        _selectionBox.style.top = `${rect.top}px`;
        _selectionBox.style.width = `${rect.width}px`;
        _selectionBox.style.height = `${rect.height}px`;
    }

    function getNodeScreenPosition(node) {
        if (typeof Graph === 'undefined' || !Graph?.camera || !node) return null;
        if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return null;
        const camera = Graph.camera();
        const vector = new THREE.Vector3(node.x, node.y, node.z || 0);
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        return { x, y };
    }

    function selectNodesInBox(rect, additive = true) {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const nodes = Graph.graphData().nodes || [];
        const selected = [];
        nodes.forEach(node => {
            const pos = getNodeScreenPosition(node);
            if (!pos) return;
            if (pos.x >= rect.left && pos.x <= rect.right &&
                pos.y >= rect.top && pos.y <= rect.bottom) {
                if (node.id) selected.push(node.id);
            }
        });
        if (selected.length) {
            set(selected, additive);
        }
    }

    function setupSelectionInteractions() {
        const clearBtn = document.getElementById('selection-clear');
        if (clearBtn) {
            clearBtn.onclick = () => clear();
        }

        const groupBtn = document.getElementById('btn-create-group');
        if (groupBtn && typeof createGroupFromSelection === 'function') {
            groupBtn.onclick = () => createGroupFromSelection();
        }

        _selectionBox = document.getElementById('selection-box');
        if (typeof Graph === 'undefined' || !Graph?.renderer || !_selectionBox) return;

        const canvas = Graph.renderer().domElement;
        if (!canvas) return;

        const onPointerDown = (e) => {
            if (e.button !== 0) return;
            if (typeof SPACE_PRESSED !== 'undefined' && SPACE_PRESSED) return;
            if (e.target !== canvas) return;
            if (typeof HOVERED_NODE !== 'undefined' && HOVERED_NODE) return;
            _marqueeActive = true;
            _marqueeAdditive = !!e.shiftKey;
            _marqueeStart = { x: e.clientX, y: e.clientY };
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, _marqueeStart) : { left: e.clientX, top: e.clientY, width: 0, height: 0 });
            if (Graph.controls()) {
                Graph.controls().enabled = false;
            }
            e.preventDefault();
        };

        const onPointerMove = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            updateSelectionBox(typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) });
        };

        const finishSelection = (e) => {
            if (!_marqueeActive || !_marqueeStart) return;
            const rect = typeof getBoxRect === 'function' ? getBoxRect(_marqueeStart, { x: e.clientX, y: e.clientY }) : { left: Math.min(_marqueeStart.x, e.clientX), top: Math.min(_marqueeStart.y, e.clientY), width: Math.abs(e.clientX - _marqueeStart.x), height: Math.abs(e.clientY - _marqueeStart.y), right: Math.max(_marqueeStart.x, e.clientX), bottom: Math.max(_marqueeStart.y, e.clientY) };
            _selectionBox.style.display = 'none';
            const additive = _marqueeAdditive;
            _marqueeActive = false;
            _marqueeStart = null;
            _marqueeAdditive = false;
            _lastMarqueeEndTs = Date.now();
            if (Graph.controls()) {
                Graph.controls().enabled = true;
            }
            const didDrag = rect.width > 4 && rect.height > 4;
            if (didDrag) {
                selectNodesInBox(rect, additive);
            }
        };

        canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
        canvas.addEventListener('pointermove', onPointerMove, { passive: true });
        canvas.addEventListener('pointerup', finishSelection, { passive: true });
        canvas.addEventListener('pointerleave', finishSelection, { passive: true });
    }

    // =========================================================================
    // SYNC AND INIT
    // =========================================================================

    function syncSelectionAfterGraphUpdate() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;
        const visibleIds = new Set((Graph.graphData().nodes || []).map(n => n.id));
        const idsToRemove = [];
        Array.from(_ids).forEach(id => {
            if (!visibleIds.has(id)) {
                idsToRemove.push(id);
            }
        });
        if (idsToRemove.length > 0) {
            remove(idsToRemove);
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    function initSelectionState(data) {
        if (typeof buildDatasetKey === 'function') {
            window.DATASET_KEY = buildDatasetKey(data);
            window.GROUPS_STORAGE_KEY = `collider_groups_${window.DATASET_KEY}`;
        }
        if (typeof loadGroups === 'function') loadGroups();
        if (typeof renderGroupList === 'function') renderGroupList();
        updateSelectionPanel();
        _updateGroupButtonState();
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core selection
        set,
        toggle,
        clear,
        maybeClear,
        add,
        remove,
        getSelectedNodes,

        // State access
        get ids() { return _ids; },
        get size() { return _ids.size; },
        has(id) { return _ids.has(id); },

        // Animation
        startAnimation,
        stopAnimation,

        // Overlays
        ensureOverlays,
        updateOverlayScale,

        // Marquee
        setMarqueeActive,
        setMarqueeStart,
        setMarqueeAdditive,
        get marqueeActive() { return _marqueeActive; },
        get marqueeStart() { return _marqueeStart; },
        get marqueeAdditive() { return _marqueeAdditive; },
        get lastMarqueeEndTs() { return _lastMarqueeEndTs; },

        // Internal access (for migration)
        _selectionOriginals,
        _originalColorsForDim,

        // UI (moved from app.js)
        updateSelectionPanel,
        showSelectionModal,
        hideSelectionModal,
        initSelectionModal,
        updateSelectionBox,
        getNodeScreenPosition,
        selectNodesInBox,
        setupSelectionInteractions,
        syncSelectionAfterGraphUpdate,
        initSelectionState
    };
})();

// Backward compatibility aliases - Using getters to ensure live updates
// Note: All variables use Object.defineProperty to avoid duplicate declarations with app.js
// SELECTED_NODE_IDS - selection.js is now the SINGLE SOURCE OF TRUTH (unified in modularization)
Object.defineProperty(window, 'SELECTED_NODE_IDS', { get: () => SELECT.ids, configurable: true });
Object.defineProperty(window, 'MARQUEE_ACTIVE', { get: () => SELECT.marqueeActive, configurable: true });
Object.defineProperty(window, 'MARQUEE_START', { get: () => SELECT.marqueeStart, configurable: true });
Object.defineProperty(window, 'MARQUEE_ADDITIVE', { get: () => SELECT.marqueeAdditive, configurable: true });
Object.defineProperty(window, 'LAST_MARQUEE_END_TS', { get: () => SELECT.lastMarqueeEndTs, configurable: true });
// selectionOriginals, originalColorsForDim - app.js owns these, not duplicated here

function getSelectedNodes() { return SELECT.getSelectedNodes(); }
function setSelection(ids, additive) { SELECT.set(ids, additive); }
function toggleSelection(node) { SELECT.toggle(node); }
function clearSelection() { SELECT.clear(); }
function maybeClearSelection() { SELECT.maybeClear(); }
function startSelectionAnimation() { SELECT.startAnimation(); }
function stopSelectionAnimation() { SELECT.stopAnimation(); }
function ensureNodeOverlays(node) { return SELECT.ensureOverlays(node); }
function updateOverlayScale(node) { SELECT.updateOverlayScale(node); }

// UI functions (moved from app.js)
function updateSelectionPanel() { SELECT.updateSelectionPanel(); }
function showSelectionModal() { SELECT.showSelectionModal(); }
function hideSelectionModal() { SELECT.hideSelectionModal(); }
function initSelectionModal() { SELECT.initSelectionModal(); }
function updateSelectionBox(rect) { SELECT.updateSelectionBox(rect); }
function getNodeScreenPosition(node) { return SELECT.getNodeScreenPosition(node); }
function selectNodesInBox(rect, additive) { SELECT.selectNodesInBox(rect, additive); }
function setupSelectionInteractions() { SELECT.setupSelectionInteractions(); }
function syncSelectionAfterGraphUpdate() { SELECT.syncSelectionAfterGraphUpdate(); }
function initSelectionState(data) { SELECT.initSelectionState(data); }

console.log('[Module] SELECT loaded - selection UI, modal, marquee, animation');


// ═══ MODULE: modules/panels.js ═══
/**
 * PANELS MODULE
 *
 * Manages floating panels and HUD layout for the visualization.
 * Handles panel open/close, command bar, and UI dimming.
 *
 * Usage:
 *   PANELS.open('view')       // Open a panel
 *   PANELS.close('view')      // Close a panel
 *   PANELS.toggle('view')     // Toggle panel visibility
 *   PANELS.initCommandBar()   // Wire up command bar buttons
 */

const PANELS = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _activePanelId = null;

    // =========================================================================
    // PANEL FUNCTIONS
    // =========================================================================

    /**
     * Open a panel by ID
     */
    function open(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        // Close any already-open panel
        if (_activePanelId && _activePanelId !== panelId) {
            close(_activePanelId);
        }

        if (panel) {
            panel.classList.add('visible');
            setTimeout(() => { panel.style.opacity = '1'; }, 10);
        }
        if (btn) btn.classList.add('active');
        _activePanelId = panelId;

        // Dim the universe when panel opens
        document.body.classList.add('ui-active');

        // Dim starfield via JS
        if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
            const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
            STARFIELD.material.opacity = baseOpacity * 0.3;
        }
    }

    /**
     * Close a panel by ID
     */
    function close(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        if (panel) {
            panel.classList.remove('visible');
        }
        if (btn) btn.classList.remove('active');
        if (_activePanelId === panelId) _activePanelId = null;

        // Restore universe when all panels closed
        if (!_activePanelId) {
            document.body.classList.remove('ui-active');

            // Restore starfield
            if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
                const starsBtn = document.getElementById('btn-stars');
                const starsVisible = starsBtn && starsBtn.classList.contains('active');
                const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
                STARFIELD.material.opacity = starsVisible ? baseOpacity : 0;
            }
        }
    }

    /**
     * Toggle a panel
     */
    function toggle(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        if (panel && panel.classList.contains('visible')) {
            close(panelId);
        } else {
            open(panelId);
        }
    }

    /**
     * Get active panel ID
     */
    function getActive() {
        return _activePanelId;
    }

    // =========================================================================
    // COMMAND BAR INITIALIZATION
    // =========================================================================

    function initCommandBar() {
        const cmdBtns = {
            'cmd-view': 'view',
            'cmd-filter': 'filter',
            'cmd-style': 'style',
            'cmd-settings': 'settings'
        };

        Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', () => toggle(panelId));
            }
        });

        // Settings panel: Oval margin slider
        _initOvalMarginSlider();
        _initOvalDebugToggle();

        // Style panel sliders (consolidated from app.js)
        _initStylePanelSliders();
        _initToggleSwitches();
        _initSegmentedControls();
        _initCommandBarActions();
    }

    // ═══════════════════════════════════════════════════════════════════
    // STYLE PANEL SLIDERS - Connected to appearance system
    // ═══════════════════════════════════════════════════════════════════

    function _initStylePanelSliders() {
        // Node Size Slider
        const nodeSizeSlider = document.getElementById('node-size-slider');
        const nodeSizeValue = document.getElementById('node-size-value');
        if (nodeSizeSlider) {
            nodeSizeSlider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                if (nodeSizeValue) nodeSizeValue.textContent = val.toFixed(1) + 'x';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.nodeVal(node => (node.val || node.size || 1) * val);
                }
            });
        }

        // Edge Opacity Slider
        const edgeOpacitySlider = document.getElementById('edge-opacity-slider');
        const edgeOpacityValue = document.getElementById('edge-opacity-value');
        if (edgeOpacitySlider) {
            edgeOpacitySlider.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (edgeOpacityValue) edgeOpacityValue.textContent = val + '%';
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val / 100;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
            });
        }

        // Density Slider (filter panel) - NOTE: #density-slider2 not in current HTML template
        // Code retained for future filter panel implementation
        const densitySlider2 = document.getElementById('density-slider2');
        const densityValue2 = document.getElementById('density-value2');
        if (densitySlider2) {
            densitySlider2.addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                if (densityValue2) densityValue2.textContent = val + '%';
                if (typeof CURRENT_DENSITY !== 'undefined') window.CURRENT_DENSITY = val;
                if (typeof refreshGraph === 'function') refreshGraph();
            });
        }
    }

    function _initToggleSwitches() {
        document.querySelectorAll('.toggle-switch').forEach(toggle => {
            toggle.addEventListener('click', () => {
                toggle.classList.toggle('active');
            });
        });
    }

    function _initSegmentedControls() {
        document.querySelectorAll('.segmented-control').forEach(control => {
            control.querySelectorAll('.segment').forEach(segment => {
                segment.addEventListener('click', () => {
                    control.querySelectorAll('.segment').forEach(s => s.classList.remove('active'));
                    segment.classList.add('active');

                    // Handle dimension change
                    if (control.id === 'dim-control') {
                        const dim = segment.dataset.dim;
                        if (typeof IS_3D !== 'undefined') {
                            window.IS_3D = (dim !== '2');
                            if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                        }
                    }

                    // Handle node color mode
                    if (control.id === 'node-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode && typeof setNodeColorMode === 'function') {
                            setNodeColorMode(mode);
                        }
                    }

                    // Handle edge color mode
                    if (control.id === 'edge-color-control') {
                        const mode = segment.dataset.mode;
                        if (mode) {
                            if (typeof EDGE_MODE !== 'undefined') window.EDGE_MODE = mode;
                            if (typeof applyEdgeMode === 'function') applyEdgeMode();
                        }
                    }

                    // Handle panel layout
                    if (control.id === 'layout-control') {
                        const layout = segment.dataset.layout;
                        if (layout) {
                            document.body.setAttribute('data-layout', layout);
                        }
                    }
                });
            });
        });
    }

    function _initCommandBarActions() {
        // Skip if REGISTRY not available (defensive)
        if (typeof REGISTRY === 'undefined' || !REGISTRY.register) return;

        // File mode toggle
        REGISTRY.register('cmd-files2', () => {
            if (typeof setFileModeState === 'function') {
                const newState = typeof fileMode !== 'undefined' ? !fileMode : true;
                setFileModeState(newState);
                const btn = document.getElementById('cmd-files2');
                if (btn) btn.classList.toggle('active', newState);
            }
        }, { desc: 'Toggle File Boundaries Mode' });

        // Flow mode toggle
        REGISTRY.register('cmd-flow2', () => {
            if (typeof toggleFlowMode === 'function') {
                toggleFlowMode();
                const btn = document.getElementById('cmd-flow2');
                if (btn && typeof flowMode !== 'undefined') btn.classList.toggle('active', flowMode);
            }
        }, { desc: 'Toggle Flow Mode' });

        // 3D toggle
        REGISTRY.register('cmd-3d', () => {
            if (typeof toggleDimensions === 'function') {
                toggleDimensions();
            } else if (typeof IS_3D !== 'undefined') {
                window.IS_3D = !window.IS_3D;
                if (typeof Graph !== 'undefined' && Graph) Graph.numDimensions(window.IS_3D ? 3 : 2);
                const btnDim = document.getElementById('btn-dimensions');
                if (btnDim) btnDim.textContent = window.IS_3D ? '2D' : '3D';
            }
            const btn = document.getElementById('cmd-3d');
            if (btn && typeof IS_3D !== 'undefined') btn.classList.toggle('active', window.IS_3D);

            // Update dim-control if exists
            const dimControl = document.getElementById('dim-control');
            if (dimControl && typeof IS_3D !== 'undefined') {
                dimControl.querySelectorAll('.segment').forEach(s => {
                    s.classList.toggle('active', s.dataset.dim === (window.IS_3D ? '3' : '2'));
                });
            }
        }, { desc: 'Toggle 2D/3D View' });

        console.log('[PANELS] Command bar actions registered');
    }

    function _initOvalMarginSlider() {
        const ovalSlider = document.getElementById('oval-margin-slider');
        const ovalValue = document.getElementById('oval-margin-value');
        let ovalDebounceTimer = null;

        if (ovalSlider) {
            ovalSlider.addEventListener('input', (e) => {
                if (ovalValue) ovalValue.textContent = e.target.value + '%';
            });

            const applyOvalMargin = () => {
                clearTimeout(ovalDebounceTimer);
                ovalDebounceTimer = setTimeout(() => {
                    const val = ovalSlider.value;
                    document.documentElement.style.setProperty('--oval-margin', val + '%');
                }, 300);
            };

            ovalSlider.addEventListener('mouseup', applyOvalMargin);
            ovalSlider.addEventListener('touchend', applyOvalMargin);
            ovalSlider.addEventListener('change', applyOvalMargin);
        }
    }

    function _initOvalDebugToggle() {
        const toggleOvalDebug = document.getElementById('toggle-oval-debug');
        if (toggleOvalDebug) {
            toggleOvalDebug.addEventListener('click', () => {
                toggleOvalDebug.classList.toggle('active');
                const ovalDebug = document.querySelector('.oval-debug');
                if (ovalDebug) {
                    ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
                }
            });
        }
    }

    // =========================================================================
    // HUD LAYOUT MANAGER - REMOVED, USE LAYOUT MODULE
    // =========================================================================
    // The HudLayoutManager has been unified into modules/layout.js
    // Use LAYOUT.reflow() instead of PANELS.HudLayoutManager.reflow()

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        open,
        close,
        toggle,
        getActive,
        initCommandBar,

        // State access
        get activePanelId() { return _activePanelId; }
    };
})();

// Backward compatibility - _activePanelId is managed by app.js
function openPanel(panelId) { PANELS.open(panelId); }
function closePanel(panelId) { PANELS.close(panelId); }
function togglePanel(panelId) { PANELS.toggle(panelId); }
function initCommandBar() { PANELS.initCommandBar(); }
// HudLayoutManager - app.js owns this, not duplicated here

// ════════════════════════════════════════════════════════════════════════
// PANEL DRAG & RESIZE - Make panels movable and resizable
// ════════════════════════════════════════════════════════════════════════

const PANEL_DRAG = (function() {
    'use strict';

    const _panels = new Map();
    let _dragState = null;
    let _resizeState = null;
    const STORAGE_KEY = 'collider-panel-positions';

    function init() {
        // Initialize draggable/resizable panels (use actual element IDs)
        initPanel('side-dock', { draggable: true, resizable: true, minWidth: 150, maxWidth: 400 });
        initPanel('header-panel', { draggable: true, resizable: false });
        initPanel('stats-panel', { draggable: true, resizable: false });
        initPanel('metrics-panel', { draggable: true, resizable: true, minWidth: 180, maxWidth: 350 });

        // Restore saved positions
        restorePositions();

        // Global mouse handlers
        document.addEventListener('mousemove', (e) => _onMouseMove(e));
        document.addEventListener('mouseup', (e) => _onMouseUp(e));
    }

    function initPanel(id, options = {}) {
        const panel = document.getElementById(id) || document.querySelector('.' + id);
        if (!panel) return;

        const config = {
            el: panel,
            id: id,
            draggable: options.draggable !== false,
            resizable: options.resizable === true,
            minWidth: options.minWidth || 100,
            maxWidth: options.maxWidth || 600,
            minHeight: options.minHeight || 50,
            maxHeight: options.maxHeight || window.innerHeight - 100
        };

        _panels.set(id, config);

        // Make panel positioned if not already
        const style = window.getComputedStyle(panel);
        if (style.position === 'static') {
            panel.style.position = 'absolute';
        }

        // Add drag handle (the panel header or title)
        if (config.draggable) {
            const header = panel.querySelector('.side-title, .hud-title, .panel-header') || panel;
            header.style.cursor = 'move';
            header.addEventListener('mousedown', (e) => _startDrag(e, id));
        }

        // Add resize handle
        if (config.resizable) {
            const handle = document.createElement('div');
            handle.className = 'panel-resize-handle';
            handle.addEventListener('mousedown', (e) => _startResize(e, id));
            panel.appendChild(handle);
            panel.style.position = 'absolute';
        }
    }

    function _startDrag(e, panelId) {
        // Don't drag if clicking on interactive elements
        if (e.target.closest('input, button, select, .collapsible-content, .preset-btn, .layout-btn, .scheme-btn')) {
            return;
        }

        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        const rect = config.el.getBoundingClientRect();

        _dragState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startLeft: rect.left,
            startTop: rect.top
        };

        config.el.classList.add('panel-dragging');
    }

    function _startResize(e, panelId) {
        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        e.stopPropagation();

        const rect = config.el.getBoundingClientRect();

        _resizeState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startWidth: rect.width,
            startHeight: rect.height
        };

        config.el.classList.add('panel-resizing');
    }

    function _onMouseMove(e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (!config) return;

            const dx = e.clientX - _dragState.startX;
            const dy = e.clientY - _dragState.startY;

            let newLeft = _dragState.startLeft + dx;
            let newTop = _dragState.startTop + dy;

            // Keep within viewport
            newLeft = Math.max(0, Math.min(window.innerWidth - 50, newLeft));
            newTop = Math.max(0, Math.min(window.innerHeight - 50, newTop));

            config.el.style.left = newLeft + 'px';
            config.el.style.top = newTop + 'px';
            config.el.style.right = 'auto';
            config.el.style.bottom = 'auto';
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (!config) return;

            const dx = e.clientX - _resizeState.startX;
            const dy = e.clientY - _resizeState.startY;

            let newWidth = _resizeState.startWidth + dx;
            let newHeight = _resizeState.startHeight + dy;

            // Apply constraints
            newWidth = Math.max(config.minWidth, Math.min(config.maxWidth, newWidth));
            newHeight = Math.max(config.minHeight, Math.min(config.maxHeight, newHeight));

            config.el.style.width = newWidth + 'px';
            // Only resize height for certain panels
            if (config.el.classList.contains('side-dock') || config.el.classList.contains('side-content')) {
                // Don't change height for sidebar - it's auto
            } else {
                config.el.style.height = newHeight + 'px';
            }
        }
    }

    function _onMouseUp(_e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (config) {
                config.el.classList.remove('panel-dragging');
                savePositions();
            }
            _dragState = null;
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (config) {
                config.el.classList.remove('panel-resizing');
                savePositions();
            }
            _resizeState = null;
        }
    }

    function savePositions() {
        const positions = {};
        _panels.forEach((config, id) => {
            const rect = config.el.getBoundingClientRect();
            const style = config.el.style;
            positions[id] = {
                left: style.left || rect.left + 'px',
                top: style.top || rect.top + 'px',
                width: style.width || null,
                height: style.height || null
            };
        });
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not save positions:', e);
        }
    }

    function restorePositions() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;

            const positions = JSON.parse(saved);
            Object.entries(positions).forEach(([id, pos]) => {
                const config = _panels.get(id);
                if (!config) return;

                if (pos.left) config.el.style.left = pos.left;
                if (pos.top) config.el.style.top = pos.top;
                if (pos.width) config.el.style.width = pos.width;
                if (pos.height) config.el.style.height = pos.height;

                // Clear right/bottom if we're setting left/top
                if (pos.left) config.el.style.right = 'auto';
                if (pos.top) config.el.style.bottom = 'auto';
            });
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not restore positions:', e);
        }
    }

    function resetPositions() {
        try {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not reset positions:', e);
        }
    }

    return {
        init,
        initPanel,
        savePositions,
        restorePositions,
        resetPositions,
        get panels() { return _panels; }
    };
})();

// Backward compatibility wrapper
const PanelManager = {
    panels: PANEL_DRAG.panels,
    init() { PANEL_DRAG.init(); },
    initPanel(id, opts) { PANEL_DRAG.initPanel(id, opts); },
    savePositions() { PANEL_DRAG.savePositions(); },
    restorePositions() { PANEL_DRAG.restorePositions(); },
    resetPositions() { PANEL_DRAG.resetPositions(); }
};

// Initialize after DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => PANEL_DRAG.init());
} else {
    setTimeout(() => PANEL_DRAG.init(), 100);
}

// Expose globally
window.PANEL_DRAG = PANEL_DRAG;
window.PanelManager = PanelManager;


// ═══ MODULE: modules/sidebar.js ═══
/**
 * SIDEBAR MODULE
 *
 * Manages sidebar controls including color presets, layout presets,
 * physics controls, appearance controls, filters, and panel updates.
 *
 * Depends on: ANIM (for layouts), REFRESH (for throttled updates)
 *
 * Usage:
 *   SIDEBAR.init()                         // Initialize after DOM ready
 *   SIDEBAR.setColorMode('tier')           // Change color mode
 *   SIDEBAR.setLayout('force')             // Change layout
 *   SIDEBAR.setPhysicsPreset('tight')      // Apply physics preset
 *   SIDEBAR.updateStats(nodes, edges)      // Update stat displays
 */

// Note: Using window assignment instead of const to avoid duplicate declaration with app.js
window.SIDEBAR = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _refreshTimer = null;
    let _bound = false;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    /**
     * Initialize sidebar - call after DOM is ready
     */
    function init() {
        if (_bound) return;
        _bound = true;

        // Initialize unified state manager first
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.init();
        }

        _bindSectionHeaders();
        _bindColorPresets();
        _bindLayoutPresets();
        _bindPhysicsControls();
        _bindAppearanceControls();
        _bindActionButtons();
        initSchemeNavigator();
        initViewModeToggle();
        initSectionResize();   // Enable vertical section resizing
        initSidebarResize();   // Enable horizontal sidebar resizing

        // Sync UI to initial state
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.syncUIFromState();
        }

        console.log('[SIDEBAR] Initialized');
    }

    // =========================================================================
    // SECTION COLLAPSE/EXPAND
    // =========================================================================

    function _bindSectionHeaders() {
        document.querySelectorAll('.section-header[data-section]').forEach(header => {
            header.addEventListener('click', () => {
                const sectionId = header.dataset.section;
                const content = document.getElementById(`section-${sectionId}`);
                if (!content) return;

                const isCollapsed = header.classList.toggle('collapsed');
                content.classList.toggle('collapsed', isCollapsed);
            });
        });
    }

    // =========================================================================
    // COLOR PRESETS (TIER, FAMILY, LAYER, RING, FILE, FLOW)
    // =========================================================================

    // =========================================================================
    // COLOR PRESETS: SMART SIDEBAR CONFIGURATION
    // =========================================================================

    const PRESET_CONFIG = [
        {
            category: 'Architecture',
            presets: [
                { id: 'tier', label: 'Tier', desc: 'Auto-detected architectural height' },
                { id: 'layer', label: 'Layer', desc: 'Business logic strata' },
                { id: 'subsystem', label: 'Subsystem', desc: 'Functional domain grouping' },
                { id: 'boundary_score', label: 'Boundary', desc: 'Internal vs External (1-9)' },
                { id: 'phase', label: 'Phase', desc: 'Data-Logic-Org-Exec (MIPO)' }
            ]
        },
        {
            category: 'Taxonomy',
            presets: [
                { id: 'atom', label: 'Atom', desc: 'Function, Class, Module types' },
                { id: 'family', label: 'Family', desc: 'Logic, Data, Execution' },
                { id: 'role', label: 'Role', desc: 'Service, Repo, Controller' },
                { id: 'roleCategory', label: 'Role Cat', desc: 'Query, Command, Event' },
                { id: 'fileType', label: 'File Type', desc: 'Extension-based coloring' }
            ]
        },
        {
            category: 'Metrics',
            presets: [
                { id: 'complexity', label: 'Complexity', desc: 'Cyclomatic complexity' },
                { id: 'loc', label: 'LOC', desc: 'Lines of Code' },
                { id: 'fan_in', label: 'Fan-In', desc: 'Incoming dependencies' },
                { id: 'fan_out', label: 'Fan-Out', desc: 'Outgoing dependencies' },
                { id: 'trust', label: 'Trust', desc: 'Detection confidence' }
            ]
        },
        {
            category: 'RPBL DNA',
            presets: [
                { id: 'responsibility', label: 'Responsibility', desc: 'SRP alignment (1-9)' },
                { id: 'purity', label: 'Purity', desc: 'Side-effect profile (1-9)' },
                { id: 'lifecycle_score', label: 'Lifecycle', desc: 'Static vs Dynamic (1-9)' },
                { id: 'state', label: 'State', desc: 'Stateful vs Stateless' },
                { id: 'visibility', label: 'Visibility', desc: 'Public vs Private' }
            ]
        },
        {
            category: 'Topology',
            presets: [
                { id: 'centrality', label: 'Centrality', desc: 'Graph importance' },
                { id: 'rank', label: 'PageRank', desc: 'Algorithmic influence' }, // mapped to centrality logic or similar
                { id: 'ring', label: 'Ring', desc: 'Concentric architecture rings' },
                { id: 'flow', label: 'Flow', desc: 'Dependency direction' }
            ]
        },
        {
            category: 'Evolution',
            presets: [
                { id: 'churn', label: 'Churn', desc: 'Change frequency (Simulated)' },
                { id: 'age', label: 'Age', desc: 'Time since creation (Simulated)' }
            ]
        }
    ];

    // =========================================================================
    // SCHEME NAVIGATOR: 33 Named Color Schemes
    // =========================================================================

    const SCHEME_CONFIG = [
        // PART A: Famous Scientific (15)
        { category: 'Sequential', schemes: ['viridis', 'plasma', 'magma', 'inferno', 'cividis', 'turbo', 'mako', 'rocket'] },
        { category: 'Diverging', schemes: ['coolwarm', 'spectral'] },
        { category: 'Thematic', schemes: ['thermal', 'nightvision', 'ocean', 'terrain', 'electric'] },

        // PART B: Role-Semantic (18 key roles)
        { category: 'Access', schemes: ['query', 'finder'] },
        { category: 'Mutation', schemes: ['command', 'creator', 'destroyer'] },
        { category: 'Construction', schemes: ['factory'] },
        { category: 'Storage', schemes: ['repository', 'cache'] },
        { category: 'Control', schemes: ['service', 'orchestrator'] },
        { category: 'Validation', schemes: ['validator', 'guard'] },
        { category: 'Transform', schemes: ['transformer', 'parser'] },
        { category: 'Events', schemes: ['handler', 'emitter'] },
        { category: 'Support', schemes: ['utility', 'lifecycle'] },

        // PART C: OKLCH Geometry (Mathematical paths through color space)
        { category: 'Loops', schemes: ['rainbow-loop', 'rainbow-bright', 'rainbow-dark'] },
        { category: 'Arcs', schemes: ['arc-warm', 'arc-cool', 'arc-nature'] },
        { category: 'Spirals', schemes: ['spiral-up', 'spiral-down', 'spiral-chroma'] },
        { category: 'Waves', schemes: ['wave-lightness', 'wave-chroma', 'pulse'] },
        { category: 'Ramps', schemes: ['ramp-hue', 'ramp-lightness', 'ramp-chroma'] },
        { category: 'Paths', schemes: ['helix', 'convergent', 'divergent', 'bicone'] }
    ];

    function _bindColorPresets() {
        // Init Smart Sidebar
        const container = document.getElementById('section-color');
        if (!container) return;

        // Clear existing static buttons if any (except header)
        const contentDiv = container.querySelector('.section-content');
        if (contentDiv) {
            contentDiv.innerHTML = ''; // Rebuild from scratch
            renderSmartSidebar(contentDiv);
        }
    }

    function renderSmartSidebar(container) {
        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Presets...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.preset-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.btn').forEach(btn => {
                    const match = btn.textContent.toLowerCase().includes(term) || btn.title.toLowerCase().includes(term);
                    btn.style.display = match ? 'block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        searchContainer.appendChild(searchInput);
        container.appendChild(searchContainer);

        // Render Categories
        PRESET_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'preset-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'btn-grid btn-grid-3'; // Default to 3-col

            section.presets.forEach(p => {
                const btn = document.createElement('button');
                btn.className = 'btn color-btn';
                btn.textContent = p.label;
                btn.title = p.desc;
                btn.dataset.preset = p.id;

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    setColorMode(p.id);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    // =========================================================================
    // SCHEME NAVIGATOR RENDERER
    // =========================================================================

    function renderSchemeNavigator(container) {
        if (!container) return;
        container.innerHTML = '';

        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Schemes...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.scheme-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.scheme-btn').forEach(btn => {
                    const match = btn.dataset.scheme.toLowerCase().includes(term) ||
                        (btn.title && btn.title.toLowerCase().includes(term));
                    btn.style.display = match ? 'inline-block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear';
        clearBtn.title = 'Remove scheme, use default colors';
        clearBtn.style.cssText = 'margin-left: 8px; padding: 4px 8px; font-size: 9px; background: rgba(255,100,100,0.2); border: 1px solid rgba(255,100,100,0.3); color: var(--text); border-radius: 4px; cursor: pointer;';
        clearBtn.addEventListener('click', clearColorScheme);

        searchContainer.appendChild(searchInput);
        searchContainer.appendChild(clearBtn);
        container.appendChild(searchContainer);

        // Render Categories
        SCHEME_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'scheme-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'scheme-grid';
            grid.style.cssText = 'display: flex; flex-wrap: wrap; gap: 4px;';

            section.schemes.forEach(schemeName => {
                const btn = document.createElement('button');
                btn.className = 'scheme-btn';
                btn.dataset.scheme = schemeName;

                // Get scheme info from COLOR engine
                let info = { name: schemeName, semantic: '' };
                if (typeof COLOR !== 'undefined' && COLOR.getSchemeInfo) {
                    info = COLOR.getSchemeInfo(schemeName);
                }

                btn.title = info.semantic || schemeName;

                // Create clean color swatches (5 stops) instead of ugly gradient
                const swatchContainer = document.createElement('div');
                swatchContainer.className = 'scheme-swatches';

                if (typeof COLOR !== 'undefined' && COLOR.getSchemeColor) {
                    // Sample 5 colors from the scheme path
                    [0, 0.25, 0.5, 0.75, 1].forEach(t => {
                        const swatch = document.createElement('span');
                        swatch.className = 'scheme-swatch';
                        swatch.style.backgroundColor = COLOR.getSchemeColor(schemeName, t);
                        swatchContainer.appendChild(swatch);
                    });
                }

                btn.appendChild(swatchContainer);

                // Label below swatches
                const label = document.createElement('span');
                label.className = 'scheme-label';
                label.textContent = info.name;
                btn.appendChild(label);

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    applyColorScheme(schemeName);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    /**
     * Apply a named color scheme (palette)
     *
     * NEW BEHAVIOR (via VIS_STATE):
     * - Palette is "armed" but does NOT auto-switch colorBy mode
     * - Palette only visually applies when colorBy is an interval mode
     * - When user switches to interval mode, the armed palette becomes active
     */
    function applyColorScheme(schemeName) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(schemeName);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(schemeName);
        }

        try {
            localStorage.setItem('collider_scheme', schemeName);
        } catch (e) { /* ignore */ }

        _refreshGraphColors();
        console.log('[SIDEBAR] Applied scheme:', schemeName);
    }

    /**
     * Clear active scheme, return to default interval colors
     */
    function clearColorScheme() {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(null);
            return;
        }

        // Fallback
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(null);
        }

        try {
            localStorage.removeItem('collider_scheme');
        } catch (e) { /* ignore */ }

        document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));

        _refreshGraphColors();

        console.log('[SIDEBAR] Cleared color scheme');
    }

    /**
     * Internal: Refresh all node colors and re-render the graph
     */
    function _refreshGraphColors() {
        if (typeof Graph === 'undefined' || !Graph) return;

        // Get current nodes from DataManager or Graph
        const DM = window.DM;
        const nodes = DM ? DM.getNodes() : (Graph.graphData ? Graph.graphData().nodes : []);

        // Recompute colors using current mode
        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render
        Graph.nodeColor(Graph.nodeColor());

        // Also refresh edges if in gradient mode
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    /**
     * Initialize scheme navigator in sidebar
     */
    function initSchemeNavigator() {
        const container = document.getElementById('section-schemes');
        if (container) {
            renderSchemeNavigator(container);
        }

        // Setup collapsible header for schemes panel
        const collapsibleHeaders = document.querySelectorAll('.info-panel-header.collapsible');
        collapsibleHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    header.classList.toggle('collapsed', isCollapsed);
                }
            });
        });

        // Setup color mode buttons (for right sidebar)
        const colorBtns = document.querySelectorAll('.color-panel .color-btn');
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                if (!preset) return;

                // Apply color mode via VIS_STATE (handles UI sync)
                setColorMode(preset);
            });
        });

        // NOTE: Saved preferences are now loaded by VIS_STATE.init()
        // UI sync is handled by VIS_STATE.syncUIFromState()
    }

    // =========================================================================
    // VIEW MODE TOGGLE (ATOMS vs FILES)
    // =========================================================================

    let _currentViewMode = 'atoms';
    let _deferredViewMode = null;  // Stores mode to apply after data loads

    /**
     * Initialize the view mode toggle (Atoms vs Files)
     * Note: Only sets up event handlers and button visual state.
     * Actual mode application for 'files' is deferred until data is loaded.
     */
    function initViewModeToggle() {
        const toggle = document.getElementById('view-mode-toggle');
        if (!toggle) return;

        const buttons = toggle.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                if (!mode || mode === _currentViewMode) return;

                setViewMode(mode);
            });
        });

        // Load saved preference - but only update button state, defer actual mode switch
        try {
            const saved = localStorage.getItem('collider_view_mode');
            if (saved && (saved === 'atoms' || saved === 'files')) {
                // Update button visual state immediately
                buttons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === saved);
                });
                _currentViewMode = saved;

                // If files mode, defer application until data is loaded
                if (saved === 'files') {
                    _deferredViewMode = 'files';
                    console.log('[SIDEBAR] Files mode saved - deferring until data loads');
                }
            }
        } catch (e) { /* ignore */ }
    }

    /**
     * Apply deferred view mode after data is loaded
     * Call this from initGraph() after DM.init() completes
     */
    function applyDeferredViewMode() {
        if (_deferredViewMode === 'files') {
            console.log('[SIDEBAR] Applying deferred files mode now that data is loaded');
            _deferredViewMode = null;  // Clear to prevent re-application

            // Apply files mode (data is now available)
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
                console.log('[SIDEBAR] View mode: FILES - showing file nodes');

                if (typeof showToast === 'function') {
                    showToast('FILE VIEW: Each node is a file. Click to expand.');
                }
            }
        }
    }

    /**
     * Set the view mode (atoms or files)
     */
    function setViewMode(mode) {
        if (mode !== 'atoms' && mode !== 'files') return;
        _currentViewMode = mode;

        // Update button states
        const buttons = document.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });

        // Save preference
        try {
            localStorage.setItem('collider_view_mode', mode);
        } catch (e) { /* ignore */ }

        // Apply view mode via FILE_VIZ module
        if (mode === 'files') {
            // Switch to file-nodes view
            if (typeof FILE_VIZ !== 'undefined') {
                // Build the file graph first (required before switching mode)
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'files';
                if (typeof buildFileGraph === 'function') buildFileGraph(null);
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: FILES - showing file nodes');
        } else {
            // Switch to atoms view
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.graphMode = 'atoms';
                FILE_VIZ.setEnabled(false);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'atoms';
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: ATOMS - showing individual atoms');
        }

        // Show toast notification
        if (typeof showToast === 'function') {
            const msg = mode === 'files'
                ? 'FILE VIEW: Each node is a file. Click to expand.'
                : 'ATOM VIEW: Each node is a code element.';
            showToast(msg);
        }
    }

    /**
     * Get current view mode
     */
    function getViewMode() {
        return _currentViewMode;
    }

    function setColorMode(mode) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setColorBy(mode);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof APPEARANCE_STATE !== 'undefined') {
            APPEARANCE_STATE.colorMode = mode;
            APPEARANCE_STATE.currentPreset = mode;
        }

        if (typeof setNodeColorMode === 'function') {
            setNodeColorMode(mode);
        }

        // Handle flow mode specially
        if (mode === 'flow') {
            if (typeof flowMode !== 'undefined' && !flowMode && typeof toggleFlowMode === 'function') {
                toggleFlowMode();
            }
        } else if (typeof flowMode !== 'undefined' && flowMode && typeof disableFlowMode === 'function') {
            disableFlowMode();
        }

        if (typeof window !== 'undefined' && typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        console.log('[SIDEBAR] Color mode:', mode);
    }

    // =========================================================================
    // LAYOUT PRESETS (FORCE, RADIAL, ORBITAL, SPHERE, GRID, SPIRAL)
    // =========================================================================

    function _bindLayoutPresets() {
        const container = document.getElementById('section-layout');
        if (!container) return;

        container.querySelectorAll('.btn[data-layout]').forEach(btn => {
            btn.addEventListener('click', () => {
                const layout = btn.dataset.layout;
                setLayout(layout);

                // Update active state
                container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });
    }

    function setLayout(layout) {
        // Prefer ANIM module if available
        if (typeof ANIM !== 'undefined' && ANIM.applyLayout) {
            ANIM.applyLayout(layout, true);
        } else if (typeof applyLayoutPreset === 'function') {
            applyLayoutPreset(layout, true);
        }
        console.log('[SIDEBAR] Layout:', layout);
    }

    // =========================================================================
    // PHYSICS CONTROLS
    // =========================================================================

    const PHYSICS_PRESETS = {
        default: { charge: -120, link: 50, center: 0.05, damping: 0.4 },
        tight: { charge: -80, link: 30, center: 0.1, damping: 0.5 },
        loose: { charge: -200, link: 80, center: 0.02, damping: 0.3 },
        explosive: { charge: -400, link: 120, center: 0.01, damping: 0.2 }
    };

    function _bindPhysicsControls() {
        // Charge (repulsion)
        _bindSlider('physics-charge', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('charge').strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Link distance
        _bindSlider('physics-link', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('link').distance(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Center pull
        _bindSlider('physics-center', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                const center = Graph.d3Force('center');
                if (center && center.strength) center.strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Damping (velocity decay)
        _bindSlider('physics-damping', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3VelocityDecay(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Physics presets
        const container = document.getElementById('section-physics');
        if (container) {
            container.querySelectorAll('.btn[data-physics]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.physics;
                    setPhysicsPreset(preset);
                });
            });
        }
    }

    function setPhysicsPreset(preset) {
        const p = PHYSICS_PRESETS[preset];
        if (!p) return;

        // Update sliders
        _setSliderValue('physics-charge', p.charge);
        _setSliderValue('physics-link', p.link);
        _setSliderValue('physics-center', p.center);
        _setSliderValue('physics-damping', p.damping);

        // Apply to graph
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('charge').strength(p.charge);
            Graph.d3Force('link').distance(p.link);
            const center = Graph.d3Force('center');
            if (center && center.strength) center.strength(p.center);
            Graph.d3VelocityDecay(p.damping);
            Graph.d3ReheatSimulation();
        }

        console.log('[SIDEBAR] Physics preset:', preset);
    }

    // =========================================================================
    // APPEARANCE CONTROLS
    // =========================================================================

    function _bindAppearanceControls() {
        // Auto-bind all sliders that have a matching numeric input
        // This covers cfg-node-size, cfg-node-opacity, etc.
        const ranges = document.querySelectorAll('input[type="range"]');
        ranges.forEach(range => {
            if (range.id) {
                _bindSlider(range.id, (val) => {
                    // Dispatch to specific handlers based on ID
                    // This creates a centralized handler dispatch
                    _handleSliderChange(range.id, val);
                });
            }
        });

        // Toggles
        _bindToggle('cfg-toggle-labels', (active) => {
            if (typeof VIS_FILTERS !== 'undefined' && VIS_FILTERS.metadata) {
                VIS_FILTERS.metadata.showLabels = active;
            }
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.nodeLabel(n => active ? n.name : null);
            }
        });

        _bindToggle('cfg-toggle-highlight', (active) => {
            // Handled by VIS_STATE or interactions
        });

        _bindToggle('cfg-toggle-pulse', (active) => {
            if (typeof ANIM !== 'undefined') {
                ANIM.togglePulse(active);
            }
        });

        _bindToggle('cfg-toggle-depth', (active) => {
            // 3D shading toggle
        });

        _bindToggle('cfg-toggle-arrows', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.showArrows = active;
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.linkDirectionalArrowLength(active ? 6 : 0);
                Graph.linkDirectionalArrowRelPos(0.9);
            }
        });

        _bindToggle('cfg-toggle-gradient', (active) => {
            if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.gradientEdges = active;
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            window.refreshGradientEdgeColors && window.refreshGradientEdgeColors();
        });
    }

    // Centralized handler for all sliders
    function _handleSliderChange(id, val) {
        // Map ID to logic
        switch (id) {
            // Node Config
            case 'cfg-node-size':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeVal(n => (n.val || 1) * val);
                break;
            case 'cfg-node-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode(); // Re-apply colors with new alpha
                break;
            case 'cfg-node-res':
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeResolution(val);
                break;
            case 'cfg-label-size':
                // Note: 3d-force-graph doesn't have a direct dynamic label size multiplier, 
                // but we can trigger a re-render or update state.
                break;

            // Edge Config    
            case 'cfg-edge-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
                break;
            case 'cfg-edge-width':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeWidth = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkWidth(val);
                break;
            case 'cfg-edge-curve':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeCurvature = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.linkCurvature(val);
                break;
            case 'cfg-particle-speed':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticleSpeed(val);
                break;
            case 'cfg-particle-count':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticles(val);
                break;

            // Physics (Updated IDs)
            case 'physics-charge':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('charge').strength(val);
                    Graph.d3ReheatSimulation();
                }
                break;
            case 'physics-link':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('link').distance(val);
                    Graph.d3ReheatSimulation();
                }
                break;
        }
    }


    // =========================================================================
    // ACTION BUTTONS
    // =========================================================================

    function _bindActionButtons() {
        // Reset view
        const resetBtn = document.getElementById('btn-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
                }
            });
        }

        // Screenshot
        const screenshotBtn = document.getElementById('btn-screenshot');
        if (screenshotBtn) {
            screenshotBtn.addEventListener('click', () => {
                if (typeof takeScreenshot === 'function') {
                    takeScreenshot();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    const link = document.createElement('a');
                    link.download = 'collider-screenshot.png';
                    link.href = Graph.renderer().domElement.toDataURL('image/png');
                    link.click();
                }
            });
        }

        // Toggle 2D
        const toggle2dBtn = document.getElementById('btn-2d');
        if (toggle2dBtn) {
            toggle2dBtn.addEventListener('click', () => {
                if (typeof toggle2DMode === 'function') toggle2DMode();
            });
        }

        // Freeze simulation
        const freezeBtn = document.getElementById('btn-freeze');
        if (freezeBtn) {
            freezeBtn.addEventListener('click', () => {
                if (typeof toggleFreeze === 'function') {
                    toggleFreeze();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    // Simple freeze toggle
                    const alpha = Graph.d3AlphaTarget();
                    Graph.d3AlphaTarget(alpha === 0 ? 0.3 : 0);
                    freezeBtn.classList.toggle('active', alpha !== 0);
                }
            });
        }
    }

    // =========================================================================
    // FILTER CHIPS
    // =========================================================================

    function populateFilterChips(data) {
        if (!data || !data.nodes) return;

        // Tiers
        const tiers = [...new Set(data.nodes.map(n => n.tier).filter(Boolean))].sort();
        _populateChipGroup('filter-tiers', tiers, 'tiers');

        // Rings
        const rings = [...new Set(data.nodes.map(n => n.ring).filter(Boolean))].sort();
        _populateChipGroup('filter-rings', rings, 'rings');

        // Edge types
        const edgeTypes = [...new Set(data.links?.map(e => e.type).filter(Boolean) || [])].sort();
        _populateChipGroup('filter-edges', edgeTypes, 'edges');
    }

    function _populateChipGroup(containerId, items, filterKey) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';
        items.forEach(item => {
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = item;
            chip.addEventListener('click', () => {
                const isActive = chip.classList.toggle('active');
                setFilter(filterKey, item, !isActive); // active = filtered OUT
                _scheduleRefresh();
            });
            container.appendChild(chip);
        });
    }

    function setFilter(dimension, value, visible) {
        if (typeof VIS_FILTERS === 'undefined') return;
        const set = VIS_FILTERS[dimension];
        if (!set) return;

        if (visible) {
            set.delete(value); // Remove from filter = show
        } else {
            set.add(value);    // Add to filter = hide
        }
    }

    // =========================================================================
    // HOVER PANEL
    // =========================================================================

    function showHoverPanel(node) {
        const panel = document.getElementById('hover-panel');
        if (!panel || !node) return;

        const setField = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value || '--';
        };

        setField('hover-name', node.name);
        setField('hover-kind', node.kind || node.type || 'unknown');
        setField('hover-atom', node.atom);
        setField('hover-family', node.family || (node.atom ? node.atom.split('.')[0] : null));
        setField('hover-ring', node.ring);
        setField('hover-tier', node.tier);
        setField('hover-role', node.role);

        const fileEl = document.getElementById('hover-file');
        if (fileEl) fileEl.textContent = node.file_path || node.file || '';

        panel.classList.add('visible');
    }

    function hideHoverPanel() {
        const panel = document.getElementById('hover-panel');
        if (panel) panel.classList.remove('visible');
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel(selectedNodes) {
        const panel = document.getElementById('selection-panel');
        const title = document.getElementById('selection-title');
        const list = document.getElementById('selection-list');
        const clearBtn = document.getElementById('selection-clear');

        if (!panel || !list) return;

        if (!selectedNodes || selectedNodes.length === 0) {
            panel.classList.remove('visible');
            return;
        }

        if (title) title.textContent = `SELECTED (${selectedNodes.length})`;

        list.innerHTML = selectedNodes.slice(0, 20).map(n =>
            `<div class="selection-item">${n.name || n.id}</div>`
        ).join('');

        if (selectedNodes.length > 20) {
            list.innerHTML += `<div class="selection-item" style="opacity:0.5">...and ${selectedNodes.length - 20} more</div>`;
        }

        panel.classList.add('visible');

        // Bind clear button
        if (clearBtn) {
            clearBtn.onclick = () => {
                if (typeof SELECT !== 'undefined') {
                    SELECT.clear();
                } else if (typeof clearSelection === 'function') {
                    clearSelection();
                }
                panel.classList.remove('visible');
            };
        }
    }

    // =========================================================================
    // STATS DISPLAY
    // =========================================================================

    function updateStats(nodes, edges, entropy) {
        const nodeEl = document.getElementById('stat-nodes');
        const edgeEl = document.getElementById('stat-edges');
        const entropyEl = document.getElementById('stat-entropy');

        if (nodeEl) nodeEl.textContent = nodes?.toLocaleString() || '0';
        if (edgeEl) edgeEl.textContent = edges?.toLocaleString() || '0';
        if (entropyEl) entropyEl.textContent = entropy?.toFixed(2) || '--';
    }

    // =========================================================================
    // HELPER: SLIDERS
    // =========================================================================

    function _bindSlider(id, callback) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);

        // Handle deprecated value span if it exists (for backward compat)
        const valSpan = document.getElementById(`${id}-val`);

        if (!slider) return;

        // Slider -> Number
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (numberInput) numberInput.value = val;
            if (valSpan) valSpan.textContent = val;
            callback(val);
        });

        // Number -> Slider
        if (numberInput) {
            numberInput.addEventListener('change', () => { // Change triggers on enter/blur
                let val = parseFloat(numberInput.value);

                // Clamp
                if (slider.min) val = Math.max(parseFloat(slider.min), val);
                if (slider.max) val = Math.min(parseFloat(slider.max), val);

                numberInput.value = val;
                slider.value = val;
                if (valSpan) valSpan.textContent = val;
                callback(val);
            });

            // Optional: Live update while typing? Maybe too heavy. Use change for now.
        }
    }

    function _setSliderValue(id, value) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);
        const valSpan = document.getElementById(`${id}-val`);

        if (slider) slider.value = value;
        if (numberInput) numberInput.value = value;
        if (valSpan) valSpan.textContent = value;
    }

    // =========================================================================
    // HELPER: TOGGLES
    // =========================================================================

    function _bindToggle(id, callback) {
        const toggle = document.getElementById(id);
        if (!toggle) {
            console.warn('[SIDEBAR] _bindToggle: element not found:', id);
            return;
        }

        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            callback(isActive);
        });
    }

    // =========================================================================
    // DEBOUNCED REFRESH
    // =========================================================================

    function _scheduleRefresh() {
        clearTimeout(_refreshTimer);
        _refreshTimer = setTimeout(() => {
            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof refreshGraph === 'function') {
                refreshGraph();
            }
        }, 16); // ~1 frame
    }

    // =========================================================================
    // SECTION RESIZING - Vertical drag handles
    // =========================================================================

    const SECTION_HEIGHT_KEY = 'viz_section_heights';
    let _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };

    function initSectionResize() {
        // Add resize handles to each section
        document.querySelectorAll('.section-content').forEach(content => {
            const sectionId = content.id;
            if (!sectionId) return;

            // Make content resizable
            content.classList.add('resizable');

            // Create resize handle
            const handle = document.createElement('div');
            handle.className = 'section-resize-handle';
            handle.dataset.section = sectionId;

            // Insert after section-content (before next section)
            const section = content.closest('.section');
            if (section && section.nextElementSibling) {
                section.parentNode.insertBefore(handle, section.nextElementSibling);
            }

            // Bind drag events
            handle.addEventListener('mousedown', _startResize);
        });

        // Global mouse events
        document.addEventListener('mousemove', _onResize);
        document.addEventListener('mouseup', _endResize);

        // Restore saved heights
        _restoreSectionHeights();

        console.log('[SIDEBAR] Section resize initialized');
    }

    function _startResize(e) {
        const sectionId = e.target.dataset.section;
        const content = document.getElementById(sectionId);
        if (!content) return;

        _resizeState = {
            active: true,
            section: content,
            startY: e.clientY,
            startHeight: content.offsetHeight
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }

    function _onResize(e) {
        if (!_resizeState.active || !_resizeState.section) return;

        const delta = e.clientY - _resizeState.startY;
        const newHeight = Math.max(60, Math.min(400, _resizeState.startHeight + delta));

        _resizeState.section.style.maxHeight = newHeight + 'px';
    }

    function _endResize() {
        if (!_resizeState.active) return;

        // Save height
        if (_resizeState.section) {
            _saveSectionHeight(_resizeState.section.id, _resizeState.section.style.maxHeight);
        }

        // Cleanup
        document.querySelectorAll('.section-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };
    }

    function _saveSectionHeight(sectionId, height) {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            heights[sectionId] = height;
            localStorage.setItem(SECTION_HEIGHT_KEY, JSON.stringify(heights));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save section height:', e);
        }
    }

    function _restoreSectionHeights() {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            Object.entries(heights).forEach(([sectionId, height]) => {
                const content = document.getElementById(sectionId);
                if (content && height) {
                    content.style.maxHeight = height;
                }
            });
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore section heights:', e);
        }
    }

    // =========================================================================
    // SIDEBAR RESIZING - Horizontal drag handles
    // =========================================================================

    const SIDEBAR_WIDTH_KEY = 'viz_sidebar_widths';
    let _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };

    function initSidebarResize() {
        const leftHandle = document.getElementById('left-resize-handle');
        const rightHandle = document.getElementById('right-resize-handle');

        if (leftHandle) {
            leftHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'left'));
        }
        if (rightHandle) {
            rightHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'right'));
        }

        // Global mouse events
        document.addEventListener('mousemove', _onSidebarResize);
        document.addEventListener('mouseup', _endSidebarResize);

        // Restore saved widths
        _restoreSidebarWidths();

        console.log('[SIDEBAR] Sidebar resize initialized');
    }

    function _startSidebarResize(e, side) {
        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        const currentWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(cssVar)) || 280;

        _sidebarResizeState = {
            active: true,
            side: side,
            startX: e.clientX,
            startWidth: currentWidth
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        e.preventDefault();
    }

    function _onSidebarResize(e) {
        if (!_sidebarResizeState.active) return;

        const { side, startX, startWidth } = _sidebarResizeState;
        const delta = side === 'left' ? (e.clientX - startX) : (startX - e.clientX);
        const minWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-sidebar-width')) || 200;
        const maxWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-sidebar-width')) || 400;
        const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + delta));

        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        document.documentElement.style.setProperty(cssVar, newWidth + 'px');

        // Update handle position
        const handle = document.getElementById(`${side}-resize-handle`);
        if (handle) {
            if (side === 'left') {
                handle.style.left = (newWidth - 3) + 'px';
            } else {
                handle.style.right = (newWidth - 3) + 'px';
            }
        }
    }

    function _endSidebarResize() {
        if (!_sidebarResizeState.active) return;

        // Save widths
        _saveSidebarWidths();

        // Cleanup
        document.querySelectorAll('.sidebar-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };
    }

    function _saveSidebarWidths() {
        try {
            const left = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width');
            const right = getComputedStyle(document.documentElement).getPropertyValue('--right-panel-width');
            localStorage.setItem(SIDEBAR_WIDTH_KEY, JSON.stringify({ left, right }));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save sidebar widths:', e);
        }
    }

    function _restoreSidebarWidths() {
        try {
            const widths = JSON.parse(localStorage.getItem(SIDEBAR_WIDTH_KEY) || '{}');
            if (widths.left) {
                document.documentElement.style.setProperty('--sidebar-width', widths.left);
                const leftHandle = document.getElementById('left-resize-handle');
                if (leftHandle) leftHandle.style.left = `calc(${widths.left} - 3px)`;
            }
            if (widths.right) {
                document.documentElement.style.setProperty('--right-panel-width', widths.right);
                const rightHandle = document.getElementById('right-resize-handle');
                if (rightHandle) rightHandle.style.right = `calc(${widths.right} - 3px)`;
            }
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore sidebar widths:', e);
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Initialization
        init,
        initSectionResize,
        initSidebarResize,

        // Color modes
        setColorMode,

        // Color Schemes (33 named gradients)
        applyColorScheme,
        clearColorScheme,
        renderSchemeNavigator,
        initSchemeNavigator,
        SCHEME_CONFIG,

        // Layouts
        setLayout,

        // Physics
        setPhysicsPreset,
        PHYSICS_PRESETS,

        // Filters
        populateFilterChips,
        setFilter,
        renderSmartSidebar, // Export for debug/manual re-render

        // Panels
        showHoverPanel,
        hideHoverPanel,
        updateSelectionPanel,

        // Stats
        updateStats,

        // View Mode (ATOMS/FILES toggle)
        initViewModeToggle,
        setViewMode,
        getViewMode,
        applyDeferredViewMode
    };
})();

// Backward compatibility - SidebarManager class is defined in app.js, not duplicated here
// The SIDEBAR module provides all functionality via SIDEBAR.* calls


// ═══ MODULE: modules/edge-system.js ═══
/**
 * EDGE SYSTEM MODULE
 *
 * Manages edge coloring, width, modes, and gradient effects.
 * Includes gradient palettes for tier, file, flow, depth, and semantic modes.
 *
 * Depends on: COLOR (for type-based colors), NODE (for tier lookups)
 *
 * Usage:
 *   EDGE.getColor(link)           // Get color for a link
 *   EDGE.getWidth(link)           // Get width for a link
 *   EDGE.setMode('gradient-tier') // Change edge mode
 *   EDGE.apply()                  // Apply current mode to graph
 */

const EDGE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODE_ORDER = [
        'gradient-tier',      // Source→Target tier flow (architecture layers)
        'gradient-file',      // File boundaries (module regions)
        'gradient-flow',      // Markov probability (hot paths)
        'gradient-depth',     // Call depth progression
        'gradient-semantic',  // Semantic distance (type similarity)
        'type',               // Classic type-based
        'weight',             // Weight intensity
        'mono'                // Minimal monochrome
    ];

    const MODE_LABELS = {
        'gradient-tier': '▼ TIER FLOW',
        'gradient-file': '▼ FILE REGIONS',
        'gradient-flow': '▼ HOT PATHS',
        'gradient-depth': '▼ CALL DEPTH',
        'gradient-semantic': '▼ SEMANTIC',
        type: 'EDGE: TYPE',
        weight: 'EDGE: WEIGHT',
        mono: 'EDGE: MONO'
    };

    const MODE_HINTS = {
        'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
        'gradient-file': 'Color by file region - shows module boundaries',
        'gradient-flow': 'Hot paths - markov probability gradient',
        'gradient-depth': 'Color by call chain depth',
        'gradient-semantic': 'Color by semantic similarity of endpoints',
        type: 'Edge color by type (calls, imports, etc.)',
        weight: 'Edge width & color by weight',
        mono: 'Minimal monochrome'
    };

    // Gradient color palettes for different modes
    const PALETTES = {
        tier: {
            // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
            T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
            T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
            T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
            UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
        },
        file: {
            // Rainbow hues distributed across files
            saturation: 65,
            lightness: 48
        },
        flow: {
            // Cold (low prob) to Hot (high prob)
            cold: { h: 220, s: 60, l: 45 },   // Blue
            warm: { h: 45, s: 85, l: 50 },    // Yellow
            hot: { h: 0, s: 90, l: 55 }       // Red
        },
        depth: {
            // Shallow (bright) to Deep (dark, saturated)
            shallow: { h: 180, s: 50, l: 65 },  // Light cyan
            mid: { h: 260, s: 70, l: 50 },      // Purple
            deep: { h: 320, s: 80, l: 40 }      // Magenta
        },
        semantic: {
            // Similar (harmonious) to Different (contrasting)
            similar: { h: 150, s: 60, l: 50 },    // Green - same type
            related: { h: 200, s: 65, l: 48 },    // Cyan - related
            different: { h: 340, s: 75, l: 50 }   // Pink - different
        }
    };

    const DEFAULT_OPACITY = 0.08;
    const MIN_WIDTH = 0.6;
    const MAX_WIDTH = 2.2;
    const BASE_WIDTH = 1.0;

    // =========================================================================
    // STATE
    // =========================================================================

    let _mode = 'gradient-file';  // Default mode
    let _ranges = { weight: { min: 1, max: 1 }, confidence: { min: 1, max: 1 } };
    let _nodeFileIndex = new Map();
    let _fileHueMap = new Map();
    let _config = {
        opacity: DEFAULT_OPACITY,
        dim: { interfile_factor: 0.25 }
    };

    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================

    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function interpolateHSL(hsl1, hsl2, t) {
        t = clamp01(t);
        // Handle hue interpolation (shortest path on color wheel)
        let h1 = hsl1.h, h2 = hsl2.h;
        let dh = h2 - h1;
        if (Math.abs(dh) > 180) {
            if (dh > 0) h1 += 360;
            else h2 += 360;
        }
        const h = (h1 + (h2 - h1) * t) % 360;
        const s = hsl1.s + (hsl2.s - hsl1.s) * t;
        const l = hsl1.l + (hsl2.l - hsl1.l) * t;
        return hslColor(h, s, l);
    }

    /**
     * Normalize a metric value to [0,1] range.
     * NOW DELEGATES TO UPB_SCALES when available.
     */
    function normalizeMetric(value, range, scaleName) {
        // If range is degenerate (all same values), return based on absolute value
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }

        // === UPB INTEGRATION ===
        if (window.UPB_SCALES) {
            return window.UPB_SCALES.applyScale(
                scaleName || 'linear',
                value,
                range.min,
                range.max
            );
        }

        // Fallback: inline linear normalization
        return clamp01((value - range.min) / (range.max - range.min));
    }

    // =========================================================================
    // NODE HELPERS (use canonical versions from node-helpers.js via window.*)
    // =========================================================================

    function getLinkFileIdx(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.fileIdx ?? -1;
        }
        if (endpoint) {
            return _nodeFileIndex.get(endpoint) ?? -1;
        }
        return -1;
    }

    // =========================================================================
    // FILE HUE MAP
    // =========================================================================

    function buildFileHueMap() {
        _fileHueMap.clear();
        // Try DATA module first, then DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
                   (typeof DM !== 'undefined' ? DM : null);
        if (!dm || !dm.getFileBoundaries) return;

        const files = dm.getFileBoundaries();
        const goldenAngle = 137.508;  // Golden angle for good distribution
        files.forEach((file, idx) => {
            const hue = (idx * goldenAngle) % 360;
            _fileHueMap.set(idx, hue);
        });
    }

    // =========================================================================
    // RANGE UPDATES
    // =========================================================================

    function updateRanges() {
        const links = (typeof Graph !== 'undefined' && Graph?.graphData()?.links) || [];
        let minWeight = Infinity, maxWeight = -Infinity;
        let minConf = Infinity, maxConf = -Infinity;

        links.forEach(link => {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            minWeight = Math.min(minWeight, weight);
            maxWeight = Math.max(maxWeight, weight);
            minConf = Math.min(minConf, confidence);
            maxConf = Math.max(maxConf, confidence);
        });

        _ranges = {
            weight: {
                min: isFinite(minWeight) ? minWeight : 1,
                max: isFinite(maxWeight) ? maxWeight : 1
            },
            confidence: {
                min: isFinite(minConf) ? minConf : 1,
                max: isFinite(maxConf) ? maxConf : 1
            }
        };
    }

    function refreshNodeFileIndex() {
        _nodeFileIndex.clear();
        const nodes = (typeof Graph !== 'undefined' && Graph?.graphData()?.nodes) || [];
        nodes.forEach(node => {
            if (node && node.id) {
                _nodeFileIndex.set(node.id, node.fileIdx ?? -1);
            }
        });
    }

    // =========================================================================
    // GRADIENT EDGE COLOR
    // =========================================================================

    function getGradientColor(link, mode) {
        const srcNode = typeof link.source === 'object' ? link.source :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.source) : null);
        const tgtNode = typeof link.target === 'object' ? link.target :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.target) : null);

        if (mode === 'gradient-tier') {
            const srcTier = window.getNodeTierValue(srcNode);
            const tgtTier = window.getNodeTierValue(tgtNode);
            const avgTier = (srcTier + tgtTier) / 2;

            const palette = PALETTES.tier;
            let color;
            if (avgTier < 0.5) {
                color = interpolateHSL(palette.T0, palette.T1, avgTier * 2);
            } else if (avgTier < 1.5) {
                color = interpolateHSL(palette.T0, palette.T1, (avgTier - 0.5));
            } else {
                color = interpolateHSL(palette.T1, palette.T2, (avgTier - 1) / 2);
            }

            // Highlight tier transitions (edges crossing tiers)
            if (srcTier !== tgtTier) {
                return hslColor(
                    parseInt(color.slice(4)),
                    75,  // Higher saturation
                    55   // Brighter
                );
            }
            return color;
        }

        if (mode === 'gradient-file') {
            const srcFile = srcNode?.fileIdx ?? -1;
            const tgtFile = tgtNode?.fileIdx ?? -1;
            const palette = PALETTES.file;

            if (srcFile === tgtFile && srcFile >= 0) {
                const hue = _fileHueMap.get(srcFile) ?? (srcFile * 37 % 360);
                return hslColor(hue, palette.saturation, palette.lightness);
            } else {
                const srcHue = _fileHueMap.get(srcFile) ?? 0;
                const tgtHue = _fileHueMap.get(tgtFile) ?? 180;
                let midHue = (srcHue + tgtHue) / 2;
                if (Math.abs(srcHue - tgtHue) > 180) {
                    midHue = (midHue + 180) % 360;
                }
                return hslColor(midHue, palette.saturation * 0.6, palette.lightness * 1.1);
            }
        }

        if (mode === 'gradient-flow') {
            const mw = link.markov_weight ?? link.weight ?? 0;
            const palette = PALETTES.flow;

            if (mw < 0.3) {
                return interpolateHSL(palette.cold, palette.warm, mw / 0.3);
            } else if (mw < 0.7) {
                return interpolateHSL(palette.warm, palette.hot, (mw - 0.3) / 0.4);
            } else {
                return hslColor(palette.hot.h, palette.hot.s + 10, palette.hot.l + 10);
            }
        }

        if (mode === 'gradient-depth') {
            const srcDepth = window.getNodeDepth(srcNode);
            const tgtDepth = window.getNodeDepth(tgtNode);
            const avgDepth = (srcDepth + tgtDepth) / 2;
            const palette = PALETTES.depth;

            if (avgDepth < 0.33) {
                return interpolateHSL(palette.shallow, palette.mid, avgDepth * 3);
            } else if (avgDepth < 0.66) {
                return interpolateHSL(palette.mid, palette.deep, (avgDepth - 0.33) * 3);
            } else {
                return hslColor(palette.deep.h, palette.deep.s, palette.deep.l - 10);
            }
        }

        if (mode === 'gradient-semantic') {
            const similarity = window.getSemanticSimilarity(srcNode, tgtNode);
            const palette = PALETTES.semantic;

            if (similarity > 0.7) {
                return interpolateHSL(palette.related, palette.similar, (similarity - 0.7) / 0.3);
            } else if (similarity > 0.3) {
                return interpolateHSL(palette.different, palette.related, (similarity - 0.3) / 0.4);
            } else {
                return hslColor(palette.different.h, palette.different.s + 10, palette.different.l);
            }
        }

        return '#444444';
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(link) {
        // Gradient modes
        if (_mode.startsWith('gradient-')) {
            return getGradientColor(link, _mode);
        }

        const edgeKey = String(link.edge_type || link.type || 'unknown').toLowerCase();

        if (_mode === 'type') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', edgeKey) : '#666666';
        }

        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const t = normalizeMetric(weight, _ranges.weight);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('weight', t) : hslColor(30, 70, 50 + t * 30);
        }

        if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            const t = normalizeMetric(confidence, _ranges.confidence);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('confidence', t) : hslColor(200, 70, 50 + t * 30);
        }

        if (_mode === 'mono') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', 'unknown') : '#555555';
        }

        // Default: type-based coloring
        return typeof COLOR !== 'undefined' ?
            COLOR.get('edgeType', edgeKey) : '#666666';
    }

    // =========================================================================
    // EDGE WIDTH
    // =========================================================================

    function getWidth(link) {
        // For most modes, return uniform width for visual consistency
        if (_mode !== 'weight' && _mode !== 'confidence') {
            return BASE_WIDTH;
        }

        // Weight/confidence modes: subtle variation within tight bounds
        let t = 0.5;
        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            t = normalizeMetric(weight, _ranges.weight);
        } else if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            t = normalizeMetric(confidence, _ranges.confidence);
        }

        return MIN_WIDTH + (t * (MAX_WIDTH - MIN_WIDTH));
    }

    // =========================================================================
    // APPLY MODE TO GRAPH
    // =========================================================================

    function apply() {
        updateRanges();
        refreshNodeFileIndex();
        buildFileHueMap();

        if (typeof Graph === 'undefined' || !Graph) return;

        Graph.linkColor(link => {
            const color = getColor(link);
            return typeof toColorNumber === 'function' ?
                toColorNumber(color, 0x222222) : color;
        });

        Graph.linkOpacity(link => {
            const overrideOpacity = (typeof APPEARANCE_STATE !== 'undefined' &&
                typeof APPEARANCE_STATE.edgeOpacity === 'number')
                ? APPEARANCE_STATE.edgeOpacity
                : null;
            const baseOpacity = (overrideOpacity !== null)
                ? overrideOpacity
                : (link.opacity ?? DEFAULT_OPACITY);

            // File mode dimming
            const fileMode = typeof window !== 'undefined' && window.fileMode;
            const graphMode = typeof GRAPH_MODE !== 'undefined' ? GRAPH_MODE : 'atoms';
            if (fileMode && graphMode === 'atoms') {
                const srcIdx = getLinkFileIdx(link, 'source');
                const tgtIdx = getLinkFileIdx(link, 'target');
                if (srcIdx >= 0 && tgtIdx >= 0 && srcIdx !== tgtIdx) {
                    const dimFactor = _config.dim?.interfile_factor ?? 0.25;
                    return baseOpacity * dimFactor;
                }
            }
            return baseOpacity;
        });

        // Don't override width in flow mode
        const flowMode = typeof window !== 'undefined' && window.flowMode;
        if (!flowMode) {
            Graph.linkWidth(link => {
                const baseWidth = getWidth(link);
                // Respect APPEARANCE_STATE.edgeWidth multiplier if set
                const widthMultiplier = (typeof APPEARANCE_STATE !== 'undefined' &&
                    typeof APPEARANCE_STATE.edgeWidth === 'number')
                    ? APPEARANCE_STATE.edgeWidth
                    : 1;
                return Math.max(0.5, baseWidth * widthMultiplier);
            });
        }
    }

    // =========================================================================
    // MODE MANAGEMENT
    // =========================================================================

    function setMode(mode) {
        if (!MODE_ORDER.includes(mode)) return;
        _mode = mode;

        const button = document.getElementById('btn-edge-mode');
        if (button) {
            button.textContent = MODE_LABELS[_mode] || 'EDGE';
        }

        apply();

        // Update legend to reflect edge mode colors
        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        // Show mode toast hint
        if (typeof showModeToast === 'function') {
            showModeToast(MODE_HINTS[mode] || `Edge mode: ${mode}`);
        }
    }

    function cycleMode() {
        const currentIndex = MODE_ORDER.indexOf(_mode);
        const nextIndex = (currentIndex + 1) % MODE_ORDER.length;
        setMode(MODE_ORDER[nextIndex]);
    }

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getWidth,
        apply,

        // Mode management
        setMode,
        cycleMode,
        get mode() { return _mode; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Constants
        MODE_ORDER,
        MODE_LABELS,
        MODE_HINTS,
        PALETTES,

        // Internal access (for migration)
        get ranges() { return _ranges; },
        get nodeFileIndex() { return _nodeFileIndex; },
        get fileHueMap() { return _fileHueMap; },

        // Utility exports
        buildFileHueMap,
        updateRanges,
        refreshNodeFileIndex
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// These create getters/setters that sync with EDGE module state
Object.defineProperty(window, 'EDGE_MODE', {
    get: () => EDGE.mode,
    set: (v) => EDGE.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'EDGE_RANGES', {
    get: () => EDGE.ranges,
    configurable: true
});
Object.defineProperty(window, 'NODE_FILE_INDEX', {
    get: () => EDGE.nodeFileIndex,
    configurable: true
});
Object.defineProperty(window, 'FILE_HUE_MAP', {
    get: () => EDGE.fileHueMap,
    configurable: true
});
// Static constants - app.js owns these, not duplicated here
// EDGE_MODE_ORDER, EDGE_MODE_LABELS, EDGE_MODE_HINTS, GRADIENT_PALETTES - defined in app.js

function getEdgeColor(link) { return EDGE.getColor(link); }
function getEdgeWidth(link) { return EDGE.getWidth(link); }
function applyEdgeMode() { EDGE.apply(); }
function setEdgeMode(mode) { EDGE.setMode(mode); }
function cycleEdgeMode() { EDGE.cycleMode(); }
function updateEdgeRanges() { EDGE.updateRanges(); }
function refreshNodeFileIndex() { EDGE.refreshNodeFileIndex(); }
function buildFileHueMap() { EDGE.buildFileHueMap(); }
function getGradientEdgeColor(link, mode) { return EDGE.getColor(link); }


// ═══ MODULE: modules/file-viz.js ═══
/**
 * FILE VIZ MODULE
 *
 * Manages file visualization modes: color, hulls, cluster, map, spheres.
 * Handles file coloring, boundaries, mode switching, and FILE GRAPH.
 *
 * FILE GRAPH: Shows repository structure as first-class nodes where each
 * file becomes a hoverable, selectable node. This provides:
 * - Clear view of the repository file system
 * - Hover to see file details (atom count, path, metrics)
 * - Click to expand and see atoms within
 * - Edge weights show inter-file dependencies
 *
 * Depends on: DATA (for file boundaries), COLOR (for transforms)
 *
 * Pattern: IIFE with State Unification (see docs/specs/VISUALIZATION_UI_SPEC.md)
 *
 * Usage:
 *   FILE_VIZ.setMode('map')          // Switch to file-nodes view
 *   FILE_VIZ.toggle()                // Toggle file mode on/off
 *   FILE_VIZ.getColor(idx, total)    // Get color for a file
 *   FILE_VIZ.buildFileGraph()        // Build file-level graph
 *   FILE_VIZ.apply()                 // Apply current mode
 */

const FILE_VIZ = (function () {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODES = ['color', 'hulls', 'cluster', 'map', 'spheres'];

    const MODE_HINTS = {
        color: 'Files colored by hue - each file gets unique color',
        hulls: 'Boundary hulls around file clusters',
        cluster: 'Force clustering groups files together',
        map: 'FILE NODES view - see repository structure as nodes! Click to expand.',
        spheres: 'Containment spheres with collision physics'
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _enabled = false;
    let _mode = 'color';
    let _config = {
        strategy: 'golden-angle',
        angle: 137.5,
        chroma: null,
        saturation: 70,
        lightness: 50
    };
    let _boundaryMeshes = [];
    let _hullRedrawTimer = null;
    let _hullRedrawAttempts = 0;

    // FILE GRAPH STATE - for file-as-nodes visualization
    let _fileGraph = null;          // { nodes: [], links: [] } for file-level view
    let _fileNodeIds = new Map();   // fileIdx -> nodeId mapping
    let _fileNodePositions = new Map(); // Preserve positions across mode switches
    let _expandedFiles = new Set(); // Files expanded to show atoms
    let _graphMode = 'atoms';       // atoms | files | hybrid
    let _expandMode = 'inline';     // inline | detach
    let _activeMapping = 'format';  // Current visual mapping mode

    // =========================================================================
    // VISUAL MAPPING SYSTEM - Map metadata to visual properties
    // =========================================================================

    /**
     * Visual dimension mappings - connect file metadata to visual properties.
     * Each mapping defines: source metadata field → visual property + scale
     */
    // =========================================================================
    // VISUAL MAPPING SYSTEM - DELEGATED TO UPB (Universal Property Binder)
    // =========================================================================

    // Mappings are now defined in standard-model-of-code/src/core/viz/assets/modules/upb/bindings.js


    /**
     * Apply a visual mapping to file nodes.
     * NOW DELEGATES TO UPB (Universal Property Binder)
     *
     * @param {string} mappingKey - Key from VISUAL_MAPPINGS (source property)
     * @param {Array} fileNodes - Array of file node objects
     */
    /**
     * Apply a visual mapping to file nodes.
     * NOW DELEGATES TO UPB (Universal Property Binder).
     *
     * @param {string} mappingKey - Key for the UPB binding (e.g. 'complexity_density')
     * @param {Array} fileNodes - Array of file node objects
     */
    function applyVisualMapping(mappingKey, fileNodes) {
        _activeMapping = mappingKey;

        // Verify UPB availability
        if (!window.UPB) {
            console.warn('[FILE_VIZ] UPB not loaded. Cannot apply mapping:', mappingKey);
            return;
        }

        // Apply visual updates via UPB
        // This calculates new values for node properties (color, val, etc.)
        // Note: apply() returns diffs, but also mutates nodes in place if configured.
        const updates = window.UPB.apply(fileNodes);

        console.log(`[FILE_VIZ] Delegated mapping '${mappingKey}' to UPB. Updated ${updates.length} nodes.`);

        // If the mapping targets specific visual properties (like size/color),
        // we might done here since UPB modifies the node state.
        // The render loop will pick up 'node.val' or 'node.color' changes.
    }

    // _normalizeValueFallback REMOVED - Logic moved to UPB_SCALES


    function _applyVisualProperty(node, property, value) {
        switch (property) {
            case 'nodeSize':
                node.val = value;
                break;
            case 'hue':
                // Rebuild color with new hue
                const sat = _config.saturation ?? 70;
                const light = _config.lightness ?? 50;
                node.color = hslColor(value, sat, light);
                break;
            case 'saturation':
                // Would need to parse existing color - simplified approach
                node._saturation = value;
                break;
            case 'lightness':
                node._lightness = value;
                break;
            case 'opacity':
                node._opacity = value;
                break;
            case 'pulse':
                node._pulseIntensity = value;
                break;
        }
    }

    /**
     * Get color for file based on active mapping or default
     */
    function getColorForMapping(node) {
        // If we have an active mapping managed by UPB, the node.color might already
        // be updated. But if we need to calculate it on the fly:

        // For now, rely on standard "index" based color if no specific UPB override
        // is active or if we just want the base identity color.
        return getColor(node.fileIdx, 100, node.file_name);
    }

    // =========================================================================
    // COLOR UTILITIES
    // =========================================================================

    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function hashToUnit(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash;
        }
        return Math.abs(hash % 1000) / 1000;
    }

    function getHue(fileIdx, totalFiles, fileName) {
        const strategy = _config.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return hashToUnit(seed) * 360;
        }
        const angle = _config.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const saturation = _config.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (_config.lightness ?? 50);
        const hue = getHue(fileIdx, totalFiles, fileName);

        // Apply color tweaks if available
        const tweaks = typeof COLOR_TWEAKS !== 'undefined' ? COLOR_TWEAKS : {};

        if (typeof _config.chroma === 'number' && typeof oklchColor === 'function') {
            return oklchColor(lightness, _config.chroma, hue);
        }

        const adjustedHue = hue + (tweaks.hueShift || 0);
        const adjustedLightness = clampValue(lightness + (tweaks.lightnessShift || 0), 0, 100);
        return hslColor(adjustedHue, saturation, adjustedLightness);
    }

    // =========================================================================
    // APPLY COLORS TO NODES
    // =========================================================================

    function applyColors(graphNodes) {
        // Get file boundaries from DATA module or DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        const boundaries = dm?.getFileBoundaries ? dm.getFileBoundaries() : [];
        const totalFiles = boundaries.length;

        graphNodes.forEach(node => {
            if (node.fileIdx >= 0) {
                const fileInfo = boundaries[node.fileIdx] || {};
                const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                node.color = getColor(node.fileIdx, totalFiles, fileLabel);
            }
        });

        if (typeof Graph !== 'undefined' && Graph) {
            Graph.nodeColor(n => {
                return typeof toColorNumber === 'function' ?
                    toColorNumber(n.color, 0x888888) : n.color;
            });
        }
    }

    // =========================================================================
    // FILE GRAPH BUILDING - Repository as Nodes
    // =========================================================================

    /**
     * Build a file-level graph where each file is a node.
     * This creates a clear view of repository structure with:
     * - File nodes sized by atom count
     * - Edges weighted by inter-file dependencies
     * - Colors by file index (golden angle distribution)
     */
    function buildFileGraph() {
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        const boundaries = dm?.getFileBoundaries ? dm.getFileBoundaries() : [];
        const nodes = dm?.getNodes ? dm.getNodes() : [];
        const links = dm?.getLinks ? dm.getLinks() : [];

        // Get current atom positions from Graph for centroid calculation
        const currentGraphNodes = (typeof Graph !== 'undefined' && Graph)
            ? (Graph.graphData()?.nodes || [])
            : [];
        const atomPositions = new Map();
        currentGraphNodes.forEach(n => {
            if (n && n.id && Number.isFinite(n.x) && Number.isFinite(n.y)) {
                atomPositions.set(n.id, { x: n.x, y: n.y, z: n.z || 0 });
            }
        });

        const totalFiles = boundaries.length;
        const fileNodes = [];
        _fileNodeIds.clear();
        const nodeFileIdx = new Map();

        // Build node -> fileIdx mapping
        nodes.forEach(n => {
            if (n && n.id) {
                nodeFileIdx.set(n.id, n.fileIdx ?? -1);
            }
        });

        // Build file -> atoms mapping for centroid calculation
        const fileAtoms = new Map(); // fileIdx -> [atom positions]
        nodes.forEach(n => {
            if (n && n.id && n.fileIdx !== undefined && n.fileIdx >= 0) {
                const pos = atomPositions.get(n.id);
                if (pos) {
                    if (!fileAtoms.has(n.fileIdx)) fileAtoms.set(n.fileIdx, []);
                    fileAtoms.get(n.fileIdx).push(pos);
                }
            }
        });

        // Create file nodes with centroid positions
        boundaries.forEach((boundary, idx) => {
            const label = boundary.file_name || boundary.file || `file-${idx}`;
            const atomCount = boundary.atom_count || 1;
            const nodeId = `file:${idx}`;
            _fileNodeIds.set(idx, nodeId);

            // Calculate centroid from atom positions (SMOOTH TRANSITION)
            const atoms = fileAtoms.get(idx) || [];
            let cx = 0, cy = 0, cz = 0;
            if (atoms.length > 0) {
                atoms.forEach(p => { cx += p.x; cy += p.y; cz += p.z; });
                cx /= atoms.length;
                cy /= atoms.length;
                cz /= atoms.length;
            } else {
                // Fallback: radial layout for files with no positioned atoms
                const angle = (idx / totalFiles) * Math.PI * 2;
                const radius = 200;
                cx = Math.cos(angle) * radius;
                cy = Math.sin(angle) * radius;
                cz = (Math.random() - 0.5) * 50;
            }

            fileNodes.push({
                id: nodeId,
                name: label,
                fileIdx: idx,
                isFileNode: true,
                // POSITION: Initialize at centroid of atoms for smooth transition
                x: cx, y: cy, z: cz,
                fx: undefined, fy: undefined, fz: undefined, // Allow physics to relax
                val: Math.max(2, Math.sqrt(atomCount) * 1.5), // Size by atom count
                color: getColor(idx, totalFiles, label),
                file_path: boundary.file || '',
                atom_count: atomCount,
                // Enriched file metadata for hover panel and visual mappings
                tier: boundary.tier || 'UNKNOWN',
                ring: boundary.ring || 'UNKNOWN',
                internal_edges: boundary.internal_edges || 0,
                external_edges: boundary.external_edges || 0,
                // Physical metadata
                size_bytes: boundary.size_bytes ?? 0,
                size_kb: boundary.size_kb ?? 0,
                token_estimate: boundary.token_estimate ?? 0,
                line_count: boundary.line_count ?? 0,
                code_lines: boundary.code_lines ?? 0,
                // Temporal metadata
                age_days: boundary.age_days ?? 0,
                modified_date: boundary.modified_date || '',
                is_stale: boundary.is_stale ?? false,
                is_recent: boundary.is_recent ?? false,
                // Categorical metadata
                format_category: boundary.format_category || 'other',
                purpose: boundary.purpose || 'general',
                extension: boundary.extension || '',
                is_test: boundary.is_test ?? false,
                is_config: boundary.is_config ?? false,
                // Complexity metadata
                complexity_density: boundary.complexity_density ?? 0,
                cohesion: boundary.cohesion ?? 0.5,
                code_ratio: boundary.code_ratio ?? 0.5
            });
        });

        // Build inter-file edges with weights
        const edgeMap = new Map();
        links.forEach(link => {
            const srcId = _getLinkEndpointId(link, 'source');
            const tgtId = _getLinkEndpointId(link, 'target');
            const srcIdx = nodeFileIdx.get(srcId) ?? -1;
            const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;

            // Skip internal edges and invalid indices
            if (srcIdx < 0 || tgtIdx < 0 || srcIdx === tgtIdx) return;

            const key = `${srcIdx}->${tgtIdx}`;
            const existing = edgeMap.get(key) || {
                source: _fileNodeIds.get(srcIdx),
                target: _fileNodeIds.get(tgtIdx),
                weight: 0,
                edge_type: 'file-dependency',
                resolution: 'file'
            };
            existing.weight += 1;
            edgeMap.set(key, existing);
        });

        _fileGraph = {
            nodes: fileNodes,
            links: Array.from(edgeMap.values())
        };

        console.log(`[FILE_VIZ] Built file graph: ${fileNodes.length} files, ${edgeMap.size} inter-file edges`);
        return _fileGraph;
    }

    function _getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (!endpoint) return null;
        if (typeof endpoint === 'object') return endpoint.id;
        return endpoint;
    }

    /**
     * Save current file node positions for smooth transitions
     */
    function captureFileNodePositions() {
        _fileNodePositions.clear();
        if (typeof Graph === 'undefined' || !Graph) return;

        const nodes = Graph.graphData()?.nodes || [];
        nodes.forEach(node => {
            if (node && node.isFileNode && Number.isFinite(node.x) && Number.isFinite(node.y)) {
                _fileNodePositions.set(node.fileIdx, {
                    x: node.x,
                    y: node.y,
                    z: Number.isFinite(node.z) ? node.z : 0
                });
            }
        });
    }

    /**
     * Restore saved positions to file nodes
     */
    function restoreFileNodePositions(nodes) {
        nodes.forEach(node => {
            if (node.isFileNode && _fileNodePositions.has(node.fileIdx)) {
                const pos = _fileNodePositions.get(node.fileIdx);
                node.x = pos.x;
                node.y = pos.y;
                node.z = pos.z;
            }
        });
    }

    /**
     * Get file target position for radial layout
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpread) {
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: (Math.random() - 0.5) * zSpread
        };
    }

    /**
     * Expand a file to show its atoms
     */
    function expandFile(fileIdx) {
        _expandedFiles.add(fileIdx);
        _graphMode = 'hybrid';
        if (typeof refreshGraph === 'function') refreshGraph();
    }

    /**
     * Collapse a file to hide its atoms
     */
    function collapseFile(fileIdx) {
        _expandedFiles.delete(fileIdx);
        _graphMode = _expandedFiles.size > 0 ? 'hybrid' : 'files';
        if (typeof refreshGraph === 'function') refreshGraph();
    }

    /**
     * Toggle file expansion
     */
    function toggleFileExpansion(fileIdx) {
        if (_expandedFiles.has(fileIdx)) {
            collapseFile(fileIdx);
        } else {
            expandFile(fileIdx);
        }
    }

    /**
     * Apply the file graph to the visualization
     */
    function applyFileGraphMode() {
        if (!_fileGraph) {
            buildFileGraph();
        }
        if (!_fileGraph || typeof Graph === 'undefined' || !Graph) return;

        restoreFileNodePositions(_fileGraph.nodes);
        Graph.graphData(_fileGraph);
        applyColors(_fileGraph.nodes);

        // UPB Hook: Re-apply any active bindings to the new file nodes
        if (window.UPB && typeof window.UPB.apply === 'function') {
            // CRITICAL FIX: Recalculate ranges for FILE nodes because they track
            // much larger values (e.g. Total Tokens) than individual Atoms.
            // Without this, everything gets clamped to 1.0 (Max Size/Color).
            if (window.UPB.BINDINGS && window.UPB.BINDINGS.defaultGraph) {
                const activeBindings = window.UPB.BINDINGS.defaultGraph._bindings;
                const newRanges = {};

                Object.keys(activeBindings).forEach(targetKey => {
                    const bindings = activeBindings[targetKey];
                    bindings.forEach(b => {
                        const sourceKey = b.source;
                        // Extract values from file nodes for this source
                        const values = _fileGraph.nodes
                            .map(n => n[sourceKey])
                            .filter(v => typeof v === 'number');

                        if (values.length > 0) {
                            newRanges[sourceKey] = {
                                min: Math.min(...values),
                                max: Math.max(...values)
                            };
                        }
                    });
                });

                // Update graph ranges for this context
                window.UPB.init(newRanges);
            }

            const updates = window.UPB.apply(_fileGraph.nodes);

            // Apply updates to nodes
            updates.forEach(update => {
                const node = _fileGraph.nodes.find(n => n.id === update.id);
                if (node && update.visuals) {
                    Object.keys(update.visuals).forEach(key => {
                        if (typeof CONTROL_BAR !== 'undefined' && CONTROL_BAR.applyToNode) {
                            CONTROL_BAR.applyToNode(node, key, update.visuals[key]);
                        }
                    });
                }
            });
        }

        // Reheat simulation for nice spread
        Graph.d3ReheatSimulation();

        if (typeof showToast === 'function') {
            showToast(`File view: ${_fileGraph.nodes.length} files. Click to expand atoms.`);
        }
    }

    // =========================================================================
    // BOUNDARY MANAGEMENT
    // =========================================================================

    function clearBoundaries() {
        if (typeof Graph === 'undefined' || !Graph) return;
        const scene = Graph.scene();
        if (!scene) return;

        _boundaryMeshes.forEach(mesh => scene.remove(mesh));
        _boundaryMeshes = [];
    }

    function scheduleHullRedraw(delayMs = 1200) {
        if (_hullRedrawTimer) {
            clearTimeout(_hullRedrawTimer);
        }
        _hullRedrawTimer = setTimeout(() => {
            if (!(_enabled && _mode === 'hulls')) {
                _hullRedrawAttempts = 0;
                return;
            }

            // Call external drawFileBoundaries if available
            if (typeof drawFileBoundaries === 'function') {
                const drawn = drawFileBoundaries(null);
                if (drawn === 0 && _hullRedrawAttempts < 3) {
                    _hullRedrawAttempts += 1;
                    scheduleHullRedraw(1000);
                }
            }
        }, delayMs);
    }

    // =========================================================================
    // MODE CLEARING
    // =========================================================================

    function clearAllModes() {
        clearBoundaries();

        // Reset file cohesion force if active
        if (typeof clearFileCohesion === 'function') {
            clearFileCohesion();
        }

        // Reset cluster force if active
        if (typeof clusterForceActive !== 'undefined' && clusterForceActive &&
            typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('cluster', null);
            if (typeof DEFAULT_LINK_DISTANCE !== 'undefined' && DEFAULT_LINK_DISTANCE !== null) {
                Graph.d3Force('link').distance(DEFAULT_LINK_DISTANCE);
            }
            Graph.d3ReheatSimulation();
        }

        // Stop containment animation if active
        if (typeof stopContainmentAnimation === 'function') {
            stopContainmentAnimation();
        }

        // Clear containment spheres
        if (typeof FILE_CONTAINMENT !== 'undefined' && FILE_CONTAINMENT?.spheres) {
            const scene = typeof Graph !== 'undefined' ? Graph?.scene() : null;
            if (scene) {
                FILE_CONTAINMENT.spheres.forEach(s => {
                    if (s.mesh) scene.remove(s.mesh);
                });
            }
            FILE_CONTAINMENT.spheres = [];
            FILE_CONTAINMENT.boundariesPopped = false;
        }

        // Clear lingering filters
        if (typeof VIS_FILTERS !== 'undefined') {
            const filterSets = ['rings', 'tiers', 'families', 'files', 'roles', 'edges', 'layers', 'effects', 'edgeFamilies'];
            filterSets.forEach(key => {
                if (VIS_FILTERS[key]?.clear) VIS_FILTERS[key].clear();
            });
            document.querySelectorAll('.filter-chip.active').forEach(c => c.classList.remove('active'));
        }

        // Reset POP button state
        const popBtn = document.getElementById('btn-file-pop');
        if (popBtn) {
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
        }
    }

    // =========================================================================
    // SET FILE MODE STATE
    // =========================================================================

    function setEnabled(enabled) {
        _enabled = enabled;

        // Update UI buttons
        const cmdBtn = document.getElementById('cmd-files');
        if (cmdBtn) cmdBtn.classList.toggle('active', _enabled);
        const dockBtn = document.getElementById('btn-files');
        if (dockBtn) dockBtn.classList.toggle('active', _enabled);

        // Update panels
        const filePanel = document.getElementById('file-panel');
        const modeControls = document.getElementById('file-mode-controls');
        const expandControls = document.getElementById('file-expand-controls');

        if (_enabled) {
            if (filePanel) filePanel.classList.add('visible');
            if (modeControls) modeControls.classList.add('visible');
            if (expandControls) expandControls.classList.toggle('visible', _mode === 'map');
            apply();
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            // Use unified LAYOUT module for reflow
            if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
        } else {
            if (filePanel) filePanel.classList.remove('visible');
            if (modeControls) modeControls.classList.remove('visible');
            if (expandControls) expandControls.classList.remove('visible');

            // Clear expanded files
            if (typeof EXPANDED_FILES !== 'undefined') EXPANDED_FILES.clear();
            if (typeof GRAPH_MODE !== 'undefined') window.GRAPH_MODE = 'atoms';

            // Use unified LAYOUT module for reflow
            if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();

            clearAllModes();
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            if (typeof refreshGraph === 'function') refreshGraph();
        }
    }

    function toggle() {
        setEnabled(!_enabled);
    }

    // =========================================================================
    // SET VIZ MODE
    // =========================================================================

    function setMode(mode) {
        if (!MODES.includes(mode)) return;
        _mode = mode;

        // Update button states
        document.querySelectorAll('.file-mode-btn').forEach(btn => btn.classList.remove('active'));
        const modeBtn = document.getElementById('btn-file-' + mode);
        if (modeBtn) modeBtn.classList.add('active');

        // Toggle expand controls visibility
        const expandControls = document.getElementById('file-expand-controls');
        if (expandControls) expandControls.classList.toggle('visible', _mode === 'map');
        if (_mode === 'map' && typeof updateExpandButtons === 'function') {
            updateExpandButtons();
        }

        // Update graph mode
        if (_mode === 'map') {
            const hasExpanded = typeof EXPANDED_FILES !== 'undefined' && EXPANDED_FILES.size > 0;
            if (typeof GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = hasExpanded ? 'hybrid' : 'files';
            }
        } else {
            if (typeof EXPANDED_FILES !== 'undefined') EXPANDED_FILES.clear();
            if (typeof GRAPH_MODE !== 'undefined') window.GRAPH_MODE = 'atoms';
        }

        // Apply mode
        if (!_enabled) {
            setEnabled(true);
        } else if (_mode === 'map') {
            apply();
        } else {
            if (typeof refreshGraph === 'function') refreshGraph();
        }
    }

    // =========================================================================
    // APPLY CURRENT MODE
    // =========================================================================

    function apply() {
        if (!_enabled) return;

        // Clear previous state
        clearBoundaries();
        if (_mode !== 'hulls') {
            _hullRedrawAttempts = 0;
        }

        // Get graph nodes
        const dm = typeof DATA !== 'undefined' ? DATA :
            (typeof DM !== 'undefined' ? DM : null);
        const graphNodes = dm?.getVisibleNodes ?
            dm.getVisibleNodes() :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes || [] : []);

        // Apply file cohesion for color/hulls/cluster modes
        if (_mode === 'color' || _mode === 'hulls' || _mode === 'cluster') {
            if (typeof applyFileCohesion === 'function' && dm?.raw) {
                const physicsPayload = { physics: dm.raw.physics, config: dm.raw.config };
                applyFileCohesion(physicsPayload);
            }
        }

        if (_mode === 'color') {
            applyColors(graphNodes);
        }
        else if (_mode === 'hulls') {
            applyColors(graphNodes);
            scheduleHullRedraw(1500);
        }
        else if (_mode === 'cluster') {
            applyColors(graphNodes);
            if (typeof applyClusterForce === 'function' && dm?.raw) {
                applyClusterForce(dm.raw);
            }
        }
        else if (_mode === 'map') {
            const hasExpanded = typeof EXPANDED_FILES !== 'undefined' && EXPANDED_FILES.size > 0;
            if (typeof GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = hasExpanded ? 'hybrid' : 'files';
            }
            if (typeof refreshGraph === 'function') refreshGraph();
            if (typeof showToast === 'function') {
                showToast('File map active. Click a file node to expand.');
            }
        }
        else if (_mode === 'spheres') {
            applyColors(graphNodes);
            if (typeof buildDirectoryTree === 'function' && dm?.raw) {
                buildDirectoryTree(dm.raw);
            }
            if (typeof computeFileActivity === 'function' && dm?.raw) {
                computeFileActivity(dm.raw, graphNodes);
            }
            if (typeof drawContainmentSpheres === 'function' && dm?.raw) {
                drawContainmentSpheres(dm.raw, graphNodes);
            }
            if (typeof startContainmentAnimation === 'function') {
                startContainmentAnimation();
            }
            if (typeof showToast === 'function') {
                showToast('Containment spheres active. Files as force fields. Click POP! to release.');
            }
        }
    }

    // =========================================================================
    // FILE CLUSTERING FORCES - D3 force manipulation for file grouping
    // =========================================================================

    let _clusterForceActive = false;
    let _fileCohesionActive = false;

    /**
     * Apply cluster force to group nodes by file
     * Creates fixed target positions arranged in a circular pattern
     */
    function applyClusterForce(data) {
        const Graph = window.Graph;
        const DM = window.DM;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const IS_3D = window.IS_3D;

        const clusterConfig = data?.physics?.cluster || {};
        const modeStrength = (typeof clusterConfig.modes?.strong === 'number') ? clusterConfig.modes.strong : null;
        const sliderStrength = (typeof APPEARANCE_STATE?.clusterStrength === 'number') ? APPEARANCE_STATE.clusterStrength : null;
        const clusterStrength = (typeof sliderStrength === 'number')
            ? sliderStrength
            : ((typeof modeStrength === 'number')
                ? modeStrength
                : ((typeof clusterConfig.strength === 'number') ? clusterConfig.strength : 0.3));
        const clusterRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius : 150;
        const clusterZSpacing = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing : 30;
        const linkDistance = (typeof clusterConfig.linkDistance === 'number')
            ? clusterConfig.linkDistance
            : (data?.physics?.forces?.link?.distance || 50);

        const graphNodes = DM ? DM.getVisibleNodes() : (Graph?.graphData()?.nodes || []);
        const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
        const numFiles = boundaries.length;

        // Fixed target positions: arrange files in circular pattern
        const fileTargets = {};
        for (let i = 0; i < numFiles; i++) {
            fileTargets[i] = getFileTarget(i, numFiles, clusterRadius, clusterZSpacing);
        }

        // Reduce link distance to keep intra-file nodes tighter
        Graph.d3Force('link').distance(linkDistance);

        // Apply strong clustering force toward fixed targets
        Graph.d3Force('cluster', (alpha) => {
            const k = alpha * clusterStrength;
            graphNodes.forEach(node => {
                const target = fileTargets[node.fileIdx];
                if (target) {
                    node.vx = (node.vx || 0) + (target.x - node.x) * k;
                    node.vy = (node.vy || 0) + (target.y - node.y) * k;
                    if (IS_3D) {
                        node.vz = (node.vz || 0) + (target.z - node.z) * k;
                    }
                }
            });
        });

        _clusterForceActive = true;
        Graph.d3ReheatSimulation();
        scheduleHullRedraw(1500);
    }

    /**
     * Apply file cohesion force - nodes in same file attract each other
     * Also stretches inter-file links for better separation
     */
    function applyFileCohesion(data) {
        if (_fileCohesionActive) return;

        const Graph = window.Graph;
        const DM = window.DM;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const IS_3D = window.IS_3D;
        const DEFAULT_LINK_DISTANCE = window.DEFAULT_LINK_DISTANCE || 50;

        const config = data?.physics?.fileCohesion || {};
        const strength = (typeof APPEARANCE_STATE?.fileCohesionStrength === 'number')
            ? APPEARANCE_STATE.fileCohesionStrength
            : (config.strength ?? 0.15);
        const linkMult = config.interFileLinkMultiplier ?? 2.5;
        const minDist = config.minDistance ?? 20;

        const nodes = DM ? DM.getVisibleNodes() : (Graph?.graphData()?.nodes || []);
        if (!nodes.length) return;

        // Pre-compute file groups
        const groups = new Map();
        nodes.forEach(n => {
            const f = n.fileIdx ?? -1;
            if (f >= 0) (groups.get(f) || groups.set(f, []).get(f)).push(n);
        });

        // Intra-file centroid attraction
        Graph.d3Force('fileCohesion', (alpha) => {
            const k = strength * alpha;
            groups.forEach(g => {
                if (g.length < 2) return;
                let cx = 0, cy = 0, cz = 0;
                g.forEach(n => { cx += n.x || 0; cy += n.y || 0; cz += n.z || 0; });
                cx /= g.length; cy /= g.length; cz /= g.length;
                g.forEach(n => {
                    const dx = cx - (n.x || 0), dy = cy - (n.y || 0), dz = cz - (n.z || 0);
                    const d = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;
                    if (d > minDist) {
                        const f = k * Math.min(1, d / 100);
                        n.vx = (n.vx || 0) + dx * f;
                        n.vy = (n.vy || 0) + dy * f;
                        if (IS_3D) n.vz = (n.vz || 0) + dz * f;
                    }
                });
            });
        });

        // Inter-file links stretched
        const base = DEFAULT_LINK_DISTANCE;
        Graph.d3Force('link').distance(link => {
            const s = typeof link.source === 'object' ? link.source : nodes.find(n => n.id === link.source);
            const t = typeof link.target === 'object' ? link.target : nodes.find(n => n.id === link.target);
            if (!s || !t) return base;
            const sf = s.fileIdx ?? -1, tf = t.fileIdx ?? -1;
            return (sf >= 0 && tf >= 0 && sf !== tf) ? base * linkMult : base;
        });

        _fileCohesionActive = true;
        Graph.d3ReheatSimulation();
    }

    /**
     * Clear file cohesion force
     */
    function clearFileCohesion() {
        if (!_fileCohesionActive) return;

        const Graph = window.Graph;
        const DEFAULT_LINK_DISTANCE = window.DEFAULT_LINK_DISTANCE;

        Graph.d3Force('fileCohesion', null);
        if (DEFAULT_LINK_DISTANCE !== null) {
            Graph.d3Force('link').distance(DEFAULT_LINK_DISTANCE);
        }
        _fileCohesionActive = false;
        Graph.d3ReheatSimulation();
    }

    /**
     * Clear cluster force
     */
    function clearClusterForce() {
        if (!_clusterForceActive) return;

        const Graph = window.Graph;
        Graph.d3Force('cluster', null);
        _clusterForceActive = false;
        Graph.d3ReheatSimulation();
    }

    // =========================================================================
    // FILE CONTAINMENT SYSTEM - Spherical fields with particle physics
    // "Metaphysical force from another dimension" - holding particles together
    // =========================================================================

    const _containment = {
        spheres: [],              // Three.js sphere meshes
        directoryTree: null,      // Parsed directory hierarchy
        particleActivity: {},     // FileIdx → activity level (0-1)
        boundariesPopped: false,  // Animation state
        popProgress: 0,           // 0 = contained, 1 = fully free
        slowMotionFactor: 0.15,   // Time multiplier for dreamy slow motion
        collisionEnabled: true,   // Enable soft collisions
        spatialGrid: null,        // For efficient collision detection
        gridCellSize: 20,         // Size of spatial hash cells
        animationFrame: null,
        isAnimating: false
    };

    /**
     * Toggle file expansion for a single file
     */
    function toggleFileExpand(fileIdx) {
        if (!Number.isFinite(fileIdx)) return;
        captureFileNodePositions();
        const dm = typeof DATA !== 'undefined' ? DATA : (typeof DM !== 'undefined' ? DM : null);
        const fileInfo = dm ? dm.getFile(fileIdx) : {};
        const fileLabel = fileInfo?.file_name || fileInfo?.file || `file-${fileIdx}`;
        if (_expandedFiles.has(fileIdx)) {
            _expandedFiles.delete(fileIdx);
            if (typeof showToast === 'function') showToast(`Collapsed ${fileLabel}`);
        } else {
            _expandedFiles.clear();
            _expandedFiles.add(fileIdx);
            if (typeof showToast === 'function') showToast(`Expanded ${fileLabel}`);
        }
        window.GRAPH_MODE = (_expandedFiles.size > 0) ? 'hybrid' : 'files';
        if (typeof refreshGraph === 'function') refreshGraph();
    }

    /**
     * Draw file boundary hulls
     */
    function drawFileBoundaries(data) {
        const Graph = window.Graph;
        const IS_3D = window.IS_3D;
        const APPEARANCE_STATE = window.APPEARANCE_STATE || {};
        const dm = typeof DATA !== 'undefined' ? DATA : (typeof DM !== 'undefined' ? DM : null);

        let drawn = 0;
        const boundaryConfig = data?.appearance?.boundary || {};
        const fillOpacity =
            (typeof APPEARANCE_STATE.boundaryFill === 'number')
                ? APPEARANCE_STATE.boundaryFill
                : (boundaryConfig.fill_opacity || 0.05); // Reduced from 0.08
        const wireOpacity =
            (typeof APPEARANCE_STATE.boundaryWire === 'number')
                ? APPEARANCE_STATE.boundaryWire
                : (boundaryConfig.wire_opacity || 0.15); // Reduced from 0.3
        const padding = boundaryConfig.padding || 1.2;
        const minExtent = boundaryConfig.min_extent || 6;
        const quantileRange = boundaryConfig.quantile || 0.9;
        const lowQ = Math.max(0, (1 - quantileRange) / 2);
        const highQ = Math.min(1, 1 - lowQ);
        const boundaryPhysics = data?.physics?.boundary || {};
        const hullType = String(boundaryPhysics.hullType || 'convex').toLowerCase();
        const fileBoundaries = dm ? dm.getFileBoundaries() : (data?.file_boundaries || []);
        const totalFiles = fileBoundaries.length;

        const graphNodes = dm ? dm.getVisibleNodes() : (Graph?.graphData()?.nodes || []);
        const scene = Graph?.scene();
        if (!scene) return drawn;

        // Clear existing boundary meshes
        _boundaryMeshes.forEach(mesh => scene.remove(mesh));
        _boundaryMeshes = [];

        if (!_enabled) return drawn;

        // Group nodes by file (only use nodes with stable positions)
        const fileGroups = {};
        const validNodes = graphNodes.filter(node => {
            if (!node) return false;
            if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return false;
            if (IS_3D && !Number.isFinite(node.z)) return false;
            return true;
        });

        if (!validNodes.length) return drawn;

        validNodes.forEach(node => {
            const idx = node.fileIdx;
            if (idx >= 0) {
                if (!fileGroups[idx]) fileGroups[idx] = [];
                fileGroups[idx].push(node);
            }
        });

        // Draw boundary for each file group
        Object.entries(fileGroups).forEach(([fileIdx, nodes]) => {
            const sampled = typeof sampleFileNodes === 'function' ? sampleFileNodes(nodes, 180) : nodes.slice(0, 180);
            const xs = sampled.map(n => n.x || 0);
            const ys = sampled.map(n => n.y || 0);
            const zs = sampled.map(n => n.z || 0);

            const quantileFn = typeof quantile === 'function' ? quantile : (arr, q) => arr.sort((a, b) => a - b)[Math.floor(arr.length * q)] || 0;
            const minX = quantileFn(xs, lowQ);
            const maxX = quantileFn(xs, highQ);
            const minY = quantileFn(ys, lowQ);
            const maxY = quantileFn(ys, highQ);
            const minZ = quantileFn(zs, lowQ);
            const maxZ = quantileFn(zs, highQ);

            const filtered = sampled.filter(n => {
                const x = n.x || 0;
                const y = n.y || 0;
                const z = n.z || 0;
                return x >= minX && x <= maxX && y >= minY && y <= maxY && z >= minZ && z <= maxZ;
            });
            const hullNodes = filtered.length >= 3 ? filtered : sampled;
            const positions = hullNodes.map(n => new THREE.Vector3(n.x || 0, n.y || 0, n.z || 0));
            const centroid = typeof computeCentroid === 'function' ? computeCentroid(positions) :
                new THREE.Vector3(
                    positions.reduce((s, p) => s + p.x, 0) / positions.length,
                    positions.reduce((s, p) => s + p.y, 0) / positions.length,
                    positions.reduce((s, p) => s + p.z, 0) / positions.length
                );
            const zRange = maxZ - minZ;
            const extentX = Math.max(0.001, maxX - minX);
            const extentY = Math.max(0.001, maxY - minY);
            const extentZ = Math.max(0.001, maxZ - minZ);
            const scaleFixX = Math.max(1, minExtent / extentX);
            const scaleFixY = Math.max(1, minExtent / extentY);
            const scaleFixZ = IS_3D ? Math.max(1, minExtent / extentZ) : 1;
            const scaleX = padding * scaleFixX;
            const scaleY = padding * scaleFixY;
            const scaleZ = padding * scaleFixZ;
            const sizeX = extentX * scaleX;
            const sizeY = extentY * scaleY;
            const sizeZ = extentZ * scaleZ;

            const fileIndex = Number.parseInt(fileIdx, 10);
            const safeFileIdx = Number.isFinite(fileIndex) ? fileIndex : 0;
            const fileInfo = (fileBoundaries || [])[safeFileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            const color = new THREE.Color(getColor(safeFileIdx, totalFiles, fileLabel));

            let mesh = null;
            let wireMesh = null;

            if (nodes.length < 3) {
                const rawPositions = nodes.map(n => new THREE.Vector3(n.x || 0, n.y || 0, n.z || 0));
                const smallCentroid = typeof computeCentroid === 'function' ? computeCentroid(rawPositions) :
                    new THREE.Vector3(
                        rawPositions.reduce((s, p) => s + p.x, 0) / rawPositions.length,
                        rawPositions.reduce((s, p) => s + p.y, 0) / rawPositions.length,
                        rawPositions.reduce((s, p) => s + p.z, 0) / rawPositions.length
                    );
                const maxRadius = rawPositions.reduce((acc, p) => {
                    return Math.max(acc, p.distanceTo(smallCentroid));
                }, 0);
                const bubbleRadius = Math.max(minExtent * 0.5, maxRadius + minExtent * 0.35);
                const material = new THREE.MeshBasicMaterial({
                    color: color, transparent: true, opacity: fillOpacity,
                    wireframe: false, side: THREE.DoubleSide, depthWrite: false
                });
                if (IS_3D) {
                    const geometry = new THREE.SphereGeometry(bubbleRadius, 14, 10);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.copy(smallCentroid);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(geometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                } else {
                    const geometry = new THREE.CircleGeometry(bubbleRadius, 32);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(smallCentroid.x, smallCentroid.y, smallCentroid.z);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(geometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                }
            }

            if (!mesh && hullType === 'convex') {
                if (IS_3D && zRange > 0.001 && positions.length >= 4) {
                    const ConvexCtor =
                        (typeof ConvexGeometry !== 'undefined')
                            ? ConvexGeometry
                            : (THREE.ConvexGeometry || null);
                    const relPoints = positions.map(p => p.clone().sub(centroid));
                    let boundaryGeometry = null;
                    if (ConvexCtor) {
                        try { boundaryGeometry = new ConvexCtor(relPoints); }
                        catch (err) { boundaryGeometry = null; }
                    }
                    if (boundaryGeometry) {
                        const material = new THREE.MeshBasicMaterial({
                            color: color, transparent: true, opacity: fillOpacity,
                            wireframe: false, side: THREE.DoubleSide, depthWrite: false
                        });
                        mesh = new THREE.Mesh(boundaryGeometry, material);
                        mesh.position.copy(centroid);
                        mesh.scale.set(scaleX, scaleY, scaleZ);
                        const wireMaterial = new THREE.LineBasicMaterial({
                            color: color, transparent: true, opacity: wireOpacity
                        });
                        const edges = new THREE.EdgesGeometry(boundaryGeometry);
                        wireMesh = new THREE.LineSegments(edges, wireMaterial);
                        wireMesh.position.copy(centroid);
                        wireMesh.scale.copy(mesh.scale);
                    }
                }

                if (!mesh) {
                    const hull2d = typeof buildHull2D === 'function' ?
                        buildHull2D(positions.map(p => new THREE.Vector2(p.x, p.y))) : null;
                    if (!hull2d || hull2d.length < 3) return;
                    const localHull = hull2d.map(p => new THREE.Vector2(p.x - centroid.x, p.y - centroid.y));
                    const shape = new THREE.Shape(localHull);
                    const boundaryGeometry = new THREE.ShapeGeometry(shape);
                    const material = new THREE.MeshBasicMaterial({
                        color: color, transparent: true, opacity: fillOpacity,
                        wireframe: false, side: THREE.DoubleSide, depthWrite: false
                    });
                    mesh = new THREE.Mesh(boundaryGeometry, material);
                    mesh.position.set(centroid.x, centroid.y, centroid.z);
                    mesh.scale.set(scaleX, scaleY, 1);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const wireGeometry = new THREE.BufferGeometry().setFromPoints(
                        localHull.map(p => new THREE.Vector3(p.x, p.y, 0))
                    );
                    wireMesh = new THREE.LineLoop(wireGeometry, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                    wireMesh.scale.copy(mesh.scale);
                }
            } else if (!mesh && hullType === 'box') {
                const material = new THREE.MeshBasicMaterial({
                    color: color, transparent: true, opacity: fillOpacity,
                    wireframe: false, side: THREE.DoubleSide, depthWrite: false
                });
                if (IS_3D) {
                    const geometry = new THREE.BoxGeometry(sizeX, sizeY, sizeZ);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.copy(centroid);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(geometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                } else {
                    const geometry = new THREE.PlaneGeometry(sizeX, sizeY);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(centroid.x, centroid.y, centroid.z);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(geometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                }
            } else if (!mesh) {
                const radius = 0.5 * Math.max(sizeX, sizeY, IS_3D ? sizeZ : 0);
                const material = new THREE.MeshBasicMaterial({
                    color: color, transparent: true, opacity: fillOpacity,
                    wireframe: false, side: THREE.DoubleSide, depthWrite: false
                });
                if (IS_3D) {
                    const geometry = new THREE.SphereGeometry(radius, 18, 14);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.copy(centroid);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(geometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                } else {
                    const geometry = new THREE.CircleGeometry(radius, 40);
                    mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(centroid.x, centroid.y, centroid.z);
                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color, transparent: true, opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(geometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(mesh.position);
                }
            }

            if (!mesh) return;
            scene.add(mesh);
            _boundaryMeshes.push(mesh);
            drawn += 1;
            if (wireMesh) {
                scene.add(wireMesh);
                _boundaryMeshes.push(wireMesh);
            }
        });
        return drawn;
    }

    /**
     * Build directory tree from file paths
     */
    function buildDirectoryTree(data) {
        const fileBoundaries = data?.file_boundaries || [];
        const tree = { name: '/', path: '', depth: 0, children: {}, files: [], totalNodes: 0 };

        fileBoundaries.forEach((file, idx) => {
            const filePath = file.file || file.file_name || '';
            const parts = filePath.split('/').filter(p => p);
            let current = tree;

            parts.forEach((part, partIdx) => {
                const isFile = partIdx === parts.length - 1;
                if (isFile) {
                    current.files.push({
                        name: part, path: filePath, fileIdx: idx,
                        nodeCount: (file.atom_ids || []).length, activity: 0
                    });
                } else {
                    if (!current.children[part]) {
                        current.children[part] = {
                            name: part, path: parts.slice(0, partIdx + 1).join('/'),
                            depth: partIdx + 1, children: {}, files: [], totalNodes: 0
                        };
                    }
                    current = current.children[part];
                }
            });
        });

        _containment.directoryTree = tree;
        return tree;
    }

    /**
     * Compute activity levels from markov transitions
     */
    function computeFileActivity(data) {
        const markov = data?.markov || {};
        const highEntropy = markov.high_entropy_nodes || [];
        const transitions = markov.transitions || {};
        const fileActivity = {};

        (data?.file_boundaries || []).forEach((file, idx) => {
            const atomIds = file.atom_ids || [];
            let activity = 0;
            atomIds.forEach(atomId => {
                if (highEntropy.some(h => h.node === atomId)) activity += 0.3;
                const fanout = Object.keys(transitions[atomId] || {}).length;
                activity += Math.min(fanout / 10, 0.5);
            });
            fileActivity[idx] = Math.min(1, activity / Math.max(1, atomIds.length));
        });

        _containment.particleActivity = fileActivity;
        return fileActivity;
    }

    /**
     * Draw containment spheres/boxes
     */
    function drawContainmentSpheres(_data) {
        const Graph = window.Graph;
        const flowMode = window.flowMode;
        const dm = typeof DATA !== 'undefined' ? DATA : (typeof DM !== 'undefined' ? DM : null);

        const scene = Graph?.scene();
        if (!scene) return;
        const graphNodes = dm ? dm.getVisibleNodes() : (Graph?.graphData()?.nodes || []);

        // Clear existing
        _containment.spheres.forEach(s => {
            if (s.mesh) scene.remove(s.mesh);
            if (s.wireframe) scene.remove(s.wireframe);
            if (s.glow) scene.remove(s.glow);
        });
        _containment.spheres = [];

        const hullsActive = document.getElementById('btn-file-hulls')?.classList.contains('active');
        if (!_enabled || flowMode || !hullsActive || _containment.boundariesPopped) return;

        // Group nodes by file
        const fileGroups = {};
        graphNodes.filter(n => n && Number.isFinite(n.x)).forEach(node => {
            if (node.fileIdx >= 0) {
                if (!fileGroups[node.fileIdx]) fileGroups[node.fileIdx] = [];
                fileGroups[node.fileIdx].push(node);
            }
        });

        Object.entries(fileGroups).forEach(([fileIdx, nodes]) => {
            if (nodes.length < 3) return;

            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            nodes.forEach(n => {
                minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x);
                minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y);
                minZ = Math.min(minZ, n.z || 0); maxZ = Math.max(maxZ, n.z || 0);
            });

            const pad = 10;
            const width = (maxX - minX) + pad * 2;
            const height = (maxY - minY) + pad * 2;
            const depth = (maxZ - minZ) + pad * 2;

            if (width < 5 || height < 5 || depth < 5) return;

            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;
            const cz = (minZ + maxZ) / 2;

            const geometry = new THREE.BoxGeometry(width, height, depth);
            const color = new THREE.Color(nodes[0].color || '#4488ff');

            const material = new THREE.MeshLambertMaterial({
                color: color, transparent: true, opacity: 0.15,
                depthWrite: false, side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(cx, cy, cz);
            scene.add(mesh);

            const wireGeo = new THREE.EdgesGeometry(geometry);
            const wireMat = new THREE.LineBasicMaterial({
                color: color, transparent: true, opacity: 0.4,
                blending: THREE.AdditiveBlending
            });
            const wireframe = new THREE.LineSegments(wireGeo, wireMat);
            wireframe.position.set(cx, cy, cz);
            scene.add(wireframe);

            _containment.spheres.push({
                mesh, wireframe,
                fileIdx: parseInt(fileIdx),
                velocity: new THREE.Vector3(0, 0, 0),
                activity: _containment.particleActivity[fileIdx] || 0,
                nodes: nodes.map(n => n.id)
            });
        });
    }

    /**
     * Start containment animation loop
     */
    function startContainmentAnimation() {
        if (_containment.isAnimating) return;
        _containment.isAnimating = true;
        const Graph = window.Graph;
        const IS_3D = window.IS_3D;

        function animate() {
            if (!_containment.isAnimating) return;

            const time = Date.now() * 0.001 * _containment.slowMotionFactor;
            const graphNodes = Graph?.graphData()?.nodes || [];

            if (_containment.boundariesPopped) {
                if (typeof applySoftCollisions === 'function') {
                    applySoftCollisions(graphNodes, _containment.gridCellSize, 0.4);
                }

                graphNodes.forEach(node => {
                    if (!node || !node.__physics) return;
                    const p = node.__physics;
                    const wander = 0.08;
                    p.vx += (Math.sin(time * 0.7 + (node.__wanderPhase || 0)) - 0.5) * wander;
                    p.vy += (Math.cos(time * 0.5 + (node.__wanderPhase || 0) * 1.3) - 0.5) * wander;
                    if (IS_3D) p.vz += (Math.sin(time * 0.6 + (node.__wanderPhase || 0) * 0.7) - 0.5) * wander;
                    p.vx *= 0.985;
                    p.vy *= 0.985;
                    p.vz *= 0.985;
                    node.x += p.vx;
                    node.y += p.vy;
                    if (IS_3D) node.z = (node.z || 0) + p.vz;
                });
            } else {
                _containment.spheres.forEach(sphere => {
                    const activity = sphere.activity;
                    const pulse = Math.sin(time * 2 + sphere.fileIdx) * 0.5 + 0.5;
                    if (sphere.mesh?.material) {
                        sphere.mesh.material.opacity = 0.04 + activity * 0.12 * pulse;
                    }
                    if (sphere.wireframe?.material) {
                        sphere.wireframe.material.opacity = 0.08 + activity * 0.2 * pulse;
                    }
                    if (activity < 0.05) return;

                    sphere.nodes.forEach(nodeId => {
                        const node = graphNodes.find(n => n.id === nodeId);
                        if (!node || !Number.isFinite(node.x)) return;
                        if (!node.__activityPhase) {
                            node.__activityPhase = {
                                x: Math.random() * Math.PI * 2,
                                y: Math.random() * Math.PI * 2,
                                z: Math.random() * Math.PI * 2
                            };
                        }
                        const amp = activity * 0.4;
                        const freq = 0.5 + activity * 0.5;
                        const phase = node.__activityPhase;
                        node.__renderOffsetX = Math.sin(time * freq + phase.x) * amp;
                        node.__renderOffsetY = Math.sin(time * freq * 1.2 + phase.y) * amp;
                        if (IS_3D) node.__renderOffsetZ = Math.sin(time * freq * 0.9 + phase.z) * amp;
                    });
                });
            }

            if (Graph) REFRESH.throttled();
            _containment.animationFrame = requestAnimationFrame(animate);
        }

        animate();
    }

    /**
     * Stop containment animation
     */
    function stopContainmentAnimation() {
        _containment.isAnimating = false;
        if (_containment.animationFrame) {
            cancelAnimationFrame(_containment.animationFrame);
        }
    }

    /**
     * Pop boundaries - release particles into free Brownian motion
     */
    function popBoundaries(duration = 3000) {
        if (_containment.boundariesPopped) {
            restoreBoundaries(duration);
            return;
        }

        console.log('[Containment] Popping boundaries...');
        _containment.boundariesPopped = true;
        const startTime = Date.now();
        const Graph = window.Graph;
        const IS_3D = window.IS_3D;
        const scene = Graph?.scene();
        const graphNodes = Graph?.graphData()?.nodes || [];

        graphNodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            node.__physics = {
                vx: (Math.random() - 0.5) * 1.5,
                vy: (Math.random() - 0.5) * 1.5,
                vz: IS_3D ? (Math.random() - 0.5) * 1.5 : 0
            };
            node.__wanderPhase = Math.random() * Math.PI * 2;
        });

        function animatePop() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);
            _containment.popProgress = progress;
            const eased = 1 - Math.pow(1 - progress, 3);

            _containment.spheres.forEach(s => {
                if (s.mesh?.material) s.mesh.material.opacity = (1 - eased) * 0.1;
                if (s.wireframe?.material) s.wireframe.material.opacity = (1 - eased) * 0.25;
                if (s.glow?.material) s.glow.material.opacity = (1 - eased) * 0.08;
            });

            if (progress < 1) {
                requestAnimationFrame(animatePop);
            } else {
                _containment.spheres.forEach(s => {
                    if (s.mesh) scene.remove(s.mesh);
                    if (s.wireframe) scene.remove(s.wireframe);
                    if (s.glow) scene.remove(s.glow);
                });
                _containment.spheres = [];
                console.log('[Containment] Particles now FREE - Brownian motion with collisions');
            }

            if (Graph) REFRESH.throttled();
        }

        animatePop();
        startContainmentAnimation();
    }

    /**
     * Restore boundaries
     */
    function restoreBoundaries(duration = 2000) {
        if (!_containment.boundariesPopped) return;

        console.log('[Containment] Restoring boundaries...');
        const startTime = Date.now();
        const Graph = window.Graph;
        const IS_3D = window.IS_3D;
        const dm = typeof DATA !== 'undefined' ? DATA : (typeof DM !== 'undefined' ? DM : null);
        const graphNodes = Graph?.graphData()?.nodes || [];

        graphNodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            node.__freePos = { x: node.x, y: node.y, z: node.z || 0 };
        });

        function animateRestore() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(1, elapsed / duration);
            _containment.popProgress = 1 - progress;
            const eased = Math.pow(progress, 2);

            graphNodes.forEach(node => {
                if (!node || !node.__freePos || !node.__originalPos) return;
                node.x = node.__freePos.x + (node.__originalPos.x - node.__freePos.x) * eased;
                node.y = node.__freePos.y + (node.__originalPos.y - node.__freePos.y) * eased;
                if (IS_3D) node.z = node.__freePos.z + ((node.__originalPos.z || 0) - node.__freePos.z) * eased;
            });

            if (progress < 1) {
                requestAnimationFrame(animateRestore);
            } else {
                _containment.boundariesPopped = false;
                drawContainmentSpheres(null);
                console.log('[Containment] Boundaries restored');
            }

            if (Graph) REFRESH.throttled();
        }

        animateRestore();
    }

    /**
     * Update expand mode buttons
     */
    function updateExpandButtons() {
        const inlineBtn = document.getElementById('btn-expand-inline');
        const detachBtn = document.getElementById('btn-expand-detach');
        if (inlineBtn) inlineBtn.classList.toggle('active', _expandMode === 'inline');
        if (detachBtn) detachBtn.classList.toggle('active', _expandMode === 'detach');
    }

    /**
     * Handle cmd-files button click
     */
    function handleCmdFiles() {
        const btn = document.getElementById('cmd-files');
        const isActive = btn ? btn.classList.contains('active') : false;
        setEnabled(!isActive);
    }

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getHue,
        applyColors,

        // Mode management
        setMode,
        get mode() { return _mode; },
        MODES,
        MODE_HINTS,

        // Enable/disable
        setEnabled,
        toggle,
        get enabled() { return _enabled; },

        // Apply
        apply,

        // FILE GRAPH - Repository as Nodes
        buildFileGraph,
        applyFileGraphMode,
        expandFile,
        collapseFile,
        toggleFileExpansion,
        captureFileNodePositions,
        restoreFileNodePositions,
        getFileTarget,
        get fileGraph() { return _fileGraph; },
        get fileNodeIds() { return _fileNodeIds; },
        get expandedFiles() { return _expandedFiles; },
        get graphMode() { return _graphMode; },
        set graphMode(val) { _graphMode = val; },
        get expandMode() { return _expandMode; },
        set expandMode(val) { _expandMode = val; },

        // VISUAL MAPPING - Metadata to Visual Properties
        applyVisualMapping,
        getColorForMapping,
        VISUAL_MAPPINGS,
        get activeMapping() { return _activeMapping; },
        set activeMapping(val) { _activeMapping = val; },

        // Boundaries
        clearBoundaries,
        clearAllModes,
        scheduleHullRedraw,

        // File Clustering Forces
        applyClusterForce,
        clearClusterForce,
        applyFileCohesion,
        clearFileCohesion,
        get clusterForceActive() { return _clusterForceActive; },
        get fileCohesionActive() { return _fileCohesionActive; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Internal state access (for migration)
        get boundaryMeshes() { return _boundaryMeshes; },
        set boundaryMeshes(val) { _boundaryMeshes = val; },

        // FILE CONTAINMENT SYSTEM - Moved from app.js
        toggleFileExpand,
        drawFileBoundaries,
        buildDirectoryTree,
        computeFileActivity,
        drawContainmentSpheres,
        startContainmentAnimation,
        stopContainmentAnimation,
        popBoundaries,
        restoreBoundaries,
        updateExpandButtons,
        handleCmdFiles,
        get containment() { return _containment; }
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'fileMode', {
    get: () => FILE_VIZ.enabled,
    set: (v) => FILE_VIZ.setEnabled(v),
    configurable: true
});
Object.defineProperty(window, 'fileVizMode', {
    get: () => FILE_VIZ.mode,
    set: (v) => FILE_VIZ.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'FILE_COLOR_CONFIG', {
    get: () => FILE_VIZ.config,
    configurable: true
});
Object.defineProperty(window, 'fileBoundaryMeshes', {
    get: () => FILE_VIZ.boundaryMeshes,
    set: (v) => { FILE_VIZ.boundaryMeshes = v; },
    configurable: true
});
// hullRedrawTimer, hullRedrawAttempts - app.js owns these, not duplicated here

function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride) {
    return FILE_VIZ.getColor(fileIdx, totalFiles, fileName, lightnessOverride);
}
function getFileHue(fileIdx, totalFiles, fileName) {
    return FILE_VIZ.getHue(fileIdx, totalFiles, fileName);
}
function setFileModeState(enabled) {
    FILE_VIZ.setEnabled(enabled);
}
function setFileVizMode(mode) {
    FILE_VIZ.setMode(mode);
}
function applyFileVizMode() {
    FILE_VIZ.apply();
}
function applyFileColors(graphNodes) {
    FILE_VIZ.applyColors(graphNodes);
}
function clearFileBoundaries() {
    FILE_VIZ.clearBoundaries();
}
function clearAllFileModes() {
    FILE_VIZ.clearAllModes();
}
function scheduleHullRedraw(delayMs) {
    FILE_VIZ.scheduleHullRedraw(delayMs);
}

// File graph backward compatibility - Using getters for live updates
Object.defineProperty(window, 'FILE_GRAPH', {
    get: () => FILE_VIZ.fileGraph,
    set: (val) => { /* Ignore - module manages state */ },
    configurable: true
});
Object.defineProperty(window, 'FILE_NODE_IDS', {
    get: () => FILE_VIZ.fileNodeIds,
    configurable: true
});
// FILE_NODE_POSITIONS is managed by app.js (not in this module's scope)
Object.defineProperty(window, 'EXPANDED_FILES', {
    get: () => FILE_VIZ.expandedFiles,
    configurable: true
});
Object.defineProperty(window, 'FILE_EXPAND_MODE', {
    get: () => FILE_VIZ.expandMode,
    set: (val) => { FILE_VIZ.expandMode = val; },
    configurable: true
});

function buildFileGraph(data) {
    // Calls module's buildFileGraph - FILE_GRAPH getter will return the result
    FILE_VIZ.buildFileGraph();
    FILE_NODE_IDS = FILE_VIZ.fileNodeIds;
    return FILE_VIZ.fileGraph;  // Return directly from module
}
function captureFileNodePositions() {
    FILE_VIZ.captureFileNodePositions();
}
function restoreNodePositions(nodes) {
    FILE_VIZ.restoreFileNodePositions(nodes);
}
function getFileTarget(fileIdx, totalFiles, radius, zSpread) {
    return FILE_VIZ.getFileTarget(fileIdx, totalFiles, radius, zSpread);
}

// File clustering force shims
function applyClusterForce(data) {
    FILE_VIZ.applyClusterForce(data);
}
function clearClusterForce() {
    FILE_VIZ.clearClusterForce();
}
function applyFileCohesion(data) {
    FILE_VIZ.applyFileCohesion(data);
}
function clearFileCohesion() {
    FILE_VIZ.clearFileCohesion();
}
Object.defineProperty(window, 'clusterForceActive', {
    get: () => FILE_VIZ.clusterForceActive,
    configurable: true
});
Object.defineProperty(window, 'fileCohesionActive', {
    get: () => FILE_VIZ.fileCohesionActive,
    configurable: true
});

// File containment system shims - moved from app.js
function toggleFileExpand(fileIdx) { FILE_VIZ.toggleFileExpand(fileIdx); }
function drawFileBoundaries(data) { return FILE_VIZ.drawFileBoundaries(data); }
function buildDirectoryTree(data) { return FILE_VIZ.buildDirectoryTree(data); }
function computeFileActivity(data, graphNodes) { return FILE_VIZ.computeFileActivity(data, graphNodes); }
function drawContainmentSpheres(data) { FILE_VIZ.drawContainmentSpheres(data); }
function startContainmentAnimation() { FILE_VIZ.startContainmentAnimation(); }
function stopContainmentAnimation() { FILE_VIZ.stopContainmentAnimation(); }
function popBoundaries(duration) { FILE_VIZ.popBoundaries(duration); }
function restoreBoundaries(duration) { FILE_VIZ.restoreBoundaries(duration); }
function updateExpandButtons() { FILE_VIZ.updateExpandButtons(); }
function handleCmdFiles() { FILE_VIZ.handleCmdFiles(); }

// Expose to global for button bindings and backward compatibility
window.popBoundaries = popBoundaries;
window.restoreBoundaries = restoreBoundaries;
window.toggleFileExpand = toggleFileExpand;
window.drawFileBoundaries = drawFileBoundaries;
window.buildDirectoryTree = buildDirectoryTree;
window.computeFileActivity = computeFileActivity;
window.drawContainmentSpheres = drawContainmentSpheres;
window.startContainmentAnimation = startContainmentAnimation;
window.stopContainmentAnimation = stopContainmentAnimation;
window.updateExpandButtons = updateExpandButtons;
window.handleCmdFiles = handleCmdFiles;

// FILE_CONTAINMENT state exposed via module
Object.defineProperty(window, 'FILE_CONTAINMENT', {
    get: () => FILE_VIZ.containment,
    configurable: true
});

console.log('[Module] FILE_VIZ loaded - file visualization, boundaries, containment');


// ═══ MODULE: modules/tooltips.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * TOOLTIPS MODULE - Tooltip and Toast Notifications
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles topology tooltips and toast notifications.
 * Depends on: TOOLTIP_STATE, HINTS_ENABLED, SMC_THEORY (globals)
 *
 * @module TOOLTIPS
 * @version 1.0.0
 * @confidence 99%
 */

window.TOOLTIPS = (function() {
    'use strict';

    // Module-local timeout reference
    let _toastTimeout = null;

    // ═══════════════════════════════════════════════════════════════════════
    // TOOLTIP OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize tooltip elements
     */
    function initTooltips() {
        const state = window.TOOLTIP_STATE;
        if (state) {
            state.element = document.getElementById('topo-tooltip');
        }
    }

    /**
     * Show topology tooltip with theory content
     * @param {string} category - Theory category (tiers, rings, families, etc.)
     * @param {string} key - Item key within category
     * @param {number} x - Screen X position
     * @param {number} y - Screen Y position
     */
    function showTopoTooltip(category, key, x, y) {
        const state = window.TOOLTIP_STATE;
        if (!state) return;

        if (!state.element) initTooltips();
        if (!state.element) return;

        const theory = window.SMC_THEORY;
        const content = theory?.[category]?.[key];
        if (!content) return;

        clearTimeout(state.hideTimeout);

        // Populate tooltip content
        const iconEl = document.getElementById('tooltip-icon');
        const titleEl = document.getElementById('tooltip-title');
        const subtitleEl = document.getElementById('tooltip-subtitle');
        const bodyEl = document.getElementById('tooltip-body');
        const theoryEl = document.getElementById('tooltip-theory');
        const examplesEl = document.getElementById('tooltip-examples');

        if (iconEl) iconEl.textContent = content.icon || '';
        if (titleEl) titleEl.textContent = content.title || key;
        if (subtitleEl) subtitleEl.textContent = content.subtitle || '';
        if (bodyEl) bodyEl.textContent = content.body || '';
        if (theoryEl) theoryEl.textContent = content.theory || '';
        if (examplesEl) {
            examplesEl.innerHTML = (content.examples || [])
                .map(ex => `<span class="topo-tooltip-example">${ex}</span>`)
                .join('');
        }

        // Position tooltip
        const tooltip = state.element;
        let left = x + 15, top = y + 15;
        if (left + 280 > window.innerWidth) left = x - 295;
        if (top + 200 > window.innerHeight) top = y - 215;
        if (left < 0) left = 15;
        if (top < 0) top = 15;

        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.classList.add('visible');

        state.visible = true;
        state.currentKey = `${category}:${key}`;
    }

    /**
     * Hide topology tooltip
     * @param {boolean} immediate - Hide immediately without delay
     */
    function hideTopoTooltip(immediate = false) {
        const state = window.TOOLTIP_STATE;
        if (!state || !state.element) return;

        if (immediate) {
            state.element.classList.remove('visible');
            state.visible = false;
        } else {
            state.hideTimeout = setTimeout(() => {
                state.element.classList.remove('visible');
                state.visible = false;
            }, 150);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Show a toast notification
     * @param {string} message - Message to display
     */
    function showToast(message) {
        const toast = document.getElementById('hud-toast');
        if (!toast) return;

        toast.textContent = message;
        toast.classList.add('visible');

        clearTimeout(toast._timer);
        toast._timer = setTimeout(() => {
            toast.classList.remove('visible');
        }, 2200);
    }

    /**
     * Show mode change toast (respects hints setting)
     * @param {string} message - Message to display
     */
    function showModeToast(message) {
        if (!window.HINTS_ENABLED) return;

        let toast = document.getElementById('mode-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'mode-toast';
            toast.className = 'mode-toast';
            document.body.appendChild(toast);
        }

        toast.textContent = message;
        toast.classList.add('visible');

        if (_toastTimeout) clearTimeout(_toastTimeout);
        _toastTimeout = setTimeout(() => {
            toast.classList.remove('visible');
        }, 1200);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        init: initTooltips,
        showTopo: showTopoTooltip,
        hideTopo: hideTopoTooltip,
        toast: showToast,
        modeToast: showModeToast
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.initTooltips = TOOLTIPS.init;
window.showTopoTooltip = TOOLTIPS.showTopo;
window.hideTopoTooltip = TOOLTIPS.hideTopo;
window.showToast = TOOLTIPS.toast;
window.showModeToast = TOOLTIPS.modeToast;

console.log('[Module] TOOLTIPS loaded - 5 functions');


// ═══ MODULE: modules/theme.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * THEME MODULE - Runtime Theme Management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles theme switching, persistence, and initialization.
 * Depends on: THEME_CONFIG (global), Graph (global), THREE (global)
 *
 * @module THEME
 * @version 1.0.0
 * @confidence 99%
 */

window.THEME = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // THEME OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Set the active theme by name.
     * Updates document data-theme attribute and stores preference.
     * @param {string} themeName - Theme name: 'dark', 'light', or 'high-contrast'
     */
    function setTheme(themeName) {
        const config = window.THEME_CONFIG;
        if (!config || !config.available.includes(themeName)) {
            console.warn(`[Theme] Unknown theme: ${themeName}. Available: ${config?.available?.join(', ') || 'none'}`);
            return;
        }

        // Update document attribute for CSS variable switching
        document.documentElement.setAttribute('data-theme', themeName);

        // Update global state
        config.current = themeName;

        // Store preference in localStorage
        try {
            localStorage.setItem('collider-theme', themeName);
        } catch (e) {
            console.warn('[Theme] Could not save preference:', e);
        }

        // Update canvas background if WebGL renderer is active
        const Graph = window.Graph;
        if (Graph && Graph.scene && Graph.scene()) {
            const scene = Graph.scene();
            if (scene.background) {
                const vizColors = window.VIZ_COLORS || {};
                const bgColor = getComputedStyle(document.documentElement)
                    .getPropertyValue('--color-viz-canvas-bg')?.trim() || vizColors.canvasBg || '#0a0a0f';
                scene.background = new THREE.Color(bgColor);
            }
        }

        // Update theme toggle buttons
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.theme === themeName);
        });

        const consoleColors = window.CONSOLE_COLORS || { success: '#4caf50' };
        console.log(`%c[Theme] Switched to: ${themeName}`, `color: ${consoleColors.success}; font-weight: bold`);

        // Show toast if available
        if (typeof window.showToast === 'function') {
            window.showToast(`Theme: ${themeName}`);
        }
    }

    /**
     * Get the current theme name.
     * @returns {string} Current theme name
     */
    function getTheme() {
        const config = window.THEME_CONFIG;
        return config ? config.current : 'dark';
    }

    /**
     * Get list of available themes.
     * @returns {string[]} Array of theme names
     */
    function getAvailableThemes() {
        const config = window.THEME_CONFIG;
        return config ? config.available : ['dark'];
    }

    /**
     * Cycle to the next theme in the list.
     */
    function cycleTheme() {
        const config = window.THEME_CONFIG;
        if (!config) return;

        const current = config.current;
        const themes = config.available;
        const currentIndex = themes.indexOf(current);
        const nextIndex = (currentIndex + 1) % themes.length;
        setTheme(themes[nextIndex]);
    }

    /**
     * Initialize theme from saved preference or default.
     */
    function initTheme() {
        const config = window.THEME_CONFIG;
        if (!config) {
            console.warn('[Theme] THEME_CONFIG not available');
            return;
        }

        // Check for saved preference
        let savedTheme = null;
        try {
            savedTheme = localStorage.getItem('collider-theme');
        } catch (e) {
            // Ignore storage errors
        }

        // Use saved preference if valid
        if (savedTheme && config.available.includes(savedTheme)) {
            setTheme(savedTheme);
            return;
        }

        // Fall back to default theme
        setTheme(config.default || 'dark');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        set: setTheme,
        get: getTheme,
        available: getAvailableThemes,
        cycle: cycleTheme,
        init: initTheme
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setTheme = THEME.set;
window.getTheme = THEME.get;
window.getAvailableThemes = THEME.available;
window.cycleTheme = THEME.cycle;
window.initTheme = THEME.init;

console.log('[Module] THEME loaded - 5 functions');


// ═══ MODULE: modules/control-bar.js ═══
/**
 * CONTROL BAR MODULE - Visual Mapping Command Center
 *
 * A persistent control bar (like ChatGPT/Claude input) that allows dynamic
 * mapping of any data characteristic to any visual/physics property.
 *
 * Features:
 * - Always visible at bottom of screen
 * - Works with selected nodes or node groups
 * - Dropdown to choose data source (any field)
 * - Dropdown to choose visual target (size, color, position, physics...)
 * - Group comparison with numbered badges
 * - Real-time preview as you adjust
 *
 * Depends on: DATA, COLOR, ANIM, SELECT
 */

const CONTROL_BAR = (function () {
    'use strict';

    // =========================================================================
    // AVAILABLE DATA SOURCES (what we can map FROM)
    // =========================================================================

    // =========================================================================
    // AVAILABLE DATA SOURCES (Delegated to UPB)
    // =========================================================================
    const DATA_SOURCES = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.SOURCES) || {
        // Fallback for safety if UPB fails to load
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' }
    };

    // =========================================================================
    // AVAILABLE TARGETS (Delegated to UPB)
    // =========================================================================
    const VISUAL_TARGETS = (window.UPB && window.UPB.ENDPOINTS && window.UPB.ENDPOINTS.TARGETS) || {
        // Fallback
        nodeSize: { label: 'Node Size', category: 'appearance', range: [1, 30] }
    };

    // =========================================================================
    // SCALE FUNCTIONS (Delegated to UPB)
    // =========================================================================
    const SCALES = (window.UPB && window.UPB.SCALES && window.UPB.SCALES.SCALES) || {
        linear: (v, min, max) => (v - min) / (max - min || 1)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _visible = false;
    let _container = null;
    let _activeMapping = null;
    let _groups = [];         // [{id, name, nodeIds, color}]
    let _groupCounter = 0;

    // Current mapping configuration
    let _config = {
        source: 'token_estimate',
        target: 'nodeSize',
        scale: 'sqrt',
        scope: 'selection',   // 'selection' | 'all' | 'group:X'
        invert: false
    };

    // =========================================================================
    // UI BUILDING
    // =========================================================================

    let _isDocked = false;

    function createUI() {
        if (_container) return _container;

        const dockContainer = document.getElementById('control-bar-container');
        _isDocked = !!dockContainer;

        _container = document.createElement('div');
        _container.id = 'control-bar';
        _container.className = _isDocked ? 'control-bar docked' : 'control-bar';

        // Scope Section
        const scopeHTML = `
            <div class="control-section scope-section">
                <label>SCOPE</label>
                <div class="row-group">
                    <select id="cb-scope" class="cb-select">
                        <option value="selection">Selected Nodes</option>
                        <option value="all">All Nodes</option>
                        <optgroup label="Groups" id="cb-groups-optgroup"></optgroup>
                    </select>
                    <button id="cb-add-group" class="cb-btn cb-btn-small" title="Create group from selection">+G</button>
                    <span id="cb-node-count" class="cb-badge">0</span>
                </div>
            </div>
        `;

        // Map FROM
        const sourceHTML = `
            <div class="control-section">
                <label>MAP DATA SOURCE</label>
                <select id="cb-source" class="cb-select full-width">
                    <optgroup label="Structural">
                        <option value="token_estimate">Token Count</option>
                        <option value="line_count">Line Count</option>
                        <option value="size_bytes">File Size</option>
                        <option value="code_lines">Code Lines</option>
                        <option value="complexity_density">Complexity</option>
                        <option value="cohesion">Cohesion</option>
                    </optgroup>
                    <optgroup label="Temporal">
                        <option value="age_days">Age (days)</option>
                    </optgroup>
                    <optgroup label="Graph">
                        <option value="in_degree">In-Degree</option>
                        <option value="out_degree">Out-Degree</option>
                    </optgroup>
                    <optgroup label="Categorical">
                        <option value="tier">Tier</option>
                        <option value="ring">Ring</option>
                        <option value="layer">Layer</option>
                        <option value="role">Role</option>
                        <option value="format_category">Format</option>
                        <option value="effect">Effect</option>
                    </optgroup>
                    <optgroup label="Boolean">
                        <option value="is_test">Is Test?</option>
                        <option value="is_config">Is Config?</option>
                        <option value="is_stale">Is Stale?</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Arrow (only for float mode, skip or style differently in dock)
        const arrowHTML = _isDocked ? '' : `
            <div class="control-section arrow-section">
                <span class="arrow">&#8594;</span>
            </div>
        `;

        // Map TO
        const targetHTML = `
            <div class="control-section">
                <label>TO VISUAL PROPERTY</label>
                <select id="cb-target" class="cb-select full-width">
                    <optgroup label="Appearance">
                        <option value="nodeSize">Node Size</option>
                        <option value="hue">Color Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="lightness">Lightness</option>
                        <option value="opacity">Opacity</option>
                    </optgroup>
                    <optgroup label="Position">
                        <option value="xPosition">X Position</option>
                        <option value="yPosition">Y Position</option>
                        <option value="zPosition">Z Depth</option>
                        <option value="radius">Radial Distance</option>
                    </optgroup>
                    <optgroup label="Physics">
                        <option value="charge">Charge (repel)</option>
                        <option value="mass">Mass</option>
                    </optgroup>
                    <optgroup label="Animation">
                        <option value="pulseSpeed">Pulse Speed</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Scale
        const scaleHTML = `
            <div class="control-section">
                <label>SCALING</label>
                <select id="cb-scale" class="cb-select full-width">
                    <option value="linear">Linear</option>
                    <option value="sqrt" selected>Sqrt</option>
                    <option value="log">Log</option>
                    <option value="inverse">Inverse</option>
                </select>
            </div>
        `;

        // Actions
        const actionsHTML = `
            <div class="control-section actions-section">
                <button id="cb-apply" class="cb-btn cb-btn-primary full-width">APPLY MAPPING</button>
                <button id="cb-reset" class="cb-btn full-width" style="margin-top:4px">Reset</button>
            </div>
        `;

        // Groups Display
        const groupsHTML = `
            <div class="control-section groups-section" id="cb-groups-display"></div>
        `;

        // Toggle (only for float mode)
        const toggleHTML = _isDocked ? '' : `
            <button id="cb-toggle" class="cb-toggle" title="Toggle Control Bar">
                <span class="chevron">&#9660;</span>
            </button>
        `;

        _container.innerHTML = `
            <div class="control-bar-inner">
                ${scopeHTML}
                ${sourceHTML}
                ${arrowHTML}
                ${targetHTML}
                ${scaleHTML}
                ${actionsHTML}
                ${groupsHTML}
                ${toggleHTML}
            </div>
        `;

        // Add styles
        addStyles();

        // Attach event listeners
        attachListeners();

        if (_isDocked) {
            dockContainer.appendChild(_container);
        } else {
            document.body.appendChild(_container);
        }

        _visible = true;

        return _container;
    }

    function addStyles() {
        if (document.getElementById('control-bar-styles')) return;

        const style = document.createElement('style');
        style.id = 'control-bar-styles';
        style.textContent = `
            /* BASE STYLES */
            .control-bar {
                font-family: 'SF Mono', 'Consolas', monospace;
            }

            /* FLOATING MODE */
            .control-bar:not(.docked) {
                position: fixed;
                bottom: 16px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 900px;
                width: calc(100% - 48px);
                z-index: 9999;
                background: linear-gradient(180deg, rgba(28, 30, 35, 0.95) 0%, rgba(22, 24, 28, 0.98) 100%);
                backdrop-filter: blur(12px);
                border: 1px solid rgba(100, 105, 115, 0.15);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.35);
                transition: transform 0.3s ease, opacity 0.3s ease;
            }

            .control-bar:not(.docked) .control-bar-inner {
                display: flex;
                align-items: center;
                gap: 16px;
                padding: 12px 20px;
                overflow-x: auto;
            }

            /* DOCKED MODE */
            .control-bar.docked {
                position: static;
                width: 100%;
                background: transparent;
                border: none;
                box-shadow: none;
                padding: 0;
            }

            .control-bar.docked .control-bar-inner {
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 0;
            }

            /* SHARED COMPONENTS */
            .control-section {
                display: flex;
                flex-direction: column;
                gap: 4px;
                width: 100%; /* Full width when docked */
            }

            .control-section label {
                font-size: 9px;
                font-weight: 600;
                color: rgba(140, 145, 155, 0.6);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .row-group {
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .cb-select {
                background: rgba(35, 38, 45, 0.85);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #c8ccd5;
                padding: 6px 10px;
                font-size: 11px;
                font-family: inherit;
                cursor: pointer;
                transition: all 0.2s;
                flex: 1;
            }

            .cb-select:hover {
                background: rgba(45, 48, 55, 0.9);
                border-color: rgba(120, 125, 135, 0.35);
            }
            
            .cb-select:focus {
                outline: none;
                border-color: var(--accent, #4a9eff);
            }

            .full-width {
                width: 100%;
            }

            .cb-btn {
                background: rgba(50, 55, 65, 0.6);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #b0b5c0;
                padding: 6px 12px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
            }
            .actions-section {
                width: 100%;
            }
            .cb-btn:hover {
                background: rgba(65, 70, 80, 0.75);
                color: #fff;
            }

            .cb-btn-primary {
                background: var(--accent-dim, rgba(74, 158, 255, 0.15));
                color: var(--accent, #4a9eff);
                border-color: var(--accent, #4a9eff);
            }

            .cb-btn-primary:hover {
                background: var(--accent, #4a9eff);
                color: #000;
            }

            .cb-btn-small {
                padding: 4px 8px;
                min-width: 30px;
            }

            .cb-badge {
                font-size: 10px;
                color: #666;
                min-width: 15px;
                text-align: center;
            }

            /* GROUP CHIPS */
            .groups-section {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 4px;
            }

            .group-chip {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
                padding: 2px 8px;
                font-size: 10px;
                cursor: default;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .group-color {
                width: 6px;
                height: 6px;
                border-radius: 50%;
            }

            .group-remove {
                margin-left: 4px;
                cursor: pointer;
                opacity: 0.5;
            }
            .group-remove:hover { opacity: 1; }
        `;

        document.head.appendChild(style);
    }

    function attachListeners() {
        // Toggle collapse
        const toggleBtn = document.getElementById('cb-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', toggle);
        }

        // Scope change
        const scopeSelect = document.getElementById('cb-scope');
        if (scopeSelect) {
            scopeSelect.addEventListener('change', (e) => {
                _config.scope = e.target.value;
                updateNodeCount();
            });
        }

        // Source change
        const sourceSelect = document.getElementById('cb-source');
        if (sourceSelect) {
            sourceSelect.addEventListener('change', (e) => {
                _config.source = e.target.value;
            });
        }

        // Target change
        const targetSelect = document.getElementById('cb-target');
        if (targetSelect) {
            targetSelect.addEventListener('change', (e) => {
                _config.target = e.target.value;
            });
        }

        // Scale change
        const scaleSelect = document.getElementById('cb-scale');
        if (scaleSelect) {
            scaleSelect.addEventListener('change', (e) => {
                _config.scale = e.target.value;
            });
        }

        // Apply button
        const applyBtn = document.getElementById('cb-apply');
        if (applyBtn) {
            applyBtn.addEventListener('click', applyMapping);
        }

        // Reset button
        const resetBtn = document.getElementById('cb-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', resetMapping);
        }

        // Add group button
        const addGroupBtn = document.getElementById('cb-add-group');
        if (addGroupBtn) {
            addGroupBtn.addEventListener('click', createGroupFromSelection);
        }

        // Update node count periodically
        setInterval(updateNodeCount, 1000);
    }

    // =========================================================================
    // GROUP MANAGEMENT
    // =========================================================================

    const GROUP_COLORS = [
        '#4a9eff', '#ff6b6b', '#51cf66', '#ffd43b',
        '#cc5de8', '#20c997', '#ff922b', '#748ffc'
    ];

    function createGroupFromSelection() {
        const selectedIds = getSelectedNodeIds();
        if (selectedIds.length === 0) {
            showToast('Select nodes first to create a group');
            return;
        }

        _groupCounter++;
        const groupId = `group-${_groupCounter}`;
        const color = GROUP_COLORS[(_groupCounter - 1) % GROUP_COLORS.length];

        const group = {
            id: groupId,
            name: `Group ${_groupCounter}`,
            nodeIds: [...selectedIds],
            color: color
        };

        _groups.push(group);
        updateGroupsUI();
        showToast(`Created ${group.name} with ${selectedIds.length} nodes`);
    }

    function removeGroup(groupId) {
        _groups = _groups.filter(g => g.id !== groupId);
        updateGroupsUI();
    }

    function updateGroupsUI() {
        // Update dropdown
        const optgroup = document.getElementById('cb-groups-optgroup');
        if (optgroup) {
            optgroup.innerHTML = _groups.map(g =>
                `<option value="group:${g.id}">${g.name} (${g.nodeIds.length})</option>`
            ).join('');
        }

        // Update chips display
        const display = document.getElementById('cb-groups-display');
        if (display) {
            display.innerHTML = _groups.map(g => `
                <div class="group-chip" data-group="${g.id}">
                    <span class="group-color" style="background: ${g.color}"></span>
                    <span class="group-name">${g.name}</span>
                    <span class="group-count">${g.nodeIds.length}</span>
                    <span class="group-remove" onclick="CONTROL_BAR.removeGroup('${g.id}')">&times;</span>
                </div>
            `).join('');
        }
    }

    // =========================================================================
    // MAPPING APPLICATION
    // =========================================================================

    function getTargetNodes() {
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        const allNodes = dm?.getNodes ? dm.getNodes() : (typeof graphNodes !== 'undefined' ? graphNodes : []);

        if (_config.scope === 'all') {
            return allNodes;
        }

        if (_config.scope === 'selection') {
            const selectedIds = getSelectedNodeIds();
            return allNodes.filter(n => selectedIds.includes(n.id));
        }

        if (_config.scope.startsWith('group:')) {
            const groupId = _config.scope.replace('group:', '');
            const group = _groups.find(g => g.id === groupId);
            if (group) {
                return allNodes.filter(n => group.nodeIds.includes(n.id));
            }
        }

        return [];
    }

    function applyMapping() {
        if (!window.UPB) {
            console.error('UPB not loaded');
            return;
        }

        const nodes = getTargetNodes();
        if (nodes.length === 0) {
            showToast('No nodes to map. Select nodes or change scope.');
            return;
        }

        const sourceKey = _config.source;
        const targetKey = _config.target;

        // 1. Create/Update Binding in UPB Graph
        window.UPB.bind(sourceKey, targetKey, {
            id: `cb-binding-${Date.now()}`,
            scale: _config.scale,
            range: VISUAL_TARGETS[targetKey]?.range
        });

        // 2. Refresh Data Ranges (if needed, usually DM handles this)
        // For now, we rely on the UPB Binding to calculate ranges per node or usage
        // But UPB.evaluate needs data ranges (min/max) for normalization.
        // We calculate them here ad-hoc for the current selection and push to UPB.
        const values = nodes.map(n => getNodeValue(n, sourceKey)).filter(v => typeof v === 'number');
        if (values.length > 0) {
            const min = Math.min(...values);
            const max = Math.max(...values);

            // Access the underlying graph to set range
            // TODO: Move this to a central DataManager
            if (window.UPB.BINDINGS.defaultGraph) {
                window.UPB.BINDINGS.defaultGraph._dataRanges[sourceKey] = { min, max };
            }
        }

        // 3. Apply to Nodes
        const updates = window.UPB.apply(nodes);

        // 4. Render Updates
        updates.forEach(update => {
            const node = nodes.find(n => n.id === update.id);
            if (node) {
                Object.keys(update.visuals).forEach(key => {
                    applyToNode(node, key, update.visuals[key]);
                });
            }
        });

        // Refresh graph
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }

        showToast(`Bound ${sourceKey} -> ${targetKey} via UPB`);
        console.log(`[CONTROL_BAR] UPB Binding Active: ${sourceKey} -> ${targetKey}`);
    }

    function getNodeValue(node, key) {
        // Direct property
        if (node[key] !== undefined) return node[key];

        // Nested in dimensions
        if (node.dimensions && node.dimensions[key] !== undefined) {
            return node.dimensions[key];
        }

        // Check common dimension mappings
        const dimMap = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };

        if (dimMap[key] && node.dimensions) {
            return node.dimensions[dimMap[key]];
        }

        return null;
    }

    function applyToNode(node, targetKey, value) {
        switch (targetKey) {
            case 'nodeSize':
                node.val = value;
                break;

            case 'hue':
                const currentColor = node.color || 'hsl(200, 70%, 50%)';
                node.color = setHSLComponent(currentColor, 'h', value);
                break;

            case 'saturation':
                node.color = setHSLComponent(node.color || 'hsl(200, 70%, 50%)', 's', value);
                break;

            case 'lightness':
                node.color = setHSLComponent(node.color || 'hsl(200, 70%, 50%)', 'l', value);
                break;

            case 'opacity':
                node.opacity = value;
                // Update color alpha if using rgba
                if (node.color && !node.color.startsWith('hsl')) {
                    node.color = setAlpha(node.color, value);
                }
                break;

            case 'xPosition':
                node.fx = value;
                break;

            case 'yPosition':
                node.fy = value;
                break;

            case 'zPosition':
                node.fz = value;
                break;

            case 'radius':
                // Position on a circle at given radius
                const angle = (node.fileIdx || Math.random() * 100) * 0.618 * Math.PI * 2;
                node.fx = Math.cos(angle) * value;
                node.fy = Math.sin(angle) * value;
                break;

            case 'charge':
                node.__charge = value;
                break;

            case 'mass':
                node.__mass = value;
                break;

            case 'pulseSpeed':
                node.__pulseSpeed = value;
                break;

            default:
                node[targetKey] = value;
        }
    }

    function setHSLComponent(colorStr, component, value) {
        // Parse existing HSL or convert
        let h = 200, s = 70, l = 50;

        const hslMatch = colorStr.match(/hsl\((\d+),\s*(\d+)%?,\s*(\d+)%?\)/);
        if (hslMatch) {
            h = parseInt(hslMatch[1]);
            s = parseInt(hslMatch[2]);
            l = parseInt(hslMatch[3]);
        }

        switch (component) {
            case 'h': h = value; break;
            case 's': s = value; break;
            case 'l': l = value; break;
        }

        return `hsl(${Math.round(h)}, ${Math.round(s)}%, ${Math.round(l)}%)`;
    }

    function setAlpha(colorStr, alpha) {
        // Simple alpha injection
        if (colorStr.startsWith('rgba')) {
            return colorStr.replace(/[\d.]+\)$/, `${alpha})`);
        }
        if (colorStr.startsWith('rgb')) {
            return colorStr.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        }
        return colorStr;
    }

    function resetMapping() {
        // Clear fixed positions
        const nodes = getTargetNodes();
        nodes.forEach(n => {
            delete n.fx;
            delete n.fy;
            delete n.fz;
            delete n.__charge;
            delete n.__mass;
            delete n.__pulseSpeed;
        });

        // Reheat simulation
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3ReheatSimulation();
        }

        showToast('Reset node positions and custom properties');
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function getSelectedNodeIds() {
        if (typeof SELECT !== 'undefined' && SELECT.getSelectedNodes) {
            return SELECT.getSelectedNodes().map(n => n.id);
        }
        if (typeof SELECTED_NODE_IDS !== 'undefined') {
            return Array.from(SELECTED_NODE_IDS);
        }
        return [];
    }

    function updateNodeCount() {
        const badge = document.getElementById('cb-node-count');
        if (!badge) return;

        const nodes = getTargetNodes();
        badge.textContent = nodes.length;
    }

    function showToast(msg) {
        if (typeof window.showToast === 'function') {
            window.showToast(msg);
        } else {
            console.log(`[CONTROL_BAR] ${msg}`);
        }
    }

    function toggle() {
        if (_container) {
            _container.classList.toggle('collapsed');
            _visible = !_container.classList.contains('collapsed');
        }
    }

    function show() {
        if (_container) {
            _container.classList.remove('collapsed');
            _visible = true;
        }
    }

    function hide() {
        if (_container) {
            _container.classList.add('collapsed');
            _visible = false;
        }
    }

    // =========================================================================
    // INIT
    // =========================================================================

    function init() {
        createUI();
        updateNodeCount();
        console.log('[CONTROL_BAR] Initialized');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        toggle,
        show,
        hide,
        applyMapping,
        resetMapping,
        createGroupFromSelection,
        removeGroup,
        get visible() { return _visible; },
        get config() { return _config; },
        get groups() { return _groups; },
        DATA_SOURCES,
        VISUAL_TARGETS,
        SCALES
    };

})();

// Auto-init when DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => CONTROL_BAR.init());
} else {
    // Small delay to ensure other modules are loaded
    setTimeout(() => CONTROL_BAR.init(), 100);
}


// ═══ MODULE: modules/main.js ═══
/**
 * MAIN.JS - MODULE INTEGRATION ENTRY POINT
 *
 * This file wires up all modules and provides backward compatibility
 * for HTML onclick handlers and global function calls.
 *
 * Module Loading Order (already handled by visualize_graph_webgl.py):
 * 1. performance.js       - Performance subsystem
 * 2. core.js              - Constants & utilities
 * 3. node-accessors.js    - Node property functions
 * 4. color-engine.js      - OKLCH color system
 * 5. refresh-throttle.js  - Throttled graph updates
 * 6. legend-manager.js    - Legend system
 * 7. data-manager.js      - Data access layer
 * 8. animation.js         - Layout & animation controller
 * 9. selection.js         - Selection system
 * 10. panels.js           - Panel management
 * 11. sidebar.js          - Sidebar controls
 * 12. edge-system.js      - Edge coloring & modes
 * 13. file-viz.js         - File visualization modes
 * 14. control-bar.js      - Visual mapping command bar
 * 15. main.js             - This file (wiring)
 * 16. app.js              - Legacy monolith (shrinking)
 */

;(function() {
    'use strict';

    // =========================================================================
    // VERIFY MODULE LOADING
    // =========================================================================

    const REQUIRED_MODULES = [
        { name: 'CORE', module: typeof CORE !== 'undefined' ? CORE : null },
        { name: 'NODE', module: typeof NODE !== 'undefined' ? NODE : null },
        { name: 'COLOR', module: typeof COLOR !== 'undefined' ? COLOR : null },
        { name: 'REFRESH', module: typeof REFRESH !== 'undefined' ? REFRESH : null },
        { name: 'LEGEND', module: typeof LEGEND !== 'undefined' ? LEGEND : null },
        { name: 'DATA', module: typeof DATA !== 'undefined' ? DATA : null },
        { name: 'LAYOUT', module: typeof LAYOUT !== 'undefined' ? LAYOUT : null },  // UI Layout Engine
        { name: 'ANIM', module: typeof ANIM !== 'undefined' ? ANIM : null },
        { name: 'SELECT', module: typeof SELECT !== 'undefined' ? SELECT : null },
        { name: 'PANELS', module: typeof PANELS !== 'undefined' ? PANELS : null },
        { name: 'SIDEBAR', module: typeof SIDEBAR !== 'undefined' ? SIDEBAR : null },
        { name: 'EDGE', module: typeof EDGE !== 'undefined' ? EDGE : null },
        { name: 'FILE_VIZ', module: typeof FILE_VIZ !== 'undefined' ? FILE_VIZ : null },
        { name: 'CONTROL_BAR', module: typeof CONTROL_BAR !== 'undefined' ? CONTROL_BAR : null },
        // STARS module removed - nodes ARE the stars
        { name: 'HUD', module: typeof HUD !== 'undefined' ? HUD : null },
        { name: 'DIMENSION', module: typeof DIMENSION !== 'undefined' ? DIMENSION : null }
    ];

    const loaded = REQUIRED_MODULES.filter(m => m.module !== null);
    const missing = REQUIRED_MODULES.filter(m => m.module === null);

    console.log(`[MAIN] Modules loaded: ${loaded.length}/${REQUIRED_MODULES.length}`);
    if (missing.length > 0) {
        console.warn('[MAIN] Missing modules:', missing.map(m => m.name).join(', '));
    }

    // =========================================================================
    // WINDOW-LEVEL EXPORTS FOR HTML ONCLICK HANDLERS
    // =========================================================================

    // Selection functions
    if (typeof SELECT !== 'undefined') {
        window.clearSelection = SELECT.clear;
        window.setSelection = SELECT.set;
        window.toggleSelection = SELECT.toggle;
        window.getSelectedNodes = SELECT.getSelectedNodes;
    }

    // Animation functions
    if (typeof ANIM !== 'undefined') {
        window.applyLayoutPreset = ANIM.applyLayout;
        window.stopAnimation = ANIM.stop;
    }

    // Edge functions
    if (typeof EDGE !== 'undefined') {
        window.setEdgeMode = EDGE.setMode;
        window.cycleEdgeMode = EDGE.cycleMode;
        window.applyEdgeMode = EDGE.apply;
    }

    // File visualization functions
    if (typeof FILE_VIZ !== 'undefined') {
        window.setFileVizMode = FILE_VIZ.setMode;
        window.toggleFileMode = FILE_VIZ.toggle;
    }

    // Panel functions
    if (typeof PANELS !== 'undefined') {
        window.openPanel = PANELS.open;
        window.closePanel = PANELS.close;
        window.togglePanel = PANELS.toggle;
    }

    // Sidebar functions
    if (typeof SIDEBAR !== 'undefined') {
        window.setColorMode = SIDEBAR.setColorMode;
        window.setLayout = SIDEBAR.setLayout;
    }

    // Refresh function
    if (typeof REFRESH !== 'undefined') {
        window.throttledRefresh = REFRESH.throttled;
    }

    // Control bar functions
    if (typeof CONTROL_BAR !== 'undefined') {
        window.toggleControlBar = CONTROL_BAR.toggle;
        window.showControlBar = CONTROL_BAR.show;
        window.hideControlBar = CONTROL_BAR.hide;
        window.applyVisualMapping = CONTROL_BAR.applyMapping;
    }

    // =========================================================================
    // CROSS-MODULE INTEGRATION
    // =========================================================================

    /**
     * Initialize all modules with data
     * NOTE: Currently unused - app.js calls module inits directly in setupControls()
     * Kept for potential future centralization
     * @deprecated Use direct module init calls instead
     */
    window.initializeModules = function(data) {
        console.log('[MAIN] Initializing modules with data...');

        // Initialize DATA module
        if (typeof DATA !== 'undefined' && DATA.init) {
            DATA.init(data);
            console.log('[MAIN] DATA module initialized');
        }

        // Initialize LEGEND module
        if (typeof LEGEND !== 'undefined' && LEGEND.init) {
            LEGEND.init(data.nodes, data.links || data.edges);
            console.log('[MAIN] LEGEND module initialized');
        }

        // Initialize SIDEBAR
        if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
            SIDEBAR.init();
            console.log('[MAIN] SIDEBAR module initialized');
        }

        // Initialize PANELS command bar
        if (typeof PANELS !== 'undefined' && PANELS.initCommandBar) {
            PANELS.initCommandBar();
            console.log('[MAIN] PANELS module initialized');
        }

        // Initialize LAYOUT (replaces HudLayoutManager from app.js)
        if (typeof LAYOUT !== 'undefined' && LAYOUT.init) {
            LAYOUT.init();
            console.log('[MAIN] LAYOUT module initialized (Ctrl+Shift+L for debug overlay)');
        }

        // STARS module removed - nodes ARE the stars

        // Initialize HUD (fade behavior)
        if (typeof HUD !== 'undefined' && HUD.setupFade) {
            HUD.setupFade();
            console.log('[MAIN] HUD module initialized');
        }

        // Initialize DIMENSION toggle
        if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) {
            DIMENSION.setup();
            console.log('[MAIN] DIMENSION module initialized');
        }

        console.log('[MAIN] Module initialization complete');
    };

    /**
     * Global refresh function that uses the throttled refresher
     */
    window.moduleRefresh = function() {
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            REFRESH.throttled();
        }
    };

    // =========================================================================
    // MODULE HEALTH CHECK
    // =========================================================================

    window.checkModuleHealth = function() {
        console.log('=== MODULE HEALTH CHECK ===');
        REQUIRED_MODULES.forEach(({ name, module }) => {
            const status = module ? 'OK' : 'MISSING';
            const color = module ? 'color: green' : 'color: red';
            console.log(`%c[${status}] ${name}`, color);
        });

        if (typeof REFRESH !== 'undefined') {
            console.log('REFRESH stats:', REFRESH.stats);
        }

        console.log('===========================');
    };

    // =========================================================================
    // INITIALIZATION MESSAGE
    // =========================================================================

    console.log('[MAIN] Entry point loaded. Modules ready for initialization.');

})();


// ═══ MODULE: modules/circuit-breaker.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * CIRCUIT BREAKER MODULE - UI Control Validator
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Runtime self-test system that validates all visualization UI controls.
 * Acts as a quality guardian - detects binding failures, state issues,
 * and provides actionable fix recommendations.
 *
 * @module CIRCUIT
 * @version 2.0.0
 *
 * ## API
 *
 * | Method | Returns | Description |
 * |--------|---------|-------------|
 * | `runAll()` | `{passed, failed, total, results}` | Run all tests |
 * | `test(name)` | `{passed, error, trace}` | Test single control |
 * | `report()` | `Map<name, result>` | Get all results |
 * | `listTests()` | `string[]` | List test names |
 * | `diagnose()` | `{category, failures}[]` | Get categorized fix recommendations |
 * | `inventory()` | `string` | Markdown table of all controls |
 * | `inventoryJSON()` | `object[]` | JSON array of control definitions |
 *
 * ## CLI Integration
 *
 * ```bash
 * python tools/validate_ui.py <html_path> --verbose
 * ```
 *
 * ## Browser Console
 *
 * ```javascript
 * CIRCUIT.runAll()        // Run all tests
 * CIRCUIT.inventory()     // Print control table
 * CIRCUIT.diagnose()      // Get fix recommendations
 * ```
 *
 * @see tools/validate_ui.py - Headless test runner
 * @see CLAUDE.md - UI Controls section
 */

const CIRCUIT = (function() {
    'use strict';

    // Test results storage
    const _results = new Map();
    let _running = false;

    // =========================================================================
    // DIAGNOSTIC HELPERS
    // =========================================================================

    function getStateValue(path) {
        try {
            const parts = path.split('.');
            let obj = window;
            for (const part of parts) {
                if (obj === undefined || obj === null) return { exists: false, value: undefined };
                obj = obj[part];
            }
            return { exists: true, value: obj };
        } catch (e) {
            return { exists: false, value: undefined, error: e.message };
        }
    }

    function traceBinding(elementId, statePath, graphMethod) {
        const trace = {
            element: { id: elementId, found: false, hasListeners: false },
            state: { path: statePath, exists: false, value: undefined },
            graph: { method: graphMethod, callable: false },
            chain: []
        };

        // Check element
        const el = document.getElementById(elementId);
        if (el) {
            trace.element.found = true;
            trace.element.tagName = el.tagName;
            trace.element.type = el.type || el.tagName;
            trace.element.value = el.value;
            trace.chain.push(`✓ DOM element #${elementId} exists`);
        } else {
            trace.chain.push(`✗ DOM element #${elementId} NOT FOUND`);
            return trace;
        }

        // Check state
        if (statePath) {
            const stateResult = getStateValue(statePath);
            trace.state.exists = stateResult.exists;
            trace.state.value = stateResult.value;
            if (stateResult.exists) {
                trace.chain.push(`✓ State ${statePath} = ${JSON.stringify(stateResult.value)}`);
            } else {
                trace.chain.push(`✗ State ${statePath} is undefined`);
            }
        }

        // Check Graph method
        if (graphMethod && typeof Graph !== 'undefined' && Graph) {
            const method = Graph[graphMethod];
            trace.graph.callable = typeof method === 'function';
            if (trace.graph.callable) {
                trace.chain.push(`✓ Graph.${graphMethod}() is callable`);
            } else {
                trace.chain.push(`✗ Graph.${graphMethod}() NOT a function`);
            }
        }

        return trace;
    }

    // =========================================================================
    // TEST DEFINITIONS - Enhanced with diagnostics
    // =========================================================================

    const TESTS = [
        // --- EDGE CONTROLS ---
        {
            name: 'edge-opacity',
            type: 'slider',
            elementId: 'cfg-edge-opacity',
            statePath: 'APPEARANCE_STATE.edgeOpacity',
            graphMethod: 'linkOpacity',
            expected: 0.8,
            trigger: (el) => {
                el.value = '0.8';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeOpacity');
                return {
                    passed: state.exists && state.value === 0.8,
                    expected: 0.8,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0.6';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Ensure bindSlider() in app.js updates APPEARANCE_STATE.edgeOpacity and calls applyEdgeMode()'
        },
        {
            name: 'edge-width',
            type: 'slider',
            elementId: 'cfg-edge-width',
            statePath: 'APPEARANCE_STATE.edgeWidth',
            graphMethod: 'linkWidth',
            expected: 'changed',
            trigger: (el) => {
                // Store initial value, then change it
                window._edgeWidthBefore = getStateValue('APPEARANCE_STATE.edgeWidth').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeWidth');
                const changed = state.exists && state.value !== window._edgeWidthBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeWidthBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeWidthBefore;
            },
            fix: 'Check if cfg-edge-width has oninput handler that updates APPEARANCE_STATE.edgeWidth'
        },
        {
            name: 'edge-curvature',
            type: 'slider',
            elementId: 'cfg-edge-curve',
            statePath: 'APPEARANCE_STATE.edgeCurvature',
            graphMethod: 'linkCurvature',
            expected: 'changed',
            trigger: (el) => {
                window._edgeCurveBefore = getStateValue('APPEARANCE_STATE.edgeCurvature').value;
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.edgeCurvature');
                const changed = state.exists && state.value !== window._edgeCurveBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._edgeCurveBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '0';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._edgeCurveBefore;
            },
            fix: 'Check if cfg-edge-curve has oninput handler that updates APPEARANCE_STATE.edgeCurvature'
        },

        // --- NODE CONTROLS ---
        {
            name: 'node-size',
            type: 'slider',
            elementId: 'cfg-node-size',
            statePath: 'APPEARANCE_STATE.nodeScale',
            graphMethod: 'nodeRelSize',
            expected: 'changed',
            trigger: (el) => {
                // Slider has max=4, so use valid value
                window._nodeSizeBefore = getStateValue('APPEARANCE_STATE.nodeScale').value;
                el.value = '3';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeScale');
                const changed = state.exists && state.value !== window._nodeSizeBefore;
                return {
                    passed: changed,
                    expected: 'different from ' + window._nodeSizeBefore,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                delete window._nodeSizeBefore;
            },
            fix: 'Check if cfg-node-size has oninput handler that updates APPEARANCE_STATE.nodeScale'
        },
        {
            name: 'node-opacity',
            type: 'slider',
            elementId: 'cfg-node-opacity',
            statePath: 'APPEARANCE_STATE.nodeOpacity',
            graphMethod: 'nodeOpacity',
            expected: 0.5,
            trigger: (el) => {
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                const state = getStateValue('APPEARANCE_STATE.nodeOpacity');
                return {
                    passed: state.exists && state.value === 0.5,
                    expected: 0.5,
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            fix: 'Check if cfg-node-opacity has oninput handler that updates APPEARANCE_STATE.nodeOpacity'
        },

        // --- TOGGLES ---
        {
            name: 'toggle-arrows',
            type: 'toggle',
            elementId: 'cfg-toggle-arrows',
            statePath: null,
            graphMethod: 'linkDirectionalArrowLength',
            expected: 'toggled',
            trigger: (el) => {
                window._arrowsActiveBefore = el.classList.contains('active');
                el.click();
            },
            validate: () => {
                const el = document.getElementById('cfg-toggle-arrows');
                if (!el) return { passed: false, error: 'Element not found' };
                const isActiveNow = el.classList.contains('active');
                return {
                    passed: isActiveNow !== window._arrowsActiveBefore,
                    expected: !window._arrowsActiveBefore,
                    actual: isActiveNow,
                    stateExists: true
                };
            },
            cleanup: (el) => {
                el.click();
                delete window._arrowsActiveBefore;
            },
            fix: 'Ensure toggle click handler toggles .active class and calls Graph.linkDirectionalArrowLength()'
        },

        // --- PHYSICS CONTROLS ---
        {
            name: 'physics-charge',
            type: 'slider',
            elementId: 'physics-charge',
            statePath: null,  // Bypasses PHYSICS_STATE, goes direct to Graph
            graphMethod: 'd3Force',
            expected: -200,
            trigger: (el) => {
                window._originalChargeValue = el.value;
                el.value = '-200';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                // Use window.Graph explicitly (Graph is exposed at app.js:1111)
                const G = window.Graph;
                if (!G) {
                    return { passed: false, error: 'Graph not defined', stateExists: false };
                }
                if (!G.d3Force) {
                    return { passed: false, error: 'Graph.d3Force not available', stateExists: false };
                }
                try {
                    const chargeForce = G.d3Force('charge');
                    if (!chargeForce || !chargeForce.strength) {
                        return { passed: false, error: 'charge force not configured', stateExists: false };
                    }
                    // d3-force strength() returns accessor function, not value
                    // Call it with dummy node to get actual strength
                    const strengthFn = chargeForce.strength();
                    const strength = typeof strengthFn === 'function' ? strengthFn({}, 0, []) : strengthFn;
                    return {
                        passed: strength === -200,
                        expected: -200,
                        actual: strength,
                        stateExists: true
                    };
                } catch (e) {
                    return { passed: false, error: e.message, stateExists: false };
                }
            },
            cleanup: (el) => {
                if (window._originalChargeValue) {
                    el.value = window._originalChargeValue;
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    delete window._originalChargeValue;
                }
            },
            fix: 'Ensure physics-charge slider calls Graph.d3Force("charge").strength(value) - check sidebar.js binding'
        },

        // NOTE: btn-edge-mode test removed - button never existed in template.html
        // The EDGE module handles missing button gracefully (line 443-446 of edge-system.js)

        // --- DIMENSION TOGGLE ---
        {
            name: 'dimension-toggle',
            type: 'button',
            elementId: 'btn-2d',
            statePath: 'DIMENSION_TRANSITION',
            graphMethod: null,
            expected: 'transition started',
            trigger: (el) => {
                // Animation takes 3s, so we check DIMENSION_TRANSITION flag (set immediately)
                window._transitionBefore = window.DIMENSION_TRANSITION;
                el.click();
            },
            validate: () => {
                // DIMENSION_TRANSITION is set true immediately on click, then false after 3s animation
                // We check that clicking triggered the transition (flag went true or animation completed)
                const transitionStarted = window.DIMENSION_TRANSITION === true ||
                                         window.DIMENSION_TRANSITION !== window._transitionBefore;
                return {
                    passed: transitionStarted || window.DIMENSION_TRANSITION === true,
                    expected: 'DIMENSION_TRANSITION = true (animation in progress)',
                    actual: window.DIMENSION_TRANSITION,
                    stateExists: typeof window.DIMENSION_TRANSITION !== 'undefined'
                };
            },
            cleanup: () => {
                // Don't click again - let animation complete naturally
                delete window._transitionBefore;
            },
            fix: 'Check if btn-2d click handler sets DIMENSION_TRANSITION and calls DIMENSION.toggle() - see dimension.js'
        },

        // --- VIEW MODE ---
        {
            name: 'view-mode-files',
            type: 'button',
            elementId: null,
            selector: '[data-mode="files"]',
            statePath: 'GRAPH_MODE',
            graphMethod: null,
            expected: 'files',
            trigger: (el) => {
                el.click();
            },
            validate: () => {
                const state = getStateValue('GRAPH_MODE');
                return {
                    passed: state.exists && state.value === 'files',
                    expected: 'files',
                    actual: state.value,
                    stateExists: state.exists
                };
            },
            cleanup: () => {
                const atomsBtn = document.querySelector('[data-mode="atoms"]');
                if (atomsBtn) atomsBtn.click();
            },
            fix: 'Ensure [data-mode="files"] button sets GRAPH_MODE = "files" and rebuilds graph'
        }
    ];

    // =========================================================================
    // TEST RUNNER - Enhanced with diagnostics
    // =========================================================================

    async function runTest(testDef) {
        const result = {
            name: testDef.name,
            type: testDef.type,
            passed: false,
            error: null,
            elementFound: false,
            // Enhanced diagnostics
            expected: testDef.expected,
            actual: null,
            stateExists: false,
            trace: null,
            fix: testDef.fix || null
        };

        try {
            // Find element
            const el = testDef.elementId
                ? document.getElementById(testDef.elementId)
                : document.querySelector(testDef.selector);

            if (!el) {
                result.error = 'Element not found';
                result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);
                return result;
            }
            result.elementFound = true;

            // Trace binding chain before test
            result.trace = traceBinding(testDef.elementId || testDef.selector, testDef.statePath, testDef.graphMethod);

            // Run trigger
            testDef.trigger(el);

            // Small delay for async effects
            await new Promise(r => setTimeout(r, 50));

            // Validate with enhanced result
            const validateResult = testDef.validate();
            if (typeof validateResult === 'object') {
                result.passed = validateResult.passed;
                result.expected = validateResult.expected !== undefined ? validateResult.expected : testDef.expected;
                result.actual = validateResult.actual;
                result.stateExists = validateResult.stateExists;
                if (validateResult.error) result.error = validateResult.error;
            } else {
                result.passed = validateResult;
            }

            // Cleanup
            if (testDef.cleanup) {
                await new Promise(r => setTimeout(r, 50));
                testDef.cleanup(el);
            }

        } catch (err) {
            result.error = err.message;
            result.passed = false;
        }

        return result;
    }

    async function runAll() {
        if (_running) {
            console.warn('[CIRCUIT] Already running');
            return;
        }
        _running = true;
        _results.clear();

        console.log('%c[CIRCUIT] Starting control validation...', 'color: #4dd4ff; font-weight: bold');

        const startTime = performance.now();
        let passed = 0;
        let failed = 0;

        for (const test of TESTS) {
            const result = await runTest(test);
            _results.set(test.name, result);

            if (result.passed) {
                passed++;
                console.log(`  %c✓ ${test.name}`, 'color: #4ade80');
            } else {
                failed++;
                const reason = result.error || (!result.elementFound ? 'Element not found' : 'Validation failed');
                console.log(`  %c✗ ${test.name}: ${reason}`, 'color: #f87171');
                if (result.expected !== undefined && result.actual !== undefined) {
                    console.log(`    Expected: ${JSON.stringify(result.expected)}, Got: ${JSON.stringify(result.actual)}`);
                }
            }

            // Small delay between tests
            await new Promise(r => setTimeout(r, 100));
        }

        const elapsed = (performance.now() - startTime).toFixed(0);
        const total = passed + failed;
        const pct = ((passed / total) * 100).toFixed(1);

        console.log('%c─────────────────────────────────────', 'color: #666');
        if (failed === 0) {
            console.log(`%c[CIRCUIT] ALL PASS: ${passed}/${total} controls (${elapsed}ms)`,
                'color: #4ade80; font-weight: bold');
        } else {
            console.log(`%c[CIRCUIT] ${passed}/${total} passed (${pct}%), ${failed} FAILED (${elapsed}ms)`,
                'color: #f87171; font-weight: bold');
        }

        _running = false;
        return { passed, failed, total, results: Object.fromEntries(_results) };
    }

    async function test(name) {
        const testDef = TESTS.find(t => t.name === name);
        if (!testDef) {
            console.error(`[CIRCUIT] Unknown test: ${name}`);
            return null;
        }
        const result = await runTest(testDef);
        _results.set(name, result);
        return result;
    }

    function report() {
        return Object.fromEntries(_results);
    }

    function listTests() {
        return TESTS.map(t => ({ name: t.name, type: t.type }));
    }

    /**
     * Get detailed fix recommendations for all failures
     */
    function diagnose() {
        const failures = [];
        for (const [name, result] of _results) {
            if (!result.passed) {
                failures.push({
                    control: name,
                    type: result.type,
                    error: result.error,
                    expected: result.expected,
                    actual: result.actual,
                    elementFound: result.elementFound,
                    stateExists: result.stateExists,
                    trace: result.trace ? result.trace.chain : [],
                    fix: result.fix
                });
            }
        }
        return failures;
    }

    // =========================================================================
    // INVENTORY - Generate control tables for documentation
    // =========================================================================

    /**
     * Generate markdown table of all tested controls
     * @returns {string} Markdown table
     */
    function inventory() {
        const lines = [
            '| Control | Type | Element ID | State Path | Purpose |',
            '|---------|------|------------|------------|---------|'
        ];
        TESTS.forEach(t => {
            const purpose = t.fix ? t.fix.split(' - ')[0].replace(/^(Check|Ensure) /, '') : t.name;
            lines.push(`| ${t.name} | ${t.type} | \`${t.elementId || '-'}\` | \`${t.statePath || '-'}\` | ${purpose.substring(0, 40)} |`);
        });
        return lines.join('\n');
    }

    /**
     * Generate JSON inventory of all controls
     * @returns {Array} Control definitions
     */
    function inventoryJSON() {
        return TESTS.map(t => ({
            name: t.name,
            type: t.type,
            elementId: t.elementId,
            statePath: t.statePath,
            graphMethod: t.graphMethod,
            expected: t.expected
        }));
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        runAll,
        test,
        report,
        listTests,
        diagnose,
        inventory,
        inventoryJSON,
        get isRunning() { return _running; },
        TESTS
    };
})();

// Global shortcut
window.CIRCUIT = CIRCUIT;

console.log('[Module] CIRCUIT loaded - UI control validator with diagnostics');


// ═══ MAIN APPLICATION ═══
window.process = window.process || { env: { NODE_ENV: "production" } };
window.global = window.global || window;
// UMD globals: THREE, ForceGraph3D, pako already loaded
// Three.js addons attach to THREE global: THREE.ConvexGeometry
const ConvexGeometry = THREE.ConvexGeometry;
// Note: Post-processing (bloom) removed for simplicity - addons not available in r149+ UMD builds

// COMPRESSED_PAYLOAD: Base64-encoded gzipped JSON data
const COMPRESSED_PAYLOAD = "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h9Sno/xtupBhV1vsVYfdu8ecILsGU5c90nJx/rQgtyPViioT1FVx/MhTaVvt9lY3veaTu7JLeGptnova4Fs5HaAX0GAxaLBY6K2wN8iW1c0C+nbwvjJloXhZdJL43hsp/+bOdZFmmnR+TKQrWDxl6A3Uvzfsa76mE/HOhf2Gcg5ATEOVNUPL6qP6U7D595WUZ933dWXkodkiwxYKTzbLLgmeZDwqpH5pOIO20muNPpuX90fEms/pxCMxM/Qc8Z+quSCm1YZiy1bGj66NhqoByb8+kMPrfXE7GzvZGXat4HKuOBHI8qflNI/jJ7y2auYczJmLp4enj2eAJzE7NhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANhSANsyObAgAbAgAbAgAbAgAbAgAbAgAbAgAbNi12Li82bi82bi82bBrsXETsHETsGHXYoOZtcHM2mBmbTCzNphZG3YtNuxabHAFNrgCG1yBDbsWG3YtNmi3DcWyA8Wyg/3nYP85UCw7wCsHeOUArxzglQO8coBXDvDKAV45wCsHeOUArxzglQO8coBXDvDKAV45wCsHeOUArxzglQO8coBXDvDKAV45wCsHeOUArxzglQO8coBXDvDKAV45wCsHeOUArxzglQO8coBXDvDKAV45wCsHeOUArxzglQO8coBXDvDKAV45wCsHeOUArxzglQO8coBXDvDKAV45wCsHeOUArxzglQO8coBXDvDKAV45wCsHeOUArxzglQO8coBXDvDKAV45wCsHeOUArxzglQO8coBXDvDKAV45wCsHeOUArxzglQO8coBXDvDKAV45wCsHeOUArxzglQO8coBXDvDKAV65wCsXeOUCr1zglQu8coFXLvDKBV65wCsXeOUCr1zglQu8coFXLvDKBV65wCsXeOUCr1zglQu8coFXLvDKBV65wCsXeOUCr1zglQu8coFXLvDKBV65wCsXeOUCr1zglQu8coFXLvDKBV65wCsXeOUCr1zg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";

// --------------------------------------------------------------------
// WEB WORKER: JSON Parsing Only (Decompression in main thread)
// OPTIMIZED: Main thread uses already-loaded pako, no duplicate CDN fetch
// --------------------------------------------------------------------
const workerScript = `
        self.onmessage = function(e) {
            const jsonStr = e.data;
            try {
                self.postMessage({status: 'PARSING...'});
                const data = JSON.parse(jsonStr);
                self.postMessage({status: 'ANALYZING COSMOS...', result: data});
            } catch (err) {
                self.postMessage({error: err.message});
            }
        };
        `;

// Initialize Worker (minimal - no pako needed)
const blob = new Blob([workerScript], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));

// OPTIMIZED: Decompress in main thread using already-loaded pako
function decompressPayload(payload) {
    // Update status
    const statusEl = document.getElementById('loader-status');
    if (statusEl) statusEl.innerText = 'DECOMPRESSING...';

    // 1. Decode Base64
    const charData = atob(payload);
    const binData = new Uint8Array(charData.length);
    for (let i = 0; i < charData.length; i++) {
        binData[i] = charData.charCodeAt(i);
    }

    // 2. Inflate using main thread's pako (already loaded from CDN)
    if (statusEl) statusEl.innerText = 'INFLATING...';
    const jsonStr = pako.inflate(binData, { to: 'string' });

    return jsonStr;
}

let FULL_GRAPH = null;
let Graph = null;
let DM = null;  // DataManager instance - initialized in initGraph()
let Legend = null;  // LegendManager instance - initialized in initGraph()
let CURRENT_DENSITY = 1; // Default: show all nodes
let ACTIVE_DATAMAPS = new Set();
let DATAMAP_CONFIGS = [];
let DATAMAP_INDEX = {};
let DATAMAP_UI = new Map();
let HOVERED_NODE = null;
// SELECTED_NODE_IDS - provided by selection.js module (getter to SELECT.ids)
let DATASET_KEY = 'default';
let GROUPS_STORAGE_KEY = 'collider_groups_default';
let GROUPS = [];
let ACTIVE_GROUP_ID = null;
// MARQUEE_ACTIVE, MARQUEE_START, MARQUEE_ADDITIVE, LAST_MARQUEE_END_TS - provided by selection.js module
let SELECTION_BOX = null;
const SELECTION_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
const GROUP_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
let SPACE_PRESSED = false;
let IS_3D = true;
// Expose for circuit-breaker tests (dimension-toggle test checks window.IS_3D)
Object.defineProperty(window, 'IS_3D', {
    get: () => IS_3D,
    set: (v) => { IS_3D = v; },
    configurable: true
});
let DIMENSION_TRANSITION = false;
// Expose for dimension.js module and circuit-breaker tests
Object.defineProperty(window, 'DIMENSION_TRANSITION', {
    get: () => DIMENSION_TRANSITION,
    set: (v) => { DIMENSION_TRANSITION = v; },
    configurable: true
});
// STARFIELD & BLOOM - REMOVED (nodes ARE the stars, post-processing not in r149+ UMD builds)
// EDGE_MODE - provided by edge-system.js module
let EDGE_DEFAULT_OPACITY = null;  // Initialized from appearance.tokens at runtime (token value: 0.08)

// PERF_MONITOR - provided by perf-monitor.js module (window.PERF, window.PERF_MONITOR)

// Initialize after DOM ready
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => PERF_MONITOR.init(), 100);
    // Initialize SidebarManager facade for sidebar controls
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
        SIDEBAR.init();
    }
});
let DEFAULT_LINK_DISTANCE = null;

// =================================================================
// THEME CONFIGURATION: Loaded from payload at runtime
// =================================================================
let THEME_CONFIG = {
    available: ['dark'],
    default: 'dark',
    current: 'dark',
    colors: {
        edge: {},
        viz: {},
        console: {},
        schemes: {}
    }
};

// Default color configs - will be overridden by payload tokens
// Edge mode configuration - populated from appearance.tokens at runtime
// Fallback values are defined in appearance.tokens.json:131-204
let EDGE_MODE_CONFIG = {
    resolution: {},
    weight: {},
    confidence: {},
    width: {},
    dim: {},
    opacity: null
};
// Edge type colors - populated from theme.tokens.json:501-512 at runtime
let EDGE_COLOR_CONFIG = {};
// FILE_COLOR_CONFIG, EDGE_RANGES, NODE_FILE_INDEX - provided by modules (file-viz.js, edge-system.js)
let NODE_COLOR_CONFIG = { tier: {}, ring: {}, unknown: '#666666' };

// Console logging colors - populated from theme config
let CONSOLE_COLORS = {
    success: '#4ade80',
    error: '#f87171',
    warning: '#ffaa00',
    info: '#4dd4ff'
};

// Viz colors for canvas and fallbacks - populated from theme config
let VIZ_COLORS = {
    canvasBg: '#03040a',
    nodeFallback: '#888888',
    edgeFallback: '#333333',
    groupHalo: '#88d0ff'
};
let FLOW_CONFIG = {};  // Flow mode settings from THE REMOTE CONTROL
window.GRAPH_MODE = 'atoms'; // atoms | files | hybrid - on window for FILE_VIZ access

// Layout stability: cache node positions to prevent re-randomization on toggles
let NODE_POSITION_CACHE = new Map();
let LAYOUT_FROZEN = false;  // When true, don't reheat simulation
let HINTS_ENABLED = true;   // Show mode toasts

// FILE_GRAPH, FILE_NODE_IDS, EXPANDED_FILES, FILE_EXPAND_MODE - provided by file-viz.js module
let LAST_FILTER_SUMMARY = null;
let FILE_NODE_POSITIONS = new Map();
let NODE_COLOR_MODE = 'tier';
let COLOR_TWEAKS = {
    hueShift: 0,
    chromaScale: 1,
    lightnessShift: 0
};
let VIS_FILTERS = {
    tiers: new Set(),
    rings: new Set(),
    roles: new Set(),
    edges: new Set(),
    families: new Set(),  // Atom families: LOG, DAT, ORG, EXE, EXT
    files: new Set(),     // File-based filtering
    layers: new Set(),    // D2_LAYER: Interface, Application, Core, Infrastructure, Test
    effects: new Set(),   // D6_EFFECT: Pure, Read, Write, ReadWrite
    edgeFamilies: new Set(), // Edge families: Structural, Dependency, Inheritance, Semantic, Temporal
    metadata: {
        showLabels: true,
        showFilePanel: true,
        showReportPanel: true,
        showEdges: true
    }
};
let SIDEBAR_STATE = {
    open: false,
    locked: false
};
let APPEARANCE_STATE = {
    nodeScale: 1,
    nodeOpacity: 1,
    labelSize: 1,
    showLabels: true,
    highlightSelected: true,
    edgeOpacity: null,
    edgeWidth: 1,
    edgeCurvature: 0,
    showArrows: false,
    gradientEdges: true,
    boundaryFill: null,
    boundaryWire: null,
    backgroundBase: null,
    backgroundBrightness: 1,
    fileLightness: null,
    clusterStrength: null,
    currentPreset: 'tier',
    colorMode: 'tier',
    sizeMode: 'fanout',
    edgeMode: 'type',
    // Amplifier: Power law exponent for visual contrast
    // γ=1 linear, γ>1 amplifies differences, γ<1 compresses
    amplifier: 1.0,
    amplifierTarget: 'all'  // 'all', 'edges', 'nodes', 'opacity'
};
// Expose for modules and circuit-breaker tests
window.APPEARANCE_STATE = APPEARANCE_STATE;

// =====================================================================
// FILE BOUNDARY & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
// fileBoundaryMeshes, fileMode, fileVizMode - provided by file-viz.js module
let originalNodeColors = new Map();
let clusterForceActive = false;
let hullRedrawTimer = null;
let hullRedrawAttempts = 0;
const originalColorsForDim = new Map();
let flowMode = false; // Hoisted from line 7333

// REGISTRY - provided by registry.js module (window.REGISTRY)


// =================================================================
// GLOBAL CONSTANTS (Hoisted for safety)
// =================================================================
const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

// OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
const PENDULUM = {
    hue: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,        // Set from appearance.tokens
        gravity: null,        // Set from appearance.tokens
        length: 1.0,
        rotationSpeed: null   // Set from appearance.tokens
    },
    chroma: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,
        gravity: null,
        length: 1.0,
        center: null,
        amplitude: null
    },
    lightness: {
        phase: 0,
        speed: null,
        center: null,
        amplitude: null
    },
    ripple: {
        speed: null,
        scale: null
    },
    currentHue: Math.random() * 360,
    lastTime: 0,
    running: false
};
// =====================================================================
// HOVER & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
let _lastHoveredNodeId = null;
const selectionOriginals = new Map();

// amplify, amplifyContrast - provided by core.js module

// =====================================================================
// DATA MANAGER: Minimal runtime checks for deterministic self-test/parity
// =====================================================================

// =====================================================================
// COLOR ORCHESTRATOR: Centralized Color Intelligence System
// =====================================================================
// SINGLE SOURCE OF TRUTH for ALL colors in the visualization.
// Everything reads from here. OKLCH transforms apply here.
// =====================================================================
const ColorOrchestrator = {
    // =================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =================================================================
    palette: {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    },

    // =================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =================================================================
    transform: {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    },

    // =================================================================
    // INTERVAL MAPPINGS: For numeric data → color gradients
    // =================================================================
    intervals: {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        }
    },

    // =================================================================
    // CORE API: Get color with transforms applied
    // =================================================================
    get(dimension, category) {
        const base = this.palette[dimension]?.[category];
        if (!base) return this._toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray

        return this._applyTransform(base);
    },

    // Get color for a numeric value using interval mapping
    getInterval(intervalName, value) {
        const interval = this.intervals[intervalName];
        if (!interval) return this._toHex({ h: 0, c: 0.02, l: 0.40 });

        const stops = interval.stops;
        const v = Math.max(0, Math.min(1, value));

        // Find surrounding stops
        let lower = stops[0];
        let upper = stops[stops.length - 1];

        for (let i = 0; i < stops.length - 1; i++) {
            if (v >= stops[i].value && v <= stops[i + 1].value) {
                lower = stops[i];
                upper = stops[i + 1];
                break;
            }
        }

        // Interpolate between stops
        const range = upper.value - lower.value;
        const t = range > 0 ? (v - lower.value) / range : 0;

        const interpolated = {
            h: lower.h + (upper.h - lower.h) * t,
            c: lower.c + (upper.c - lower.c) * t,
            l: lower.l + (upper.l - lower.l) * t
        };

        return this._applyTransform(interpolated);
    },

    // Get raw OKLCH values (for advanced use)
    getRaw(dimension, category) {
        return this.palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
    },

    // Get all categories for a dimension
    getCategories(dimension) {
        return Object.keys(this.palette[dimension] || {});
    },

    // Get label for a category
    getLabel(dimension, category) {
        return this.palette[dimension]?.[category]?.label || category;
    },

    // =================================================================
    // TRANSFORM CONTROLS: Update OKLCH state
    // =================================================================
    setTransform(key, value) {
        if (key in this.transform) {
            this.transform[key] = value;
            this._notifySubscribers('transform-change', { key, value });
        }
    },

    setAllTransforms(transforms) {
        Object.assign(this.transform, transforms);
        this._notifySubscribers('transform-change', transforms);
    },

    resetTransforms() {
        this.transform = {
            hueShift: 0,
            chromaScale: 1.0,
            lightnessShift: 0,
            amplifier: 1.0
        };
        this._notifySubscribers('transform-change', this.transform);
    },

    // =================================================================
    // INTERNAL: Apply OKLCH transforms and convert to hex
    // =================================================================
    _applyTransform(oklch) {
        const t = this.transform;

        // Apply transforms
        let h = (oklch.h + t.hueShift + 360) % 360;
        let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
        let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

        // Apply amplifier to chroma for contrast
        if (t.amplifier !== 1) {
            c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
        }

        return this._toHex({ h, c, l });
    },

    _toHex(oklch) {
        // OKLCH to sRGB conversion (simplified)
        // Using CSS color conversion would be ideal, but this approximation works
        const { h, c, l } = oklch;

        // Convert OKLCH to approximate RGB
        const hRad = h * Math.PI / 180;
        const a = c * Math.cos(hRad);
        const b = c * Math.sin(hRad);

        // Simplified OKLab to linear RGB (approximate)
        const L = l;
        const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

        const l3 = l_ * l_ * l_;
        const m3 = m_ * m_ * m_;
        const s3 = s_ * s_ * s_;

        let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
        let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
        let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

        // Clamp and convert to sRGB
        const toSRGB = (x) => {
            x = Math.max(0, Math.min(1, x));
            return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
        };

        r = Math.round(toSRGB(r) * 255);
        g = Math.round(toSRGB(g) * 255);
        bl = Math.round(toSRGB(bl) * 255);

        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        bl = Math.max(0, Math.min(255, bl));

        return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
    },

    // =================================================================
    // REACTIVE SUBSCRIPTIONS
    // =================================================================
    _subscribers: [],

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    },

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    },

    // =================================================================
    // DEBUG: Log current state
    // =================================================================
    debug() {
        console.log('[ColorOrchestrator] Transform state:', this.transform);
        console.log('[ColorOrchestrator] Palette dimensions:', Object.keys(this.palette));
        console.log('[ColorOrchestrator] Interval mappings:', Object.keys(this.intervals));
    }
};

// Global alias for convenience
const Color = ColorOrchestrator;



// =====================================================================
// FLOATING PANEL CONTROL SYSTEM - CONSOLIDATED INTO modules/panels.js
// =====================================================================
// openPanel, closePanel, togglePanel, initCommandBar - ALL IN panels.js
// (backward compat shims in panels.js)


// Populate filter chips in floating panels
function populateFilterChips() {
    if (!DM) return;  // ALL DATA FROM DM

    // Use DM cached aggregations (O(1) lookups)
    const tierCounts = DM.getTierCounts();
    const ringCounts = DM.getRingCounts();
    const edgeCounts = DM.getEdgeTypeCounts();

    buildChipGroup('chips-tiers', tierCounts, VIS_FILTERS.tiers, refreshGraph);
    buildChipGroup('chips-rings', ringCounts, VIS_FILTERS.rings, refreshGraph);
    buildChipGroup('chips-edges', edgeCounts, VIS_FILTERS.edges, refreshGraph);
}

// renderLegendSection, renderAllLegends - MOVED TO modules/legend-manager.js
// (debounce is now built into legend-manager.js, no monkey-patching needed)

// =====================================================================
// HUD LAYOUT MANAGER: MIGRATED TO modules/layout.js
// =====================================================================
// HudLayoutManager (390 lines) has been migrated to modules/layout.js
// which provides the LAYOUT module with:
//   - All original panel placement functionality
//   - NEW: Toast/control-bar collision detection
//   - NEW: Min-width graph validation
//   - NEW: Debug overlay (Ctrl+Shift+L)
//   - NEW: Component registration system
//
// Backward compatibility: window.HudLayoutManager = LAYOUT (alias)
// =====================================================================

worker.onmessage = function (e) {
    if (e.data.status && !e.data.result) {
        document.getElementById('loader-status').innerText = e.data.status;
    } else if (e.data.error) {
        document.getElementById('loader-status').innerText = "ERROR: " + e.data.error;
        document.getElementById('loader-status').style.color = "red";
    } else if (e.data.result) {
        FULL_GRAPH = e.data.result;
        FILE_GRAPH = null;
        FILE_NODE_POSITIONS = new Map();
        EXPANDED_FILES.clear();
        window.GRAPH_MODE = 'atoms';
        document.getElementById('loader-status').innerText = "INITIALIZING VISUALIZATION...";
        initGraph(FULL_GRAPH);
    }
};

// Start Work: Decompress in main thread, then send JSON string to worker for parsing
try {
    const jsonStr = decompressPayload(COMPRESSED_PAYLOAD);
    worker.postMessage(jsonStr);
} catch (err) {
    document.getElementById('loader-status').innerText = "ERROR: " + err.message;
    document.getElementById('loader-status').style.color = "red";
    console.error('[Decompression] Failed:', err);
}

// =====================================================================
// 2D CANVAS FALLBACK: Used when WebGL is unavailable
// =====================================================================
function initFallback2D(container, graphData, fullData) {
    console.log('[2D Fallback] Initializing canvas renderer');
    showToast('WebGL unavailable - using 2D fallback');

    const loader = document.getElementById('loader');
    if (loader) loader.style.display = 'none';

    // Update HUD stats even in 2D fallback mode
    updateHudStats(fullData);

    container.innerHTML = '';
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.background = VIZ_COLORS.canvasBg;
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    let width = container.clientWidth || window.innerWidth;
    let height = container.clientHeight || window.innerHeight;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    // Layout: simple force-directed positions
    const nodes = graphData.nodes || [];
    const links = graphData.links || [];
    const nodeMap = new Map();

    nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        const radius = Math.min(width, height) * 0.35;
        n._x = width / 2 + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);
        n._y = height / 2 + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5);
        n._vx = 0;
        n._vy = 0;
        nodeMap.set(n.id, n);
    });

    // Camera state
    let camX = 0, camY = 0, zoom = 1;
    let dragging = false, lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mousemove', e => {
        if (!dragging) return;
        camX += (e.clientX - lastX) / zoom;
        camY += (e.clientY - lastY) / zoom;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        zoom = Math.max(0.1, Math.min(5, zoom * factor));
    }, { passive: false });

    function toScreen(x, y) {
        return {
            x: (x + camX - width / 2) * zoom + width / 2,
            y: (y + camY - height / 2) * zoom + height / 2
        };
    }

    function parseColor(c) {
        if (typeof c === 'number') {
            return '#' + c.toString(16).padStart(6, '0');
        }
        return c || VIZ_COLORS.nodeFallback;
    }

    function render() {
        ctx.fillStyle = VIZ_COLORS.canvasBg;
        ctx.fillRect(0, 0, width, height);

        // Draw edges
        ctx.strokeStyle = 'rgba(100,100,100,0.3)';
        ctx.lineWidth = 0.5;
        for (const link of links) {
            const src = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
            const tgt = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);
            if (!src || !tgt) continue;
            const p1 = toScreen(src._x, src._y);
            const p2 = toScreen(tgt._x, tgt._y);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // Draw nodes
        for (const node of nodes) {
            const p = toScreen(node._x, node._y);
            const r = Math.max(2, (node.val || 1) * zoom * 0.5);
            ctx.fillStyle = parseColor(node.color);
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Info overlay
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '11px monospace';
        ctx.fillText('2D Fallback Mode (WebGL unavailable)', 10, 20);
        ctx.fillText('Drag to pan, scroll to zoom', 10, 35);
        ctx.fillText(`Nodes: ${nodes.length} | Edges: ${links.length}`, 10, 50);

        requestAnimationFrame(render);
    }

    function resize() {
        width = container.clientWidth || window.innerWidth;
        height = container.clientHeight || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', resize);
    render();

    // Initialize DataManager (required for UI controls)
    DM = new DataManager();
    DM.init(fullData);
    window.DM = DM;

    // Setup UI controls (they work independently of 3D graph)
    setupControls(fullData);
    setupReport(fullData);
    setupAIInsights(fullData);
    setupMetrics(fullData);
    setupHudFade();
    setupDimensionToggle();

    // Update stats with actual node/edge counts
    updateHudStats(graphData);
}

function initGraph(data) {
    // =================================================================
    // DATA MANAGER: Self-test + parity checks
    // =================================================================
    DM = new DataManager();
    DM.init(data);
    window.DM = DM;
    DM.selfTest();
    runDmParity(DM, data);

    // =================================================================
    // HUD STATS: Populate header and stats panel with graph data
    // =================================================================
    updateHudStats(data);

    // =================================================================
    // SIDEBAR: Populate filter chips from loaded data
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.populateFilterChips) {
        SIDEBAR.populateFilterChips(data);
    }

    // =================================================================
    // SIDEBAR: Apply deferred view mode (files mode if saved in localStorage)
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.applyDeferredViewMode) {
        SIDEBAR.applyDeferredViewMode();
    }

    // =================================================================
    // TOKEN-DRIVEN CONFIG: Extract from payload
    // =================================================================
    const physicsConfig = data.physics || {};
    const appearanceConfig = data.appearance || {};
    window.APPEARANCE_CONFIG = appearanceConfig;

    // =================================================================
    // THEME CONFIG: Load theme configuration for runtime switching
    // =================================================================
    if (data.theme_config) {
        THEME_CONFIG = {
            ...THEME_CONFIG,
            available: data.theme_config.available || ['dark'],
            default: data.theme_config.default || 'dark',
            current: data.theme_config.default || 'dark',
            colors: data.theme_config.colors || THEME_CONFIG.colors
        };

        // Apply edge colors from theme config
        if (THEME_CONFIG.colors.edge) {
            EDGE_COLOR_CONFIG = { ...EDGE_COLOR_CONFIG, ...THEME_CONFIG.colors.edge };
        }

        // Apply viz colors from theme config
        if (THEME_CONFIG.colors.viz) {
            const viz = THEME_CONFIG.colors.viz;
            VIZ_COLORS = {
                canvasBg: viz['canvas-bg'] || VIZ_COLORS.canvasBg,
                nodeFallback: viz['node-fallback'] || VIZ_COLORS.nodeFallback,
                edgeFallback: viz['edge-fallback'] || VIZ_COLORS.edgeFallback,
                groupHalo: viz['group-halo'] || VIZ_COLORS.groupHalo
            };
        }

        // Apply console colors from theme config
        if (THEME_CONFIG.colors.console) {
            CONSOLE_COLORS = { ...CONSOLE_COLORS, ...THEME_CONFIG.colors.console };
        }

        console.log(`%c[Theme] Loaded: ${THEME_CONFIG.available.join(', ')}`, `color: ${CONSOLE_COLORS.info}; font-weight: bold`);
    }
    const simulation = physicsConfig.simulation || {};
    // background.bloom, background.stars - REMOVED (post-processing not available in r149+ UMD builds)
    // renderConfig, highlightConfig - REMOVED (unused, features not implemented)
    FLOW_CONFIG = appearanceConfig.flow_mode || {};

    // Merge animation tokens into PENDULUM (T004)
    const animationConfig = appearanceConfig.animation || {};
    if (animationConfig.hue) {
        PENDULUM.hue.damping = animationConfig.hue.damping ?? 0.9995;
        PENDULUM.hue.gravity = animationConfig.hue.speed ?? 0.0008;
        PENDULUM.hue.rotationSpeed = animationConfig.hue.rotation ?? 0.8;
    }
    if (animationConfig.chroma) {
        PENDULUM.chroma.damping = animationConfig.chroma.damping ?? 0.998;
        PENDULUM.chroma.gravity = animationConfig.chroma.gravity ?? 0.0004;
        PENDULUM.chroma.center = animationConfig.chroma.center ?? 0.32;
        PENDULUM.chroma.amplitude = animationConfig.chroma.amplitude ?? 0.08;
    }
    if (animationConfig.lightness) {
        PENDULUM.lightness.speed = animationConfig.lightness.speed ?? 0.02;
        PENDULUM.lightness.center = animationConfig.lightness.center ?? 82;
        PENDULUM.lightness.amplitude = animationConfig.lightness.amplitude ?? 10;
    }
    if (animationConfig.ripple) {
        PENDULUM.ripple.speed = animationConfig.ripple.speed ?? 0.035;
        PENDULUM.ripple.scale = animationConfig.ripple.scale ?? 200;
    }
    const edgeModes = appearanceConfig.edge_modes || {};
    EDGE_MODE_CONFIG = {
        resolution: edgeModes.resolution || { internal: '#4dd4ff', external: '#ff6b6b', unresolved: '#9aa0a6', unknown: '#666666' },
        weight: edgeModes.weight || { hue_min: 210, hue_max: 50, saturation: 45, lightness: 42 },
        confidence: edgeModes.confidence || { hue_min: 20, hue_max: 120, saturation: 45, lightness: 44 },
        width: edgeModes.width || { base: 0.6, weight_scale: 2.0, confidence_scale: 1.5 },
        dim: edgeModes.dim || { interfile_factor: 0.25 },
        opacity: (typeof edgeModes.opacity === 'number') ? edgeModes.opacity : 0.08
    };

    FILE_COLOR_CONFIG = Object.assign({}, FILE_COLOR_CONFIG, appearanceConfig.file_color || {});
    // Token value 0.08 from appearance.tokens.json:202, fallback only if token system fails
    EDGE_DEFAULT_OPACITY =
        (typeof EDGE_MODE_CONFIG.opacity === 'number') ? EDGE_MODE_CONFIG.opacity : 0.08;
    const boundaryConfig = appearanceConfig.boundary || {};
    APPEARANCE_STATE.edgeOpacity = EDGE_DEFAULT_OPACITY;
    APPEARANCE_STATE.boundaryFill = boundaryConfig.fill_opacity ?? APPEARANCE_STATE.boundaryFill;
    APPEARANCE_STATE.boundaryWire = boundaryConfig.wire_opacity ?? APPEARANCE_STATE.boundaryWire;
    const background = appearanceConfig.background || {};
    APPEARANCE_STATE.backgroundBase = background.color || '#000000';
    APPEARANCE_STATE.fileLightness = FILE_COLOR_CONFIG.lightness ?? APPEARANCE_STATE.fileLightness;
    const nodeColor = appearanceConfig.node_color || {};
    NODE_COLOR_CONFIG = {
        tier: nodeColor.tier || {},
        ring: nodeColor.ring || {},
        unknown: nodeColor.unknown || '#666666'
    };
    const edgeColor = appearanceConfig.edge_color || {};
    EDGE_COLOR_CONFIG = {
        default: edgeColor.default || '#333333',
        calls: edgeColor.calls || '#4dd4ff',
        contains: edgeColor.contains || '#00ff9d',
        uses: edgeColor.uses || '#ffb800',
        imports: edgeColor.imports || '#9aa0a6',
        inherits: edgeColor.inherits || '#ff6b6b'
    };

    // Initial Filter: show full graph
    const filtered = filterGraph(data, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);

    // ═══════════════════════════════════════════════════════════════════
    // DATA PREP FOR ANIMATIONS: Assign file indices for wave patterns
    // ═══════════════════════════════════════════════════════════════════
    const fileMap = new Map();
    let nextFileIdx = 0;
    filtered.nodes.forEach(node => {
        // Extract filename from ID (assuming file path is in ID or explicit file prop)
        const file = node.file || (node.id.includes('/') ? node.id.split(':')[0] : 'unknown');
        if (!fileMap.has(file)) fileMap.set(file, nextFileIdx++);
        node.file_idx = fileMap.get(file);
    });

    const div = document.getElementById('3d-graph');

    // ═══════════════════════════════════════════════════════════════════
    // GRADIENT EDGES: Custom THREE.js lines with vertex colors
    // Creates beautiful gradients from source to target node colors
    // ═══════════════════════════════════════════════════════════════════
    let GRADIENT_EDGES_ENABLED = true;  // Toggle for gradient edges

    function hexToRgb(hex) {
        // Convert hex color to RGB array [0-1, 0-1, 0-1]
        if (typeof hex === 'number') {
            return [
                ((hex >> 16) & 255) / 255,
                ((hex >> 8) & 255) / 255,
                (hex & 255) / 255
            ];
        }
        if (typeof hex === 'string') {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                ((num >> 16) & 255) / 255,
                ((num >> 8) & 255) / 255,
                (num & 255) / 255
            ];
        }
        return [0.5, 0.5, 0.5];  // Default gray
    }

    function createGradientEdge(link) {
        // Get source and target nodes
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        // Get colors from nodes (using current color mode)
        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        // Create geometry with 2 vertices
        const geometry = new THREE.BufferGeometry();

        // Positions will be updated by linkPositionUpdate
        const positions = new Float32Array([0, 0, 0, 0, 0, 0]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Vertex colors: source color at start, target color at end
        const colors = new Float32Array([
            srcRgb[0], srcRgb[1], srcRgb[2],  // Source vertex color
            tgtRgb[0], tgtRgb[1], tgtRgb[2]   // Target vertex color
        ]);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Material with vertex colors
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: link.opacity ?? EDGE_DEFAULT_OPACITY,
            linewidth: 1  // Note: linewidth > 1 only works on some platforms
        });

        return new THREE.Line(geometry, material);
    }

    function updateGradientEdge(line, link, coords) {
        // Update line positions
        const posArr = line.geometry.attributes.position.array;
        posArr[0] = coords.start.x || 0;
        posArr[1] = coords.start.y || 0;
        posArr[2] = coords.start.z || 0;
        posArr[3] = coords.end.x || 0;
        posArr[4] = coords.end.y || 0;
        posArr[5] = coords.end.z || 0;
        line.geometry.attributes.position.needsUpdate = true;

        // Update colors based on current node colors
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        const colArr = line.geometry.attributes.color.array;
        colArr[0] = srcRgb[0]; colArr[1] = srcRgb[1]; colArr[2] = srcRgb[2];
        colArr[3] = tgtRgb[0]; colArr[4] = tgtRgb[1]; colArr[5] = tgtRgb[2];
        line.geometry.attributes.color.needsUpdate = true;
    }

    // Refresh all gradient edge colors (call when node color mode changes)
    function refreshGradientEdgeColors() {
        if (!GRADIENT_EDGES_ENABLED || !Graph) return;
        // Force rebuild of all link objects to update colors
        Graph.linkThreeObject(link => createGradientEdge(link));
    }

    // Make it globally accessible for color mode changes
    window.refreshGradientEdgeColors = refreshGradientEdgeColors;

    // TOKEN-DRIVEN: Read render config from THE REMOTE CONTROL
    const renderConfig = appearanceConfig.render || {};
    const dimensions = renderConfig.dimensions || 3;
    const nodeRes = renderConfig.nodeResolution || 8;

    try {
        Graph = ForceGraph3D({
            rendererConfig: {
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            }
        })
            (div)
            .graphData(filtered)
            .numDimensions(dimensions)
            .backgroundColor(toColorNumber(background.color, 0x000000))
            .nodeLabel('name')
            .nodeColor(node => toColorNumber(node.color, 0x888888))
            .nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale)
            // ═══════════════════════════════════════════════════════════════════
            // GRADIENT EDGES: Custom THREE.Line with vertex colors
            // Each edge smoothly transitions from source node color to target node color
            // ═══════════════════════════════════════════════════════════════════
            .linkThreeObject(link => GRADIENT_EDGES_ENABLED ? createGradientEdge(link) : null)
            .linkPositionUpdate((line, coords, link) => {
                if (GRADIENT_EDGES_ENABLED && line) {
                    updateGradientEdge(line, link, coords);
                }
                return true;  // Keep default behavior for non-gradient
            })
            .linkColor(link => GRADIENT_EDGES_ENABLED ? null : toColorNumber(getEdgeColor(link), 0x222222))
            .linkOpacity(link => GRADIENT_EDGES_ENABLED ? 0 : (link.opacity ?? EDGE_DEFAULT_OPACITY))
            .nodeThreeObjectExtend(true)
            .nodeThreeObject(node => ensureNodeOverlays(node))
            .nodeResolution(Math.max(nodeRes, 16))
            .linkResolution(6)
            .showNavInfo(false)
            .warmupTicks(simulation.warmupTicks || 30)
            .cooldownTicks(simulation.cooldownTicks || 0)
            .onNodeHover(node => handleNodeHover(node, data))
            .onNodeClick((node, event) => handleNodeClick(node, event))
            .onBackgroundClick(() => maybeClearSelection())
            // ═══════════════════════════════════════════════════════════════════
            // GROUP DRAG: Move all selected nodes together, maintaining offsets
            // Note: onNodeDragStart doesn't exist - detect start via flag
            // ═══════════════════════════════════════════════════════════════════
            .onNodeDrag((node, _translate) => {
                // Only handle group drag if multiple nodes selected and this node is selected
                if (SELECTED_NODE_IDS.size > 1 && SELECTED_NODE_IDS.has(node.id)) {
                    // First drag frame: store relative offsets
                    if (!window._groupDragActive) {
                        window._groupDragActive = true;
                        window._groupDragOffsets = new Map();
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            if (SELECTED_NODE_IDS.has(n.id) && n.id !== node.id) {
                                window._groupDragOffsets.set(n.id, {
                                    dx: (n.x || 0) - (node.x || 0),
                                    dy: (n.y || 0) - (node.y || 0),
                                    dz: (n.z || 0) - (node.z || 0)
                                });
                            }
                        });
                    }
                    // Move all other selected nodes with their offsets
                    if (window._groupDragOffsets) {
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            const offset = window._groupDragOffsets.get(n.id);
                            if (offset) {
                                n.fx = node.x + offset.dx;
                                n.fy = node.y + offset.dy;
                                n.fz = node.z + offset.dz;
                            }
                        });
                    }
                }
            })
            .onNodeDragEnd(_node => {
                // Clear group drag state
                window._groupDragActive = false;
                window._groupDragOffsets = null;
                // Fix all selected nodes at their final positions
                if (SELECTED_NODE_IDS.size > 0) {
                    const nodes = Graph.graphData().nodes;
                    nodes.forEach(n => {
                        if (SELECTED_NODE_IDS.has(n.id)) {
                            n.fx = n.x; n.fy = n.y; n.fz = n.z;
                        }
                    });
                }
            })
            .onEngineStop(() => {
                // Physics-dependent operations (run after simulation stabilizes)
                drawFileBoundaries(data);
                // LAYOUT STABILITY: Freeze layout after initial simulation completes
                if (!LAYOUT_FROZEN) {
                    saveNodePositions();
                    freezeLayout();
                }
            });
    } catch (err) {
        console.error('[WebGL] Failed to initialize 3D graph:', err);
        initFallback2D(div, filtered, data);
        return;
    }

    window.Graph = Graph;

    // FIX: Drift on resize
    // Updates Graph renderer size when window creates
    window.addEventListener('resize', () => {
        if (Graph) {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        }
    });

    // OPTIMIZATION: Hide loader immediately after Graph creation (don't wait for physics)
    // This makes the visualization appear 200-500ms faster
    document.getElementById('loader').style.display = 'none';

    // =================================================================
    // RENDERER QUALITY: Enable anti-aliasing and high DPI
    // =================================================================
    const renderer = Graph.renderer();
    if (renderer) {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Enable high quality rendering
        renderer.antialias = true;
        renderer.alpha = true;
        renderer.powerPreference = 'high-performance';
    }

    initSelectionState(data);
    setupSelectionInteractions();
    // updateSelectionVisuals is in selection.js (window scope), may not be loaded yet
    if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();

    // =================================================================
    // CONTROLS: keep default camera behavior, enable damping
    // =================================================================
    const controls = Graph.controls();
    if (controls) {
        // TOKEN-DRIVEN: Read from payload (if available), else use defaults
        // Allow remote configuration of mouse buttons and damping
        const navConfig = data.config?.controls || data.controls || {};

        controls.enableDamping = navConfig.enableDamping !== undefined ? navConfig.enableDamping : true;
        controls.dampingFactor = navConfig.dampingFactor || 0.1;
        controls.enableRotate = navConfig.enableRotate !== undefined ? navConfig.enableRotate : true;
        controls.enablePan = navConfig.enablePan !== undefined ? navConfig.enablePan : true;

        // Mouse Buttons: Map generic names to integer constants
        // 0: ROTATE, 1: DOLLY (Zoom), 2: PAN
        const defaultButtons = {
            LEFT: 2, // PAN
            MIDDLE: 1, // DOLLY
            RIGHT: 0 // ROTATE
        };

        if (navConfig.mouseButtons) {
            controls.mouseButtons = {
                LEFT: navConfig.mouseButtons.LEFT ?? defaultButtons.LEFT,
                MIDDLE: navConfig.mouseButtons.MIDDLE ?? defaultButtons.MIDDLE,
                RIGHT: navConfig.mouseButtons.RIGHT ?? defaultButtons.RIGHT
            };
        } else {
            controls.mouseButtons = defaultButtons;
        }

        // Spacebar toggling disabled to ensure stability
    }

    // =================================================================
    // TOKEN-DRIVEN: Force Configuration
    // =================================================================
    const forces = physicsConfig.forces || {};
    if (forces.charge?.enabled) {
        Graph.d3Force('charge').strength(forces.charge.strength || -120);
        Graph.d3Force('charge').distanceMax(forces.charge.distanceMax || 500);
    }
    if (forces.link?.enabled) {
        const linkDistance = forces.link.distance || 50;
        Graph.d3Force('link').distance(linkDistance);
        DEFAULT_LINK_DISTANCE = linkDistance;
    }
    if (forces.center?.enabled) {
        Graph.d3Force('center').strength(forces.center.strength || 0.05);
    }

    // =================================================================
    // STARFIELD REMOVED - Nodes ARE the stars
    // Rationale: Adding background dots creates visual confusion with actual data nodes.
    // The cosmos metaphor works better when the data itself forms the starfield.
    // =================================================================

    // =================================================================
    // TOKEN-DRIVEN: Bloom Post-Processing (DISABLED - UMD build compatibility)
    // Post-processing addons require ES modules; using UMD for file:// support
    // =================================================================
    // Bloom disabled for compatibility - visualization works without it

    // Setup Hud Controls (TOKEN-DRIVEN)
    // OPTIMIZATION: Defer UI setup to next frame so graph renders first
    // This makes the visualization appear 150-200ms faster
    Promise.resolve().then(() => {
        setupControls(data);
        setupReport(data);
        setupAIInsights(data);
        setupMetrics(data);
        setupHudFade();
        setupDimensionToggle();
        applyEdgeMode();

        // SELF-TEST: Deterministic validation of UI controls (deferred)
        runSelfTest(data);
    });
}

function runSelfTest(data) {
    const results = {
        timestamp: new Date().toISOString(),
        passed: [],
        failed: []
    };

    const test = (name, condition) => {
        if (condition) {
            results.passed.push(name);
        } else {
            results.failed.push(name);
        }
    };

    // Test 1: Core UI structure (dual-sidebar layout)

    // Main layout containers
    test('header-exists', !!document.getElementById('header'));
    test('left-sidebar-exists', !!document.getElementById('left-sidebar'));
    test('right-sidebar-exists', !!document.getElementById('right-sidebar'));
    test('graph-container-exists', !!document.getElementById('3d-graph'));

    // Header stats
    test('stat-nodes-exists', !!document.getElementById('stat-nodes'));
    test('stat-edges-exists', !!document.getElementById('stat-edges'));
    test('target-name-exists', !!document.getElementById('target-name'));

    // Left sidebar configuration sections
    test('section-node-config-exists', !!document.getElementById('section-node-config'));
    test('section-edge-config-exists', !!document.getElementById('section-edge-config'));
    test('section-layout-exists', !!document.getElementById('section-layout'));
    test('section-physics-exists', !!document.getElementById('section-physics'));
    test('section-filters-exists', !!document.getElementById('section-filters'));
    test('section-actions-exists', !!document.getElementById('section-actions'));

    // Left sidebar action buttons
    test('btn-reset-exists', !!document.getElementById('btn-reset'));
    test('btn-screenshot-exists', !!document.getElementById('btn-screenshot'));
    test('btn-2d-exists', !!document.getElementById('btn-2d'));
    test('btn-freeze-exists', !!document.getElementById('btn-freeze'));

    // Right sidebar panels
    test('hover-panel-exists', !!document.getElementById('hover-panel'));
    test('section-schemes-exists', !!document.getElementById('section-schemes'));
    test('section-color-exists', !!document.getElementById('section-color'));

    // Selection elements
    test('selection-count-exists', !!document.getElementById('selection-count'));
    test('selection-list-exists', !!document.getElementById('selection-list'));

    // Stats panel
    test('stats-nodes-exists', !!document.getElementById('stats-nodes'));
    test('stats-edges-exists', !!document.getElementById('stats-edges'));

    // Performance HUD
    test('perf-hud-exists', !!document.getElementById('perf-hud'));
    test('perf-fps-exists', !!document.getElementById('perf-fps'));

    // Test 1b: Color mode buttons exist
    const colorButtons = document.querySelectorAll('.color-btn[data-preset]');
    test('color-mode-buttons-exist', colorButtons.length >= 4);

    // Test 1c: HUD Layout Manager tests
    test('hud-layout-manager-exists', typeof HudLayoutManager === 'object' && HudLayoutManager !== null);
    test('hud-layout-manager-has-reflow', typeof HudLayoutManager.reflow === 'function');
    test('hud-layout-manager-has-placePanel', typeof HudLayoutManager.placePanel === 'function');

    // Test 1d: HUD placement with synthetic rects (collision avoidance)
    if (typeof HudLayoutManager.placePanel === 'function') {
        // Create a test scenario: occupied rect on top-left, panel should avoid it
        const fakeOccupied = [{ left: 0, top: 0, right: 300, bottom: 200 }];
        const fakeCandidates = [
            { left: 20, top: 100 },   // Would overlap with occupied
            { left: 400, top: 100 }   // Should be clear
        ];
        // Create a mock panel element
        const mockPanel = document.createElement('div');
        mockPanel.style.width = '200px';
        mockPanel.style.height = '150px';
        mockPanel.style.position = 'fixed';
        document.body.appendChild(mockPanel);

        const result = HudLayoutManager.placePanel(mockPanel, fakeCandidates, fakeOccupied);
        // Should choose the second candidate (no overlap)
        const pickedNonOverlapping = result && result.left >= 300;
        test('hud-placement-avoids-overlap', pickedNonOverlapping);

        document.body.removeChild(mockPanel);
    }

    // Test 1e: Canonical taxonomy field tests
    // Test that node.tier is preferred over atom prefix inference
    const mockNodeWithTier = { tier: 'T2', atom: 'CORE.001', ring: 'DOMAIN' };
    const tierResult = getNodeTier(mockNodeWithTier);
    test('node-tier-prefers-field', tierResult === 'T2');  // Should use tier field, not infer T0 from CORE.

    // Test that node.ring is used when present
    const mockNodeWithRing = { ring: 'PRESENTATION', layer: 'APPLICATION' };
    const ringResult = getNodeRing(mockNodeWithRing);
    test('node-ring-prefers-field', ringResult === 'PRESENTATION');  // Should use ring, not layer

    // Test tier aliases work (CORE → T0, EXT → T2)
    test('tier-alias-core-to-t0', normalizeTier('CORE') === 'T0');
    test('tier-alias-ext-to-t2', normalizeTier('EXT') === 'T2');

    // Test atom_family extraction
    const mockNodeWithFamily = { atom_family: 'LOG', atom: 'ORG.AGG.M' };
    const familyResult = getNodeAtomFamily(mockNodeWithFamily);
    test('node-atom-family-prefers-field', familyResult === 'LOG');  // Should use atom_family, not infer ORG

    // Test 1f: Hover panel tests
    test('hover-panel-exists', document.getElementById('hover-panel') !== null);

    // Test hover panel uses canonical fields
    const mockCanonicalNode = {
        name: 'TestNode',
        atom_family: 'LOG',
        ring: 'PRESENTATION',
        tier: 'T2',
        atom: 'ORG.AGG.M',
        kind: 'function',
        role: 'Utility'
    };
    // Simulate updateHoverPanel with mock node
    if (typeof updateHoverPanel === 'function') {
        updateHoverPanel(mockCanonicalNode);
        const hoverFamily = document.getElementById('hover-family')?.textContent;
        const hoverRing = document.getElementById('hover-ring')?.textContent;
        const hoverTier = document.getElementById('hover-tier')?.textContent;
        // Verify canonical fields are used (LOG not ORG, PRESENTATION, T2)
        test('hover-panel-uses-canonical-fields',
            hoverFamily === 'LOG' && hoverRing === 'PRESENTATION' && hoverTier === 'T2');
        // Clean up: hide panel
        updateHoverPanel(null);
    }

    // Test 2: Header stats populated (stat-* elements - these are set early)
    const headerNodes = document.getElementById('stat-nodes');
    const headerEdges = document.getElementById('stat-edges');
    test('header-nodes-populated', headerNodes && headerNodes.textContent !== '0');
    test('header-edges-populated', headerEdges && headerEdges.textContent !== '0');

    // Test 3: Data integrity
    test('nodes-count-positive', data.nodes && data.nodes.length > 0);
    test('links-count-positive', data.links && data.links.length > 0);
    test('graph-initialized', !!window.Graph);

    // Test 4: Controls config loaded
    test('controls-config-exists', !!data.controls);
    test('appearance-config-exists', !!data.appearance);
    test('physics-config-exists', !!data.physics);

    // Test 5: Initial state correct
    const physicsCharge = document.getElementById('physics-charge');
    test('physics-slider-has-value', physicsCharge && physicsCharge.value !== undefined);
    test('3d-mode-default', IS_3D === true);

    // Test 6: VIS_STATE module loaded
    test('vis-state-module-exists', typeof VIS_STATE !== 'undefined');
    test('vis-state-has-applyState', typeof VIS_STATE?.applyState === 'function');
    test('vis-state-has-getState', typeof VIS_STATE?.getState === 'function');

    // Expose results to window for external testing
    window.SELF_TEST_RESULTS = results;

    // Log summary
    const total = results.passed.length + results.failed.length;
    const passRate = ((results.passed.length / total) * 100).toFixed(1);

    if (results.failed.length === 0) {
        console.log(`%c✅ SELF-TEST PASSED: ${results.passed.length}/${total} tests (${passRate}%)`, 'color: #00ff00; font-weight: bold');
    } else {
        console.warn(`%c⚠️ SELF-TEST: ${results.passed.length}/${total} passed (${passRate}%)`, 'color: #ffaa00; font-weight: bold');
        console.warn('Failed tests:', results.failed);
    }

    return results;
}

// TIER_ALIASES, normalizeTier, getNodeTier, getNodeAtomFamily, normalizeRingValue,
// getNodeRing, getNodeLayer, getNodeEffect - provided by node-accessors.js module

// getNodeColorByMode, getSubsystem, getPhase, getFileType, getRoleCategory, applyNodeColors - MOVED TO modules/node-helpers.js
// normalize - MOVED TO modules/utils.js

function filterGraph(data, minVal, datamapSet, filters) {
    // ALL DATA FROM DM - the processing pipeline
    const allNodes = DM ? DM.getNodes() : (data?.nodes || []);
    const allLinks = DM ? DM.getLinks() : (data?.links || []);

    const tierFilter = filters?.tiers || new Set();
    const ringFilter = filters?.rings || new Set();
    const roleFilter = filters?.roles || new Set();
    const edgeFilter = filters?.edges || new Set();
    const familyFilter = filters?.families || new Set();
    const layerFilter = filters?.layers || new Set();
    const effectFilter = filters?.effects || new Set();
    const edgeFamilyFilter = filters?.edgeFamilies || new Set();
    const showEdges = filters?.metadata?.showEdges !== false;

    const availableRings = Array.from(new Set(allNodes.map(n => getNodeRing(n)))).sort();
    let ringFilterValues = Array.from(ringFilter);
    let ringIntersection = ringFilterValues.filter(r => availableRings.includes(r));
    if (ringFilterValues.length > 0 && ringIntersection.length === 0) {
        console.warn('[Filters] Ring filter values not present in dataset; clearing.', {
            ringValues: ringFilterValues,
            availableRings
        });
        ringFilter.clear();
        ringFilterValues = [];
        ringIntersection = [];
    }

    // Filter nodes by size/importance
    let visibleNodes = allNodes.filter(n => (n.val ?? 1) >= minVal);

    if (datamapSet && datamapSet.size > 0) {
        visibleNodes = visibleNodes.filter(n => {
            for (const id of datamapSet) {
                const config = DATAMAP_INDEX[id];
                if (config && datamapMatches(n, config)) return true;
            }
            return false;
        });
    }

    const tierFilterActive = tierFilter.size > 0;
    const ringFilterActive = ringFilter.size > 0;
    const roleFilterActive = roleFilter.size > 0;
    const familyFilterActive = familyFilter.size > 0;
    const layerFilterActive = layerFilter.size > 0;
    const effectFilterActive = effectFilter.size > 0;

    const filterSummary = {
        active: {
            tier: tierFilter.size,
            ring: ringFilter.size,
            role: roleFilter.size,
            family: familyFilter.size,
            layer: layerFilter.size,
            effect: effectFilter.size
        },
        ringValues: ringFilterValues.slice().sort(),
        availableRings,
        ringIntersectionSize: ringIntersection.length
    };
    const filterSummaryKey = JSON.stringify(filterSummary);
    if (filterSummaryKey !== LAST_FILTER_SUMMARY) {
        console.log('[Filters] summary', filterSummary);
        LAST_FILTER_SUMMARY = filterSummaryKey;
    }

    visibleNodes = visibleNodes.filter(n => {
        if (tierFilterActive && !tierFilter.has(getNodeTier(n))) return false;
        if (ringFilterActive && !ringFilter.has(getNodeRing(n))) return false;
        if (roleFilterActive && !roleFilter.has(String(n.role || 'Unknown'))) return false;
        if (familyFilterActive && !familyFilter.has(getNodeAtomFamily(n))) return false;
        if (layerFilterActive && !layerFilter.has(getNodeLayer(n))) return false;
        if (effectFilterActive && !effectFilter.has(getNodeEffect(n))) return false;
        return true;
    });



    // Zero-node protection: warn when dimension filters result in empty graph
    if (visibleNodes.length === 0 && (tierFilterActive || ringFilterActive || roleFilterActive || familyFilterActive || layerFilterActive || effectFilterActive)) {
        const activeFilters = [];
        if (tierFilterActive) activeFilters.push(`tiers: [${Array.from(tierFilter).join(', ')}]`);
        if (ringFilterActive) activeFilters.push(`rings: [${Array.from(ringFilter).join(', ')}]`);
        if (roleFilterActive) activeFilters.push(`roles: [${Array.from(roleFilter).join(', ')}]`);
        if (familyFilterActive) activeFilters.push(`families: [${Array.from(familyFilter).join(', ')}]`);
        if (layerFilterActive) activeFilters.push(`layers: [${Array.from(layerFilter).join(', ')}]`);
        if (effectFilterActive) activeFilters.push(`effects: [${Array.from(effectFilter).join(', ')}]`);
        console.warn('[filterGraph] Zero nodes match filters:', activeFilters.join(', '));
    }

    const visibleIds = new Set(visibleNodes.map(n => n.id));

    // Keep edges only between visible nodes
    let visibleLinks = allLinks.filter(l =>
        visibleIds.has(l.source.id || l.source) &&
        visibleIds.has(l.target.id || l.target)
    );

    if (edgeFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFilter.has(String(l.edge_type || l.type || 'default')));
    }

    if (edgeFamilyFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFamilyFilter.has(l.family || 'Dependency'));
    }

    if (!showEdges) {
        visibleLinks = [];
    }

    return { nodes: visibleNodes, links: visibleLinks };
}

// ====================================================================
// LAYOUT STABILITY: saveNodePositions, restoreNodePositions, freezeLayout, unfreezeLayout, resetLayout - MOVED TO modules/layout-helpers.js
// showModeToast - MOVED TO modules/tooltips.js
// getLinkEndpointId, getFileTarget - MOVED TO modules/layout-helpers.js
// stableOffset - MOVED TO modules/utils.js

// buildFileGraph - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.buildFileGraph)
// captureFileNodePositions - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.captureFileNodePositions)

function buildHybridGraph(data) {
    // ALL DATA FROM DM - the reaction chamber for data chemistry
    if (!FILE_GRAPH) {
        FILE_GRAPH = buildFileGraph(data);
    }
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const nodes = DM ? DM.getNodes() : (data?.nodes || []);
    const links = DM ? DM.getLinks() : (data?.links || []);

    const totalFiles = boundaries.length;
    const clusterConfig = data?.physics?.cluster || {};
    const detachRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius * 1.3 : 200;
    const detachZ = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing * 2 : 80;
    const expandRadius = 30;
    const expandedSet = new Set(EXPANDED_FILES);

    const fileNodes = FILE_GRAPH.nodes.map(node => {
        const copy = Object.assign({}, node);
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach' && expandedSet.has(node.fileIdx))
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        copy.x = anchor.x + detachOffset.x;
        copy.y = anchor.y + detachOffset.y;
        copy.z = (anchor.z || 0) + detachOffset.z;
        return copy;
    });

    const nodeFileIdx = new Map();
    nodes.forEach(n => {
        if (n && n.id) {
            nodeFileIdx.set(n.id, n.fileIdx ?? -1);
        }
    });

    const childNodes = [];
    nodes.forEach(node => {
        if (!expandedSet.has(node.fileIdx)) return;
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach')
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        const local = stableOffset(node, `file-${node.fileIdx}`, expandRadius);
        const copy = Object.assign({}, node);
        copy.x = anchor.x + detachOffset.x + local.x;
        copy.y = anchor.y + detachOffset.y + local.y;
        copy.z = (anchor.z || 0) + detachOffset.z + (IS_3D ? local.z : 0);
        childNodes.push(copy);
    });

    const childLinks = [];
    links.forEach(link => {
        const srcId = getLinkEndpointId(link, 'source');
        const tgtId = getLinkEndpointId(link, 'target');
        const srcIdx = nodeFileIdx.get(srcId) ?? -1;
        const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;
        if (srcIdx < 0 || tgtIdx < 0 || srcIdx !== tgtIdx) return;
        if (!expandedSet.has(srcIdx)) return;
        childLinks.push({
            source: srcId,
            target: tgtId,
            color: link.color,
            opacity: link.opacity,
            edge_type: link.edge_type,
            weight: link.weight,
            confidence: link.confidence,
            resolution: link.resolution
        });
    });

    return {
        nodes: fileNodes.concat(childNodes),
        links: FILE_GRAPH.links.concat(childLinks)
    };
}

function setupControls(data) {
    // Initialize the Unified UI Manager
    UIManager.init(data);

    // Initialize modules that require data/DOM to be ready
    // (SIDEBAR.init() is called earlier in DOMContentLoaded)
    if (typeof LAYOUT !== 'undefined' && LAYOUT.init) LAYOUT.init();
    if (typeof HUD !== 'undefined' && HUD.setupFade) HUD.setupFade();
    if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) DIMENSION.setup();

    // Initialize Command Bar and Floating Panels
    initCommandBar();

    // Initialize Selection Detail Modal
    initSelectionModal();

    // Initialize Node & Edge Config Controls (PRIME SECTIONS)
    setupConfigControls();

    // Render color-coded legends with counts
    renderAllLegends();

    // Flow mode button (attached here for proper DOM timing)
    const btnFlow = document.getElementById('btn-flow');
    if (btnFlow) btnFlow.onclick = () => toggleFlowMode();
}

/**
 * =================================================================
 * setupConfigControls: Initialize NODE CONFIG and EDGE CONFIG panels
 * =================================================================
 * These are the "prime position" controls at the top of the sidebar
 */
function setupConfigControls() {
    // Helper: Bind slider with value display
    const bindSlider = (id, valueId, onChange, decimals = 1) => {
        const slider = document.getElementById(id);
        const valueEl = document.getElementById(valueId);
        if (!slider) return;
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (valueEl) valueEl.textContent = decimals === 0 ? val.toString() : val.toFixed(decimals);
            onChange(val);
        });
    };

    // Helper: Bind toggle switch
    const bindToggle = (id, initialState, onChange) => {
        const toggle = document.getElementById(id);
        if (!toggle) return;
        if (initialState) toggle.classList.add('active');
        else toggle.classList.remove('active');
        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            onChange(isActive);
        });
    };

    // Helper: Bind button group (radio-like selection)
    const bindButtonGroup = (container, dataAttr, onChange) => {
        const buttons = container.querySelectorAll(`[${dataAttr}]`);
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                onChange(btn.getAttribute(dataAttr));
            });
        });
    };

    // ═══════════════════════════════════════════════════════════════════
    // NODE CONFIG
    // ═══════════════════════════════════════════════════════════════════

    // Size Mode Selector
    const nodeCfg = document.getElementById('section-node-config');
    if (nodeCfg) {
        bindButtonGroup(nodeCfg, 'data-size-mode', (mode) => {
            APPEARANCE_STATE.sizeMode = mode;
            applyNodeSizeMode(mode);
            console.log('[CONFIG] Size mode:', mode);
        });
    }

    // Node Base Size
    bindSlider('cfg-node-size', 'cfg-node-size-val', (val) => {
        APPEARANCE_STATE.nodeScale = val;
        applyNodeSizeMode(APPEARANCE_STATE.sizeMode || 'uniform');
    });

    // Node Opacity
    bindSlider('cfg-node-opacity', 'cfg-node-opacity-val', (val) => {
        APPEARANCE_STATE.nodeOpacity = val;
        if (Graph) Graph.nodeOpacity(val);
    });

    // Node Resolution (sphere segments)
    bindSlider('cfg-node-res', 'cfg-node-res-val', (val) => {
        APPEARANCE_STATE.nodeResolution = Math.round(val);
        if (Graph) Graph.nodeResolution(Math.round(val));
    }, 0);

    // Label Size
    bindSlider('cfg-label-size', 'cfg-label-size-val', (val) => {
        APPEARANCE_STATE.labelSize = val;
        if (Graph && APPEARANCE_STATE.showLabels) {
            Graph.nodeLabel(node => val > 0.2 ? (node.name || node.id) : null);
        }
    });

    // Show Labels Toggle
    bindToggle('cfg-toggle-labels', APPEARANCE_STATE.showLabels, (active) => {
        APPEARANCE_STATE.showLabels = active;
        if (Graph) Graph.nodeLabel(node => active ? (node.name || node.id) : null);
    });

    // Highlight Selected Toggle
    bindToggle('cfg-toggle-highlight', APPEARANCE_STATE.highlightSelected, (active) => {
        APPEARANCE_STATE.highlightSelected = active;
        if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();
    });

    // Pulse Animation Toggle
    bindToggle('cfg-toggle-pulse', false, (active) => {
        APPEARANCE_STATE.pulseAnimation = active;
        console.log('[CONFIG] Pulse animation:', active ? 'ON' : 'OFF');
    });

    // 3D Depth Shading Toggle
    bindToggle('cfg-toggle-depth', true, (active) => {
        APPEARANCE_STATE.depthShading = active;
        console.log('[CONFIG] Depth shading:', active ? 'ON' : 'OFF');
    });

    // ═══════════════════════════════════════════════════════════════════
    // EDGE CONFIG - Enhanced with better visibility and flow animation
    // ═══════════════════════════════════════════════════════════════════

    // Edge Style Selector
    const edgeCfg = document.getElementById('section-edge-config');
    if (edgeCfg) {
        bindButtonGroup(edgeCfg, 'data-edge-style', (style) => {
            APPEARANCE_STATE.edgeStyle = style;
            applyEdgeStyle(style);
            console.log('[CONFIG] Edge style:', style);
        });
    }

    // Edge Opacity - ENHANCED: Higher default for visibility
    bindSlider('cfg-edge-opacity', 'cfg-edge-opacity-val', (val) => {
        APPEARANCE_STATE.edgeOpacity = val;
        // Use applyEdgeMode to ensure consistent function-based opacity
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Width - ENHANCED: Thicker default
    bindSlider('cfg-edge-width', 'cfg-edge-width-val', (val) => {
        APPEARANCE_STATE.edgeWidth = val;
        // Use applyEdgeMode to ensure consistent function-based width
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Curvature - Direct Graph API (not handled by EDGE module)
    bindSlider('cfg-edge-curve', 'cfg-edge-curve-val', (val) => {
        APPEARANCE_STATE.edgeCurvature = val;
        if (Graph) Graph.linkCurvature(val);
    });

    // Particle Speed - For FLOW visualization
    bindSlider('cfg-particle-speed', 'cfg-particle-speed-val', (val) => {
        APPEARANCE_STATE.particleSpeed = val;
        if (Graph) Graph.linkDirectionalParticleSpeed(val);
    }, 3);

    // Particle Density - For FLOW visualization
    bindSlider('cfg-particle-count', 'cfg-particle-count-val', (val) => {
        APPEARANCE_STATE.particleCount = Math.round(val);
        if (Graph) Graph.linkDirectionalParticles(Math.round(val));
    }, 0);

    // NOTE: Toggle bindings moved to sidebar.js (_bindAppearanceControls)
    // Keeping only initial state sync here
    const arrowToggle = document.getElementById('cfg-toggle-arrows');
    if (arrowToggle && APPEARANCE_STATE.showArrows) arrowToggle.classList.add('active');

    const gradientToggle = document.getElementById('cfg-toggle-gradient');
    if (gradientToggle && APPEARANCE_STATE.gradientEdges) gradientToggle.classList.add('active');

    // Highlight Edges on Hover Toggle
    bindToggle('cfg-toggle-edge-hover', true, (active) => {
        APPEARANCE_STATE.edgeHoverHighlight = active;
    });

    // ═══════════════════════════════════════════════════════════════════
    // Section Collapse Handlers
    // ═══════════════════════════════════════════════════════════════════
    document.querySelectorAll('.section-header[data-section]').forEach(header => {
        header.addEventListener('click', () => {
            const sectionId = header.dataset.section;
            const content = document.getElementById(`section-${sectionId}`);
            if (!content) return;
            const isCollapsed = header.classList.toggle('collapsed');
            content.classList.toggle('collapsed', isCollapsed);
        });
    });

    console.log('[CONFIG] Node & Edge config controls initialized');
}

// applyNodeSizeMode - MOVED TO modules/node-helpers.js

/**
 * Apply edge style - controls edge rendering mode
 */
function applyEdgeStyle(style) {
    if (!Graph) return;
    const opacity = APPEARANCE_STATE.edgeOpacity || 0.4;
    const speed = APPEARANCE_STATE.particleSpeed || 0.01;
    const count = APPEARANCE_STATE.particleCount || 0;

    switch (style) {
        case 'solid':
            Graph.linkLineDash(null);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'dashed':
            Graph.linkLineDash([4, 4]);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'particle':
            // Particle mode: dim lines, bright particles for flow effect
            Graph.linkLineDash(null);
            Graph.linkOpacity(Math.max(0.1, opacity * 0.3));
            Graph.linkDirectionalParticles(Math.max(4, count));
            Graph.linkDirectionalParticleSpeed(speed);
            Graph.linkDirectionalParticleWidth(3);
            Graph.linkDirectionalParticleColor(link => {
                // Use source node color for particles
                if (link.source && typeof link.source === 'object') {
                    return link.source.__threeObj?.material?.color?.getStyle() || '#00d4ff';
                }
                return '#00d4ff';
            });
            break;
    }
}

// UIManager - provided by ui-manager.js module (window.UI_MANAGER, window.UIManager)

function refreshGraph() {
    if (!DM || !Graph) return;  // ALL DATA FROM DM

    // LAYOUT STABILITY: Save current positions before any graph update
    saveNodePositions();

    if (GRAPH_MODE === 'files') {
        if (!FILE_GRAPH) {
            FILE_GRAPH = buildFileGraph(null);  // Uses DM internally
        }
        restoreNodePositions(FILE_GRAPH.nodes);
        Graph.graphData(FILE_GRAPH);
        applyFileColors(FILE_GRAPH.nodes);
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel('name');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    if (GRAPH_MODE === 'hybrid') {
        const hybrid = buildHybridGraph(null);  // Uses DM internally
        restoreNodePositions(hybrid.nodes);
        Graph.graphData(hybrid);
        applyFileColors(hybrid.nodes);
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    const subset = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);  // Uses DM internally
    if (ACTIVE_DATAMAPS.size > 0 && subset.nodes.length === 0) {
        showToast('No nodes for that datamap selection.');
        ACTIVE_DATAMAPS.clear();
        const fallback = filterGraph(null, CURRENT_DENSITY, new Set(), VIS_FILTERS);  // Uses DM internally
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        // Force re-evaluation of accessors
        Graph.nodeColor(Graph.nodeColor());
        Graph.nodeRelSize(Graph.nodeRelSize());
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        if (fileMode && GRAPH_MODE === 'atoms') {
            applyFileVizMode();
        }
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    // Zero-node protection for VIS_FILTERS (tier/ring/family/role)
    const hasActiveFilters = VIS_FILTERS.tiers.size > 0 || VIS_FILTERS.rings.size > 0 ||
        VIS_FILTERS.families.size > 0 || VIS_FILTERS.roles.size > 0;
    if (subset.nodes.length === 0 && hasActiveFilters) {
        showToast('No nodes match current filters. Clearing filters.');
        clearAllFilters();
        const fallback = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    applyNodeColors(subset.nodes);
    restoreNodePositions(subset.nodes);
    Graph.graphData(subset);
    Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
    Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
    applyEdgeMode();
    if (fileMode && GRAPH_MODE === 'atoms') {
        applyFileVizMode();
    }
    updateDatamapControls();
    syncSelectionAfterGraphUpdate();
    if (LAYOUT_FROZEN) freezeLayout();
}

// ═══════════════════════════════════════════════════════════════════════
// THEORY CONSTANTS - MOVED TO modules/theory.js
// ═══════════════════════════════════════════════════════════════════════
// SCALE_16_LEVELS, THREE_LAYERS, SMC_THEORY, LEVEL_ZONES, VIS_PRESETS
// Now provided by THEORY module with backward-compat shims

// Tooltip state - shared with modules/tooltips.js
const TOOLTIP_STATE = { visible: false, currentKey: null, element: null, hideTimeout: null };

// initTooltips, showTopoTooltip, hideTopoTooltip - MOVED TO modules/tooltips.js

// ═══════════════════════════════════════════════════════════════════════
// getTopoColor - MOVED TO modules/color-helpers.js

// ═══════════════════════════════════════════════════════════════════════
// LAYOUT PRESETS - MOVED TO modules/animation.js
// ═══════════════════════════════════════════════════════════════════════
// LAYOUT_PRESETS, STAGGER_PATTERNS, CURRENT_LAYOUT, LAYOUT_ANIMATION_ID,
// LAYOUT_TIME, CURRENT_STAGGER_PATTERN, applyLayoutPreset, cycleStaggerPattern,
// startLayoutMotion, startFlockSimulation, groupNodesByTier
// All now provided by ANIM module with O(n) spatial hashing (fixes ARCH-002)








// Count nodes by tier and family







// Hermite basis functions for C¹ continuous color interpolation




// ═══════════════════════════════════════════════════════════════









// OKLCH-inspired colors (converted to linear RGB for Three.js)
// Chaos (bottom): OKLCH(0.25, 0.12, 240) ≈ deep cosmic blue




// ═══════════════════════════════════════════════════════════════


























// clearAllFilters - MOVED TO modules/visibility.js







// collectCounts, buildCheckboxRow, buildFilterGroup - MOVED TO modules/ui-builders.js
// resolveDefaults - MOVED TO modules/utils.js
// normalizeDatamapConfig, resolveDatamapConfigs, datamapMatches - MOVED TO modules/datamap.js
// buildDatamapToggle, buildExclusiveOptions - MOVED TO modules/ui-builders.js

// ═══════════════════════════════════════════════════════════════════════════
// APPEARANCE SLIDERS - Orchestration layer (uses UI_BUILDERS for pure UI)
// This function owns the business logic: what sliders exist, their values,
// and what happens when they change. UI_BUILDERS.buildAppearanceSliders
// handles the DOM creation.
// ═══════════════════════════════════════════════════════════════════════════

function buildAppearanceSliders(containerId, sliderConfigs) {

    const resolveSlider = (key, fallback) => {
        const config = (sliderConfigs && sliderConfigs[key]) ? sliderConfigs[key] : {};
        return {
            label: config.label || fallback.label,
            min: (config.min !== undefined) ? config.min : fallback.min,
            max: (config.max !== undefined) ? config.max : fallback.max,
            step: (config.step !== undefined) ? config.step : fallback.step,
            default: (config.default !== undefined) ? config.default : fallback.value
        };
    };

    const sliderDefs = [
        (() => {
            const config = resolveSlider('edgeOpacity', {
                label: 'EDGE OPACITY',
                min: 0.02,
                max: 0.4,
                step: 0.01,
                value: EDGE_DEFAULT_OPACITY
            });
            return {
                id: 'edge-opacity',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.edgeOpacity ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.edgeOpacity = val;
                    applyEdgeMode();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('nodeScale', {
                label: 'NODE SCALE',
                min: 0.6,
                max: 2.5,
                step: 0.1,
                value: 1
            });
            return {
                id: 'node-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.nodeScale ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.nodeScale = val;
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('backgroundBrightness', {
                label: 'BACKGROUND',
                min: 0,
                max: 1,
                step: 0.05,
                value: 1
            });
            return {
                id: 'bg-brightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.backgroundBrightness ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.backgroundBrightness = val;
                    updateBackgroundBrightness();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('fileLightness', {
                label: 'FILE LIGHT',
                min: 20,
                max: 80,
                step: 1,
                value: 50
            });
            return {
                id: 'file-lightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.fileLightness ?? config.default,
                onChange: (val) => {
                    FILE_COLOR_CONFIG.lightness = val;
                    APPEARANCE_STATE.fileLightness = val;
                    if (fileMode) {
                        applyFileVizMode();
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hueShift', {
                label: 'HUE SHIFT',
                min: -180,
                max: 180,
                step: 1,
                value: 0
            });
            return {
                id: 'hue-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.hueShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.hueShift = val;
                    Color.setTransform('hueShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('chromaScale', {
                label: 'CHROMA SCALE',
                min: 0,
                max: 2,
                step: 0.05,
                value: 1
            });
            return {
                id: 'chroma-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.chromaScale ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.chromaScale = val;
                    Color.setTransform('chromaScale', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('lightnessShift', {
                label: 'LIGHT SHIFT',
                min: -20,
                max: 20,
                step: 1,
                value: 0
            });
            return {
                id: 'lightness-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.lightnessShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.lightnessShift = val;
                    Color.setTransform('lightnessShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('boundaryOpacity', {
                label: 'HULL OPACITY',
                min: 0.02,
                max: 0.25,
                step: 0.01,
                value: 0.1
            });
            return {
                id: 'boundary-fill',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryFill ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryFill = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hullWireOpacity', {
                label: 'HULL WIRE',
                min: 0.05,
                max: 0.6,
                step: 0.02,
                value: 0.35
            });
            return {
                id: 'boundary-wire',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryWire ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryWire = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('clusterStrength', {
                label: 'CLUSTER FORCE',
                min: 0,
                max: 1,
                step: 0.1,
                value: 0.45
            });
            return {
                id: 'cluster-strength',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.clusterStrength ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.clusterStrength = val;
                    if (fileMode && fileVizMode === 'cluster') {
                        applyClusterForce(null);  // Uses DM internally
                    }
                }
            };
        })(),
        // ═══════════════════════════════════════════════════════════
        // AMPLIFIER SLIDER - Power law exponent for visual contrast
        // γ=1 linear, γ>1 amplifies small differences, γ<1 compresses
        // Formula: amplified = value^(1/γ)
        // ═══════════════════════════════════════════════════════════
        (() => {
            const config = resolveSlider('amplifier', {
                label: 'AMPLIFIER (γ)',
                min: 0.3,
                max: 5.0,
                step: 0.1,
                value: 1.0
            });
            return {
                id: 'amplifier',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.amplifier ?? config.default,
                className: 'meta-amplifier',  // Special styling for meta-slider
                description: 'γ>1 amplifies differences, γ<1 compresses',
                onChange: (val) => {
                    APPEARANCE_STATE.amplifier = val;
                    // Re-apply edge mode to update widths with new amplification
                    applyEdgeMode();
                    // If in flow mode, re-apply flow visualization
                    if (flowMode) {
                        applyFlowVisualization();
                    }
                }
            };
        })()
    ];

    // Use UI_BUILDERS for pure DOM creation (decoupled architecture)
    // Each sliderDef has its own onChange handler - business logic stays here
    UI_BUILDERS.buildAppearanceSliders(containerId, sliderDefs);
}

// ═══════════════════════════════════════════════════════════════════════
// PHYSICS CONTROLS - Real-time force simulation adjustment
// ═══════════════════════════════════════════════════════════════════════
const PHYSICS_STATE = {
    charge: -120,
    linkDistance: 50,
    centerStrength: 0.05,
    velocityDecay: 0.4
};

const PHYSICS_PRESETS = {
    default: { charge: -120, linkDistance: 50, centerStrength: 0.05, velocityDecay: 0.4, label: 'DEFAULT' },
    tight: { charge: -80, linkDistance: 30, centerStrength: 0.1, velocityDecay: 0.5, label: 'TIGHT' },
    loose: { charge: -200, linkDistance: 80, centerStrength: 0.02, velocityDecay: 0.3, label: 'LOOSE' },
    explosive: { charge: -400, linkDistance: 120, centerStrength: 0.01, velocityDecay: 0.2, label: 'EXPLOSIVE' }
};

// applyPhysicsState, applyPhysicsPreset, updatePhysicsSliders, buildPhysicsControls - MOVED TO modules/physics.js

// updateBackgroundBrightness, applyMetadataVisibility - MOVED TO modules/visibility.js

// Deprecated setupSidebar - replaced by UIManager
// Deprecated buildDatamapControls - replaced by UIManager


// ═══════════════════════════════════════════════════════════════
// PRESET BUTTONS - Quick visualization mode selection (Tier, Family, etc.)
// Uses VIS_STATE for unified state management
// ═══════════════════════════════════════════════════════════════
const presetGrid = document.getElementById('dock-presets');
const presetBtnGrid = document.getElementById('preset-grid');
if (presetBtnGrid) {
    presetBtnGrid.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const presetKey = btn.dataset.preset;

            // Use VIS_STATE for unified state management
            if (typeof VIS_STATE !== 'undefined') {
                VIS_STATE.applyPreset(presetKey);
                return;
            }

            // Fallback for when VIS_STATE not loaded
            const preset = VIS_PRESETS[presetKey];
            if (!preset) return;

            presetBtnGrid.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            APPEARANCE_STATE.currentPreset = presetKey;
            APPEARANCE_STATE.colorMode = preset.colorBy;

            setNodeColorMode(preset.colorBy);

            const edgeModes = { 'type': 'gradient-tier', 'weight': 'weight', 'resolution': 'gradient-file' };
            EDGE_MODE = edgeModes[preset.edgeBy] || preset.edgeBy || 'gradient-tier';
            applyEdgeMode();

            if (presetKey === 'flow') {
                if (!flowMode && typeof toggleFlowMode === 'function') toggleFlowMode();
            } else if (flowMode && typeof disableFlowMode === 'function') {
                disableFlowMode();
            }

            if (typeof window.refreshGradientEdgeColors === 'function') {
                window.refreshGradientEdgeColors();
            }

            if (typeof renderAllLegends === 'function') {
                renderAllLegends();
            }

            console.log('[Preset] Applied:', preset.name, '| colorBy:', preset.colorBy, '| edgeBy:', preset.edgeBy);
        });
    });
}

// ═══════════════════════════════════════════════════════════════
// NOTE: Color scheme buttons are now handled by sidebar.js via SIDEBAR.initSchemeNavigator()
// The 33 named schemes (viridis, plasma, thermal, etc.) are defined in color-engine.js schemePaths
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// LAYOUT BUTTONS - Graph layout presets with perpetual motion
// ═══════════════════════════════════════════════════════════════
const layoutGrid = document.getElementById('layout-grid');
if (layoutGrid) {
    layoutGrid.querySelectorAll('.layout-btn').forEach(btn => {
        const layoutKey = btn.dataset.layout;
        // Assign ID if missing for Registry
        if (!btn.id) btn.id = `layout-btn-${layoutKey}`;

        REGISTRY.register(btn.id, () => {
            if (!layoutKey || !LAYOUT_PRESETS[layoutKey]) return;

            // Update active state
            layoutGrid.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Apply the layout
            applyLayoutPreset(layoutKey, true);

            console.log('[Layout] Applied:', LAYOUT_PRESETS[layoutKey].name);
        }, { desc: `Activate ${layoutKey} layout` });
    });
}

// VIEW section controls
buildExclusiveOptions('filter-node-color', [
    { label: 'TIER', value: 'tier' },
    { label: 'RING', value: 'ring' },
    { label: 'FAMILY', value: 'family' },
    { label: 'LAYER', value: 'layer' },
    { label: 'FILE', value: 'file' },
    { label: 'ATOM', value: 'atom' },
    { label: 'COMPLEXITY', value: 'complexity' },
    { label: 'CHURN', value: 'churn' }
], NODE_COLOR_MODE, setNodeColorMode);
buildExclusiveOptions('filter-edge-mode', [
    { label: 'GRAD-FILE', value: 'gradient-file' },
    { label: 'GRAD-TIER', value: 'gradient-tier' },
    { label: 'GRAD-FLOW', value: 'gradient-flow' },
    { label: 'TYPE', value: 'type' },
    { label: 'WEIGHT', value: 'weight' },
    { label: 'MONO', value: 'mono' }
], EDGE_MODE, setEdgeMode);
buildMetadataControls('filter-metadata', VIS_FILTERS.metadata);
buildAppearanceSliders('appearance-sliders', {}); // controlsConfig removed - sliders built dynamically
buildPhysicsControls('physics-sliders');  // Physics/forces controls

applyMetadataVisibility();
updateBackgroundBrightness();
refreshGraph();

// setupCollapsibleSections - MOVED TO modules/visibility.js

// setupReport, setupAIInsights, setupMetrics - MOVED TO modules/report.js

// escapeHtml - MOVED TO modules/utils.js

// setupHudFade, updateHudStats - MOVED TO modules/hud.js

// showToast - MOVED TO modules/tooltips.js
// updateDatamapControls - MOVED TO modules/datamap.js

// toggleDimensions, setupDimensionToggle, animateDimensionChange - MOVED TO modules/dimension.js

// stableSeed, stableZ - MOVED TO modules/utils.js

// ====================================================================
// EDGE VISUALIZATION MODES - GRADIENT & DATA-DRIVEN SYSTEM
// ====================================================================
// NEW: Edge modes with gradients showing data progression & regions
const EDGE_MODE_ORDER = [
    'gradient-tier',      // Source→Target tier flow (architecture layers)
    'gradient-file',      // File boundaries (module regions)
    'gradient-flow',      // Markov probability (hot paths)
    'gradient-depth',     // Call depth progression
    'gradient-semantic',  // Semantic distance (type similarity)
    'type',               // Classic type-based
    'weight',             // Weight intensity
    'mono'                // Minimal monochrome
];
const EDGE_MODE_LABELS = {
    'gradient-tier': '▼ TIER FLOW',
    'gradient-file': '▼ FILE REGIONS',
    'gradient-flow': '▼ HOT PATHS',
    'gradient-depth': '▼ CALL DEPTH',
    'gradient-semantic': '▼ SEMANTIC',
    type: 'EDGE: TYPE',
    weight: 'EDGE: WEIGHT',
    mono: 'EDGE: MONO'
};
const EDGE_MODE_HINTS = {
    'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
    'gradient-file': 'Color by file region - shows module boundaries',
    'gradient-flow': 'Hot paths - markov probability gradient',
    'gradient-depth': 'Color by call chain depth',
    'gradient-semantic': 'Color by semantic similarity of endpoints',
    type: 'Edge color by type (calls, imports, etc.)',
    weight: 'Edge width & color by weight',
    mono: 'Minimal monochrome'
};

// Gradient color palettes for different modes
const GRADIENT_PALETTES = {
    tier: {
        // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
        T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
        T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
        T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
        UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
    },
    file: {
        // Rainbow hues distributed across files
        saturation: 65,
        lightness: 48
    },
    flow: {
        // Cold (low prob) to Hot (high prob)
        cold: { h: 220, s: 60, l: 45 },   // Blue
        warm: { h: 45, s: 85, l: 50 },    // Yellow
        hot: { h: 0, s: 90, l: 55 }       // Red
    },
    depth: {
        // Shallow (bright) to Deep (dark, saturated)
        shallow: { h: 180, s: 50, l: 65 },  // Light cyan
        mid: { h: 260, s: 70, l: 50 },      // Purple
        deep: { h: 320, s: 80, l: 40 }      // Magenta
    },
    semantic: {
        // Similar (harmonious) to Different (contrasting)
        similar: { h: 150, s: 60, l: 50 },    // Green - same type
        related: { h: 200, s: 65, l: 48 },    // Cyan - related
        different: { h: 340, s: 75, l: 50 }   // Pink - different
    }
};

// FILE_HUE_MAP, buildFileHueMap - provided by edge-system.js module

// Get node tier value (0=T0, 1=T1, 2=T2)
// getNodeTierValue, getNodeDepth, getSemanticSimilarity - MOVED TO modules/node-helpers.js

// interpolateColor, applyColorTweaks, oklchToSrgb, oklchColor - MOVED TO modules/color-engine.js
// Use COLOR.interpolate() and COLOR.get() instead

// getGradientEdgeColor - MOVED TO modules/edge-system.js
// clamp01, clampValue - MOVED TO modules/utils.js
// hslColor REMOVED - Using OKLCH Native via Color.interpolate
// parseOklchString - MOVED TO modules/utils.js
// normalizeColorInput, toColorNumber - MOVED TO modules/color-helpers.js

// updateEdgeRanges, refreshNodeFileIndex, getLinkFileIdx - MOVED TO modules/edge-system.js
// (shims delegate to EDGE.updateRanges, EDGE.refreshNodeFileIndex; getLinkFileIdx is internal)

// normalizeMetric - MOVED TO modules/utils.js
// getEdgeColor, getEdgeWidth, applyEdgeMode, cycleEdgeMode, setEdgeMode - MOVED TO modules/edge-system.js
// (backward compat shims in edge-system.js)

// Datamap toggles are wired in buildDatamapControls().
const btnReport = document.getElementById('btn-report');
if (btnReport) {
    btnReport.onclick = () => {
        const panel = document.getElementById('report-panel');
        const btn = document.getElementById('btn-report');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// AI INSIGHTS PANEL TOGGLE
const btnInsights = document.getElementById('btn-insights');
if (btnInsights) {
    btnInsights.onclick = () => {
        const panel = document.getElementById('insights-panel');
        const btn = document.getElementById('btn-insights');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// setStarsVisible, STARS_STORAGE_KEY, stars toggle binding - MOVED TO modules/stars.js
// Call STARS.init() to initialize (done in modules/main.js)

// Reset Layout button - explicitly re-run physics
const btnResetLayout = document.getElementById('btn-reset-layout');
if (btnResetLayout) {
    btnResetLayout.onclick = () => resetLayout();
}

// Hints toggle - enable/disable mode toasts
const btnHints = document.getElementById('btn-hints');
if (btnHints) {
    btnHints.onclick = () => {
        HINTS_ENABLED = !HINTS_ENABLED;
        btnHints.classList.toggle('active', HINTS_ENABLED);
        if (HINTS_ENABLED) {
            showModeToast('Hints enabled');
        }
    };
}

const btnEdgeMode = document.getElementById('btn-edge-mode');
if (btnEdgeMode) {
    btnEdgeMode.onclick = () => cycleEdgeMode();
}

// ====================================================================
// FLOW MODE: Markov Chain Visualization (Token-Driven)
// ====================================================================
// flowMode hoisted to top
let originalLinkWidths = new Map();
let highEntropyNodes = new Set();
// FLOW_CONFIG is set in initGraph() from THE REMOTE CONTROL tokens

// getFlowPresetColor, getFlowPresetValue - MOVED TO modules/flow.js

// FLOW_PRESETS, currentFlowPreset - MOVED TO modules/flow.js

// toggleFlowMode, disableFlowMode, applyFlowVisualization, clearFlowVisualization - MOVED TO modules/flow.js

// setDatamap, setNodeColorMode, applyDatamap - MOVED TO modules/datamap.js

// ====================================================================
// FILE BOUNDARIES & HOVER SYSTEM
// ====================================================================
// NOTE: fileBoundaryMeshes, fileMode, fileVizMode, etc. declared at top of file

// hashToUnit - MOVED TO modules/utils.js
// getFileHue, getFileColor - MOVED TO modules/color-helpers.js
// updateHoverPanel, handleNodeHover, handleNodeClick - MOVED TO modules/hover.js
// buildDatasetKey - MOVED TO modules/utils.js
// loadGroups, saveGroups, getNextGroupColor, getGroupById, getPrimaryGroupForNode - MOVED TO modules/groups.js
// renderGroupList, updateGroupButtonState, createGroupFromSelection - MOVED TO modules/groups.js

// getSelectedNodes, setSelection, toggleSelection, clearSelection, maybeClearSelection - MOVED TO modules/selection.js
// Use SELECT.getSelectedNodes(), SELECT.set(), SELECT.toggle(), SELECT.clear(), SELECT.maybeClear()
// Shims in selection.js provide global function names for backward compatibility


function handleNodeHover(node, data) {
    const filePanel = document.getElementById('file-panel');
    HOVERED_NODE = node || null;

    // Always update hover panel (separate from file panel)
    updateHoverPanel(node);

    // Guard: file-panel may not exist in minimal template
    if (!filePanel) return;

    if (!VIS_FILTERS.metadata.showFilePanel) {
        filePanel.classList.remove('visible');
        return;
    }

    if (!node) {
        // Mouse left node - hide panel after delay
        setTimeout(() => {
            if (!fileMode) filePanel.classList.remove('visible');
        }, 300);
        return;
    }

    // Get file info from boundaries
    const boundaries = data.file_boundaries || [];
    const fileIdx = node.fileIdx;

    if (fileIdx < 0 || fileIdx >= boundaries.length) {
        return;
    }

    const fileInfo = boundaries[fileIdx];

    // Update panel content (with null checks for minimal template)
    const setEl = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.textContent = val;
    };
    setEl('file-name', fileInfo.file_name || 'unknown');
    setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
    setEl('file-purpose', fileInfo.purpose || '--');
    setEl('file-atom-count', fileInfo.atom_count || 0);
    setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
    setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
    setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

    // Show code preview from node body
    const code = node.body || '// no source available';
    setEl('file-code', code);

    // Show panel and trigger smart placement
    filePanel.classList.add('visible');
    HudLayoutManager.reflow();
}

function handleNodeClick(node, event) {
    if (!node) return;
    const additive = event && event.shiftKey;
    if (additive) {
        toggleSelection(node);
        return;
    }
    if (node.id) {
        setSelection([node.id]);
    }
    if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
        toggleFileExpand(node.fileIdx);
    }
}


// ====================================================================
// FILE MODE HANDLERS
// ====================================================================

// setFileModeState - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setEnabled)

const btnFiles = document.getElementById('btn-files');
if (btnFiles) btnFiles.onclick = () => setFileModeState(!fileMode);

// COLOR mode - atoms colored by file
const btnFileColor = document.getElementById('btn-file-color');
if (btnFileColor) btnFileColor.onclick = () => setFileVizMode('color');

// HULLS mode - draw boundary spheres
const btnFileHulls = document.getElementById('btn-file-hulls');
if (btnFileHulls) btnFileHulls.onclick = () => setFileVizMode('hulls');

// CLUSTER mode - force clustering by file
const btnFileCluster = document.getElementById('btn-file-cluster');
if (btnFileCluster) btnFileCluster.onclick = () => setFileVizMode('cluster');

// MAP mode - show file nodes
const btnFileMap = document.getElementById('btn-file-map');
if (btnFileMap) btnFileMap.onclick = () => setFileVizMode('map');

// SPHERES mode - show containment spheres (button may be hidden)
const spheresBtn = document.getElementById('btn-file-spheres');
if (spheresBtn) spheresBtn.onclick = () => setFileVizMode('spheres');

// POP button - toggle boundary pop/restore (button may be hidden)
const popBtn = document.getElementById('btn-file-pop');
if (popBtn) {
    popBtn.onclick = () => {
        if (!FILE_CONTAINMENT.boundariesPopped) {
            popBoundaries(3000);
            popBtn.classList.add('active');
            popBtn.textContent = 'RESTORE';
            showToast('Boundaries popped! Particles in slow-motion chaos...');
        } else {
            restoreBoundaries(2000);
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
            showToast('Boundaries restored. Order from chaos.');
        }
    };
}

// Expand mode toggles (only relevant in MAP mode)
const btnExpandInline = document.getElementById('btn-expand-inline');
if (btnExpandInline) {
    btnExpandInline.onclick = () => {
        FILE_EXPAND_MODE = 'inline';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}

const btnExpandDetach = document.getElementById('btn-expand-detach');
if (btnExpandDetach) {
    btnExpandDetach.onclick = () => {
        FILE_EXPAND_MODE = 'detach';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}


// setFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setMode)

// applyFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.apply)

// scheduleHullRedraw - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.scheduleHullRedraw)

// applyFileColors - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.applyColors)

// clearFileBoundaries - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearBoundaries)

// Moved here to avoid temporal dead zone issue
let fileCohesionActive = false;

// clearAllFileModes - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearAllModes)

// applyClusterForce, applyFileCohesion, clearFileCohesion - MOVED TO modules/file-viz.js

// ════════════════════════════════════════════════════════════════════════
// SURFACE PARITY HANDLERS - Architectural Enforcements
// ════════════════════════════════════════════════════════════════════════

// Panel Handlers - use togglePanel('view') etc. or PANELS.toggle('view')
// togglePanelView/Filter/Style/Settings - simplified via modules/panels.js


// Action Handlers
function handleCmdFlow() { toggleFlowMode(); }
function handleCmd3d() { toggleDimensions(); }

// PanelManager - provided by panels.js module (window.PANEL_DRAG, window.PanelManager)

// =================================================================
// THEME SWITCHING - MOVED TO modules/theme.js
// setTheme, getTheme, getAvailableThemes, cycleTheme, initTheme

// Initialize theme on DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        // Small delay to ensure CSS vars are loaded
        setTimeout(initTheme, 50);
    });
} else {
    setTimeout(initTheme, 50);
}

// Expose theme functions globally
window.setTheme = setTheme;
window.getTheme = getTheme;
window.getAvailableThemes = getAvailableThemes;
window.cycleTheme = cycleTheme;
window.THEME_CONFIG = THEME_CONFIG;

// Expose filtering/graph globals for module access
window.VIS_FILTERS = VIS_FILTERS;
window.refreshGraph = refreshGraph;

    </script>
</body>

</html>