{
  "timestamp": "20260121_145234",
  "domain": "pipeline",
  "execution_id": "pipeline-20260121_145234",
  "generation": 1,
  "parent_execution_id": null,
  "analysis_type": "primary",
  "source": {
    "type": "repository",
    "location": "/Users/lech/PROJECTS_all/PROJECT_elements"
  },
  "results": [
    {
      "hypothesis": {
        "concept": "Stage",
        "claim": "Hypothesis: The concept 'Stage' is implemented according to strict invariants.",
        "description": "A processing unit in the analysis pipeline.",
        "invariants": [
          "Must inherit from a base Stage class (e.g., BaseStage)",
          "Must implement an 'execute' or 'run' method",
          "Should be stateless (no instance variables modified during run)",
          "Must return a standard result format (ProcessingResult/AnalysisResult)"
        ],
        "anchors": [
          {
            "file": "standard-model-of-code/src/core/*_stage.py",
            "pattern": "class *Stage"
          },
          {
            "file": "standard-model-of-code/src/core/full_analysis.py",
            "pattern": "class FullAnalysisPipeline"
          }
        ],
        "scope": "standard-model-of-code/src/core/**"
      },
      "result": {
        "verified": true,
        "candidates": [
          "/Users/lech/PROJECTS_all/PROJECT_elements/standard-model-of-code/src/core/full_analysis.py"
        ],
        "analysis": "### Findings\n- **Entity**: `compute_markov_matrix`\n- **Status**: Non-Compliant\n- **Evidence**: The entity is a standalone function, not a class. It modifies one of its inputs (`edges`) in place, violating the statelessness principle.\n    ```python\n    def compute_markov_matrix(nodes: List[Dict], edges: List[Dict]) -> Dict:\n        # ...\n        for edge in edges:\n            source = edge.get('source', '')\n            target = edge.get('target', '')\n            if source in transitions and target in transitions[source]:\n                edge['markov_weight'] = transitions[source][target] # Modifies input\n    ```\n- **Deviation**: The entity does not inherit from a `BaseStage` class. While it is called like a processing unit, its implementation as a function that mutates its arguments violates the 'stateless' invariant, which is critical for predictable pipeline behavior.\n\n---\n- **Entity**: `detect_knots`\n- **Status**: Non-Compliant\n- **Evidence**: The entity is a standalone function, not a class.\n    ```python\n    def detect_knots(nodes: List[Dict], edges: List[Dict]) -> Dict:\n        \"\"\"\n        Detect dependency knots (cycles) and tangles in the graph.\n        ...\n        \"\"\"\n    ```\n- **Deviation**: The entity does not inherit from a `BaseStage` class as required. Although it behaves like a stateless processing unit and returns a structured dictionary, it fails to meet the structural requirement of being an instantiable Stage class.\n\n---\n- **Entity**: `compute_data_flow`\n- **Status**: Non-Compliant\n- **Evidence**: The entity is a standalone function, not a class.\n    ```python\n    def compute_data_flow(nodes: List[Dict], edges: List[Dict]) -> Dict:\n        \"\"\"\n        Analyze data flow patterns across the codebase.\n        \"\"\"\n    ```\n- **Deviation**: The entity does not inherit from a `BaseStage` class. It correctly functions as a stateless processing unit but does not adhere to the required object-oriented structure defined by the `Stage` concept.\n\n---\n- **Entity**: `create_codome_boundaries`\n- **Status**: Non-Compliant\n- **Evidence**: The entity is a standalone function, not a class.\n    ```python\n    def create_codome_boundaries(nodes: List[Dict], edges: List[Dict]) -> Dict[str, Any]:\n        \"\"\"\n        Create synthetic codome boundary nodes and inferred edges.\n        ...\n        \"\"\"\n    ```\n- **Deviation**: The entity does not inherit from a `BaseStage` class. While it serves as a distinct processing step in the analysis pipeline, it is implemented procedurally rather than adhering to the class-based structure required by the invariants.\n\n---\n- **Entity**: Inline Graph Analytics (Stage 6.5)\n- **Status**: Non-Compliant\n- **Evidence**: The logic for \"Stage 6.5: Graph Analytics\" is implemented as a large, inline block of code within the `run_full_analysis` function, rather than being encapsulated in a separate class or even a function.\n    ```python\n    # Stage 6.5: Graph Analytics (Nerd Layer)\n    print(\"\\n\ud83e\uddee Stage 6.5: Graph Analytics...\")\n    with StageTimer(perf_manager, \"Stage 6.5: Graph Analytics\") as timer:\n        # Degree computation (always runs - needed for Control Bar mappings)\n        try:\n            import networkx as nx\n            # ... extensive logic follows ...\n    ```\n- **Deviation**: This is a significant deviation. The processing logic is not encapsulated in any reusable unit, violating all invariants. It is not a class, has no `run`/`execute` method, and is tightly coupled to the orchestrator function. It represents a \"stage\" in concept only, not in structure.",
        "guardrails": {
          "compliant": false,
          "violations": [
            {
              "law_id": "AM004",
              "severity": "HIGH",
              "reasoning": "The primary execution function `run_full_analysis` is an incomplete stub that fails to call any of the major analysis functions defined within the same file. As a result, critical functions like `classify_disconnection`, `create_codome_boundaries`, `build_file_index`, `compute_markov_matrix`, `detect_knots`, `compute_data_flow`, and `_generate_ai_insights` are orphaned. The file defines a complex analysis pipeline but provides no mechanism to execute it, rendering over 80% of the code inert and disconnected from its intended entry point."
            },
            {
              "law_id": "AM002",
              "severity": "HIGH",
              "reasoning": "The code violates its designated 'Stage' role, which implies a stateless, deterministic transformation. The implementation includes numerous side effects, such as filesystem manipulation (`_resolve_output_dir`), modifying global interpreter state (`sys.path.insert`), and launching external processes with network access (`_generate_ai_insights`). These actions are characteristic of an Orchestrator or CLI Handler, not a pure processing Stage, representing significant architectural drift."
            },
            {
              "law_id": "AM001",
              "severity": "MEDIUM",
              "reasoning": "The module exhibits context myopia by manipulating `sys.path` with `sys.path.insert(0, ...)` to resolve a local import. This is a fragile anti-pattern that ignores standard Python packaging and module resolution, creating a tight dependency on the file's location within the filesystem. This approach makes the code less portable and harder to maintain."
            }
          ],
          "critique_summary": "The code fails its audit due to being largely orphaned and architecturally drifted; its main function is an empty shell, leaving critical analysis logic disconnected, while its design incorporates side effects that violate its designated 'Stage' role."
        }
      }
    },
    {
      "hypothesis": {
        "concept": "Extractor",
        "claim": "Hypothesis: The concept 'Extractor' is implemented according to strict invariants.",
        "description": "Component responsible for raw data ingestion.",
        "invariants": [
          "Must operate on raw file content or AST",
          "Must not perform complex semantic reasoning (role of Classifier)"
        ],
        "anchors": [
          {
            "file": "standard-model-of-code/src/core/*_extractor*.py",
            "pattern": "class *Extractor"
          }
        ],
        "scope": "standard-model-of-code/src/core/**"
      },
      "result": {
        "verified": true,
        "candidates": [
          "/Users/lech/PROJECTS_all/PROJECT_elements/standard-model-of-code/src/core/edge_extractor.py",
          "/Users/lech/PROJECTS_all/PROJECT_elements/standard-model-of-code/src/core/smart_extractor.py"
        ],
        "analysis": "### Findings\n- **Entity**: `EdgeExtractionStrategy` (and its concrete subclasses: `PythonEdgeStrategy`, `JavascriptEdgeStrategy`, `PythonTreeSitterStrategy`, etc.)\n- **Status**: Compliant\n- **Evidence**: The responsibility of these strategy classes is to extract potential relationships from a single particle's `body_source`. They operate either on the raw string content using regular expressions (e.g., `PythonEdgeStrategy`) or by parsing the body into a local AST and querying it (e.g., `PythonTreeSitterStrategy`). For example, `PythonEdgeStrategy` uses `re.findall(r'(?:self\\.)?(\\w+)\\s*\\(', body)` to find call-like patterns. This fits the definition of operating on raw file content or AST. The logic within is confined to identifying syntactic constructs, not interpreting their cross-module meaning.\n- **Deviation**: None.\n\n---\n- **Entity**: `JSModuleResolver`\n- **Status**: Non-Compliant\n- **Evidence**: This class is designed to resolve JavaScript module references across files. It analyzes file content to build up a stateful model of `window_exports` and `import_aliases`. The method `resolve_member_call` then uses this cross-file knowledge to link a call site (e.g., `COLOR.subscribe()`) to a particle in a different file.\n- **Deviation**: This functionality constitutes \"complex semantic reasoning\". Instead of simply ingesting raw data (finding the text `COLOR.subscribe`), it interprets the semantics of JavaScript's module system to resolve the meaning of the `COLOR` identifier in a global context. This requires building a cross-file symbol table, a task that goes beyond raw data ingestion and into semantic analysis, which is explicitly designated as the role of other components (like a `Classifier` or a dedicated `Resolver`).\n\n---\n- **Entity**: `extract_call_edges`\n- **Status**: Non-Compliant\n- **Evidence**: This function serves as the main orchestrator. It is responsible for initializing and populating the `JSModuleResolver`: `reset_js_module_resolver()`, `resolver = get_js_module_resolver()`, `resolver.analyze_file(file_path, content)`. The results of this analysis are then used by the `JavaScriptTreeSitterStrategy` to perform cross-file call resolution.\n- **Deviation**: By orchestrating the `JSModuleResolver` and incorporating its results into the edge extraction process, this function violates the invariant against performing complex semantic reasoning. It is not merely extracting raw relationships but is actively resolving them using a semantic model of the codebase's module structure, which is outside the scope of a simple \"Extractor\".",
        "guardrails": {
          "compliant": false,
          "violations": [
            {
              "law_id": "AM004",
              "severity": "LOW",
              "reasoning": "The code defines a constant `STDLIB_MODULES` (line 321) and a function `_collect_file_node_ids` (line 428) which are never used or referenced within the provided file. This constitutes orphan code that adds clutter and potential confusion for future maintenance without providing any current functionality."
            }
          ],
          "critique_summary": "The extractor is architecturally sound, leveraging a strategy pattern and correctly handling optional dependencies, but it contains orphan code elements that should be removed or integrated."
        }
      }
    }
  ]
}