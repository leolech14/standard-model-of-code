{
  "timestamp": "20260121_063639",
  "domain": "pipeline",
  "execution_id": "pipeline-20260121_063639",
  "generation": 1,
  "parent_execution_id": null,
  "analysis_type": "primary",
  "source": {
    "type": "repository",
    "location": "/Users/lech/PROJECTS_all/PROJECT_elements"
  },
  "results": [
    {
      "hypothesis": {
        "concept": "Stage",
        "claim": "Hypothesis: The concept 'Stage' is implemented according to strict invariants.",
        "description": "A processing unit in the analysis pipeline.",
        "invariants": [
          "Must inherit from a base Stage class (e.g., BaseStage)",
          "Must implement an 'execute' or 'run' method",
          "Should be stateless (no instance variables modified during run)",
          "Must return a standard result format (ProcessingResult/AnalysisResult)"
        ],
        "anchors": [
          {
            "file": "standard-model-of-code/src/core/*_stage.py",
            "pattern": "class *Stage"
          },
          {
            "file": "standard-model-of-code/src/core/full_analysis.py",
            "pattern": "class FullAnalysisPipeline"
          }
        ],
        "scope": "standard-model-of-code/src/core/**"
      },
      "result": {
        "verified": true,
        "candidates": [
          "/Users/lech/PROJECTS_all/PROJECT_elements/standard-model-of-code/src/core/full_analysis.py"
        ],
        "analysis": "### Findings\n\n- **Entity**: `_resolve_output_dir` (function)\n- **Status**: Non-Compliant\n- **Evidence**: This is a utility function, not a Stage.\n- **Deviation**: Does not inherit from a base Stage class, does not implement 'execute' or 'run', is not stateless in the context of a Stage, and does not return a standard result format.\n\n- **Entity**: `_find_latest_html` (function)\n- **Status**: Non-Compliant\n- **Evidence**: This is a utility function, not a Stage.\n- **Deviation**: Does not inherit from a base Stage class, does not implement 'execute' or 'run', is not stateless in the context of a Stage, and does not return a standard result format.\n\n- **Entity**: `_open_file` (function)\n- **Status**: Non-Compliant\n- **Evidence**: This is a utility function, not a Stage.\n- **Deviation**: Does not inherit from a base Stage class, does not implement 'execute' or 'run', is not stateless in the context of a Stage, and does not return a standard result format.\n\n- **Entity**: `_manual_open_command` (function)\n- **Status**: Non-Compliant\n- **Evidence**: This is a utility function, not a Stage.\n- **Deviation**: Does not inherit from a base Stage class, does not implement 'execute' or 'run', is not stateless in the context of a Stage, and does not return a standard result format.\n\n- **Entity**: `build_file_index` (function)\n- **Status**: Non-Compliant\n- **Evidence**: This is a utility function, not a Stage.\n- **Deviation**: Does not inherit from a base Stage class, does not implement 'execute' or 'run', is not stateless in the context of a Stage, and does not return a standard result format.\n\n- **Entity**: `build_file_boundaries` (function)\n- **Status**: Non-Compliant\n- **Evidence**: This is a utility function, not a Stage.\n- **Deviation**: Does not inherit from a base Stage class, does not implement 'execute' or 'run', is not stateless in the context of a Stage, and does not return a standard result format.\n\n- **Entity**: `_calculate_theory_completeness` (function)\n- **Status**: Non-Compliant\n- **Evidence**: This is a utility function, not a Stage.\n- **Deviation**: Does not inherit from a base Stage class, does not implement 'execute' or 'run', is not stateless in the context of a Stage, and does not return a standard result format.\n\n- **Entity**: `compute_markov_matrix` (function)\n- **Status**: Non-Compliant\n- **Evidence**: This is a utility function, not a Stage.\n- **Deviation**: Does not inherit from a base Stage class, does not implement 'execute' or 'run', is not stateless in the context of a Stage, and does not return a standard result format.\n\n- **Entity**: `detect_knots` (function)\n- **Status**: Non-Compliant\n- **Evidence**: This is a utility function, not a Stage.\n- **Deviation**: Does not inherit from a base Stage class, does not implement 'execute' or 'run', is not stateless in the context of a Stage, and does not return a standard result format.\n\n- **Entity**: `compute_data_flow` (function)\n- **Status**: Non-Compliant\n- **Evidence**: This is a utility function, not a Stage.\n- **Deviation**: Does not inherit from a base Stage class, does not implement 'execute' or 'run', is not stateless in the context of a Stage, and does not return a standard result format.\n\n- **Entity**: `_generate_ai_insights` (function)\n- **Status**: Non-Compliant\n- **Evidence**: This is a utility function, not a Stage.\n- **Deviation**: Does not inherit from a base Stage class, does not implement 'execute' or 'run', is not stateless in the context of a Stage, and does not return a standard result format.\n\n- **Entity**: `run_full_analysis` (function)\n- **Status**: Non-Compliant\n- **Evidence**: While this function orchestrates the analysis, it's not a Stage itself. It manages and calls other stages.\n- **Deviation**: Does not inherit from a base Stage class.\n\n",
        "guardrails": {
          "compliant": false,
          "violations": [
            {
              "law_id": "AM001",
              "severity": "LOW",
              "reasoning": "The function `_open_file` attempts to open a file using OS-specific commands. This might be better handled by a cross-platform library if one exists within the project's approved dependencies, reducing platform-specific code."
            },
            {
              "law_id": "AM001",
              "severity": "LOW",
              "reasoning": "The function `_manual_open_command` generates OS-specific open commands. Similar to `_open_file`, a project utility or established cross-platform approach might be preferable."
            },
            {
              "law_id": "AM004",
              "severity": "LOW",
              "reasoning": "Orphan Integration Analysis was REMOVED, indicating that logic that depends on it may be broken or orphaned now."
            }
          ],
          "critique_summary": "The code exhibits minor context myopia due to OS-specific implementations and potentially outdated logic, but is largely compliant with architectural and dependency constraints."
        }
      }
    },
    {
      "hypothesis": {
        "concept": "Extractor",
        "claim": "Hypothesis: The concept 'Extractor' is implemented according to strict invariants.",
        "description": "Component responsible for raw data ingestion.",
        "invariants": [
          "Must operate on raw file content or AST",
          "Must not perform complex semantic reasoning (role of Classifier)"
        ],
        "anchors": [
          {
            "file": "standard-model-of-code/src/core/*_extractor*.py",
            "pattern": "class *Extractor"
          }
        ],
        "scope": "standard-model-of-code/src/core/**"
      },
      "result": {
        "verified": true,
        "candidates": [
          "/Users/lech/PROJECTS_all/PROJECT_elements/standard-model-of-code/src/core/edge_extractor.py",
          "/Users/lech/PROJECTS_all/PROJECT_elements/standard-model-of-code/src/core/smart_extractor.py"
        ],
        "analysis": "### Findings\n\n- **Entity**: `EdgeExtractionStrategy`\n- **Status**: Compliant\n- **Evidence**: This is an abstract base class for language-specific edge extraction from source bodies. The `extract_edges` method operates on a particle (representing a code element) and a dictionary mapping names to particles. It does not perform semantic reasoning, but rather extracts edges based on the content of the particle's body.\n- **Deviation**: N/A\n\n- **Entity**: `PythonEdgeStrategy`\n- **Status**: Compliant\n- **Evidence**: The `PythonEdgeStrategy` extracts edges from Python code using regular expressions. It operates on the `body_source` of a particle, which represents the raw source code of a function or method. The strategy uses regular expressions to identify function calls and attribute accesses, and creates edges based on these patterns. The logic focuses on pattern matching, avoiding complex semantic analysis.\n- **Deviation**: N/A\n\n- **Entity**: `JavascriptEdgeStrategy`\n- **Status**: Compliant\n- **Evidence**: The `JavascriptEdgeStrategy` extracts edges from JavaScript code using regular expressions. It examines the function bodies and extracts function calls. This approach relies on pattern matching rather than deep semantic understanding.\n- **Deviation**: N/A\n\n- **Entity**: `TypeScriptEdgeStrategy`\n- **Status**: Compliant\n- **Evidence**: The `TypeScriptEdgeStrategy` inherits from `JavascriptEdgeStrategy`. It performs edge extraction using regex on the `body_source`.\n- **Deviation**: N/A\n\n- **Entity**: `GoEdgeStrategy`\n- **Status**: Compliant\n- **Evidence**: The `GoEdgeStrategy` extracts edges from Go code using regular expressions.  It focuses on identifying function calls within the function bodies.\n- **Deviation**: N/A\n\n- **Entity**: `RustEdgeStrategy`\n- **Status**: Compliant\n- **Evidence**: The `RustEdgeStrategy` extracts edges from Rust code using regular expressions. It focuses on identifying function calls within the function bodies.\n- **Deviation**: N/A\n\n- **Entity**: `DefaultEdgeStrategy`\n- **Status**: Compliant\n- **Evidence**: The `DefaultEdgeStrategy` serves as a fallback. It does not perform any edge extraction, thereby avoiding any complex reasoning.\n- **Deviation**: N/A\n\n- **Entity**: `TreeSitterEdgeStrategy`\n- **Status**: Compliant\n- **Evidence**: The `TreeSitterEdgeStrategy` extracts function calls based on the Abstract Syntax Tree (AST) of the code. While it uses the AST for more precise identification of function calls, it does not perform any complex semantic analysis. The strategy extracts the callee name from the AST nodes and creates edges. It operates on raw AST.\n- **Deviation**: N/A\n\n- **Entity**: `PythonTreeSitterStrategy`\n- **Status**: Compliant\n- **Evidence**: The `PythonTreeSitterStrategy` inherits from `TreeSitterEdgeStrategy` and provides a Python-specific implementation. It uses Tree-sitter to parse the Python code and extract function calls based on the AST.\n- **Deviation**: N/A\n\n- **Entity**: `JavaScriptTreeSitterStrategy`\n- **Status**: Compliant\n- **Evidence**: The `JavaScriptTreeSitterStrategy` inherits from `TreeSitterEdgeStrategy` and provides a Javascript-specific implementation. It uses Tree-sitter to parse the JavaScript code and extract function calls based on the AST.\n- **Deviation**: N/A\n\n- **Entity**: `TypeScriptTreeSitterStrategy`\n- **Status**: Compliant\n- **Evidence**: The `TypeScriptTreeSitterStrategy` inherits from `TreeSitterEdgeStrategy` and provides a Typescript-specific implementation. It uses Tree-sitter to parse the TypeScript code and extract function calls based on the AST.\n- **Deviation**: N/A\n\n- **Entity**: `extract_call_edges`\n- **Status**: Compliant\n- **Evidence**: This function orchestrates the edge extraction process. It uses `get_strategy_for_file` to select the appropriate extraction strategy based on the file extension. The selected strategy's `extract_edges` method is then called to extract edges from the particle's `body_source`. It mainly operates on raw imports and particle bodies, leveraging specific strategies for each language.\n- **Deviation**: N/A\n",
        "guardrails": {
          "compliant": true,
          "violations": [],
          "critique_summary": "The code appears to adhere to the specified constraints and does not exhibit any obvious antimatter violations."
        }
      }
    }
  ]
}