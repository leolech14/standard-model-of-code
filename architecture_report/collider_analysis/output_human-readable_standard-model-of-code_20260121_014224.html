<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Collider v4.0.0</title>
    <style>
        /* ═══════════════════════════════════════════════════════════════════
           COLLIDER UI - Dual Sidebar Layout
           ═══════════════════════════════════════════════════════════════════ */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --surface: rgba(15, 15, 22, 0.85);
            --surface-hover: rgba(25, 25, 35, 0.9);
            --border: rgba(255, 255, 255, 0.08);
            --border-accent: rgba(74, 158, 255, 0.3);
            --text: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.5);
            --text-muted: rgba(255, 255, 255, 0.3);
            --accent: #4a9eff;
            --accent-dim: rgba(74, 158, 255, 0.15);
            --accent-glow: rgba(74, 158, 255, 0.25);
            --green: #5a9a70;
            --yellow: #a09060;
            --red: #b07070;
            --cyan: #7090a0;
            --sidebar-width: 300px;
            --right-panel-width: 280px;
            --min-sidebar-width: 240px;
            --max-sidebar-width: 500px;
            --header-height: 48px;
            --radius: 8px;
            --radius-sm: 4px;
            --glass: blur(12px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            font-size: 12px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LOADER
           ═══════════════════════════════════════════════════════════════════ */
        #loader {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 9999;
            font-size: 14px;
            letter-spacing: 2px;
        }

        #loader-status {
            font-size: 11px;
            opacity: 0.5;
        }

        /* ═══════════════════════════════════════════════════════════════════
           HEADER - Top bar spanning full width
           ═══════════════════════════════════════════════════════════════════ */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 24px;
            z-index: 200;
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 1px;
            color: var(--accent);
        }

        .logo span {
            opacity: 0.5;
            font-size: 10px;
            margin-left: 6px;
            color: var(--text);
        }

        .header-stats {
            display: flex;
            gap: 20px;
            font-size: 11px;
        }

        .stat {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .stat-label {
            opacity: 0.4;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            color: var(--cyan);
        }

        .target-name {
            margin-left: auto;
            font-size: 11px;
            opacity: 0.5;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ═══════════════════════════════════════════════════════════════════
           MAIN LAYOUT - Graph container
           ═══════════════════════════════════════════════════════════════════ */
        #3d-graph {
            position: fixed;
            top: var(--header-height);
            left: var(--sidebar-width);
            right: var(--right-panel-width);
            bottom: 0;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LEFT SIDEBAR - Controls & Filters
           ═══════════════════════════════════════════════════════════════════ */
        #left-sidebar {
            position: fixed;
            top: var(--header-height);
            left: 0;
            bottom: 0;
            width: var(--sidebar-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
        }

        #left-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #left-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #left-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           RIGHT SIDEBAR - Info Panels
           ═══════════════════════════════════════════════════════════════════ */
        #right-sidebar {
            position: fixed;
            top: var(--header-height);
            right: 0;
            bottom: 0;
            width: var(--right-panel-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #right-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #right-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #right-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SIDEBAR RESIZE DIVIDERS - Horizontal drag handles
           ═══════════════════════════════════════════════════════════════════ */
        .sidebar-resize-handle {
            position: fixed;
            top: var(--header-height);
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 101;
            background: transparent;
            transition: background 0.15s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.25);
        }

        .sidebar-resize-handle.left {
            left: calc(var(--sidebar-width) - 3px);
        }

        .sidebar-resize-handle.right {
            right: calc(var(--right-panel-width) - 3px);
        }

        /* Visual indicator line */
        .sidebar-resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 40px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .sidebar-resize-handle:hover::after {
            opacity: 1;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION - Collapsible sections
           ═══════════════════════════════════════════════════════════════════ */
        .section {
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            padding: 12px 14px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.15s;
        }

        .section-header:hover {
            opacity: 0.9;
            background: var(--surface-hover);
        }

        .section-header .arrow {
            transition: transform 0.2s;
            font-size: 8px;
        }

        .section-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        /* PRIME SECTIONS - Highlighted config sections (muted) */
        .section.prime {
            background: linear-gradient(180deg, rgba(100, 110, 130, 0.03) 0%, transparent 100%);
            border-left: 2px solid rgba(100, 110, 130, 0.3);
        }

        .section.prime .section-header {
            opacity: 0.75;
            color: var(--text-secondary);
        }

        .section.prime .section-header:hover {
            opacity: 0.9;
        }

        .section-content {
            padding: 8px 14px 14px;
            overflow-y: auto;
            transition: max-height 0.2s ease;
        }

        .section-content.collapsed {
            display: none;
        }

        /* RESIZABLE SECTIONS - Vertical drag handles */
        .section-resize-handle {
            height: 4px;
            cursor: ns-resize;
            background: transparent;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
            position: relative;
        }

        .section-resize-handle:hover,
        .section-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.2);
        }

        .section-resize-handle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 2px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .section-resize-handle:hover::after {
            opacity: 1;
        }

        /* Section content height constraints when resizing */
        .section-content.resizable {
            min-height: 60px;
            max-height: 400px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           VIEW MODE TOGGLE - ATOMS vs FILES (top of left sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            padding: 8px 10px;
            background: linear-gradient(180deg, rgba(74, 158, 255, 0.08) 0%, rgba(74, 158, 255, 0.02) 100%);
            border-bottom: 2px solid var(--accent);
        }

        .view-mode-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .view-mode-btn:first-child {
            border-radius: var(--radius-sm) 0 0 var(--radius-sm);
            border-right: none;
        }

        .view-mode-btn:last-child {
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        }

        .view-mode-btn:hover {
            background: rgba(74, 158, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        .view-mode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
        }

        .view-mode-icon {
            font-size: 14px;
        }

        .view-mode-label {
            font-size: 10px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════════════
           BUTTON GRID - For presets and actions
           ═══════════════════════════════════════════════════════════════════ */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .btn-grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .btn-grid-4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .btn-grid-6 {
            grid-template-columns: repeat(6, 1fr);
        }

        .btn {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            font-size: 9px;
            font-weight: 500;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: var(--border-accent);
        }

        .btn.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        /* Icon buttons */
        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SLIDERS
           ═══════════════════════════════════════════════════════════════════ */
        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .slider-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .slider-label {
            opacity: 0.6;
        }

        .slider-value {
            display: none;
            /* Replaced by input */
        }

        .number-input {
            width: 48px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--cyan);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 10px;
            padding: 2px 4px;
            text-align: right;
            -moz-appearance: textfield;
        }

        .number-input::-webkit-outer-spin-button,
        .number-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.4);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px var(--accent-glow);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }

        /* ═══════════════════════════════════════════════════════════════════
           FILTER CHIPS
           ═══════════════════════════════════════════════════════════════════ */
        .filter-group {
            margin-bottom: 12px;
        }

        .filter-group:last-child {
            margin-bottom: 0;
        }

        .filter-label {
            font-size: 9px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .chip {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 14px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .chip.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
        }

        .chip .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOGGLE SWITCHES
           ═══════════════════════════════════════════════════════════════════ */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            padding: 6px 0;
        }

        .toggle-row .toggle-label {
            opacity: 0.7;
        }

        .toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text);
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle.active::after {
            transform: translateX(16px);
        }

        /* ═══════════════════════════════════════════════════════════════════
           INFO PANEL - Right sidebar node info
           ═══════════════════════════════════════════════════════════════════ */
        .info-panel {
            padding: 14px;
            border-bottom: 1px solid var(--border);
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .info-panel-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .node-info {
            display: none;
        }

        .node-info.visible {
            display: block;
        }

        .node-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
            word-break: break-all;
            color: var(--cyan);
        }

        .node-kind {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row .label {
            opacity: 0.4;
        }

        .info-row .value {
            text-align: right;
        }

        .node-file {
            font-size: 9px;
            opacity: 0.3;
            margin-top: 10px;
            word-break: break-all;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .placeholder-text {
            font-size: 10px;
            opacity: 0.3;
            text-align: center;
            padding: 20px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SELECTION PANEL
           ═══════════════════════════════════════════════════════════════════ */
        .selection-panel {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
        }

        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .selection-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .selection-count {
            font-size: 9px;
            padding: 2px 8px;
            background: var(--accent-dim);
            border-radius: 10px;
            color: var(--accent);
        }

        .selection-clear {
            font-size: 9px;
            padding: 4px 8px;
            background: none;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            cursor: pointer;
        }

        .selection-clear:hover {
            color: var(--text);
            border-color: var(--text-dim);
        }

        .selection-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .selection-item {
            font-size: 10px;
            padding: 6px 8px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            margin-bottom: 2px;
            background: rgba(255, 255, 255, 0.02);
        }

        .selection-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--accent);
        }

        /* ═══════════════════════════════════════════════════════════════════
           STATS PANEL (bottom of right sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .stats-panel {
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid var(--border);
            margin-top: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stats-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-sm);
        }

        .stats-item .value {
            font-size: 16px;
            font-weight: 600;
            color: var(--cyan);
            font-variant-numeric: tabular-nums;
        }

        .stats-item .label {
            font-size: 8px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           COLOR PANELS (right sidebar color controls)
           ═══════════════════════════════════════════════════════════════════ */
        .color-panel,
        .schemes-panel {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
        }

        .color-panel .section-content,
        .schemes-panel .section-content {
            padding: 0;
            margin-top: 10px;
        }

        .color-panel .btn-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .color-panel .btn {
            padding: 6px 8px;
            font-size: 9px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .color-panel .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .color-panel .btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        /* Collapsible header for schemes panel */
        .info-panel-header.collapsible {
            cursor: pointer;
            user-select: none;
        }

        .info-panel-header.collapsible:hover {
            opacity: 0.9;
        }

        .info-panel-header .collapse-icon {
            font-size: 8px;
            transition: transform 0.2s;
        }

        .info-panel-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .schemes-panel .section-content {
            max-height: 250px;
            overflow-y: auto;
        }

        .schemes-panel .section-content::-webkit-scrollbar {
            width: 4px;
        }

        .schemes-panel .section-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .schemes-panel .section-content.collapsed {
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           PERFORMANCE HUD (optional overlay)
           ═══════════════════════════════════════════════════════════════════ */
        #perf-hud {
            position: fixed;
            top: calc(var(--header-height) + 8px);
            left: calc(var(--sidebar-width) + 8px);
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-family: 'SF Mono', Monaco, monospace;
            z-index: 150;
            display: none;
        }

        #perf-hud.visible {
            display: block;
        }

        .perf-row {
            display: flex;
            gap: 12px;
        }

        .perf-label {
            opacity: 0.5;
        }

        .perf-value {
            font-variant-numeric: tabular-nums;
        }

        .perf-good {
            color: var(--green);
        }

        .perf-warn {
            color: var(--yellow);
        }

        .perf-bad {
            color: var(--red);
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════════════ */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--surface);
            border: 1px solid var(--border-accent);
            padding: 12px 24px;
            border-radius: var(--radius);
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Selection box for drag select */
        #selection-box {
            position: fixed;
            border: 1px solid var(--accent);
            background: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION-SPECIFIC STYLING
           ═══════════════════════════════════════════════════════════════════ */

        /* Color mode buttons with color indicators */
        .color-btn {
            position: relative;
        }

        .color-btn::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .color-btn[data-preset="tier"]::before {
            background: #ff6b6b;
        }

        .color-btn[data-preset="family"]::before {
            background: #4ecdc4;
        }

        .color-btn[data-preset="layer"]::before {
            background: #95e1d3;
        }

        .color-btn[data-preset="ring"]::before {
            background: #f9ed69;
        }

        .color-btn[data-preset="file"]::before {
            background: #a8e6cf;
        }

        .color-btn[data-preset="flow"]::before {
            background: #dcd6f7;
        }

        /* Layout buttons with mini icons */
        .layout-btn {
            height: 32px;
        }
    </style>

    <script>
        window.process = window.process || { env: { NODE_ENV: "production" } };
        window.global = window.global || window;
    </script>
    <!-- THREE.js r149 (last version without deprecation warning) + 3d-force-graph -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
</head>

<body>
    <!-- Loader -->
    <div id="loader">
        <div>INITIALIZING...</div>
        <div id="loader-status">Loading data...</div>
    </div>

    <!-- Header -->
    <div id="header">
        <div class="logo">COLLIDER <span>v4.0.0</span></div>
        <div class="header-stats">
            <div class="stat">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="stat-nodes">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="stat-edges">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Entropy</span>
                <span class="stat-value" id="stat-entropy">--</span>
            </div>
        </div>
        <div class="target-name" id="target-name"></div>
    </div>

    <!-- Left Sidebar -->
    <div id="left-sidebar">
        <!-- VIEW MODE TOGGLE - TOP PRIORITY -->
        <div class="view-mode-toggle" id="view-mode-toggle">
            <button class="view-mode-btn active" data-mode="atoms">
                <span class="view-mode-icon">◉</span>
                <span class="view-mode-label">ATOMS</span>
            </button>
            <button class="view-mode-btn" data-mode="files">
                <span class="view-mode-icon">◫</span>
                <span class="view-mode-label">FILES</span>
            </button>
        </div>

        <!-- MAPPING CONTROL (Docked) -->
        <div class="section prime" id="control-bar-container">
            <!-- Injected by control-bar.js -->
        </div>

        <!-- NODE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="node-config">
                <span>⬢ Node Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-node-config">
                <!-- Size Mode Selector -->
                <div class="filter-group">
                    <div class="filter-label">Size Mode</div>
                    <div class="btn-grid btn-grid-4">
                        <button class="btn active" data-size-mode="uniform">Uniform</button>
                        <button class="btn" data-size-mode="degree">Degree</button>
                        <button class="btn" data-size-mode="fanout">Fanout</button>
                        <button class="btn" data-size-mode="complexity">Complex</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Base Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-size" min="0.2" max="4" step="0.1" value="1">
                        <input type="number" id="cfg-node-size-num" class="number-input" min="0.2" max="4" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-opacity" min="0.1" max="1" step="0.05" value="1">
                        <input type="number" id="cfg-node-opacity-num" class="number-input" min="0.1" max="1"
                            step="0.05" value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Resolution</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-res" min="4" max="32" step="4" value="8">
                        <input type="number" id="cfg-node-res-num" class="number-input" min="4" max="32" step="4"
                            value="8">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Label Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-label-size" min="0" max="3" step="0.1" value="1">
                        <input type="number" id="cfg-label-size-num" class="number-input" min="0" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="cfg-toggle-labels"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight Selected</span>
                    <div class="toggle active" id="cfg-toggle-highlight"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Pulse Animation</span>
                    <div class="toggle" id="cfg-toggle-pulse"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">3D Depth Shading</span>
                    <div class="toggle active" id="cfg-toggle-depth"></div>
                </div>
            </div>
        </div>

        <!-- EDGE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="edge-config">
                <span>⟷ Edge Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-edge-config">
                <!-- Edge Style Selector -->
                <div class="filter-group">
                    <div class="filter-label">Edge Style</div>
                    <div class="btn-grid">
                        <button class="btn active" data-edge-style="solid">Solid</button>
                        <button class="btn" data-edge-style="dashed">Dashed</button>
                        <button class="btn" data-edge-style="particle">Particle</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-opacity" min="0" max="1" step="0.05" value="0.6">
                        <input type="number" id="cfg-edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.6">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Width</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-width" min="0.2" max="5" step="0.2" value="1.5">
                        <input type="number" id="cfg-edge-width-num" class="number-input" min="0.2" max="5" step="0.1"
                            value="1.5">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Curvature</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-curve" min="0" max="1" step="0.05" value="0">
                        <input type="number" id="cfg-edge-curve-num" class="number-input" min="0" max="1" step="0.05"
                            value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Speed</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-speed" min="0" max="0.05" step="0.005" value="0.01">
                        <input type="number" id="cfg-particle-speed-num" class="number-input" min="0" max="0.05"
                            step="0.005" value="0.01">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Density</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-count" min="0" max="10" step="1" value="0">
                        <input type="number" id="cfg-particle-count-num" class="number-input" min="0" max="10" step="1"
                            value="0">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Arrows</span>
                    <div class="toggle" id="cfg-toggle-arrows"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Gradient Colors</span>
                    <div class="toggle active" id="cfg-toggle-gradient"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight on Hover</span>
                    <div class="toggle active" id="cfg-toggle-edge-hover"></div>
                </div>
            </div>
        </div>

        <!-- LAYOUT -->
        <div class="section">
            <div class="section-header" data-section="layout">
                <span>Layout</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-layout">
                <div class="btn-grid">
                    <button class="btn layout-btn active" data-layout="force">Force</button>
                    <button class="btn layout-btn" data-layout="radial">Radial</button>
                    <button class="btn layout-btn" data-layout="orbital">Orbital</button>
                    <button class="btn layout-btn" data-layout="sphere">Sphere</button>
                    <button class="btn layout-btn" data-layout="grid">Grid</button>
                    <button class="btn layout-btn" data-layout="spiral">Spiral</button>
                </div>
            </div>
        </div>

        <!-- PHYSICS -->
        <div class="section">
            <div class="section-header" data-section="physics">
                <span>Physics</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-physics">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Repulsion</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-charge" min="-500" max="0" value="-120">
                        <input type="number" id="physics-charge-num" class="number-input" min="-500" max="0"
                            value="-120">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Link Distance</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-link" min="10" max="200" value="50">
                        <input type="number" id="physics-link-num" class="number-input" min="10" max="200" value="50">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Center Pull</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-center" min="0" max="0.5" step="0.01" value="0.05">
                        <input type="number" id="physics-center-num" class="number-input" min="0" max="0.5" step="0.01"
                            value="0.05">
                    </div>
                </div>
                <div class="btn-grid btn-grid-4" style="margin-top: 8px;">
                    <button class="btn" data-physics="default">Def</button>
                    <button class="btn" data-physics="tight">Tight</button>
                    <button class="btn" data-physics="loose">Loose</button>
                    <button class="btn" data-physics="explosive">Boom</button>
                </div>
            </div>
        </div>

        <!-- APPEARANCE -->
        <div class="section">
            <div class="section-header" data-section="appearance">
                <span>Appearance</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-appearance">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Node Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="node-size" min="0.2" max="3" step="0.1" value="1">
                        <input type="number" id="node-size-num" class="number-input" min="0.2" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Edge Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="edge-opacity" min="0" max="1" step="0.05" value="0.4">
                        <input type="number" id="edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.4">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="toggle-labels"></div>
                </div>
                <!-- Starfield toggle REMOVED - nodes ARE the stars -->
            </div>
        </div>

        <!-- FILTERS -->
        <div class="section">
            <div class="section-header" data-section="filters">
                <span>Filters</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-filters">
                <div class="filter-group">
                    <div class="filter-label">Tiers</div>
                    <div class="chips" id="filter-tiers"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Rings</div>
                    <div class="chips" id="filter-rings"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Edge Types</div>
                    <div class="chips" id="filter-edges"></div>
                </div>
            </div>
        </div>

        <!-- ACTIONS -->
        <div class="section">
            <div class="section-header collapsed" data-section="actions">
                <span>Actions</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content collapsed" id="section-actions">
                <div class="btn-grid btn-grid-2">
                    <button class="btn" id="btn-reset">Reset View</button>
                    <button class="btn" id="btn-screenshot">Screenshot</button>
                    <button class="btn" id="btn-2d">Toggle 2D</button>
                    <button class="btn" id="btn-freeze">Freeze</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Graph Container -->
    <div id="3d-graph"></div>

    <!-- Sidebar Resize Handles -->
    <div class="sidebar-resize-handle left" id="left-resize-handle"></div>
    <div class="sidebar-resize-handle right" id="right-resize-handle"></div>

    <!-- Right Sidebar -->
    <div id="right-sidebar">
        <!-- Hover Info Panel -->
        <div class="info-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Node Info</span>
            </div>
            <div class="node-info" id="hover-panel">
                <div class="node-name" id="hover-name">Node Name</div>
                <div class="node-kind" id="hover-kind">function</div>
                <div class="info-row"><span class="label">Atom</span><span class="value" id="hover-atom">--</span></div>
                <div class="info-row"><span class="label">Family</span><span class="value" id="hover-family">--</span>
                </div>
                <div class="info-row"><span class="label">Ring</span><span class="value" id="hover-ring">--</span></div>
                <div class="info-row"><span class="label">Tier</span><span class="value" id="hover-tier">--</span></div>
                <div class="info-row"><span class="label">Role</span><span class="value" id="hover-role">--</span></div>
                <div class="node-file" id="hover-file"></div>
            </div>
            <div class="placeholder-text" id="hover-placeholder">Hover over a node to see details</div>
        </div>

        <!-- Selection Panel -->
        <div class="selection-panel">
            <div class="selection-header">
                <span class="selection-title">Selection</span>
                <span class="selection-count" id="selection-count">0</span>
            </div>
            <div id="selection-actions" style="display: none; margin-bottom: 10px;">
                <button class="selection-clear" id="selection-clear">Clear</button>
            </div>
            <div class="selection-list" id="selection-list">
                <div class="placeholder-text">Click nodes to select</div>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="value" id="stats-nodes">0</div>
                    <div class="label">Visible</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-edges">0</div>
                    <div class="label">Edges</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-files">0</div>
                    <div class="label">Files</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-density">--</div>
                    <div class="label">Density</div>
                </div>
            </div>
        </div>

        <!-- COLOR SCHEMES (33 Named Gradients) - Primary color selection -->
        <div class="info-panel schemes-panel">
            <div class="info-panel-header collapsible" data-target="section-schemes">
                <span class="info-panel-title">Color Schemes</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="section-content" id="section-schemes">
                <!-- Populated dynamically by sidebar.js -->
            </div>
        </div>

        <!-- COLOR MODE (Presets) - What dimension to color by -->
        <div class="info-panel color-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Color Mode</span>
            </div>
            <div class="section-content" id="section-color">
                <div class="btn-grid btn-grid-3">
                    <button class="btn color-btn active" data-preset="tier">Tier</button>
                    <button class="btn color-btn" data-preset="family">Family</button>
                    <button class="btn color-btn" data-preset="layer">Layer</button>
                    <button class="btn color-btn" data-preset="ring">Ring</button>
                    <button class="btn color-btn" data-preset="file">File</button>
                    <button class="btn color-btn" data-preset="flow">Flow</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance HUD -->
    <div id="perf-hud">
        <div class="perf-row">
            <span class="perf-label">FPS:</span>
            <span class="perf-value" id="perf-fps">60</span>
            <span class="perf-label">Frame:</span>
            <span class="perf-value" id="perf-frame">0ms</span>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast"></div>

    <!-- Core Application Injection -->
    <div id="selection-box"></div>
    <script>
        // ═══ MODULE: performance.js ═══
/**
 * COLLIDER PERFORMANCE SUBSYSTEM
 *
 * Provides frame-budget-aware animation scheduling, adaptive quality management,
 * and real-time performance monitoring for the WebGL visualization.
 *
 * Architecture:
 *   PerformanceMonitor  → measures frame times, detects stuttering
 *   AnimationScheduler  → manages animation queue, enforces frame budget
 *   AdaptiveQuality     → degrades/upgrades quality based on performance
 *   PositionOwnership   → enforces single-owner invariant for node positions
 *
 * Usage:
 *   PERF.monitor.start()
 *   PERF.scheduler.requestTransition(nodes, targetPositions, duration)
 *   PERF.quality.current  // 'ultra' | 'high' | 'medium' | 'low' | 'minimal'
 */

const PERF = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION (loaded from performance.tokens.json or defaults)
    // =========================================================================

    const CONFIG = {
        frameBudget: {
            targetFps: 60,
            targetFrameMs: 16.67,
            warningThreshold: 0.8,   // 80% of budget
            criticalThreshold: 1.5   // 150% of budget
        },
        nodeThresholds: {
            small: 100,
            medium: 500,
            large: 1000,
            massive: 5000
        },
        monitoring: {
            sampleWindowMs: 1000,
            sampleCount: 60,
            degradeAfterConsecutiveDrops: 10,
            upgradeAfterConsecutiveGood: 30
        }
    };

    // =========================================================================
    // PERFORMANCE MONITOR
    // Tracks frame times using a rolling window
    // =========================================================================

    const PerformanceMonitor = {
        _frameTimes: [],
        _lastFrameTime: 0,
        _frameCount: 0,
        _droppedFrames: 0,
        _consecutiveDrops: 0,
        _consecutiveGood: 0,
        _isRunning: false,
        _rafId: null,

        start() {
            if (this._isRunning) return;
            this._isRunning = true;
            this._lastFrameTime = performance.now();
            this._tick();
        },

        stop() {
            this._isRunning = false;
            if (this._rafId) {
                cancelAnimationFrame(this._rafId);
                this._rafId = null;
            }
        },

        _tick() {
            if (!this._isRunning) return;

            const now = performance.now();
            const frameTime = now - this._lastFrameTime;
            this._lastFrameTime = now;

            // Record frame time
            this._frameTimes.push(frameTime);
            if (this._frameTimes.length > CONFIG.monitoring.sampleCount) {
                this._frameTimes.shift();
            }

            this._frameCount++;

            // Check for dropped frame
            const budget = CONFIG.frameBudget.targetFrameMs;
            if (frameTime > budget * CONFIG.frameBudget.criticalThreshold) {
                this._droppedFrames++;
                this._consecutiveDrops++;
                this._consecutiveGood = 0;

                // Trigger quality degradation check
                if (this._consecutiveDrops >= CONFIG.monitoring.degradeAfterConsecutiveDrops) {
                    AdaptiveQuality.degrade();
                    this._consecutiveDrops = 0;
                }
            } else if (frameTime < budget * CONFIG.frameBudget.warningThreshold) {
                this._consecutiveGood++;
                this._consecutiveDrops = 0;

                // Trigger quality upgrade check
                if (this._consecutiveGood >= CONFIG.monitoring.upgradeAfterConsecutiveGood) {
                    AdaptiveQuality.upgrade();
                    this._consecutiveGood = 0;
                }
            }

            this._rafId = requestAnimationFrame(() => this._tick());
        },

        get fps() {
            if (this._frameTimes.length < 2) return 0;
            const avg = this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
            return Math.round(1000 / avg);
        },

        get avgFrameTime() {
            if (this._frameTimes.length === 0) return 0;
            return this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
        },

        get lastFrameTime() {
            return this._frameTimes[this._frameTimes.length - 1] || 0;
        },

        get droppedFramePercent() {
            if (this._frameCount === 0) return 0;
            return Math.round((this._droppedFrames / this._frameCount) * 100);
        },

        get stats() {
            return {
                fps: this.fps,
                avgFrameTime: this.avgFrameTime.toFixed(2),
                lastFrameTime: this.lastFrameTime.toFixed(2),
                droppedPercent: this.droppedFramePercent,
                quality: AdaptiveQuality.current,
                owner: PositionOwnership.current
            };
        },

        reset() {
            this._frameTimes = [];
            this._frameCount = 0;
            this._droppedFrames = 0;
            this._consecutiveDrops = 0;
            this._consecutiveGood = 0;
        }
    };

    // =========================================================================
    // ADAPTIVE QUALITY MANAGER
    // Adjusts rendering quality based on performance
    // =========================================================================

    const QUALITY_TIERS = ['minimal', 'low', 'medium', 'high', 'ultra'];

    const QUALITY_SETTINGS = {
        ultra:   { refreshEvery: 1, flockEnabled: true,  labelDensity: 1.0, animDuration: 1500 },
        high:    { refreshEvery: 1, flockEnabled: false, labelDensity: 0.8, animDuration: 1200 },
        medium:  { refreshEvery: 2, flockEnabled: false, labelDensity: 0.5, animDuration: 800  },
        low:     { refreshEvery: 3, flockEnabled: false, labelDensity: 0.2, animDuration: 500  },
        minimal: { refreshEvery: 5, flockEnabled: false, labelDensity: 0.1, animDuration: 200  }
    };

    const AdaptiveQuality = {
        _current: 'high',
        _locked: false,
        _nodeCount: 0,
        _callbacks: [],

        init(nodeCount) {
            this._nodeCount = nodeCount;
            // Auto-select initial tier based on node count
            if (nodeCount <= CONFIG.nodeThresholds.small) {
                this._current = 'ultra';
            } else if (nodeCount <= CONFIG.nodeThresholds.medium) {
                this._current = 'high';
            } else if (nodeCount <= CONFIG.nodeThresholds.large) {
                this._current = 'medium';
            } else if (nodeCount <= CONFIG.nodeThresholds.massive) {
                this._current = 'low';
            } else {
                this._current = 'minimal';
            }
            console.log(`[PERF] Quality auto-set to '${this._current}' for ${nodeCount} nodes`);
            this._notify();
        },

        get current() { return this._current; },

        get settings() { return QUALITY_SETTINGS[this._current]; },

        set(tier) {
            if (!QUALITY_TIERS.includes(tier)) {
                console.warn(`[PERF] Unknown quality tier: ${tier}`);
                return;
            }
            this._current = tier;
            console.log(`[PERF] Quality set to '${tier}'`);
            this._notify();
        },

        degrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            if (idx > 0) {
                this._current = QUALITY_TIERS[idx - 1];
                console.log(`[PERF] Quality degraded to '${this._current}'`);
                this._notify();
            }
        },

        upgrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            // Don't upgrade beyond what node count allows
            const maxTier = this._getMaxTierForNodeCount();
            const maxIdx = QUALITY_TIERS.indexOf(maxTier);
            if (idx < maxIdx) {
                this._current = QUALITY_TIERS[idx + 1];
                console.log(`[PERF] Quality upgraded to '${this._current}'`);
                this._notify();
            }
        },

        lock() { this._locked = true; },
        unlock() { this._locked = false; },

        _getMaxTierForNodeCount() {
            const n = this._nodeCount;
            if (n <= CONFIG.nodeThresholds.small) return 'ultra';
            if (n <= CONFIG.nodeThresholds.medium) return 'high';
            if (n <= CONFIG.nodeThresholds.large) return 'medium';
            if (n <= CONFIG.nodeThresholds.massive) return 'low';
            return 'minimal';
        },

        onChange(callback) {
            this._callbacks.push(callback);
        },

        _notify() {
            this._callbacks.forEach(cb => cb(this._current, this.settings));
        }
    };

    // =========================================================================
    // POSITION OWNERSHIP
    // Enforces single-owner invariant for node positions (fx/fy/fz)
    // =========================================================================

    const OWNERS = ['none', 'transition', 'motion', 'flock', 'force'];

    const PositionOwnership = {
        _current: 'none',
        _animationId: null,

        get current() { return this._current; },

        acquire(owner, animationId = null) {
            if (!OWNERS.includes(owner)) {
                console.warn(`[PERF] Unknown position owner: ${owner}`);
                return false;
            }

            // Cancel any existing animation
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }

            this._current = owner;
            this._animationId = animationId;
            console.log(`[PERF] Position ownership: ${owner}`);
            return true;
        },

        release(owner) {
            if (this._current === owner) {
                if (this._animationId) {
                    cancelAnimationFrame(this._animationId);
                    this._animationId = null;
                }
                this._current = 'none';
                console.log(`[PERF] Position ownership released by ${owner}`);
            }
        },

        setAnimationId(id) {
            this._animationId = id;
        },

        cancelAnimation() {
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }
        }
    };

    // =========================================================================
    // ANIMATION SCHEDULER
    // Frame-budget-aware animation with throttling
    // =========================================================================

    const AnimationScheduler = {
        _refreshFrameCounter: 0,

        /**
         * Run a layout transition with frame budget awareness
         * @param {Object} options
         * @param {Array} options.nodes - Array of node objects
         * @param {Function} options.getTargetPosition - (node, index, total) => {x, y, z}
         * @param {number} options.duration - Animation duration in ms
         * @param {Function} options.onFrame - Called each frame with progress (0-1)
         * @param {Function} options.onComplete - Called when animation finishes
         * @param {Function} options.refresh - Function to call to refresh the graph
         */
        runTransition(options) {
            const { nodes, getTargetPosition, duration, onFrame, onComplete, refresh } = options;

            // Acquire ownership
            PositionOwnership.acquire('transition');

            const total = nodes.length;
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => getTargetPosition(n, i, total));

            const startTime = performance.now();
            const settings = AdaptiveQuality.settings;
            const actualDuration = Math.min(duration, settings.animDuration);

            this._refreshFrameCounter = 0;

            const animate = () => {
                // Check if we still own positions
                if (PositionOwnership.current !== 'transition') {
                    console.log('[PERF] Transition interrupted - lost ownership');
                    return;
                }

                const now = performance.now();
                const elapsed = now - startTime;
                const progress = Math.min(1, elapsed / actualDuration);

                // Smoothstep easing
                const eased = progress * progress * (3 - 2 * progress);

                // Update positions
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];
                    const s = startPos[i];
                    const t = targetPos[i];
                    n.fx = s.x + (t.x - s.x) * eased;
                    n.fy = s.y + (t.y - s.y) * eased;
                    n.fz = s.z + (t.z - s.z) * eased;
                }

                // Throttled refresh based on quality settings
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                if (onFrame) onFrame(progress);

                if (progress < 1) {
                    const id = requestAnimationFrame(animate);
                    PositionOwnership.setAnimationId(id);
                } else {
                    PositionOwnership.release('transition');
                    if (onComplete) onComplete();
                }
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Run continuous motion (rotate/orbit) with throttling
         */
        runMotion(options) {
            const { nodes, getPosition, speed, refresh } = options;

            PositionOwnership.acquire('motion');

            const total = nodes.length;
            const settings = AdaptiveQuality.settings;
            let time = 0;

            this._refreshFrameCounter = 0;

            const animate = () => {
                if (PositionOwnership.current !== 'motion') {
                    console.log('[PERF] Motion interrupted - lost ownership');
                    return;
                }

                time += speed;

                for (let i = 0; i < nodes.length; i++) {
                    const pos = getPosition(nodes[i], i, total, time);
                    nodes[i].fx = pos.x;
                    nodes[i].fy = pos.y;
                    nodes[i].fz = pos.z;
                }

                // Throttled refresh
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                const id = requestAnimationFrame(animate);
                PositionOwnership.setAnimationId(id);
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Stop any running animation
         */
        stop() {
            PositionOwnership.cancelAnimation();
            PositionOwnership._current = 'none';
        }
    };

    // =========================================================================
    // HUD OVERLAY
    // Real-time performance display (toggleable)
    // =========================================================================

    const HUD = {
        _element: null,
        _visible: false,
        _updateInterval: null,

        init() {
            this._element = document.createElement('div');
            this._element.id = 'perf-hud';
            this._element.style.cssText = `
                position: fixed;
                bottom: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.8);
                color: #0f0;
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
                padding: 8px 12px;
                border-radius: 4px;
                z-index: 10000;
                display: none;
                min-width: 140px;
                border: 1px solid #333;
            `;
            document.body.appendChild(this._element);
        },

        show() {
            if (!this._element) this.init();
            this._element.style.display = 'block';
            this._visible = true;
            this._startUpdates();
        },

        hide() {
            if (this._element) {
                this._element.style.display = 'none';
            }
            this._visible = false;
            this._stopUpdates();
        },

        toggle() {
            if (this._visible) this.hide();
            else this.show();
        },

        _startUpdates() {
            if (this._updateInterval) return;
            this._updateInterval = setInterval(() => this._update(), 100);
        },

        _stopUpdates() {
            if (this._updateInterval) {
                clearInterval(this._updateInterval);
                this._updateInterval = null;
            }
        },

        _update() {
            if (!this._element || !this._visible) return;

            const stats = PerformanceMonitor.stats;
            const fpsColor = stats.fps >= 55 ? '#0f0' : stats.fps >= 30 ? '#ff0' : '#f00';

            this._element.innerHTML = `
                <div style="color: ${fpsColor}; font-weight: bold;">${stats.fps} FPS</div>
                <div style="color: #888;">Frame: ${stats.lastFrameTime}ms</div>
                <div style="color: #888;">Avg: ${stats.avgFrameTime}ms</div>
                <div style="color: #888;">Drops: ${stats.droppedPercent}%</div>
                <div style="color: #0af;">Quality: ${stats.quality}</div>
                <div style="color: #a0f;">Owner: ${stats.owner}</div>
            `;
        }
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        monitor: PerformanceMonitor,
        quality: AdaptiveQuality,
        ownership: PositionOwnership,
        scheduler: AnimationScheduler,
        hud: HUD,
        config: CONFIG,

        /**
         * Initialize the performance subsystem
         * @param {number} nodeCount - Number of nodes in the graph
         * @param {Object} tokens - Optional performance tokens from JSON
         */
        init(nodeCount, tokens = null) {
            if (tokens) {
                Object.assign(CONFIG, tokens);
            }
            AdaptiveQuality.init(nodeCount);
            PerformanceMonitor.start();
            HUD.init();
            console.log('[PERF] Performance subsystem initialized');
        },

        /**
         * Check if flock simulation should be enabled
         */
        isFlockAllowed() {
            return AdaptiveQuality.settings.flockEnabled;
        },

        /**
         * Get current animation duration (adjusted for quality)
         */
        getAnimationDuration(requested) {
            return Math.min(requested, AdaptiveQuality.settings.animDuration);
        }
    };
})();

// Export for module systems if available
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PERF;
}


// ═══ MODULE: modules/utils.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UTILS MODULE - Pure Utility Functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Zero-dependency pure functions for math, string, and data operations.
 * These functions have NO external state dependencies and can be used anywhere.
 *
 * @module UTILS
 * @version 1.0.0
 * @confidence 99%
 */

window.UTILS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // MATH UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clamp value to [0, 1] range
     * @param {number} value - Value to clamp
     * @returns {number} Clamped value
     */
    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    /**
     * Clamp value to [min, max] range
     * @param {number} value - Value to clamp
     * @param {number} min - Minimum bound
     * @param {number} max - Maximum bound
     * @returns {number} Clamped value
     */
    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Normalize value to [0, 1] based on max
     * @param {number} val - Value to normalize
     * @param {number} max - Maximum value
     * @returns {number} Normalized value
     */
    function normalize(val, max) {
        return Math.min(1, Math.max(0, val / max));
    }

    /**
     * Normalize metric value based on range
     * Handles degenerate ranges gracefully
     * @param {number} value - Value to normalize
     * @param {min: number, max: number} range - Range object
     * @returns {number} Normalized value in [0, 1]
     */
    function normalizeMetric(value, range) {
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }
        return clamp01((value - range.min) / (range.max - range.min));
    }

    /**
     * Calculate quantile from sorted values
     * @param {number[]} values - Array of numbers
     * @param {number} q - Quantile (0-1)
     * @returns {number} Quantile value
     */
    function quantile(values, q) {
        if (!values.length) return 0;
        const sorted = values.slice().sort((a, b) => a - b);
        const pos = (sorted.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;
        if (sorted[base + 1] !== undefined) {
            return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
        }
        return sorted[base];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HASH & SEED UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Convert any value to a unit float [0, 1] via hashing
     * @param {*} value - Any value to hash
     * @returns {number} Hash as unit float
     */
    function hashToUnit(value) {
        const str = String(value || '');
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return (hash >>> 0) / 0xffffffff;
    }

    /**
     * Generate stable seed from node and salt
     * @param {Object} node - Node object with id/name
     * @param {string} salt - Salt string
     * @returns {number} Stable seed in [0, 1]
     */
    function stableSeed(node, salt) {
        const id = String(node.id || node.name || '');
        const combined = `${id}|${salt}`;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
            hash = ((hash << 5) - hash + combined.charCodeAt(i)) | 0;
        }
        return ((hash >>> 0) % 1000) / 1000;
    }

    /**
     * Generate stable Z offset for node
     * @param {Object} node - Node object
     * @returns {number} Z offset
     */
    function stableZ(node) {
        const normalized = stableSeed(node, 'z');
        return (normalized - 0.5) * 60;
    }

    /**
     * Generate stable offset vector for node positioning
     * @param {Object} node - Node object
     * @param {string} salt - Salt string
     * @param {number} radius - Base radius
     * @returns {x: number, y: number, z: number} Offset vector
     */
    function stableOffset(node, salt, radius) {
        const angle = stableSeed(node, `${salt}:angle`) * Math.PI * 2;
        const spread = 0.3 + stableSeed(node, `${salt}:radius`) * 0.7;
        const zJitter = (stableSeed(node, `${salt}:z`) - 0.5) * radius * 0.6;
        const dist = radius * spread;
        return {
            x: Math.cos(angle) * dist,
            y: Math.sin(angle) * dist,
            z: zJitter
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STRING UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Escape HTML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML
     */
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Parse OKLCH color string
     * @param {string} value - OKLCH color string
     * @returns {L: number, C: number, H: number, A: number}|null} Parsed values or null
     */
    function parseOklchString(value) {
        if (typeof value !== 'string') return null;
        const match = value.trim().match(/^oklch\(\s*([\d.]+)%\s+([\d.]+)\s+([\d.]+)(?:\s*\/\s*([\d.]+))?\s*\)$/i);
        if (!match) return null;
        return {
            L: parseFloat(match[1]),
            C: parseFloat(match[2]),
            H: parseFloat(match[3]),
            A: match[4] !== undefined ? parseFloat(match[4]) : 1
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Resolve defaults against available values
     * @param {Array} defaults - Preferred defaults
     * @param {Array} available - Available values
     * @returns {Array} Resolved values
     */
    function resolveDefaults(defaults, available) {
        if (!Array.isArray(defaults) || defaults.length === 0) {
            return available;
        }
        const availableSet = new Set(available);
        const intersection = defaults.filter(value => availableSet.has(value));
        return intersection.length ? intersection : available;
    }

    /**
     * Build dataset key from data object
     * @param {Object} data - Data object with meta, nodes, links
     * @returns {string} Dataset key
     */
    function buildDatasetKey(data) {
        const meta = (data && data.meta) ? data.meta : {};
        const target = meta.target || meta.project || 'dataset';
        const version = meta.version || '';
        const nodeCount = Array.isArray(data?.nodes) ? data.nodes.length : 0;
        const edgeCount = Array.isArray(data?.links)
            ? data.links.length
            : (Array.isArray(data?.edges) ? data.edges.length : 0);
        const raw = `${target}|${nodeCount}|${edgeCount}|${version}`;
        return raw.replace(/[^a-zA-Z0-9_.-]/g, '_').slice(0, 180);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GEOMETRY UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Calculate bounding box from two points
     * @param {x: number, y: number} start - Start point
     * @param {x: number, y: number} end - End point
     * @returns {left: number, top: number, width: number, height: number, right: number, bottom: number} Box rect
     */
    function getBoxRect(start, end) {
        const left = Math.min(start.x, end.x);
        const top = Math.min(start.y, end.y);
        const width = Math.abs(start.x - end.x);
        const height = Math.abs(start.y - end.y);
        return {
            left,
            top,
            width,
            height,
            right: left + width,
            bottom: top + height
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Math
        clamp01,
        clampValue,
        normalize,
        normalizeMetric,
        quantile,

        // Hash & Seed
        hashToUnit,
        stableSeed,
        stableZ,
        stableOffset,

        // String
        escapeHtml,
        parseOklchString,

        // Data
        resolveDefaults,
        buildDatasetKey,

        // Geometry
        getBoxRect
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════
// These ensure existing code continues to work without modification

window.clamp01 = UTILS.clamp01;
window.clampValue = UTILS.clampValue;
window.normalize = UTILS.normalize;
window.normalizeMetric = UTILS.normalizeMetric;
window.quantile = UTILS.quantile;
window.hashToUnit = UTILS.hashToUnit;
window.stableSeed = UTILS.stableSeed;
window.stableZ = UTILS.stableZ;
window.stableOffset = UTILS.stableOffset;
window.escapeHtml = UTILS.escapeHtml;
window.parseOklchString = UTILS.parseOklchString;
window.resolveDefaults = UTILS.resolveDefaults;
window.buildDatasetKey = UTILS.buildDatasetKey;
window.getBoxRect = UTILS.getBoxRect;

console.log('[Module] UTILS loaded - 14 pure functions');


// ═══ MODULE: modules/registry.js ═══
/**
 * @module registry
 * @description Centralized UI and command registration system
 * @responsibility Manage DOM element and command handler registration
 */

const REGISTRY = (function() {
    'use strict';

    // Private state
    const _items = new Map();
    const _commands = new Map();

    /**
     * Register a command handler or DOM element
     * @param {string} id - The identifier
     * @param {Function|Element} item - Handler function or DOM element
     * @param {Object} options - Additional options
     */
    function register(id, item, options = {}) {
        // CASE 1: Registering a Command Identifier + Handler Function
        // e.g. REGISTRY.register('cmd-files', () => toggleFiles(), { desc: '...' })
        if (typeof item === 'function') {
            _commands.set(id, { handler: item, options });

            // Auto-wire if DOM element exists with this ID
            const btn = document.getElementById(id);
            if (btn) {
                btn.onclick = (e) => {
                    item(e);
                };
                btn.setAttribute('data-command-id', id);
            }
            return;
        }

        // CASE 2: Registering a DOM Element directly
        let element = item;
        let elementId = id;

        // Overload: register(element) -> id comes from element.id
        if ((item instanceof Element) && arguments.length === 1) {
            element = item;
            elementId = element.id;
        }
        // Overload: register(id, element)
        else if (item instanceof Element) {
            element = item;
        }
        // Fallback: mismatched args
        else if (!element && (typeof id === 'object' && id instanceof Element)) {
            element = id;
            elementId = element.id;
        }

        if (!element || !element.setAttribute) {
            return;
        }

        if (!elementId) {
            return;
        }

        _items.set(elementId, element);
        element.setAttribute('data-registry-id', elementId);
    }

    /**
     * Get a registered element by ID (falls back to document.getElementById)
     * @param {string} id - The element ID
     * @returns {Element|null}
     */
    function get(id) {
        return _items.get(id) || document.getElementById(id);
    }

    /**
     * Get a registered command handler
     * @param {string} id - The command ID
     * @returns {Object|undefined} - { handler, options }
     */
    function getCommand(id) {
        return _commands.get(id);
    }

    /**
     * Execute a registered command
     * @param {string} id - The command ID
     * @param {Event} event - Optional event object
     * @returns {*} - Result of handler execution
     */
    function execute(id, event) {
        const cmd = _commands.get(id);
        if (cmd && typeof cmd.handler === 'function') {
            return cmd.handler(event);
        }
        console.warn(`[Registry] Command not found: ${id}`);
        return undefined;
    }

    /**
     * Check if a command is registered
     * @param {string} id - The command ID
     * @returns {boolean}
     */
    function hasCommand(id) {
        return _commands.has(id);
    }

    /**
     * Check if an element is registered
     * @param {string} id - The element ID
     * @returns {boolean}
     */
    function hasElement(id) {
        return _items.has(id);
    }

    /**
     * Get all registered command IDs
     * @returns {string[]}
     */
    function listCommands() {
        return Array.from(_commands.keys());
    }

    /**
     * Get all registered element IDs
     * @returns {string[]}
     */
    function listElements() {
        return Array.from(_items.keys());
    }

    // Public API
    return {
        register,
        get,
        getCommand,
        execute,
        hasCommand,
        hasElement,
        listCommands,
        listElements,
        // Expose maps for backward compatibility (read-only access pattern)
        get items() { return _items; },
        get commands() { return _commands; }
    };
})();

// Expose globally for backward compatibility
window.REGISTRY = REGISTRY;


// ═══ MODULE: modules/perf-monitor.js ═══
/**
 * @module perf-monitor
 * @description Real-time performance monitoring and FPS diagnostics
 * @responsibility Track frame delivery, detect dropped frames, display HUD
 */

const PERF = (function() {
    'use strict';

    // Configuration
    const _config = {
        enabled: true,
        maxFrames: 60,
        droppedFrameThreshold: 50  // ms (>50ms = <20fps)
    };

    // State
    const _state = {
        fps: 0,
        frameTime: 0,
        lastFrameTime: 0,
        frameTimes: [],
        renderCalls: 0,
        droppedFrames: 0,
        lastSecond: 0,
        framesThisSecond: 0,
        hudElement: null,
        monitoring: false
    };

    /**
     * Initialize the performance monitor
     */
    function init() {
        if (!_config.enabled) return;

        // Create HUD element
        _state.hudElement = document.createElement('div');
        _state.hudElement.id = 'perf-hud';
        _state.hudElement.style.cssText = `
            position: fixed; top: 10px; right: 10px; z-index: 99999;
            background: rgba(0,0,0,0.85); color: #0f0; font-family: monospace;
            font-size: 11px; padding: 8px 12px; border-radius: 4px;
            border: 1px solid #333; min-width: 140px; pointer-events: none;
        `;
        document.body.appendChild(_state.hudElement);
        _startMonitoring();
    }

    /**
     * Start the monitoring loop
     */
    function _startMonitoring() {
        if (_state.monitoring) return;
        _state.monitoring = true;

        const monitor = () => {
            if (!_state.monitoring) return;

            const now = performance.now();

            // Calculate frame time
            if (_state.lastFrameTime > 0) {
                _state.frameTime = now - _state.lastFrameTime;
                _state.frameTimes.push(_state.frameTime);
                if (_state.frameTimes.length > _config.maxFrames) {
                    _state.frameTimes.shift();
                }

                // Detect dropped frames
                if (_state.frameTime > _config.droppedFrameThreshold) {
                    _state.droppedFrames++;
                }
            }
            _state.lastFrameTime = now;

            // Calculate FPS every second
            const second = Math.floor(now / 1000);
            if (second !== _state.lastSecond) {
                _state.fps = _state.framesThisSecond;
                _state.framesThisSecond = 0;
                _state.lastSecond = second;
            }
            _state.framesThisSecond++;

            // Update HUD
            _updateHUD();
            requestAnimationFrame(monitor);
        };
        requestAnimationFrame(monitor);
    }

    /**
     * Update the HUD display
     */
    function _updateHUD() {
        if (!_state.hudElement) return;

        const avgFrameTime = _state.frameTimes.length > 0
            ? (_state.frameTimes.reduce((a, b) => a + b, 0) / _state.frameTimes.length).toFixed(1)
            : '0.0';

        // Color code FPS
        let fpsColor = '#0f0';  // Green = good
        if (_state.fps < 30) fpsColor = '#ff0';  // Yellow = warning
        if (_state.fps < 15) fpsColor = '#f00';  // Red = bad

        // Animation state - use ANIM module if available
        const isAnimating = typeof ANIM !== 'undefined' && ANIM.isAnimating;
        const animating = isAnimating ? '▶ ANIMATING' : '■ IDLE';
        const animColor = isAnimating ? '#0ff' : '#666';
        const staggerPattern = (typeof ANIM !== 'undefined' && ANIM.staggerPattern) || 'none';

        _state.hudElement.innerHTML = `
            <div style="color:${fpsColor};font-size:14px;font-weight:bold">${_state.fps} FPS</div>
            <div>Frame: ${avgFrameTime}ms</div>
            <div>Dropped: <span style="color:${_state.droppedFrames > 10 ? '#f00' : '#0f0'}">${_state.droppedFrames}</span></div>
            <div style="color:${animColor}">${animating}</div>
            <div style="font-size:9px;color:#666;margin-top:4px">Pattern: ${staggerPattern}</div>
        `;
    }

    /**
     * Log a performance resistance point
     * @param {string} location - Where the resistance occurred
     * @param {number} duration - Duration in milliseconds
     */
    function logResistance(location, duration) {
        if (duration > 16) {
            console.warn(`[PERF RESISTANCE] ${location}: ${duration.toFixed(1)}ms (>${Math.floor(duration / 16.67)} frames)`);
        }
    }

    /**
     * Stop monitoring
     */
    function stop() {
        _state.monitoring = false;
        if (_state.hudElement && _state.hudElement.parentNode) {
            _state.hudElement.parentNode.removeChild(_state.hudElement);
        }
        _state.hudElement = null;
    }

    /**
     * Reset statistics
     */
    function reset() {
        _state.fps = 0;
        _state.frameTime = 0;
        _state.frameTimes = [];
        _state.droppedFrames = 0;
        _state.framesThisSecond = 0;
    }

    /**
     * Toggle HUD visibility
     */
    function toggle() {
        if (_state.hudElement) {
            _state.hudElement.style.display =
                _state.hudElement.style.display === 'none' ? 'block' : 'none';
        }
    }

    /**
     * Enable/disable monitoring
     * @param {boolean} enabled
     */
    function setEnabled(enabled) {
        _config.enabled = enabled;
        if (!enabled) {
            stop();
        } else if (!_state.monitoring) {
            init();
        }
    }

    // Public API
    return {
        init,
        stop,
        reset,
        toggle,
        setEnabled,
        logResistance,
        // Read-only state access
        get fps() { return _state.fps; },
        get frameTime() { return _state.frameTime; },
        get droppedFrames() { return _state.droppedFrames; },
        get enabled() { return _config.enabled; },
        get monitoring() { return _state.monitoring; }
    };
})();

// Backward compatibility alias
const PERF_MONITOR = PERF;

// Expose globally
window.PERF = PERF;
window.PERF_MONITOR = PERF_MONITOR;


// ═══ MODULE: modules/core.js ═══
/**
 * CORE MODULE
 *
 * Foundation constants and utility functions for the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   CORE.SELECTION_SIZE_MULT      // Node size multiplier when selected
 *   CORE.PENDULUM                 // OKLCH color oscillator state
 *   CORE.amplify(value, gamma)    // Power law amplification
 *   CORE.amplifyContrast(value)   // S-curve contrast expansion
 */

const CORE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

    // OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
    const PENDULUM = {
        hue: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,        // Set from appearance.tokens
            gravity: null,        // Set from appearance.tokens
            length: 1.0,
            rotationSpeed: null   // Set from appearance.tokens
        },
        chroma: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,
            gravity: null,
            length: 1.0,
            center: null,
            amplitude: null
        },
        lightness: {
            phase: 0,
            speed: null,
            center: null,
            amplitude: null
        },
        ripple: {
            speed: null,
            scale: null
        },
        currentHue: Math.random() * 360,
        lastTime: 0,
        running: false
    };

    // =========================================================================
    // AMPLIFICATION UTILITIES
    // =========================================================================

    /**
     * Amplification function using power law: f(x) = x^(1/gamma)
     * Maps normalized [0,1] input to amplified [0,1] output
     * @param {number} value - Input value (0-1)
     * @param {number} gamma - Amplification factor (default from APPEARANCE_STATE)
     * @returns {number} Amplified value (0-1)
     */
    function amplify(value, gamma) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const g = gamma !== undefined ? gamma :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (g === 1) return value;
        // Clamp to valid range
        const v = Math.max(0, Math.min(1, value));
        // Power law: v^(1/gamma) - when gamma>1, small diffs become larger
        // Using 1/gamma so that higher slider = more amplification
        return Math.pow(v, 1 / g);
    }

    /**
     * Contrast amplification: expands values away from midpoint
     * Uses S-curve (tanh) for smooth contrast expansion
     * @param {number} value - Input value (0-1)
     * @param {number} strength - Contrast strength (default from APPEARANCE_STATE)
     * @returns {number} Contrast-enhanced value (0-1)
     */
    function amplifyContrast(value, strength) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const s = strength !== undefined ? strength :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (s === 1) return value;
        const v = Math.max(0, Math.min(1, value));
        // S-curve using tanh for smooth contrast expansion
        const centered = (v - 0.5) * 2;  // [-1, 1]
        const amplified = Math.tanh(centered * s) / Math.tanh(s);
        return (amplified + 1) / 2;  // Back to [0, 1]
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Constants
        SELECTION_SIZE_MULT,
        PENDULUM,

        // Utilities
        amplify,
        amplifyContrast
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'SELECTION_SIZE_MULT', {
    get: () => CORE.SELECTION_SIZE_MULT,
    configurable: true
});
Object.defineProperty(window, 'PENDULUM', {
    get: () => CORE.PENDULUM,
    configurable: true
});
Object.defineProperty(window, 'amplify', {
    get: () => CORE.amplify,
    configurable: true
});
Object.defineProperty(window, 'amplifyContrast', {
    get: () => CORE.amplifyContrast,
    configurable: true
});


// ═══ MODULE: modules/node-accessors.js ═══
/**
 * NODE ACCESSORS MODULE
 *
 * Provides standardized access to node properties across the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   NODE.getTier(node)       // Returns 'T0', 'T1', 'T2', or 'UNKNOWN'
 *   NODE.getFamily(node)     // Returns 'LOG', 'DAT', 'ORG', 'EXE', 'EXT', or 'UNKNOWN'
 *   NODE.getRing(node)       // Returns ring/layer value
 *   NODE.getLayer(node)      // Returns D2_LAYER value
 *   NODE.getEffect(node)     // Returns D6_EFFECT value
 */

const NODE = (function() {
    'use strict';

    // =========================================================================
    // TIER SYSTEM
    // =========================================================================

    // Tier aliases: legacy names -> canonical T0/T1/T2
    const TIER_ALIASES = {
        'CORE': 'T0', 'T0': 'T0',
        'ARCH': 'T1', 'T1': 'T1',
        'EXT': 'T2', 'T2': 'T2',
        'DISCOVERED': 'T2',  // EXT.DISCOVERED -> T2
        'UNKNOWN': 'UNKNOWN'
    };

    function normalizeTier(tier) {
        if (!tier) return 'UNKNOWN';
        const upper = String(tier).toUpperCase();
        return TIER_ALIASES[upper] || upper;
    }

    // Prefer canonical node.tier field; fallback to atom prefix inference
    function getTier(node) {
        // If node is a string (backward compat: called with atomId), infer from prefix
        if (typeof node === 'string') {
            const atomId = node;
            if (!atomId) return 'UNKNOWN';
            if (atomId.startsWith('CORE.')) return 'T0';
            if (atomId.startsWith('ARCH.')) return 'T1';
            if (atomId.startsWith('EXT.')) return 'T2';
            return 'UNKNOWN';
        }
        // Prefer canonical field
        if (node.tier) {
            return normalizeTier(node.tier);
        }
        // Fallback: infer from atom prefix
        const atomId = String(node.atom || '');
        if (atomId.startsWith('CORE.')) return 'T0';
        if (atomId.startsWith('ARCH.')) return 'T1';
        if (atomId.startsWith('EXT.')) return 'T2';
        return 'UNKNOWN';
    }

    // =========================================================================
    // FAMILY SYSTEM
    // =========================================================================

    // Get atom family from canonical field or infer from atom prefix
    function getFamily(node) {
        // Prefer canonical field
        if (node.atom_family) {
            return String(node.atom_family).toUpperCase();
        }
        // Fallback: infer from atom (e.g., "LOG.FNC.M" -> "LOG")
        const atomId = String(node.atom || '');
        const dotIdx = atomId.indexOf('.');
        if (dotIdx > 0) {
            return atomId.substring(0, dotIdx).toUpperCase();
        }
        return 'UNKNOWN';
    }

    // =========================================================================
    // RING SYSTEM
    // =========================================================================

    function normalizeRing(value) {
        if (value === null || value === undefined) return null;
        const ring = String(value).trim().toUpperCase();
        if (!ring) return null;
        const aliases = {
            TEST: 'TESTING'
        };
        return aliases[ring] || ring;
    }

    function getRing(node) {
        const ring = node.ring || node.layer || 'UNKNOWN';
        return normalizeRing(ring) || 'UNKNOWN';
    }

    // =========================================================================
    // LAYER SYSTEM (D2_LAYER)
    // =========================================================================

    function getLayer(node) {
        if (!node) return 'Unknown';
        return node.layer || node.dimensions?.D2_LAYER || 'Unknown';
    }

    // =========================================================================
    // EFFECT SYSTEM (D6_EFFECT)
    // =========================================================================

    function getEffect(node) {
        if (!node) return 'Unknown';
        return node.effect || node.dimensions?.D6_EFFECT || 'Unknown';
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Tier
        getTier,
        normalizeTier,
        TIER_ALIASES,

        // Family
        getFamily,

        // Ring
        getRing,
        normalizeRing,

        // Layer
        getLayer,

        // Effect
        getEffect
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'getNodeTier', { get: () => NODE.getTier, configurable: true });
Object.defineProperty(window, 'getNodeAtomFamily', { get: () => NODE.getFamily, configurable: true });
Object.defineProperty(window, 'getNodeRing', { get: () => NODE.getRing, configurable: true });
Object.defineProperty(window, 'getNodeLayer', { get: () => NODE.getLayer, configurable: true });
Object.defineProperty(window, 'getNodeEffect', { get: () => NODE.getEffect, configurable: true });
Object.defineProperty(window, 'normalizeTier', { get: () => NODE.normalizeTier, configurable: true });
Object.defineProperty(window, 'normalizeRingValue', { get: () => NODE.normalizeRing, configurable: true });
Object.defineProperty(window, 'TIER_ALIASES', { get: () => NODE.TIER_ALIASES, configurable: true });


// ═══ MODULE: modules/node-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * NODE-HELPERS MODULE - Node classification and color functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node color mode selection, data enrichment helpers, and tier grouping.
 * Depends on: COLOR (ColorOrchestrator), NODE (node-accessors), DM, Graph
 *
 * @module NODE_HELPERS
 * @version 1.0.0
 */

window.NODE_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR BY MODE
    // ═══════════════════════════════════════════════════════════════════════

    // =========================================================================
    // MODE_ACCESSORS: Declarative map replacing the mega-switch
    // Each mode maps to a function: (node, Color) => colorString
    // =========================================================================

    const MODE_ACCESSORS = {
        // 1. ARCHITECTURE
        tier:           (n, C) => C.get('tier', window.getNodeTier(n)),
        layer:          (n, C) => C.get('layer', (n.layer || n.dimensions?.D2_LAYER || 'UNKNOWN').toUpperCase()),
        subsystem:      (n, C) => C.get('subsystem', getSubsystem(n)),
        boundary_score: (n, C) => C.getInterval('boundary_score', window.normalize(n.rpbl?.boundary ?? 1, 9)),
        phase:          (n, C) => C.get('phase', getPhase(n)),

        // 2. TAXONOMY
        atom:           (n, C) => C.get('atom', (n.kind || n.type || 'unknown').toLowerCase()),
        family:         (n, C) => C.get('family', window.getNodeAtomFamily(n)),
        role:           (n, C) => C.get('roleCategory', n.role_cat || 'Unknown'),
        roleCategory:   (n, C) => C.get('roleCategory', n.role_cat || getRoleCategory(n)),
        fileType:       (n, C) => C.get('fileType', getFileType(n)),

        // 3. METRICS
        complexity:     (n, C) => C.getInterval('complexity', window.normalize(n.complexity || 0, 20)),
        loc:            (n, C) => C.getInterval('loc', window.normalize(n.lines_of_code || 0, 500)),
        fan_in:         (n, C) => C.getInterval('fan_in', window.normalize(n.in_degree || 0, 20)),
        fan_out:        (n, C) => C.getInterval('fan_out', window.normalize(n.out_degree || 0, 20)),
        trust:          (n, C) => C.getInterval('trust', n.trust || n.confidence || 0),

        // 4. RPBL DNA
        responsibility: (n, C) => C.getInterval('responsibility', window.normalize(n.rpbl?.responsibility ?? 1, 9)),
        purity:         (n, C) => C.getInterval('purity', window.normalize(n.rpbl?.purity ?? 1, 9)),
        lifecycle_score:(n, C) => C.getInterval('lifecycle_score', window.normalize(n.rpbl?.lifecycle ?? 1, 9)),
        state:          (n, C) => C.get('state', (n.dimensions?.D5_STATE === 'Stateful') ? 'Stateful' : 'Stateless'),
        visibility:     (n, C) => C.get('visibility', n.dimensions?.D4_BOUNDARY === 'External' ? 'Public' : 'Private'),

        // 5. TOPOLOGY
        centrality:     (n, C) => C.getInterval('centrality', n.centrality || 0),
        rank:           (n, C) => C.getInterval('centrality', n.pagerank || 0),
        ring:           (n, C) => C.get('ring', window.getNodeRing(n)),

        // 6. EVOLUTION (Placeholders)
        churn:          (n, C) => C.getInterval('churn', Math.random() * 0.5),
        age:            (n, C) => C.getInterval('churn', 0.2)
    };

    function getNodeColorByMode(node) {
        const Color = window.Color;
        const NODE_COLOR_MODE = window.NODE_COLOR_MODE;
        const DM = window.DM;

        // Special case: file coloring needs extra context
        if (NODE_COLOR_MODE === 'file') {
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx < 0) return Color.get('tier', 'UNKNOWN');
            const fileBoundaries = DM ? DM.getFileBoundaries() : [];
            const totalFiles = fileBoundaries.length;
            const fileInfo = fileBoundaries[fileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            return window.getFileColor(fileIdx, totalFiles, fileLabel);
        }

        // Use MODE_ACCESSORS map - O(1) lookup instead of if-chain
        const accessor = MODE_ACCESSORS[NODE_COLOR_MODE];
        if (accessor) return accessor(node, Color);

        // Default fallback
        return Color.get('tier', window.getNodeTier(node));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA ENRICHMENT HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getSubsystem(node) {
        if (!node.file_path) return 'Unknown';
        if (node.file_path.includes('/api/')) return 'Ingress';
        if (node.file_path.includes('/db/') || node.file_path.includes('repository')) return 'Persistence';
        if (node.file_path.includes('/core/') || node.file_path.includes('domain')) return 'Domain';
        if (node.file_path.includes('/ui/') || node.file_path.includes('frontend')) return 'Presentation';
        if (node.file_path.includes('config')) return 'Config';
        return 'Domain';
    }

    function getPhase(node) {
        const kind = (node.kind || '').toLowerCase();
        if (kind.includes('data') || kind.includes('entity') || kind.includes('schema')) return 'DATA';
        if (kind.includes('function') || kind.includes('logic')) return 'LOGIC';
        if (kind.includes('module') || kind.includes('package')) return 'ORGANIZATION';
        if (kind.includes('script') || kind.includes('main')) return 'EXECUTION';
        return 'LOGIC';
    }

    function getFileType(node) {
        const p = node.file_path || node.id || '';
        const ext = p.split('.').pop().toLowerCase();
        return ext || 'unknown';
    }

    function getRoleCategory(node) {
        const r = (node.role || '').toLowerCase();
        if (r.includes('service') || r.includes('manager')) return 'Orchestration';
        if (r.includes('repo') || r.includes('store')) return 'Storage';
        if (r.includes('controller') || r.includes('handler')) return 'Ingress';
        if (r.includes('util') || r.includes('helper')) return 'Utility';
        return 'Unknown';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR APPLICATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeColors(nodes) {
        const DM = window.DM;
        const fileBoundaries = DM ? DM.getFileBoundaries() : [];
        nodes.forEach(node => {
            if (node && node.isFileNode) {
                if (!node.color) {
                    const totalFiles = fileBoundaries.length;
                    const fileInfo = fileBoundaries[node.fileIdx] || {};
                    const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                    node.color = window.getFileColor(node.fileIdx, totalFiles, fileLabel);
                }
                return;
            }
            if (window.fileMode) {
                return;
            }
            node.color = getNodeColorByMode(node);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SIZE MODE
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeSizeMode(mode) {
        const Graph = window.Graph;
        if (!Graph) return;
        const scale = window.APPEARANCE_STATE?.nodeScale || 1;
        switch (mode) {
            case 'uniform':
                Graph.nodeVal(() => 1 * scale);
                break;
            case 'degree':
                Graph.nodeVal(n => Math.max(1, ((n.in_degree || 0) + (n.out_degree || 0)) * 0.5) * scale);
                break;
            case 'fanout':
                Graph.nodeVal(n => (n.val || n.fanout || 1) * scale);
                break;
            case 'complexity':
                Graph.nodeVal(n => Math.max(1, (n.complexity || n.loc || 10) * 0.05) * scale);
                break;
            default:
                Graph.nodeVal(n => (n.val || 1) * scale);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER/DEPTH/SIMILARITY HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNodeTierValue(node) {
        if (!node) return 1;
        const tier = window.getNodeTier(node);
        if (tier === 'T0') return 0;
        if (tier === 'T1') return 1;
        if (tier === 'T2') return 2;
        return 1;
    }

    function getNodeDepth(node) {
        if (node && typeof node.y === 'number') {
            return Math.abs(node.y) / 500;
        }
        return 0.5;
    }

    function getSemanticSimilarity(srcNode, tgtNode) {
        if (!srcNode || !tgtNode) return 0.5;
        let score = 0;
        if (srcNode.type === tgtNode.type) score += 0.4;
        if (srcNode.fileIdx === tgtNode.fileIdx) score += 0.3;
        if (window.getNodeTier(srcNode) === window.getNodeTier(tgtNode)) score += 0.2;
        if (srcNode.ring === tgtNode.ring) score += 0.1;
        return score;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER GROUPING
    // ═══════════════════════════════════════════════════════════════════════

    function groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = window.getNodeTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getColorByMode: getNodeColorByMode,
        getSubsystem: getSubsystem,
        getPhase: getPhase,
        getFileType: getFileType,
        getRoleCategory: getRoleCategory,
        applyColors: applyNodeColors,
        applySizeMode: applyNodeSizeMode,
        getTierValue: getNodeTierValue,
        getDepth: getNodeDepth,
        getSemanticSimilarity: getSemanticSimilarity,
        groupByTier: groupNodesByTier
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getNodeColorByMode = NODE_HELPERS.getColorByMode;
window.getSubsystem = NODE_HELPERS.getSubsystem;
window.getPhase = NODE_HELPERS.getPhase;
window.getFileType = NODE_HELPERS.getFileType;
window.getRoleCategory = NODE_HELPERS.getRoleCategory;
window.applyNodeColors = NODE_HELPERS.applyColors;
window.applyNodeSizeMode = NODE_HELPERS.applySizeMode;
window.getNodeTierValue = NODE_HELPERS.getTierValue;
window.getNodeDepth = NODE_HELPERS.getDepth;
window.getSemanticSimilarity = NODE_HELPERS.getSemanticSimilarity;
window.groupNodesByTier = NODE_HELPERS.groupByTier;

console.log('[Module] NODE_HELPERS loaded - 11 functions');


// ═══ MODULE: modules/color-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * COLOR-HELPERS MODULE - Color utilities and conversions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Topology colors, color normalization, file hue generation.
 * Depends on: UTILS (parseOklchString, hashToUnit, clampValue), COLOR (oklchColor)
 *
 * @module COLOR_HELPERS
 * @version 1.0.0
 */

window.COLOR_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // TOPOLOGY COLOR LOOKUP
    // ═══════════════════════════════════════════════════════════════════════

    function getTopoColor(category, key) {
        const APPEARANCE_CONFIG = window.APPEARANCE_CONFIG;
        if (!APPEARANCE_CONFIG || !APPEARANCE_CONFIG.color) return { l: 50, c: 0, h: 0 };

        let tokenKey = key;
        let section = 'atom-family'; // Default

        // Map legacy/UI keys to Token keys
        if (category === 'tiers') {
            section = 'atom';
            if (key === 'T0') tokenKey = 't0-core';
            else if (key === 'T1') tokenKey = 't1-arch';
            else if (key === 'T2') tokenKey = 't2-eco';
            else if (key === 'UNKNOWN') tokenKey = 'unknown';
        } else if (category === 'rings') {
            section = 'ring';
            if (key === 'KERNEL') tokenKey = 'DOMAIN';
            if (key === 'CORE') tokenKey = 'APPLICATION';
            if (key === 'SERVICE') tokenKey = 'PRESENTATION';
            if (key === 'ADAPTER') tokenKey = 'INTERFACE';
        } else if (category === 'families') {
            section = 'atom-family';
        }

        // Lookup token
        const tokenStr = APPEARANCE_CONFIG.color[section]?.[tokenKey] || APPEARANCE_CONFIG.color[section]?.['UNKNOWN'];

        // Parse OKLCH
        const parsed = window.parseOklchString(tokenStr);
        if (!parsed) return { l: 50, c: 0, h: 0 }; // Fallback gray

        // Normalize to internal l,c,h format (lowercase)
        return { l: parsed.L * 100, c: parsed.C, h: parsed.H };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLOR NORMALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeColorInput(color, fallback = 'rgb(128, 128, 128)') {
        if (color === null || color === undefined) {
            return fallback;
        }
        if (typeof color !== 'string') {
            return color;
        }
        const parsed = window.parseOklchString(color);
        if (parsed) {
            return window.oklchColor(parsed.L, parsed.C, parsed.H, parsed.A);
        }
        return color;
    }

    function toColorNumber(color, fallback = '#777777') {
        // Returns CSS hex string (polished-compatible) instead of JS hex int
        if (typeof color === 'number') {
            return '#' + color.toString(16).padStart(6, '0');
        }
        if (typeof color !== 'string') {
            return fallback;
        }
        const normalized = normalizeColorInput(color);
        if (typeof normalized === 'string') {
            color = normalized;
        }
        if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl')) {
            return color;  // Already valid CSS color
        }
        try {
            const hex = new THREE.Color(color).getHex();
            return '#' + hex.toString(16).padStart(6, '0');
        } catch (err) {
            return fallback;
        }
    }

    function dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILE COLOR GENERATION
    // ═══════════════════════════════════════════════════════════════════════

    function getFileHue(fileIdx, totalFiles, fileName) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const strategy = FILE_COLOR_CONFIG.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return window.hashToUnit(seed) * 360;
        }
        const angle = FILE_COLOR_CONFIG.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const COLOR_TWEAKS = window.COLOR_TWEAKS || {};
        const saturation = FILE_COLOR_CONFIG.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (FILE_COLOR_CONFIG.lightness ?? 50);
        const hue = getFileHue(fileIdx, totalFiles, fileName);
        if (typeof FILE_COLOR_CONFIG.chroma === 'number') {
            return window.oklchColor(lightness, FILE_COLOR_CONFIG.chroma, hue);
        }
        const adjustedHue = hue + (COLOR_TWEAKS.hueShift || 0);
        const adjustedLightness = window.clampValue(lightness + (COLOR_TWEAKS.lightnessShift || 0), 0, 100);
        return `hsl(${adjustedHue}, ${saturation}%, ${adjustedLightness}%)`;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getTopoColor: getTopoColor,
        normalizeInput: normalizeColorInput,
        toNumber: toColorNumber,
        dim: dimColor,
        getFileHue: getFileHue,
        getFileColor: getFileColor
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getTopoColor = COLOR_HELPERS.getTopoColor;
window.normalizeColorInput = COLOR_HELPERS.normalizeInput;
window.toColorNumber = COLOR_HELPERS.toNumber;
window.dimColor = COLOR_HELPERS.dim;
window.getFileHue = COLOR_HELPERS.getFileHue;
window.getFileColor = COLOR_HELPERS.getFileColor;

console.log('[Module] COLOR_HELPERS loaded - 6 functions');


// ═══ MODULE: modules/color-engine.js ═══
/**
 * COLOR ENGINE MODULE
 *
 * Centralized Color Intelligence System using OKLCH color space.
 * Single source of truth for ALL colors in the visualization.
 * Everything reads from here. OKLCH transforms apply here.
 *
 * Usage:
 *   COLOR.get('tier', 'T0')              // Get hex color for tier T0
 *   COLOR.getInterval('markov', 0.5)     // Get interpolated color
 *   COLOR.setTransform('hueShift', 30)   // Shift all hues by 30 degrees
 *   COLOR.subscribe(callback)            // React to transform changes
 */

const COLOR = (function () {
    'use strict';

    // =========================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =========================================================================

    const palette = {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        atom: {
            // Function-like (Green-Cyan)
            'function': { h: 160, c: 0.20, l: 0.65, label: 'Function', semantic: 'logic' },
            'method': { h: 175, c: 0.20, l: 0.62, label: 'Method', semantic: 'logic' },
            'closure': { h: 190, c: 0.20, l: 0.60, label: 'Closure', semantic: 'logic' },
            // Class-like (Blue-Purple)
            'class': { h: 260, c: 0.22, l: 0.60, label: 'Class', semantic: 'structure' },
            'interface': { h: 280, c: 0.20, l: 0.65, label: 'Interface', semantic: 'abstraction' },
            'struct': { h: 240, c: 0.20, l: 0.60, label: 'Struct', semantic: 'data' },
            // Module/Package (Orange-Yellow)
            'module': { h: 45, c: 0.22, l: 0.70, label: 'Module', semantic: 'container' },
            'package': { h: 30, c: 0.24, l: 0.65, label: 'Package', semantic: 'container' },
            // Variables/Fields (Pink-Red)
            'variable': { h: 340, c: 0.18, l: 0.65, label: 'Variable', semantic: 'state' },
            'field': { h: 350, c: 0.18, l: 0.62, label: 'Field', semantic: 'state' },
            // Unknown
            'unknown': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        roleCategory: {
            'Query': { h: 190, c: 0.20, l: 0.65, label: 'Query', semantic: 'read' },         // Cyan
            'Command': { h: 25, c: 0.24, l: 0.60, label: 'Command', semantic: 'write' },     // Orange/Red
            'Factory': { h: 280, c: 0.22, l: 0.60, label: 'Factory', semantic: 'create' },   // Purple
            'Storage': { h: 140, c: 0.20, l: 0.65, label: 'Storage', semantic: 'persist' },  // Green
            'Orchestration': { h: 240, c: 0.22, l: 0.60, label: 'Orchestration', semantic: 'manage' }, // Blue
            'Validation': { h: 45, c: 0.24, l: 0.70, label: 'Validation', semantic: 'check' }, // Yellow
            'Transform': { h: 320, c: 0.20, l: 0.60, label: 'Transform', semantic: 'change' }, // Pink
            'Event': { h: 260, c: 0.22, l: 0.65, label: 'Event', semantic: 'async' },        // Violet
            'Utility': { h: 200, c: 0.10, l: 0.70, label: 'Utility', semantic: 'helper' },   // Light Blue
            'Internal': { h: 0, c: 0.00, l: 0.60, label: 'Internal', semantic: 'private' },  // Gray
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        subsystem: {
            'Ingress': { h: 220, c: 0.24, l: 0.60, label: 'Ingress', semantic: 'entry' },
            'Egress': { h: 20, c: 0.24, l: 0.60, label: 'Egress', semantic: 'exit' },
            'Domain': { h: 260, c: 0.24, l: 0.55, label: 'Domain Core', semantic: 'core' },
            'Persistence': { h: 142, c: 0.22, l: 0.65, label: 'Persistence', semantic: 'store' },
            'Async': { h: 300, c: 0.22, l: 0.60, label: 'Async', semantic: 'bg' },
            'Presentation': { h: 190, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'ui' },
            'Security': { h: 0, c: 0.26, l: 0.55, label: 'Security', semantic: 'guard' },
            'Observability': { h: 60, c: 0.22, l: 0.75, label: 'Observability', semantic: 'monitor' },
            'Config': { h: 290, c: 0.18, l: 0.65, label: 'config', semantic: 'setup' },
            'Delivery': { h: 30, c: 0.20, l: 0.70, label: 'Delivery', semantic: 'ops' },
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        phase: {
            'DATA': { h: 142, c: 0.22, l: 0.65, label: 'Data', semantic: 'structure' },
            'LOGIC': { h: 240, c: 0.24, l: 0.60, label: 'Logic', semantic: 'flow' },
            'ORGANIZATION': { h: 280, c: 0.22, l: 0.60, label: 'Organization', semantic: 'arch' },
            'EXECUTION': { h: 20, c: 0.26, l: 0.60, label: 'Execution', semantic: 'run' }
        },
        state: {
            'Stateless': { h: 220, c: 0.20, l: 0.70, label: 'Stateless', semantic: 'pure' }, // Light Blue
            'Stateful': { h: 20, c: 0.24, l: 0.60, label: 'Stateful', semantic: 'impure' }   // Orange
        },
        effect: {
            'Pure': { h: 142, c: 0.22, l: 0.70, label: 'Pure', semantic: 'safe' },          // Green
            'SideEffect': { h: 340, c: 0.22, l: 0.60, label: 'Side Effect', semantic: 'risk' } // Pink/Red
        },
        visibility: {
            'Public': { h: 220, c: 0.20, l: 0.65, label: 'Public', semantic: 'open' },
            'Private': { h: 0, c: 0.05, l: 0.55, label: 'Private', semantic: 'closed' },
            'Internal': { h: 280, c: 0.15, l: 0.60, label: 'Internal', semantic: 'module' }
        },
        fileType: {
            'js': { h: 60, c: 0.24, l: 0.70, label: 'JavaScript', semantic: 'code' },    // Yellow
            'ts': { h: 240, c: 0.22, l: 0.60, label: 'TypeScript', semantic: 'code' },    // Blue
            'py': { h: 220, c: 0.20, l: 0.62, label: 'Python', semantic: 'code' },        // Blue
            'go': { h: 190, c: 0.22, l: 0.68, label: 'Go', semantic: 'code' },            // Cyan
            'rs': { h: 30, c: 0.24, l: 0.60, label: 'Rust', semantic: 'code' },           // Orange
            'java': { h: 40, c: 0.24, l: 0.62, label: 'Java', semantic: 'code' },         // Orange/Red
            'c': { h: 210, c: 0.18, l: 0.60, label: 'C', semantic: 'code' },             // Blue
            'cpp': { h: 210, c: 0.20, l: 0.55, label: 'C++', semantic: 'code' },          // Blue
            'h': { h: 280, c: 0.16, l: 0.60, label: 'Header', semantic: 'code' },         // Purple
            'html': { h: 20, c: 0.25, l: 0.60, label: 'HTML', semantic: 'markup' },       // Orange
            'css': { h: 230, c: 0.24, l: 0.60, label: 'CSS', semantic: 'style' },         // Blue
            'json': { h: 60, c: 0.18, l: 0.75, label: 'JSON', semantic: 'data' },         // Yellow
            'yaml': { h: 300, c: 0.18, l: 0.65, label: 'YAML', semantic: 'config' },      // Magenta
            'md': { h: 0, c: 0.04, l: 0.70, label: 'Markdown', semantic: 'doc' },         // Gray
            'unknown': { h: 0, c: 0.02, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    };

    // =========================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =========================================================================

    const transform = {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    };

    // =========================================================================
    // INTERVAL MAPPINGS: For numeric data -> color gradients
    // =========================================================================

    const intervals = {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        },
        complexity: {
            stops: [
                { value: 0.0, h: 142, c: 0.18, l: 0.70 },  // Low complexity (0) - Green
                { value: 0.3, h: 100, c: 0.18, l: 0.75 },  // Moderate (5-10) - Yellow-Green
                { value: 0.6, h: 50, c: 0.20, l: 0.70 },   // High (10-20) - Orange
                { value: 1.0, h: 15, c: 0.24, l: 0.60 }    // Very High (20+) - Red
            ]
        },
        churn: {
            stops: [
                { value: 0.0, h: 230, c: 0.10, l: 0.45 },  // Stale/Cold - Blue
                { value: 0.5, h: 300, c: 0.14, l: 0.60 },  // Active - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // Hot - Orange/Red
            ]
        },
        loc: {
            stops: [
                { value: 0.0, h: 200, c: 0.10, l: 0.75 },  // Small - Light Blue
                { value: 0.3, h: 240, c: 0.18, l: 0.60 },  // Medium - Blue
                { value: 0.7, h: 280, c: 0.20, l: 0.50 },  // Large - Purple
                { value: 1.0, h: 320, c: 0.22, l: 0.40 }   // Massive - Dark Purple
            ]
        },
        trust: {
            stops: [
                { value: 0.0, h: 0, c: 0.24, l: 0.50 },    // Untrusted - Red
                { value: 0.5, h: 60, c: 0.20, l: 0.70 },   // Warning - Yellow
                { value: 1.0, h: 142, c: 0.22, l: 0.65 }   // Trusted - Green
            ]
        },
        responsibility: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Single Purpose (1) - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.75 },   // Moderate (5) - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // God Object (9) - Red
            ]
        },
        purity: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Pure (1) - Green
                { value: 0.5, h: 220, c: 0.18, l: 0.65 },  // Mixed (5) - Blue
                { value: 1.0, h: 320, c: 0.24, l: 0.55 }   // I/O Heavy (9) - Purple/Red
            ]
        },
        boundary_score: {
            stops: [
                { value: 0.0, h: 240, c: 0.15, l: 0.65 },  // Internal (1) - Blue
                { value: 0.5, h: 280, c: 0.18, l: 0.60 },  // Module (5) - Purple
                { value: 1.0, h: 20, c: 0.24, l: 0.60 }    // External API (9) - Orange
            ]
        },
        lifecycle_score: {
            stops: [
                { value: 0.0, h: 180, c: 0.15, l: 0.70 },  // Ephemeral (1) - Cyan
                { value: 0.5, h: 220, c: 0.18, l: 0.60 },  // Managed (5) - Blue
                { value: 1.0, h: 280, c: 0.22, l: 0.50 }   // Singleton (9) - Purple
            ]
        },
        centrality: {
            stops: [
                { value: 0.0, h: 240, c: 0.05, l: 0.40 },  // Periphery - Gray/Blue
                { value: 0.5, h: 280, c: 0.20, l: 0.60 },  // Bridge - Purple
                { value: 1.0, h: 340, c: 0.25, l: 0.65 }   // Core - Pink/Red
            ]
        },
        fan_in: {
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.65 },  // Low - Blue
                { value: 0.5, h: 300, c: 0.18, l: 0.60 },  // Med - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // High - Orange
            ]
        },
        fan_out: {
            stops: [
                { value: 0.0, h: 142, c: 0.15, l: 0.65 },  // Low - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.70 },   // Med - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // High - Red
            ]
        }
    };

    // =========================================================================
    // SCHEME PATHS: 33 Named Color Gradients (OKLCH 3D Paths)
    // Each scheme is a path through OKLCH color space mapping normalized values to colors
    // =========================================================================

    const schemePaths = {
        // =====================================================================
        // PART A: FAMOUS SCIENTIFIC GRADIENTS (15 schemes)
        // Source: matplotlib/viridis family - perceptually uniform
        // =====================================================================

        // === SEQUENTIAL (monotonic lightness) ===
        viridis: {
            name: 'Viridis',
            semantic: 'The gold standard - blue→green→yellow',
            stops: [
                { value: 0.0, h: 280, c: 0.12, l: 0.25 },  // Dark purple
                { value: 0.25, h: 240, c: 0.16, l: 0.40 }, // Blue
                { value: 0.5, h: 170, c: 0.18, l: 0.55 },  // Teal
                { value: 0.75, h: 120, c: 0.20, l: 0.70 }, // Green
                { value: 1.0, h: 65, c: 0.22, l: 0.90 }    // Yellow
            ]
        },
        plasma: {
            name: 'Plasma',
            semantic: 'Purple→pink→orange→yellow arc',
            stops: [
                { value: 0.0, h: 280, c: 0.15, l: 0.20 },  // Deep purple
                { value: 0.25, h: 300, c: 0.22, l: 0.40 }, // Magenta
                { value: 0.5, h: 340, c: 0.25, l: 0.55 },  // Pink-red
                { value: 0.75, h: 30, c: 0.28, l: 0.72 },  // Orange
                { value: 1.0, h: 60, c: 0.24, l: 0.92 }    // Bright yellow
            ]
        },
        magma: {
            name: 'Magma',
            semantic: 'Black→purple→orange→white (lava)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.08 },  // Near black
                { value: 0.25, h: 300, c: 0.18, l: 0.30 }, // Deep purple
                { value: 0.5, h: 340, c: 0.24, l: 0.50 },  // Magenta
                { value: 0.75, h: 30, c: 0.26, l: 0.75 },  // Orange
                { value: 1.0, h: 60, c: 0.08, l: 0.98 }    // Near white
            ]
        },
        inferno: {
            name: 'Inferno',
            semantic: 'Black→purple→red→yellow (fire)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.05 },  // Black
                { value: 0.2, h: 300, c: 0.16, l: 0.25 },  // Purple
                { value: 0.4, h: 350, c: 0.24, l: 0.45 },  // Red-purple
                { value: 0.6, h: 20, c: 0.28, l: 0.60 },   // Red-orange
                { value: 0.8, h: 50, c: 0.26, l: 0.78 },   // Orange-yellow
                { value: 1.0, h: 65, c: 0.18, l: 0.95 }    // Bright yellow
            ]
        },
        cividis: {
            name: 'Cividis',
            semantic: 'Blue→yellow (colorblind optimized)',
            stops: [
                { value: 0.0, h: 240, c: 0.10, l: 0.25 },  // Dark blue
                { value: 0.33, h: 220, c: 0.08, l: 0.45 }, // Steel blue
                { value: 0.66, h: 80, c: 0.08, l: 0.65 },  // Olive
                { value: 1.0, h: 60, c: 0.14, l: 0.88 }    // Yellow
            ]
        },
        turbo: {
            name: 'Turbo',
            semantic: 'Improved rainbow (no banding)',
            stops: [
                { value: 0.0, h: 260, c: 0.18, l: 0.35 },  // Blue-purple
                { value: 0.2, h: 210, c: 0.22, l: 0.55 },  // Cyan-blue
                { value: 0.4, h: 150, c: 0.24, l: 0.65 },  // Green
                { value: 0.6, h: 60, c: 0.26, l: 0.75 },   // Yellow
                { value: 0.8, h: 30, c: 0.28, l: 0.65 },   // Orange
                { value: 1.0, h: 0, c: 0.24, l: 0.50 }     // Red
            ]
        },
        mako: {
            name: 'Mako',
            semantic: 'Deep ocean blue→teal',
            stops: [
                { value: 0.0, h: 260, c: 0.08, l: 0.12 },  // Abyss
                { value: 0.33, h: 240, c: 0.14, l: 0.35 }, // Deep blue
                { value: 0.66, h: 200, c: 0.18, l: 0.58 }, // Ocean blue
                { value: 1.0, h: 170, c: 0.16, l: 0.82 }   // Light teal
            ]
        },
        rocket: {
            name: 'Rocket',
            semantic: 'Dark→red→white (heat)',
            stops: [
                { value: 0.0, h: 280, c: 0.06, l: 0.10 },  // Dark
                { value: 0.33, h: 340, c: 0.20, l: 0.35 }, // Purple-red
                { value: 0.66, h: 15, c: 0.26, l: 0.60 },  // Red-orange
                { value: 1.0, h: 30, c: 0.08, l: 0.95 }    // Near white
            ]
        },

        // === DIVERGING (center-outward) ===
        coolwarm: {
            name: 'Coolwarm',
            semantic: 'Blue↔neutral↔red (diverging)',
            stops: [
                { value: 0.0, h: 230, c: 0.22, l: 0.45 },  // Cool blue
                { value: 0.25, h: 220, c: 0.12, l: 0.60 }, // Light blue
                { value: 0.5, h: 0, c: 0.02, l: 0.75 },    // Neutral gray
                { value: 0.75, h: 20, c: 0.14, l: 0.60 },  // Light red
                { value: 1.0, h: 15, c: 0.24, l: 0.45 }    // Warm red
            ]
        },
        spectral: {
            name: 'Spectral',
            semantic: 'Full rainbow diverging',
            stops: [
                { value: 0.0, h: 10, c: 0.22, l: 0.50 },   // Red
                { value: 0.25, h: 40, c: 0.24, l: 0.70 },  // Orange-yellow
                { value: 0.5, h: 60, c: 0.20, l: 0.85 },   // Yellow (center)
                { value: 0.75, h: 140, c: 0.20, l: 0.65 }, // Green
                { value: 1.0, h: 240, c: 0.18, l: 0.50 }   // Blue
            ]
        },

        // === APPLICATION-SPECIFIC ===
        thermal: {
            name: 'Thermal',
            semantic: 'Cold→hot temperature map',
            stops: [
                { value: 0.0, h: 240, c: 0.18, l: 0.30 },  // Cold blue
                { value: 0.25, h: 200, c: 0.20, l: 0.45 }, // Cool cyan
                { value: 0.5, h: 60, c: 0.22, l: 0.65 },   // Warm yellow
                { value: 0.75, h: 30, c: 0.26, l: 0.58 },  // Hot orange
                { value: 1.0, h: 0, c: 0.28, l: 0.50 }     // Burning red
            ]
        },
        nightvision: {
            name: 'Night Vision',
            semantic: 'Phosphor green display',
            stops: [
                { value: 0.0, h: 140, c: 0.02, l: 0.05 },  // Black
                { value: 0.33, h: 140, c: 0.12, l: 0.25 }, // Dark green
                { value: 0.66, h: 130, c: 0.22, l: 0.55 }, // Bright green
                { value: 1.0, h: 120, c: 0.28, l: 0.85 }   // Glowing green
            ]
        },
        ocean: {
            name: 'Ocean',
            semantic: 'Bathymetry depth map',
            stops: [
                { value: 0.0, h: 250, c: 0.12, l: 0.15 },  // Abyss
                { value: 0.33, h: 230, c: 0.18, l: 0.35 }, // Deep
                { value: 0.66, h: 200, c: 0.20, l: 0.55 }, // Mid-depth
                { value: 1.0, h: 180, c: 0.16, l: 0.80 }   // Shallow
            ]
        },
        terrain: {
            name: 'Terrain',
            semantic: 'Water→land→mountain',
            stops: [
                { value: 0.0, h: 220, c: 0.16, l: 0.40 },  // Water blue
                { value: 0.3, h: 140, c: 0.18, l: 0.55 },  // Lowland green
                { value: 0.5, h: 80, c: 0.16, l: 0.60 },   // Plains yellow-green
                { value: 0.7, h: 40, c: 0.14, l: 0.50 },   // Hills brown
                { value: 1.0, h: 0, c: 0.04, l: 0.90 }     // Snow white
            ]
        },
        electric: {
            name: 'Electric',
            semantic: 'Neon cyberpunk glow',
            stops: [
                { value: 0.0, h: 280, c: 0.25, l: 0.30 },  // Deep purple
                { value: 0.33, h: 320, c: 0.30, l: 0.50 }, // Hot pink
                { value: 0.66, h: 190, c: 0.28, l: 0.65 }, // Electric cyan
                { value: 1.0, h: 60, c: 0.26, l: 0.85 }    // Neon yellow
            ]
        },

        // =====================================================================
        // PART B: ROLE-SEMANTIC GRADIENTS (18 schemes)
        // Named after canonical roles with meaningful color journeys
        // =====================================================================

        // === GROUP 1: QUERIES & ACCESS (Cool blues/cyans - passive reads) ===
        query: {
            name: 'Query',
            semantic: 'Retrieve data calmly',
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },  // Deep blue - start
                { value: 0.5, h: 200, c: 0.15, l: 0.55 },  // Sky blue - middle
                { value: 1.0, h: 190, c: 0.20, l: 0.70 }   // Light cyan - found
            ]
        },
        finder: {
            name: 'Finder',
            semantic: 'Search and seek',
            stops: [
                { value: 0.0, h: 200, c: 0.05, l: 0.35 },  // Dim - searching
                { value: 0.3, h: 180, c: 0.12, l: 0.50 },  // Teal - hunting
                { value: 0.7, h: 160, c: 0.18, l: 0.65 },  // Cyan-green - close
                { value: 1.0, h: 140, c: 0.24, l: 0.75 }   // Bright green - found!
            ]
        },

        // === GROUP 2: COMMANDS & MUTATIONS (Warm - active writes) ===
        command: {
            name: 'Command',
            semantic: 'Execute with authority',
            stops: [
                { value: 0.0, h: 30, c: 0.15, l: 0.45 },   // Amber ready
                { value: 0.5, h: 20, c: 0.22, l: 0.58 },   // Orange active
                { value: 1.0, h: 10, c: 0.28, l: 0.65 }    // Red-orange fired
            ]
        },
        creator: {
            name: 'Creator',
            semantic: 'Bring into existence',
            stops: [
                { value: 0.0, h: 180, c: 0.10, l: 0.40 },  // Seed teal
                { value: 0.4, h: 150, c: 0.18, l: 0.55 },  // Sprout green
                { value: 0.8, h: 120, c: 0.24, l: 0.68 },  // Growth lime
                { value: 1.0, h: 90, c: 0.28, l: 0.75 }    // Full bloom yellow-green
            ]
        },
        destroyer: {
            name: 'Destroyer',
            semantic: 'Remove from existence',
            stops: [
                { value: 0.0, h: 0, c: 0.08, l: 0.60 },    // Pale warning
                { value: 0.4, h: 10, c: 0.18, l: 0.50 },   // Red alert
                { value: 0.7, h: 350, c: 0.26, l: 0.40 },  // Crimson
                { value: 1.0, h: 340, c: 0.20, l: 0.25 }   // Dark destruction
            ]
        },

        // === GROUP 3: FACTORIES (Construction - blue→green) ===
        factory: {
            name: 'Factory',
            semantic: 'Assembly line production',
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.45 },  // Blueprint blue
                { value: 0.3, h: 200, c: 0.16, l: 0.55 },  // Processing
                { value: 0.6, h: 170, c: 0.20, l: 0.62 },  // Assembly
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Product green
            ]
        },

        // === GROUP 4: STORAGE (Solid, grounded - deep blues/purples) ===
        repository: {
            name: 'Repository',
            semantic: 'Deep data vault',
            stops: [
                { value: 0.0, h: 240, c: 0.12, l: 0.30 },  // Database depths
                { value: 0.5, h: 230, c: 0.18, l: 0.45 },  // Data layer
                { value: 1.0, h: 220, c: 0.22, l: 0.60 }   // Accessible
            ]
        },
        cache: {
            name: 'Cache',
            semantic: 'Fast temporary',
            stops: [
                { value: 0.0, h: 300, c: 0.08, l: 0.50 },  // Magenta flash
                { value: 0.5, h: 320, c: 0.16, l: 0.62 },  // Pink speed
                { value: 1.0, h: 340, c: 0.22, l: 0.75 }   // Hot pink hit
            ]
        },

        // === GROUP 5: ORCHESTRATION (Purple/magenta - control flow) ===
        service: {
            name: 'Service',
            semantic: 'Coordinate operations',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Purple quiet
                { value: 0.5, h: 280, c: 0.16, l: 0.55 },  // Active violet
                { value: 1.0, h: 290, c: 0.22, l: 0.68 }   // Bright orchid
            ]
        },
        orchestrator: {
            name: 'Orchestrator',
            semantic: 'See all, conduct all',
            stops: [
                { value: 0.0, h: 200, c: 0.12, l: 0.40 },  // Start blue
                { value: 0.25, h: 270, c: 0.18, l: 0.50 }, // Through purple
                { value: 0.5, h: 330, c: 0.22, l: 0.58 },  // To pink
                { value: 0.75, h: 30, c: 0.24, l: 0.62 },  // Through orange
                { value: 1.0, h: 60, c: 0.26, l: 0.70 }    // End gold (full spectrum)
            ]
        },

        // === GROUP 6: VALIDATION (Yellow/green - pass/fail semantics) ===
        validator: {
            name: 'Validator',
            semantic: 'Check and verify',
            stops: [
                { value: 0.0, h: 0, c: 0.20, l: 0.50 },    // Red fail
                { value: 0.4, h: 45, c: 0.22, l: 0.65 },   // Yellow warning
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Green pass
            ]
        },
        guard: {
            name: 'Guard',
            semantic: 'Protect and defend',
            stops: [
                { value: 0.0, h: 350, c: 0.18, l: 0.40 },  // Dark red blocked
                { value: 0.5, h: 30, c: 0.20, l: 0.55 },   // Orange caution
                { value: 1.0, h: 120, c: 0.22, l: 0.65 }   // Green allowed
            ]
        },

        // === GROUP 7: TRANSFORMATION (Rainbow arc - any to any) ===
        transformer: {
            name: 'Transformer',
            semantic: 'Complete metamorphosis',
            stops: [
                { value: 0.0, h: 220, c: 0.14, l: 0.45 },  // Blue input
                { value: 0.3, h: 280, c: 0.18, l: 0.52 },  // Purple process
                { value: 0.6, h: 340, c: 0.22, l: 0.58 },  // Pink transition
                { value: 1.0, h: 30, c: 0.26, l: 0.65 }    // Orange output
            ]
        },
        parser: {
            name: 'Parser',
            semantic: 'Decode from wire',
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.85 },    // White wire
                { value: 0.5, h: 180, c: 0.10, l: 0.70 },  // Decoding
                { value: 1.0, h: 160, c: 0.20, l: 0.55 }   // Data teal
            ]
        },

        // === GROUP 8: EVENTS (Signals - purple/yellow pulses) ===
        handler: {
            name: 'Handler',
            semantic: 'React to event',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Waiting purple
                { value: 0.5, h: 290, c: 0.18, l: 0.55 },  // Triggered
                { value: 1.0, h: 310, c: 0.26, l: 0.68 }   // Handling pink
            ]
        },
        emitter: {
            name: 'Emitter',
            semantic: 'Broadcast signal',
            stops: [
                { value: 0.0, h: 50, c: 0.18, l: 0.55 },   // Yellow charge
                { value: 0.5, h: 45, c: 0.24, l: 0.68 },   // Bright emit
                { value: 1.0, h: 40, c: 0.30, l: 0.78 }    // Golden broadcast
            ]
        },

        // === GROUP 9: UTILITIES (Neutral supporting - grays/pastels) ===
        utility: {
            name: 'Utility',
            semantic: 'General tool',
            stops: [
                { value: 0.0, h: 220, c: 0.04, l: 0.45 },  // Gray-blue tool
                { value: 0.5, h: 200, c: 0.08, l: 0.58 },  // Soft cyan
                { value: 1.0, h: 180, c: 0.12, l: 0.72 }   // Light teal
            ]
        },
        lifecycle: {
            name: 'Lifecycle',
            semantic: 'Birth to death cycle',
            stops: [
                { value: 0.0, h: 120, c: 0.20, l: 0.65 },  // Birth green
                { value: 0.25, h: 60, c: 0.22, l: 0.70 },  // Youth yellow
                { value: 0.5, h: 30, c: 0.24, l: 0.60 },   // Maturity orange
                { value: 0.75, h: 0, c: 0.20, l: 0.50 },   // Aging red
                { value: 1.0, h: 280, c: 0.10, l: 0.35 }   // Death purple
            ]
        },

        // =====================================================================
        // PART C: OKLCH GEOMETRY GENERATORS (Function-based paths)
        // These use mathematical functions instead of discrete stops.
        // Each has a `generator` function: (t) => { h, c, l }
        // =====================================================================

        // === LOOPS (Full 360° hue cycles) ===
        'rainbow-loop': {
            name: 'Rainbow Loop',
            semantic: 'Full hue circle at constant L/C',
            generator: (t) => ({
                h: t * 360,           // Full hue rotation
                c: 0.20,              // Constant chroma
                l: 0.65               // Constant lightness
            })
        },
        'rainbow-bright': {
            name: 'Rainbow Bright',
            semantic: 'Vivid rainbow with high chroma',
            generator: (t) => ({
                h: t * 360,
                c: 0.28,              // High chroma for vivid colors
                l: 0.70
            })
        },
        'rainbow-dark': {
            name: 'Rainbow Dark',
            semantic: 'Subdued rainbow for dark themes',
            generator: (t) => ({
                h: t * 360,
                c: 0.18,
                l: 0.45               // Lower lightness
            })
        },

        // === ARCS (Partial hue sweeps) ===
        'arc-warm': {
            name: 'Warm Arc',
            semantic: 'Red→Yellow→Orange (warm sector)',
            generator: (t) => ({
                h: 0 + t * 60,        // 0° to 60° (red to yellow)
                c: 0.24,
                l: 0.55 + t * 0.15    // Slight lightness increase
            })
        },
        'arc-cool': {
            name: 'Cool Arc',
            semantic: 'Cyan→Blue→Purple (cool sector)',
            generator: (t) => ({
                h: 180 + t * 100,     // 180° to 280° (cyan to purple)
                c: 0.22,
                l: 0.50 + t * 0.15
            })
        },
        'arc-nature': {
            name: 'Nature Arc',
            semantic: 'Green→Teal→Cyan (nature)',
            generator: (t) => ({
                h: 120 + t * 60,      // 120° to 180° (green to cyan)
                c: 0.20,
                l: 0.60 + t * 0.10
            })
        },

        // === SPIRALS (Hue + varying L or C) ===
        'spiral-up': {
            name: 'Spiral Up',
            semantic: 'Hue rotates as lightness increases',
            generator: (t) => ({
                h: t * 270,           // 3/4 hue rotation
                c: 0.18,
                l: 0.30 + t * 0.55    // Dark to light
            })
        },
        'spiral-down': {
            name: 'Spiral Down',
            semantic: 'Hue rotates as lightness decreases',
            generator: (t) => ({
                h: t * 270,
                c: 0.20,
                l: 0.85 - t * 0.55    // Light to dark
            })
        },
        'spiral-chroma': {
            name: 'Spiral Chroma',
            semantic: 'Hue rotates as saturation increases',
            generator: (t) => ({
                h: t * 360,
                c: 0.06 + t * 0.22,   // Gray to vivid
                l: 0.60
            })
        },

        // === SINUSOIDAL (Wave patterns) ===
        'wave-lightness': {
            name: 'Wave Lightness',
            semantic: 'Sinusoidal lightness oscillation',
            generator: (t) => ({
                h: t * 180,           // Half hue rotation
                c: 0.20,
                l: 0.50 + Math.sin(t * Math.PI * 2) * 0.20  // Wave between 0.30 and 0.70
            })
        },
        'wave-chroma': {
            name: 'Wave Chroma',
            semantic: 'Sinusoidal saturation oscillation',
            generator: (t) => ({
                h: t * 180,
                c: 0.15 + Math.sin(t * Math.PI * 2) * 0.12, // Wave between 0.03 and 0.27
                l: 0.60
            })
        },
        'pulse': {
            name: 'Pulse',
            semantic: 'Both L and C oscillate together',
            generator: (t) => {
                const wave = Math.sin(t * Math.PI * 3); // 1.5 full waves
                return {
                    h: t * 120,       // Partial hue sweep
                    c: 0.15 + wave * 0.10,
                    l: 0.55 + wave * 0.15
                };
            }
        },

        // === LINEAR RAMPS (Simple mathematical paths) ===
        'ramp-hue': {
            name: 'Hue Ramp',
            semantic: 'Pure hue change, constant L/C',
            generator: (t) => ({
                h: 220 + t * 140,     // Blue to pink (220° to 360°)
                c: 0.22,
                l: 0.60
            })
        },
        'ramp-lightness': {
            name: 'Lightness Ramp',
            semantic: 'Dark to light, constant H/C',
            generator: (t) => ({
                h: 220,               // Fixed blue
                c: 0.18,
                l: 0.25 + t * 0.60    // 0.25 to 0.85
            })
        },
        'ramp-chroma': {
            name: 'Chroma Ramp',
            semantic: 'Gray to vivid, constant H/L',
            generator: (t) => ({
                h: 280,               // Fixed purple
                c: 0.02 + t * 0.26,   // 0.02 to 0.28
                l: 0.60
            })
        },

        // === SPECIAL GEOMETRIC PATHS ===
        'helix': {
            name: 'Helix',
            semantic: 'Full 3D path through OKLCH cylinder',
            generator: (t) => ({
                h: t * 540,           // 1.5 hue rotations
                c: 0.10 + t * 0.15,   // Increasing chroma
                l: 0.30 + t * 0.50    // Rising lightness
            })
        },
        'convergent': {
            name: 'Convergent',
            semantic: 'Colors converge toward gray',
            generator: (t) => ({
                h: t * 180,           // Half rotation
                c: 0.26 * (1 - t),    // Chroma decreases to 0
                l: 0.55
            })
        },
        'divergent': {
            name: 'Divergent',
            semantic: 'Colors diverge from gray',
            generator: (t) => ({
                h: 180 + t * 180,     // Second half of hue wheel
                c: 0.26 * t,          // Chroma increases from 0
                l: 0.55
            })
        },
        'bicone': {
            name: 'Bicone',
            semantic: 'Center peak, edges dark (HSL-like)',
            generator: (t) => {
                // Lightness peaks at center, dark at edges
                const l = t < 0.5 ? 0.30 + t * 0.70 : 0.65 - (t - 0.5) * 0.70;
                return {
                    h: t * 360,
                    c: 0.20,
                    l: Math.max(0.30, l)
                };
            }
        }
    };

    // Current active scheme
    let _activeScheme = null;

// =========================================================================
// SUBSCRIBERS: Reactive notifications
// =========================================================================

let _subscribers = [];

function subscribe(callback) {
    _subscribers.push(callback);
    return () => {
        _subscribers = _subscribers.filter(cb => cb !== callback);
    };
}

function _notifySubscribers(event, data) {
    _subscribers.forEach(cb => cb(event, data));
}

// =========================================================================
// OKLCH -> HEX CONVERSION
// =========================================================================

function _toHex(oklch) {
    const { h, c, l } = oklch;

    // Convert OKLCH to approximate RGB
    const hRad = h * Math.PI / 180;
    const a = c * Math.cos(hRad);
    const b = c * Math.sin(hRad);

    // Simplified OKLab to linear RGB (approximate)
    const L = l;
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    const l3 = l_ * l_ * l_;
    const m3 = m_ * m_ * m_;
    const s3 = s_ * s_ * s_;

    let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
    let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
    let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

    // Clamp and convert to sRGB
    const toSRGB = (x) => {
        x = Math.max(0, Math.min(1, x));
        return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
    };

    r = Math.round(toSRGB(r) * 255);
    g = Math.round(toSRGB(g) * 255);
    bl = Math.round(toSRGB(bl) * 255);

    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    bl = Math.max(0, Math.min(255, bl));

    return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
}

function _applyTransform(oklch) {
    const t = transform;

    // Apply transforms
    let h = (oklch.h + t.hueShift + 360) % 360;
    let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
    let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

    // Apply amplifier to chroma for contrast
    if (t.amplifier !== 1) {
        c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
    }

    return _toHex({ h, c, l });
}

// =========================================================================
// CORE API
// =========================================================================

/**
 * Get color with transforms applied
 * @param {string} dimension - Palette dimension (tier, family, ring, layer, edgeType)
 * @param {string} category - Category within dimension
 * @returns {string} Hex color string
 */
function get(dimension, category) {
    const base = palette[dimension]?.[category];
    if (!base) return _toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray
    return _applyTransform(base);
}

/**
 * Get color for a numeric value using interval mapping
 * @param {string} intervalName - Interval name (markov, weight, confidence)
 * @param {number} value - Value (0-1)
 * @returns {string} Hex color string
 */
function getInterval(intervalName, value) {
    const v = Math.max(0, Math.min(1, value));

    // =========================================================================
    // SCHEME OVERRIDE: If an active scheme is selected, use it for ALL intervals
    // This makes the 33 named schemes (viridis, plasma, thermal, etc.) work
    // =========================================================================
    if (_activeScheme && schemePaths[_activeScheme]) {
        return getSchemeColor(_activeScheme, v);
    }

    // Fall back to hardcoded interval if no scheme active
    const interval = intervals[intervalName];
    if (!interval) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const stops = interval.stops;

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const t = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * t,
        c: lower.c + (upper.c - lower.c) * t,
        l: lower.l + (upper.l - lower.l) * t
    };

    return _applyTransform(interpolated);
}

/**
 * Interpolate between two hex colors in OKLCH space
 * @param {string} color1 - Hex color 1
 * @param {string} color2 - Hex color 2
 * @param {number} t - Interpolation factor (0-1)
 * @returns {string} Hex result
 */
function interpolate(color1, color2, t) {
    // We assume input hexes can be approximated back to OKLCH or treated as sRGB->OKLCH
    // For simplicity in this engine which mostly generates from OKLCH, we'll assume
    // specific OKLCH-derived palettes unless provided raw hex.
    // If we really need robust hex->oklch, we need a converter.
    // BUT, for edge gradients in app.js, we often have raw HSL or OKLCH objects.
    // Let's support passing Objects {h,c,l} or hex strings (naive interpolation for hex if needed).
    // Best approach: app.js should use COLOR.get() to get objects if possible, or we expose a helper
    // that takes our internal palette objects.

    // Actually, let's keep it simple: assume app.js will partial refactoring.
    // We will accept object {h,c,l} inputs for maximum precision.
    const c1 = (typeof color1 === 'string') ? parseOklchString(color1) || { h: 0, c: 0, l: 0.5 } : color1;
    const c2 = (typeof color2 === 'string') ? parseOklchString(color2) || { h: 0, c: 0, l: 0.5 } : color2;

    t = Math.max(0, Math.min(1, t));

    // Shortest path hue interpolation
    let h1 = c1.h || c1.H || 0;
    let h2 = c2.h || c2.H || 0;
    let dh = h2 - h1;
    if (Math.abs(dh) > 180) {
        if (dh > 0) h1 += 360;
        else h2 += 360;
    }

    const h = (h1 + (h2 - h1) * t) % 360;
    const c = (c1.c !== undefined ? c1.c : c1.C) + ((c2.c !== undefined ? c2.c : c2.C) - (c1.c !== undefined ? c1.c : c1.C)) * t;
    const l = (c1.l !== undefined ? c1.l : c1.L) + ((c2.l !== undefined ? c2.l : c2.L) - (c1.l !== undefined ? c1.l : c1.L)) * t;

    return _applyTransform({ h, c, l });
}

/**
 * Get raw OKLCH values (for advanced use)
 */
function getRaw(dimension, category) {
    return palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
}

/**
 * Get all categories for a dimension
 */
function getCategories(dimension) {
    return Object.keys(palette[dimension] || {});
}

/**
 * Get label for a category
 */
function getLabel(dimension, category) {
    return palette[dimension]?.[category]?.label || category;
}

// =========================================================================
// TRANSFORM CONTROLS
// =========================================================================

function setTransform(key, value) {
    if (key in transform) {
        transform[key] = value;
        _notifySubscribers('transform-change', { key, value });
    }
}

function setAllTransforms(transforms) {
    Object.assign(transform, transforms);
    _notifySubscribers('transform-change', transforms);
}

function resetTransforms() {
    transform.hueShift = 0;
    transform.chromaScale = 1.0;
    transform.lightnessShift = 0;
    transform.amplifier = 1.0;
    _notifySubscribers('transform-change', transform);
}

function getTransform() {
    return { ...transform };
}

// =========================================================================
// SCHEME API: Named Color Gradients
// =========================================================================

/**
 * List all available scheme names
 * @returns {string[]} Array of scheme names
 */
function listSchemes() {
    return Object.keys(schemePaths);
}

/**
 * Get scheme definition
 * @param {string} schemeName - Name of the scheme
 * @returns {object|null} Scheme definition with name, semantic, and stops
 */
function getScheme(schemeName) {
    return schemePaths[schemeName] || null;
}

/**
 * Get color at position t (0-1) along a scheme path
 * Supports both:
 *   - stops: Array of discrete points (interpolated)
 *   - generator: Function (t) => { h, c, l } (direct mathematical path)
 *
 * @param {string} schemeName - Name of the scheme
 * @param {number} t - Position along path (0-1)
 * @returns {string} Hex color string
 */
function getSchemeColor(schemeName, t) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const v = Math.max(0, Math.min(1, t));

    // GENERATOR MODE: Mathematical function (OKLCH geometry)
    if (scheme.generator && typeof scheme.generator === 'function') {
        const oklch = scheme.generator(v);
        return _applyTransform(oklch);
    }

    // STOPS MODE: Discrete points with interpolation
    const stops = scheme.stops;
    if (!stops || stops.length === 0) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const interp = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * interp,
        c: lower.c + (upper.c - lower.c) * interp,
        l: lower.l + (upper.l - lower.l) * interp
    };

    return _applyTransform(interpolated);
}

/**
 * Apply a scheme as the active color scheme
 * This sets transforms and notifies subscribers
 * @param {string} schemeName - Name of the scheme
 */
function applyScheme(schemeName) {
    // Allow null/undefined to clear the active scheme
    if (!schemeName) {
        _activeScheme = null;
        _notifySubscribers('scheme-change', { scheme: null, definition: null });
        console.log('[COLOR] Cleared active scheme, using default intervals');
        return;
    }

    const scheme = schemePaths[schemeName];
    if (!scheme) {
        console.warn('[COLOR] Unknown scheme:', schemeName);
        return;
    }

    _activeScheme = schemeName;
    _notifySubscribers('scheme-change', { scheme: schemeName, definition: scheme });
    console.log('[COLOR] Applied scheme:', schemeName, '-', scheme.semantic);
}

/**
 * Get the currently active scheme name
 * @returns {string|null} Active scheme name or null
 */
function getActiveScheme() {
    return _activeScheme;
}

/**
 * Generate a CSS gradient string for a scheme (for UI previews)
 * @param {string} schemeName - Name of the scheme
 * @param {string} direction - CSS gradient direction (default: 'to right')
 * @returns {string} CSS linear-gradient string
 */
function getSchemeGradientCSS(schemeName, direction = 'to right') {
    const scheme = schemePaths[schemeName];
    if (!scheme) return 'linear-gradient(to right, #333, #666)';

    const colorStops = scheme.stops.map(stop => {
        const color = _applyTransform(stop);
        const percent = Math.round(stop.value * 100);
        return `${color} ${percent}%`;
    });

    return `linear-gradient(${direction}, ${colorStops.join(', ')})`;
}

/**
 * Get scheme metadata (name, semantic description)
 * @param {string} schemeName - Name of the scheme
 * @returns {object} {name, semantic}
 */
function getSchemeInfo(schemeName) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return { name: schemeName, semantic: 'Unknown' };
    return { name: scheme.name, semantic: scheme.semantic };
}

// =========================================================================
// DEBUG
// =========================================================================

function debug() {
    console.log('[COLOR] Transform state:', transform);
    console.log('[COLOR] Palette dimensions:', Object.keys(palette));
    console.log('[COLOR] Interval mappings:', Object.keys(intervals));
    console.log('[COLOR] Schemes:', Object.keys(schemePaths).length, 'available');
    console.log('[COLOR] Active scheme:', _activeScheme);
}

// =========================================================================
// PUBLIC API
// =========================================================================

return {
    // Core API
    get,
    getInterval,
    getRaw,
    getCategories,
    getLabel,
    interpolate,

    // Transform controls
    setTransform,
    setAllTransforms,
    resetTransforms,
    getTransform,

    // Scheme API (33 named color gradients)
    listSchemes,
    getScheme,
    getSchemeColor,
    applyScheme,
    getActiveScheme,
    getSchemeGradientCSS,
    getSchemeInfo,

    // Subscriptions
    subscribe,

    // Internal access (for migration)
    palette,
    intervals,
    transform,
    schemePaths,

    // Debug
    debug
};
}) ();

// Export to window for global access
window.COLOR = COLOR;

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'ColorOrchestrator', { get: () => COLOR, configurable: true });
Object.defineProperty(window, 'Color', { get: () => COLOR, configurable: true });

console.log('[Module] COLOR loaded - OKLCH color engine with', Object.keys(COLOR.schemePaths || {}).length, 'schemes');


// ═══ MODULE: modules/refresh-throttle.js ═══
/**
 * REFRESH THROTTLE MODULE
 *
 * Prevents excessive Graph.refresh() calls that can cause performance issues.
 * Implements frame-budget-aware throttling at 60fps max.
 *
 * Fixes ARCH-003: Unthrottled Graph.refresh() calls
 *
 * Usage:
 *   REFRESH.throttled()     // Request a throttled refresh
 *   REFRESH.force()         // Force immediate refresh (use sparingly)
 *   REFRESH.stats           // Get refresh statistics
 */

const REFRESH = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        minInterval: 16,      // 60fps max (1000ms / 60 = 16.67ms)
        maxPending: 3,        // Max queued refresh requests before forcing
        logThreshold: 100     // Log warning if more than N refreshes/second
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _pending = false;
    let _lastRefresh = 0;
    let _rafId = null;
    let _pendingCount = 0;

    // Statistics
    let _stats = {
        totalCalls: 0,
        throttledCalls: 0,
        actualRefreshes: 0,
        lastSecondRefreshes: 0,
        currentSecondRefreshes: 0,
        lastSecond: 0
    };

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Request a throttled graph refresh.
     * Multiple calls within the same frame are coalesced into one refresh.
     */
    function throttled() {
        _stats.totalCalls++;
        _pendingCount++;

        // Track calls per second for diagnostics
        const now = performance.now();
        const currentSecond = Math.floor(now / 1000);
        if (currentSecond !== _stats.lastSecond) {
            _stats.lastSecondRefreshes = _stats.currentSecondRefreshes;
            _stats.currentSecondRefreshes = 0;
            _stats.lastSecond = currentSecond;

            // Warn if too many refreshes
            if (_stats.lastSecondRefreshes > CONFIG.logThreshold) {
                console.warn(`[REFRESH] High refresh rate: ${_stats.lastSecondRefreshes}/s`);
            }
        }

        // If already pending, don't queue another
        if (_pending) {
            _stats.throttledCalls++;

            // Force refresh if too many pending
            if (_pendingCount >= CONFIG.maxPending) {
                _doRefresh();
            }
            return;
        }

        // Check if enough time has passed since last refresh
        const elapsed = now - _lastRefresh;
        if (elapsed >= CONFIG.minInterval) {
            // Enough time passed, refresh immediately
            _doRefresh();
        } else {
            // Schedule refresh for next frame
            _pending = true;
            _rafId = requestAnimationFrame(() => {
                _pending = false;
                _doRefresh();
            });
        }
    }

    /**
     * Force an immediate refresh, bypassing throttle.
     * Use sparingly - for critical updates only.
     */
    function force() {
        // Cancel any pending throttled refresh
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _doRefresh();
    }

    /**
     * Internal: Perform the actual refresh
     */
    function _doRefresh() {
        _lastRefresh = performance.now();
        _pendingCount = 0;
        _stats.actualRefreshes++;
        _stats.currentSecondRefreshes++;

        // Call the global Graph.refresh() if available
        if (typeof Graph !== 'undefined' && Graph && Graph.refresh) {
            Graph.refresh();
        }
    }

    /**
     * Cancel any pending refresh
     */
    function cancel() {
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _pendingCount = 0;
    }

    /**
     * Reset statistics
     */
    function resetStats() {
        _stats = {
            totalCalls: 0,
            throttledCalls: 0,
            actualRefreshes: 0,
            lastSecondRefreshes: 0,
            currentSecondRefreshes: 0,
            lastSecond: 0
        };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        throttled,
        force,
        cancel,
        resetStats,

        // Config (read-only access, can be modified via setConfig)
        get config() { return { ...CONFIG }; },
        setConfig(key, value) {
            if (key in CONFIG) {
                CONFIG[key] = value;
            }
        },

        // Statistics
        get stats() {
            return {
                ..._stats,
                throttleRatio: _stats.totalCalls > 0
                    ? (_stats.throttledCalls / _stats.totalCalls * 100).toFixed(1) + '%'
                    : '0%',
                pending: _pending,
                pendingCount: _pendingCount
            };
        },

        // Debug
        debug() {
            console.log('[REFRESH] Stats:', this.stats);
            console.log('[REFRESH] Config:', CONFIG);
        }
    };
})();


// ═══ MODULE: modules/legend-manager.js ═══
/**
 * LEGEND MANAGER MODULE
 *
 * Manages legend data, counts, and visibility for all visualization dimensions.
 * Delegates all color operations to the COLOR module.
 *
 * Depends on: COLOR, NODE
 *
 * Usage:
 *   LEGEND.init(nodes, links)           // Initialize with graph data
 *   LEGEND.getLegendData('tier')        // Get legend items for a dimension
 *   LEGEND.getColor('tier', 'T0')       // Get color (delegates to COLOR)
 *   LEGEND.subscribe(callback)          // React to legend changes
 */

const LEGEND = (function() {
    'use strict';

    // =========================================================================
    // DIMENSION METADATA
    // =========================================================================

    const dimensions = {
        tier: {
            name: 'TIERS',
            icon: '◐',
            extract: (node) => NODE.getTier(node)
        },
        family: {
            name: 'FAMILIES',
            icon: '⬡',
            extract: (node) => NODE.getFamily(node)
        },
        ring: {
            name: 'RINGS',
            icon: '◎',
            extract: (node) => NODE.getRing(node)
        },
        layer: {
            name: 'LAYERS',
            icon: '☰',
            extract: (node) => NODE.getLayer(node).toUpperCase()
        },
        effect: {
            name: 'EFFECTS',
            icon: '⚡',
            extract: (node) => NODE.getEffect(node)
        },
        edgeType: {
            name: 'EDGE TYPES',
            icon: '→',
            extract: (link) => (link.edge_type || link.type || 'unknown').toLowerCase()
        },
        edgeFamily: {
            name: 'EDGE FAMILIES',
            icon: '⇢',
            extract: (link) => (link.family || 'Dependency')
        }
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _counts = {};
    let _subscribers = [];

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Initialize legend with nodes and links data
     */
    function init(nodes, links) {
        _computeCounts(nodes, links);
        return LEGEND;
    }

    /**
     * Compute counts for all dimensions
     */
    function _computeCounts(nodes, links) {
        _counts = {};

        // Node dimensions
        ['tier', 'family', 'ring', 'layer', 'effect'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (nodes || []).forEach(node => {
                const cat = extract(node);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        // Edge dimensions
        ['edgeType', 'edgeFamily'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (links || []).forEach(link => {
                const cat = extract(link);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        console.log('[LEGEND] Counts computed:', Object.keys(_counts));
        _notifySubscribers('counts-updated', _counts);
    }

    /**
     * Get legend data for a dimension
     * Returns array of { id, label, color, count, dimension }
     */
    function getLegendData(dimension) {
        const counts = _counts[dimension] || {};

        return Object.keys(counts)
            .filter(cat => counts[cat] > 0)
            .sort((a, b) => (counts[b] || 0) - (counts[a] || 0))
            .map(cat => ({
                id: cat,
                label: COLOR.getLabel(dimension, cat),
                color: COLOR.get(dimension, cat),
                count: counts[cat] || 0,
                dimension: dimension
            }));
    }

    /**
     * Get color for a dimension/category (delegates to COLOR)
     */
    function getColor(dimension, category) {
        return COLOR.get(dimension, category);
    }

    /**
     * Get counts for a dimension
     */
    function getCounts(dimension) {
        return _counts[dimension] || {};
    }

    /**
     * Get all available dimensions
     */
    function getDimensions() {
        return Object.keys(dimensions);
    }

    /**
     * Get dimension metadata
     */
    function getDimensionMeta(dimension) {
        return dimensions[dimension] || null;
    }

    // =========================================================================
    // SUBSCRIPTIONS
    // =========================================================================

    function subscribe(callback) {
        _subscribers.push(callback);
        return () => {
            _subscribers = _subscribers.filter(cb => cb !== callback);
        };
    }

    function _notifySubscribers(event, data) {
        _subscribers.forEach(cb => cb(event, data));
    }

    // =========================================================================
    // DOM RENDERING
    // =========================================================================

    /**
     * Render a legend section to the DOM
     * @param {string} containerId - DOM container ID
     * @param {string} dimension - Dimension to render (tier, family, etc.)
     * @param {Set} stateSet - Filter state set (items to show)
     * @param {Function} onUpdate - Callback when filter changes
     */
    function renderSection(containerId, dimension, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        const legendData = getLegendData(dimension);
        if (!legendData || legendData.length === 0) return;

        // Build legend items
        legendData.forEach(item => {
            const el = document.createElement('div');
            el.className = 'topo-legend-item' + (stateSet && !stateSet.has(item.id) ? ' filtered' : '');
            el.dataset.category = item.id;
            el.dataset.dimension = dimension;

            // Color swatch
            const swatch = document.createElement('span');
            swatch.className = 'topo-legend-swatch';
            swatch.style.backgroundColor = item.color;

            // Label with count
            const label = document.createElement('span');
            label.className = 'topo-legend-label';
            label.textContent = item.id;

            const count = document.createElement('span');
            count.className = 'topo-legend-count';
            count.textContent = `(${item.count})`;

            el.appendChild(swatch);
            el.appendChild(label);
            el.appendChild(count);

            // Click to toggle filter
            if (stateSet) {
                el.addEventListener('click', () => {
                    if (stateSet.has(item.id)) {
                        stateSet.delete(item.id);
                        el.classList.add('filtered');
                    } else {
                        stateSet.add(item.id);
                        el.classList.remove('filtered');
                    }
                    if (onUpdate) onUpdate();
                });
            }

            container.appendChild(el);
        });

        console.log(`[Legend] Rendered ${dimension}: ${legendData.length} items`);
    }

    /**
     * Render all legend sections
     * @param {Object} filters - VIS_FILTERS object with filter Sets
     * @param {Function} onUpdate - Callback when any filter changes (typically refreshGraph)
     */
    function renderAll(filters, onUpdate) {
        // Render node legends
        renderSection('topo-tiers', 'tier', filters?.tiers, onUpdate);
        renderSection('topo-families', 'family', filters?.families, onUpdate);
        renderSection('topo-rings', 'ring', filters?.rings, onUpdate);
        renderSection('topo-layers', 'layer', filters?.layers, onUpdate);
        renderSection('topo-effects', 'effect', filters?.effects, onUpdate);

        // Render edge legends
        renderSection('topo-edges', 'edgeType', filters?.edges, onUpdate);
        renderSection('topo-edge-families', 'edgeFamily', filters?.edgeFamilies, onUpdate);

        console.log('[Legend] All sections rendered');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        getLegendData,
        getColor,
        getCounts,
        getDimensions,
        getDimensionMeta,
        subscribe,
        renderSection,
        renderAll,

        // Direct access to dimensions (for migration)
        dimensions,

        // Computed counts
        get counts() { return _counts; }
    };
})();

// Backward compatibility - LegendManager class wrapper
class LegendManager {
    constructor() {
        this.dimensions = LEGEND.dimensions;
        this.counts = {};
        this._subscribers = [];
    }

    init(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
        return this;
    }

    _computeCounts(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
    }

    getLegendData(dimension) {
        return LEGEND.getLegendData(dimension);
    }

    getColor(dimension, category) {
        return LEGEND.getColor(dimension, category);
    }

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    }

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    }
}

// Global Legend instance - defined by app.js (not duplicated here to avoid redeclaration)
// Legend is accessed as a global variable provided by app.js

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

// renderLegendSection calls LEGEND.renderSection with Legend (global) as source
window.renderLegendSection = function(containerId, dimension, stateSet, onUpdate) {
    LEGEND.renderSection(containerId, dimension, stateSet, onUpdate);
};

// renderAllLegends uses VIS_FILTERS and refreshGraph from app.js globals
window.renderAllLegends = function() {
    const VIS_FILTERS = window.VIS_FILTERS;
    const refreshGraph = window.refreshGraph;
    if (VIS_FILTERS && refreshGraph) {
        LEGEND.renderAll(VIS_FILTERS, refreshGraph);
    } else {
        console.warn('[Legend] VIS_FILTERS or refreshGraph not available');
    }
};

console.log('[Module] LEGEND loaded - 10 functions');


// ═══ MODULE: modules/data-manager.js ═══
/**
 * DATA MANAGER MODULE
 *
 * Single gate for ALL data access in the visualization.
 * Replaces direct access to FULL_GRAPH and Graph.graphData().
 * Provides O(1) indexed lookups and cached aggregations.
 *
 * Depends on: NODE, COLOR, LEGEND
 *
 * Usage:
 *   DATA.init(graphData)                // Initialize with payload data
 *   DATA.getNodes()                     // Get all raw nodes
 *   DATA.getNode(id)                    // O(1) node lookup
 *   DATA.getNodesByTier('T0')           // O(1) tier lookup
 *   DATA.getEdgesFrom(nodeId)           // O(1) edge lookup
 *   DATA.getTierCounts()                // Cached aggregation
 */

const DATA = (function() {
    'use strict';

    // =========================================================================
    // RAW DATA (immutable after init)
    // =========================================================================

    const raw = {
        nodes: [],
        links: [],
        fileBoundaries: [],
        markov: {},
        kpis: {},
        meta: {},
        physics: {},
        config: {}
    };

    // =========================================================================
    // ANALYTICS DATA (all Collider sections)
    // =========================================================================

    const analytics = {
        counts: {},
        stats: {},
        coverage: {},
        performance: {},
        classification: {},
        auto_discovery: {},
        ecosystem_discovery: {},
        dependencies: {},
        architecture: {},
        topology: {},
        execution_flow: {},
        data_flow: {},
        knots: {},
        warnings: [],
        recommendations: [],
        theory_completeness: {},
        distributions: {},
        edge_types: {},
        rpbl_profile: {},
        purpose_field: {},
        top_hubs: [],
        orphans_list: [],
        files: [],
        semantics: {},
        llm_enrichment: {},
        brain_download: {},
        ai_insights: null
    };

    // =========================================================================
    // INDEXES (O(1) lookups - built once)
    // =========================================================================

    const index = {
        nodeById: new Map(),           // id -> node
        nodesByTier: new Map(),        // tier -> [nodes]
        nodesByFamily: new Map(),      // family -> [nodes]
        nodesByRing: new Map(),        // ring -> [nodes]
        nodesByLayer: new Map(),       // layer -> [nodes]
        nodesByEffect: new Map(),      // effect -> [nodes]
        nodesByFile: new Map(),        // fileIdx -> [nodes]
        edgesBySource: new Map(),      // nodeId -> [edges from]
        edgesByTarget: new Map(),      // nodeId -> [edges to]
        edgeByKey: new Map(),          // "src|tgt" -> edge
        fileByIndex: new Map(),        // idx -> fileBoundary
        markovBySource: new Map()      // nodeId -> sorted edges by weight
    };

    // =========================================================================
    // CACHED AGGREGATIONS (computed once, invalidated on filter)
    // =========================================================================

    const cache = {
        tierCounts: null,
        familyCounts: null,
        ringCounts: null,
        layerCounts: null,
        effectCounts: null,
        edgeTypeCounts: null,
        edgeFamilyCounts: null,
        edgeRanges: null
    };

    // =========================================================================
    // CURRENT STATE (filtered view)
    // =========================================================================

    const filtered = {
        nodes: [],
        links: []
    };

    // Legend manager instance
    let _legend = null;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function init(data) {
        // Store raw data
        raw.nodes = Array.isArray(data?.nodes) ? data.nodes : [];
        raw.links = Array.isArray(data?.links) ? data.links : [];
        raw.fileBoundaries = Array.isArray(data?.file_boundaries) ? data.file_boundaries : [];
        raw.markov = data?.markov || {};
        raw.kpis = data?.kpis || {};
        raw.meta = data?.meta || {};
        raw.physics = data?.physics || {};
        raw.config = data?.config || {};

        // Store analytics data
        Object.keys(analytics).forEach(key => {
            if (data?.[key] !== undefined) {
                analytics[key] = data[key];
            }
        });

        // Build all indexes
        _buildAllIndexes();

        // Initialize legend
        _legend = new LegendManager();
        _legend.init(raw.nodes, raw.links);

        // Set global Legend reference
        if (typeof Legend !== 'undefined') {
            Legend = _legend;
        }

        console.log('%c[DATA] Initialized', 'color: #4ade80; font-weight: bold',
            `${raw.nodes.length} nodes, ${raw.links.length} edges, ${raw.fileBoundaries.length} files`);

        return DATA;
    }

    // =========================================================================
    // INDEX BUILDING
    // =========================================================================

    function _buildAllIndexes() {
        _buildNodeIndex();
        _buildSemanticIndexes();
        _buildEdgeIndexes();
        _buildFileIndex();
        _buildMarkovIndex();
        _invalidateCache();
    }

    function _buildNodeIndex() {
        index.nodeById.clear();
        for (const node of raw.nodes) {
            if (node?.id) {
                index.nodeById.set(node.id, node);
            }
        }
    }

    function _buildSemanticIndexes() {
        index.nodesByTier.clear();
        index.nodesByFamily.clear();
        index.nodesByRing.clear();
        index.nodesByLayer.clear();
        index.nodesByEffect.clear();
        index.nodesByFile.clear();

        for (const node of raw.nodes) {
            if (!node) continue;

            // Tier index
            const tier = NODE.getTier(node);
            if (!index.nodesByTier.has(tier)) {
                index.nodesByTier.set(tier, []);
            }
            index.nodesByTier.get(tier).push(node);

            // Family index
            const family = NODE.getFamily(node);
            if (!index.nodesByFamily.has(family)) {
                index.nodesByFamily.set(family, []);
            }
            index.nodesByFamily.get(family).push(node);

            // Ring index
            const ring = NODE.getRing(node);
            if (!index.nodesByRing.has(ring)) {
                index.nodesByRing.set(ring, []);
            }
            index.nodesByRing.get(ring).push(node);

            // Layer index
            const layer = NODE.getLayer(node);
            if (!index.nodesByLayer.has(layer)) {
                index.nodesByLayer.set(layer, []);
            }
            index.nodesByLayer.get(layer).push(node);

            // Effect index
            const effect = NODE.getEffect(node);
            if (!index.nodesByEffect.has(effect)) {
                index.nodesByEffect.set(effect, []);
            }
            index.nodesByEffect.get(effect).push(node);

            // File index
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx >= 0) {
                if (!index.nodesByFile.has(fileIdx)) {
                    index.nodesByFile.set(fileIdx, []);
                }
                index.nodesByFile.get(fileIdx).push(node);
            }
        }
    }

    function _buildEdgeIndexes() {
        index.edgesBySource.clear();
        index.edgesByTarget.clear();
        index.edgeByKey.clear();

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');

            if (srcId) {
                if (!index.edgesBySource.has(srcId)) {
                    index.edgesBySource.set(srcId, []);
                }
                index.edgesBySource.get(srcId).push(link);
            }

            if (tgtId) {
                if (!index.edgesByTarget.has(tgtId)) {
                    index.edgesByTarget.set(tgtId, []);
                }
                index.edgesByTarget.get(tgtId).push(link);
            }

            if (srcId && tgtId) {
                index.edgeByKey.set(`${srcId}|${tgtId}`, link);
            }
        }
    }

    function _buildFileIndex() {
        index.fileByIndex.clear();
        for (let i = 0; i < raw.fileBoundaries.length; i++) {
            index.fileByIndex.set(i, raw.fileBoundaries[i]);
        }
    }

    function _buildMarkovIndex() {
        index.markovBySource.clear();
        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const mw = link.markov_weight || 0;
            if (srcId && mw > 0) {
                if (!index.markovBySource.has(srcId)) {
                    index.markovBySource.set(srcId, []);
                }
                index.markovBySource.get(srcId).push(link);
            }
        }
        // Sort each list by markov weight descending
        for (const [, edges] of index.markovBySource) {
            edges.sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0));
        }
    }

    function _invalidateCache() {
        Object.keys(cache).forEach(key => {
            cache[key] = null;
        });
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }

    // =========================================================================
    // RAW DATA ACCESSORS
    // =========================================================================

    function getNodes() { return raw.nodes; }
    function getLinks() { return raw.links; }
    function getFileBoundaries() { return raw.fileBoundaries; }
    function getMarkov() { return raw.markov; }
    function getKpis() { return raw.kpis; }
    function getMeta() { return raw.meta; }
    function getPhysics() { return raw.physics; }
    function getConfig() { return raw.config; }
    function getAnalytics(key) { return analytics[key]; }

    // =========================================================================
    // INDEXED LOOKUPS (O(1))
    // =========================================================================

    function getNode(id) {
        return index.nodeById.get(id) || null;
    }

    function getNodesByTier(tier) {
        return index.nodesByTier.get(tier) || [];
    }

    function getNodesByFamily(family) {
        return index.nodesByFamily.get(family) || [];
    }

    function getNodesByRing(ring) {
        return index.nodesByRing.get(ring) || [];
    }

    function getNodesByLayer(layer) {
        return index.nodesByLayer.get(layer) || [];
    }

    function getNodesByEffect(effect) {
        return index.nodesByEffect.get(effect) || [];
    }

    function getNodesByFile(fileIdx) {
        return index.nodesByFile.get(fileIdx) || [];
    }

    function getEdgesFrom(nodeId) {
        return index.edgesBySource.get(nodeId) || [];
    }

    function getEdgesTo(nodeId) {
        return index.edgesByTarget.get(nodeId) || [];
    }

    function getEdgeBetween(srcId, tgtId) {
        return index.edgeByKey.get(`${srcId}|${tgtId}`) || null;
    }

    function getFile(idx) {
        return index.fileByIndex.get(idx) || null;
    }

    function getTopMarkovEdges(nodeId, k = 5) {
        const edges = index.markovBySource.get(nodeId) || [];
        return edges.slice(0, k);
    }

    function isHighEntropyNode(nodeId) {
        const highEntropy = raw.markov?.high_entropy_nodes || [];
        return highEntropy.some(h => h.node === nodeId);
    }

    // =========================================================================
    // FILTERED DATA
    // =========================================================================

    function setFiltered(nodes, links) {
        filtered.nodes = nodes || [];
        filtered.links = links || [];
    }

    function getVisibleNodes() {
        if (filtered.nodes.length > 0) {
            return filtered.nodes;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().nodes || [])
            : [];
    }

    function getVisibleLinks() {
        if (filtered.links.length > 0) {
            return filtered.links;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().links || [])
            : [];
    }

    // =========================================================================
    // AGGREGATIONS (cached)
    // =========================================================================

    function getTierCounts() {
        if (!cache.tierCounts) {
            cache.tierCounts = new Map();
            for (const [tier, nodes] of index.nodesByTier) {
                cache.tierCounts.set(tier, nodes.length);
            }
        }
        return cache.tierCounts;
    }

    function getFamilyCounts() {
        if (!cache.familyCounts) {
            cache.familyCounts = new Map();
            for (const [family, nodes] of index.nodesByFamily) {
                cache.familyCounts.set(family, nodes.length);
            }
        }
        return cache.familyCounts;
    }

    function getRingCounts() {
        if (!cache.ringCounts) {
            cache.ringCounts = new Map();
            for (const [ring, nodes] of index.nodesByRing) {
                cache.ringCounts.set(ring, nodes.length);
            }
        }
        return cache.ringCounts;
    }

    function getLayerCounts() {
        if (!cache.layerCounts) {
            cache.layerCounts = new Map();
            for (const [layer, nodes] of index.nodesByLayer) {
                cache.layerCounts.set(layer, nodes.length);
            }
        }
        return cache.layerCounts;
    }

    function getEffectCounts() {
        if (!cache.effectCounts) {
            cache.effectCounts = new Map();
            for (const [effect, nodes] of index.nodesByEffect) {
                cache.effectCounts.set(effect, nodes.length);
            }
        }
        return cache.effectCounts;
    }

    function getEdgeTypeCounts() {
        if (!cache.edgeTypeCounts) {
            cache.edgeTypeCounts = new Map();
            for (const link of raw.links) {
                const type = link.edge_type || link.type || 'unknown';
                cache.edgeTypeCounts.set(type, (cache.edgeTypeCounts.get(type) || 0) + 1);
            }
        }
        return cache.edgeTypeCounts;
    }

    function getEdgeFamilyCounts() {
        if (!cache.edgeFamilyCounts) {
            cache.edgeFamilyCounts = new Map();
            for (const link of raw.links) {
                const family = link.family || 'Dependency';
                cache.edgeFamilyCounts.set(family, (cache.edgeFamilyCounts.get(family) || 0) + 1);
            }
        }
        return cache.edgeFamilyCounts;
    }

    function getEdgeRanges() {
        if (!cache.edgeRanges) {
            let minW = Infinity, maxW = -Infinity;
            let minC = Infinity, maxC = -Infinity;
            for (const link of raw.links) {
                const w = link.weight ?? 1;
                const c = link.confidence ?? 1;
                if (w < minW) minW = w;
                if (w > maxW) maxW = w;
                if (c < minC) minC = c;
                if (c > maxC) maxC = c;
            }
            cache.edgeRanges = {
                weight: { min: minW === Infinity ? 0 : minW, max: maxW === -Infinity ? 1 : maxW },
                confidence: { min: minC === Infinity ? 0 : minC, max: maxC === -Infinity ? 1 : maxC }
            };
        }
        return cache.edgeRanges;
    }

    // =========================================================================
    // SELF-TEST
    // =========================================================================

    function selfTest() {
        const errors = [];
        const warnings = [];
        const seenIds = new Set();

        for (const node of raw.nodes) {
            if (!node?.id) {
                errors.push('Node missing id');
                continue;
            }
            if (seenIds.has(node.id)) {
                errors.push(`Duplicate node id: ${node.id}`);
                continue;
            }
            seenIds.add(node.id);
        }

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');
            if (srcId && !index.nodeById.has(srcId)) {
                warnings.push(`Edge source not in graph: ${srcId}`);
            }
            if (tgtId && !index.nodeById.has(tgtId)) {
                warnings.push(`Edge target not in graph: ${tgtId}`);
            }
        }

        const status = errors.length === 0 ? 'PASS' : 'FAIL';
        const style = errors.length === 0
            ? 'color: #4ade80; font-weight: bold'
            : 'color: #f87171; font-weight: bold';

        console.log(`%c[DATA] Self-Test: ${status}`, style);
        console.log(`  Raw: ${raw.nodes.length} nodes, ${raw.links.length} edges`);
        console.log(`  Indexes: nodeById=${index.nodeById.size}, tiers=${index.nodesByTier.size}`);

        if (errors.length > 0) console.error('[DATA] Errors:', errors);
        if (warnings.length > 0) {
            console.warn('[DATA] Warnings:', warnings.slice(0, 5));
            if (warnings.length > 5) console.warn(`  ... and ${warnings.length - 5} more`);
        }

        return { errors, warnings, pass: errors.length === 0 };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Init
        init,

        // Raw data
        getNodes,
        getLinks,
        getFileBoundaries,
        getMarkov,
        getKpis,
        getMeta,
        getPhysics,
        getConfig,
        getAnalytics,

        // Indexed lookups
        getNode,
        getNodesByTier,
        getNodesByFamily,
        getNodesByRing,
        getNodesByLayer,
        getNodesByEffect,
        getNodesByFile,
        getEdgesFrom,
        getEdgesTo,
        getEdgeBetween,
        getFile,
        getTopMarkovEdges,
        isHighEntropyNode,

        // Filtered data
        setFiltered,
        getVisibleNodes,
        getVisibleLinks,

        // Aggregations
        getTierCounts,
        getFamilyCounts,
        getRingCounts,
        getLayerCounts,
        getEffectCounts,
        getEdgeTypeCounts,
        getEdgeFamilyCounts,
        getEdgeRanges,

        // Self-test
        selfTest,

        // Direct access (for migration)
        raw,
        index,
        cache,
        filtered,

        // Legend reference
        get legend() { return _legend; },

        // Color access (convenience)
        get color() { return COLOR; }
    };
})();

// Backward compatibility - DataManager class wrapper
class DataManager {
    constructor() {
        this.raw = DATA.raw;
        this.analytics = {};
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = null;
        this.color = COLOR;
    }

    init(data) {
        DATA.init(data);
        this.raw = DATA.raw;
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = DATA.legend;
        return this;
    }

    // Delegate all methods to DATA module
    getNodes() { return DATA.getNodes(); }
    getLinks() { return DATA.getLinks(); }
    getFileBoundaries() { return DATA.getFileBoundaries(); }
    getMarkov() { return DATA.getMarkov(); }
    getKpis() { return DATA.getKpis(); }
    getMeta() { return DATA.getMeta(); }
    getNode(id) { return DATA.getNode(id); }
    getNodesByTier(tier) { return DATA.getNodesByTier(tier); }
    getNodesByFamily(family) { return DATA.getNodesByFamily(family); }
    getNodesByRing(ring) { return DATA.getNodesByRing(ring); }
    getNodesByFile(fileIdx) { return DATA.getNodesByFile(fileIdx); }
    getEdgesFrom(nodeId) { return DATA.getEdgesFrom(nodeId); }
    getEdgesTo(nodeId) { return DATA.getEdgesTo(nodeId); }
    getEdgeBetween(srcId, tgtId) { return DATA.getEdgeBetween(srcId, tgtId); }
    getFile(idx) { return DATA.getFile(idx); }
    getTopMarkovEdges(nodeId, k) { return DATA.getTopMarkovEdges(nodeId, k); }
    isHighEntropyNode(nodeId) { return DATA.isHighEntropyNode(nodeId); }
    setFiltered(nodes, links) { DATA.setFiltered(nodes, links); }
    getVisibleNodes() { return DATA.getVisibleNodes(); }
    getVisibleLinks() { return DATA.getVisibleLinks(); }
    getTierCounts() { return DATA.getTierCounts(); }
    getFamilyCounts() { return DATA.getFamilyCounts(); }
    getRingCounts() { return DATA.getRingCounts(); }
    getLayerCounts() { return DATA.getLayerCounts(); }
    getEffectCounts() { return DATA.getEffectCounts(); }
    getEdgeTypeCounts() { return DATA.getEdgeTypeCounts(); }
    getEdgeFamilyCounts() { return DATA.getEdgeFamilyCounts(); }
    getEdgeRanges() { return DATA.getEdgeRanges(); }
    selfTest() { return DATA.selfTest(); }

    // Internal methods
    _buildAllIndexes() {}
    _buildNodeIndex() {}
    _buildSemanticIndexes() {}
    _buildEdgeIndexes() {}
    _buildFileIndex() {}
    _buildMarkovIndex() {}
    _invalidateCache() {}
    _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }
    _getNodeTier(node) { return NODE.getTier(node); }
    _getNodeFamily(node) { return NODE.getFamily(node); }
    _getNodeRing(node) { return NODE.getRing(node); }
    _getNodeLayer(node) { return NODE.getLayer(node); }
    _getNodeEffect(node) { return NODE.getEffect(node); }
}

// Global DM instance - defined by app.js (not duplicated here to avoid redeclaration)
// DM is accessed as a global variable provided by app.js

// Parity check function
function runDmParity(dm, data) {
    if (!dm) return;
    const checks = [];
    const rawNodes = Array.isArray(data?.nodes) ? data.nodes.length : 0;
    const rawEdges = Array.isArray(data?.links) ? data.links.length : 0;
    const dmNodes = dm.raw.nodes.length;
    const dmEdges = dm.raw.links.length;

    checks.push({ name: 'Node count', dm: dmNodes, old: rawNodes, pass: dmNodes === rawNodes });
    checks.push({ name: 'Edge count', dm: dmEdges, old: rawEdges, pass: dmEdges === rawEdges });
    checks.push({ name: 'Node index size', dm: dm.index.nodeById.size, old: rawNodes, pass: dm.index.nodeById.size === rawNodes });

    const allPass = checks.every(c => c.pass);
    const style = allPass ? 'color: #4ade80; font-weight: bold' : 'color: #f87171; font-weight: bold';
    console.log(`%c[DM Parity] ${allPass ? 'ALL PASS' : 'MISMATCH'}`, style);
    checks.forEach(c => {
        const icon = c.pass ? '✓' : '✗';
        console.log(`  ${icon} ${c.name}: DM=${c.dm}, Raw=${c.old}`);
    });
}


// ═══ MODULE: modules/vis-state.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VIS-STATE MODULE - Unified visualization state management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Single source of truth for visualization state. All controls funnel through
 * applyState() to ensure consistency.
 *
 * KEY DESIGN DECISIONS:
 * 1. Palette selection NEVER auto-switches colorBy mode
 * 2. Palette is "armed" - it applies when colorBy changes to interval mode
 * 3. Presets are macros that call applyState() with multiple properties
 * 4. syncUIFromState() updates all UI elements to match state
 *
 * @module VIS_STATE
 * @version 1.0.0
 */

window.VIS_STATE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CATEGORICAL vs INTERVAL MODE CLASSIFICATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Categorical modes use discrete color palettes (tier, family, atom...)
     * Interval modes use continuous gradients (complexity, fan_in, loc...)
     */
    const CATEGORICAL_MODES = new Set([
        'tier', 'family', 'atom', 'ring', 'layer', 'role', 'roleCategory',
        'subsystem', 'phase', 'fileType', 'file', 'state', 'visibility'
    ]);

    const INTERVAL_MODES = new Set([
        'complexity', 'loc', 'fan_in', 'fan_out', 'trust',
        'responsibility', 'purity', 'lifecycle_score', 'boundary_score',
        'centrality', 'rank', 'churn', 'age', 'depth'
    ]);

    function isIntervalMode(mode) {
        return INTERVAL_MODES.has(mode);
    }

    function isCategoricalMode(mode) {
        return CATEGORICAL_MODES.has(mode);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATE OBJECT - Single source of truth
    // ═══════════════════════════════════════════════════════════════════════

    const state = {
        colorBy: 'fan_in',         // Default to interval mode to show OKLCH schemes
        sizeBy: 'fanout',          // 'uniform', 'degree', 'fanout', 'complexity'
        edgeBy: 'type',            // 'type', 'resolution', 'weight', 'gradient-tier', etc.
        palette: 'helix',          // OKLCH helix path - visually striking default
        paletteType: 'interval'    // Derived: 'categorical' or 'interval'
    };

    // ═══════════════════════════════════════════════════════════════════════
    // VIEW PRESETS - Macros that set multiple properties at once
    // ═══════════════════════════════════════════════════════════════════════

    const VIEW_PRESETS = {
        tier: {
            label: 'Tier',
            description: 'T0/T1/T2 architectural height',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        family: {
            label: 'Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        layer: {
            label: 'Layer',
            description: 'Physical/Virtual/Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        ring: {
            label: 'Ring',
            description: 'Domain architecture rings',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        file: {
            label: 'File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        flow: {
            label: 'Flow',
            description: 'Markov transition probability',
            colorBy: 'fan_in',  // Use interval mode for flow
            sizeBy: 'degree',
            edgeBy: 'weight',
            special: 'flow'    // Triggers flow visualization
        }
    };

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY STATE - Central function all controls use
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply state changes. This is THE function all UI controls call.
     *
     * @param {Object} nextState - Partial state to merge
     * @param {string} reason - Debug label for console (e.g., 'preset:tier', 'control:colorBy')
     */
    function applyState(nextState, reason = 'unknown') {
        const prevColorBy = state.colorBy;
        const prevPalette = state.palette;

        // Merge new state
        if (nextState.colorBy !== undefined) state.colorBy = nextState.colorBy;
        if (nextState.sizeBy !== undefined) state.sizeBy = nextState.sizeBy;
        if (nextState.edgeBy !== undefined) state.edgeBy = nextState.edgeBy;
        if (nextState.palette !== undefined) state.palette = nextState.palette;

        // Derive paletteType from colorBy
        state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';

        console.log(`[VIS_STATE] applyState(${reason}):`, {
            colorBy: state.colorBy,
            sizeBy: state.sizeBy,
            edgeBy: state.edgeBy,
            palette: state.palette,
            paletteType: state.paletteType
        });

        // ─── Apply color mode ───
        if (nextState.colorBy !== undefined && nextState.colorBy !== prevColorBy) {
            _applyColorMode(state.colorBy);
        }

        // ─── Apply size mode ───
        if (nextState.sizeBy !== undefined) {
            _applySizeMode(state.sizeBy);
        }

        // ─── Apply edge mode ───
        if (nextState.edgeBy !== undefined) {
            _applyEdgeMode(state.edgeBy);
        }

        // ─── Apply palette (only if in interval mode) ───
        if (nextState.palette !== undefined || nextState.colorBy !== undefined) {
            _applyPalette();
        }

        // ─── Handle special modes (flow) ───
        if (nextState.special === 'flow') {
            _enableFlowMode();
        } else if (prevColorBy === 'flow' && nextState.colorBy !== 'flow') {
            _disableFlowMode();
        }

        // ─── Sync UI to match state ───
        syncUIFromState();

        // ─── Refresh visualization ───
        _refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INTERNAL APPLY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════

    function _applyColorMode(mode) {
        // Update globals for backward compatibility
        window.NODE_COLOR_MODE = mode;

        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.colorMode = mode;
            window.APPEARANCE_STATE.currentPreset = mode;
        }

        // Disable flow mode if switching away from flow
        if (mode !== 'flow' && typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _applySizeMode(mode) {
        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.sizeMode = mode;
        }

        if (typeof window.applyNodeSizeMode === 'function') {
            window.applyNodeSizeMode(mode);
        } else if (typeof window.NODE_HELPERS !== 'undefined') {
            window.NODE_HELPERS.applySizeMode(mode);
        }
    }

    function _applyEdgeMode(mode) {
        if (typeof window.EDGE_GRADIENT_MODE !== 'undefined') {
            // Edge gradient modes
            if (mode.startsWith('gradient-')) {
                window.EDGE_GRADIENT_MODE = mode.replace('gradient-', '');
            }
        }

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
    }

    function _applyPalette() {
        // Only apply scheme coloring if in interval mode
        if (state.paletteType === 'interval' && state.palette) {
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(state.palette);
            }
        } else {
            // In categorical mode, clear active scheme
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(null);
            }
        }
    }

    function _enableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && !window.flowMode) {
            if (typeof window.toggleFlowMode === 'function') {
                window.toggleFlowMode();
            }
        }
    }

    function _disableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _refreshGraph() {
        // Recompute node colors
        const DM = window.DM;
        const Graph = window.Graph;
        const nodes = DM ? DM.getNodes() : (Graph?.graphData ? Graph.graphData().nodes : []);

        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render with new function reference to force update
        if (Graph) {
            Graph.nodeColor(n => n.color);
        }

        // Refresh edge gradients
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        // Re-render legends
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SYNC UI FROM STATE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all UI elements to reflect current state.
     * Called after every applyState() and on initialization.
     */
    function syncUIFromState() {
        // ─── View Preset buttons ───
        document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
            const presetKey = btn.dataset.preset;
            const preset = VIEW_PRESETS[presetKey];
            const isActive = preset && preset.colorBy === state.colorBy;
            btn.classList.toggle('active', isActive);
        });

        // ─── Color Mode buttons (PRESET_CONFIG grid) ───
        document.querySelectorAll('.color-btn[data-preset]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.preset === state.colorBy);
        });

        // ─── Size Mode buttons ───
        document.querySelectorAll('[data-size-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.sizeMode === state.sizeBy);
        });

        // ─── Edge Mode buttons ───
        document.querySelectorAll('[data-edge-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.edgeMode === state.edgeBy);
        });

        // ─── Palette buttons ───
        document.querySelectorAll('.scheme-btn[data-scheme]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.scheme === state.palette);
        });

        // ─── Palette panel enabled/disabled state ───
        const schemesPanel = document.getElementById('section-schemes');
        if (schemesPanel) {
            const isDisabled = state.paletteType === 'categorical';
            schemesPanel.classList.toggle('disabled', isDisabled);

            // Update scheme buttons opacity/interactivity
            schemesPanel.querySelectorAll('.scheme-btn').forEach(btn => {
                btn.disabled = isDisabled;
                btn.style.opacity = isDisabled ? '0.4' : '1';
                btn.style.pointerEvents = isDisabled ? 'none' : 'auto';
            });

            // Show hint when disabled
            let hint = schemesPanel.querySelector('.scheme-hint');
            if (isDisabled) {
                if (!hint) {
                    hint = document.createElement('div');
                    hint.className = 'scheme-hint';
                    hint.style.cssText = 'padding: 8px; font-size: 10px; opacity: 0.6; text-align: center; font-style: italic;';
                    hint.textContent = 'Switch to a metric mode (Fan-In, Complexity, etc.) to enable color schemes';
                    schemesPanel.insertBefore(hint, schemesPanel.firstChild);
                }
            } else if (hint) {
                hint.remove();
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVENIENCE METHODS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply a view preset by name
     */
    function applyPreset(presetKey) {
        const preset = VIEW_PRESETS[presetKey];
        if (!preset) {
            console.warn('[VIS_STATE] Unknown preset:', presetKey);
            return;
        }

        applyState({
            colorBy: preset.colorBy,
            sizeBy: preset.sizeBy,
            edgeBy: preset.edgeBy,
            special: preset.special
        }, `preset:${presetKey}`);
    }

    /**
     * Set color mode only
     */
    function setColorBy(mode) {
        applyState({ colorBy: mode }, `colorBy:${mode}`);
    }

    /**
     * Set size mode only
     */
    function setSizeBy(mode) {
        applyState({ sizeBy: mode }, `sizeBy:${mode}`);
    }

    /**
     * Set edge mode only
     */
    function setEdgeBy(mode) {
        applyState({ edgeBy: mode }, `edgeBy:${mode}`);
    }

    /**
     * Set palette (arms the palette, applies if in interval mode)
     */
    function setPalette(schemeName) {
        applyState({ palette: schemeName }, `palette:${schemeName}`);
    }

    /**
     * Get current state (read-only copy)
     */
    function getState() {
        return { ...state };
    }

    /**
     * Initialize from saved preferences or defaults
     */
    function init() {
        try {
            const savedScheme = localStorage.getItem('collider_scheme');
            const savedColorMode = localStorage.getItem('collider_color_mode');

            if (savedScheme) state.palette = savedScheme;
            if (savedColorMode) state.colorBy = savedColorMode;

            state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';
        } catch (e) { /* ignore localStorage errors */ }

        // Apply initial state to globals (critical for NODE_COLOR_MODE)
        _applyColorMode(state.colorBy);
        _applyPalette();

        console.log('[VIS_STATE] Initialized:', state);
    }

    /**
     * Save current preferences
     */
    function savePreferences() {
        try {
            localStorage.setItem('collider_scheme', state.palette);
            localStorage.setItem('collider_color_mode', state.colorBy);
        } catch (e) { /* ignore */ }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // State access
        getState,
        isIntervalMode,
        isCategoricalMode,

        // Main API
        applyState,
        applyPreset,
        syncUIFromState,

        // Convenience setters
        setColorBy,
        setSizeBy,
        setEdgeBy,
        setPalette,

        // Lifecycle
        init,
        savePreferences,

        // Constants
        VIEW_PRESETS,
        CATEGORICAL_MODES,
        INTERVAL_MODES
    };
})();

console.log('[Module] VIS_STATE loaded - unified visualization state');


// ═══ MODULE: modules/ui-manager.js ═══
/**
 * @module ui-manager
 * @description Orchestrates the "One Dock" unified interface
 * @responsibility Manage sidebar, dock, modes, and filters UI
 * @depends_on vis-state, data-manager, refresh-throttle
 */

const UI_MANAGER = (function() {
    'use strict';

    // Private state
    let _data = null;
    let _initialized = false;

    /**
     * Initialize the UI Manager
     * @param {Object} data - Graph data object
     */
    function init(data) {
        _data = data;
        _setupSidebar();
        _setupDock();
        _setupModes();
        _populateFilters();
        _updateStatus();
        _initialized = true;
    }

    /**
     * Setup sidebar toggle and accordion behavior
     */
    function _setupSidebar() {
        const sidebar = document.getElementById('sidebar');
        const btnFilters = document.getElementById('btn-filters');
        const btnClose = document.getElementById('sidebar-close');

        const toggle = () => {
            sidebar.classList.toggle('open');
            _updateFilterBadge();
        };

        if (btnFilters) btnFilters.onclick = (e) => {
            e.stopPropagation();
            toggle();
        };
        if (btnClose) btnClose.onclick = () => sidebar.classList.remove('open');

        // Accordion Logic
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.onclick = () => {
                const accordion = header.parentElement;
                accordion.classList.toggle('open');
            };
        });
    }

    /**
     * Setup dock controls
     */
    function _setupDock() {
        // Reset Layout
        const btnReset = document.getElementById('btn-reset-layout');
        if (btnReset) btnReset.onclick = () => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.zoomToFit(1000);
            }
        };

        // Dimensions Toggle (2D/3D - stub)
        const btnDim = document.getElementById('btn-dimensions');
        if (btnDim) btnDim.onclick = () => {
            console.log("Dimension toggle requested");
        };

        // Report Button
        const btnReport = document.getElementById('btn-report');
        if (btnReport) btnReport.onclick = () => {
            const reportPanel = document.getElementById('report-panel');
            if (reportPanel) {
                const isHidden = reportPanel.style.display === 'none';
                reportPanel.style.display = isHidden ? 'block' : 'none';
                btnReport.classList.toggle('active', isHidden);
            }
        };
    }

    /**
     * Setup mode buttons (explore, files, flow)
     */
    function _setupModes() {
        const modes = ['explore', 'files', 'flow'];

        const setMode = (mode) => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.getElementById(`mode-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');

            document.querySelectorAll('.mode-control-group').forEach(g => g.style.display = 'none');
            const group = document.getElementById(`${mode}-controls`);
            if (group) group.style.display = 'flex';
        };

        modes.forEach(mode => {
            const btn = document.getElementById(`mode-${mode}`);
            if (btn) btn.onclick = () => setMode(mode);
        });

        // Files Sub-controls wiring
        const bindToggle = (id, onClick) => {
            const el = document.getElementById(id);
            if (el) el.onclick = (e) => {
                e.target.classList.toggle('active');
                if (onClick) onClick(e.target.classList.contains('active'));
            };
        };

        bindToggle('btn-file-hulls', (_active) => {
            // Toggle hull visibility
        });
    }

    /**
     * Populate filter chips for all categories
     */
    function _populateFilters() {
        if (!_data) return;

        // Helper: Create Filter Chips
        const createChips = (containerId, counts, activeSet) => {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            counts.forEach(([key, count]) => {
                const chip = document.createElement('div');
                const isActive = activeSet.has(key);
                chip.className = `filter-chip ${isActive ? 'active' : ''}`;
                chip.innerHTML = `${key} <span class="chip-count">${count}</span>`;
                chip.onclick = () => {
                    if (activeSet.has(key)) activeSet.delete(key);
                    else activeSet.add(key);

                    chip.classList.toggle('active');
                    _updateFilterBadge();
                    // Call refreshGraph if available
                    if (typeof refreshGraph === 'function') refreshGraph();
                };
                container.appendChild(chip);
            });

            const type = containerId.replace('filter-', '');
            const countEl = document.getElementById(`count-${type}`);
            if (countEl) countEl.innerText = activeSet.size;
        };

        // Get accessor functions
        const getNodeRing = typeof window.getNodeRing === 'function' ? window.getNodeRing :
            (typeof NODE !== 'undefined' ? NODE.getRing : (n => n.ring || 'Unknown'));
        const getNodeTier = typeof window.getNodeTier === 'function' ? window.getNodeTier :
            (typeof NODE !== 'undefined' ? NODE.getTier : (n => n.tier || 'Unknown'));
        const getNodeAtomFamily = typeof window.getNodeAtomFamily === 'function' ? window.getNodeAtomFamily :
            (typeof NODE !== 'undefined' ? NODE.getFamily : (n => n.atom_family || 'Unknown'));
        const normalizeRingValue = typeof window.normalizeRingValue === 'function' ? window.normalizeRingValue :
            (typeof NODE !== 'undefined' ? NODE.normalizeRing : (v => v));
        const collectCounts = typeof window.collectCounts === 'function' ? window.collectCounts :
            _defaultCollectCounts;

        // Get VIS_FILTERS
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set(), edges: new Set(), families: new Set() };

        // 1. LAYERS (Rings)
        const ringCounts = collectCounts(_data.nodes, getNodeRing);
        const rawRingDefaults = _data.controls?.filters?.rings || [];
        const ringDefaults = rawRingDefaults
            .map(v => normalizeRingValue(v))
            .filter(v => v !== null);

        if (VIS_FILTERS.rings.size === 0 && ringDefaults.length > 0) {
            const availableRings = new Set(ringCounts.map(([ring]) => ring));
            const matchedRings = ringDefaults.filter(r => availableRings.has(r));
            if (matchedRings.length > 0) {
                matchedRings.forEach(r => VIS_FILTERS.rings.add(r));
            } else {
                const familyCounts = collectCounts(_data.nodes, getNodeAtomFamily);
                const availableFamilies = new Set(familyCounts.map(([family]) => family));
                const matchedFamilies = ringDefaults.filter(f => availableFamilies.has(f));
                if (matchedFamilies.length > 0 && VIS_FILTERS.families.size === 0) {
                    matchedFamilies.forEach(f => VIS_FILTERS.families.add(f));
                    console.warn('[Filters] Ring defaults matched families; applying as family filters.');
                }
            }
        }
        createChips('filter-rings', ringCounts, VIS_FILTERS.rings);

        // 2. TIERS
        const tierCounts = collectCounts(_data.nodes, getNodeTier);
        createChips('filter-tiers', tierCounts, VIS_FILTERS.tiers);

        // 3. ROLES
        const roleCounts = collectCounts(_data.nodes, n => String(n.role || 'Unknown'));
        createChips('filter-roles', roleCounts, VIS_FILTERS.roles);

        // 4. EDGES
        const edgeCounts = collectCounts(_data.links, l => String(l.edge_type || l.type || 'default'));
        createChips('filter-edges', edgeCounts, VIS_FILTERS.edges);

        // 5. DATAMAPS
        _populateDatamaps();

        _updateFilterBadge();
    }

    /**
     * Default collectCounts implementation
     */
    function _defaultCollectCounts(items, accessor) {
        const counts = new Map();
        items.forEach(item => {
            const key = accessor(item);
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    /**
     * Populate datamap chips
     */
    function _populateDatamaps() {
        const container = document.getElementById('filter-datamaps');
        if (!container) return;
        container.innerHTML = '';

        const controls = _data.controls || {};
        const resolveDatamapConfigs = typeof window.resolveDatamapConfigs === 'function'
            ? window.resolveDatamapConfigs
            : () => [];
        const configs = resolveDatamapConfigs(controls);
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS || new Set();
        const setDatamap = typeof window.setDatamap === 'function' ? window.setDatamap : () => {};

        configs.forEach(cfg => {
            const chip = document.createElement('div');
            const isActive = ACTIVE_DATAMAPS.has(cfg.id);
            chip.className = `filter-chip ${isActive ? 'active' : ''}`;
            chip.style.width = '100%';
            chip.style.marginBottom = '4px';
            chip.innerHTML = `${cfg.label}`;

            chip.onclick = () => {
                setDatamap(cfg.id);
                Array.from(container.children).forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            };
            container.appendChild(chip);
        });

        const countEl = document.getElementById('count-datamaps');
        if (countEl) countEl.innerText = configs.length;
    }

    /**
     * Update filter badge count
     */
    function _updateFilterBadge() {
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set() };

        let total = 0;
        total += VIS_FILTERS.rings.size;
        total += VIS_FILTERS.tiers.size;
        total += VIS_FILTERS.roles.size;

        const badge = document.getElementById('filter-badge');
        const miniBadge = document.getElementById('filter-badge-mini');

        if (badge) badge.innerText = total;
        if (miniBadge) {
            miniBadge.innerText = total;
            miniBadge.classList.toggle('visible', total > 0);
        }

        const summary = document.getElementById('filter-summary');
        if (summary) {
            summary.innerText = total > 0 ? `${total} filters active` : "No filters active";
        }
    }

    /**
     * Update status display (node/edge counts)
     */
    function _updateStatus() {
        if (_data && _data.nodes) {
            const n = _data.nodes.length;
            const e = _data.links.length;
            const statusNodes = document.getElementById('status-nodes');
            const statusEdges = document.getElementById('status-edges');

            if (statusNodes) statusNodes.innerText = n;
            if (statusEdges) statusEdges.innerText = e;
        }
    }

    /**
     * Refresh filters (re-populate from current data)
     */
    function refreshFilters() {
        _populateFilters();
    }

    /**
     * Update badge count (public interface)
     */
    function updateFilterBadge() {
        _updateFilterBadge();
    }

    // Public API
    return {
        init,
        refreshFilters,
        updateFilterBadge,
        get data() { return _data; },
        get initialized() { return _initialized; }
    };
})();

// Backward compatibility - expose as UIManager
const UIManager = {
    data: null,
    init(data) {
        this.data = data;
        UI_MANAGER.init(data);
    },
    setupSidebar() { /* Now internal */ },
    setupDock() { /* Now internal */ },
    setupModes() { /* Now internal */ },
    populateFilters() { UI_MANAGER.refreshFilters(); },
    populateDatamaps() { UI_MANAGER.refreshFilters(); },
    updateFilterBadge() { UI_MANAGER.updateFilterBadge(); },
    updateStatus() { /* Now internal */ }
};

// Expose globally
window.UI_MANAGER = UI_MANAGER;
window.UIManager = UIManager;


// ═══ MODULE: modules/physics.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * PHYSICS MODULE - Force simulation controls
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Physics presets, sliders, and force parameter management.
 * Depends on: Graph, PHYSICS_STATE, PHYSICS_PRESETS (globals)
 *
 * @module PHYSICS
 * @version 1.0.0
 */

window.PHYSICS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS STATE
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsState() {
        const Graph = window.Graph;
        const PHYSICS_STATE = window.PHYSICS_STATE;
        if (!Graph) return;
        try {
            Graph.d3Force('charge')?.strength(PHYSICS_STATE.charge);
            Graph.d3Force('link')?.distance(PHYSICS_STATE.linkDistance);
            Graph.d3Force('center')?.strength(PHYSICS_STATE.centerStrength);
            Graph.d3VelocityDecay?.(PHYSICS_STATE.velocityDecay);
            Graph.d3ReheatSimulation();
        } catch (e) {
            console.warn('[Physics] Could not apply:', e.message);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS PRESET
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsPreset(presetName) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const preset = PHYSICS_PRESETS[presetName];
        if (!preset) return;
        Object.assign(PHYSICS_STATE, {
            charge: preset.charge,
            linkDistance: preset.linkDistance,
            centerStrength: preset.centerStrength,
            velocityDecay: preset.velocityDecay
        });
        applyPhysicsState();
        updatePhysicsSliders();
        window.showModeToast(`Physics: ${preset.label}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE PHYSICS SLIDERS
    // ═══════════════════════════════════════════════════════════════════════

    function updatePhysicsSliders() {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const sliders = {
            'physics-charge': PHYSICS_STATE.charge,
            'physics-link-distance': PHYSICS_STATE.linkDistance,
            'physics-center': PHYSICS_STATE.centerStrength,
            'physics-damping': PHYSICS_STATE.velocityDecay
        };
        for (const [id, value] of Object.entries(sliders)) {
            const input = document.getElementById(id);
            const display = document.getElementById(id + '-value');
            if (input) input.value = value;
            if (display) display.textContent = typeof value === 'number' && value % 1 !== 0 ? value.toFixed(2) : value;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // BUILD PHYSICS CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function buildPhysicsControls(containerId) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const container = document.getElementById(containerId);
        if (!container) return;

        // Preset buttons
        const presetRow = document.createElement('div');
        presetRow.className = 'physics-presets';
        presetRow.style.cssText = 'display:flex;gap:4px;margin-bottom:8px;flex-wrap:wrap;';
        Object.entries(PHYSICS_PRESETS).forEach(([key, preset]) => {
            const btn = document.createElement('button');
            btn.className = 'preset-btn physics-preset-btn';
            btn.textContent = preset.label;
            btn.style.cssText = 'font-size:9px;padding:2px 6px;';
            btn.onclick = () => applyPhysicsPreset(key);
            presetRow.appendChild(btn);
        });
        container.appendChild(presetRow);

        // Sliders
        const sliderDefs = [
            {
                id: 'physics-charge',
                label: 'REPULSION',
                min: -500,
                max: 50,
                step: 10,
                value: PHYSICS_STATE.charge,
                onChange: (val) => { PHYSICS_STATE.charge = val; applyPhysicsState(); }
            },
            {
                id: 'physics-link-distance',
                label: 'LINK DIST',
                min: 10,
                max: 200,
                step: 5,
                value: PHYSICS_STATE.linkDistance,
                onChange: (val) => { PHYSICS_STATE.linkDistance = val; applyPhysicsState(); }
            },
            {
                id: 'physics-center',
                label: 'CENTER PULL',
                min: 0,
                max: 0.3,
                step: 0.01,
                value: PHYSICS_STATE.centerStrength,
                onChange: (val) => { PHYSICS_STATE.centerStrength = val; applyPhysicsState(); }
            },
            {
                id: 'physics-damping',
                label: 'DAMPING',
                min: 0,
                max: 1,
                step: 0.05,
                value: PHYSICS_STATE.velocityDecay,
                onChange: (val) => { PHYSICS_STATE.velocityDecay = val; applyPhysicsState(); }
            }
        ];

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row';

            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            valueDisplay.textContent = def.step < 1 ? def.value.toFixed(2) : def.value;
            header.appendChild(label);
            header.appendChild(valueDisplay);

            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = def.value;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = def.step < 1 ? val.toFixed(2) : val;
                def.onChange(val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);
            container.appendChild(wrapper);
        });

        console.log('[Physics] Controls initialized');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        applyState: applyPhysicsState,
        applyPreset: applyPhysicsPreset,
        updateSliders: updatePhysicsSliders,
        buildControls: buildPhysicsControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.applyPhysicsState = PHYSICS.applyState;
window.applyPhysicsPreset = PHYSICS.applyPreset;
window.updatePhysicsSliders = PHYSICS.updateSliders;
window.buildPhysicsControls = PHYSICS.buildControls;

console.log('[Module] PHYSICS loaded - 4 functions');


// ═══ MODULE: modules/datamap.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DATAMAP MODULE - Data mapping and filtering
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Datamap configuration, matching, and UI control updates.
 * Depends on: DM, VIS_FILTERS, ACTIVE_DATAMAPS, NODE (node-accessors)
 *
 * @module DATAMAP
 * @version 1.0.0
 */

window.DATAMAP = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NORMALIZE DATAMAP CONFIG
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeDatamapConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const id = String(raw.id || raw.key || raw.label || '').trim();
        if (!id) return null;
        const normalizeList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => String(item).toUpperCase());
        };
        const normalizeTierList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => window.normalizeTier(item));
        };
        const match = raw.match || {};
        return {
            id: id.toUpperCase(),
            label: String(raw.label || raw.id || id).toUpperCase(),
            match: {
                atom_families: normalizeList(match.atom_families),
                atom_prefixes: normalizeList(match.atom_prefixes),
                tiers: normalizeTierList(match.tiers),
                rings: normalizeList(match.rings),
                roles: normalizeList(match.roles)
            },
            default: Boolean(raw.default)
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // RESOLVE DATAMAP CONFIGS
    // ═══════════════════════════════════════════════════════════════════════

    function resolveDatamapConfigs(controlsConfig) {
        const fromTokens = Array.isArray(controlsConfig.datamaps) ? controlsConfig.datamaps : [];
        const normalized = fromTokens
            .map(normalizeDatamapConfig)
            .filter(Boolean);
        if (normalized.length) return normalized;

        const fallback = controlsConfig.buttons?.datamaps || {};
        return Object.entries(fallback).map(([label, config]) => {
            const prefix = config.filter || null;
            return normalizeDatamapConfig({
                id: label.toUpperCase(),
                label: label.toUpperCase(),
                match: prefix ? { atom_prefixes: [prefix] } : {},
                default: false
            });
        }).filter(Boolean);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP MATCHING
    // ═══════════════════════════════════════════════════════════════════════

    function datamapMatches(node, config) {
        const match = config.match || {};
        const atomId = String(node.atom || '');
        const atomFamily = window.getNodeAtomFamily(node);
        const tier = window.getNodeTier(node);
        const ring = window.getNodeRing(node);
        const role = String(node.role || 'Unknown').toUpperCase();

        if (Array.isArray(match.atom_families) && match.atom_families.length) {
            if (!match.atom_families.includes(atomFamily)) return false;
        }

        if (Array.isArray(match.atom_prefixes) && match.atom_prefixes.length) {
            const matchesFamily = match.atom_prefixes.includes(atomFamily);
            const matchesPrefix = match.atom_prefixes.some(prefix => atomId.startsWith(prefix));
            if (!matchesFamily && !matchesPrefix) return false;
        }

        if (Array.isArray(match.tiers) && match.tiers.length) {
            if (!match.tiers.includes(tier)) return false;
        }

        if (Array.isArray(match.rings) && match.rings.length) {
            if (!match.rings.includes(ring)) return false;
        }

        if (Array.isArray(match.roles) && match.roles.length) {
            if (!match.roles.includes(role)) return false;
        }
        return true;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET DATAMAP
    // ═══════════════════════════════════════════════════════════════════════

    function setDatamap(prefix) {
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const nextSet = new Set(ACTIVE_DATAMAPS);
        if (!prefix) {
            nextSet.clear();
        } else if (nextSet.has(prefix)) {
            nextSet.delete(prefix);
        } else {
            nextSet.add(prefix);
        }

        if (!window.DM) {
            window.ACTIVE_DATAMAPS = nextSet;
            updateDatamapControls();
            return;
        }

        const subset = window.filterGraph(null, window.CURRENT_DENSITY, nextSet, window.VIS_FILTERS);
        if (!subset.nodes.length) {
            window.showToast('No nodes for that datamap selection.');
            updateDatamapControls();
            return;
        }

        window.ACTIVE_DATAMAPS = nextSet;
        updateDatamapControls();
        window.refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET NODE COLOR MODE
    // ═══════════════════════════════════════════════════════════════════════

    function setNodeColorMode(mode) {
        window.NODE_COLOR_MODE = mode;
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
        window.refreshGraph();
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY DATAMAP (ALIAS)
    // ═══════════════════════════════════════════════════════════════════════

    function applyDatamap(prefix) {
        setDatamap(prefix);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE DATAMAP CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function updateDatamapControls() {
        const DM = window.DM;
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const DATAMAP_UI = window.DATAMAP_UI;
        const DATAMAP_CONFIGS = window.DATAMAP_CONFIGS;
        const GRAPH_MODE = window.GRAPH_MODE;
        const VIS_FILTERS = window.VIS_FILTERS;

        if (!DM) return;
        const datamapEnabled = GRAPH_MODE === 'atoms';
        const base = window.filterGraph(null, window.CURRENT_DENSITY, new Set(), VIS_FILTERS);
        const nodes = base.nodes || [];
        const totalCount = nodes.length;

        const allUI = DATAMAP_UI.get('__ALL__');
        if (allUI) {
            allUI.input.checked = ACTIVE_DATAMAPS.size === 0;
            if (allUI.count) {
                allUI.count.textContent = datamapEnabled ? String(totalCount) : '--';
            }
            allUI.input.disabled = !datamapEnabled;
            allUI.wrapper.classList.toggle('disabled', !datamapEnabled);
            allUI.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.size === 0);
        }

        DATAMAP_CONFIGS.forEach((config) => {
            const count = nodes.reduce((acc, node) => acc + (datamapMatches(node, config) ? 1 : 0), 0);
            const ui = DATAMAP_UI.get(config.id);
            if (!ui) return;
            if (ui.count) {
                ui.count.textContent = datamapEnabled ? String(count) : '--';
            }
            ui.input.disabled = !datamapEnabled || count === 0;
            ui.wrapper.classList.toggle('disabled', !datamapEnabled || count === 0);
            ui.input.checked = ACTIVE_DATAMAPS.has(config.id);
            ui.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.has(config.id));
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        normalizeConfig: normalizeDatamapConfig,
        resolveConfigs: resolveDatamapConfigs,
        matches: datamapMatches,
        set: setDatamap,
        setColorMode: setNodeColorMode,
        apply: applyDatamap,
        updateControls: updateDatamapControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.normalizeDatamapConfig = DATAMAP.normalizeConfig;
window.resolveDatamapConfigs = DATAMAP.resolveConfigs;
window.datamapMatches = DATAMAP.matches;
window.setDatamap = DATAMAP.set;
window.setNodeColorMode = DATAMAP.setColorMode;
window.applyDatamap = DATAMAP.apply;
window.updateDatamapControls = DATAMAP.updateControls;

console.log('[Module] DATAMAP loaded - 7 functions');


// ═══ MODULE: modules/groups.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * GROUPS MODULE - Node grouping functionality
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Group creation, storage, rendering, and management.
 * Depends on: GROUPS, ACTIVE_GROUP_ID, SELECTED_NODE_IDS, GROUPS_STORAGE_KEY
 *
 * @module GROUPS_MODULE
 * @version 1.0.0
 */

window.GROUPS_MODULE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    function loadGroups() {
        window.GROUPS = [];
        try {
            const stored = localStorage.getItem(window.GROUPS_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    window.GROUPS = parsed;
                }
            }
        } catch (e) {
            // localStorage unavailable
        }
        window.GROUPS = window.GROUPS.filter(group => group && group.id && Array.isArray(group.node_ids));
        window.GROUPS.forEach(group => {
            if (group.visible === undefined) group.visible = true;
        });
    }

    function saveGroups() {
        try {
            localStorage.setItem(window.GROUPS_STORAGE_KEY, JSON.stringify(window.GROUPS));
        } catch (e) {
            // localStorage unavailable
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNextGroupColor() {
        const hue = (window.GROUPS.length * 137.5) % 360;
        return window.hslColor(hue, 65, 55);
    }

    function getGroupById(groupId) {
        return window.GROUPS.find(group => group.id === groupId) || null;
    }

    function getPrimaryGroupForNode(nodeId) {
        const visibleGroups = window.GROUPS.filter(group =>
            group.visible !== false && Array.isArray(group.node_ids) && group.node_ids.includes(nodeId)
        );
        if (!visibleGroups.length) return null;
        if (window.ACTIVE_GROUP_ID) {
            const active = visibleGroups.find(group => group.id === window.ACTIVE_GROUP_ID);
            if (active) return active;
        }
        return visibleGroups[0];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP LIST RENDERING
    // ═══════════════════════════════════════════════════════════════════════

    function renderGroupList() {
        const container = document.getElementById('group-list');
        if (!container) return;
        container.innerHTML = '';

        if (!window.GROUPS.length) {
            const empty = document.createElement('div');
            empty.style.fontSize = '9px';
            empty.style.color = 'rgba(255,255,255,0.4)';
            empty.textContent = 'No groups yet';
            container.appendChild(empty);
            return;
        }

        window.GROUPS.forEach(group => {
            const row = document.createElement('div');
            row.className = 'group-item';
            row.classList.toggle('active', group.id === window.ACTIVE_GROUP_ID);

            const dot = document.createElement('span');
            dot.className = 'group-color';
            dot.style.background = group.color || '#6fe8ff';

            const name = document.createElement('span');
            name.className = 'group-name';
            name.textContent = group.name || 'Group';

            const count = document.createElement('span');
            count.className = 'group-count';
            count.textContent = String((group.node_ids || []).length);

            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.className = 'group-toggle';
            toggle.checked = group.visible !== false;
            toggle.onchange = (e) => {
                e.stopPropagation();
                group.visible = toggle.checked;
                saveGroups();
                window.updateSelectionVisuals();
                renderGroupList();
            };

            row.onclick = (e) => {
                if (e.target === toggle) return;
                window.ACTIVE_GROUP_ID = group.id;
                renderGroupList();
                window.setSelection(group.node_ids || []);
                window.updateSelectionVisuals();
            };

            row.appendChild(dot);
            row.appendChild(name);
            row.appendChild(count);
            row.appendChild(toggle);
            container.appendChild(row);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP BUTTON STATE
    // ═══════════════════════════════════════════════════════════════════════

    function updateGroupButtonState() {
        const btn = document.getElementById('btn-create-group');
        if (!btn) return;
        const hasSelection = window.SELECTED_NODE_IDS.size > 0;
        btn.classList.toggle('disabled', !hasSelection);
        btn.disabled = !hasSelection;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CREATE GROUP FROM SELECTION
    // ═══════════════════════════════════════════════════════════════════════

    function createGroupFromSelection() {
        if (window.SELECTED_NODE_IDS.size === 0) return;
        const nodeIds = Array.from(window.SELECTED_NODE_IDS);
        const groupId = `group_${Date.now().toString(36)}`;
        const groupName = `Group ${window.GROUPS.length + 1}`;
        const groupColor = getNextGroupColor();
        window.GROUPS.push({
            id: groupId,
            name: groupName,
            color: groupColor,
            node_ids: nodeIds,
            visible: true
        });
        window.ACTIVE_GROUP_ID = groupId;
        saveGroups();
        renderGroupList();
        window.updateSelectionVisuals();
        window.showToast(`Created ${groupName} (${nodeIds.length})`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        load: loadGroups,
        save: saveGroups,
        getNextColor: getNextGroupColor,
        getById: getGroupById,
        getPrimaryForNode: getPrimaryGroupForNode,
        renderList: renderGroupList,
        updateButtonState: updateGroupButtonState,
        createFromSelection: createGroupFromSelection
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.loadGroups = GROUPS_MODULE.load;
window.saveGroups = GROUPS_MODULE.save;
window.getNextGroupColor = GROUPS_MODULE.getNextColor;
window.getGroupById = GROUPS_MODULE.getById;
window.getPrimaryGroupForNode = GROUPS_MODULE.getPrimaryForNode;
window.renderGroupList = GROUPS_MODULE.renderList;
window.updateGroupButtonState = GROUPS_MODULE.updateButtonState;
window.createGroupFromSelection = GROUPS_MODULE.createFromSelection;

console.log('[Module] GROUPS_MODULE loaded - 8 functions');


// ═══ MODULE: modules/hover.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HOVER MODULE - Node hover and click interactions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node hover panel updates, click handling, and interaction management.
 * Depends on: HOVERED_NODE, VIS_FILTERS, GRAPH_MODE, DM, Graph
 *
 * @module HOVER
 * @version 1.0.0
 */

window.HOVER = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE HOVER PANEL
    // ═══════════════════════════════════════════════════════════════════════

    function updateHoverPanel(node) {
        const hoverPanel = document.getElementById('hover-panel');
        const placeholder = document.getElementById('hover-placeholder');
        if (!hoverPanel) return;

        if (!node) {
            hoverPanel.classList.remove('has-node');
            if (placeholder) placeholder.style.display = '';
            return;
        }

        hoverPanel.classList.add('has-node');
        if (placeholder) placeholder.style.display = 'none';

        // Helper to set element text safely
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val ?? '--';
        };

        // Basic info
        setEl('hover-name', node.label || node.id || 'Unknown');
        setEl('hover-type', node.type || node.kind || '--');
        setEl('hover-file', node.file_path || '--');

        // Tier/Ring/Family
        setEl('hover-tier', window.getNodeTier ? window.getNodeTier(node) : (node.tier || '--'));
        setEl('hover-ring', window.getNodeRing ? window.getNodeRing(node) : (node.ring || '--'));
        setEl('hover-family', window.getNodeAtomFamily ? window.getNodeAtomFamily(node) : (node.atom_family || '--'));

        // Metrics
        setEl('hover-complexity', node.complexity ?? '--');
        setEl('hover-loc', node.lines_of_code ?? node.loc ?? '--');
        setEl('hover-fanin', node.in_degree ?? '--');
        setEl('hover-fanout', node.out_degree ?? '--');

        // Role
        setEl('hover-role', node.role || '--');

        // Code preview (if available)
        const codeEl = document.getElementById('hover-code');
        if (codeEl) {
            const code = node.body_source || node.body || '';
            codeEl.textContent = code ? code.substring(0, 500) : '// no source';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE HOVER
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeHover(node, data) {
        const filePanel = document.getElementById('file-panel');
        window.HOVERED_NODE = node || null;

        // Always update hover panel
        updateHoverPanel(node);

        // Guard: file-panel may not exist
        if (!filePanel) return;

        const VIS_FILTERS = window.VIS_FILTERS;
        if (!VIS_FILTERS.metadata.showFilePanel) {
            filePanel.classList.remove('visible');
            return;
        }

        if (!node) {
            setTimeout(() => {
                if (!window.fileMode) filePanel.classList.remove('visible');
            }, 300);
            return;
        }

        // Get file info from boundaries
        const boundaries = data.file_boundaries || [];
        const fileIdx = node.fileIdx;

        if (fileIdx < 0 || fileIdx >= boundaries.length) {
            return;
        }

        const fileInfo = boundaries[fileIdx];

        // Update panel content
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        };
        setEl('file-name', fileInfo.file_name || 'unknown');
        setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
        setEl('file-purpose', fileInfo.purpose || '--');
        setEl('file-atom-count', fileInfo.atom_count || 0);
        setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
        setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
        setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

        // Code preview from node body
        const code = node.body || '// no source available';
        setEl('file-code', code);

        // Show panel
        filePanel.classList.add('visible');
        if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE CLICK
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeClick(node, event) {
        if (!node) return;
        const additive = event && event.shiftKey;
        if (additive) {
            window.toggleSelection(node);
            return;
        }
        if (node.id) {
            window.setSelection([node.id]);
        }
        const GRAPH_MODE = window.GRAPH_MODE;
        if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
            window.toggleFileExpand(node.fileIdx);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updatePanel: updateHoverPanel,
        onNodeHover: handleNodeHover,
        onNodeClick: handleNodeClick
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateHoverPanel = HOVER.updatePanel;
window.handleNodeHover = HOVER.onNodeHover;
window.handleNodeClick = HOVER.onNodeClick;

console.log('[Module] HOVER loaded - 3 functions');


// ═══ MODULE: modules/flow.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * FLOW MODULE - Flow visualization mode with presets
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Flow mode highlights high-entropy nodes and edge transition probabilities.
 * Cycles through visual presets (EMBER, OCEAN, PLASMA, MATRIX, PULSE, AURORA).
 * Depends on: Graph, DM, THEME_CONFIG, APPEARANCE_CONFIG, FLOW_CONFIG
 *
 * @module FLOW
 * @version 1.0.0
 */

window.FLOW = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // PRESET COLOR/VALUE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getFlowPresetColor(presetName, property, fallback) {
        const schemes = (window.THEME_CONFIG && window.THEME_CONFIG.colors && window.THEME_CONFIG.colors.schemes) || {};
        const scheme = schemes[presetName.toLowerCase()] || {};
        return scheme[property] || fallback;
    }

    function getFlowPresetValue(presetName, property, fallback) {
        const presets = (typeof window.APPEARANCE_CONFIG !== 'undefined' && window.APPEARANCE_CONFIG && window.APPEARANCE_CONFIG['flow-presets']) || {};
        const preset = presets[presetName.toLowerCase()] || {};
        const value = preset[property];
        return (value !== undefined && value !== null) ? value : fallback;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FLOW PRESETS
    // ═══════════════════════════════════════════════════════════════════════

    const PRESETS = [
        {
            name: 'EMBER',
            highlightColor: getFlowPresetColor('EMBER', 'highlightColor', getFlowPresetValue('ember', 'highlightColor', '#ff8c00')),
            particleColor: getFlowPresetColor('EMBER', 'particleColor', getFlowPresetValue('ember', 'particleColor', '#ffaa00')),
            dimColor: getFlowPresetColor('EMBER', 'dimColor', getFlowPresetValue('ember', 'dimColor', '#331100')),
            edgeColor: getFlowPresetColor('EMBER', 'edgeColor', getFlowPresetValue('ember', 'edgeColor', '#ff6600')),
            particleCount: getFlowPresetValue('ember', 'particleCount', 3),
            particleWidth: getFlowPresetValue('ember', 'particleWidth', 2.5),
            particleSpeed: getFlowPresetValue('ember', 'particleSpeed', 0.008),
            edgeWidthScale: getFlowPresetValue('ember', 'edgeWidthScale', 3.0),
            sizeMultiplier: getFlowPresetValue('ember', 'sizeMultiplier', 1.8),
            edgeOpacityMin: getFlowPresetValue('ember', 'edgeOpacityMin', 0.3),
            dimOpacity: getFlowPresetValue('ember', 'dimOpacity', 0.05)
        },
        {
            name: 'OCEAN',
            highlightColor: getFlowPresetColor('OCEAN', 'highlightColor', getFlowPresetValue('ocean', 'highlightColor', '#00d4ff')),
            particleColor: getFlowPresetColor('OCEAN', 'particleColor', getFlowPresetValue('ocean', 'particleColor', '#4df0ff')),
            dimColor: getFlowPresetColor('OCEAN', 'dimColor', getFlowPresetValue('ocean', 'dimColor', '#001122')),
            edgeColor: getFlowPresetColor('OCEAN', 'edgeColor', getFlowPresetValue('ocean', 'edgeColor', '#0088cc')),
            particleCount: getFlowPresetValue('ocean', 'particleCount', 4),
            particleWidth: getFlowPresetValue('ocean', 'particleWidth', 2.0),
            particleSpeed: getFlowPresetValue('ocean', 'particleSpeed', 0.006),
            edgeWidthScale: getFlowPresetValue('ocean', 'edgeWidthScale', 2.5),
            sizeMultiplier: getFlowPresetValue('ocean', 'sizeMultiplier', 1.6),
            edgeOpacityMin: getFlowPresetValue('ocean', 'edgeOpacityMin', 0.25),
            dimOpacity: getFlowPresetValue('ocean', 'dimOpacity', 0.03)
        },
        {
            name: 'PLASMA',
            highlightColor: getFlowPresetColor('PLASMA', 'highlightColor', getFlowPresetValue('plasma', 'highlightColor', '#ff00ff')),
            particleColor: getFlowPresetColor('PLASMA', 'particleColor', getFlowPresetValue('plasma', 'particleColor', '#ff66ff')),
            dimColor: getFlowPresetColor('PLASMA', 'dimColor', getFlowPresetValue('plasma', 'dimColor', '#110011')),
            edgeColor: getFlowPresetColor('PLASMA', 'edgeColor', getFlowPresetValue('plasma', 'edgeColor', '#cc00cc')),
            particleCount: getFlowPresetValue('plasma', 'particleCount', 5),
            particleWidth: getFlowPresetValue('plasma', 'particleWidth', 3.0),
            particleSpeed: getFlowPresetValue('plasma', 'particleSpeed', 0.012),
            edgeWidthScale: getFlowPresetValue('plasma', 'edgeWidthScale', 4.0),
            sizeMultiplier: getFlowPresetValue('plasma', 'sizeMultiplier', 2.0),
            edgeOpacityMin: getFlowPresetValue('plasma', 'edgeOpacityMin', 0.35),
            dimOpacity: getFlowPresetValue('plasma', 'dimOpacity', 0.04)
        },
        {
            name: 'MATRIX',
            highlightColor: getFlowPresetColor('MATRIX', 'highlightColor', getFlowPresetValue('matrix', 'highlightColor', '#00ff00')),
            particleColor: getFlowPresetColor('MATRIX', 'particleColor', getFlowPresetValue('matrix', 'particleColor', '#88ff88')),
            dimColor: getFlowPresetColor('MATRIX', 'dimColor', getFlowPresetValue('matrix', 'dimColor', '#001100')),
            edgeColor: getFlowPresetColor('MATRIX', 'edgeColor', getFlowPresetValue('matrix', 'edgeColor', '#00cc00')),
            particleCount: getFlowPresetValue('matrix', 'particleCount', 6),
            particleWidth: getFlowPresetValue('matrix', 'particleWidth', 1.5),
            particleSpeed: getFlowPresetValue('matrix', 'particleSpeed', 0.015),
            edgeWidthScale: getFlowPresetValue('matrix', 'edgeWidthScale', 2.0),
            sizeMultiplier: getFlowPresetValue('matrix', 'sizeMultiplier', 1.4),
            edgeOpacityMin: getFlowPresetValue('matrix', 'edgeOpacityMin', 0.2),
            dimOpacity: getFlowPresetValue('matrix', 'dimOpacity', 0.02)
        },
        {
            name: 'PULSE',
            highlightColor: getFlowPresetColor('PULSE', 'highlightColor', getFlowPresetValue('pulse', 'highlightColor', '#ff4444')),
            particleColor: getFlowPresetColor('PULSE', 'particleColor', getFlowPresetValue('pulse', 'particleColor', '#ff8888')),
            dimColor: getFlowPresetColor('PULSE', 'dimColor', getFlowPresetValue('pulse', 'dimColor', '#110000')),
            edgeColor: getFlowPresetColor('PULSE', 'edgeColor', getFlowPresetValue('pulse', 'edgeColor', '#cc2222')),
            particleCount: getFlowPresetValue('pulse', 'particleCount', 2),
            particleWidth: getFlowPresetValue('pulse', 'particleWidth', 4.0),
            particleSpeed: getFlowPresetValue('pulse', 'particleSpeed', 0.004),
            edgeWidthScale: getFlowPresetValue('pulse', 'edgeWidthScale', 5.0),
            sizeMultiplier: getFlowPresetValue('pulse', 'sizeMultiplier', 2.2),
            edgeOpacityMin: getFlowPresetValue('pulse', 'edgeOpacityMin', 0.4),
            dimOpacity: getFlowPresetValue('pulse', 'dimOpacity', 0.06)
        },
        {
            name: 'AURORA',
            highlightColor: getFlowPresetColor('AURORA', 'highlightColor', getFlowPresetValue('aurora', 'highlightColor', '#33ccbb')),
            particleColor: getFlowPresetColor('AURORA', 'particleColor', getFlowPresetValue('aurora', 'particleColor', '#66ffee')),
            dimColor: getFlowPresetColor('AURORA', 'dimColor', getFlowPresetValue('aurora', 'dimColor', '#002222')),
            edgeColor: getFlowPresetColor('AURORA', 'edgeColor', getFlowPresetValue('aurora', 'edgeColor', '#22aa99')),
            particleCount: getFlowPresetValue('aurora', 'particleCount', 4),
            particleWidth: getFlowPresetValue('aurora', 'particleWidth', 2.2),
            particleSpeed: getFlowPresetValue('aurora', 'particleSpeed', 0.007),
            edgeWidthScale: getFlowPresetValue('aurora', 'edgeWidthScale', 3.5),
            sizeMultiplier: getFlowPresetValue('aurora', 'sizeMultiplier', 1.7),
            edgeOpacityMin: getFlowPresetValue('aurora', 'edgeOpacityMin', 0.28),
            dimOpacity: getFlowPresetValue('aurora', 'dimOpacity', 0.04)
        }
    ];

    let currentPresetIndex = 0;

    // ═══════════════════════════════════════════════════════════════════════
    // TOGGLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function toggle() {
        const flowMode = window.flowMode;

        // If already in flow mode, cycle to next preset
        if (flowMode) {
            currentPresetIndex = (currentPresetIndex + 1) % PRESETS.length;
            const preset = PRESETS[currentPresetIndex];
            console.log(`[Flow] Cycling to preset: ${preset.name}`);
            applyVisualization();
            window.showModeToast(`FLOW: ${preset.name}`);
            return;
        }

        window.flowMode = true;
        currentPresetIndex = 0;
        console.log('[Flow] Toggled to:', window.flowMode);

        // Sync BOTH potential buttons (Dock vs CommandBar)
        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.toggle('active', window.flowMode);

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.toggle('active', window.flowMode);

        // Show/hide flow legend
        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.toggle('visible', window.flowMode);

        // EXCLUSIVE MODE: Clear other visual noise
        if (typeof window.clearAllFileModes === 'function') {
            window.clearAllFileModes();
        }
        // Ensure standard file/hull buttons are off
        document.querySelectorAll('.file-mode-btn').forEach(b => b.classList.remove('active'));

        applyVisualization();
        const preset = PRESETS[currentPresetIndex];
        window.showModeToast(`FLOW: ${preset.name}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DISABLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function disable() {
        if (!window.flowMode) return;
        window.flowMode = false;
        currentPresetIndex = 0;

        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.remove('active');

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.remove('active');

        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.remove('visible');

        clearVisualization();
        window.showModeToast('Flow mode off');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyVisualization() {
        const Graph = window.Graph;
        const DM = window.DM;

        // Guard: Ensure Graph is ready
        if (!Graph || !DM) {
            console.warn('[Flow] Graph or DM not ready');
            return;
        }

        // Get current preset settings
        const preset = PRESETS[currentPresetIndex];
        const markov = DM.getMarkov ? DM.getMarkov() : {};
        const highEntropy = markov.high_entropy_nodes || [];

        // Use preset values (fallback to FLOW_CONFIG for topK/minWeight if not in preset)
        const flowCfg = window.FLOW_CONFIG || {};
        const highlightColor = preset.highlightColor;
        const particleColor = preset.particleColor;
        const sizeMult = preset.sizeMultiplier;
        const edgeScale = preset.edgeWidthScale;
        const particleCount = preset.particleCount;
        const particleWidth = preset.particleWidth;
        const particleSpeed = preset.particleSpeed;
        const edgeOpacityMin = preset.edgeOpacityMin;
        const dimOpacity = preset.dimOpacity;
        const topK = flowCfg.topKEdges || 3;
        const minWeight = flowCfg.minWeight || 0.01;

        // Build set of high entropy node names
        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();
        highEntropy.forEach(n => highEntropyNodes.add(n.node));
        window.highEntropyNodes = highEntropyNodes;

        const graphNodes = Graph.graphData().nodes;
        const graphLinks = Graph.graphData().links;

        // THRESHOLDING: Build a map of top-K outgoing edges per source node
        const edgesBySource = new Map();
        graphLinks.forEach(link => {
            const srcId = typeof link.source === 'object' ? link.source.id : link.source;
            if (!edgesBySource.has(srcId)) {
                edgesBySource.set(srcId, []);
            }
            edgesBySource.get(srcId).push(link);
        });

        // For each source, keep only top-K by markov_weight (transition probability)
        const visibleEdges = new Set();
        edgesBySource.forEach((edges, srcId) => {
            const sorted = edges
                .filter(e => (e.markov_weight || 0) >= minWeight)
                .sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0))
                .slice(0, topK);
            sorted.forEach(e => visibleEdges.add(e));
        });

        // Store original colors and sizes, then apply flow coloring
        const originalNodeColors = window.originalNodeColors || new Map();
        window.originalNodeColors = originalNodeColors;

        graphNodes.forEach(node => {
            if (!originalNodeColors.has(node.id)) {
                originalNodeColors.set(node.id, node.color);
            }
            // Restore original size first (in case switching presets)
            if (node._originalVal) {
                node.val = node._originalVal;
            } else {
                node._originalVal = node.val || 1;
            }
            // High entropy nodes highlighted (decision points)
            if (highEntropyNodes.has(node.name)) {
                node.color = highlightColor;
                node.val = node._originalVal * sizeMult;
            }
        });

        // Update link widths based on markov_weight (with amplification)
        const maxMarkov = Math.max(0.001, ...graphLinks.map(l => l.markov_weight || 0));
        const amplify = window.amplify || (x => x);

        Graph.linkWidth(link => {
            if (!visibleEdges.has(link)) return 0.1;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return 0.5 + amplified * edgeScale * 2;
        });

        // Update link opacity to emphasize important edges
        Graph.linkOpacity(link => {
            if (!visibleEdges.has(link)) return dimOpacity;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return edgeOpacityMin + amplified * (1.0 - edgeOpacityMin);
        });

        // Add directional particles only on visible edges
        Graph.linkDirectionalParticles(link => {
            if (!visibleEdges.has(link)) return 0;
            return particleCount;
        });
        Graph.linkDirectionalParticleWidth(particleWidth);
        Graph.linkDirectionalParticleSpeed(particleSpeed);
        Graph.linkDirectionalParticleColor(() => particleColor);

        // Update node coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }

        // Debug: count edges with markov weights
        const edgesWithMarkov = graphLinks.filter(l => l.markov_weight > 0).length;
        console.log(`[Flow] Preset: ${preset.name} | ${highEntropyNodes.size} high entropy nodes, ${visibleEdges.size} visible edges (top-${topK}), ${edgesWithMarkov}/${graphLinks.length} edges with markov`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CLEAR FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function clearVisualization() {
        const Graph = window.Graph;

        // Guard: Ensure Graph is ready
        if (!Graph) return;

        const graphNodes = Graph.graphData().nodes;
        const originalNodeColors = window.originalNodeColors || new Map();

        // Restore original node colors and sizes
        graphNodes.forEach(node => {
            if (originalNodeColors.has(node.id)) {
                node.color = originalNodeColors.get(node.id);
            }
            // Restore original size from saved value
            if (node._originalVal) {
                node.val = node._originalVal;
                delete node._originalVal;
            }
        });

        // Reset link widths
        Graph.linkWidth(1);

        // Reset link opacity
        Graph.linkOpacity(0.6);

        // Remove directional particles
        Graph.linkDirectionalParticles(0);

        // Update coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getPresetColor: getFlowPresetColor,
        getPresetValue: getFlowPresetValue,
        toggle: toggle,
        disable: disable,
        apply: applyVisualization,
        clear: clearVisualization,
        PRESETS: PRESETS,
        getCurrentPreset: () => PRESETS[currentPresetIndex],
        getCurrentPresetIndex: () => currentPresetIndex
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getFlowPresetColor = FLOW.getPresetColor;
window.getFlowPresetValue = FLOW.getPresetValue;
window.toggleFlowMode = FLOW.toggle;
window.disableFlowMode = FLOW.disable;
window.applyFlowVisualization = FLOW.apply;
window.clearFlowVisualization = FLOW.clear;
window.FLOW_PRESETS = FLOW.PRESETS;

console.log('[Module] FLOW loaded - 6 functions');


// ═══ MODULE: modules/ui-builders.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UI-BUILDERS MODULE - DOM element construction utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Factory functions for building common UI elements: checkboxes, toggles,
 * filter groups, and option selectors.
 *
 * @module UI_BUILDERS
 * @version 1.0.0
 */

window.UI_BUILDERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // COUNT COLLECTION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Collect counts by key from items
     * @param {Array} items - Items to count
     * @param {Function} keyFn - Function to extract key from item
     * @returns {Array} Array of [key, count] pairs sorted by count desc
     */
    function collectCounts(items, keyFn) {
        const counts = new Map();
        items.forEach(item => {
            const key = keyFn(item);
            if (!key) return;
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHECKBOX ROW
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a checkbox row element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Element ID
     * @param {string} label - Display label
     * @param {number|null} count - Optional count to display
     * @param {boolean} checked - Initial checked state
     * @param {Function} onChange - Callback when checkbox changes
     * @returns {HTMLInputElement} The checkbox input element
     */
    function buildCheckboxRow(container, id, label, count, checked, onChange) {
        const row = document.createElement('div');
        row.className = 'filter-item';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = id;
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('label');
        text.setAttribute('for', id);
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'filter-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        row.appendChild(input);
        row.appendChild(text);
        if (countEl.textContent) {
            row.appendChild(countEl);
        }
        container.appendChild(row);

        return input;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER GROUP
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a filter group with ALL checkbox and individual items
     * @param {string} containerId - Container element ID
     * @param {Array} items - Array of [value, count] pairs
     * @param {Set} stateSet - Set to track selected values
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildFilterGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const allId = `${containerId}-all`;
        let allCheckbox = null;

        allCheckbox = buildCheckboxRow(container, allId, 'ALL', null, true, (checked) => {
            stateSet.clear();
            if (checked) {
                items.forEach(([value]) => stateSet.add(value));
            }
            container.querySelectorAll('input[type="checkbox"]').forEach(box => {
                if (box.id !== allId) box.checked = checked;
            });
            onUpdate();
        });

        items.forEach(([value, count], index) => {
            const id = `${containerId}-${index}`;
            const checked = stateSet.has(value);
            buildCheckboxRow(container, id, value, count, checked, (isChecked) => {
                if (isChecked) {
                    stateSet.add(value);
                } else {
                    stateSet.delete(value);
                }
                const allChecked = items.every(([v]) => stateSet.has(v));
                allCheckbox.checked = allChecked;
                onUpdate();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a datamap toggle element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Toggle ID
     * @param {string} label - Display label
     * @param {boolean} checked - Initial checked state
     * @param {number|null} count - Optional count to display
     * @param {Function} onChange - Callback when toggle changes
     * @returns {Object} Object with wrapper, input, and count elements
     */
    function buildDatamapToggle(container, id, label, checked, count, onChange) {
        const wrapper = document.createElement('label');
        wrapper.className = 'datamap-toggle';
        wrapper.setAttribute('data-id', id);

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('span');
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'datamap-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        wrapper.appendChild(input);
        wrapper.appendChild(text);
        wrapper.appendChild(countEl);
        container.appendChild(wrapper);

        return { wrapper, input, count: countEl };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // EXCLUSIVE OPTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build exclusive (radio-like) options using checkboxes
     * @param {string} containerId - Container element ID
     * @param {Array} options - Array of {label, value} objects
     * @param {*} activeValue - Currently active value
     * @param {Function} onSelect - Callback when option is selected
     */
    function buildExclusiveOptions(containerId, options, activeValue, onSelect) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const inputs = [];
        options.forEach((option, index) => {
            const id = `${containerId}-${index}`;
            const input = buildCheckboxRow(
                container,
                id,
                option.label,
                null,
                option.value === activeValue,
                (checked) => {
                    if (!checked) {
                        input.checked = true;
                        return;
                    }
                    inputs.forEach(other => {
                        if (other !== input) other.checked = false;
                    });
                    onSelect(option.value);
                }
            );
            inputs.push(input);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        collectCounts: collectCounts,
        buildCheckboxRow: buildCheckboxRow,
        buildFilterGroup: buildFilterGroup,
        buildDatamapToggle: buildDatamapToggle,
        buildExclusiveOptions: buildExclusiveOptions
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.collectCounts = UI_BUILDERS.collectCounts;
window.buildCheckboxRow = UI_BUILDERS.buildCheckboxRow;
window.buildFilterGroup = UI_BUILDERS.buildFilterGroup;
window.buildDatamapToggle = UI_BUILDERS.buildDatamapToggle;
window.buildExclusiveOptions = UI_BUILDERS.buildExclusiveOptions;

console.log('[Module] UI_BUILDERS loaded - 5 functions');


// ═══ MODULE: modules/layout-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT-HELPERS MODULE - Layout stability and position utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Functions for saving/restoring node positions, freezing/unfreezing layout,
 * and calculating file positions.
 * Depends on: Graph, NODE_POSITION_CACHE, LAYOUT_FROZEN, IS_3D
 *
 * @module LAYOUT_HELPERS
 * @version 1.0.0
 */

window.LAYOUT_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // POSITION PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Save current node positions to cache
     */
    function saveNodePositions() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;
        if (!Graph || !cache) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined && node.y !== undefined) {
                cache.set(node.id, {
                    x: node.x, y: node.y, z: node.z || 0,
                    vx: node.vx || 0, vy: node.vy || 0, vz: node.vz || 0,
                    fx: node.fx, fy: node.fy, fz: node.fz
                });
            }
        });
    }

    /**
     * Restore node positions from cache
     * @param {Array} nodes - Nodes to restore positions for
     */
    function restoreNodePositions(nodes) {
        const cache = window.NODE_POSITION_CACHE;
        const frozen = window.LAYOUT_FROZEN;
        if (!cache) return;

        nodes.forEach(node => {
            const cached = cache.get(node.id);
            if (cached) {
                node.x = cached.x;
                node.y = cached.y;
                node.z = cached.z;
                node.vx = cached.vx;
                node.vy = cached.vy;
                node.vz = cached.vz;
                // Pin nodes in place when layout is frozen
                if (frozen) {
                    node.fx = cached.x;
                    node.fy = cached.y;
                    node.fz = cached.z;
                }
            }
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LAYOUT FREEZE/UNFREEZE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Freeze layout by pinning all nodes in place
     */
    function freezeLayout() {
        window.LAYOUT_FROZEN = true;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined) {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            }
        });
        Graph.cooldownTicks(0);  // Stop simulation immediately
    }

    /**
     * Unfreeze layout by unpinning all nodes
     */
    function unfreezeLayout() {
        window.LAYOUT_FROZEN = false;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            node.fx = undefined;
            node.fy = undefined;
            node.fz = undefined;
        });
    }

    /**
     * Reset layout - clear cache and reheat simulation
     */
    function resetLayout() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;

        // Clear position cache
        if (cache) cache.clear();

        // Unfreeze and restart simulation
        unfreezeLayout();

        if (Graph) {
            Graph.cooldownTicks(200);  // Allow simulation to run
            Graph.d3ReheatSimulation();
        }

        if (typeof window.showModeToast === 'function') {
            window.showModeToast('Layout reset - physics running');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LINK/FILE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get the ID of a link endpoint (source or target)
     * @param {Object} link - The link object
     * @param {string} side - 'source' or 'target'
     * @returns {string|undefined} The endpoint ID
     */
    function getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.id || endpoint;
        }
        return endpoint;
    }

    /**
     * Calculate target position for a file node in radial layout
     * @param {number} fileIdx - Index of the file
     * @param {number} totalFiles - Total number of files
     * @param {number} radius - Radius of the circle
     * @param {number} zSpacing - Z-axis spacing between files
     * @returns {Object} Position {x, y, z}
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpacing) {
        if (totalFiles <= 0) {
            return { x: 0, y: 0, z: 0 };
        }
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        const is3D = window.IS_3D;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: is3D ? (fileIdx - totalFiles / 2) * zSpacing : 0
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        savePositions: saveNodePositions,
        restorePositions: restoreNodePositions,
        freeze: freezeLayout,
        unfreeze: unfreezeLayout,
        reset: resetLayout,
        getLinkEndpointId: getLinkEndpointId,
        getFileTarget: getFileTarget
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.saveNodePositions = LAYOUT_HELPERS.savePositions;
window.restoreNodePositions = LAYOUT_HELPERS.restorePositions;
window.freezeLayout = LAYOUT_HELPERS.freeze;
window.unfreezeLayout = LAYOUT_HELPERS.unfreeze;
window.resetLayout = LAYOUT_HELPERS.reset;
window.getLinkEndpointId = LAYOUT_HELPERS.getLinkEndpointId;
window.getFileTarget = LAYOUT_HELPERS.getFileTarget;

console.log('[Module] LAYOUT_HELPERS loaded - 7 functions');


// ═══ MODULE: modules/spatial.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SPATIAL MODULE - Spatial algorithms and collision detection
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Spatial hashing for O(n) collision detection, convex hull calculation,
 * and node sampling utilities.
 * Depends on: IS_3D, FILE_CONTAINMENT, THREE
 *
 * @module SPATIAL
 * @version 1.0.0
 */

window.SPATIAL = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SAMPLING
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Sample nodes evenly if there are too many
     * @param {Array} nodes - Array of nodes
     * @param {number} maxPoints - Maximum number of points to return
     * @returns {Array} Sampled nodes
     */
    function sampleFileNodes(nodes, maxPoints) {
        if (nodes.length <= maxPoints) return nodes;
        const step = Math.ceil(nodes.length / maxPoints);
        return nodes.filter((_, idx) => idx % step === 0);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVEX HULL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build 2D convex hull using Andrew's monotone chain algorithm
     * @param {Array} points - Array of {x, y} points
     * @returns {Array|null} Hull points or null if insufficient points
     */
    function buildHull2D(points) {
        if (points.length < 3) return null;

        // Remove duplicates
        const unique = new Map();
        points.forEach(p => {
            const key = `${p.x.toFixed(4)},${p.y.toFixed(4)}`;
            if (!unique.has(key)) unique.set(key, p);
        });

        // Sort by x, then y
        const pts = Array.from(unique.values()).sort((a, b) => {
            if (a.x === b.x) return a.y - b.y;
            return a.x - b.x;
        });

        if (pts.length < 3) return null;

        // Cross product of vectors OA and OB
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

        // Build lower hull
        const lower = [];
        for (const p of pts) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                lower.pop();
            }
            lower.push(p);
        }

        // Build upper hull
        const upper = [];
        for (let i = pts.length - 1; i >= 0; i--) {
            const p = pts[i];
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                upper.pop();
            }
            upper.push(p);
        }

        // Remove last point of each half (it's the starting point of the other)
        upper.pop();
        lower.pop();

        return lower.concat(upper);
    }

    /**
     * Compute centroid of points
     * @param {Array} points - Array of THREE.Vector3-like objects
     * @returns {THREE.Vector3} Centroid
     */
    function computeCentroid(points) {
        const THREE = window.THREE;
        const centroid = new THREE.Vector3();
        points.forEach(p => centroid.add(p));
        return centroid.divideScalar(Math.max(1, points.length));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SPATIAL HASHING - O(n) collision detection
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build spatial hash grid for efficient neighbor queries
     * @param {Array} nodes - Array of nodes with x, y, z coordinates
     * @param {number} cellSize - Size of each grid cell
     * @returns {Map} Grid map with cell keys to node arrays
     */
    function buildSpatialGrid(nodes, cellSize) {
        const is3D = window.IS_3D;
        const grid = new Map();

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) grid.set(key, []);
            grid.get(key).push(node);
        });

        // Store for file containment
        if (window.FILE_CONTAINMENT) {
            window.FILE_CONTAINMENT.spatialGrid = grid;
        }

        return grid;
    }

    /**
     * Get keys for neighboring cells (3x3x3 in 3D, 3x3 in 2D)
     * @param {number} cellX - Cell X coordinate
     * @param {number} cellY - Cell Y coordinate
     * @param {number} cellZ - Cell Z coordinate
     * @returns {Array} Array of neighbor cell keys
     */
    function getNeighborCells(cellX, cellY, cellZ) {
        const is3D = window.IS_3D;
        const neighbors = [];

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = is3D ? -1 : 0; dz <= (is3D ? 1 : 0); dz++) {
                    neighbors.push(`${cellX + dx},${cellY + dy},${cellZ + dz}`);
                }
            }
        }

        return neighbors;
    }

    /**
     * Apply soft collision forces to push overlapping nodes apart
     * @param {Array} nodes - Array of nodes
     * @param {number} cellSize - Spatial grid cell size
     * @param {number} repulsionStrength - Strength of repulsion (0-1)
     */
    function applySoftCollisions(nodes, cellSize, repulsionStrength = 0.5) {
        const containment = window.FILE_CONTAINMENT;
        const is3D = window.IS_3D;

        if (!containment || !containment.collisionEnabled) return;

        const grid = buildSpatialGrid(nodes, cellSize);
        const minDist = 8;  // Minimum distance between particles
        const minDistSq = minDist * minDist;

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            if (!node.__physics) {
                node.__physics = { vx: 0, vy: 0, vz: 0 };
            }

            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const neighborKeys = getNeighborCells(cellX, cellY, cellZ);

            neighborKeys.forEach(key => {
                const cellNodes = grid.get(key);
                if (!cellNodes) return;

                cellNodes.forEach(other => {
                    if (other === node) return;

                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dz = is3D ? ((node.z || 0) - (other.z || 0)) : 0;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < minDistSq && distSq > 0.001) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        const force = (overlap / minDist) * repulsionStrength;

                        // Push apart along normal
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = is3D ? dz / dist : 0;

                        node.__physics.vx += nx * force;
                        node.__physics.vy += ny * force;
                        if (is3D) node.__physics.vz += nz * force;
                    }
                });
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        sampleFileNodes: sampleFileNodes,
        buildHull2D: buildHull2D,
        computeCentroid: computeCentroid,
        buildSpatialGrid: buildSpatialGrid,
        getNeighborCells: getNeighborCells,
        applySoftCollisions: applySoftCollisions
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.sampleFileNodes = SPATIAL.sampleFileNodes;
window.buildHull2D = SPATIAL.buildHull2D;
window.computeCentroid = SPATIAL.computeCentroid;
window.buildSpatialGrid = SPATIAL.buildSpatialGrid;
window.getNeighborCells = SPATIAL.getNeighborCells;
window.applySoftCollisions = SPATIAL.applySoftCollisions;

console.log('[Module] SPATIAL loaded - 6 functions');


// ═══ MODULE: modules/layout.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT MODULE - Unified UI Layout Engine
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * MIGRATED FROM: app.js HudLayoutManager (390 lines)
 * This is the SINGLE SOURCE OF TRUTH for UI layout intelligence.
 *
 * Features:
 *   - Panel placement with collision avoidance (from HudLayoutManager)
 *   - Component registration system (NEW)
 *   - Toast/control-bar collision detection (NEW)
 *   - Min-width graph validation (NEW)
 *   - Debug overlay with Ctrl+Shift+L (NEW)
 *
 * @module LAYOUT
 * @version 2.0.0
 * @confidence 94%
 */

window.LAYOUT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CONFIGURATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    const CONFIG = {
        MARGIN: 16,
        MIN_GRAPH_WIDTH: 320,
        REFLOW_THROTTLE_MS: 50,
        DEBUG_COLORS: {
            dock: 'rgba(100, 150, 255, 0.3)',
            overlay: 'rgba(255, 150, 100, 0.3)',
            floating: 'rgba(100, 255, 150, 0.3)',
            fixed: 'rgba(150, 150, 150, 0.3)'
        }
    };

    // Panels by priority (higher = more important, won't be moved)
    // MIGRATED from HudLayoutManager
    const FIXED_PANELS = ['top-left-header', 'stats-panel', 'metrics-panel', 'bottom-dock', 'report-panel', 'side-dock'];
    const DYNAMIC_PANELS = ['hover-panel', 'file-panel', 'selection-panel'];

    // ═══════════════════════════════════════════════════════════════════════
    // STATE
    // ═══════════════════════════════════════════════════════════════════════

    // Throttle state (from HudLayoutManager)
    let _rafPending = false;
    let _lastReflow = 0;

    // Mouse position for hover-panel placement (from HudLayoutManager)
    let _mouseX = 0;
    let _mouseY = 0;

    // Component registry (NEW)
    const _registry = new Map();

    // Debug overlay state (NEW)
    let _debugEnabled = false;
    let _debugOverlay = null;

    // ═══════════════════════════════════════════════════════════════════════
    // VIEWPORT & RECT UTILITIES (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get viewport rectangle with margins
     */
    function getViewport() {
        return {
            left: CONFIG.MARGIN,
            top: CONFIG.MARGIN,
            right: window.innerWidth - CONFIG.MARGIN,
            bottom: window.innerHeight - CONFIG.MARGIN,
            width: window.innerWidth - 2 * CONFIG.MARGIN,
            height: window.innerHeight - 2 * CONFIG.MARGIN
        };
    }

    /**
     * Check if sidebar is effectively "open" (occupying space)
     */
    function isSidebarOpen() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock) return false;
        const state = window.SIDEBAR_STATE;
        return (state && (state.locked || state.open)) ||
            sideDock.classList.contains('locked') ||
            sideDock.classList.contains('expanded') ||
            sideDock.matches(':hover');
    }

    /**
     * Get rectangle for an element (returns null if hidden/missing)
     */
    function getRect(el) {
        if (!el) return null;
        if (typeof el === 'string') {
            el = document.getElementById(el) || document.querySelector(el);
        }
        if (!el) return null;
        const style = window.getComputedStyle(el);
        if (style.display === 'none' || style.visibility === 'hidden') return null;
        const r = el.getBoundingClientRect();
        if (r.width === 0 && r.height === 0) return null;
        return { left: r.left, top: r.top, right: r.right, bottom: r.bottom, width: r.width, height: r.height };
    }

    /**
     * Get sidebar occupied region (full expanded width when open)
     */
    function getSidebarRect() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock || !isSidebarOpen()) return null;
        const sideWidth = parseInt(getComputedStyle(sideDock).getPropertyValue('--side-width')) || 260;
        return {
            left: 0,
            top: 0,
            right: 16 + sideWidth + 20,
            bottom: window.innerHeight,
            width: 16 + sideWidth + 20,
            height: window.innerHeight
        };
    }

    /**
     * Get all occupied rectangles (fixed panels + sidebar when open)
     */
    function getOccupiedRects() {
        const rects = [];

        // Sidebar takes priority when open
        const sidebarRect = getSidebarRect();
        if (sidebarRect) rects.push(sidebarRect);

        // Fixed panels
        FIXED_PANELS.forEach(id => {
            if (id === 'side-dock') return;
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (rect) rects.push(rect);
        });

        // Top-left header (special case - class-based)
        const topLeft = document.querySelector('.top-left');
        const topLeftRect = getRect(topLeft);
        if (topLeftRect) rects.push(topLeftRect);

        return rects;
    }

    /**
     * Calculate overlap area between two rectangles
     */
    function overlapArea(r1, r2) {
        if (!r1 || !r2) return 0;
        const xOverlap = Math.max(0, Math.min(r1.right, r2.right) - Math.max(r1.left, r2.left));
        const yOverlap = Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
        return xOverlap * yOverlap;
    }

    /**
     * Check if rect is fully inside viewport
     */
    function isInsideViewport(rect, viewport) {
        return rect.left >= viewport.left &&
            rect.top >= viewport.top &&
            rect.right <= viewport.right &&
            rect.bottom <= viewport.bottom;
    }

    /**
     * Clamp position to keep panel inside viewport
     */
    function clampToViewport(pos, panelWidth, panelHeight, viewport) {
        return {
            left: Math.max(viewport.left, Math.min(pos.left, viewport.right - panelWidth)),
            top: Math.max(viewport.top, Math.min(pos.top, viewport.bottom - panelHeight))
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CANDIDATE GENERATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Generate candidate positions for file panel
     */
    function getFilePanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Generate candidate positions for selection panel
     */
    function getSelectionPanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Get screen centroid of selected nodes
     */
    function getSelectionCentroid() {
        const Graph = window.Graph;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (!Graph || !Graph.graphData || !selectedIds || selectedIds.size === 0) return null;

        const nodes = Graph.graphData().nodes || [];
        const selectedNodes = nodes.filter(n => selectedIds.has(n.id));
        if (selectedNodes.length === 0) return null;

        let sumX = 0, sumY = 0, sumZ = 0;
        selectedNodes.forEach(n => {
            sumX += n.x || 0;
            sumY += n.y || 0;
            sumZ += n.z || 0;
        });
        const centroid3D = {
            x: sumX / selectedNodes.length,
            y: sumY / selectedNodes.length,
            z: sumZ / selectedNodes.length
        };

        const camera = Graph.camera();
        if (!camera || !window.THREE) return null;
        const vector = new window.THREE.Vector3(centroid3D.x, centroid3D.y, centroid3D.z);
        vector.project(camera);
        return {
            x: (vector.x * 0.5 + 0.5) * window.innerWidth,
            y: (-vector.y * 0.5 + 0.5) * window.innerHeight
        };
    }

    /**
     * Generate candidate positions for hover panel
     */
    function getHoverPanelCandidates(mouseX, mouseY, panelWidth, panelHeight) {
        const vp = getViewport();
        const offset = 16;

        let anchorX = mouseX;
        let anchorY = mouseY;

        const hoveredNode = window.HOVERED_NODE;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (hoveredNode && selectedIds && selectedIds.has(hoveredNode.id)) {
            const centroid = getSelectionCentroid();
            if (centroid) {
                anchorX = mouseX * 0.3 + centroid.x * 0.7;
                anchorY = mouseY * 0.3 + centroid.y * 0.7;
            }
        }

        const sidebarOpen = isSidebarOpen();
        const sidebarRect = sidebarOpen ? getSidebarRect() : null;
        const minLeft = sidebarRect ? sidebarRect.right + offset : vp.left;

        let candidates = [
            { left: anchorX + offset, top: anchorY - panelHeight - offset },
            { left: anchorX + offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY - panelHeight - offset }
        ];

        if (sidebarRect) {
            candidates = candidates.map(c => ({
                left: Math.max(c.left, minLeft),
                top: c.top
            }));
        }

        return candidates;
    }

    /**
     * Update mouse position
     */
    function updateMousePosition(x, y) {
        _mouseX = x;
        _mouseY = y;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PANEL PLACEMENT (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Place a panel at the best position (least overlap)
     */
    function placePanel(panelEl, candidates, occupiedRects) {
        if (!panelEl) return null;

        const rect = panelEl.getBoundingClientRect();
        const panelWidth = rect.width || 400;
        const panelHeight = rect.height || 350;
        const viewport = getViewport();

        let bestPos = candidates[0];
        let bestOverlap = Infinity;

        for (const pos of candidates) {
            const clampedPos = clampToViewport(pos, panelWidth, panelHeight, viewport);
            const panelRect = {
                left: clampedPos.left,
                top: clampedPos.top,
                right: clampedPos.left + panelWidth,
                bottom: clampedPos.top + panelHeight
            };

            let totalOverlap = 0;
            for (const occRect of occupiedRects) {
                totalOverlap += overlapArea(panelRect, occRect);
            }

            if (!isInsideViewport(panelRect, viewport)) {
                totalOverlap += 10000;
            }

            if (totalOverlap < bestOverlap) {
                bestOverlap = totalOverlap;
                bestPos = clampedPos;
                if (totalOverlap === 0) break;
            }
        }

        return bestPos;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST/CONTROL-BAR COLLISION (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Check and resolve toast/control-bar collision
     * Returns offset to apply to toast if collision detected
     */
    function resolveToastCollision() {
        const toast = document.getElementById('toast') ||
                      document.getElementById('hud-toast') ||
                      document.getElementById('mode-toast');
        const controlBar = document.querySelector('.control-bar');

        if (!toast || !controlBar) return 0;

        const toastRect = getRect(toast);
        const barRect = getRect(controlBar);

        if (!toastRect || !barRect) return 0;

        const overlap = overlapArea(toastRect, barRect);
        if (overlap > 0) {
            // Move toast above control bar
            const offset = barRect.height + CONFIG.MARGIN;
            console.log(`[LAYOUT] Toast/control-bar collision: ${overlap}px², offset: -${offset}px`);
            return -offset;
        }
        return 0;
    }

    /**
     * Apply toast offset if needed
     */
    function applyToastOffset() {
        const offset = resolveToastCollision();
        if (offset !== 0) {
            const toast = document.getElementById('toast') ||
                          document.getElementById('hud-toast');
            if (toast) {
                toast.style.transform = `translateX(-50%) translateY(${offset}px)`;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MIN-WIDTH VALIDATOR (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Validate graph has minimum width, adjust sidebars if needed
     */
    function validateGraphWidth() {
        const leftSidebar = document.getElementById('left-sidebar');
        const rightSidebar = document.getElementById('right-sidebar');
        const viewport = getViewport();

        const leftWidth = leftSidebar ? (getRect(leftSidebar)?.width || 0) : 0;
        const rightWidth = rightSidebar ? (getRect(rightSidebar)?.width || 0) : 0;
        const graphWidth = viewport.width - leftWidth - rightWidth;

        if (graphWidth < CONFIG.MIN_GRAPH_WIDTH) {
            const deficit = CONFIG.MIN_GRAPH_WIDTH - graphWidth;
            console.warn(`[LAYOUT] Graph width ${graphWidth}px < ${CONFIG.MIN_GRAPH_WIDTH}px minimum`);

            // Try to reduce right sidebar
            if (rightSidebar && rightWidth > 200) {
                const newWidth = Math.max(200, rightWidth - deficit);
                document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
                return { adjusted: true, component: 'right-sidebar', newWidth };
            }
        }
        return { adjusted: false };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // REFLOW (from HudLayoutManager, enhanced)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Reflow all dynamic panels
     */
    function reflow() {
        const now = Date.now();
        if (now - _lastReflow < CONFIG.REFLOW_THROTTLE_MS) {
            if (!_rafPending) {
                _rafPending = true;
                requestAnimationFrame(() => {
                    _rafPending = false;
                    reflow();
                });
            }
            return;
        }
        _lastReflow = now;

        const occupiedRects = getOccupiedRects();

        // Place hover panel first (higher priority)
        const hoverPanel = document.getElementById('hover-panel');
        let hoverPanelRect = null;
        if (hoverPanel && hoverPanel.classList.contains('visible')) {
            const hoverWidth = hoverPanel.offsetWidth || 280;
            const hoverHeight = hoverPanel.offsetHeight || 200;
            const candidates = getHoverPanelCandidates(_mouseX, _mouseY, hoverWidth, hoverHeight);
            const pos = placePanel(hoverPanel, candidates, occupiedRects);
            if (pos) {
                hoverPanel.style.left = pos.left + 'px';
                hoverPanel.style.top = pos.top + 'px';
                hoverPanel.style.right = 'auto';
                hoverPanelRect = {
                    left: pos.left, top: pos.top,
                    right: pos.left + hoverWidth, bottom: pos.top + hoverHeight
                };
            }
        }

        const filePanelOccupied = [...occupiedRects];
        if (hoverPanelRect) filePanelOccupied.push(hoverPanelRect);

        // Place selection panel
        const selectionPanel = document.getElementById('selection-panel');
        if (selectionPanel && selectionPanel.classList.contains('visible')) {
            const candidates = getSelectionPanelCandidates(
                selectionPanel.offsetWidth || 320,
                selectionPanel.offsetHeight || 280
            );
            const pos = placePanel(selectionPanel, candidates, filePanelOccupied);
            if (pos) {
                selectionPanel.style.left = pos.left + 'px';
                selectionPanel.style.top = pos.top + 'px';
                selectionPanel.style.right = 'auto';
                filePanelOccupied.push({
                    left: pos.left, top: pos.top,
                    right: pos.left + (selectionPanel.offsetWidth || 320),
                    bottom: pos.top + (selectionPanel.offsetHeight || 280)
                });
            }
        }

        // Place file panel
        const filePanel = document.getElementById('file-panel');
        if (filePanel && filePanel.classList.contains('visible')) {
            const candidates = getFilePanelCandidates(
                filePanel.offsetWidth || 400,
                filePanel.offsetHeight || 350
            );
            const pos = placePanel(filePanel, candidates, filePanelOccupied);
            if (pos) {
                filePanel.style.left = pos.left + 'px';
                filePanel.style.top = pos.top + 'px';
                filePanel.style.bottom = 'auto';
            }
        }

        // NEW: Check toast/control-bar collision
        applyToastOffset();

        // NEW: Validate graph width
        validateGraphWidth();

        // NEW: Update debug overlay
        if (_debugEnabled) updateDebugOverlay();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DEBUG OVERLAY (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle debug overlay
     */
    function toggleDebugOverlay() {
        _debugEnabled = !_debugEnabled;

        if (_debugEnabled) {
            if (!_debugOverlay) {
                _debugOverlay = document.createElement('div');
                _debugOverlay.id = 'layout-debug-overlay';
                _debugOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none; z-index: 10001;
                `;
                document.body.appendChild(_debugOverlay);
            }
            updateDebugOverlay();
            console.log('[LAYOUT] Debug overlay ON (Ctrl+Shift+L)');
        } else {
            if (_debugOverlay) {
                _debugOverlay.remove();
                _debugOverlay = null;
            }
            console.log('[LAYOUT] Debug overlay OFF');
        }
    }

    /**
     * Update debug overlay with current component bounds
     */
    function updateDebugOverlay() {
        if (!_debugOverlay) return;

        let html = '';
        const allPanels = [...FIXED_PANELS, ...DYNAMIC_PANELS, 'toast', 'control-bar', 'left-sidebar', 'right-sidebar'];

        allPanels.forEach(id => {
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (!rect) return;

            const kind = FIXED_PANELS.includes(id) ? 'fixed' :
                         DYNAMIC_PANELS.includes(id) ? 'floating' : 'overlay';
            const color = CONFIG.DEBUG_COLORS[kind] || 'rgba(128,128,128,0.3)';

            html += `
                <div style="
                    position: fixed;
                    left: ${rect.left}px; top: ${rect.top}px;
                    width: ${rect.width}px; height: ${rect.height}px;
                    background: ${color};
                    border: 1px solid ${color.replace('0.3', '0.8')};
                    font-size: 10px; color: white; text-shadow: 0 0 2px black;
                    padding: 2px 4px; box-sizing: border-box; overflow: hidden;
                ">${id}</div>
            `;
        });

        _debugOverlay.innerHTML = html;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COMPONENT REGISTRATION (NEW - for future explicit constraints)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Register a component (for explicit constraint tracking)
     */
    function register(descriptor) {
        const { id, selector, kind = 'dock' } = descriptor;
        if (!id) return null;

        let element = typeof selector === 'string' ?
            (document.getElementById(selector.replace('#', '')) || document.querySelector(selector)) :
            selector;

        _registry.set(id, { ...descriptor, element });
        console.log(`[LAYOUT] Registered: ${id} (${kind})`);
        return _registry.get(id);
    }

    /**
     * Get registered component
     */
    function get(id) {
        return _registry.get(id) || null;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize layout system
     */
    function init() {
        // Window resize
        window.addEventListener('resize', () => reflow());

        // Track mouse position
        window.addEventListener('mousemove', (e) => {
            updateMousePosition(e.clientX, e.clientY);
        }, { passive: true });

        // Sidebar state changes
        const sideDock = document.getElementById('side-dock');
        if (sideDock) {
            sideDock.addEventListener('mouseenter', () => reflow());
            sideDock.addEventListener('mouseleave', () => {
                setTimeout(() => reflow(), 200);
            });
        }

        // Debug overlay shortcut (Ctrl+Shift+L)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                e.preventDefault();
                toggleDebugOverlay();
            }
        });

        console.log('[LAYOUT] Initialized (replaces HudLayoutManager)');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Core utilities
        getViewport,
        getRect,
        overlapArea,
        isInsideViewport,
        clampToViewport,

        // Panel placement (backward compatible with HudLayoutManager)
        getOccupiedRects,
        placePanel,
        getFilePanelCandidates,
        getSelectionPanelCandidates,
        getHoverPanelCandidates,
        getSelectionCentroid,
        updateMousePosition,

        // Main entry points
        reflow,
        init,

        // NEW: Validation
        validateGraphWidth,
        resolveToastCollision,

        // NEW: Debug
        toggleDebugOverlay,

        // NEW: Registration
        register,
        get,

        // Config (read-only)
        CONFIG: Object.freeze({ ...CONFIG })
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY: HudLayoutManager alias
// ═══════════════════════════════════════════════════════════════════════════

window.HudLayoutManager = LAYOUT;
window.Layout = LAYOUT;

console.log('[Module] LAYOUT loaded - Unified Layout Engine v2.0.0');


// ═══ MODULE: modules/hud.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HUD MODULE - Heads-up display management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles HUD fade behavior and stats panel updates.
 * Depends on: DOM elements (stat-nodes, stat-edges, stat-entropy, etc.)
 *
 * @module HUD
 * @version 1.0.0
 */

window.HUD = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // HUD FADE BEHAVIOR
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup HUD auto-fade on idle
     * Fades HUD elements after period of inactivity
     */
    function setupFade() {
        const idleDelay = 2200;
        let timer = null;

        const activate = () => {
            document.body.classList.remove('hud-quiet');
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                document.body.classList.add('hud-quiet');
            }, idleDelay);
        };

        ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach((evt) => {
            window.addEventListener(evt, activate, { passive: true });
        });

        activate();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATS UPDATES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all HUD stats elements
     * @param {Object} data - Graph data with nodes, links, meta
     */
    function updateStats(data) {
        if (!data) return;

        // Stats panel: NODES, EDGES, ENTROPY
        const nodeCount = (data.nodes || []).length;
        const edgeCount = (data.links || []).length;

        const statNodes = document.getElementById('stat-nodes');
        const statEdges = document.getElementById('stat-edges');
        const statEntropy = document.getElementById('stat-entropy');

        if (statNodes) statNodes.textContent = nodeCount.toLocaleString();
        if (statEdges) statEdges.textContent = edgeCount.toLocaleString();
        if (statEntropy) {
            const entropy = data.meta?.entropy ?? data.entropy ?? '--';
            statEntropy.textContent = typeof entropy === 'number' ? entropy.toFixed(2) : entropy;
        }

        // Header panel: target name and timestamp
        const targetName = document.getElementById('target-name');
        const timestamp = document.getElementById('timestamp');

        if (targetName) {
            const target = data.meta?.target || data.target || 'Unknown';
            // Show just the last part of the path
            const shortTarget = target.split('/').pop() || target;
            targetName.textContent = shortTarget;
        }

        if (timestamp) {
            const ts = data.meta?.timestamp || data.timestamp || '';
            // Format: 2024-01-15T10:30:00 -> 2024-01-15 10:30
            const formatted = ts.replace('T', ' ').substring(0, 16);
            timestamp.textContent = formatted || 'Live';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupFade: setupFade,
        updateStats: updateStats
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupHudFade = HUD.setupFade;
window.updateHudStats = HUD.updateStats;

console.log('[Module] HUD loaded - 2 functions');


// ═══ MODULE: modules/dimension.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DIMENSION MODULE - 2D/3D dimension switching with animation
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles smooth animated transitions between 2D and 3D graph views.
 * Depends on: Graph, IS_3D, DIMENSION_TRANSITION, STARFIELD, STARFIELD_OPACITY,
 *             BLOOM_PASS, BLOOM_STRENGTH, stableSeed, stableZ, fileMode,
 *             GRAPH_MODE, applyFileVizMode
 *
 * @module DIMENSION
 * @version 1.0.0
 */

window.DIMENSION = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // DIMENSION TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle between 2D and 3D dimensions
     */
    function toggle() {
        if (window.DIMENSION_TRANSITION) return;
        window.DIMENSION_TRANSITION = true;

        const target3d = !window.IS_3D;
        const button = document.getElementById('btn-dimensions');

        animateChange(target3d, () => {
            window.IS_3D = target3d;
            window.DIMENSION_TRANSITION = false;
            if (button) button.textContent = window.IS_3D ? '2D' : '3D';

            // Re-apply file viz mode if active
            if (window.fileMode && window.GRAPH_MODE === 'atoms') {
                if (typeof window.applyFileVizMode === 'function') {
                    window.applyFileVizMode();
                }
            }
        });
    }

    /**
     * Setup the dimension toggle button
     */
    function setup() {
        const button = document.getElementById('btn-dimensions');
        if (!button) return;

        const updateLabel = () => {
            button.textContent = window.IS_3D ? '2D' : '3D';
        };
        updateLabel();
        button.onclick = toggle;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ANIMATED TRANSITION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Animate transition between 2D and 3D
     * @param {boolean} target3d - Whether transitioning to 3D
     * @param {Function} done - Callback when animation completes
     */
    function animateChange(target3d, done) {
        const Graph = window.Graph;
        const STARFIELD = window.STARFIELD;
        const STARFIELD_OPACITY = window.STARFIELD_OPACITY;
        const BLOOM_PASS = window.BLOOM_PASS;
        const BLOOM_STRENGTH = window.BLOOM_STRENGTH;
        const stableSeed = window.stableSeed;
        const stableZ = window.stableZ;

        const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
        const startTime = performance.now();
        const duration = 3000;
        const delayMin = 0;
        const delayMax = 2000;
        const lockPositionsAfterTransition = true;

        const easeInOutSine = (t) => 0.5 - 0.5 * Math.cos(Math.PI * t);

        const starStart = STARFIELD ? STARFIELD.material.opacity : 0;
        const starTarget = target3d ? STARFIELD_OPACITY : 0;
        const bloomStart = BLOOM_PASS ? BLOOM_PASS.strength : 0;
        const bloomTarget = BLOOM_PASS ? (target3d ? BLOOM_STRENGTH : 0) : 0;

        // Store previous simulation settings
        const previousVelocityDecay = (Graph && Graph.d3VelocityDecay) ? Graph.d3VelocityDecay() : null;
        const previousAlphaTarget = (Graph && Graph.d3AlphaTarget) ? Graph.d3AlphaTarget() : null;
        const previousCooldownTicks = (Graph && Graph.cooldownTicks) ? Graph.cooldownTicks() : null;
        const previousCooldownTime = (Graph && Graph.cooldownTime) ? Graph.cooldownTime() : null;

        // Freeze simulation during transition
        if (Graph && Graph.cooldownTicks) Graph.cooldownTicks(Infinity);
        if (Graph && Graph.cooldownTime) Graph.cooldownTime(Infinity);
        if (Graph && Graph.d3VelocityDecay) Graph.d3VelocityDecay(1);
        if (Graph && Graph.d3AlphaTarget) Graph.d3AlphaTarget(0);
        if (Graph && Graph.d3ReheatSimulation) Graph.d3ReheatSimulation();

        // Initialize node animation state
        nodes.forEach((node) => {
            node.__xStart = node.x || 0;
            node.__yStart = node.y || 0;
            node.__zStart = node.z || 0;
            node.__delay = delayMin + (stableSeed(node, 'delay') * (delayMax - delayMin));
            node.fx = node.__xStart;
            node.fy = node.__yStart;
            node.vx = 0;
            node.vy = 0;
            node.vz = 0;

            if (target3d) {
                if (node.__z3d === undefined || node.__z3d === null) {
                    node.__z3d = node.__zStart || stableZ(node);
                }
            } else {
                node.__z3d = node.__zStart;
            }
        });

        const maxDistance = nodes.reduce((acc, node) => Math.max(acc, Math.abs(node.__zStart || 0)), 1);

        Graph.numDimensions(3);

        const animate = (now) => {
            const elapsed = now - startTime;
            const t = Math.min(1, elapsed / duration);
            const eased = easeInOutSine(t);

            // Animate each node's Z position
            nodes.forEach((node) => {
                const startZ = node.__zStart || 0;
                const targetZ = target3d ? (node.__z3d || 0) : 0;
                const delay = node.__delay || 0;
                const localDuration = Math.max(600, duration - delay);
                const localElapsed = Math.max(0, elapsed - delay);
                const localT = Math.min(1, localElapsed / localDuration);
                const localEase = easeInOutSine(localT);
                const distanceRatio = maxDistance > 0 ? Math.abs(startZ) / maxDistance : 0;
                const distanceCurve = 0.6 + (1 - distanceRatio) * 0.6;
                const progress = Math.pow(localEase, distanceCurve);
                const nextZ = startZ + (targetZ - startZ) * progress;
                node.z = nextZ;
                node.fz = nextZ;
                node.vz = 0;
            });

            // Animate starfield and bloom
            if (STARFIELD) {
                const nextOpacity = starStart + (starTarget - starStart) * eased;
                STARFIELD.material.opacity = nextOpacity;
                STARFIELD.visible = nextOpacity > 0.02;
            }
            if (BLOOM_PASS) {
                BLOOM_PASS.strength = bloomStart + (bloomTarget - bloomStart) * eased;
            }

            if (t < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - clean up
                nodes.forEach((node) => {
                    delete node.fz;
                    delete node.__zStart;
                    delete node.__xStart;
                    delete node.__yStart;
                    delete node.__delay;

                    if (!target3d) {
                        node.z = 0;
                        node.fz = 0;
                    } else if (lockPositionsAfterTransition) {
                        node.z = node.__z3d || node.z || 0;
                        node.fz = node.z;
                    } else {
                        delete node.fx;
                        delete node.fy;
                    }
                });

                Graph.numDimensions(target3d ? 3 : 2);

                if (!target3d && STARFIELD) {
                    STARFIELD.visible = false;
                }

                // Restore simulation settings
                if (Graph && Graph.d3VelocityDecay && previousVelocityDecay !== null) {
                    Graph.d3VelocityDecay(previousVelocityDecay);
                }
                if (Graph && Graph.d3AlphaTarget && previousAlphaTarget !== null) {
                    Graph.d3AlphaTarget(previousAlphaTarget);
                }
                if (Graph && Graph.cooldownTicks && previousCooldownTicks !== null) {
                    Graph.cooldownTicks(previousCooldownTicks);
                }
                if (Graph && Graph.cooldownTime && previousCooldownTime !== null) {
                    Graph.cooldownTime(previousCooldownTime);
                }

                if (done) done();
            }
        };

        requestAnimationFrame(animate);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        toggle: toggle,
        setup: setup,
        animateChange: animateChange
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.toggleDimensions = DIMENSION.toggle;
window.setupDimensionToggle = DIMENSION.setup;
window.animateDimensionChange = DIMENSION.animateChange;

console.log('[Module] DIMENSION loaded - 3 functions');


// ═══ MODULE: modules/report.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * REPORT MODULE - Report panel, AI insights, and metrics display
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles the brain download report, AI insights panel, and metrics/KPI display.
 * Depends on: escapeHtml (from utils.js), DOM elements
 *
 * @module REPORT
 * @version 1.0.0
 */

window.REPORT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BRAIN DOWNLOAD REPORT
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the brain download report panel
     * @param {Object} data - Data object with brain_download field
     */
    function setupReport(data) {
        const panel = document.getElementById('report-panel');
        const content = document.getElementById('report-content');
        // Guard: elements may not exist in minimal template
        if (!content) return;
        const report = (data && data.brain_download) ? data.brain_download : '';
        content.textContent = report || 'No report available.';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // AI INSIGHTS PANEL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the AI insights panel
     * @param {Object} data - Data object with ai_insights field
     */
    function setupAIInsights(data) {
        const escapeHtml = window.escapeHtml || ((s) => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])));

        const panel = document.getElementById('insights-panel');
        const content = document.getElementById('insights-content');
        const btn = document.getElementById('btn-insights');

        const insights = (data && data.ai_insights) ? data.ai_insights : null;

        if (!insights) {
            // Hide the button if no insights available
            if (btn) btn.style.display = 'none';
            return;
        }

        // Show the button
        if (btn) btn.style.display = 'inline-flex';

        // Render insights
        let html = '';

        // Executive Summary
        if (insights.executive_summary) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Executive Summary</div>
                <div class="insights-summary">${escapeHtml(insights.executive_summary)}</div>
            </div>`;
        }

        // Patterns Detected
        if (insights.patterns_detected && insights.patterns_detected.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Patterns Detected</div>`;
            for (const pattern of insights.patterns_detected) {
                const confidencePercent = Math.round((pattern.confidence || 0) * 100);
                html += `<div class="insights-pattern">
                    <div class="insights-pattern-header">
                        <span class="insights-pattern-name">${escapeHtml(pattern.pattern_name || 'Unknown')}</span>
                        <span class="insights-pattern-type ${pattern.pattern_type || ''}">${escapeHtml(pattern.pattern_type || '')}</span>
                    </div>
                    <div class="insights-confidence">
                        <div class="insights-confidence-bar">
                            <div class="insights-confidence-fill" style="width: ${confidencePercent}%"></div>
                        </div>
                        <span>${confidencePercent}%</span>
                    </div>
                    ${pattern.evidence ? `<div class="insights-pattern-evidence">${escapeHtml(pattern.evidence)}</div>` : ''}
                    ${pattern.recommendation ? `<div class="insights-pattern-evidence" style="color: var(--color-accent-secondary);">Tip: ${escapeHtml(pattern.recommendation)}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Refactoring Opportunities
        if (insights.refactoring_opportunities && insights.refactoring_opportunities.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Refactoring Opportunities</div>`;
            for (const refactor of insights.refactoring_opportunities) {
                html += `<div class="insights-refactor">
                    <div class="insights-refactor-title">
                        ${escapeHtml(refactor.title || 'Untitled')}
                        <span class="insights-refactor-priority ${refactor.priority || 'LOW'}">${refactor.priority || 'LOW'}</span>
                    </div>
                    ${refactor.description ? `<div class="insights-refactor-desc">${escapeHtml(refactor.description)}</div>` : ''}
                    ${refactor.affected_files && refactor.affected_files.length > 0 ?
                        `<div class="insights-refactor-desc" style="margin-top: 4px; color: var(--color-text-muted);">Files: ${refactor.affected_files.slice(0, 3).map(f => escapeHtml(f)).join(', ')}${refactor.affected_files.length > 3 ? '...' : ''}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Topology Analysis
        if (insights.topology_analysis) {
            const topo = insights.topology_analysis;
            html += `<div class="insights-section">
                <div class="insights-section-title">Topology Analysis</div>
                ${topo.shape_interpretation ? `<div class="insights-summary">${escapeHtml(topo.shape_interpretation)}</div>` : ''}
                ${topo.health_assessment ? `<div class="insights-pattern-evidence">Health: ${escapeHtml(topo.health_assessment)}</div>` : ''}
                ${topo.coupling_analysis ? `<div class="insights-pattern-evidence">Coupling: ${escapeHtml(topo.coupling_analysis)}</div>` : ''}
            </div>`;
        }

        // Risk Areas
        if (insights.risk_areas && insights.risk_areas.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Risk Areas</div>`;
            for (const risk of insights.risk_areas) {
                html += `<div class="insights-risk">
                    <span class="insights-risk-level ${risk.risk_level || 'LOW'}">${risk.risk_level || 'LOW'}</span>
                    <div class="insights-risk-content">
                        <div class="insights-risk-area">${escapeHtml(risk.area || 'Unknown')}</div>
                        ${risk.description ? `<div class="insights-risk-desc">${escapeHtml(risk.description)}</div>` : ''}
                        ${risk.mitigation ? `<div class="insights-risk-desc" style="color: var(--color-accent-secondary); margin-top: 4px;">Tip: ${escapeHtml(risk.mitigation)}</div>` : ''}
                    </div>
                </div>`;
            }
            html += '</div>';
        }

        // Meta information
        if (insights.meta) {
            const meta = insights.meta;
            html += `<div class="insights-meta">
                Generated: ${meta.generated_at ? new Date(meta.generated_at).toLocaleString() : 'Unknown'}
                | Model: ${escapeHtml(meta.model || 'Unknown')}
                ${meta.confidence ? ` | Confidence: ${Math.round(meta.confidence * 100)}%` : ''}
            </div>`;
        }

        content.innerHTML = html || '<div class="insights-placeholder">No insights data available.</div>';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METRICS / KPI DISPLAY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup metrics and health indicators
     * @param {Object} data - Data object with kpis field
     */
    function setupMetrics(data) {
        const kpis = (data && data.kpis) ? data.kpis : {};

        const setText = (id, value) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = value;
        };

        const asNumber = (val) => {
            const num = Number(val);
            return Number.isFinite(num) ? num : null;
        };

        const formatPercent = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}%`;
        };

        const formatCount = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${Math.round(num)}`;
        };

        const formatScore = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}/10`;
        };

        // Set metric values
        setText('metric-edge-resolution', formatPercent(kpis.edge_resolution_percent));
        setText('metric-call-ratio', formatPercent(kpis.call_ratio_percent));
        setText('metric-reachability', formatPercent(kpis.reachability_percent));
        setText('metric-dead-code', formatPercent(kpis.dead_code_percent));
        setText('metric-knot-score', formatScore(kpis.knot_score));
        setText('metric-topology', kpis.topology_shape || 'UNKNOWN');
        setText('metric-orphans', formatCount(kpis.orphan_count));
        setText('metric-top-hubs', formatCount(kpis.top_hub_count));

        // Set health indicators (traffic light bars)
        const setHealth = (id, level) => {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('good', 'medium', 'bad', 'neutral');
                el.classList.add(level);
            }
        };

        // Edge Resolution: >90% good, 70-90% medium, <70% bad
        const edgeRes = asNumber(kpis.edge_resolution_percent);
        setHealth('health-edge-resolution', edgeRes === null ? 'neutral' : edgeRes >= 90 ? 'good' : edgeRes >= 70 ? 'medium' : 'bad');

        // Call Ratio: >60% good, 40-60% medium, <40% bad
        const callRatio = asNumber(kpis.call_ratio_percent);
        setHealth('health-call-ratio', callRatio === null ? 'neutral' : callRatio >= 60 ? 'good' : callRatio >= 40 ? 'medium' : 'bad');

        // Reachability: >90% good, 70-90% medium, <70% bad
        const reach = asNumber(kpis.reachability_percent);
        setHealth('health-reachability', reach === null ? 'neutral' : reach >= 90 ? 'good' : reach >= 70 ? 'medium' : 'bad');

        // Dead Code: <5% good, 5-15% medium, >15% bad (INVERTED - lower is better)
        const dead = asNumber(kpis.dead_code_percent);
        setHealth('health-dead-code', dead === null ? 'neutral' : dead <= 5 ? 'good' : dead <= 15 ? 'medium' : 'bad');

        // Knot Score: <3 good, 3-6 medium, >6 bad (INVERTED - lower is better)
        const knot = asNumber(kpis.knot_score);
        setHealth('health-knot-score', knot === null ? 'neutral' : knot <= 3 ? 'good' : knot <= 6 ? 'medium' : 'bad');

        // Topology: neutral (informational only)
        setHealth('health-topology', 'neutral');

        // Orphans: <10 good, 10-50 medium, >50 bad (INVERTED - lower is better)
        const orphans = asNumber(kpis.orphan_count);
        setHealth('health-orphans', orphans === null ? 'neutral' : orphans <= 10 ? 'good' : orphans <= 50 ? 'medium' : 'bad');

        // Top Hubs: neutral (informational only)
        setHealth('health-top-hubs', 'neutral');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupReport: setupReport,
        setupAIInsights: setupAIInsights,
        setupMetrics: setupMetrics
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupReport = REPORT.setupReport;
window.setupAIInsights = REPORT.setupAIInsights;
window.setupMetrics = REPORT.setupMetrics;

console.log('[Module] REPORT loaded - 3 functions');


// ═══ MODULE: modules/visibility.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VISIBILITY MODULE - UI visibility controls and filter utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles background brightness, metadata visibility, filter clearing,
 * and collapsible section management.
 * Depends on: Graph, APPEARANCE_STATE, VIS_FILTERS, THREE
 *
 * @module VISIBILITY
 * @version 1.0.0
 */

window.VISIBILITY = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BACKGROUND CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update background brightness based on APPEARANCE_STATE
     */
    function updateBackgroundBrightness() {
        const Graph = window.Graph;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const THREE = window.THREE;

        if (!Graph || !APPEARANCE_STATE.backgroundBase) return;
        const baseColor = new THREE.Color(APPEARANCE_STATE.backgroundBase);
        const brightness = APPEARANCE_STATE.backgroundBrightness ?? 1;
        const adjusted = baseColor.clone().multiplyScalar(brightness);
        Graph.backgroundColor(`#${adjusted.getHexString()}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA VISIBILITY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply metadata visibility settings (report panel, file panel, etc.)
     */
    function applyMetadataVisibility() {
        const VIS_FILTERS = window.VIS_FILTERS;

        const reportPanel = document.getElementById('report-panel');
        const reportButton = document.getElementById('btn-report');
        const filePanel = document.getElementById('file-panel');

        // Guard: elements may not exist in minimal template
        if (!reportPanel && !reportButton) return;

        if (!VIS_FILTERS.metadata.showReportPanel) {
            if (reportPanel) reportPanel.style.display = 'none';
            if (reportButton) {
                reportButton.classList.remove('active');
                reportButton.style.display = 'none';
            }
        } else {
            if (reportButton) reportButton.style.display = 'inline-flex';
        }
        if (!VIS_FILTERS.metadata.showFilePanel && filePanel) {
            filePanel.classList.remove('visible');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clear all dimension filters (tier, ring, family, role, file, edge)
     * Used for zero-node recovery and manual reset
     */
    function clearAllFilters() {
        const VIS_FILTERS = window.VIS_FILTERS;

        VIS_FILTERS.tiers.clear();
        VIS_FILTERS.rings.clear();
        VIS_FILTERS.families.clear();
        VIS_FILTERS.roles.clear();
        VIS_FILTERS.files.clear();
        VIS_FILTERS.edges.clear();
        VIS_FILTERS.layers.clear();
        VIS_FILTERS.effects.clear();
        VIS_FILTERS.edgeFamilies.clear();

        // Update legend UI
        document.querySelectorAll('.topo-legend-item.filtered').forEach(el => el.classList.remove('filtered'));

        // Update chip UI
        document.querySelectorAll('.filter-chip.active').forEach(el => el.classList.remove('active'));

        console.log('[Filters] All filters cleared');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLLAPSIBLE SECTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup collapsible sections in sidebar and panels
     */
    function setupCollapsibleSections() {
        // Standard sidebar sections
        const titles = document.querySelectorAll('.side-title.collapsible');
        titles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('collapsed', isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });

        // Topology section collapsibles (GEOMETRY panel)
        const topoTitles = document.querySelectorAll('.topo-section-title.collapsible');
        topoTitles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('expanded', !isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updateBackgroundBrightness: updateBackgroundBrightness,
        applyMetadataVisibility: applyMetadataVisibility,
        clearAllFilters: clearAllFilters,
        setupCollapsibleSections: setupCollapsibleSections
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateBackgroundBrightness = VISIBILITY.updateBackgroundBrightness;
window.applyMetadataVisibility = VISIBILITY.applyMetadataVisibility;
window.clearAllFilters = VISIBILITY.clearAllFilters;
window.setupCollapsibleSections = VISIBILITY.setupCollapsibleSections;

console.log('[Module] VISIBILITY loaded - 4 functions');


// ═══ MODULE: modules/animation.js ═══
/**
 * ANIMATION MODULE
 *
 * Unified animation controller for all layout transitions and continuous motions.
 * Addresses ARCH-002 (O(n^2) flock), ARCH-003 (unthrottled refresh), ARCH-004 (conflicts).
 *
 * Key improvements:
 * - Single animation ownership prevents conflicts
 * - Spatial hashing reduces flock from O(n^2) to O(n)
 * - Integration with REFRESH module for throttled updates
 *
 * Usage:
 *   ANIM.applyLayout('orbital')           // Apply a layout preset
 *   ANIM.stop()                           // Stop all animations
 *   ANIM.setStaggerPattern('radial')      // Change wave pattern
 */

const ANIM = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        baseDuration: 1200,      // Base animation duration (ms)
        staggerSpread: 800,      // Stagger spread (ms)
        flockMaxNodes: 500,      // Max nodes for flock simulation
        spatialGridSize: 50,     // Grid cell size for spatial hashing
        motionFrameSkip: 0       // Skip frames for motion (0 = no skip)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _currentLayout = 'force';
    let _animationId = null;
    let _layoutTime = 0;
    let _currentStaggerPattern = 'tier';
    let _owner = 'none';  // Current animation owner

    // =========================================================================
    // STAGGER PATTERNS - Wave-based node transitions
    // =========================================================================

    const STAGGER_PATTERNS = {
        // Radial ripple: center nodes move first, ripples outward
        radial: (node, startPos, targetPos) => {
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2 + startPos.z ** 2);
            return Math.min(1, dist / 500);
        },
        // Tier cascade: T0 first, then T1, then T2
        tier: (node) => {
            const tier = NODE.getTier(node);
            const tierNum = tier === 'T0' ? 0 : tier === 'T1' ? 1 : 2;
            return tierNum / 2;
        },
        // Distance-based: shortest travel first
        distance: (node, startPos, targetPos) => {
            const dx = targetPos.x - startPos.x;
            const dy = targetPos.y - startPos.y;
            const dz = targetPos.z - startPos.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            return Math.min(1, dist / 400);
        },
        // File grouping: nodes in same file move together
        file: (node) => {
            const fileIdx = node.fileIdx ?? 0;
            return (fileIdx % 8) / 8;
        },
        // Spiral pattern
        spiral: (node, startPos) => {
            const angle = Math.atan2(startPos.y, startPos.x);
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2);
            return ((angle + Math.PI) / (2 * Math.PI) + dist / 1000) % 1;
        },
        // Random stagger
        random: () => Math.random() * 0.6
    };

    // =========================================================================
    // LAYOUT PRESETS
    // =========================================================================

    const LAYOUT_PRESETS = {
        'force': {
            name: 'FORCE', icon: '?', description: 'Physics-based clustering',
            motion: 'settle', cooldown: 300, warmupTicks: 40, getPosition: null
        },
        'orbital': {
            name: 'ORBITAL', icon: '?', description: 'Planetary orbit bands',
            motion: 'orbit', cooldown: Infinity, orbitSpeed: 0.002,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const r = { T0: 80, T1: 160, T2: 280, UNKNOWN: 200 }[tier] || 200;
                const fOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const angle = (fOff / 5) * Math.PI * 2 + (idx / Math.max(1, total)) * Math.PI * 0.3 + (time || 0) * (0.5 + r * 0.001);
                const wobble = Math.sin(idx * 0.7 + (time || 0) * 2) * 15;
                return {
                    x: Math.cos(angle) * (r + wobble),
                    y: Math.sin(idx * 0.3) * 40 + (tier === 'T0' ? -50 : tier === 'T2' ? 50 : 0),
                    z: Math.sin(angle) * (r + wobble)
                };
            }
        },
        'radial': {
            name: 'RADIAL', icon: '?', description: 'Concentric tier rings',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total, time, tierGroups) => {
                const tier = NODE.getTier(node);
                const r = { T0: 60, T1: 150, T2: 280, UNKNOWN: 220 }[tier] || 180;
                const tierNodes = tierGroups?.[tier] || [];
                const tierIdx = tierNodes.indexOf(node);
                const tierTotal = tierNodes.length || 1;
                const angle = (tierIdx / tierTotal) * Math.PI * 2;
                return { x: Math.cos(angle) * r, y: 0, z: Math.sin(angle) * r };
            }
        },
        'spiral': {
            name: 'SPIRAL', icon: '?', description: 'DNA-like helix',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.003,
            getPosition: (node, idx, total, time) => {
                const t = idx / Math.max(1, total);
                const angle = t * Math.PI * 2 * 4 + (time || 0);
                const r = 100 + t * 150;
                return { x: Math.cos(angle) * r, y: (t - 0.5) * 400, z: Math.sin(angle) * r };
            }
        },
        'sphere': {
            name: 'SPHERE', icon: '?', description: 'Globe surface',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const latBase = { T0: 0.8, T1: 0.5, T2: 0.2, UNKNOWN: 0.5 }[tier] || 0.5;
                const lat = (latBase + (idx % 10) * 0.02) * Math.PI;
                const lonBase = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 180 }[family] || 0;
                const lon = ((lonBase + idx * 3) % 360) * Math.PI / 180 + (time || 0);
                const r = 200;
                return {
                    x: Math.sin(lat) * Math.cos(lon) * r,
                    y: Math.cos(lat) * r,
                    z: Math.sin(lat) * Math.sin(lon) * r
                };
            }
        },
        'grid': {
            name: 'GRID', icon: '?', description: '3D lattice',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const tierX = { T0: -150, T1: 0, T2: 150, UNKNOWN: 0 }[tier] || 0;
                const famZ = { LOG: -120, DAT: -60, ORG: 0, EXE: 60, EXT: 120, UNKNOWN: 0 }[family] || 0;
                const row = Math.floor(idx / 15);
                const col = idx % 15;
                return { x: tierX + (col - 7) * 20, y: row * 25 - 100, z: famZ + Math.sin(idx * 0.5) * 20 };
            }
        },
        'flock': {
            name: 'FLOCK', icon: '?', description: 'Swarming birds',
            motion: 'flock', cooldown: Infinity,
            flockParams: { separation: 25, alignment: 0.05, cohesion: 0.01, maxSpeed: 2 },
            getPosition: null
        },
        'galaxy': {
            name: 'GALAXY', icon: '?', description: 'Spiral arms',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const family = NODE.getFamily(node);
                const tier = NODE.getTier(node);
                const armOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const baseAngle = (armOff / 5) * Math.PI * 2;
                const dist = 50 + (idx / total) * 250;
                const spiralAngle = baseAngle + dist * 0.015 + (time || 0);
                const tierY = { T0: -30, T1: 0, T2: 30, UNKNOWN: 0 }[tier] || 0;
                return {
                    x: Math.cos(spiralAngle) * dist,
                    y: tierY + Math.sin(idx * 0.5) * 20,
                    z: Math.sin(spiralAngle) * dist
                };
            }
        }
    };

    // =========================================================================
    // SPATIAL HASHING - O(n) neighbor lookup for flock simulation
    // =========================================================================

    function _buildSpatialGrid(nodes, cellSize) {
        const grid = new Map();

        nodes.forEach((node, idx) => {
            const x = node.x || 0;
            const y = node.y || 0;
            const z = node.z || 0;

            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) {
                grid.set(key, []);
            }
            grid.get(key).push({ node, idx });
        });

        return grid;
    }

    function _getNeighborsFromGrid(grid, node, cellSize, radius) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);

        const neighbors = [];
        const cellRadius = Math.ceil(radius / cellSize);

        // Check neighboring cells
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                    const key = `${cellX + dx},${cellY + dy},${cellZ + dz}`;
                    const cell = grid.get(key);
                    if (cell) {
                        cell.forEach(entry => {
                            if (entry.node !== node) {
                                neighbors.push(entry.node);
                            }
                        });
                    }
                }
            }
        }

        return neighbors;
    }

    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================

    function _groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = NODE.getTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    function _acquireOwnership(owner) {
        // Cancel any existing animation
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = owner;
        return true;
    }

    function _releaseOwnership(owner) {
        if (_owner === owner) {
            if (_animationId) {
                cancelAnimationFrame(_animationId);
                _animationId = null;
            }
            _owner = 'none';
        }
    }

    // =========================================================================
    // LAYOUT APPLICATION
    // =========================================================================

    function applyLayout(presetKey, animate = true) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset) return;

        _currentLayout = presetKey;
        _acquireOwnership('layout');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);

        // Handle force layout specially
        if (presetKey === 'force') {
            nodes.forEach(n => {
                n.fx = undefined;
                n.fy = undefined;
                n.fz = undefined;
            });
            Graph.cooldownTicks(preset.cooldown);
            Graph.d3ReheatSimulation();
            _releaseOwnership('layout');
            if (typeof showModeToast === 'function') {
                showModeToast('? FORCE layout');
            }
            return;
        }

        // Handle flock specially
        if (preset.motion === 'flock') {
            _startFlockSimulation(preset.flockParams);
            Graph.cooldownTicks(preset.cooldown);
            if (typeof showModeToast === 'function') {
                showModeToast(`${preset.icon} ${preset.name} layout`);
            }
            return;
        }

        // Position-based layouts
        if (preset.getPosition) {
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => preset.getPosition(n, i, total, 0, tierGroups));

            if (animate && total > 100) {
                // STAGGERED ANIMATION for large graphs
                _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey);
            } else if (animate) {
                // SIMPLE ANIMATION for small graphs
                _animateSimple(nodes, startPos, targetPos, preset, presetKey);
            } else {
                // INSTANT
                nodes.forEach((n, i) => {
                    const p = targetPos[i];
                    n.fx = p.x;
                    n.fy = p.y;
                    n.fz = p.z;
                });
                if (typeof REFRESH !== 'undefined') {
                    REFRESH.force();
                } else if (Graph) {
                    Graph.refresh();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                }
            }
        }

        Graph.cooldownTicks(preset.cooldown);
        if (typeof showModeToast === 'function') {
            showModeToast(`${preset.icon} ${preset.name} layout`);
        }
    }

    function _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey) {
        const baseDuration = CONFIG.baseDuration;
        const staggerSpread = CONFIG.staggerSpread;
        const startTime = Date.now();

        // Hide edges during animation for performance
        Graph.linkOpacity(0);

        // Calculate delay for each node
        const pattern = STAGGER_PATTERNS[_currentStaggerPattern] || STAGGER_PATTERNS.tier;
        const delays = nodes.map((n, i) => pattern(n, startPos[i], targetPos[i]) * staggerSpread);

        function animateFrame() {
            if (_owner !== 'layout') return;

            const elapsed = Date.now() - startTime;

            nodes.forEach((n, i) => {
                const nodeStart = delays[i];
                const nodeElapsed = elapsed - nodeStart;

                if (nodeElapsed <= 0) {
                    n.fx = startPos[i].x;
                    n.fy = startPos[i].y;
                    n.fz = startPos[i].z;
                } else if (nodeElapsed >= baseDuration) {
                    n.fx = targetPos[i].x;
                    n.fy = targetPos[i].y;
                    n.fz = targetPos[i].z;
                } else {
                    const progress = nodeElapsed / baseDuration;
                    const eased = progress * progress * (3 - 2 * progress);
                    n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                    n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                    n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
                }
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                Graph.refresh();
            }

            const totalDuration = baseDuration + staggerSpread;
            if (elapsed < totalDuration) {
                _animationId = requestAnimationFrame(animateFrame);
            } else {
                // Restore edges
                if (typeof applyEdgeMode === 'function') {
                    applyEdgeMode();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                } else {
                    _releaseOwnership('layout');
                }
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _animateSimple(nodes, startPos, targetPos, preset, presetKey) {
        const duration = 1500;
        const startTime = Date.now();

        function animateFrame() {
            if (_owner !== 'layout') return;

            const progress = Math.min(1, (Date.now() - startTime) / duration);
            const eased = progress * progress * (3 - 2 * progress);

            nodes.forEach((n, i) => {
                n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                Graph.refresh();
            }

            if (progress < 1) {
                _animationId = requestAnimationFrame(animateFrame);
            } else if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                _startLayoutMotion(presetKey);
            } else {
                _releaseOwnership('layout');
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _startLayoutMotion(presetKey) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset || !preset.getPosition) return;

        _acquireOwnership('motion');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);
        const speed = preset.rotateSpeed || preset.orbitSpeed || 0.002;

        function animate() {
            if (_owner !== 'motion') return;

            _layoutTime += speed;

            nodes.forEach((n, i) => {
                const pos = preset.getPosition(n, i, total, _layoutTime, tierGroups);
                n.fx = pos.x;
                n.fy = pos.y;
                n.fz = pos.z;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                Graph.refresh();
            }

            _animationId = requestAnimationFrame(animate);
        }

        _animationId = requestAnimationFrame(animate);
    }

    // =========================================================================
    // FLOCK SIMULATION - O(n) with spatial hashing
    // =========================================================================

    function _startFlockSimulation(params) {
        const nodes = Graph?.graphData()?.nodes || [];

        // Performance guard
        if (nodes.length > CONFIG.flockMaxNodes) {
            console.warn(`[ANIM] Flock disabled: ${nodes.length} nodes exceeds ${CONFIG.flockMaxNodes} limit`);
            if (typeof showModeToast === 'function') {
                showModeToast('Warning: Flock disabled (too many nodes)');
            }
            return;
        }

        _acquireOwnership('flock');

        const { separation, alignment, cohesion, maxSpeed } = params;

        // Initialize velocities
        nodes.forEach(n => {
            n._vx = (Math.random() - 0.5) * 2;
            n._vy = (Math.random() - 0.5) * 2;
            n._vz = (Math.random() - 0.5) * 2;
        });

        function flockStep() {
            if (_owner !== 'flock') return;

            // Build spatial grid for O(n) neighbor lookup
            const grid = _buildSpatialGrid(nodes, CONFIG.spatialGridSize);
            const neighborRadius = separation * 3;

            nodes.forEach(n => {
                // Get nearby neighbors from spatial grid (O(1) per node)
                const neighbors = _getNeighborsFromGrid(grid, n, CONFIG.spatialGridSize, neighborRadius);

                let sepX = 0, sepY = 0, sepZ = 0, sepCount = 0;
                let alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;

                const myFamily = NODE.getFamily(n);

                neighbors.forEach(other => {
                    const dx = (other.x || 0) - (n.x || 0);
                    const dy = (other.y || 0) - (n.y || 0);
                    const dz = (other.z || 0) - (n.z || 0);
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 0.001;

                    // Separation
                    if (dist < separation * 2) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                        sepZ -= dz / dist;
                        sepCount++;
                    }

                    // Alignment and cohesion (same family only)
                    if (NODE.getFamily(other) === myFamily && dist < 150) {
                        alignX += other._vx || 0;
                        alignY += other._vy || 0;
                        alignZ += other._vz || 0;
                        alignCount++;

                        cohX += other.x || 0;
                        cohY += other.y || 0;
                        cohZ += other.z || 0;
                        cohCount++;
                    }
                });

                // Apply forces
                if (sepCount > 0) {
                    n._vx += (sepX / sepCount) * separation * 0.05;
                    n._vy += (sepY / sepCount) * separation * 0.05;
                    n._vz += (sepZ / sepCount) * separation * 0.05;
                }
                if (alignCount > 0) {
                    n._vx += ((alignX / alignCount) - n._vx) * alignment;
                    n._vy += ((alignY / alignCount) - n._vy) * alignment;
                    n._vz += ((alignZ / alignCount) - n._vz) * alignment;
                }
                if (cohCount > 0) {
                    n._vx += (cohX / cohCount - (n.x || 0)) * cohesion;
                    n._vy += (cohY / cohCount - (n.y || 0)) * cohesion;
                    n._vz += (cohZ / cohCount - (n.z || 0)) * cohesion;
                }

                // Center attraction
                n._vx -= (n.x || 0) * 0.0005;
                n._vy -= (n.y || 0) * 0.0005;
                n._vz -= (n.z || 0) * 0.0005;

                // Speed limit
                const speed = Math.sqrt(n._vx * n._vx + n._vy * n._vy + n._vz * n._vz);
                if (speed > maxSpeed) {
                    n._vx = (n._vx / speed) * maxSpeed;
                    n._vy = (n._vy / speed) * maxSpeed;
                    n._vz = (n._vz / speed) * maxSpeed;
                }

                // Update position
                n.fx = (n.x || 0) + n._vx;
                n.fy = (n.y || 0) + n._vy;
                n.fz = (n.z || 0) + n._vz;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                Graph.refresh();
            }

            _animationId = requestAnimationFrame(flockStep);
        }

        _animationId = requestAnimationFrame(flockStep);
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function stop() {
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = 'none';
    }

    function setStaggerPattern(pattern) {
        if (STAGGER_PATTERNS[pattern]) {
            _currentStaggerPattern = pattern;
            if (typeof showModeToast === 'function') {
                showModeToast(`Wave pattern: ${pattern.toUpperCase()}`);
            }
        }
    }

    function cycleStaggerPattern() {
        const patterns = Object.keys(STAGGER_PATTERNS);
        const currentIdx = patterns.indexOf(_currentStaggerPattern);
        _currentStaggerPattern = patterns[(currentIdx + 1) % patterns.length];
        if (typeof showModeToast === 'function') {
            showModeToast(`Wave pattern: ${_currentStaggerPattern.toUpperCase()}`);
        }
        return _currentStaggerPattern;
    }

    return {
        // Layout control
        applyLayout,
        stop,

        // Stagger patterns
        setStaggerPattern,
        cycleStaggerPattern,
        get staggerPattern() { return _currentStaggerPattern; },
        get staggerPatterns() { return Object.keys(STAGGER_PATTERNS); },

        // State
        get currentLayout() { return _currentLayout; },
        get isAnimating() { return _animationId !== null; },
        get owner() { return _owner; },

        // Layout presets
        presets: LAYOUT_PRESETS,

        // Config
        config: CONFIG
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// Note: CURRENT_LAYOUT, LAYOUT_ANIMATION_ID, LAYOUT_TIME, CURRENT_STAGGER_PATTERN
// are managed by app.js (separate animation system) - not duplicated here
Object.defineProperty(window, 'LAYOUT_PRESETS', { get: () => ANIM.presets, configurable: true });
Object.defineProperty(window, 'STAGGER_PATTERNS', { get: () => ANIM.staggerPatterns, configurable: true });

function applyLayoutPreset(presetKey, animate) {
    ANIM.applyLayout(presetKey, animate);
}

function cycleStaggerPattern() {
    ANIM.cycleStaggerPattern();
}

function startFlockSimulation(params) {
    // Handled internally by ANIM
    ANIM.applyLayout('flock');
}

function groupNodesByTier(nodes) {
    const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
    nodes.forEach(n => {
        const tier = NODE.getTier(n);
        (groups[tier] || groups.UNKNOWN).push(n);
    });
    return groups;
}


// ═══ MODULE: modules/selection.js ═══
/**
 * SELECTION MODULE
 *
 * Manages node selection, multi-select, marquee selection, and selection visuals.
 * Includes animated selection colors using OKLCH pendulum system.
 *
 * Depends on: CORE (PENDULUM, SELECTION_SIZE_MULT), NODE, COLOR
 *
 * Usage:
 *   SELECT.set([id1, id2])              // Set selection
 *   SELECT.toggle(node)                 // Toggle node selection
 *   SELECT.clear()                      // Clear selection
 *   SELECT.getSelectedNodes()           // Get selected node objects
 *   SELECT.ids                          // Get Set of selected IDs
 */

const SELECT = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    const _ids = new Set();
    let _marqueeActive = false;
    let _marqueeStart = null;
    let _marqueeAdditive = false;
    let _lastMarqueeEndTs = 0;

    // Selection visuals state
    const _selectionOriginals = new Map();
    const _originalColorsForDim = new Map();

    // THREE.js geometries (created lazily)
    let _selectionHaloGeometry = null;
    let _groupHaloGeometry = null;

    // =========================================================================
    // CORE SELECTION FUNCTIONS
    // =========================================================================

    /**
     * Get currently selected nodes
     */
    function getSelectedNodes() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return [];
        const nodes = Graph.graphData().nodes || [];
        return nodes.filter(node => node && node.id && _ids.has(node.id));
    }

    /**
     * Set selection (optionally additive)
     */
    function set(ids, additive = false) {
        if (!additive) {
            _ids.clear();
        }
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        // Use app.js's updateSelectionVisuals if available (has group halo logic)
        // Otherwise fall back to internal _updateVisuals
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Toggle a node's selection state
     */
    function toggle(node) {
        if (!node || !node.id) return;
        if (_ids.has(node.id)) {
            _ids.delete(node.id);
        } else {
            _ids.add(node.id);
        }
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Clear all selection
     */
    function clear() {
        _ids.clear();
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Maybe clear selection (with marquee debounce)
     */
    function maybeClear() {
        const now = Date.now();
        if (_marqueeActive) return;
        if (now - _lastMarqueeEndTs < 250) return;
        clear();
    }

    /**
     * Add nodes to selection
     */
    function add(ids) {
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Remove nodes from selection
     */
    function remove(ids) {
        (ids || []).forEach(id => {
            _ids.delete(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    // =========================================================================
    // OKLCH COLOR UTILITIES
    // =========================================================================

    function _oklchToHex(L, C, H) {
        const hRad = H * Math.PI / 180;
        const a = C * Math.cos(hRad);
        const b = C * Math.sin(hRad);

        const l_ = L / 100 + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L / 100 - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L / 100 - 0.0894841775 * a - 1.2914855480 * b;

        const l = l_ * l_ * l_;
        const m = m_ * m_ * m_;
        const s = s_ * s_ * s_;

        let rLin = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
        let gLin = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
        let bLin = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

        const gamma = x => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;

        let rOut = Math.round(gamma(rLin) * 255);
        let gOut = Math.round(gamma(gLin) * 255);
        let bOut = Math.round(gamma(bLin) * 255);

        rOut = Math.max(0, Math.min(255, rOut));
        gOut = Math.max(0, Math.min(255, gOut));
        bOut = Math.max(0, Math.min(255, bOut));

        return '#' + [rOut, gOut, bOut].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function _dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // =========================================================================
    // PENDULUM ANIMATION
    // =========================================================================

    function _updatePendulums(dt) {
        const PENDULUM = CORE.PENDULUM;
        const p1 = PENDULUM.hue;
        const p2 = PENDULUM.chroma;

        // Pendulum 1: Modulates hue rotation speed
        const accel1 = -(p1.gravity / p1.length) * Math.sin(p1.angle);
        p1.velocity += accel1 * dt;
        p1.velocity *= p1.damping;
        p1.angle += p1.velocity * dt;

        // Continuous hue rotation
        const speedMod = 1 + Math.sin(p1.angle) * 0.5;
        PENDULUM.currentHue = (PENDULUM.currentHue + p1.rotationSpeed * speedMod * (dt / 16)) % 360;

        // Pendulum 2: Chroma with coupling
        const coupling = 0.00015 * Math.sin(p1.angle);
        const accel2 = -(p2.gravity / p2.length) * Math.sin(p2.angle) + coupling;
        p2.velocity += accel2 * dt;
        p2.velocity *= p2.damping;
        p2.angle += p2.velocity * dt;

        // Lightness phase
        PENDULUM.lightness.phase += PENDULUM.lightness.speed * dt;
    }

    function _getSelectionColor(phaseOffset = 0) {
        const PENDULUM = CORE.PENDULUM;
        const p2 = PENDULUM.chroma;
        const p3 = PENDULUM.lightness;

        const H = (PENDULUM.currentHue + phaseOffset * 45) % 360;
        const C = Math.max(0.18, p2.center + Math.sin(p2.angle + phaseOffset * Math.PI * 2) * p2.amplitude);
        const L = p3.center + Math.sin(p3.phase + phaseOffset * Math.PI * 4) * p3.amplitude;

        return _oklchToHex(L, C, H);
    }

    function _getNodeSpatialPhase(node) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const distance = Math.sqrt(x * x + y * y + z * z);
        const PENDULUM = CORE.PENDULUM;
        const scale = PENDULUM.ripple ? (PENDULUM.ripple.scale || 200) : 200;
        const ripplePhase = (distance / scale) % 1;

        const angle = Math.atan2(y, x);
        const angularOffset = Math.sin(angle * 3) * 0.1;

        return (ripplePhase + angularOffset + 1) % 1;
    }

    function _animateSelectionColors(timestamp) {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) return;

        const dt = PENDULUM.lastTime ? Math.min(timestamp - PENDULUM.lastTime, 50) : 16;
        PENDULUM.lastTime = timestamp;

        _updatePendulums(dt);

        if (_ids.size > 0 && typeof Graph !== 'undefined' && Graph?.graphData) {
            const nodes = Graph.graphData().nodes || [];

            nodes.forEach(node => {
                if (_ids.has(node.id)) {
                    const spatialPhase = _getNodeSpatialPhase(node);
                    node.color = _getSelectionColor(spatialPhase);
                }
            });

            if (typeof toColorNumber === 'function') {
                Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
            }
        }

        requestAnimationFrame(_animateSelectionColors);
    }

    function startAnimation() {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) {
            PENDULUM.running = true;
            PENDULUM.hue.velocity = 0.02 + Math.random() * 0.01;
            PENDULUM.chroma.velocity = 0.015 + Math.random() * 0.01;
            PENDULUM.lastTime = 0;
            requestAnimationFrame(_animateSelectionColors);
        }
    }

    function stopAnimation() {
        CORE.PENDULUM.running = false;
    }

    // =========================================================================
    // VISUAL UPDATES
    // =========================================================================

    function _updateVisuals() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;

        const nodes = Graph.graphData().nodes || [];
        const hasSelection = _ids.size > 0;
        const SELECTION_SIZE_MULT = CORE.SELECTION_SIZE_MULT;

        nodes.forEach(node => {
            const isSelected = _ids.has(node.id);

            // Save original for restoration
            if (hasSelection && !_originalColorsForDim.has(node.id)) {
                _originalColorsForDim.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            if (isSelected && !_selectionOriginals.has(node.id)) {
                _selectionOriginals.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            // Apply styling
            if (hasSelection) {
                if (isSelected) {
                    const orig = _selectionOriginals.get(node.id);
                    node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
                } else {
                    const orig = _originalColorsForDim.get(node.id);
                    if (orig) {
                        node.color = _dimColor(orig.color, 0.5);
                        node.val = orig.val * 0.7;
                    }
                }
            } else {
                // Restore originals
                const orig = _originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = orig.color;
                    node.val = orig.val;
                }
            }

            // Update halo visibility
            if (node.__selectionHalo) {
                node.__selectionHalo.visible = isSelected;
            }
        });

        // Handle animation state
        if (hasSelection) {
            startAnimation();
        } else {
            stopAnimation();
            _selectionOriginals.clear();
            _originalColorsForDim.clear();
        }

        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (Graph) {
            Graph.refresh();
        }
    }

    function _updatePanel() {
        if (typeof updateSelectionPanel === 'function') {
            updateSelectionPanel();
        }
    }

    function _updateGroupButtonState() {
        if (typeof updateGroupButtonState === 'function') {
            updateGroupButtonState();
        }
    }

    // =========================================================================
    // NODE OVERLAYS (3D halos)
    // =========================================================================

    function ensureOverlays(node) {
        if (!node) return null;
        if (node.__overlayGroup) return node.__overlayGroup;

        // Lazy init geometry
        if (!_selectionHaloGeometry) {
            _selectionHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
            _groupHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
        }

        const group = new THREE.Group();

        const selectionMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
        });
        const selectionHalo = new THREE.Mesh(_selectionHaloGeometry, selectionMaterial);
        selectionHalo.visible = false;
        selectionHalo.renderOrder = 3;

        const groupMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.45,
            depthWrite: false
        });
        const groupHalo = new THREE.Mesh(_groupHaloGeometry, groupMaterial);
        groupHalo.visible = false;
        groupHalo.renderOrder = 2;

        group.add(selectionHalo);
        group.add(groupHalo);

        node.__selectionHalo = selectionHalo;
        node.__groupHalo = groupHalo;
        node.__overlayGroup = group;

        return group;
    }

    function updateOverlayScale(node) {
        const APPEARANCE_STATE = typeof window !== 'undefined' ? window.APPEARANCE_STATE : { nodeScale: 1 };
        const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE?.nodeScale || 1));
        const selectionScale = base * 2.5;
        const groupScale = base * 1.8;

        if (node.__selectionHalo) {
            node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
        }
        if (node.__groupHalo) {
            node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
        }
    }

    // =========================================================================
    // MARQUEE STATE
    // =========================================================================

    function setMarqueeActive(active) {
        _marqueeActive = active;
        if (!active) {
            _lastMarqueeEndTs = Date.now();
        }
    }

    function setMarqueeStart(pos) {
        _marqueeStart = pos;
    }

    function setMarqueeAdditive(additive) {
        _marqueeAdditive = additive;
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core selection
        set,
        toggle,
        clear,
        maybeClear,
        add,
        remove,
        getSelectedNodes,

        // State access
        get ids() { return _ids; },
        get size() { return _ids.size; },
        has(id) { return _ids.has(id); },

        // Animation
        startAnimation,
        stopAnimation,

        // Overlays
        ensureOverlays,
        updateOverlayScale,

        // Marquee
        setMarqueeActive,
        setMarqueeStart,
        setMarqueeAdditive,
        get marqueeActive() { return _marqueeActive; },
        get marqueeStart() { return _marqueeStart; },
        get marqueeAdditive() { return _marqueeAdditive; },
        get lastMarqueeEndTs() { return _lastMarqueeEndTs; },

        // Internal access (for migration)
        _selectionOriginals,
        _originalColorsForDim
    };
})();

// Backward compatibility aliases - Using getters to ensure live updates
// Note: All variables use Object.defineProperty to avoid duplicate declarations with app.js
// SELECTED_NODE_IDS - selection.js is now the SINGLE SOURCE OF TRUTH (unified in modularization)
Object.defineProperty(window, 'SELECTED_NODE_IDS', { get: () => SELECT.ids, configurable: true });
Object.defineProperty(window, 'MARQUEE_ACTIVE', { get: () => SELECT.marqueeActive, configurable: true });
Object.defineProperty(window, 'MARQUEE_START', { get: () => SELECT.marqueeStart, configurable: true });
Object.defineProperty(window, 'MARQUEE_ADDITIVE', { get: () => SELECT.marqueeAdditive, configurable: true });
Object.defineProperty(window, 'LAST_MARQUEE_END_TS', { get: () => SELECT.lastMarqueeEndTs, configurable: true });
// selectionOriginals, originalColorsForDim - app.js owns these, not duplicated here

function getSelectedNodes() { return SELECT.getSelectedNodes(); }
function setSelection(ids, additive) { SELECT.set(ids, additive); }
function toggleSelection(node) { SELECT.toggle(node); }
function clearSelection() { SELECT.clear(); }
function maybeClearSelection() { SELECT.maybeClear(); }
function startSelectionAnimation() { SELECT.startAnimation(); }
function stopSelectionAnimation() { SELECT.stopAnimation(); }
function ensureNodeOverlays(node) { return SELECT.ensureOverlays(node); }
function updateOverlayScale(node) { SELECT.updateOverlayScale(node); }


// ═══ MODULE: modules/panels.js ═══
/**
 * PANELS MODULE
 *
 * Manages floating panels and HUD layout for the visualization.
 * Handles panel open/close, command bar, and UI dimming.
 *
 * Usage:
 *   PANELS.open('view')       // Open a panel
 *   PANELS.close('view')      // Close a panel
 *   PANELS.toggle('view')     // Toggle panel visibility
 *   PANELS.initCommandBar()   // Wire up command bar buttons
 */

const PANELS = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _activePanelId = null;

    // =========================================================================
    // PANEL FUNCTIONS
    // =========================================================================

    /**
     * Open a panel by ID
     */
    function open(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        // Close any already-open panel
        if (_activePanelId && _activePanelId !== panelId) {
            close(_activePanelId);
        }

        if (panel) {
            panel.classList.add('visible');
            setTimeout(() => { panel.style.opacity = '1'; }, 10);
        }
        if (btn) btn.classList.add('active');
        _activePanelId = panelId;

        // Dim the universe when panel opens
        document.body.classList.add('ui-active');

        // Dim starfield via JS
        if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
            const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
            STARFIELD.material.opacity = baseOpacity * 0.3;
        }
    }

    /**
     * Close a panel by ID
     */
    function close(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        if (panel) {
            panel.classList.remove('visible');
        }
        if (btn) btn.classList.remove('active');
        if (_activePanelId === panelId) _activePanelId = null;

        // Restore universe when all panels closed
        if (!_activePanelId) {
            document.body.classList.remove('ui-active');

            // Restore starfield
            if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
                const starsBtn = document.getElementById('btn-stars');
                const starsVisible = starsBtn && starsBtn.classList.contains('active');
                const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
                STARFIELD.material.opacity = starsVisible ? baseOpacity : 0;
            }
        }
    }

    /**
     * Toggle a panel
     */
    function toggle(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        if (panel && panel.classList.contains('visible')) {
            close(panelId);
        } else {
            open(panelId);
        }
    }

    /**
     * Get active panel ID
     */
    function getActive() {
        return _activePanelId;
    }

    // =========================================================================
    // COMMAND BAR INITIALIZATION
    // =========================================================================

    function initCommandBar() {
        const cmdBtns = {
            'cmd-view': 'view',
            'cmd-filter': 'filter',
            'cmd-style': 'style',
            'cmd-settings': 'settings'
        };

        Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', () => toggle(panelId));
            }
        });

        // Settings panel: Oval margin slider
        _initOvalMarginSlider();
        _initOvalDebugToggle();
    }

    function _initOvalMarginSlider() {
        const ovalSlider = document.getElementById('oval-margin-slider');
        const ovalValue = document.getElementById('oval-margin-value');
        let ovalDebounceTimer = null;

        if (ovalSlider) {
            ovalSlider.addEventListener('input', (e) => {
                if (ovalValue) ovalValue.textContent = e.target.value + '%';
            });

            const applyOvalMargin = () => {
                clearTimeout(ovalDebounceTimer);
                ovalDebounceTimer = setTimeout(() => {
                    const val = ovalSlider.value;
                    document.documentElement.style.setProperty('--oval-margin', val + '%');
                }, 300);
            };

            ovalSlider.addEventListener('mouseup', applyOvalMargin);
            ovalSlider.addEventListener('touchend', applyOvalMargin);
            ovalSlider.addEventListener('change', applyOvalMargin);
        }
    }

    function _initOvalDebugToggle() {
        const toggleOvalDebug = document.getElementById('toggle-oval-debug');
        if (toggleOvalDebug) {
            toggleOvalDebug.addEventListener('click', () => {
                toggleOvalDebug.classList.toggle('active');
                const ovalDebug = document.querySelector('.oval-debug');
                if (ovalDebug) {
                    ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
                }
            });
        }
    }

    // =========================================================================
    // HUD LAYOUT MANAGER - REMOVED, USE LAYOUT MODULE
    // =========================================================================
    // The HudLayoutManager has been unified into modules/layout.js
    // Use LAYOUT.reflow() instead of PANELS.HudLayoutManager.reflow()

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        open,
        close,
        toggle,
        getActive,
        initCommandBar,

        // State access
        get activePanelId() { return _activePanelId; }
    };
})();

// Backward compatibility - _activePanelId is managed by app.js
function openPanel(panelId) { PANELS.open(panelId); }
function closePanel(panelId) { PANELS.close(panelId); }
function togglePanel(panelId) { PANELS.toggle(panelId); }
function initCommandBar() { PANELS.initCommandBar(); }
// HudLayoutManager - app.js owns this, not duplicated here

// ════════════════════════════════════════════════════════════════════════
// PANEL DRAG & RESIZE - Make panels movable and resizable
// ════════════════════════════════════════════════════════════════════════

const PANEL_DRAG = (function() {
    'use strict';

    const _panels = new Map();
    let _dragState = null;
    let _resizeState = null;
    const STORAGE_KEY = 'collider-panel-positions';

    function init() {
        // Initialize draggable/resizable panels (use actual element IDs)
        initPanel('side-dock', { draggable: true, resizable: true, minWidth: 150, maxWidth: 400 });
        initPanel('header-panel', { draggable: true, resizable: false });
        initPanel('stats-panel', { draggable: true, resizable: false });
        initPanel('metrics-panel', { draggable: true, resizable: true, minWidth: 180, maxWidth: 350 });

        // Restore saved positions
        restorePositions();

        // Global mouse handlers
        document.addEventListener('mousemove', (e) => _onMouseMove(e));
        document.addEventListener('mouseup', (e) => _onMouseUp(e));
    }

    function initPanel(id, options = {}) {
        const panel = document.getElementById(id) || document.querySelector('.' + id);
        if (!panel) return;

        const config = {
            el: panel,
            id: id,
            draggable: options.draggable !== false,
            resizable: options.resizable === true,
            minWidth: options.minWidth || 100,
            maxWidth: options.maxWidth || 600,
            minHeight: options.minHeight || 50,
            maxHeight: options.maxHeight || window.innerHeight - 100
        };

        _panels.set(id, config);

        // Make panel positioned if not already
        const style = window.getComputedStyle(panel);
        if (style.position === 'static') {
            panel.style.position = 'absolute';
        }

        // Add drag handle (the panel header or title)
        if (config.draggable) {
            const header = panel.querySelector('.side-title, .hud-title, .panel-header') || panel;
            header.style.cursor = 'move';
            header.addEventListener('mousedown', (e) => _startDrag(e, id));
        }

        // Add resize handle
        if (config.resizable) {
            const handle = document.createElement('div');
            handle.className = 'panel-resize-handle';
            handle.addEventListener('mousedown', (e) => _startResize(e, id));
            panel.appendChild(handle);
            panel.style.position = 'absolute';
        }
    }

    function _startDrag(e, panelId) {
        // Don't drag if clicking on interactive elements
        if (e.target.closest('input, button, select, .collapsible-content, .preset-btn, .layout-btn, .scheme-btn')) {
            return;
        }

        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        const rect = config.el.getBoundingClientRect();

        _dragState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startLeft: rect.left,
            startTop: rect.top
        };

        config.el.classList.add('panel-dragging');
    }

    function _startResize(e, panelId) {
        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        e.stopPropagation();

        const rect = config.el.getBoundingClientRect();

        _resizeState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startWidth: rect.width,
            startHeight: rect.height
        };

        config.el.classList.add('panel-resizing');
    }

    function _onMouseMove(e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (!config) return;

            const dx = e.clientX - _dragState.startX;
            const dy = e.clientY - _dragState.startY;

            let newLeft = _dragState.startLeft + dx;
            let newTop = _dragState.startTop + dy;

            // Keep within viewport
            newLeft = Math.max(0, Math.min(window.innerWidth - 50, newLeft));
            newTop = Math.max(0, Math.min(window.innerHeight - 50, newTop));

            config.el.style.left = newLeft + 'px';
            config.el.style.top = newTop + 'px';
            config.el.style.right = 'auto';
            config.el.style.bottom = 'auto';
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (!config) return;

            const dx = e.clientX - _resizeState.startX;
            const dy = e.clientY - _resizeState.startY;

            let newWidth = _resizeState.startWidth + dx;
            let newHeight = _resizeState.startHeight + dy;

            // Apply constraints
            newWidth = Math.max(config.minWidth, Math.min(config.maxWidth, newWidth));
            newHeight = Math.max(config.minHeight, Math.min(config.maxHeight, newHeight));

            config.el.style.width = newWidth + 'px';
            // Only resize height for certain panels
            if (config.el.classList.contains('side-dock') || config.el.classList.contains('side-content')) {
                // Don't change height for sidebar - it's auto
            } else {
                config.el.style.height = newHeight + 'px';
            }
        }
    }

    function _onMouseUp(_e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (config) {
                config.el.classList.remove('panel-dragging');
                savePositions();
            }
            _dragState = null;
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (config) {
                config.el.classList.remove('panel-resizing');
                savePositions();
            }
            _resizeState = null;
        }
    }

    function savePositions() {
        const positions = {};
        _panels.forEach((config, id) => {
            const rect = config.el.getBoundingClientRect();
            const style = config.el.style;
            positions[id] = {
                left: style.left || rect.left + 'px',
                top: style.top || rect.top + 'px',
                width: style.width || null,
                height: style.height || null
            };
        });
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not save positions:', e);
        }
    }

    function restorePositions() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;

            const positions = JSON.parse(saved);
            Object.entries(positions).forEach(([id, pos]) => {
                const config = _panels.get(id);
                if (!config) return;

                if (pos.left) config.el.style.left = pos.left;
                if (pos.top) config.el.style.top = pos.top;
                if (pos.width) config.el.style.width = pos.width;
                if (pos.height) config.el.style.height = pos.height;

                // Clear right/bottom if we're setting left/top
                if (pos.left) config.el.style.right = 'auto';
                if (pos.top) config.el.style.bottom = 'auto';
            });
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not restore positions:', e);
        }
    }

    function resetPositions() {
        try {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not reset positions:', e);
        }
    }

    return {
        init,
        initPanel,
        savePositions,
        restorePositions,
        resetPositions,
        get panels() { return _panels; }
    };
})();

// Backward compatibility wrapper
const PanelManager = {
    panels: PANEL_DRAG.panels,
    init() { PANEL_DRAG.init(); },
    initPanel(id, opts) { PANEL_DRAG.initPanel(id, opts); },
    savePositions() { PANEL_DRAG.savePositions(); },
    restorePositions() { PANEL_DRAG.restorePositions(); },
    resetPositions() { PANEL_DRAG.resetPositions(); }
};

// Initialize after DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => PANEL_DRAG.init());
} else {
    setTimeout(() => PANEL_DRAG.init(), 100);
}

// Expose globally
window.PANEL_DRAG = PANEL_DRAG;
window.PanelManager = PanelManager;


// ═══ MODULE: modules/sidebar.js ═══
/**
 * SIDEBAR MODULE
 *
 * Manages sidebar controls including color presets, layout presets,
 * physics controls, appearance controls, filters, and panel updates.
 *
 * Depends on: ANIM (for layouts), REFRESH (for throttled updates)
 *
 * Usage:
 *   SIDEBAR.init()                         // Initialize after DOM ready
 *   SIDEBAR.setColorMode('tier')           // Change color mode
 *   SIDEBAR.setLayout('force')             // Change layout
 *   SIDEBAR.setPhysicsPreset('tight')      // Apply physics preset
 *   SIDEBAR.updateStats(nodes, edges)      // Update stat displays
 */

// Note: Using window assignment instead of const to avoid duplicate declaration with app.js
window.SIDEBAR = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _refreshTimer = null;
    let _bound = false;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    /**
     * Initialize sidebar - call after DOM is ready
     */
    function init() {
        if (_bound) return;
        _bound = true;

        // Initialize unified state manager first
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.init();
        }

        _bindSectionHeaders();
        _bindColorPresets();
        _bindLayoutPresets();
        _bindPhysicsControls();
        _bindAppearanceControls();
        _bindActionButtons();
        initSchemeNavigator();
        initViewModeToggle();
        initSectionResize();   // Enable vertical section resizing
        initSidebarResize();   // Enable horizontal sidebar resizing

        // Sync UI to initial state
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.syncUIFromState();
        }

        console.log('[SIDEBAR] Initialized');
    }

    // =========================================================================
    // SECTION COLLAPSE/EXPAND
    // =========================================================================

    function _bindSectionHeaders() {
        document.querySelectorAll('.section-header[data-section]').forEach(header => {
            header.addEventListener('click', () => {
                const sectionId = header.dataset.section;
                const content = document.getElementById(`section-${sectionId}`);
                if (!content) return;

                const isCollapsed = header.classList.toggle('collapsed');
                content.classList.toggle('collapsed', isCollapsed);
            });
        });
    }

    // =========================================================================
    // COLOR PRESETS (TIER, FAMILY, LAYER, RING, FILE, FLOW)
    // =========================================================================

    // =========================================================================
    // COLOR PRESETS: SMART SIDEBAR CONFIGURATION
    // =========================================================================

    const PRESET_CONFIG = [
        {
            category: 'Architecture',
            presets: [
                { id: 'tier', label: 'Tier', desc: 'Auto-detected architectural height' },
                { id: 'layer', label: 'Layer', desc: 'Business logic strata' },
                { id: 'subsystem', label: 'Subsystem', desc: 'Functional domain grouping' },
                { id: 'boundary_score', label: 'Boundary', desc: 'Internal vs External (1-9)' },
                { id: 'phase', label: 'Phase', desc: 'Data-Logic-Org-Exec (MIPO)' }
            ]
        },
        {
            category: 'Taxonomy',
            presets: [
                { id: 'atom', label: 'Atom', desc: 'Function, Class, Module types' },
                { id: 'family', label: 'Family', desc: 'Logic, Data, Execution' },
                { id: 'role', label: 'Role', desc: 'Service, Repo, Controller' },
                { id: 'roleCategory', label: 'Role Cat', desc: 'Query, Command, Event' },
                { id: 'fileType', label: 'File Type', desc: 'Extension-based coloring' }
            ]
        },
        {
            category: 'Metrics',
            presets: [
                { id: 'complexity', label: 'Complexity', desc: 'Cyclomatic complexity' },
                { id: 'loc', label: 'LOC', desc: 'Lines of Code' },
                { id: 'fan_in', label: 'Fan-In', desc: 'Incoming dependencies' },
                { id: 'fan_out', label: 'Fan-Out', desc: 'Outgoing dependencies' },
                { id: 'trust', label: 'Trust', desc: 'Detection confidence' }
            ]
        },
        {
            category: 'RPBL DNA',
            presets: [
                { id: 'responsibility', label: 'Responsibility', desc: 'SRP alignment (1-9)' },
                { id: 'purity', label: 'Purity', desc: 'Side-effect profile (1-9)' },
                { id: 'lifecycle_score', label: 'Lifecycle', desc: 'Static vs Dynamic (1-9)' },
                { id: 'state', label: 'State', desc: 'Stateful vs Stateless' },
                { id: 'visibility', label: 'Visibility', desc: 'Public vs Private' }
            ]
        },
        {
            category: 'Topology',
            presets: [
                { id: 'centrality', label: 'Centrality', desc: 'Graph importance' },
                { id: 'rank', label: 'PageRank', desc: 'Algorithmic influence' }, // mapped to centrality logic or similar
                { id: 'ring', label: 'Ring', desc: 'Concentric architecture rings' },
                { id: 'flow', label: 'Flow', desc: 'Dependency direction' }
            ]
        },
        {
            category: 'Evolution',
            presets: [
                { id: 'churn', label: 'Churn', desc: 'Change frequency (Simulated)' },
                { id: 'age', label: 'Age', desc: 'Time since creation (Simulated)' }
            ]
        }
    ];

    // =========================================================================
    // SCHEME NAVIGATOR: 33 Named Color Schemes
    // =========================================================================

    const SCHEME_CONFIG = [
        // PART A: Famous Scientific (15)
        { category: 'Sequential', schemes: ['viridis', 'plasma', 'magma', 'inferno', 'cividis', 'turbo', 'mako', 'rocket'] },
        { category: 'Diverging', schemes: ['coolwarm', 'spectral'] },
        { category: 'Thematic', schemes: ['thermal', 'nightvision', 'ocean', 'terrain', 'electric'] },

        // PART B: Role-Semantic (18 key roles)
        { category: 'Access', schemes: ['query', 'finder'] },
        { category: 'Mutation', schemes: ['command', 'creator', 'destroyer'] },
        { category: 'Construction', schemes: ['factory'] },
        { category: 'Storage', schemes: ['repository', 'cache'] },
        { category: 'Control', schemes: ['service', 'orchestrator'] },
        { category: 'Validation', schemes: ['validator', 'guard'] },
        { category: 'Transform', schemes: ['transformer', 'parser'] },
        { category: 'Events', schemes: ['handler', 'emitter'] },
        { category: 'Support', schemes: ['utility', 'lifecycle'] },

        // PART C: OKLCH Geometry (Mathematical paths through color space)
        { category: 'Loops', schemes: ['rainbow-loop', 'rainbow-bright', 'rainbow-dark'] },
        { category: 'Arcs', schemes: ['arc-warm', 'arc-cool', 'arc-nature'] },
        { category: 'Spirals', schemes: ['spiral-up', 'spiral-down', 'spiral-chroma'] },
        { category: 'Waves', schemes: ['wave-lightness', 'wave-chroma', 'pulse'] },
        { category: 'Ramps', schemes: ['ramp-hue', 'ramp-lightness', 'ramp-chroma'] },
        { category: 'Paths', schemes: ['helix', 'convergent', 'divergent', 'bicone'] }
    ];

    function _bindColorPresets() {
        // Init Smart Sidebar
        const container = document.getElementById('section-color');
        if (!container) return;

        // Clear existing static buttons if any (except header)
        const contentDiv = container.querySelector('.section-content');
        if (contentDiv) {
            contentDiv.innerHTML = ''; // Rebuild from scratch
            renderSmartSidebar(contentDiv);
        }
    }

    function renderSmartSidebar(container) {
        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Presets...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.preset-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.btn').forEach(btn => {
                    const match = btn.textContent.toLowerCase().includes(term) || btn.title.toLowerCase().includes(term);
                    btn.style.display = match ? 'block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        searchContainer.appendChild(searchInput);
        container.appendChild(searchContainer);

        // Render Categories
        PRESET_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'preset-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'btn-grid btn-grid-3'; // Default to 3-col

            section.presets.forEach(p => {
                const btn = document.createElement('button');
                btn.className = 'btn color-btn';
                btn.textContent = p.label;
                btn.title = p.desc;
                btn.dataset.preset = p.id;

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    setColorMode(p.id);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    // =========================================================================
    // SCHEME NAVIGATOR RENDERER
    // =========================================================================

    function renderSchemeNavigator(container) {
        if (!container) return;
        container.innerHTML = '';

        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Schemes...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.scheme-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.scheme-btn').forEach(btn => {
                    const match = btn.dataset.scheme.toLowerCase().includes(term) ||
                        (btn.title && btn.title.toLowerCase().includes(term));
                    btn.style.display = match ? 'inline-block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear';
        clearBtn.title = 'Remove scheme, use default colors';
        clearBtn.style.cssText = 'margin-left: 8px; padding: 4px 8px; font-size: 9px; background: rgba(255,100,100,0.2); border: 1px solid rgba(255,100,100,0.3); color: var(--text); border-radius: 4px; cursor: pointer;';
        clearBtn.addEventListener('click', clearColorScheme);

        searchContainer.appendChild(searchInput);
        searchContainer.appendChild(clearBtn);
        container.appendChild(searchContainer);

        // Render Categories
        SCHEME_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'scheme-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'scheme-grid';
            grid.style.cssText = 'display: flex; flex-wrap: wrap; gap: 4px;';

            section.schemes.forEach(schemeName => {
                const btn = document.createElement('button');
                btn.className = 'scheme-btn';
                btn.dataset.scheme = schemeName;

                // Get scheme info from COLOR engine
                let info = { name: schemeName, semantic: '' };
                if (typeof COLOR !== 'undefined' && COLOR.getSchemeInfo) {
                    info = COLOR.getSchemeInfo(schemeName);
                }

                btn.title = info.semantic || schemeName;

                // Create clean color swatches (5 stops) instead of ugly gradient
                const swatchContainer = document.createElement('div');
                swatchContainer.className = 'scheme-swatches';

                if (typeof COLOR !== 'undefined' && COLOR.getSchemeColor) {
                    // Sample 5 colors from the scheme path
                    [0, 0.25, 0.5, 0.75, 1].forEach(t => {
                        const swatch = document.createElement('span');
                        swatch.className = 'scheme-swatch';
                        swatch.style.backgroundColor = COLOR.getSchemeColor(schemeName, t);
                        swatchContainer.appendChild(swatch);
                    });
                }

                btn.appendChild(swatchContainer);

                // Label below swatches
                const label = document.createElement('span');
                label.className = 'scheme-label';
                label.textContent = info.name;
                btn.appendChild(label);

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    applyColorScheme(schemeName);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    /**
     * Apply a named color scheme (palette)
     *
     * NEW BEHAVIOR (via VIS_STATE):
     * - Palette is "armed" but does NOT auto-switch colorBy mode
     * - Palette only visually applies when colorBy is an interval mode
     * - When user switches to interval mode, the armed palette becomes active
     */
    function applyColorScheme(schemeName) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(schemeName);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(schemeName);
        }

        try {
            localStorage.setItem('collider_scheme', schemeName);
        } catch (e) { /* ignore */ }

        _refreshGraphColors();
        console.log('[SIDEBAR] Applied scheme:', schemeName);
    }

    /**
     * Clear active scheme, return to default interval colors
     */
    function clearColorScheme() {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(null);
            return;
        }

        // Fallback
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(null);
        }

        try {
            localStorage.removeItem('collider_scheme');
        } catch (e) { /* ignore */ }

        document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));

        _refreshGraphColors();

        console.log('[SIDEBAR] Cleared color scheme');
    }

    /**
     * Internal: Refresh all node colors and re-render the graph
     */
    function _refreshGraphColors() {
        if (typeof Graph === 'undefined' || !Graph) return;

        // Get current nodes from DataManager or Graph
        const DM = window.DM;
        const nodes = DM ? DM.getNodes() : (Graph.graphData ? Graph.graphData().nodes : []);

        // Recompute colors using current mode
        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render
        Graph.nodeColor(Graph.nodeColor());

        // Also refresh edges if in gradient mode
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    /**
     * Initialize scheme navigator in sidebar
     */
    function initSchemeNavigator() {
        const container = document.getElementById('section-schemes');
        if (container) {
            renderSchemeNavigator(container);
        }

        // Setup collapsible header for schemes panel
        const collapsibleHeaders = document.querySelectorAll('.info-panel-header.collapsible');
        collapsibleHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    header.classList.toggle('collapsed', isCollapsed);
                }
            });
        });

        // Setup color mode buttons (for right sidebar)
        const colorBtns = document.querySelectorAll('.color-panel .color-btn');
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                if (!preset) return;

                // Apply color mode via VIS_STATE (handles UI sync)
                setColorMode(preset);
            });
        });

        // NOTE: Saved preferences are now loaded by VIS_STATE.init()
        // UI sync is handled by VIS_STATE.syncUIFromState()
    }

    // =========================================================================
    // VIEW MODE TOGGLE (ATOMS vs FILES)
    // =========================================================================

    let _currentViewMode = 'atoms';
    let _deferredViewMode = null;  // Stores mode to apply after data loads

    /**
     * Initialize the view mode toggle (Atoms vs Files)
     * Note: Only sets up event handlers and button visual state.
     * Actual mode application for 'files' is deferred until data is loaded.
     */
    function initViewModeToggle() {
        const toggle = document.getElementById('view-mode-toggle');
        if (!toggle) return;

        const buttons = toggle.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                if (!mode || mode === _currentViewMode) return;

                setViewMode(mode);
            });
        });

        // Load saved preference - but only update button state, defer actual mode switch
        try {
            const saved = localStorage.getItem('collider_view_mode');
            if (saved && (saved === 'atoms' || saved === 'files')) {
                // Update button visual state immediately
                buttons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === saved);
                });
                _currentViewMode = saved;

                // If files mode, defer application until data is loaded
                if (saved === 'files') {
                    _deferredViewMode = 'files';
                    console.log('[SIDEBAR] Files mode saved - deferring until data loads');
                }
            }
        } catch (e) { /* ignore */ }
    }

    /**
     * Apply deferred view mode after data is loaded
     * Call this from initGraph() after DM.init() completes
     */
    function applyDeferredViewMode() {
        if (_deferredViewMode === 'files') {
            console.log('[SIDEBAR] Applying deferred files mode now that data is loaded');
            _deferredViewMode = null;  // Clear to prevent re-application

            // Apply files mode (data is now available)
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
                console.log('[SIDEBAR] View mode: FILES - showing file nodes');

                if (typeof showToast === 'function') {
                    showToast('FILE VIEW: Each node is a file. Click to expand.');
                }
            }
        }
    }

    /**
     * Set the view mode (atoms or files)
     */
    function setViewMode(mode) {
        if (mode !== 'atoms' && mode !== 'files') return;
        _currentViewMode = mode;

        // Update button states
        const buttons = document.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });

        // Save preference
        try {
            localStorage.setItem('collider_view_mode', mode);
        } catch (e) { /* ignore */ }

        // Apply view mode via FILE_VIZ module
        if (mode === 'files') {
            // Switch to file-nodes view
            if (typeof FILE_VIZ !== 'undefined') {
                // Build the file graph first (required before switching mode)
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'files';
                if (typeof buildFileGraph === 'function') buildFileGraph(null);
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: FILES - showing file nodes');
        } else {
            // Switch to atoms view
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.graphMode = 'atoms';
                FILE_VIZ.setEnabled(false);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'atoms';
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: ATOMS - showing individual atoms');
        }

        // Show toast notification
        if (typeof showToast === 'function') {
            const msg = mode === 'files'
                ? 'FILE VIEW: Each node is a file. Click to expand.'
                : 'ATOM VIEW: Each node is a code element.';
            showToast(msg);
        }
    }

    /**
     * Get current view mode
     */
    function getViewMode() {
        return _currentViewMode;
    }

    function setColorMode(mode) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setColorBy(mode);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof APPEARANCE_STATE !== 'undefined') {
            APPEARANCE_STATE.colorMode = mode;
            APPEARANCE_STATE.currentPreset = mode;
        }

        if (typeof setNodeColorMode === 'function') {
            setNodeColorMode(mode);
        }

        // Handle flow mode specially
        if (mode === 'flow') {
            if (typeof flowMode !== 'undefined' && !flowMode && typeof toggleFlowMode === 'function') {
                toggleFlowMode();
            }
        } else if (typeof flowMode !== 'undefined' && flowMode && typeof disableFlowMode === 'function') {
            disableFlowMode();
        }

        if (typeof window !== 'undefined' && typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        console.log('[SIDEBAR] Color mode:', mode);
    }

    // =========================================================================
    // LAYOUT PRESETS (FORCE, RADIAL, ORBITAL, SPHERE, GRID, SPIRAL)
    // =========================================================================

    function _bindLayoutPresets() {
        const container = document.getElementById('section-layout');
        if (!container) return;

        container.querySelectorAll('.btn[data-layout]').forEach(btn => {
            btn.addEventListener('click', () => {
                const layout = btn.dataset.layout;
                setLayout(layout);

                // Update active state
                container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });
    }

    function setLayout(layout) {
        // Prefer ANIM module if available
        if (typeof ANIM !== 'undefined' && ANIM.applyLayout) {
            ANIM.applyLayout(layout, true);
        } else if (typeof applyLayoutPreset === 'function') {
            applyLayoutPreset(layout, true);
        }
        console.log('[SIDEBAR] Layout:', layout);
    }

    // =========================================================================
    // PHYSICS CONTROLS
    // =========================================================================

    const PHYSICS_PRESETS = {
        default: { charge: -120, link: 50, center: 0.05, damping: 0.4 },
        tight: { charge: -80, link: 30, center: 0.1, damping: 0.5 },
        loose: { charge: -200, link: 80, center: 0.02, damping: 0.3 },
        explosive: { charge: -400, link: 120, center: 0.01, damping: 0.2 }
    };

    function _bindPhysicsControls() {
        // Charge (repulsion)
        _bindSlider('physics-charge', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('charge').strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Link distance
        _bindSlider('physics-link', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('link').distance(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Center pull
        _bindSlider('physics-center', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                const center = Graph.d3Force('center');
                if (center && center.strength) center.strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Damping (velocity decay)
        _bindSlider('physics-damping', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3VelocityDecay(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Physics presets
        const container = document.getElementById('section-physics');
        if (container) {
            container.querySelectorAll('.btn[data-physics]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.physics;
                    setPhysicsPreset(preset);
                });
            });
        }
    }

    function setPhysicsPreset(preset) {
        const p = PHYSICS_PRESETS[preset];
        if (!p) return;

        // Update sliders
        _setSliderValue('physics-charge', p.charge);
        _setSliderValue('physics-link', p.link);
        _setSliderValue('physics-center', p.center);
        _setSliderValue('physics-damping', p.damping);

        // Apply to graph
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('charge').strength(p.charge);
            Graph.d3Force('link').distance(p.link);
            const center = Graph.d3Force('center');
            if (center && center.strength) center.strength(p.center);
            Graph.d3VelocityDecay(p.damping);
            Graph.d3ReheatSimulation();
        }

        console.log('[SIDEBAR] Physics preset:', preset);
    }

    // =========================================================================
    // APPEARANCE CONTROLS
    // =========================================================================

    function _bindAppearanceControls() {
        // Auto-bind all sliders that have a matching numeric input
        // This covers cfg-node-size, cfg-node-opacity, etc.
        const ranges = document.querySelectorAll('input[type="range"]');
        ranges.forEach(range => {
            if (range.id) {
                _bindSlider(range.id, (val) => {
                    // Dispatch to specific handlers based on ID
                    // This creates a centralized handler dispatch
                    _handleSliderChange(range.id, val);
                });
            }
        });

        // Toggles
        _bindToggle('cfg-toggle-labels', (active) => {
            if (typeof VIS_FILTERS !== 'undefined' && VIS_FILTERS.metadata) {
                VIS_FILTERS.metadata.showLabels = active;
            }
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.nodeLabel(n => active ? n.name : null);
            }
        });

        _bindToggle('cfg-toggle-highlight', (active) => {
            // Handled by VIS_STATE or interactions
        });

        _bindToggle('cfg-toggle-pulse', (active) => {
            if (typeof ANIM !== 'undefined') {
                ANIM.togglePulse(active);
            }
        });

        _bindToggle('cfg-toggle-depth', (active) => {
            // 3D shading toggle
        });

        _bindToggle('cfg-toggle-arrows', (active) => {
            if (typeof Graph !== 'undefined' && Graph) {
                const linkDirectionalArrowLength = active ? 3.5 : 0;
                Graph.linkDirectionalArrowLength(linkDirectionalArrowLength);
            }
        });

        _bindToggle('cfg-toggle-gradient', (active) => {
            if (typeof VIS_STATE !== 'undefined') {
                // Trigger re-render of edges
                window.refreshGradientEdgeColors && window.refreshGradientEdgeColors();
            }
        });
    }

    // Centralized handler for all sliders
    function _handleSliderChange(id, val) {
        // Map ID to logic
        switch (id) {
            // Node Config
            case 'cfg-node-size':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeVal(n => (n.val || 1) * val);
                break;
            case 'cfg-node-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode(); // Re-apply colors with new alpha
                break;
            case 'cfg-node-res':
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeResolution(val);
                break;
            case 'cfg-label-size':
                // Note: 3d-force-graph doesn't have a direct dynamic label size multiplier, 
                // but we can trigger a re-render or update state.
                break;

            // Edge Config    
            case 'cfg-edge-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
                break;
            case 'cfg-edge-width':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkWidth(val);
                break;
            case 'cfg-edge-curve':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkCurvature(val);
                break;
            case 'cfg-particle-speed':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticleSpeed(val);
                break;
            case 'cfg-particle-count':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticles(val);
                break;

            // Physics (Updated IDs)
            case 'physics-charge':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('charge').strength(val);
                    Graph.d3ReheatSimulation();
                }
                break;
            case 'physics-link':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('link').distance(val);
                    Graph.d3ReheatSimulation();
                }
                break;
        }
    }


    // =========================================================================
    // ACTION BUTTONS
    // =========================================================================

    function _bindActionButtons() {
        // Reset view
        const resetBtn = document.getElementById('btn-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
                }
            });
        }

        // Screenshot
        const screenshotBtn = document.getElementById('btn-screenshot');
        if (screenshotBtn) {
            screenshotBtn.addEventListener('click', () => {
                if (typeof takeScreenshot === 'function') {
                    takeScreenshot();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    const link = document.createElement('a');
                    link.download = 'collider-screenshot.png';
                    link.href = Graph.renderer().domElement.toDataURL('image/png');
                    link.click();
                }
            });
        }

        // Toggle 2D
        const toggle2dBtn = document.getElementById('btn-2d');
        if (toggle2dBtn) {
            toggle2dBtn.addEventListener('click', () => {
                if (typeof toggle2DMode === 'function') toggle2DMode();
            });
        }

        // Freeze simulation
        const freezeBtn = document.getElementById('btn-freeze');
        if (freezeBtn) {
            freezeBtn.addEventListener('click', () => {
                if (typeof toggleFreeze === 'function') {
                    toggleFreeze();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    // Simple freeze toggle
                    const alpha = Graph.d3AlphaTarget();
                    Graph.d3AlphaTarget(alpha === 0 ? 0.3 : 0);
                    freezeBtn.classList.toggle('active', alpha !== 0);
                }
            });
        }
    }

    // =========================================================================
    // FILTER CHIPS
    // =========================================================================

    function populateFilterChips(data) {
        if (!data || !data.nodes) return;

        // Tiers
        const tiers = [...new Set(data.nodes.map(n => n.tier).filter(Boolean))].sort();
        _populateChipGroup('filter-tiers', tiers, 'tiers');

        // Rings
        const rings = [...new Set(data.nodes.map(n => n.ring).filter(Boolean))].sort();
        _populateChipGroup('filter-rings', rings, 'rings');

        // Edge types
        const edgeTypes = [...new Set(data.links?.map(e => e.type).filter(Boolean) || [])].sort();
        _populateChipGroup('filter-edges', edgeTypes, 'edges');
    }

    function _populateChipGroup(containerId, items, filterKey) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';
        items.forEach(item => {
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = item;
            chip.addEventListener('click', () => {
                const isActive = chip.classList.toggle('active');
                setFilter(filterKey, item, !isActive); // active = filtered OUT
                _scheduleRefresh();
            });
            container.appendChild(chip);
        });
    }

    function setFilter(dimension, value, visible) {
        if (typeof VIS_FILTERS === 'undefined') return;
        const set = VIS_FILTERS[dimension];
        if (!set) return;

        if (visible) {
            set.delete(value); // Remove from filter = show
        } else {
            set.add(value);    // Add to filter = hide
        }
    }

    // =========================================================================
    // HOVER PANEL
    // =========================================================================

    function showHoverPanel(node) {
        const panel = document.getElementById('hover-panel');
        if (!panel || !node) return;

        const setField = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value || '--';
        };

        setField('hover-name', node.name);
        setField('hover-kind', node.kind || node.type || 'unknown');
        setField('hover-atom', node.atom);
        setField('hover-family', node.family || (node.atom ? node.atom.split('.')[0] : null));
        setField('hover-ring', node.ring);
        setField('hover-tier', node.tier);
        setField('hover-role', node.role);

        const fileEl = document.getElementById('hover-file');
        if (fileEl) fileEl.textContent = node.file_path || node.file || '';

        panel.classList.add('visible');
    }

    function hideHoverPanel() {
        const panel = document.getElementById('hover-panel');
        if (panel) panel.classList.remove('visible');
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel(selectedNodes) {
        const panel = document.getElementById('selection-panel');
        const title = document.getElementById('selection-title');
        const list = document.getElementById('selection-list');
        const clearBtn = document.getElementById('selection-clear');

        if (!panel || !list) return;

        if (!selectedNodes || selectedNodes.length === 0) {
            panel.classList.remove('visible');
            return;
        }

        if (title) title.textContent = `SELECTED (${selectedNodes.length})`;

        list.innerHTML = selectedNodes.slice(0, 20).map(n =>
            `<div class="selection-item">${n.name || n.id}</div>`
        ).join('');

        if (selectedNodes.length > 20) {
            list.innerHTML += `<div class="selection-item" style="opacity:0.5">...and ${selectedNodes.length - 20} more</div>`;
        }

        panel.classList.add('visible');

        // Bind clear button
        if (clearBtn) {
            clearBtn.onclick = () => {
                if (typeof SELECT !== 'undefined') {
                    SELECT.clear();
                } else if (typeof clearSelection === 'function') {
                    clearSelection();
                }
                panel.classList.remove('visible');
            };
        }
    }

    // =========================================================================
    // STATS DISPLAY
    // =========================================================================

    function updateStats(nodes, edges, entropy) {
        const nodeEl = document.getElementById('stat-nodes');
        const edgeEl = document.getElementById('stat-edges');
        const entropyEl = document.getElementById('stat-entropy');

        if (nodeEl) nodeEl.textContent = nodes?.toLocaleString() || '0';
        if (edgeEl) edgeEl.textContent = edges?.toLocaleString() || '0';
        if (entropyEl) entropyEl.textContent = entropy?.toFixed(2) || '--';
    }

    // =========================================================================
    // HELPER: SLIDERS
    // =========================================================================

    function _bindSlider(id, callback) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);

        // Handle deprecated value span if it exists (for backward compat)
        const valSpan = document.getElementById(`${id}-val`);

        if (!slider) return;

        // Slider -> Number
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (numberInput) numberInput.value = val;
            if (valSpan) valSpan.textContent = val;
            callback(val);
        });

        // Number -> Slider
        if (numberInput) {
            numberInput.addEventListener('change', () => { // Change triggers on enter/blur
                let val = parseFloat(numberInput.value);

                // Clamp
                if (slider.min) val = Math.max(parseFloat(slider.min), val);
                if (slider.max) val = Math.min(parseFloat(slider.max), val);

                numberInput.value = val;
                slider.value = val;
                if (valSpan) valSpan.textContent = val;
                callback(val);
            });

            // Optional: Live update while typing? Maybe too heavy. Use change for now.
        }
    }

    function _setSliderValue(id, value) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);
        const valSpan = document.getElementById(`${id}-val`);

        if (slider) slider.value = value;
        if (numberInput) numberInput.value = value;
        if (valSpan) valSpan.textContent = value;
    }

    // =========================================================================
    // HELPER: TOGGLES
    // =========================================================================

    function _bindToggle(id, callback) {
        const toggle = document.getElementById(id);
        if (!toggle) return;

        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            callback(isActive);
        });
    }

    // =========================================================================
    // DEBOUNCED REFRESH
    // =========================================================================

    function _scheduleRefresh() {
        clearTimeout(_refreshTimer);
        _refreshTimer = setTimeout(() => {
            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof refreshGraph === 'function') {
                refreshGraph();
            }
        }, 16); // ~1 frame
    }

    // =========================================================================
    // SECTION RESIZING - Vertical drag handles
    // =========================================================================

    const SECTION_HEIGHT_KEY = 'viz_section_heights';
    let _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };

    function initSectionResize() {
        // Add resize handles to each section
        document.querySelectorAll('.section-content').forEach(content => {
            const sectionId = content.id;
            if (!sectionId) return;

            // Make content resizable
            content.classList.add('resizable');

            // Create resize handle
            const handle = document.createElement('div');
            handle.className = 'section-resize-handle';
            handle.dataset.section = sectionId;

            // Insert after section-content (before next section)
            const section = content.closest('.section');
            if (section && section.nextElementSibling) {
                section.parentNode.insertBefore(handle, section.nextElementSibling);
            }

            // Bind drag events
            handle.addEventListener('mousedown', _startResize);
        });

        // Global mouse events
        document.addEventListener('mousemove', _onResize);
        document.addEventListener('mouseup', _endResize);

        // Restore saved heights
        _restoreSectionHeights();

        console.log('[SIDEBAR] Section resize initialized');
    }

    function _startResize(e) {
        const sectionId = e.target.dataset.section;
        const content = document.getElementById(sectionId);
        if (!content) return;

        _resizeState = {
            active: true,
            section: content,
            startY: e.clientY,
            startHeight: content.offsetHeight
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }

    function _onResize(e) {
        if (!_resizeState.active || !_resizeState.section) return;

        const delta = e.clientY - _resizeState.startY;
        const newHeight = Math.max(60, Math.min(400, _resizeState.startHeight + delta));

        _resizeState.section.style.maxHeight = newHeight + 'px';
    }

    function _endResize() {
        if (!_resizeState.active) return;

        // Save height
        if (_resizeState.section) {
            _saveSectionHeight(_resizeState.section.id, _resizeState.section.style.maxHeight);
        }

        // Cleanup
        document.querySelectorAll('.section-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };
    }

    function _saveSectionHeight(sectionId, height) {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            heights[sectionId] = height;
            localStorage.setItem(SECTION_HEIGHT_KEY, JSON.stringify(heights));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save section height:', e);
        }
    }

    function _restoreSectionHeights() {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            Object.entries(heights).forEach(([sectionId, height]) => {
                const content = document.getElementById(sectionId);
                if (content && height) {
                    content.style.maxHeight = height;
                }
            });
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore section heights:', e);
        }
    }

    // =========================================================================
    // SIDEBAR RESIZING - Horizontal drag handles
    // =========================================================================

    const SIDEBAR_WIDTH_KEY = 'viz_sidebar_widths';
    let _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };

    function initSidebarResize() {
        const leftHandle = document.getElementById('left-resize-handle');
        const rightHandle = document.getElementById('right-resize-handle');

        if (leftHandle) {
            leftHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'left'));
        }
        if (rightHandle) {
            rightHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'right'));
        }

        // Global mouse events
        document.addEventListener('mousemove', _onSidebarResize);
        document.addEventListener('mouseup', _endSidebarResize);

        // Restore saved widths
        _restoreSidebarWidths();

        console.log('[SIDEBAR] Sidebar resize initialized');
    }

    function _startSidebarResize(e, side) {
        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        const currentWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(cssVar)) || 280;

        _sidebarResizeState = {
            active: true,
            side: side,
            startX: e.clientX,
            startWidth: currentWidth
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        e.preventDefault();
    }

    function _onSidebarResize(e) {
        if (!_sidebarResizeState.active) return;

        const { side, startX, startWidth } = _sidebarResizeState;
        const delta = side === 'left' ? (e.clientX - startX) : (startX - e.clientX);
        const minWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-sidebar-width')) || 200;
        const maxWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-sidebar-width')) || 400;
        const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + delta));

        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        document.documentElement.style.setProperty(cssVar, newWidth + 'px');

        // Update handle position
        const handle = document.getElementById(`${side}-resize-handle`);
        if (handle) {
            if (side === 'left') {
                handle.style.left = (newWidth - 3) + 'px';
            } else {
                handle.style.right = (newWidth - 3) + 'px';
            }
        }
    }

    function _endSidebarResize() {
        if (!_sidebarResizeState.active) return;

        // Save widths
        _saveSidebarWidths();

        // Cleanup
        document.querySelectorAll('.sidebar-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };
    }

    function _saveSidebarWidths() {
        try {
            const left = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width');
            const right = getComputedStyle(document.documentElement).getPropertyValue('--right-panel-width');
            localStorage.setItem(SIDEBAR_WIDTH_KEY, JSON.stringify({ left, right }));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save sidebar widths:', e);
        }
    }

    function _restoreSidebarWidths() {
        try {
            const widths = JSON.parse(localStorage.getItem(SIDEBAR_WIDTH_KEY) || '{}');
            if (widths.left) {
                document.documentElement.style.setProperty('--sidebar-width', widths.left);
                const leftHandle = document.getElementById('left-resize-handle');
                if (leftHandle) leftHandle.style.left = `calc(${widths.left} - 3px)`;
            }
            if (widths.right) {
                document.documentElement.style.setProperty('--right-panel-width', widths.right);
                const rightHandle = document.getElementById('right-resize-handle');
                if (rightHandle) rightHandle.style.right = `calc(${widths.right} - 3px)`;
            }
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore sidebar widths:', e);
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Initialization
        init,
        initSectionResize,
        initSidebarResize,

        // Color modes
        setColorMode,

        // Color Schemes (33 named gradients)
        applyColorScheme,
        clearColorScheme,
        renderSchemeNavigator,
        initSchemeNavigator,
        SCHEME_CONFIG,

        // Layouts
        setLayout,

        // Physics
        setPhysicsPreset,
        PHYSICS_PRESETS,

        // Filters
        populateFilterChips,
        setFilter,
        renderSmartSidebar, // Export for debug/manual re-render

        // Panels
        showHoverPanel,
        hideHoverPanel,
        updateSelectionPanel,

        // Stats
        updateStats,

        // View Mode (ATOMS/FILES toggle)
        initViewModeToggle,
        setViewMode,
        getViewMode,
        applyDeferredViewMode
    };
})();

// Backward compatibility - SidebarManager class is defined in app.js, not duplicated here
// The SIDEBAR module provides all functionality via SIDEBAR.* calls


// ═══ MODULE: modules/edge-system.js ═══
/**
 * EDGE SYSTEM MODULE
 *
 * Manages edge coloring, width, modes, and gradient effects.
 * Includes gradient palettes for tier, file, flow, depth, and semantic modes.
 *
 * Depends on: COLOR (for type-based colors), NODE (for tier lookups)
 *
 * Usage:
 *   EDGE.getColor(link)           // Get color for a link
 *   EDGE.getWidth(link)           // Get width for a link
 *   EDGE.setMode('gradient-tier') // Change edge mode
 *   EDGE.apply()                  // Apply current mode to graph
 */

const EDGE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODE_ORDER = [
        'gradient-tier',      // Source→Target tier flow (architecture layers)
        'gradient-file',      // File boundaries (module regions)
        'gradient-flow',      // Markov probability (hot paths)
        'gradient-depth',     // Call depth progression
        'gradient-semantic',  // Semantic distance (type similarity)
        'type',               // Classic type-based
        'weight',             // Weight intensity
        'mono'                // Minimal monochrome
    ];

    const MODE_LABELS = {
        'gradient-tier': '▼ TIER FLOW',
        'gradient-file': '▼ FILE REGIONS',
        'gradient-flow': '▼ HOT PATHS',
        'gradient-depth': '▼ CALL DEPTH',
        'gradient-semantic': '▼ SEMANTIC',
        type: 'EDGE: TYPE',
        weight: 'EDGE: WEIGHT',
        mono: 'EDGE: MONO'
    };

    const MODE_HINTS = {
        'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
        'gradient-file': 'Color by file region - shows module boundaries',
        'gradient-flow': 'Hot paths - markov probability gradient',
        'gradient-depth': 'Color by call chain depth',
        'gradient-semantic': 'Color by semantic similarity of endpoints',
        type: 'Edge color by type (calls, imports, etc.)',
        weight: 'Edge width & color by weight',
        mono: 'Minimal monochrome'
    };

    // Gradient color palettes for different modes
    const PALETTES = {
        tier: {
            // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
            T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
            T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
            T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
            UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
        },
        file: {
            // Rainbow hues distributed across files
            saturation: 65,
            lightness: 48
        },
        flow: {
            // Cold (low prob) to Hot (high prob)
            cold: { h: 220, s: 60, l: 45 },   // Blue
            warm: { h: 45, s: 85, l: 50 },    // Yellow
            hot: { h: 0, s: 90, l: 55 }       // Red
        },
        depth: {
            // Shallow (bright) to Deep (dark, saturated)
            shallow: { h: 180, s: 50, l: 65 },  // Light cyan
            mid: { h: 260, s: 70, l: 50 },      // Purple
            deep: { h: 320, s: 80, l: 40 }      // Magenta
        },
        semantic: {
            // Similar (harmonious) to Different (contrasting)
            similar: { h: 150, s: 60, l: 50 },    // Green - same type
            related: { h: 200, s: 65, l: 48 },    // Cyan - related
            different: { h: 340, s: 75, l: 50 }   // Pink - different
        }
    };

    const DEFAULT_OPACITY = 0.08;
    const MIN_WIDTH = 0.6;
    const MAX_WIDTH = 2.2;
    const BASE_WIDTH = 1.0;

    // =========================================================================
    // STATE
    // =========================================================================

    let _mode = 'gradient-file';  // Default mode
    let _ranges = { weight: { min: 1, max: 1 }, confidence: { min: 1, max: 1 } };
    let _nodeFileIndex = new Map();
    let _fileHueMap = new Map();
    let _config = {
        opacity: DEFAULT_OPACITY,
        dim: { interfile_factor: 0.25 }
    };

    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================

    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function interpolateHSL(hsl1, hsl2, t) {
        t = clamp01(t);
        // Handle hue interpolation (shortest path on color wheel)
        let h1 = hsl1.h, h2 = hsl2.h;
        let dh = h2 - h1;
        if (Math.abs(dh) > 180) {
            if (dh > 0) h1 += 360;
            else h2 += 360;
        }
        const h = (h1 + (h2 - h1) * t) % 360;
        const s = hsl1.s + (hsl2.s - hsl1.s) * t;
        const l = hsl1.l + (hsl2.l - hsl1.l) * t;
        return hslColor(h, s, l);
    }

    function normalizeMetric(value, range) {
        // If range is degenerate (all same values), return based on absolute value
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }
        return clamp01((value - range.min) / (range.max - range.min));
    }

    // =========================================================================
    // NODE HELPERS (use canonical versions from node-helpers.js via window.*)
    // =========================================================================

    function getLinkFileIdx(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.fileIdx ?? -1;
        }
        if (endpoint) {
            return _nodeFileIndex.get(endpoint) ?? -1;
        }
        return -1;
    }

    // =========================================================================
    // FILE HUE MAP
    // =========================================================================

    function buildFileHueMap() {
        _fileHueMap.clear();
        // Try DATA module first, then DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
                   (typeof DM !== 'undefined' ? DM : null);
        if (!dm || !dm.getFileBoundaries) return;

        const files = dm.getFileBoundaries();
        const goldenAngle = 137.508;  // Golden angle for good distribution
        files.forEach((file, idx) => {
            const hue = (idx * goldenAngle) % 360;
            _fileHueMap.set(idx, hue);
        });
    }

    // =========================================================================
    // RANGE UPDATES
    // =========================================================================

    function updateRanges() {
        const links = (typeof Graph !== 'undefined' && Graph?.graphData()?.links) || [];
        let minWeight = Infinity, maxWeight = -Infinity;
        let minConf = Infinity, maxConf = -Infinity;

        links.forEach(link => {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            minWeight = Math.min(minWeight, weight);
            maxWeight = Math.max(maxWeight, weight);
            minConf = Math.min(minConf, confidence);
            maxConf = Math.max(maxConf, confidence);
        });

        _ranges = {
            weight: {
                min: isFinite(minWeight) ? minWeight : 1,
                max: isFinite(maxWeight) ? maxWeight : 1
            },
            confidence: {
                min: isFinite(minConf) ? minConf : 1,
                max: isFinite(maxConf) ? maxConf : 1
            }
        };
    }

    function refreshNodeFileIndex() {
        _nodeFileIndex.clear();
        const nodes = (typeof Graph !== 'undefined' && Graph?.graphData()?.nodes) || [];
        nodes.forEach(node => {
            if (node && node.id) {
                _nodeFileIndex.set(node.id, node.fileIdx ?? -1);
            }
        });
    }

    // =========================================================================
    // GRADIENT EDGE COLOR
    // =========================================================================

    function getGradientColor(link, mode) {
        const srcNode = typeof link.source === 'object' ? link.source :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.source) : null);
        const tgtNode = typeof link.target === 'object' ? link.target :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.target) : null);

        if (mode === 'gradient-tier') {
            const srcTier = window.getNodeTierValue(srcNode);
            const tgtTier = window.getNodeTierValue(tgtNode);
            const avgTier = (srcTier + tgtTier) / 2;

            const palette = PALETTES.tier;
            let color;
            if (avgTier < 0.5) {
                color = interpolateHSL(palette.T0, palette.T1, avgTier * 2);
            } else if (avgTier < 1.5) {
                color = interpolateHSL(palette.T0, palette.T1, (avgTier - 0.5));
            } else {
                color = interpolateHSL(palette.T1, palette.T2, (avgTier - 1) / 2);
            }

            // Highlight tier transitions (edges crossing tiers)
            if (srcTier !== tgtTier) {
                return hslColor(
                    parseInt(color.slice(4)),
                    75,  // Higher saturation
                    55   // Brighter
                );
            }
            return color;
        }

        if (mode === 'gradient-file') {
            const srcFile = srcNode?.fileIdx ?? -1;
            const tgtFile = tgtNode?.fileIdx ?? -1;
            const palette = PALETTES.file;

            if (srcFile === tgtFile && srcFile >= 0) {
                const hue = _fileHueMap.get(srcFile) ?? (srcFile * 37 % 360);
                return hslColor(hue, palette.saturation, palette.lightness);
            } else {
                const srcHue = _fileHueMap.get(srcFile) ?? 0;
                const tgtHue = _fileHueMap.get(tgtFile) ?? 180;
                let midHue = (srcHue + tgtHue) / 2;
                if (Math.abs(srcHue - tgtHue) > 180) {
                    midHue = (midHue + 180) % 360;
                }
                return hslColor(midHue, palette.saturation * 0.6, palette.lightness * 1.1);
            }
        }

        if (mode === 'gradient-flow') {
            const mw = link.markov_weight ?? link.weight ?? 0;
            const palette = PALETTES.flow;

            if (mw < 0.3) {
                return interpolateHSL(palette.cold, palette.warm, mw / 0.3);
            } else if (mw < 0.7) {
                return interpolateHSL(palette.warm, palette.hot, (mw - 0.3) / 0.4);
            } else {
                return hslColor(palette.hot.h, palette.hot.s + 10, palette.hot.l + 10);
            }
        }

        if (mode === 'gradient-depth') {
            const srcDepth = window.getNodeDepth(srcNode);
            const tgtDepth = window.getNodeDepth(tgtNode);
            const avgDepth = (srcDepth + tgtDepth) / 2;
            const palette = PALETTES.depth;

            if (avgDepth < 0.33) {
                return interpolateHSL(palette.shallow, palette.mid, avgDepth * 3);
            } else if (avgDepth < 0.66) {
                return interpolateHSL(palette.mid, palette.deep, (avgDepth - 0.33) * 3);
            } else {
                return hslColor(palette.deep.h, palette.deep.s, palette.deep.l - 10);
            }
        }

        if (mode === 'gradient-semantic') {
            const similarity = window.getSemanticSimilarity(srcNode, tgtNode);
            const palette = PALETTES.semantic;

            if (similarity > 0.7) {
                return interpolateHSL(palette.related, palette.similar, (similarity - 0.7) / 0.3);
            } else if (similarity > 0.3) {
                return interpolateHSL(palette.different, palette.related, (similarity - 0.3) / 0.4);
            } else {
                return hslColor(palette.different.h, palette.different.s + 10, palette.different.l);
            }
        }

        return '#444444';
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(link) {
        // Gradient modes
        if (_mode.startsWith('gradient-')) {
            return getGradientColor(link, _mode);
        }

        const edgeKey = String(link.edge_type || link.type || 'unknown').toLowerCase();

        if (_mode === 'type') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', edgeKey) : '#666666';
        }

        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const t = normalizeMetric(weight, _ranges.weight);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('weight', t) : hslColor(30, 70, 50 + t * 30);
        }

        if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            const t = normalizeMetric(confidence, _ranges.confidence);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('confidence', t) : hslColor(200, 70, 50 + t * 30);
        }

        if (_mode === 'mono') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', 'unknown') : '#555555';
        }

        // Default: type-based coloring
        return typeof COLOR !== 'undefined' ?
            COLOR.get('edgeType', edgeKey) : '#666666';
    }

    // =========================================================================
    // EDGE WIDTH
    // =========================================================================

    function getWidth(link) {
        // For most modes, return uniform width for visual consistency
        if (_mode !== 'weight' && _mode !== 'confidence') {
            return BASE_WIDTH;
        }

        // Weight/confidence modes: subtle variation within tight bounds
        let t = 0.5;
        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            t = normalizeMetric(weight, _ranges.weight);
        } else if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            t = normalizeMetric(confidence, _ranges.confidence);
        }

        return MIN_WIDTH + (t * (MAX_WIDTH - MIN_WIDTH));
    }

    // =========================================================================
    // APPLY MODE TO GRAPH
    // =========================================================================

    function apply() {
        updateRanges();
        refreshNodeFileIndex();
        buildFileHueMap();

        if (typeof Graph === 'undefined' || !Graph) return;

        Graph.linkColor(link => {
            const color = getColor(link);
            return typeof toColorNumber === 'function' ?
                toColorNumber(color, 0x222222) : color;
        });

        Graph.linkOpacity(link => {
            const overrideOpacity = (typeof APPEARANCE_STATE !== 'undefined' &&
                typeof APPEARANCE_STATE.edgeOpacity === 'number')
                ? APPEARANCE_STATE.edgeOpacity
                : null;
            const baseOpacity = (overrideOpacity !== null)
                ? overrideOpacity
                : (link.opacity ?? DEFAULT_OPACITY);

            // File mode dimming
            const fileMode = typeof window !== 'undefined' && window.fileMode;
            const graphMode = typeof GRAPH_MODE !== 'undefined' ? GRAPH_MODE : 'atoms';
            if (fileMode && graphMode === 'atoms') {
                const srcIdx = getLinkFileIdx(link, 'source');
                const tgtIdx = getLinkFileIdx(link, 'target');
                if (srcIdx >= 0 && tgtIdx >= 0 && srcIdx !== tgtIdx) {
                    const dimFactor = _config.dim?.interfile_factor ?? 0.25;
                    return baseOpacity * dimFactor;
                }
            }
            return baseOpacity;
        });

        // Don't override width in flow mode
        const flowMode = typeof window !== 'undefined' && window.flowMode;
        if (!flowMode) {
            Graph.linkWidth(link => {
                const baseWidth = getWidth(link);
                // Respect APPEARANCE_STATE.edgeWidth multiplier if set
                const widthMultiplier = (typeof APPEARANCE_STATE !== 'undefined' &&
                    typeof APPEARANCE_STATE.edgeWidth === 'number')
                    ? APPEARANCE_STATE.edgeWidth
                    : 1;
                return Math.max(0.5, baseWidth * widthMultiplier);
            });
        }
    }

    // =========================================================================
    // MODE MANAGEMENT
    // =========================================================================

    function setMode(mode) {
        if (!MODE_ORDER.includes(mode)) return;
        _mode = mode;

        const button = document.getElementById('btn-edge-mode');
        if (button) {
            button.textContent = MODE_LABELS[_mode] || 'EDGE';
        }

        apply();

        // Update legend to reflect edge mode colors
        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        // Show mode toast hint
        if (typeof showModeToast === 'function') {
            showModeToast(MODE_HINTS[mode] || `Edge mode: ${mode}`);
        }
    }

    function cycleMode() {
        const currentIndex = MODE_ORDER.indexOf(_mode);
        const nextIndex = (currentIndex + 1) % MODE_ORDER.length;
        setMode(MODE_ORDER[nextIndex]);
    }

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getWidth,
        apply,

        // Mode management
        setMode,
        cycleMode,
        get mode() { return _mode; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Constants
        MODE_ORDER,
        MODE_LABELS,
        MODE_HINTS,
        PALETTES,

        // Internal access (for migration)
        get ranges() { return _ranges; },
        get nodeFileIndex() { return _nodeFileIndex; },
        get fileHueMap() { return _fileHueMap; },

        // Utility exports
        buildFileHueMap,
        updateRanges,
        refreshNodeFileIndex
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// These create getters/setters that sync with EDGE module state
Object.defineProperty(window, 'EDGE_MODE', {
    get: () => EDGE.mode,
    set: (v) => EDGE.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'EDGE_RANGES', {
    get: () => EDGE.ranges,
    configurable: true
});
Object.defineProperty(window, 'NODE_FILE_INDEX', {
    get: () => EDGE.nodeFileIndex,
    configurable: true
});
Object.defineProperty(window, 'FILE_HUE_MAP', {
    get: () => EDGE.fileHueMap,
    configurable: true
});
// Static constants - app.js owns these, not duplicated here
// EDGE_MODE_ORDER, EDGE_MODE_LABELS, EDGE_MODE_HINTS, GRADIENT_PALETTES - defined in app.js

function getEdgeColor(link) { return EDGE.getColor(link); }
function getEdgeWidth(link) { return EDGE.getWidth(link); }
function applyEdgeMode() { EDGE.apply(); }
function setEdgeMode(mode) { EDGE.setMode(mode); }
function cycleEdgeMode() { EDGE.cycleMode(); }
function updateEdgeRanges() { EDGE.updateRanges(); }
function refreshNodeFileIndex() { EDGE.refreshNodeFileIndex(); }
function buildFileHueMap() { EDGE.buildFileHueMap(); }
function getGradientEdgeColor(link, mode) { return EDGE.getColor(link); }


// ═══ MODULE: modules/file-viz.js ═══
/**
 * FILE VIZ MODULE
 *
 * Manages file visualization modes: color, hulls, cluster, map, spheres.
 * Handles file coloring, boundaries, mode switching, and FILE GRAPH.
 *
 * FILE GRAPH: Shows repository structure as first-class nodes where each
 * file becomes a hoverable, selectable node. This provides:
 * - Clear view of the repository file system
 * - Hover to see file details (atom count, path, metrics)
 * - Click to expand and see atoms within
 * - Edge weights show inter-file dependencies
 *
 * Depends on: DATA (for file boundaries), COLOR (for transforms)
 *
 * Pattern: IIFE with State Unification (see docs/specs/VISUALIZATION_UI_SPEC.md)
 *
 * Usage:
 *   FILE_VIZ.setMode('map')          // Switch to file-nodes view
 *   FILE_VIZ.toggle()                // Toggle file mode on/off
 *   FILE_VIZ.getColor(idx, total)    // Get color for a file
 *   FILE_VIZ.buildFileGraph()        // Build file-level graph
 *   FILE_VIZ.apply()                 // Apply current mode
 */

const FILE_VIZ = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODES = ['color', 'hulls', 'cluster', 'map', 'spheres'];

    const MODE_HINTS = {
        color: 'Files colored by hue - each file gets unique color',
        hulls: 'Boundary hulls around file clusters',
        cluster: 'Force clustering groups files together',
        map: 'FILE NODES view - see repository structure as nodes! Click to expand.',
        spheres: 'Containment spheres with collision physics'
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _enabled = false;
    let _mode = 'color';
    let _config = {
        strategy: 'golden-angle',
        angle: 137.5,
        chroma: null,
        saturation: 70,
        lightness: 50
    };
    let _boundaryMeshes = [];
    let _hullRedrawTimer = null;
    let _hullRedrawAttempts = 0;

    // FILE GRAPH STATE - for file-as-nodes visualization
    let _fileGraph = null;          // { nodes: [], links: [] } for file-level view
    let _fileNodeIds = new Map();   // fileIdx -> nodeId mapping
    let _fileNodePositions = new Map(); // Preserve positions across mode switches
    let _expandedFiles = new Set(); // Files expanded to show atoms
    let _graphMode = 'atoms';       // atoms | files | hybrid
    let _expandMode = 'inline';     // inline | detach
    let _activeMapping = 'format';  // Current visual mapping mode

    // =========================================================================
    // VISUAL MAPPING SYSTEM - Map metadata to visual properties
    // =========================================================================

    /**
     * Visual dimension mappings - connect file metadata to visual properties.
     * Each mapping defines: source metadata field → visual property + scale
     */
    const VISUAL_MAPPINGS = {
        // Size-based mappings
        size_bytes: {
            property: 'nodeSize',
            scale: 'sqrt',
            min: 2,
            max: 20,
            label: 'File Size (bytes)'
        },
        token_estimate: {
            property: 'nodeSize',
            scale: 'log',
            min: 2,
            max: 18,
            label: 'Token Count'
        },
        line_count: {
            property: 'nodeSize',
            scale: 'sqrt',
            min: 2,
            max: 15,
            label: 'Line Count'
        },

        // Time-based mappings
        age_days: {
            property: 'opacity',
            scale: 'linear',
            invert: true,  // Older = more faded
            min: 0.3,
            max: 1.0,
            label: 'File Age'
        },

        // Categorical mappings (discrete colors)
        format_category: {
            property: 'hue',
            discrete: true,
            values: {
                code:   210,  // Blue - primary code
                config: 45,   // Orange - configuration
                doc:    120,  // Green - documentation
                data:   280,  // Purple - data files
                test:   340,  // Pink - test files
                style:  180,  // Cyan - stylesheets
                script: 30,   // Yellow-Orange - scripts
                build:  0,    // Red - build files
                other:  0     // Gray (handled by saturation)
            },
            label: 'File Format'
        },
        purpose: {
            property: 'hue',
            discrete: true,
            values: {
                test:       340,  // Pink
                config:     45,   // Orange
                model:      260,  // Purple
                service:    210,  // Blue
                controller: 180,  // Cyan
                utility:    90,   // Yellow-Green
                interface:  300,  // Magenta
                data:       30,   // Orange-Yellow
                general:    200   // Light Blue
            },
            label: 'File Purpose'
        },

        // Complexity mappings
        complexity_density: {
            property: 'saturation',
            scale: 'linear',
            min: 30,
            max: 90,
            label: 'Complexity'
        },
        cohesion: {
            property: 'lightness',
            scale: 'linear',
            min: 35,
            max: 65,
            label: 'Cohesion'
        },

        // Git mappings (if available)
        git_commits: {
            property: 'pulse',  // Animation intensity
            scale: 'log',
            min: 0,
            max: 1,
            label: 'Git Commits'
        }
    };

    /**
     * Apply a visual mapping to file nodes.
     * @param {string} mappingKey - Key from VISUAL_MAPPINGS
     * @param {Array} fileNodes - Array of file node objects
     */
    function applyVisualMapping(mappingKey, fileNodes) {
        const mapping = VISUAL_MAPPINGS[mappingKey];
        if (!mapping) {
            console.warn(`[FILE_VIZ] Unknown mapping: ${mappingKey}`);
            return;
        }

        _activeMapping = mappingKey;

        // Get data range for normalization
        const values = fileNodes.map(n => n[mappingKey]).filter(v => v !== undefined && v !== null);
        if (values.length === 0) {
            console.warn(`[FILE_VIZ] No data for mapping: ${mappingKey}`);
            return;
        }

        const dataMin = Math.min(...values);
        const dataMax = Math.max(...values);

        fileNodes.forEach(node => {
            const rawValue = node[mappingKey];
            if (rawValue === undefined || rawValue === null) return;

            if (mapping.discrete) {
                // Categorical mapping
                const discreteValue = mapping.values[rawValue] ?? mapping.values['other'] ?? 0;
                _applyVisualProperty(node, mapping.property, discreteValue);
            } else {
                // Continuous mapping
                let normalized = _normalizeValue(rawValue, dataMin, dataMax, mapping.scale);
                if (mapping.invert) normalized = 1 - normalized;

                const visualMin = mapping.min ?? 0;
                const visualMax = mapping.max ?? 1;
                const visualValue = visualMin + normalized * (visualMax - visualMin);

                _applyVisualProperty(node, mapping.property, visualValue);
            }
        });

        console.log(`[FILE_VIZ] Applied mapping: ${mappingKey} (${mapping.label})`);
    }

    function _normalizeValue(value, min, max, scale) {
        if (max === min) return 0.5;

        let normalized;
        switch (scale) {
            case 'log':
                const logMin = Math.log10(Math.max(1, min));
                const logMax = Math.log10(Math.max(1, max));
                const logVal = Math.log10(Math.max(1, value));
                normalized = (logVal - logMin) / (logMax - logMin);
                break;
            case 'sqrt':
                const sqrtMin = Math.sqrt(min);
                const sqrtMax = Math.sqrt(max);
                const sqrtVal = Math.sqrt(value);
                normalized = (sqrtVal - sqrtMin) / (sqrtMax - sqrtMin);
                break;
            default: // linear
                normalized = (value - min) / (max - min);
        }
        return Math.max(0, Math.min(1, normalized));
    }

    function _applyVisualProperty(node, property, value) {
        switch (property) {
            case 'nodeSize':
                node.val = value;
                break;
            case 'hue':
                // Rebuild color with new hue
                const sat = _config.saturation ?? 70;
                const light = _config.lightness ?? 50;
                node.color = hslColor(value, sat, light);
                break;
            case 'saturation':
                // Would need to parse existing color - simplified approach
                node._saturation = value;
                break;
            case 'lightness':
                node._lightness = value;
                break;
            case 'opacity':
                node._opacity = value;
                break;
            case 'pulse':
                node._pulseIntensity = value;
                break;
        }
    }

    /**
     * Get color for file based on active mapping or default
     */
    function getColorForMapping(node) {
        const mapping = VISUAL_MAPPINGS[_activeMapping];
        if (!mapping || mapping.property !== 'hue') {
            // Use default golden angle coloring
            return getColor(node.fileIdx, 100, node.file_name);
        }

        const rawValue = node[_activeMapping];
        if (rawValue === undefined || !mapping.discrete) {
            return getColor(node.fileIdx, 100, node.file_name);
        }

        const hue = mapping.values[rawValue] ?? 200;
        const sat = node._saturation ?? (_config.saturation ?? 70);
        const light = node._lightness ?? (_config.lightness ?? 50);
        return hslColor(hue, sat, light);
    }

    // =========================================================================
    // COLOR UTILITIES
    // =========================================================================

    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function hashToUnit(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash;
        }
        return Math.abs(hash % 1000) / 1000;
    }

    function getHue(fileIdx, totalFiles, fileName) {
        const strategy = _config.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return hashToUnit(seed) * 360;
        }
        const angle = _config.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const saturation = _config.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (_config.lightness ?? 50);
        const hue = getHue(fileIdx, totalFiles, fileName);

        // Apply color tweaks if available
        const tweaks = typeof COLOR_TWEAKS !== 'undefined' ? COLOR_TWEAKS : {};

        if (typeof _config.chroma === 'number' && typeof oklchColor === 'function') {
            return oklchColor(lightness, _config.chroma, hue);
        }

        const adjustedHue = hue + (tweaks.hueShift || 0);
        const adjustedLightness = clampValue(lightness + (tweaks.lightnessShift || 0), 0, 100);
        return hslColor(adjustedHue, saturation, adjustedLightness);
    }

    // =========================================================================
    // APPLY COLORS TO NODES
    // =========================================================================

    function applyColors(graphNodes) {
        // Get file boundaries from DATA module or DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
                   (typeof DM !== 'undefined' ? DM : null);
        const boundaries = dm?.getFileBoundaries ? dm.getFileBoundaries() : [];
        const totalFiles = boundaries.length;

        graphNodes.forEach(node => {
            if (node.fileIdx >= 0) {
                const fileInfo = boundaries[node.fileIdx] || {};
                const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                node.color = getColor(node.fileIdx, totalFiles, fileLabel);
            }
        });

        if (typeof Graph !== 'undefined' && Graph) {
            Graph.nodeColor(n => {
                return typeof toColorNumber === 'function' ?
                    toColorNumber(n.color, 0x888888) : n.color;
            });
        }
    }

    // =========================================================================
    // FILE GRAPH BUILDING - Repository as Nodes
    // =========================================================================

    /**
     * Build a file-level graph where each file is a node.
     * This creates a clear view of repository structure with:
     * - File nodes sized by atom count
     * - Edges weighted by inter-file dependencies
     * - Colors by file index (golden angle distribution)
     */
    function buildFileGraph() {
        const dm = typeof DATA !== 'undefined' ? DATA :
                   (typeof DM !== 'undefined' ? DM : null);
        const boundaries = dm?.getFileBoundaries ? dm.getFileBoundaries() : [];
        const nodes = dm?.getNodes ? dm.getNodes() : [];
        const links = dm?.getLinks ? dm.getLinks() : [];

        // Get current atom positions from Graph for centroid calculation
        const currentGraphNodes = (typeof Graph !== 'undefined' && Graph)
            ? (Graph.graphData()?.nodes || [])
            : [];
        const atomPositions = new Map();
        currentGraphNodes.forEach(n => {
            if (n && n.id && Number.isFinite(n.x) && Number.isFinite(n.y)) {
                atomPositions.set(n.id, { x: n.x, y: n.y, z: n.z || 0 });
            }
        });

        const totalFiles = boundaries.length;
        const fileNodes = [];
        _fileNodeIds.clear();
        const nodeFileIdx = new Map();

        // Build node -> fileIdx mapping
        nodes.forEach(n => {
            if (n && n.id) {
                nodeFileIdx.set(n.id, n.fileIdx ?? -1);
            }
        });

        // Build file -> atoms mapping for centroid calculation
        const fileAtoms = new Map(); // fileIdx -> [atom positions]
        nodes.forEach(n => {
            if (n && n.id && n.fileIdx !== undefined && n.fileIdx >= 0) {
                const pos = atomPositions.get(n.id);
                if (pos) {
                    if (!fileAtoms.has(n.fileIdx)) fileAtoms.set(n.fileIdx, []);
                    fileAtoms.get(n.fileIdx).push(pos);
                }
            }
        });

        // Create file nodes with centroid positions
        boundaries.forEach((boundary, idx) => {
            const label = boundary.file_name || boundary.file || `file-${idx}`;
            const atomCount = boundary.atom_count || 1;
            const nodeId = `file:${idx}`;
            _fileNodeIds.set(idx, nodeId);

            // Calculate centroid from atom positions (SMOOTH TRANSITION)
            const atoms = fileAtoms.get(idx) || [];
            let cx = 0, cy = 0, cz = 0;
            if (atoms.length > 0) {
                atoms.forEach(p => { cx += p.x; cy += p.y; cz += p.z; });
                cx /= atoms.length;
                cy /= atoms.length;
                cz /= atoms.length;
            } else {
                // Fallback: radial layout for files with no positioned atoms
                const angle = (idx / totalFiles) * Math.PI * 2;
                const radius = 200;
                cx = Math.cos(angle) * radius;
                cy = Math.sin(angle) * radius;
                cz = (Math.random() - 0.5) * 50;
            }

            fileNodes.push({
                id: nodeId,
                name: label,
                fileIdx: idx,
                isFileNode: true,
                // POSITION: Initialize at centroid of atoms for smooth transition
                x: cx, y: cy, z: cz,
                fx: undefined, fy: undefined, fz: undefined, // Allow physics to relax
                val: Math.max(2, Math.sqrt(atomCount) * 1.5), // Size by atom count
                color: getColor(idx, totalFiles, label),
                file_path: boundary.file || '',
                atom_count: atomCount,
                // Enriched file metadata for hover panel and visual mappings
                tier: boundary.tier || 'UNKNOWN',
                ring: boundary.ring || 'UNKNOWN',
                internal_edges: boundary.internal_edges || 0,
                external_edges: boundary.external_edges || 0,
                // Physical metadata
                size_bytes: boundary.size_bytes ?? 0,
                size_kb: boundary.size_kb ?? 0,
                token_estimate: boundary.token_estimate ?? 0,
                line_count: boundary.line_count ?? 0,
                code_lines: boundary.code_lines ?? 0,
                // Temporal metadata
                age_days: boundary.age_days ?? 0,
                modified_date: boundary.modified_date || '',
                is_stale: boundary.is_stale ?? false,
                is_recent: boundary.is_recent ?? false,
                // Categorical metadata
                format_category: boundary.format_category || 'other',
                purpose: boundary.purpose || 'general',
                extension: boundary.extension || '',
                is_test: boundary.is_test ?? false,
                is_config: boundary.is_config ?? false,
                // Complexity metadata
                complexity_density: boundary.complexity_density ?? 0,
                cohesion: boundary.cohesion ?? 0.5,
                code_ratio: boundary.code_ratio ?? 0.5
            });
        });

        // Build inter-file edges with weights
        const edgeMap = new Map();
        links.forEach(link => {
            const srcId = _getLinkEndpointId(link, 'source');
            const tgtId = _getLinkEndpointId(link, 'target');
            const srcIdx = nodeFileIdx.get(srcId) ?? -1;
            const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;

            // Skip internal edges and invalid indices
            if (srcIdx < 0 || tgtIdx < 0 || srcIdx === tgtIdx) return;

            const key = `${srcIdx}->${tgtIdx}`;
            const existing = edgeMap.get(key) || {
                source: _fileNodeIds.get(srcIdx),
                target: _fileNodeIds.get(tgtIdx),
                weight: 0,
                edge_type: 'file-dependency',
                resolution: 'file'
            };
            existing.weight += 1;
            edgeMap.set(key, existing);
        });

        _fileGraph = {
            nodes: fileNodes,
            links: Array.from(edgeMap.values())
        };

        console.log(`[FILE_VIZ] Built file graph: ${fileNodes.length} files, ${edgeMap.size} inter-file edges`);
        return _fileGraph;
    }

    function _getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (!endpoint) return null;
        if (typeof endpoint === 'object') return endpoint.id;
        return endpoint;
    }

    /**
     * Save current file node positions for smooth transitions
     */
    function captureFileNodePositions() {
        _fileNodePositions.clear();
        if (typeof Graph === 'undefined' || !Graph) return;

        const nodes = Graph.graphData()?.nodes || [];
        nodes.forEach(node => {
            if (node && node.isFileNode && Number.isFinite(node.x) && Number.isFinite(node.y)) {
                _fileNodePositions.set(node.fileIdx, {
                    x: node.x,
                    y: node.y,
                    z: Number.isFinite(node.z) ? node.z : 0
                });
            }
        });
    }

    /**
     * Restore saved positions to file nodes
     */
    function restoreFileNodePositions(nodes) {
        nodes.forEach(node => {
            if (node.isFileNode && _fileNodePositions.has(node.fileIdx)) {
                const pos = _fileNodePositions.get(node.fileIdx);
                node.x = pos.x;
                node.y = pos.y;
                node.z = pos.z;
            }
        });
    }

    /**
     * Get file target position for radial layout
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpread) {
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: (Math.random() - 0.5) * zSpread
        };
    }

    /**
     * Expand a file to show its atoms
     */
    function expandFile(fileIdx) {
        _expandedFiles.add(fileIdx);
        _graphMode = 'hybrid';
        if (typeof refreshGraph === 'function') refreshGraph();
    }

    /**
     * Collapse a file to hide its atoms
     */
    function collapseFile(fileIdx) {
        _expandedFiles.delete(fileIdx);
        _graphMode = _expandedFiles.size > 0 ? 'hybrid' : 'files';
        if (typeof refreshGraph === 'function') refreshGraph();
    }

    /**
     * Toggle file expansion
     */
    function toggleFileExpansion(fileIdx) {
        if (_expandedFiles.has(fileIdx)) {
            collapseFile(fileIdx);
        } else {
            expandFile(fileIdx);
        }
    }

    /**
     * Apply the file graph to the visualization
     */
    function applyFileGraphMode() {
        if (!_fileGraph) {
            buildFileGraph();
        }
        if (!_fileGraph || typeof Graph === 'undefined' || !Graph) return;

        restoreFileNodePositions(_fileGraph.nodes);
        Graph.graphData(_fileGraph);
        applyColors(_fileGraph.nodes);

        // Reheat simulation for nice spread
        Graph.d3ReheatSimulation();

        if (typeof showToast === 'function') {
            showToast(`File view: ${_fileGraph.nodes.length} files. Click to expand atoms.`);
        }
    }

    // =========================================================================
    // BOUNDARY MANAGEMENT
    // =========================================================================

    function clearBoundaries() {
        if (typeof Graph === 'undefined' || !Graph) return;
        const scene = Graph.scene();
        if (!scene) return;

        _boundaryMeshes.forEach(mesh => scene.remove(mesh));
        _boundaryMeshes = [];
    }

    function scheduleHullRedraw(delayMs = 1200) {
        if (_hullRedrawTimer) {
            clearTimeout(_hullRedrawTimer);
        }
        _hullRedrawTimer = setTimeout(() => {
            if (!(_enabled && _mode === 'hulls')) {
                _hullRedrawAttempts = 0;
                return;
            }

            // Call external drawFileBoundaries if available
            if (typeof drawFileBoundaries === 'function') {
                const drawn = drawFileBoundaries(null);
                if (drawn === 0 && _hullRedrawAttempts < 3) {
                    _hullRedrawAttempts += 1;
                    scheduleHullRedraw(1000);
                }
            }
        }, delayMs);
    }

    // =========================================================================
    // MODE CLEARING
    // =========================================================================

    function clearAllModes() {
        clearBoundaries();

        // Reset file cohesion force if active
        if (typeof clearFileCohesion === 'function') {
            clearFileCohesion();
        }

        // Reset cluster force if active
        if (typeof clusterForceActive !== 'undefined' && clusterForceActive &&
            typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('cluster', null);
            if (typeof DEFAULT_LINK_DISTANCE !== 'undefined' && DEFAULT_LINK_DISTANCE !== null) {
                Graph.d3Force('link').distance(DEFAULT_LINK_DISTANCE);
            }
            Graph.d3ReheatSimulation();
        }

        // Stop containment animation if active
        if (typeof stopContainmentAnimation === 'function') {
            stopContainmentAnimation();
        }

        // Clear containment spheres
        if (typeof FILE_CONTAINMENT !== 'undefined' && FILE_CONTAINMENT?.spheres) {
            const scene = typeof Graph !== 'undefined' ? Graph?.scene() : null;
            if (scene) {
                FILE_CONTAINMENT.spheres.forEach(s => {
                    if (s.mesh) scene.remove(s.mesh);
                });
            }
            FILE_CONTAINMENT.spheres = [];
            FILE_CONTAINMENT.boundariesPopped = false;
        }

        // Clear lingering filters
        if (typeof VIS_FILTERS !== 'undefined') {
            const filterSets = ['rings', 'tiers', 'families', 'files', 'roles', 'edges', 'layers', 'effects', 'edgeFamilies'];
            filterSets.forEach(key => {
                if (VIS_FILTERS[key]?.clear) VIS_FILTERS[key].clear();
            });
            document.querySelectorAll('.filter-chip.active').forEach(c => c.classList.remove('active'));
        }

        // Reset POP button state
        const popBtn = document.getElementById('btn-file-pop');
        if (popBtn) {
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
        }
    }

    // =========================================================================
    // SET FILE MODE STATE
    // =========================================================================

    function setEnabled(enabled) {
        _enabled = enabled;

        // Update UI buttons
        const cmdBtn = document.getElementById('cmd-files');
        if (cmdBtn) cmdBtn.classList.toggle('active', _enabled);
        const dockBtn = document.getElementById('btn-files');
        if (dockBtn) dockBtn.classList.toggle('active', _enabled);

        // Update panels
        const filePanel = document.getElementById('file-panel');
        const modeControls = document.getElementById('file-mode-controls');
        const expandControls = document.getElementById('file-expand-controls');

        if (_enabled) {
            if (filePanel) filePanel.classList.add('visible');
            if (modeControls) modeControls.classList.add('visible');
            if (expandControls) expandControls.classList.toggle('visible', _mode === 'map');
            apply();
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            // Use unified LAYOUT module for reflow
            if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
        } else {
            if (filePanel) filePanel.classList.remove('visible');
            if (modeControls) modeControls.classList.remove('visible');
            if (expandControls) expandControls.classList.remove('visible');

            // Clear expanded files
            if (typeof EXPANDED_FILES !== 'undefined') EXPANDED_FILES.clear();
            if (typeof GRAPH_MODE !== 'undefined') window.GRAPH_MODE = 'atoms';

            // Use unified LAYOUT module for reflow
            if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();

            clearAllModes();
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            if (typeof refreshGraph === 'function') refreshGraph();
        }
    }

    function toggle() {
        setEnabled(!_enabled);
    }

    // =========================================================================
    // SET VIZ MODE
    // =========================================================================

    function setMode(mode) {
        if (!MODES.includes(mode)) return;
        _mode = mode;

        // Update button states
        document.querySelectorAll('.file-mode-btn').forEach(btn => btn.classList.remove('active'));
        const modeBtn = document.getElementById('btn-file-' + mode);
        if (modeBtn) modeBtn.classList.add('active');

        // Toggle expand controls visibility
        const expandControls = document.getElementById('file-expand-controls');
        if (expandControls) expandControls.classList.toggle('visible', _mode === 'map');
        if (_mode === 'map' && typeof updateExpandButtons === 'function') {
            updateExpandButtons();
        }

        // Update graph mode
        if (_mode === 'map') {
            const hasExpanded = typeof EXPANDED_FILES !== 'undefined' && EXPANDED_FILES.size > 0;
            if (typeof GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = hasExpanded ? 'hybrid' : 'files';
            }
        } else {
            if (typeof EXPANDED_FILES !== 'undefined') EXPANDED_FILES.clear();
            if (typeof GRAPH_MODE !== 'undefined') window.GRAPH_MODE = 'atoms';
        }

        // Apply mode
        if (!_enabled) {
            setEnabled(true);
        } else if (_mode === 'map') {
            apply();
        } else {
            if (typeof refreshGraph === 'function') refreshGraph();
        }
    }

    // =========================================================================
    // APPLY CURRENT MODE
    // =========================================================================

    function apply() {
        if (!_enabled) return;

        // Clear previous state
        clearBoundaries();
        if (_mode !== 'hulls') {
            _hullRedrawAttempts = 0;
        }

        // Get graph nodes
        const dm = typeof DATA !== 'undefined' ? DATA :
                   (typeof DM !== 'undefined' ? DM : null);
        const graphNodes = dm?.getVisibleNodes ?
            dm.getVisibleNodes() :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes || [] : []);

        // Apply file cohesion for color/hulls/cluster modes
        if (_mode === 'color' || _mode === 'hulls' || _mode === 'cluster') {
            if (typeof applyFileCohesion === 'function' && dm?.raw) {
                const physicsPayload = { physics: dm.raw.physics, config: dm.raw.config };
                applyFileCohesion(physicsPayload);
            }
        }

        if (_mode === 'color') {
            applyColors(graphNodes);
        }
        else if (_mode === 'hulls') {
            applyColors(graphNodes);
            scheduleHullRedraw(1500);
        }
        else if (_mode === 'cluster') {
            applyColors(graphNodes);
            if (typeof applyClusterForce === 'function' && dm?.raw) {
                applyClusterForce(dm.raw);
            }
        }
        else if (_mode === 'map') {
            const hasExpanded = typeof EXPANDED_FILES !== 'undefined' && EXPANDED_FILES.size > 0;
            if (typeof GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = hasExpanded ? 'hybrid' : 'files';
            }
            if (typeof refreshGraph === 'function') refreshGraph();
            if (typeof showToast === 'function') {
                showToast('File map active. Click a file node to expand.');
            }
        }
        else if (_mode === 'spheres') {
            applyColors(graphNodes);
            if (typeof buildDirectoryTree === 'function' && dm?.raw) {
                buildDirectoryTree(dm.raw);
            }
            if (typeof computeFileActivity === 'function' && dm?.raw) {
                computeFileActivity(dm.raw, graphNodes);
            }
            if (typeof drawContainmentSpheres === 'function' && dm?.raw) {
                drawContainmentSpheres(dm.raw, graphNodes);
            }
            if (typeof startContainmentAnimation === 'function') {
                startContainmentAnimation();
            }
            if (typeof showToast === 'function') {
                showToast('Containment spheres active. Files as force fields. Click POP! to release.');
            }
        }
    }

    // =========================================================================
    // FILE CLUSTERING FORCES - D3 force manipulation for file grouping
    // =========================================================================

    let _clusterForceActive = false;
    let _fileCohesionActive = false;

    /**
     * Apply cluster force to group nodes by file
     * Creates fixed target positions arranged in a circular pattern
     */
    function applyClusterForce(data) {
        const Graph = window.Graph;
        const DM = window.DM;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const IS_3D = window.IS_3D;

        const clusterConfig = data?.physics?.cluster || {};
        const modeStrength = (typeof clusterConfig.modes?.strong === 'number') ? clusterConfig.modes.strong : null;
        const sliderStrength = (typeof APPEARANCE_STATE?.clusterStrength === 'number') ? APPEARANCE_STATE.clusterStrength : null;
        const clusterStrength = (typeof sliderStrength === 'number')
            ? sliderStrength
            : ((typeof modeStrength === 'number')
                ? modeStrength
                : ((typeof clusterConfig.strength === 'number') ? clusterConfig.strength : 0.3));
        const clusterRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius : 150;
        const clusterZSpacing = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing : 30;
        const linkDistance = (typeof clusterConfig.linkDistance === 'number')
            ? clusterConfig.linkDistance
            : (data?.physics?.forces?.link?.distance || 50);

        const graphNodes = DM ? DM.getVisibleNodes() : (Graph?.graphData()?.nodes || []);
        const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
        const numFiles = boundaries.length;

        // Fixed target positions: arrange files in circular pattern
        const fileTargets = {};
        for (let i = 0; i < numFiles; i++) {
            fileTargets[i] = getFileTarget(i, numFiles, clusterRadius, clusterZSpacing);
        }

        // Reduce link distance to keep intra-file nodes tighter
        Graph.d3Force('link').distance(linkDistance);

        // Apply strong clustering force toward fixed targets
        Graph.d3Force('cluster', (alpha) => {
            const k = alpha * clusterStrength;
            graphNodes.forEach(node => {
                const target = fileTargets[node.fileIdx];
                if (target) {
                    node.vx = (node.vx || 0) + (target.x - node.x) * k;
                    node.vy = (node.vy || 0) + (target.y - node.y) * k;
                    if (IS_3D) {
                        node.vz = (node.vz || 0) + (target.z - node.z) * k;
                    }
                }
            });
        });

        _clusterForceActive = true;
        Graph.d3ReheatSimulation();
        scheduleHullRedraw(1500);
    }

    /**
     * Apply file cohesion force - nodes in same file attract each other
     * Also stretches inter-file links for better separation
     */
    function applyFileCohesion(data) {
        if (_fileCohesionActive) return;

        const Graph = window.Graph;
        const DM = window.DM;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const IS_3D = window.IS_3D;
        const DEFAULT_LINK_DISTANCE = window.DEFAULT_LINK_DISTANCE || 50;

        const config = data?.physics?.fileCohesion || {};
        const strength = (typeof APPEARANCE_STATE?.fileCohesionStrength === 'number')
            ? APPEARANCE_STATE.fileCohesionStrength
            : (config.strength ?? 0.15);
        const linkMult = config.interFileLinkMultiplier ?? 2.5;
        const minDist = config.minDistance ?? 20;

        const nodes = DM ? DM.getVisibleNodes() : (Graph?.graphData()?.nodes || []);
        if (!nodes.length) return;

        // Pre-compute file groups
        const groups = new Map();
        nodes.forEach(n => {
            const f = n.fileIdx ?? -1;
            if (f >= 0) (groups.get(f) || groups.set(f, []).get(f)).push(n);
        });

        // Intra-file centroid attraction
        Graph.d3Force('fileCohesion', (alpha) => {
            const k = strength * alpha;
            groups.forEach(g => {
                if (g.length < 2) return;
                let cx = 0, cy = 0, cz = 0;
                g.forEach(n => { cx += n.x || 0; cy += n.y || 0; cz += n.z || 0; });
                cx /= g.length; cy /= g.length; cz /= g.length;
                g.forEach(n => {
                    const dx = cx - (n.x || 0), dy = cy - (n.y || 0), dz = cz - (n.z || 0);
                    const d = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;
                    if (d > minDist) {
                        const f = k * Math.min(1, d / 100);
                        n.vx = (n.vx || 0) + dx * f;
                        n.vy = (n.vy || 0) + dy * f;
                        if (IS_3D) n.vz = (n.vz || 0) + dz * f;
                    }
                });
            });
        });

        // Inter-file links stretched
        const base = DEFAULT_LINK_DISTANCE;
        Graph.d3Force('link').distance(link => {
            const s = typeof link.source === 'object' ? link.source : nodes.find(n => n.id === link.source);
            const t = typeof link.target === 'object' ? link.target : nodes.find(n => n.id === link.target);
            if (!s || !t) return base;
            const sf = s.fileIdx ?? -1, tf = t.fileIdx ?? -1;
            return (sf >= 0 && tf >= 0 && sf !== tf) ? base * linkMult : base;
        });

        _fileCohesionActive = true;
        Graph.d3ReheatSimulation();
    }

    /**
     * Clear file cohesion force
     */
    function clearFileCohesion() {
        if (!_fileCohesionActive) return;

        const Graph = window.Graph;
        const DEFAULT_LINK_DISTANCE = window.DEFAULT_LINK_DISTANCE;

        Graph.d3Force('fileCohesion', null);
        if (DEFAULT_LINK_DISTANCE !== null) {
            Graph.d3Force('link').distance(DEFAULT_LINK_DISTANCE);
        }
        _fileCohesionActive = false;
        Graph.d3ReheatSimulation();
    }

    /**
     * Clear cluster force
     */
    function clearClusterForce() {
        if (!_clusterForceActive) return;

        const Graph = window.Graph;
        Graph.d3Force('cluster', null);
        _clusterForceActive = false;
        Graph.d3ReheatSimulation();
    }

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getHue,
        applyColors,

        // Mode management
        setMode,
        get mode() { return _mode; },
        MODES,
        MODE_HINTS,

        // Enable/disable
        setEnabled,
        toggle,
        get enabled() { return _enabled; },

        // Apply
        apply,

        // FILE GRAPH - Repository as Nodes
        buildFileGraph,
        applyFileGraphMode,
        expandFile,
        collapseFile,
        toggleFileExpansion,
        captureFileNodePositions,
        restoreFileNodePositions,
        getFileTarget,
        get fileGraph() { return _fileGraph; },
        get fileNodeIds() { return _fileNodeIds; },
        get expandedFiles() { return _expandedFiles; },
        get graphMode() { return _graphMode; },
        set graphMode(val) { _graphMode = val; },
        get expandMode() { return _expandMode; },
        set expandMode(val) { _expandMode = val; },

        // VISUAL MAPPING - Metadata to Visual Properties
        applyVisualMapping,
        getColorForMapping,
        VISUAL_MAPPINGS,
        get activeMapping() { return _activeMapping; },
        set activeMapping(val) { _activeMapping = val; },

        // Boundaries
        clearBoundaries,
        clearAllModes,
        scheduleHullRedraw,

        // File Clustering Forces
        applyClusterForce,
        clearClusterForce,
        applyFileCohesion,
        clearFileCohesion,
        get clusterForceActive() { return _clusterForceActive; },
        get fileCohesionActive() { return _fileCohesionActive; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Internal state access (for migration)
        get boundaryMeshes() { return _boundaryMeshes; },
        set boundaryMeshes(val) { _boundaryMeshes = val; }
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'fileMode', {
    get: () => FILE_VIZ.enabled,
    set: (v) => FILE_VIZ.setEnabled(v),
    configurable: true
});
Object.defineProperty(window, 'fileVizMode', {
    get: () => FILE_VIZ.mode,
    set: (v) => FILE_VIZ.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'FILE_COLOR_CONFIG', {
    get: () => FILE_VIZ.config,
    configurable: true
});
Object.defineProperty(window, 'fileBoundaryMeshes', {
    get: () => FILE_VIZ.boundaryMeshes,
    set: (v) => { FILE_VIZ.boundaryMeshes = v; },
    configurable: true
});
// hullRedrawTimer, hullRedrawAttempts - app.js owns these, not duplicated here

function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride) {
    return FILE_VIZ.getColor(fileIdx, totalFiles, fileName, lightnessOverride);
}
function getFileHue(fileIdx, totalFiles, fileName) {
    return FILE_VIZ.getHue(fileIdx, totalFiles, fileName);
}
function setFileModeState(enabled) {
    FILE_VIZ.setEnabled(enabled);
}
function setFileVizMode(mode) {
    FILE_VIZ.setMode(mode);
}
function applyFileVizMode() {
    FILE_VIZ.apply();
}
function applyFileColors(graphNodes) {
    FILE_VIZ.applyColors(graphNodes);
}
function clearFileBoundaries() {
    FILE_VIZ.clearBoundaries();
}
function clearAllFileModes() {
    FILE_VIZ.clearAllModes();
}
function scheduleHullRedraw(delayMs) {
    FILE_VIZ.scheduleHullRedraw(delayMs);
}

// File graph backward compatibility - Using getters for live updates
Object.defineProperty(window, 'FILE_GRAPH', {
    get: () => FILE_VIZ.fileGraph,
    set: (val) => { /* Ignore - module manages state */ },
    configurable: true
});
Object.defineProperty(window, 'FILE_NODE_IDS', {
    get: () => FILE_VIZ.fileNodeIds,
    configurable: true
});
// FILE_NODE_POSITIONS is managed by app.js (not in this module's scope)
Object.defineProperty(window, 'EXPANDED_FILES', {
    get: () => FILE_VIZ.expandedFiles,
    configurable: true
});
Object.defineProperty(window, 'FILE_EXPAND_MODE', {
    get: () => FILE_VIZ.expandMode,
    set: (val) => { FILE_VIZ.expandMode = val; },
    configurable: true
});

function buildFileGraph(data) {
    // Calls module's buildFileGraph - FILE_GRAPH getter will return the result
    FILE_VIZ.buildFileGraph();
    FILE_NODE_IDS = FILE_VIZ.fileNodeIds;
    return FILE_VIZ.fileGraph;  // Return directly from module
}
function captureFileNodePositions() {
    FILE_VIZ.captureFileNodePositions();
}
function restoreNodePositions(nodes) {
    FILE_VIZ.restoreFileNodePositions(nodes);
}
function getFileTarget(fileIdx, totalFiles, radius, zSpread) {
    return FILE_VIZ.getFileTarget(fileIdx, totalFiles, radius, zSpread);
}

// File clustering force shims
function applyClusterForce(data) {
    FILE_VIZ.applyClusterForce(data);
}
function clearClusterForce() {
    FILE_VIZ.clearClusterForce();
}
function applyFileCohesion(data) {
    FILE_VIZ.applyFileCohesion(data);
}
function clearFileCohesion() {
    FILE_VIZ.clearFileCohesion();
}
Object.defineProperty(window, 'clusterForceActive', {
    get: () => FILE_VIZ.clusterForceActive,
    configurable: true
});
Object.defineProperty(window, 'fileCohesionActive', {
    get: () => FILE_VIZ.fileCohesionActive,
    configurable: true
});


// ═══ MODULE: modules/tooltips.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * TOOLTIPS MODULE - Tooltip and Toast Notifications
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles topology tooltips and toast notifications.
 * Depends on: TOOLTIP_STATE, HINTS_ENABLED, SMC_THEORY (globals)
 *
 * @module TOOLTIPS
 * @version 1.0.0
 * @confidence 99%
 */

window.TOOLTIPS = (function() {
    'use strict';

    // Module-local timeout reference
    let _toastTimeout = null;

    // ═══════════════════════════════════════════════════════════════════════
    // TOOLTIP OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize tooltip elements
     */
    function initTooltips() {
        const state = window.TOOLTIP_STATE;
        if (state) {
            state.element = document.getElementById('topo-tooltip');
        }
    }

    /**
     * Show topology tooltip with theory content
     * @param {string} category - Theory category (tiers, rings, families, etc.)
     * @param {string} key - Item key within category
     * @param {number} x - Screen X position
     * @param {number} y - Screen Y position
     */
    function showTopoTooltip(category, key, x, y) {
        const state = window.TOOLTIP_STATE;
        if (!state) return;

        if (!state.element) initTooltips();
        if (!state.element) return;

        const theory = window.SMC_THEORY;
        const content = theory?.[category]?.[key];
        if (!content) return;

        clearTimeout(state.hideTimeout);

        // Populate tooltip content
        const iconEl = document.getElementById('tooltip-icon');
        const titleEl = document.getElementById('tooltip-title');
        const subtitleEl = document.getElementById('tooltip-subtitle');
        const bodyEl = document.getElementById('tooltip-body');
        const theoryEl = document.getElementById('tooltip-theory');
        const examplesEl = document.getElementById('tooltip-examples');

        if (iconEl) iconEl.textContent = content.icon || '';
        if (titleEl) titleEl.textContent = content.title || key;
        if (subtitleEl) subtitleEl.textContent = content.subtitle || '';
        if (bodyEl) bodyEl.textContent = content.body || '';
        if (theoryEl) theoryEl.textContent = content.theory || '';
        if (examplesEl) {
            examplesEl.innerHTML = (content.examples || [])
                .map(ex => `<span class="topo-tooltip-example">${ex}</span>`)
                .join('');
        }

        // Position tooltip
        const tooltip = state.element;
        let left = x + 15, top = y + 15;
        if (left + 280 > window.innerWidth) left = x - 295;
        if (top + 200 > window.innerHeight) top = y - 215;
        if (left < 0) left = 15;
        if (top < 0) top = 15;

        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.classList.add('visible');

        state.visible = true;
        state.currentKey = `${category}:${key}`;
    }

    /**
     * Hide topology tooltip
     * @param {boolean} immediate - Hide immediately without delay
     */
    function hideTopoTooltip(immediate = false) {
        const state = window.TOOLTIP_STATE;
        if (!state || !state.element) return;

        if (immediate) {
            state.element.classList.remove('visible');
            state.visible = false;
        } else {
            state.hideTimeout = setTimeout(() => {
                state.element.classList.remove('visible');
                state.visible = false;
            }, 150);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Show a toast notification
     * @param {string} message - Message to display
     */
    function showToast(message) {
        const toast = document.getElementById('hud-toast');
        if (!toast) return;

        toast.textContent = message;
        toast.classList.add('visible');

        clearTimeout(toast._timer);
        toast._timer = setTimeout(() => {
            toast.classList.remove('visible');
        }, 2200);
    }

    /**
     * Show mode change toast (respects hints setting)
     * @param {string} message - Message to display
     */
    function showModeToast(message) {
        if (!window.HINTS_ENABLED) return;

        let toast = document.getElementById('mode-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'mode-toast';
            toast.className = 'mode-toast';
            document.body.appendChild(toast);
        }

        toast.textContent = message;
        toast.classList.add('visible');

        if (_toastTimeout) clearTimeout(_toastTimeout);
        _toastTimeout = setTimeout(() => {
            toast.classList.remove('visible');
        }, 1200);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        init: initTooltips,
        showTopo: showTopoTooltip,
        hideTopo: hideTopoTooltip,
        toast: showToast,
        modeToast: showModeToast
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.initTooltips = TOOLTIPS.init;
window.showTopoTooltip = TOOLTIPS.showTopo;
window.hideTopoTooltip = TOOLTIPS.hideTopo;
window.showToast = TOOLTIPS.toast;
window.showModeToast = TOOLTIPS.modeToast;

console.log('[Module] TOOLTIPS loaded - 5 functions');


// ═══ MODULE: modules/theme.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * THEME MODULE - Runtime Theme Management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles theme switching, persistence, and initialization.
 * Depends on: THEME_CONFIG (global), Graph (global), THREE (global)
 *
 * @module THEME
 * @version 1.0.0
 * @confidence 99%
 */

window.THEME = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // THEME OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Set the active theme by name.
     * Updates document data-theme attribute and stores preference.
     * @param {string} themeName - Theme name: 'dark', 'light', or 'high-contrast'
     */
    function setTheme(themeName) {
        const config = window.THEME_CONFIG;
        if (!config || !config.available.includes(themeName)) {
            console.warn(`[Theme] Unknown theme: ${themeName}. Available: ${config?.available?.join(', ') || 'none'}`);
            return;
        }

        // Update document attribute for CSS variable switching
        document.documentElement.setAttribute('data-theme', themeName);

        // Update global state
        config.current = themeName;

        // Store preference in localStorage
        try {
            localStorage.setItem('collider-theme', themeName);
        } catch (e) {
            console.warn('[Theme] Could not save preference:', e);
        }

        // Update canvas background if WebGL renderer is active
        const Graph = window.Graph;
        if (Graph && Graph.scene && Graph.scene()) {
            const scene = Graph.scene();
            if (scene.background) {
                const vizColors = window.VIZ_COLORS || {};
                const bgColor = getComputedStyle(document.documentElement)
                    .getPropertyValue('--color-viz-canvas-bg')?.trim() || vizColors.canvasBg || '#0a0a0f';
                scene.background = new THREE.Color(bgColor);
            }
        }

        // Update theme toggle buttons
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.theme === themeName);
        });

        const consoleColors = window.CONSOLE_COLORS || { success: '#4caf50' };
        console.log(`%c[Theme] Switched to: ${themeName}`, `color: ${consoleColors.success}; font-weight: bold`);

        // Show toast if available
        if (typeof window.showToast === 'function') {
            window.showToast(`Theme: ${themeName}`);
        }
    }

    /**
     * Get the current theme name.
     * @returns {string} Current theme name
     */
    function getTheme() {
        const config = window.THEME_CONFIG;
        return config ? config.current : 'dark';
    }

    /**
     * Get list of available themes.
     * @returns {string[]} Array of theme names
     */
    function getAvailableThemes() {
        const config = window.THEME_CONFIG;
        return config ? config.available : ['dark'];
    }

    /**
     * Cycle to the next theme in the list.
     */
    function cycleTheme() {
        const config = window.THEME_CONFIG;
        if (!config) return;

        const current = config.current;
        const themes = config.available;
        const currentIndex = themes.indexOf(current);
        const nextIndex = (currentIndex + 1) % themes.length;
        setTheme(themes[nextIndex]);
    }

    /**
     * Initialize theme from saved preference or default.
     */
    function initTheme() {
        const config = window.THEME_CONFIG;
        if (!config) {
            console.warn('[Theme] THEME_CONFIG not available');
            return;
        }

        // Check for saved preference
        let savedTheme = null;
        try {
            savedTheme = localStorage.getItem('collider-theme');
        } catch (e) {
            // Ignore storage errors
        }

        // Use saved preference if valid
        if (savedTheme && config.available.includes(savedTheme)) {
            setTheme(savedTheme);
            return;
        }

        // Fall back to default theme
        setTheme(config.default || 'dark');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        set: setTheme,
        get: getTheme,
        available: getAvailableThemes,
        cycle: cycleTheme,
        init: initTheme
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setTheme = THEME.set;
window.getTheme = THEME.get;
window.getAvailableThemes = THEME.available;
window.cycleTheme = THEME.cycle;
window.initTheme = THEME.init;

console.log('[Module] THEME loaded - 5 functions');


// ═══ MODULE: modules/control-bar.js ═══
/**
 * CONTROL BAR MODULE - Visual Mapping Command Center
 *
 * A persistent control bar (like ChatGPT/Claude input) that allows dynamic
 * mapping of any data characteristic to any visual/physics property.
 *
 * Features:
 * - Always visible at bottom of screen
 * - Works with selected nodes or node groups
 * - Dropdown to choose data source (any field)
 * - Dropdown to choose visual target (size, color, position, physics...)
 * - Group comparison with numbered badges
 * - Real-time preview as you adjust
 *
 * Depends on: DATA, COLOR, ANIM, SELECT
 */

const CONTROL_BAR = (function () {
    'use strict';

    // =========================================================================
    // AVAILABLE DATA SOURCES (what we can map FROM)
    // =========================================================================

    const DATA_SOURCES = {
        // Structural metrics
        size_bytes: { label: 'File Size (bytes)', type: 'continuous', domain: 'file' },
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' },
        line_count: { label: 'Line Count', type: 'continuous', domain: 'file' },
        code_lines: { label: 'Code Lines', type: 'continuous', domain: 'file' },
        complexity_density: { label: 'Complexity Density', type: 'continuous', domain: 'file' },
        cohesion: { label: 'Cohesion', type: 'continuous', domain: 'file' },
        code_ratio: { label: 'Code Ratio', type: 'continuous', domain: 'file' },

        // Temporal metrics
        age_days: { label: 'Age (days)', type: 'continuous', domain: 'file' },

        // Graph metrics
        in_degree: { label: 'In-Degree (callers)', type: 'continuous', domain: 'node' },
        out_degree: { label: 'Out-Degree (calls)', type: 'continuous', domain: 'node' },
        pagerank: { label: 'PageRank', type: 'continuous', domain: 'node' },

        // Categorical
        tier: { label: 'Tier (T0-T4)', type: 'discrete', values: ['T0', 'T1', 'T2', 'T3', 'T4'] },
        ring: { label: 'Ring', type: 'discrete', values: ['CORE', 'NEAR', 'FAR', 'OUTER'] },
        layer: { label: 'Layer', type: 'discrete', values: ['Core', 'Domain', 'Application', 'Interface', 'Infrastructure'] },
        role: { label: 'Role', type: 'discrete', domain: 'node' },
        format_category: { label: 'Format', type: 'discrete', values: ['code', 'config', 'doc', 'data', 'test', 'style', 'script', 'build'] },
        purpose: { label: 'Purpose', type: 'discrete', domain: 'file' },
        effect: { label: 'Effect', type: 'discrete', values: ['Pure', 'Read', 'Write', 'ReadWrite'] },

        // Boolean
        is_test: { label: 'Is Test?', type: 'boolean' },
        is_config: { label: 'Is Config?', type: 'boolean' },
        is_stale: { label: 'Is Stale?', type: 'boolean' },
        is_recent: { label: 'Is Recent?', type: 'boolean' }
    };

    // =========================================================================
    // AVAILABLE TARGETS (what we can map TO)
    // =========================================================================

    const VISUAL_TARGETS = {
        // Size
        nodeSize: { label: 'Node Size', category: 'appearance', range: [1, 30] },

        // Color components
        hue: { label: 'Color Hue', category: 'appearance', range: [0, 360] },
        saturation: { label: 'Saturation', category: 'appearance', range: [0, 100] },
        lightness: { label: 'Lightness', category: 'appearance', range: [20, 80] },
        opacity: { label: 'Opacity', category: 'appearance', range: [0.1, 1.0] },

        // Position
        xPosition: { label: 'X Position', category: 'position', range: [-500, 500] },
        yPosition: { label: 'Y Position', category: 'position', range: [-500, 500] },
        zPosition: { label: 'Z Position (depth)', category: 'position', range: [-300, 300] },
        radius: { label: 'Radial Distance', category: 'position', range: [50, 400] },

        // Physics
        charge: { label: 'Charge (repel)', category: 'physics', range: [-500, 0] },
        linkStrength: { label: 'Link Strength', category: 'physics', range: [0, 1] },
        mass: { label: 'Mass (inertia)', category: 'physics', range: [1, 10] },

        // Animation
        pulseSpeed: { label: 'Pulse Speed', category: 'animation', range: [0, 5] },
        rotationSpeed: { label: 'Rotation Speed', category: 'animation', range: [0, 2] }
    };

    // =========================================================================
    // SCALE FUNCTIONS
    // =========================================================================

    const SCALES = {
        linear: (v, min, max) => (v - min) / (max - min || 1),
        log: (v, min, max) => {
            const logMin = Math.log10(Math.max(1, min));
            const logMax = Math.log10(Math.max(1, max));
            const logVal = Math.log10(Math.max(1, v));
            return (logVal - logMin) / (logMax - logMin || 1);
        },
        sqrt: (v, min, max) => {
            const sqrtMin = Math.sqrt(Math.max(0, min));
            const sqrtMax = Math.sqrt(Math.max(0, max));
            const sqrtVal = Math.sqrt(Math.max(0, v));
            return (sqrtVal - sqrtMin) / (sqrtMax - sqrtMin || 1);
        },
        inverse: (v, min, max) => 1 - (v - min) / (max - min || 1)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _visible = false;
    let _container = null;
    let _activeMapping = null;
    let _groups = [];         // [{id, name, nodeIds, color}]
    let _groupCounter = 0;

    // Current mapping configuration
    let _config = {
        source: 'token_estimate',
        target: 'nodeSize',
        scale: 'sqrt',
        scope: 'selection',   // 'selection' | 'all' | 'group:X'
        invert: false
    };

    // =========================================================================
    // UI BUILDING
    // =========================================================================

    let _isDocked = false;

    function createUI() {
        if (_container) return _container;

        const dockContainer = document.getElementById('control-bar-container');
        _isDocked = !!dockContainer;

        _container = document.createElement('div');
        _container.id = 'control-bar';
        _container.className = _isDocked ? 'control-bar docked' : 'control-bar';

        // Scope Section
        const scopeHTML = `
            <div class="control-section scope-section">
                <label>SCOPE</label>
                <div class="row-group">
                    <select id="cb-scope" class="cb-select">
                        <option value="selection">Selected Nodes</option>
                        <option value="all">All Nodes</option>
                        <optgroup label="Groups" id="cb-groups-optgroup"></optgroup>
                    </select>
                    <button id="cb-add-group" class="cb-btn cb-btn-small" title="Create group from selection">+G</button>
                    <span id="cb-node-count" class="cb-badge">0</span>
                </div>
            </div>
        `;

        // Map FROM
        const sourceHTML = `
            <div class="control-section">
                <label>MAP DATA SOURCE</label>
                <select id="cb-source" class="cb-select full-width">
                    <optgroup label="Structural">
                        <option value="token_estimate">Token Count</option>
                        <option value="line_count">Line Count</option>
                        <option value="size_bytes">File Size</option>
                        <option value="code_lines">Code Lines</option>
                        <option value="complexity_density">Complexity</option>
                        <option value="cohesion">Cohesion</option>
                    </optgroup>
                    <optgroup label="Temporal">
                        <option value="age_days">Age (days)</option>
                    </optgroup>
                    <optgroup label="Graph">
                        <option value="in_degree">In-Degree</option>
                        <option value="out_degree">Out-Degree</option>
                    </optgroup>
                    <optgroup label="Categorical">
                        <option value="tier">Tier</option>
                        <option value="ring">Ring</option>
                        <option value="layer">Layer</option>
                        <option value="role">Role</option>
                        <option value="format_category">Format</option>
                        <option value="effect">Effect</option>
                    </optgroup>
                    <optgroup label="Boolean">
                        <option value="is_test">Is Test?</option>
                        <option value="is_config">Is Config?</option>
                        <option value="is_stale">Is Stale?</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Arrow (only for float mode, skip or style differently in dock)
        const arrowHTML = _isDocked ? '' : `
            <div class="control-section arrow-section">
                <span class="arrow">&#8594;</span>
            </div>
        `;

        // Map TO
        const targetHTML = `
            <div class="control-section">
                <label>TO VISUAL PROPERTY</label>
                <select id="cb-target" class="cb-select full-width">
                    <optgroup label="Appearance">
                        <option value="nodeSize">Node Size</option>
                        <option value="hue">Color Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="lightness">Lightness</option>
                        <option value="opacity">Opacity</option>
                    </optgroup>
                    <optgroup label="Position">
                        <option value="xPosition">X Position</option>
                        <option value="yPosition">Y Position</option>
                        <option value="zPosition">Z Depth</option>
                        <option value="radius">Radial Distance</option>
                    </optgroup>
                    <optgroup label="Physics">
                        <option value="charge">Charge (repel)</option>
                        <option value="mass">Mass</option>
                    </optgroup>
                    <optgroup label="Animation">
                        <option value="pulseSpeed">Pulse Speed</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Scale
        const scaleHTML = `
            <div class="control-section">
                <label>SCALING</label>
                <select id="cb-scale" class="cb-select full-width">
                    <option value="linear">Linear</option>
                    <option value="sqrt" selected>Sqrt</option>
                    <option value="log">Log</option>
                    <option value="inverse">Inverse</option>
                </select>
            </div>
        `;

        // Actions
        const actionsHTML = `
            <div class="control-section actions-section">
                <button id="cb-apply" class="cb-btn cb-btn-primary full-width">APPLY MAPPING</button>
                <button id="cb-reset" class="cb-btn full-width" style="margin-top:4px">Reset</button>
            </div>
        `;

        // Groups Display
        const groupsHTML = `
            <div class="control-section groups-section" id="cb-groups-display"></div>
        `;

        // Toggle (only for float mode)
        const toggleHTML = _isDocked ? '' : `
            <button id="cb-toggle" class="cb-toggle" title="Toggle Control Bar">
                <span class="chevron">&#9660;</span>
            </button>
        `;

        _container.innerHTML = `
            <div class="control-bar-inner">
                ${scopeHTML}
                ${sourceHTML}
                ${arrowHTML}
                ${targetHTML}
                ${scaleHTML}
                ${actionsHTML}
                ${groupsHTML}
                ${toggleHTML}
            </div>
        `;

        // Add styles
        addStyles();

        // Attach event listeners
        attachListeners();

        if (_isDocked) {
            dockContainer.appendChild(_container);
        } else {
            document.body.appendChild(_container);
        }

        _visible = true;

        return _container;
    }

    function addStyles() {
        if (document.getElementById('control-bar-styles')) return;

        const style = document.createElement('style');
        style.id = 'control-bar-styles';
        style.textContent = `
            /* BASE STYLES */
            .control-bar {
                font-family: 'SF Mono', 'Consolas', monospace;
            }

            /* FLOATING MODE */
            .control-bar:not(.docked) {
                position: fixed;
                bottom: 16px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 900px;
                width: calc(100% - 48px);
                z-index: 9999;
                background: linear-gradient(180deg, rgba(28, 30, 35, 0.95) 0%, rgba(22, 24, 28, 0.98) 100%);
                backdrop-filter: blur(12px);
                border: 1px solid rgba(100, 105, 115, 0.15);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.35);
                transition: transform 0.3s ease, opacity 0.3s ease;
            }

            .control-bar:not(.docked) .control-bar-inner {
                display: flex;
                align-items: center;
                gap: 16px;
                padding: 12px 20px;
                overflow-x: auto;
            }

            /* DOCKED MODE */
            .control-bar.docked {
                position: static;
                width: 100%;
                background: transparent;
                border: none;
                box-shadow: none;
                padding: 0;
            }

            .control-bar.docked .control-bar-inner {
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 0;
            }

            /* SHARED COMPONENTS */
            .control-section {
                display: flex;
                flex-direction: column;
                gap: 4px;
                width: 100%; /* Full width when docked */
            }

            .control-section label {
                font-size: 9px;
                font-weight: 600;
                color: rgba(140, 145, 155, 0.6);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .row-group {
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .cb-select {
                background: rgba(35, 38, 45, 0.85);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #c8ccd5;
                padding: 6px 10px;
                font-size: 11px;
                font-family: inherit;
                cursor: pointer;
                transition: all 0.2s;
                flex: 1;
            }

            .cb-select:hover {
                background: rgba(45, 48, 55, 0.9);
                border-color: rgba(120, 125, 135, 0.35);
            }
            
            .cb-select:focus {
                outline: none;
                border-color: var(--accent, #4a9eff);
            }

            .full-width {
                width: 100%;
            }

            .cb-btn {
                background: rgba(50, 55, 65, 0.6);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #b0b5c0;
                padding: 6px 12px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
            }
            .actions-section {
                width: 100%;
            }
            .cb-btn:hover {
                background: rgba(65, 70, 80, 0.75);
                color: #fff;
            }

            .cb-btn-primary {
                background: var(--accent-dim, rgba(74, 158, 255, 0.15));
                color: var(--accent, #4a9eff);
                border-color: var(--accent, #4a9eff);
            }

            .cb-btn-primary:hover {
                background: var(--accent, #4a9eff);
                color: #000;
            }

            .cb-btn-small {
                padding: 4px 8px;
                min-width: 30px;
            }

            .cb-badge {
                font-size: 10px;
                color: #666;
                min-width: 15px;
                text-align: center;
            }

            /* GROUP CHIPS */
            .groups-section {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 4px;
            }

            .group-chip {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
                padding: 2px 8px;
                font-size: 10px;
                cursor: default;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .group-color {
                width: 6px;
                height: 6px;
                border-radius: 50%;
            }

            .group-remove {
                margin-left: 4px;
                cursor: pointer;
                opacity: 0.5;
            }
            .group-remove:hover { opacity: 1; }
        `;

        document.head.appendChild(style);
    }

    function attachListeners() {
        // Toggle collapse
        const toggleBtn = document.getElementById('cb-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', toggle);
        }

        // Scope change
        const scopeSelect = document.getElementById('cb-scope');
        if (scopeSelect) {
            scopeSelect.addEventListener('change', (e) => {
                _config.scope = e.target.value;
                updateNodeCount();
            });
        }

        // Source change
        const sourceSelect = document.getElementById('cb-source');
        if (sourceSelect) {
            sourceSelect.addEventListener('change', (e) => {
                _config.source = e.target.value;
            });
        }

        // Target change
        const targetSelect = document.getElementById('cb-target');
        if (targetSelect) {
            targetSelect.addEventListener('change', (e) => {
                _config.target = e.target.value;
            });
        }

        // Scale change
        const scaleSelect = document.getElementById('cb-scale');
        if (scaleSelect) {
            scaleSelect.addEventListener('change', (e) => {
                _config.scale = e.target.value;
            });
        }

        // Apply button
        const applyBtn = document.getElementById('cb-apply');
        if (applyBtn) {
            applyBtn.addEventListener('click', applyMapping);
        }

        // Reset button
        const resetBtn = document.getElementById('cb-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', resetMapping);
        }

        // Add group button
        const addGroupBtn = document.getElementById('cb-add-group');
        if (addGroupBtn) {
            addGroupBtn.addEventListener('click', createGroupFromSelection);
        }

        // Update node count periodically
        setInterval(updateNodeCount, 1000);
    }

    // =========================================================================
    // GROUP MANAGEMENT
    // =========================================================================

    const GROUP_COLORS = [
        '#4a9eff', '#ff6b6b', '#51cf66', '#ffd43b',
        '#cc5de8', '#20c997', '#ff922b', '#748ffc'
    ];

    function createGroupFromSelection() {
        const selectedIds = getSelectedNodeIds();
        if (selectedIds.length === 0) {
            showToast('Select nodes first to create a group');
            return;
        }

        _groupCounter++;
        const groupId = `group-${_groupCounter}`;
        const color = GROUP_COLORS[(_groupCounter - 1) % GROUP_COLORS.length];

        const group = {
            id: groupId,
            name: `Group ${_groupCounter}`,
            nodeIds: [...selectedIds],
            color: color
        };

        _groups.push(group);
        updateGroupsUI();
        showToast(`Created ${group.name} with ${selectedIds.length} nodes`);
    }

    function removeGroup(groupId) {
        _groups = _groups.filter(g => g.id !== groupId);
        updateGroupsUI();
    }

    function updateGroupsUI() {
        // Update dropdown
        const optgroup = document.getElementById('cb-groups-optgroup');
        if (optgroup) {
            optgroup.innerHTML = _groups.map(g =>
                `<option value="group:${g.id}">${g.name} (${g.nodeIds.length})</option>`
            ).join('');
        }

        // Update chips display
        const display = document.getElementById('cb-groups-display');
        if (display) {
            display.innerHTML = _groups.map(g => `
                <div class="group-chip" data-group="${g.id}">
                    <span class="group-color" style="background: ${g.color}"></span>
                    <span class="group-name">${g.name}</span>
                    <span class="group-count">${g.nodeIds.length}</span>
                    <span class="group-remove" onclick="CONTROL_BAR.removeGroup('${g.id}')">&times;</span>
                </div>
            `).join('');
        }
    }

    // =========================================================================
    // MAPPING APPLICATION
    // =========================================================================

    function getTargetNodes() {
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        const allNodes = dm?.getNodes ? dm.getNodes() : (typeof graphNodes !== 'undefined' ? graphNodes : []);

        if (_config.scope === 'all') {
            return allNodes;
        }

        if (_config.scope === 'selection') {
            const selectedIds = getSelectedNodeIds();
            return allNodes.filter(n => selectedIds.includes(n.id));
        }

        if (_config.scope.startsWith('group:')) {
            const groupId = _config.scope.replace('group:', '');
            const group = _groups.find(g => g.id === groupId);
            if (group) {
                return allNodes.filter(n => group.nodeIds.includes(n.id));
            }
        }

        return [];
    }

    function applyMapping() {
        const nodes = getTargetNodes();
        if (nodes.length === 0) {
            showToast('No nodes to map. Select nodes or change scope.');
            return;
        }

        const sourceKey = _config.source;
        const targetKey = _config.target;
        const scaleFn = SCALES[_config.scale] || SCALES.linear;
        const targetInfo = VISUAL_TARGETS[targetKey];

        // Get value range
        const values = nodes.map(n => getNodeValue(n, sourceKey)).filter(v => v !== null && v !== undefined);
        if (values.length === 0) {
            showToast(`No data for "${sourceKey}" on selected nodes`);
            return;
        }

        const sourceInfo = DATA_SOURCES[sourceKey];
        const isDiscrete = sourceInfo?.type === 'discrete' || sourceInfo?.type === 'boolean';

        let dataMin, dataMax;
        if (!isDiscrete) {
            dataMin = Math.min(...values);
            dataMax = Math.max(...values);
        }

        // Apply to each node
        nodes.forEach(node => {
            const rawValue = getNodeValue(node, sourceKey);
            if (rawValue === null || rawValue === undefined) return;

            let mappedValue;
            if (isDiscrete) {
                // Map discrete values to evenly spaced range
                const uniqueValues = sourceInfo.values || [...new Set(values)];
                const idx = uniqueValues.indexOf(rawValue);
                mappedValue = idx >= 0 ? idx / Math.max(1, uniqueValues.length - 1) : 0.5;
            } else {
                mappedValue = scaleFn(rawValue, dataMin, dataMax);
            }

            // Map to target range
            const [tMin, tMax] = targetInfo.range;
            const targetValue = tMin + mappedValue * (tMax - tMin);

            applyToNode(node, targetKey, targetValue);
        });

        // Refresh graph
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            Graph.refresh();
        }

        showToast(`Mapped ${sourceKey} -> ${targetKey} on ${nodes.length} nodes`);
        console.log(`[CONTROL_BAR] Applied: ${sourceKey} -> ${targetKey}, scale=${_config.scale}, nodes=${nodes.length}`);
    }

    function getNodeValue(node, key) {
        // Direct property
        if (node[key] !== undefined) return node[key];

        // Nested in dimensions
        if (node.dimensions && node.dimensions[key] !== undefined) {
            return node.dimensions[key];
        }

        // Check common dimension mappings
        const dimMap = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };

        if (dimMap[key] && node.dimensions) {
            return node.dimensions[dimMap[key]];
        }

        return null;
    }

    function applyToNode(node, targetKey, value) {
        switch (targetKey) {
            case 'nodeSize':
                node.val = value;
                break;

            case 'hue':
                const currentColor = node.color || 'hsl(200, 70%, 50%)';
                node.color = setHSLComponent(currentColor, 'h', value);
                break;

            case 'saturation':
                node.color = setHSLComponent(node.color || 'hsl(200, 70%, 50%)', 's', value);
                break;

            case 'lightness':
                node.color = setHSLComponent(node.color || 'hsl(200, 70%, 50%)', 'l', value);
                break;

            case 'opacity':
                node.opacity = value;
                // Update color alpha if using rgba
                if (node.color && !node.color.startsWith('hsl')) {
                    node.color = setAlpha(node.color, value);
                }
                break;

            case 'xPosition':
                node.fx = value;
                break;

            case 'yPosition':
                node.fy = value;
                break;

            case 'zPosition':
                node.fz = value;
                break;

            case 'radius':
                // Position on a circle at given radius
                const angle = (node.fileIdx || Math.random() * 100) * 0.618 * Math.PI * 2;
                node.fx = Math.cos(angle) * value;
                node.fy = Math.sin(angle) * value;
                break;

            case 'charge':
                node.__charge = value;
                break;

            case 'mass':
                node.__mass = value;
                break;

            case 'pulseSpeed':
                node.__pulseSpeed = value;
                break;

            default:
                node[targetKey] = value;
        }
    }

    function setHSLComponent(colorStr, component, value) {
        // Parse existing HSL or convert
        let h = 200, s = 70, l = 50;

        const hslMatch = colorStr.match(/hsl\((\d+),\s*(\d+)%?,\s*(\d+)%?\)/);
        if (hslMatch) {
            h = parseInt(hslMatch[1]);
            s = parseInt(hslMatch[2]);
            l = parseInt(hslMatch[3]);
        }

        switch (component) {
            case 'h': h = value; break;
            case 's': s = value; break;
            case 'l': l = value; break;
        }

        return `hsl(${Math.round(h)}, ${Math.round(s)}%, ${Math.round(l)}%)`;
    }

    function setAlpha(colorStr, alpha) {
        // Simple alpha injection
        if (colorStr.startsWith('rgba')) {
            return colorStr.replace(/[\d.]+\)$/, `${alpha})`);
        }
        if (colorStr.startsWith('rgb')) {
            return colorStr.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        }
        return colorStr;
    }

    function resetMapping() {
        // Clear fixed positions
        const nodes = getTargetNodes();
        nodes.forEach(n => {
            delete n.fx;
            delete n.fy;
            delete n.fz;
            delete n.__charge;
            delete n.__mass;
            delete n.__pulseSpeed;
        });

        // Reheat simulation
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3ReheatSimulation();
        }

        showToast('Reset node positions and custom properties');
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function getSelectedNodeIds() {
        if (typeof SELECT !== 'undefined' && SELECT.getSelectedNodes) {
            return SELECT.getSelectedNodes().map(n => n.id);
        }
        if (typeof SELECTED_NODE_IDS !== 'undefined') {
            return Array.from(SELECTED_NODE_IDS);
        }
        return [];
    }

    function updateNodeCount() {
        const badge = document.getElementById('cb-node-count');
        if (!badge) return;

        const nodes = getTargetNodes();
        badge.textContent = nodes.length;
    }

    function showToast(msg) {
        if (typeof window.showToast === 'function') {
            window.showToast(msg);
        } else {
            console.log(`[CONTROL_BAR] ${msg}`);
        }
    }

    function toggle() {
        if (_container) {
            _container.classList.toggle('collapsed');
            _visible = !_container.classList.contains('collapsed');
        }
    }

    function show() {
        if (_container) {
            _container.classList.remove('collapsed');
            _visible = true;
        }
    }

    function hide() {
        if (_container) {
            _container.classList.add('collapsed');
            _visible = false;
        }
    }

    // =========================================================================
    // INIT
    // =========================================================================

    function init() {
        createUI();
        updateNodeCount();
        console.log('[CONTROL_BAR] Initialized');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        toggle,
        show,
        hide,
        applyMapping,
        resetMapping,
        createGroupFromSelection,
        removeGroup,
        get visible() { return _visible; },
        get config() { return _config; },
        get groups() { return _groups; },
        DATA_SOURCES,
        VISUAL_TARGETS,
        SCALES
    };

})();

// Auto-init when DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => CONTROL_BAR.init());
} else {
    // Small delay to ensure other modules are loaded
    setTimeout(() => CONTROL_BAR.init(), 100);
}


// ═══ MODULE: modules/main.js ═══
/**
 * MAIN.JS - MODULE INTEGRATION ENTRY POINT
 *
 * This file wires up all modules and provides backward compatibility
 * for HTML onclick handlers and global function calls.
 *
 * Module Loading Order (already handled by visualize_graph_webgl.py):
 * 1. performance.js       - Performance subsystem
 * 2. core.js              - Constants & utilities
 * 3. node-accessors.js    - Node property functions
 * 4. color-engine.js      - OKLCH color system
 * 5. refresh-throttle.js  - Throttled graph updates
 * 6. legend-manager.js    - Legend system
 * 7. data-manager.js      - Data access layer
 * 8. animation.js         - Layout & animation controller
 * 9. selection.js         - Selection system
 * 10. panels.js           - Panel management
 * 11. sidebar.js          - Sidebar controls
 * 12. edge-system.js      - Edge coloring & modes
 * 13. file-viz.js         - File visualization modes
 * 14. control-bar.js      - Visual mapping command bar
 * 15. main.js             - This file (wiring)
 * 16. app.js              - Legacy monolith (shrinking)
 */

;(function() {
    'use strict';

    // =========================================================================
    // VERIFY MODULE LOADING
    // =========================================================================

    const REQUIRED_MODULES = [
        { name: 'CORE', module: typeof CORE !== 'undefined' ? CORE : null },
        { name: 'NODE', module: typeof NODE !== 'undefined' ? NODE : null },
        { name: 'COLOR', module: typeof COLOR !== 'undefined' ? COLOR : null },
        { name: 'REFRESH', module: typeof REFRESH !== 'undefined' ? REFRESH : null },
        { name: 'LEGEND', module: typeof LEGEND !== 'undefined' ? LEGEND : null },
        { name: 'DATA', module: typeof DATA !== 'undefined' ? DATA : null },
        { name: 'LAYOUT', module: typeof LAYOUT !== 'undefined' ? LAYOUT : null },  // UI Layout Engine
        { name: 'ANIM', module: typeof ANIM !== 'undefined' ? ANIM : null },
        { name: 'SELECT', module: typeof SELECT !== 'undefined' ? SELECT : null },
        { name: 'PANELS', module: typeof PANELS !== 'undefined' ? PANELS : null },
        { name: 'SIDEBAR', module: typeof SIDEBAR !== 'undefined' ? SIDEBAR : null },
        { name: 'EDGE', module: typeof EDGE !== 'undefined' ? EDGE : null },
        { name: 'FILE_VIZ', module: typeof FILE_VIZ !== 'undefined' ? FILE_VIZ : null },
        { name: 'CONTROL_BAR', module: typeof CONTROL_BAR !== 'undefined' ? CONTROL_BAR : null },
        // STARS module removed - nodes ARE the stars
        { name: 'HUD', module: typeof HUD !== 'undefined' ? HUD : null },
        { name: 'DIMENSION', module: typeof DIMENSION !== 'undefined' ? DIMENSION : null }
    ];

    const loaded = REQUIRED_MODULES.filter(m => m.module !== null);
    const missing = REQUIRED_MODULES.filter(m => m.module === null);

    console.log(`[MAIN] Modules loaded: ${loaded.length}/${REQUIRED_MODULES.length}`);
    if (missing.length > 0) {
        console.warn('[MAIN] Missing modules:', missing.map(m => m.name).join(', '));
    }

    // =========================================================================
    // WINDOW-LEVEL EXPORTS FOR HTML ONCLICK HANDLERS
    // =========================================================================

    // Selection functions
    if (typeof SELECT !== 'undefined') {
        window.clearSelection = SELECT.clear;
        window.setSelection = SELECT.set;
        window.toggleSelection = SELECT.toggle;
        window.getSelectedNodes = SELECT.getSelectedNodes;
    }

    // Animation functions
    if (typeof ANIM !== 'undefined') {
        window.applyLayoutPreset = ANIM.applyLayout;
        window.stopAnimation = ANIM.stop;
    }

    // Edge functions
    if (typeof EDGE !== 'undefined') {
        window.setEdgeMode = EDGE.setMode;
        window.cycleEdgeMode = EDGE.cycleMode;
        window.applyEdgeMode = EDGE.apply;
    }

    // File visualization functions
    if (typeof FILE_VIZ !== 'undefined') {
        window.setFileVizMode = FILE_VIZ.setMode;
        window.toggleFileMode = FILE_VIZ.toggle;
    }

    // Panel functions
    if (typeof PANELS !== 'undefined') {
        window.openPanel = PANELS.open;
        window.closePanel = PANELS.close;
        window.togglePanel = PANELS.toggle;
    }

    // Sidebar functions
    if (typeof SIDEBAR !== 'undefined') {
        window.setColorMode = SIDEBAR.setColorMode;
        window.setLayout = SIDEBAR.setLayout;
    }

    // Refresh function
    if (typeof REFRESH !== 'undefined') {
        window.throttledRefresh = REFRESH.throttled;
    }

    // Control bar functions
    if (typeof CONTROL_BAR !== 'undefined') {
        window.toggleControlBar = CONTROL_BAR.toggle;
        window.showControlBar = CONTROL_BAR.show;
        window.hideControlBar = CONTROL_BAR.hide;
        window.applyVisualMapping = CONTROL_BAR.applyMapping;
    }

    // =========================================================================
    // CROSS-MODULE INTEGRATION
    // =========================================================================

    /**
     * Initialize all modules with data
     * Called from app.js after data is loaded
     */
    window.initializeModules = function(data) {
        console.log('[MAIN] Initializing modules with data...');

        // Initialize DATA module
        if (typeof DATA !== 'undefined' && DATA.init) {
            DATA.init(data);
            console.log('[MAIN] DATA module initialized');
        }

        // Initialize LEGEND module
        if (typeof LEGEND !== 'undefined' && LEGEND.init) {
            LEGEND.init(data.nodes, data.links || data.edges);
            console.log('[MAIN] LEGEND module initialized');
        }

        // Initialize SIDEBAR
        if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
            SIDEBAR.init();
            console.log('[MAIN] SIDEBAR module initialized');
        }

        // Initialize PANELS command bar
        if (typeof PANELS !== 'undefined' && PANELS.initCommandBar) {
            PANELS.initCommandBar();
            console.log('[MAIN] PANELS module initialized');
        }

        // Initialize LAYOUT (replaces HudLayoutManager from app.js)
        if (typeof LAYOUT !== 'undefined' && LAYOUT.init) {
            LAYOUT.init();
            console.log('[MAIN] LAYOUT module initialized (Ctrl+Shift+L for debug overlay)');
        }

        // STARS module removed - nodes ARE the stars

        // Initialize HUD (fade behavior)
        if (typeof HUD !== 'undefined' && HUD.setupFade) {
            HUD.setupFade();
            console.log('[MAIN] HUD module initialized');
        }

        // Initialize DIMENSION toggle
        if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) {
            DIMENSION.setup();
            console.log('[MAIN] DIMENSION module initialized');
        }

        console.log('[MAIN] Module initialization complete');
    };

    /**
     * Global refresh function that uses the throttled refresher
     */
    window.moduleRefresh = function() {
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            Graph.refresh();
        }
    };

    // =========================================================================
    // MODULE HEALTH CHECK
    // =========================================================================

    window.checkModuleHealth = function() {
        console.log('=== MODULE HEALTH CHECK ===');
        REQUIRED_MODULES.forEach(({ name, module }) => {
            const status = module ? 'OK' : 'MISSING';
            const color = module ? 'color: green' : 'color: red';
            console.log(`%c[${status}] ${name}`, color);
        });

        if (typeof REFRESH !== 'undefined') {
            console.log('REFRESH stats:', REFRESH.stats);
        }

        console.log('===========================');
    };

    // =========================================================================
    // KEYBOARD SHORTCUTS INTEGRATION
    // =========================================================================

    // The main keyboard handler remains in app.js, but modules can register
    // their own shortcuts here if needed
    window.MODULE_SHORTCUTS = {
        'KeyM': () => typeof CONTROL_BAR !== 'undefined' && CONTROL_BAR.toggle(),  // M for Mapping
        'Backquote': () => typeof CONTROL_BAR !== 'undefined' && CONTROL_BAR.toggle(),  // ` (backtick)
    };

    // =========================================================================
    // INITIALIZATION MESSAGE
    // =========================================================================

    console.log('[MAIN] Entry point loaded. Modules ready for initialization.');

})();


// ═══ MODULE: modules/circuit-breaker.js ═══
/**
 * CIRCUIT BREAKER MODULE
 *
 * Runtime self-test system that validates all UI controls work.
 * Runs a sequence of interactions and checks if they produce effects.
 *
 * Usage:
 *   CIRCUIT.runAll()           // Run all tests
 *   CIRCUIT.test('edge-opacity') // Test specific control
 *   CIRCUIT.report()           // Get test results
 */

const CIRCUIT = (function() {
    'use strict';

    // Test results storage
    const _results = new Map();
    let _running = false;

    // =========================================================================
    // TEST DEFINITIONS
    // Each test: { name, type, trigger, validate, cleanup? }
    // =========================================================================

    const TESTS = [
        // --- EDGE CONTROLS ---
        {
            name: 'edge-opacity',
            type: 'slider',
            elementId: 'cfg-edge-opacity',
            trigger: (el) => {
                el.value = '0.8';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                return typeof APPEARANCE_STATE !== 'undefined' &&
                       APPEARANCE_STATE.edgeOpacity === 0.8;
            },
            cleanup: (el) => {
                el.value = '0.6';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            }
        },
        {
            name: 'edge-width',
            type: 'slider',
            elementId: 'cfg-edge-width',
            trigger: (el) => {
                el.value = '3.0';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                return typeof APPEARANCE_STATE !== 'undefined' &&
                       APPEARANCE_STATE.edgeWidth === 3.0;
            },
            cleanup: (el) => {
                el.value = '1.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            }
        },
        {
            name: 'edge-curvature',
            type: 'slider',
            elementId: 'cfg-edge-curve',
            trigger: (el) => {
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                return typeof APPEARANCE_STATE !== 'undefined' &&
                       APPEARANCE_STATE.edgeCurvature === 0.5;
            },
            cleanup: (el) => {
                el.value = '0';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            }
        },

        // --- NODE CONTROLS ---
        {
            name: 'node-size',
            type: 'slider',
            elementId: 'cfg-node-size',
            trigger: (el) => {
                el.value = '8';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                return typeof APPEARANCE_STATE !== 'undefined' &&
                       APPEARANCE_STATE.nodeScale === 8;
            },
            cleanup: (el) => {
                el.value = '5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            }
        },
        {
            name: 'node-opacity',
            type: 'slider',
            elementId: 'cfg-node-opacity',
            trigger: (el) => {
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                return typeof APPEARANCE_STATE !== 'undefined' &&
                       APPEARANCE_STATE.nodeOpacity === 0.5;
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            }
        },

        // --- TOGGLES ---
        {
            name: 'toggle-arrows',
            type: 'toggle',
            elementId: 'cfg-toggle-arrows',
            trigger: (el) => {
                window._arrowsActiveBefore = el.classList.contains('active');
                el.click();
            },
            validate: () => {
                const el = document.getElementById('cfg-toggle-arrows');
                if (!el) return false;
                // Check if toggle state actually changed
                const isActiveNow = el.classList.contains('active');
                return isActiveNow !== window._arrowsActiveBefore;
            },
            cleanup: (el) => {
                // Toggle back to original state
                el.click();
                delete window._arrowsActiveBefore;
            }
        },

        // --- PHYSICS CONTROLS ---
        {
            name: 'physics-charge',
            type: 'slider',
            elementId: 'physics-charge',
            trigger: (el) => {
                const originalValue = el.value;
                el.value = '-200';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                el._originalValue = originalValue;
            },
            validate: () => {
                // NOTE: sidebar.js bypasses PHYSICS_STATE and calls Graph directly
                // So we validate via Graph API, not PHYSICS_STATE
                if (typeof Graph === 'undefined' || !Graph.d3Force) return false;
                const chargeForce = Graph.d3Force('charge');
                if (!chargeForce || !chargeForce.strength) return false;
                // d3 charge force stores strength as function, call it to get value
                const strength = chargeForce.strength();
                return strength === -200;
            },
            cleanup: (el) => {
                if (el._originalValue) {
                    el.value = el._originalValue;
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }
        },

        // --- BUTTONS ---
        {
            name: 'btn-edge-mode',
            type: 'button',
            elementId: 'btn-edge-mode',
            trigger: (el) => {
                window._edgeModeBefore = typeof EDGE !== 'undefined' ? EDGE.mode : null;
                el.click();
            },
            validate: () => {
                if (typeof EDGE === 'undefined') return false;
                return EDGE.mode !== window._edgeModeBefore;
            },
            cleanup: () => {
                delete window._edgeModeBefore;
            }
        },
        // NOTE: btn-color-mode test REMOVED - element doesn't exist in template.html
        // Color mode is controlled via dropdown, not a button
        // See CIRCUIT_BREAKER_RECONNAISSANCE.md for details

        // --- DIMENSION TOGGLE ---
        {
            name: 'dimension-toggle',
            type: 'button',
            elementId: 'btn-2d',  // Fixed: was 'btn-dimension' which doesn't exist
            trigger: (el) => {
                window._is3dBefore = typeof IS_3D !== 'undefined' ? IS_3D : null;
                el.click();
            },
            validate: () => {
                // Check if IS_3D actually changed (may be async)
                if (typeof IS_3D === 'undefined') return false;
                return IS_3D !== window._is3dBefore;
            },
            cleanup: () => {
                // Toggle back
                const el = document.getElementById('btn-2d');
                if (el) el.click();
                delete window._is3dBefore;
            }
        },

        // --- VIEW MODE ---
        {
            name: 'view-mode-files',
            type: 'button',
            elementId: null, // Uses selector
            selector: '[data-mode="files"]',
            trigger: (el) => {
                el.click();
            },
            validate: () => {
                return typeof GRAPH_MODE !== 'undefined' && GRAPH_MODE === 'files';
            },
            cleanup: () => {
                const atomsBtn = document.querySelector('[data-mode="atoms"]');
                if (atomsBtn) atomsBtn.click();
            }
        }
    ];

    // =========================================================================
    // TEST RUNNER
    // =========================================================================

    async function runTest(testDef) {
        const result = {
            name: testDef.name,
            type: testDef.type,
            passed: false,
            error: null,
            elementFound: false
        };

        try {
            // Find element
            const el = testDef.elementId
                ? document.getElementById(testDef.elementId)
                : document.querySelector(testDef.selector);

            if (!el) {
                result.error = 'Element not found';
                return result;
            }
            result.elementFound = true;

            // Run trigger
            testDef.trigger(el);

            // Small delay for async effects
            await new Promise(r => setTimeout(r, 50));

            // Validate
            result.passed = testDef.validate();

            // Cleanup
            if (testDef.cleanup) {
                await new Promise(r => setTimeout(r, 50));
                testDef.cleanup(el);
            }

        } catch (err) {
            result.error = err.message;
            result.passed = false;
        }

        return result;
    }

    async function runAll() {
        if (_running) {
            console.warn('[CIRCUIT] Already running');
            return;
        }
        _running = true;
        _results.clear();

        console.log('%c[CIRCUIT] Starting control validation...', 'color: #4dd4ff; font-weight: bold');

        const startTime = performance.now();
        let passed = 0;
        let failed = 0;

        for (const test of TESTS) {
            const result = await runTest(test);
            _results.set(test.name, result);

            if (result.passed) {
                passed++;
                console.log(`  %c✓ ${test.name}`, 'color: #4ade80');
            } else {
                failed++;
                const reason = result.error || (!result.elementFound ? 'Element not found' : 'Validation failed');
                console.log(`  %c✗ ${test.name}: ${reason}`, 'color: #f87171');
            }

            // Small delay between tests
            await new Promise(r => setTimeout(r, 100));
        }

        const elapsed = (performance.now() - startTime).toFixed(0);
        const total = passed + failed;
        const pct = ((passed / total) * 100).toFixed(1);

        console.log('%c─────────────────────────────────────', 'color: #666');
        if (failed === 0) {
            console.log(`%c[CIRCUIT] ALL PASS: ${passed}/${total} controls (${elapsed}ms)`,
                'color: #4ade80; font-weight: bold');
        } else {
            console.log(`%c[CIRCUIT] ${passed}/${total} passed (${pct}%), ${failed} FAILED (${elapsed}ms)`,
                'color: #f87171; font-weight: bold');
        }

        _running = false;
        return { passed, failed, total, results: Object.fromEntries(_results) };
    }

    async function test(name) {
        const testDef = TESTS.find(t => t.name === name);
        if (!testDef) {
            console.error(`[CIRCUIT] Unknown test: ${name}`);
            return null;
        }
        const result = await runTest(testDef);
        _results.set(name, result);
        return result;
    }

    function report() {
        return Object.fromEntries(_results);
    }

    function listTests() {
        return TESTS.map(t => ({ name: t.name, type: t.type }));
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        runAll,
        test,
        report,
        listTests,
        get isRunning() { return _running; },
        TESTS
    };
})();

// Global shortcut
window.CIRCUIT = CIRCUIT;

console.log('[Module] CIRCUIT loaded - UI control validator');


// ═══ MAIN APPLICATION ═══
window.process = window.process || { env: { NODE_ENV: "production" } };
window.global = window.global || window;
// UMD globals: THREE, ForceGraph3D, pako already loaded
// Three.js addons attach to THREE global: THREE.ConvexGeometry
const ConvexGeometry = THREE.ConvexGeometry;
// Note: Post-processing (bloom) removed for simplicity - addons not available in r149+ UMD builds

// COMPRESSED_PAYLOAD: Base64-encoded gzipped JSON data
const COMPRESSED_PAYLOAD = "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";

// --------------------------------------------------------------------
// WEB WORKER: JSON Parsing Only (Decompression in main thread)
// OPTIMIZED: Main thread uses already-loaded pako, no duplicate CDN fetch
// --------------------------------------------------------------------
const workerScript = `
        self.onmessage = function(e) {
            const jsonStr = e.data;
            try {
                self.postMessage({status: 'PARSING...'});
                const data = JSON.parse(jsonStr);
                self.postMessage({status: 'ANALYZING COSMOS...', result: data});
            } catch (err) {
                self.postMessage({error: err.message});
            }
        };
        `;

// Initialize Worker (minimal - no pako needed)
const blob = new Blob([workerScript], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));

// OPTIMIZED: Decompress in main thread using already-loaded pako
function decompressPayload(payload) {
    // Update status
    const statusEl = document.getElementById('loader-status');
    if (statusEl) statusEl.innerText = 'DECOMPRESSING...';

    // 1. Decode Base64
    const charData = atob(payload);
    const binData = new Uint8Array(charData.length);
    for (let i = 0; i < charData.length; i++) {
        binData[i] = charData.charCodeAt(i);
    }

    // 2. Inflate using main thread's pako (already loaded from CDN)
    if (statusEl) statusEl.innerText = 'INFLATING...';
    const jsonStr = pako.inflate(binData, { to: 'string' });

    return jsonStr;
}

let FULL_GRAPH = null;
let Graph = null;
let DM = null;  // DataManager instance - initialized in initGraph()
let Legend = null;  // LegendManager instance - initialized in initGraph()
let CURRENT_DENSITY = 1; // Default: show all nodes
let ACTIVE_DATAMAPS = new Set();
let DATAMAP_CONFIGS = [];
let DATAMAP_INDEX = {};
let DATAMAP_UI = new Map();
let HOVERED_NODE = null;
// SELECTED_NODE_IDS - provided by selection.js module (getter to SELECT.ids)
let DATASET_KEY = 'default';
let GROUPS_STORAGE_KEY = 'collider_groups_default';
let GROUPS = [];
let ACTIVE_GROUP_ID = null;
// MARQUEE_ACTIVE, MARQUEE_START, MARQUEE_ADDITIVE, LAST_MARQUEE_END_TS - provided by selection.js module
let SELECTION_BOX = null;
const SELECTION_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
const GROUP_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
let SPACE_PRESSED = false;
let IS_3D = true;
let DIMENSION_TRANSITION = false;
// STARFIELD REMOVED - nodes ARE the stars, no need for confusing background dots
let BLOOM_PASS = null;
let BLOOM_STRENGTH = 0;
// EDGE_MODE - provided by edge-system.js module
let EDGE_DEFAULT_OPACITY = null;  // Initialized from appearance.tokens at runtime (token value: 0.08)

// PERF_MONITOR - provided by perf-monitor.js module (window.PERF, window.PERF_MONITOR)

// Initialize after DOM ready
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => PERF_MONITOR.init(), 100);
    // Initialize SidebarManager facade for sidebar controls
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
        SIDEBAR.init();
    }
});
let DEFAULT_LINK_DISTANCE = null;

// =================================================================
// THEME CONFIGURATION: Loaded from payload at runtime
// =================================================================
let THEME_CONFIG = {
    available: ['dark'],
    default: 'dark',
    current: 'dark',
    colors: {
        edge: {},
        viz: {},
        console: {},
        schemes: {}
    }
};

// Default color configs - will be overridden by payload tokens
// Edge mode configuration - populated from appearance.tokens at runtime
// Fallback values are defined in appearance.tokens.json:131-204
let EDGE_MODE_CONFIG = {
    resolution: {},
    weight: {},
    confidence: {},
    width: {},
    dim: {},
    opacity: null
};
// Edge type colors - populated from theme.tokens.json:501-512 at runtime
let EDGE_COLOR_CONFIG = {};
// FILE_COLOR_CONFIG, EDGE_RANGES, NODE_FILE_INDEX - provided by modules (file-viz.js, edge-system.js)
let NODE_COLOR_CONFIG = { tier: {}, ring: {}, unknown: '#666666' };

// Console logging colors - populated from theme config
let CONSOLE_COLORS = {
    success: '#4ade80',
    error: '#f87171',
    warning: '#ffaa00',
    info: '#4dd4ff'
};

// Viz colors for canvas and fallbacks - populated from theme config
let VIZ_COLORS = {
    canvasBg: '#03040a',
    nodeFallback: '#888888',
    edgeFallback: '#333333',
    groupHalo: '#88d0ff'
};
let FLOW_CONFIG = {};  // Flow mode settings from THE REMOTE CONTROL
window.GRAPH_MODE = 'atoms'; // atoms | files | hybrid - on window for FILE_VIZ access

// Layout stability: cache node positions to prevent re-randomization on toggles
let NODE_POSITION_CACHE = new Map();
let LAYOUT_FROZEN = false;  // When true, don't reheat simulation
let HINTS_ENABLED = true;   // Show mode toasts

// FILE_GRAPH, FILE_NODE_IDS, EXPANDED_FILES, FILE_EXPAND_MODE - provided by file-viz.js module
let LAST_FILTER_SUMMARY = null;
let FILE_NODE_POSITIONS = new Map();
let NODE_COLOR_MODE = 'tier';
let COLOR_TWEAKS = {
    hueShift: 0,
    chromaScale: 1,
    lightnessShift: 0
};
let VIS_FILTERS = {
    tiers: new Set(),
    rings: new Set(),
    roles: new Set(),
    edges: new Set(),
    families: new Set(),  // Atom families: LOG, DAT, ORG, EXE, EXT
    files: new Set(),     // File-based filtering
    layers: new Set(),    // D2_LAYER: Interface, Application, Core, Infrastructure, Test
    effects: new Set(),   // D6_EFFECT: Pure, Read, Write, ReadWrite
    edgeFamilies: new Set(), // Edge families: Structural, Dependency, Inheritance, Semantic, Temporal
    metadata: {
        showLabels: true,
        showFilePanel: true,
        showReportPanel: true,
        showEdges: true
    }
};
let SIDEBAR_STATE = {
    open: false,
    locked: false
};
let APPEARANCE_STATE = {
    nodeScale: 1,
    nodeOpacity: 1,
    labelSize: 1,
    showLabels: true,
    highlightSelected: true,
    edgeOpacity: null,
    edgeWidth: 1,
    edgeCurvature: 0,
    showArrows: false,
    gradientEdges: true,
    boundaryFill: null,
    boundaryWire: null,
    backgroundBase: null,
    backgroundBrightness: 1,
    fileLightness: null,
    clusterStrength: null,
    currentPreset: 'tier',
    colorMode: 'tier',
    sizeMode: 'fanout',
    edgeMode: 'type',
    // Amplifier: Power law exponent for visual contrast
    // γ=1 linear, γ>1 amplifies differences, γ<1 compresses
    amplifier: 1.0,
    amplifierTarget: 'all'  // 'all', 'edges', 'nodes', 'opacity'
};

// =====================================================================
// FILE BOUNDARY & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
// fileBoundaryMeshes, fileMode, fileVizMode - provided by file-viz.js module
let originalNodeColors = new Map();
let clusterForceActive = false;
let hullRedrawTimer = null;
let hullRedrawAttempts = 0;
const originalColorsForDim = new Map();
let flowMode = false; // Hoisted from line 7333

// REGISTRY - provided by registry.js module (window.REGISTRY)


// =================================================================
// GLOBAL CONSTANTS (Hoisted for safety)
// =================================================================
const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

// OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
const PENDULUM = {
    hue: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,        // Set from appearance.tokens
        gravity: null,        // Set from appearance.tokens
        length: 1.0,
        rotationSpeed: null   // Set from appearance.tokens
    },
    chroma: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,
        gravity: null,
        length: 1.0,
        center: null,
        amplitude: null
    },
    lightness: {
        phase: 0,
        speed: null,
        center: null,
        amplitude: null
    },
    ripple: {
        speed: null,
        scale: null
    },
    currentHue: Math.random() * 360,
    lastTime: 0,
    running: false
};
// =====================================================================
// HOVER & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
let _lastHoveredNodeId = null;
const selectionOriginals = new Map();

// amplify, amplifyContrast - provided by core.js module

// =====================================================================
// DATA MANAGER: Minimal runtime checks for deterministic self-test/parity
// =====================================================================

// =====================================================================
// COLOR ORCHESTRATOR: Centralized Color Intelligence System
// =====================================================================
// SINGLE SOURCE OF TRUTH for ALL colors in the visualization.
// Everything reads from here. OKLCH transforms apply here.
// =====================================================================
const ColorOrchestrator = {
    // =================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =================================================================
    palette: {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    },

    // =================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =================================================================
    transform: {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    },

    // =================================================================
    // INTERVAL MAPPINGS: For numeric data → color gradients
    // =================================================================
    intervals: {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        }
    },

    // =================================================================
    // CORE API: Get color with transforms applied
    // =================================================================
    get(dimension, category) {
        const base = this.palette[dimension]?.[category];
        if (!base) return this._toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray

        return this._applyTransform(base);
    },

    // Get color for a numeric value using interval mapping
    getInterval(intervalName, value) {
        const interval = this.intervals[intervalName];
        if (!interval) return this._toHex({ h: 0, c: 0.02, l: 0.40 });

        const stops = interval.stops;
        const v = Math.max(0, Math.min(1, value));

        // Find surrounding stops
        let lower = stops[0];
        let upper = stops[stops.length - 1];

        for (let i = 0; i < stops.length - 1; i++) {
            if (v >= stops[i].value && v <= stops[i + 1].value) {
                lower = stops[i];
                upper = stops[i + 1];
                break;
            }
        }

        // Interpolate between stops
        const range = upper.value - lower.value;
        const t = range > 0 ? (v - lower.value) / range : 0;

        const interpolated = {
            h: lower.h + (upper.h - lower.h) * t,
            c: lower.c + (upper.c - lower.c) * t,
            l: lower.l + (upper.l - lower.l) * t
        };

        return this._applyTransform(interpolated);
    },

    // Get raw OKLCH values (for advanced use)
    getRaw(dimension, category) {
        return this.palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
    },

    // Get all categories for a dimension
    getCategories(dimension) {
        return Object.keys(this.palette[dimension] || {});
    },

    // Get label for a category
    getLabel(dimension, category) {
        return this.palette[dimension]?.[category]?.label || category;
    },

    // =================================================================
    // TRANSFORM CONTROLS: Update OKLCH state
    // =================================================================
    setTransform(key, value) {
        if (key in this.transform) {
            this.transform[key] = value;
            this._notifySubscribers('transform-change', { key, value });
        }
    },

    setAllTransforms(transforms) {
        Object.assign(this.transform, transforms);
        this._notifySubscribers('transform-change', transforms);
    },

    resetTransforms() {
        this.transform = {
            hueShift: 0,
            chromaScale: 1.0,
            lightnessShift: 0,
            amplifier: 1.0
        };
        this._notifySubscribers('transform-change', this.transform);
    },

    // =================================================================
    // INTERNAL: Apply OKLCH transforms and convert to hex
    // =================================================================
    _applyTransform(oklch) {
        const t = this.transform;

        // Apply transforms
        let h = (oklch.h + t.hueShift + 360) % 360;
        let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
        let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

        // Apply amplifier to chroma for contrast
        if (t.amplifier !== 1) {
            c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
        }

        return this._toHex({ h, c, l });
    },

    _toHex(oklch) {
        // OKLCH to sRGB conversion (simplified)
        // Using CSS color conversion would be ideal, but this approximation works
        const { h, c, l } = oklch;

        // Convert OKLCH to approximate RGB
        const hRad = h * Math.PI / 180;
        const a = c * Math.cos(hRad);
        const b = c * Math.sin(hRad);

        // Simplified OKLab to linear RGB (approximate)
        const L = l;
        const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

        const l3 = l_ * l_ * l_;
        const m3 = m_ * m_ * m_;
        const s3 = s_ * s_ * s_;

        let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
        let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
        let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

        // Clamp and convert to sRGB
        const toSRGB = (x) => {
            x = Math.max(0, Math.min(1, x));
            return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
        };

        r = Math.round(toSRGB(r) * 255);
        g = Math.round(toSRGB(g) * 255);
        bl = Math.round(toSRGB(bl) * 255);

        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        bl = Math.max(0, Math.min(255, bl));

        return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
    },

    // =================================================================
    // REACTIVE SUBSCRIPTIONS
    // =================================================================
    _subscribers: [],

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    },

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    },

    // =================================================================
    // DEBUG: Log current state
    // =================================================================
    debug() {
        console.log('[ColorOrchestrator] Transform state:', this.transform);
        console.log('[ColorOrchestrator] Palette dimensions:', Object.keys(this.palette));
        console.log('[ColorOrchestrator] Interval mappings:', Object.keys(this.intervals));
    }
};

// Global alias for convenience
const Color = ColorOrchestrator;



// =====================================================================
// FLOATING PANEL CONTROL SYSTEM
// =====================================================================
// openPanel, closePanel, togglePanel - MOVED TO modules/panels.js
// (backward compat shims in panels.js)

// Wire up command bar and panel controls
function initCommandBar() {
    // Command bar buttons
    const cmdBtns = {
        'cmd-view': 'view',
        'cmd-filter': 'filter',
        'cmd-style': 'style',
        'cmd-settings': 'settings'
    };

    Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
        const btn = document.getElementById(btnId);
        if (btn) {
            btn.addEventListener('click', () => togglePanel(panelId));
        }
    });

    // Settings panel: Oval margin slider (debounced - apply 300ms after release)
    const ovalSlider = document.getElementById('oval-margin-slider');
    const ovalValue = document.getElementById('oval-margin-value');
    let ovalDebounceTimer = null;
    if (ovalSlider) {
        // Update display value immediately
        ovalSlider.addEventListener('input', (e) => {
            if (ovalValue) ovalValue.textContent = e.target.value + '%';
        });
        // Apply actual change only after 300ms pause (on mouseup/touchend)
        const applyOvalMargin = () => {
            clearTimeout(ovalDebounceTimer);
            ovalDebounceTimer = setTimeout(() => {
                const val = ovalSlider.value;
                document.documentElement.style.setProperty('--oval-margin', val + '%');
            }, 300);
        };
        ovalSlider.addEventListener('mouseup', applyOvalMargin);
        ovalSlider.addEventListener('touchend', applyOvalMargin);
        ovalSlider.addEventListener('change', applyOvalMargin);
    }

    // Oval debug toggle
    const toggleOvalDebug = document.getElementById('toggle-oval-debug');
    if (toggleOvalDebug) {
        toggleOvalDebug.addEventListener('click', () => {
            toggleOvalDebug.classList.toggle('active');
            const ovalDebug = document.querySelector('.oval-debug');
            if (ovalDebug) {
                ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
            }
        });
    }

    // ═══════════════════════════════════════════════════════════════════
    // STYLE PANEL SLIDERS - Connected to appearance system
    // ═══════════════════════════════════════════════════════════════════

    // Node Size Slider
    const nodeSizeSlider = document.getElementById('node-size-slider');
    const nodeSizeValue = document.getElementById('node-size-value');
    if (nodeSizeSlider) {
        nodeSizeSlider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            if (nodeSizeValue) nodeSizeValue.textContent = val.toFixed(1) + 'x';
            APPEARANCE_STATE.nodeScale = val;
            if (Graph) {
                Graph.nodeVal(node => (node.val || node.size || 1) * val);
            }
        });
    }

    // Edge Opacity Slider
    const edgeOpacitySlider = document.getElementById('edge-opacity-slider');
    const edgeOpacityValue = document.getElementById('edge-opacity-value');
    if (edgeOpacitySlider) {
        edgeOpacitySlider.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            if (edgeOpacityValue) edgeOpacityValue.textContent = val + '%';
            APPEARANCE_STATE.edgeOpacity = val / 100;
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
        });
    }

    // Density Slider (filter panel duplicate)
    const densitySlider2 = document.getElementById('density-slider2');
    const densityValue2 = document.getElementById('density-value2');
    if (densitySlider2) {
        densitySlider2.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            if (densityValue2) densityValue2.textContent = val + '%';
            CURRENT_DENSITY = val;
            refreshGraph();
        });
    }

    // Toggle switches
    document.querySelectorAll('.toggle-switch').forEach(toggle => {
        toggle.addEventListener('click', () => {
            toggle.classList.toggle('active');
        });
    });

    // Segmented controls
    document.querySelectorAll('.segmented-control').forEach(control => {
        control.querySelectorAll('.segment').forEach(segment => {
            segment.addEventListener('click', () => {
                control.querySelectorAll('.segment').forEach(s => s.classList.remove('active'));
                segment.classList.add('active');

                // Handle dimension change
                if (control.id === 'dim-control') {
                    const dim = segment.dataset.dim;
                    if (dim === '2') {
                        IS_3D = false;
                        if (Graph) Graph.numDimensions(2);
                    } else {
                        IS_3D = true;
                        if (Graph) Graph.numDimensions(3);
                    }
                }

                // Handle node color mode
                if (control.id === 'node-color-control') {
                    const mode = segment.dataset.mode;
                    if (mode && typeof setNodeColorMode === 'function') {
                        setNodeColorMode(mode);
                    }
                }

                // Handle edge color mode
                if (control.id === 'edge-color-control') {
                    const mode = segment.dataset.mode;
                    if (mode) {
                        EDGE_MODE = mode;
                        if (typeof applyEdgeMode === 'function') applyEdgeMode();
                    }
                }

                // Handle panel layout
                if (control.id === 'layout-control') {
                    const layout = segment.dataset.layout;
                    if (layout) {
                        document.body.setAttribute('data-layout', layout);
                        console.log('[Layout] Switched to:', layout);
                    }
                }
            });
        });
    });

    // ═══════════════════════════════════════════════════════════════════
    // COMMAND BAR DIRECT ACTIONS (no proxy clicks - call functions directly)
    // ═══════════════════════════════════════════════════════════════════

    // File mode toggle
    REGISTRY.register('cmd-files2', () => {
        if (typeof setFileModeState === 'function') {
            const newState = !fileMode;
            setFileModeState(newState);
            // Visual feedback is handled by setFileModeState, but we toggle active here for instant response
            const btn = document.getElementById('cmd-files2');
            if (btn) btn.classList.toggle('active', newState);
        } else {
            console.warn('setFileModeState function missing');
        }
    }, { desc: 'Toggle File Boundaries Mode' });

    // Flow mode toggle
    REGISTRY.register('cmd-flow2', () => {
        if (typeof toggleFlowMode === 'function') {
            toggleFlowMode();
            // Visual feedback usually managed by toggle function
            const btn = document.getElementById('cmd-flow2');
            if (btn) btn.classList.toggle('active', flowMode);
        }
    }, { desc: 'Toggle Flow Mode' });

    // 3D toggle
    REGISTRY.register('cmd-3d', () => {
        if (typeof toggleDimensions === 'function') {
            toggleDimensions();
        } else {
            // Direct implementation fallback
            IS_3D = !IS_3D;
            if (Graph) Graph.numDimensions(IS_3D ? 3 : 2);
            const btnDim = document.getElementById('btn-dimensions');
            if (btnDim) btnDim.textContent = IS_3D ? '2D' : '3D';
        }
        const btn = document.getElementById('cmd-3d');
        if (btn) btn.classList.toggle('active', IS_3D);

        // Update dim-control if exists
        const dimControl = document.getElementById('dim-control');
        if (dimControl) {
            dimControl.querySelectorAll('.segment').forEach(s => {
                s.classList.toggle('active', s.dataset.dim === (IS_3D ? '3' : '2'));
            });
        }
    }, { desc: 'Toggle 2D/3D View' });

    console.log('[CommandBar] Initialized with direct function calls');
}

// Build chip buttons for filter groups
function buildChipGroup(containerId, items, stateSet, onUpdate) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.innerHTML = '';

    // "ALL" chip
    const allChip = document.createElement('button');
    allChip.className = 'chip active';
    allChip.textContent = 'ALL';
    allChip.addEventListener('click', () => {
        // Toggle all on/off
        const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
        if (allActive) {
            stateSet.clear();
            container.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
        } else {
            items.forEach((count, key) => stateSet.add(key));
            container.querySelectorAll('.chip').forEach(c => c.classList.add('active'));
        }
        if (onUpdate) onUpdate();
    });
    container.appendChild(allChip);

    // Individual chips
    items.forEach((count, key) => {
        const chip = document.createElement('button');
        chip.className = 'chip' + (stateSet.has(key) ? ' active' : '');
        chip.innerHTML = `${key}<span class="chip-count">${count}</span>`;
        chip.addEventListener('click', () => {
            if (stateSet.has(key)) {
                stateSet.delete(key);
                chip.classList.remove('active');
            } else {
                stateSet.add(key);
                chip.classList.add('active');
            }
            // Update "ALL" chip state
            const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
            allChip.classList.toggle('active', allActive);
            if (onUpdate) onUpdate();
        });
        container.appendChild(chip);
    });
}

// Populate filter chips in floating panels
function populateFilterChips() {
    if (!DM) return;  // ALL DATA FROM DM

    // Use DM cached aggregations (O(1) lookups)
    const tierCounts = DM.getTierCounts();
    const ringCounts = DM.getRingCounts();
    const edgeCounts = DM.getEdgeTypeCounts();

    buildChipGroup('chips-tiers', tierCounts, VIS_FILTERS.tiers, refreshGraph);
    buildChipGroup('chips-rings', ringCounts, VIS_FILTERS.rings, refreshGraph);
    buildChipGroup('chips-edges', edgeCounts, VIS_FILTERS.edges, refreshGraph);
}

// renderLegendSection, renderAllLegends - MOVED TO modules/legend-manager.js

// Debounce wrapper to prevent DOM thrashing during rapid updates
let _legendDebounceTimer = null;
const _originalRenderAllLegends = renderAllLegends;
renderAllLegends = function () {
    if (_legendDebounceTimer) clearTimeout(_legendDebounceTimer);
    _legendDebounceTimer = setTimeout(() => {
        _originalRenderAllLegends();
        _legendDebounceTimer = null;
    }, 100); // 100ms debounce
};

// =====================================================================
// HUD LAYOUT MANAGER: MIGRATED TO modules/layout.js
// =====================================================================
// HudLayoutManager (390 lines) has been migrated to modules/layout.js
// which provides the LAYOUT module with:
//   - All original panel placement functionality
//   - NEW: Toast/control-bar collision detection
//   - NEW: Min-width graph validation
//   - NEW: Debug overlay (Ctrl+Shift+L)
//   - NEW: Component registration system
//
// Backward compatibility: window.HudLayoutManager = LAYOUT (alias)
// =====================================================================

worker.onmessage = function (e) {
    if (e.data.status && !e.data.result) {
        document.getElementById('loader-status').innerText = e.data.status;
    } else if (e.data.error) {
        document.getElementById('loader-status').innerText = "ERROR: " + e.data.error;
        document.getElementById('loader-status').style.color = "red";
    } else if (e.data.result) {
        FULL_GRAPH = e.data.result;
        FILE_GRAPH = null;
        FILE_NODE_POSITIONS = new Map();
        EXPANDED_FILES.clear();
        window.GRAPH_MODE = 'atoms';
        document.getElementById('loader-status').innerText = "INITIALIZING VISUALIZATION...";
        initGraph(FULL_GRAPH);
    }
};

// Start Work: Decompress in main thread, then send JSON string to worker for parsing
try {
    const jsonStr = decompressPayload(COMPRESSED_PAYLOAD);
    worker.postMessage(jsonStr);
} catch (err) {
    document.getElementById('loader-status').innerText = "ERROR: " + err.message;
    document.getElementById('loader-status').style.color = "red";
    console.error('[Decompression] Failed:', err);
}

// =====================================================================
// 2D CANVAS FALLBACK: Used when WebGL is unavailable
// =====================================================================
function initFallback2D(container, graphData, fullData) {
    console.log('[2D Fallback] Initializing canvas renderer');
    showToast('WebGL unavailable - using 2D fallback');

    const loader = document.getElementById('loader');
    if (loader) loader.style.display = 'none';

    // Update HUD stats even in 2D fallback mode
    updateHudStats(fullData);

    container.innerHTML = '';
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.background = VIZ_COLORS.canvasBg;
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    let width = container.clientWidth || window.innerWidth;
    let height = container.clientHeight || window.innerHeight;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    // Layout: simple force-directed positions
    const nodes = graphData.nodes || [];
    const links = graphData.links || [];
    const nodeMap = new Map();

    nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        const radius = Math.min(width, height) * 0.35;
        n._x = width / 2 + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);
        n._y = height / 2 + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5);
        n._vx = 0;
        n._vy = 0;
        nodeMap.set(n.id, n);
    });

    // Camera state
    let camX = 0, camY = 0, zoom = 1;
    let dragging = false, lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mousemove', e => {
        if (!dragging) return;
        camX += (e.clientX - lastX) / zoom;
        camY += (e.clientY - lastY) / zoom;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        zoom = Math.max(0.1, Math.min(5, zoom * factor));
    }, { passive: false });

    function toScreen(x, y) {
        return {
            x: (x + camX - width / 2) * zoom + width / 2,
            y: (y + camY - height / 2) * zoom + height / 2
        };
    }

    function parseColor(c) {
        if (typeof c === 'number') {
            return '#' + c.toString(16).padStart(6, '0');
        }
        return c || VIZ_COLORS.nodeFallback;
    }

    function render() {
        ctx.fillStyle = VIZ_COLORS.canvasBg;
        ctx.fillRect(0, 0, width, height);

        // Draw edges
        ctx.strokeStyle = 'rgba(100,100,100,0.3)';
        ctx.lineWidth = 0.5;
        for (const link of links) {
            const src = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
            const tgt = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);
            if (!src || !tgt) continue;
            const p1 = toScreen(src._x, src._y);
            const p2 = toScreen(tgt._x, tgt._y);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // Draw nodes
        for (const node of nodes) {
            const p = toScreen(node._x, node._y);
            const r = Math.max(2, (node.val || 1) * zoom * 0.5);
            ctx.fillStyle = parseColor(node.color);
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Info overlay
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '11px monospace';
        ctx.fillText('2D Fallback Mode (WebGL unavailable)', 10, 20);
        ctx.fillText('Drag to pan, scroll to zoom', 10, 35);
        ctx.fillText(`Nodes: ${nodes.length} | Edges: ${links.length}`, 10, 50);

        requestAnimationFrame(render);
    }

    function resize() {
        width = container.clientWidth || window.innerWidth;
        height = container.clientHeight || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', resize);
    render();

    // Initialize DataManager (required for UI controls)
    DM = new DataManager();
    DM.init(fullData);
    window.DM = DM;

    // Setup UI controls (they work independently of 3D graph)
    setupControls(fullData);
    setupReport(fullData);
    setupAIInsights(fullData);
    setupMetrics(fullData);
    setupHudFade();
    setupDimensionToggle();

    // Update stats with actual node/edge counts
    updateHudStats(graphData);
}

function initGraph(data) {
    // =================================================================
    // DATA MANAGER: Self-test + parity checks
    // =================================================================
    DM = new DataManager();
    DM.init(data);
    window.DM = DM;
    DM.selfTest();
    runDmParity(DM, data);

    // =================================================================
    // HUD STATS: Populate header and stats panel with graph data
    // =================================================================
    updateHudStats(data);

    // =================================================================
    // SIDEBAR: Populate filter chips from loaded data
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.populateFilterChips) {
        SIDEBAR.populateFilterChips(data);
    }

    // =================================================================
    // SIDEBAR: Apply deferred view mode (files mode if saved in localStorage)
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.applyDeferredViewMode) {
        SIDEBAR.applyDeferredViewMode();
    }

    // =================================================================
    // TOKEN-DRIVEN CONFIG: Extract from payload
    // =================================================================
    const physicsConfig = data.physics || {};
    const appearanceConfig = data.appearance || {};
    window.APPEARANCE_CONFIG = appearanceConfig;

    // =================================================================
    // THEME CONFIG: Load theme configuration for runtime switching
    // =================================================================
    if (data.theme_config) {
        THEME_CONFIG = {
            ...THEME_CONFIG,
            available: data.theme_config.available || ['dark'],
            default: data.theme_config.default || 'dark',
            current: data.theme_config.default || 'dark',
            colors: data.theme_config.colors || THEME_CONFIG.colors
        };

        // Apply edge colors from theme config
        if (THEME_CONFIG.colors.edge) {
            EDGE_COLOR_CONFIG = { ...EDGE_COLOR_CONFIG, ...THEME_CONFIG.colors.edge };
        }

        // Apply viz colors from theme config
        if (THEME_CONFIG.colors.viz) {
            const viz = THEME_CONFIG.colors.viz;
            VIZ_COLORS = {
                canvasBg: viz['canvas-bg'] || VIZ_COLORS.canvasBg,
                nodeFallback: viz['node-fallback'] || VIZ_COLORS.nodeFallback,
                edgeFallback: viz['edge-fallback'] || VIZ_COLORS.edgeFallback,
                groupHalo: viz['group-halo'] || VIZ_COLORS.groupHalo
            };
        }

        // Apply console colors from theme config
        if (THEME_CONFIG.colors.console) {
            CONSOLE_COLORS = { ...CONSOLE_COLORS, ...THEME_CONFIG.colors.console };
        }

        console.log(`%c[Theme] Loaded: ${THEME_CONFIG.available.join(', ')}`, `color: ${CONSOLE_COLORS.info}; font-weight: bold`);
    }
    const simulation = physicsConfig.simulation || {};
    const background = appearanceConfig.background || {};
    // const stars = background.stars || {};  // REMOVED - starfield feature deleted
    const bloom = background.bloom || {};
    // NEW: Render, highlight, flow_mode from THE REMOTE CONTROL
    const renderConfig = appearanceConfig.render || {};
    const highlightConfig = appearanceConfig.highlight || {};
    FLOW_CONFIG = appearanceConfig.flow_mode || {};

    // Merge animation tokens into PENDULUM (T004)
    const animationConfig = appearanceConfig.animation || {};
    if (animationConfig.hue) {
        PENDULUM.hue.damping = animationConfig.hue.damping ?? 0.9995;
        PENDULUM.hue.gravity = animationConfig.hue.speed ?? 0.0008;
        PENDULUM.hue.rotationSpeed = animationConfig.hue.rotation ?? 0.8;
    }
    if (animationConfig.chroma) {
        PENDULUM.chroma.damping = animationConfig.chroma.damping ?? 0.998;
        PENDULUM.chroma.gravity = animationConfig.chroma.gravity ?? 0.0004;
        PENDULUM.chroma.center = animationConfig.chroma.center ?? 0.32;
        PENDULUM.chroma.amplitude = animationConfig.chroma.amplitude ?? 0.08;
    }
    if (animationConfig.lightness) {
        PENDULUM.lightness.speed = animationConfig.lightness.speed ?? 0.02;
        PENDULUM.lightness.center = animationConfig.lightness.center ?? 82;
        PENDULUM.lightness.amplitude = animationConfig.lightness.amplitude ?? 10;
    }
    if (animationConfig.ripple) {
        PENDULUM.ripple.speed = animationConfig.ripple.speed ?? 0.035;
        PENDULUM.ripple.scale = animationConfig.ripple.scale ?? 200;
    }
    const edgeModes = appearanceConfig.edge_modes || {};
    EDGE_MODE_CONFIG = {
        resolution: edgeModes.resolution || { internal: '#4dd4ff', external: '#ff6b6b', unresolved: '#9aa0a6', unknown: '#666666' },
        weight: edgeModes.weight || { hue_min: 210, hue_max: 50, saturation: 45, lightness: 42 },
        confidence: edgeModes.confidence || { hue_min: 20, hue_max: 120, saturation: 45, lightness: 44 },
        width: edgeModes.width || { base: 0.6, weight_scale: 2.0, confidence_scale: 1.5 },
        dim: edgeModes.dim || { interfile_factor: 0.25 },
        opacity: (typeof edgeModes.opacity === 'number') ? edgeModes.opacity : 0.08
    };

    FILE_COLOR_CONFIG = Object.assign({}, FILE_COLOR_CONFIG, appearanceConfig.file_color || {});
    // Token value 0.08 from appearance.tokens.json:202, fallback only if token system fails
    EDGE_DEFAULT_OPACITY =
        (typeof EDGE_MODE_CONFIG.opacity === 'number') ? EDGE_MODE_CONFIG.opacity : 0.08;
    const boundaryConfig = appearanceConfig.boundary || {};
    APPEARANCE_STATE.edgeOpacity = EDGE_DEFAULT_OPACITY;
    APPEARANCE_STATE.boundaryFill = boundaryConfig.fill_opacity ?? APPEARANCE_STATE.boundaryFill;
    APPEARANCE_STATE.boundaryWire = boundaryConfig.wire_opacity ?? APPEARANCE_STATE.boundaryWire;
    APPEARANCE_STATE.backgroundBase = background.color || '#000000';
    APPEARANCE_STATE.fileLightness = FILE_COLOR_CONFIG.lightness ?? APPEARANCE_STATE.fileLightness;
    const nodeColor = appearanceConfig.node_color || {};
    NODE_COLOR_CONFIG = {
        tier: nodeColor.tier || {},
        ring: nodeColor.ring || {},
        unknown: nodeColor.unknown || '#666666'
    };
    const edgeColor = appearanceConfig.edge_color || {};
    EDGE_COLOR_CONFIG = {
        default: edgeColor.default || '#333333',
        calls: edgeColor.calls || '#4dd4ff',
        contains: edgeColor.contains || '#00ff9d',
        uses: edgeColor.uses || '#ffb800',
        imports: edgeColor.imports || '#9aa0a6',
        inherits: edgeColor.inherits || '#ff6b6b'
    };

    // Initial Filter: show full graph
    const filtered = filterGraph(data, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);

    // ═══════════════════════════════════════════════════════════════════
    // DATA PREP FOR ANIMATIONS: Assign file indices for wave patterns
    // ═══════════════════════════════════════════════════════════════════
    const fileMap = new Map();
    let nextFileIdx = 0;
    filtered.nodes.forEach(node => {
        // Extract filename from ID (assuming file path is in ID or explicit file prop)
        const file = node.file || (node.id.includes('/') ? node.id.split(':')[0] : 'unknown');
        if (!fileMap.has(file)) fileMap.set(file, nextFileIdx++);
        node.file_idx = fileMap.get(file);
    });

    const div = document.getElementById('3d-graph');

    // ═══════════════════════════════════════════════════════════════════
    // GRADIENT EDGES: Custom THREE.js lines with vertex colors
    // Creates beautiful gradients from source to target node colors
    // ═══════════════════════════════════════════════════════════════════
    let GRADIENT_EDGES_ENABLED = true;  // Toggle for gradient edges

    function hexToRgb(hex) {
        // Convert hex color to RGB array [0-1, 0-1, 0-1]
        if (typeof hex === 'number') {
            return [
                ((hex >> 16) & 255) / 255,
                ((hex >> 8) & 255) / 255,
                (hex & 255) / 255
            ];
        }
        if (typeof hex === 'string') {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                ((num >> 16) & 255) / 255,
                ((num >> 8) & 255) / 255,
                (num & 255) / 255
            ];
        }
        return [0.5, 0.5, 0.5];  // Default gray
    }

    function createGradientEdge(link) {
        // Get source and target nodes
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        // Get colors from nodes (using current color mode)
        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        // Create geometry with 2 vertices
        const geometry = new THREE.BufferGeometry();

        // Positions will be updated by linkPositionUpdate
        const positions = new Float32Array([0, 0, 0, 0, 0, 0]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Vertex colors: source color at start, target color at end
        const colors = new Float32Array([
            srcRgb[0], srcRgb[1], srcRgb[2],  // Source vertex color
            tgtRgb[0], tgtRgb[1], tgtRgb[2]   // Target vertex color
        ]);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Material with vertex colors
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: link.opacity ?? EDGE_DEFAULT_OPACITY,
            linewidth: 1  // Note: linewidth > 1 only works on some platforms
        });

        return new THREE.Line(geometry, material);
    }

    function updateGradientEdge(line, link, coords) {
        // Update line positions
        const posArr = line.geometry.attributes.position.array;
        posArr[0] = coords.start.x || 0;
        posArr[1] = coords.start.y || 0;
        posArr[2] = coords.start.z || 0;
        posArr[3] = coords.end.x || 0;
        posArr[4] = coords.end.y || 0;
        posArr[5] = coords.end.z || 0;
        line.geometry.attributes.position.needsUpdate = true;

        // Update colors based on current node colors
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        const colArr = line.geometry.attributes.color.array;
        colArr[0] = srcRgb[0]; colArr[1] = srcRgb[1]; colArr[2] = srcRgb[2];
        colArr[3] = tgtRgb[0]; colArr[4] = tgtRgb[1]; colArr[5] = tgtRgb[2];
        line.geometry.attributes.color.needsUpdate = true;
    }

    // Refresh all gradient edge colors (call when node color mode changes)
    function refreshGradientEdgeColors() {
        if (!GRADIENT_EDGES_ENABLED || !Graph) return;
        // Force rebuild of all link objects to update colors
        Graph.linkThreeObject(link => createGradientEdge(link));
    }

    // Make it globally accessible for color mode changes
    window.refreshGradientEdgeColors = refreshGradientEdgeColors;

    // TOKEN-DRIVEN: Read render config from THE REMOTE CONTROL
    const dimensions = renderConfig.dimensions || 3;
    const nodeRes = renderConfig.nodeResolution || 8;

    try {
        Graph = ForceGraph3D({
            rendererConfig: {
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            }
        })
            (div)
            .graphData(filtered)
            .numDimensions(dimensions)
            .backgroundColor(toColorNumber(background.color, 0x000000))
            .nodeLabel('name')
            .nodeColor(node => toColorNumber(node.color, 0x888888))
            .nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale)
            // ═══════════════════════════════════════════════════════════════════
            // GRADIENT EDGES: Custom THREE.Line with vertex colors
            // Each edge smoothly transitions from source node color to target node color
            // ═══════════════════════════════════════════════════════════════════
            .linkThreeObject(link => GRADIENT_EDGES_ENABLED ? createGradientEdge(link) : null)
            .linkPositionUpdate((line, coords, link) => {
                if (GRADIENT_EDGES_ENABLED && line) {
                    updateGradientEdge(line, link, coords);
                }
                return true;  // Keep default behavior for non-gradient
            })
            .linkColor(link => GRADIENT_EDGES_ENABLED ? null : toColorNumber(getEdgeColor(link), 0x222222))
            .linkOpacity(link => GRADIENT_EDGES_ENABLED ? 0 : (link.opacity ?? EDGE_DEFAULT_OPACITY))
            .nodeThreeObjectExtend(true)
            .nodeThreeObject(node => ensureNodeOverlays(node))
            .nodeResolution(Math.max(nodeRes, 16))
            .linkResolution(6)
            .showNavInfo(false)
            .warmupTicks(simulation.warmupTicks || 30)
            .cooldownTicks(simulation.cooldownTicks || 0)
            .onNodeHover(node => handleNodeHover(node, data))
            .onNodeClick((node, event) => handleNodeClick(node, event))
            .onBackgroundClick(() => maybeClearSelection())
            // ═══════════════════════════════════════════════════════════════════
            // GROUP DRAG: Move all selected nodes together, maintaining offsets
            // Note: onNodeDragStart doesn't exist - detect start via flag
            // ═══════════════════════════════════════════════════════════════════
            .onNodeDrag((node, translate) => {
                // Only handle group drag if multiple nodes selected and this node is selected
                if (SELECTED_NODE_IDS.size > 1 && SELECTED_NODE_IDS.has(node.id)) {
                    // First drag frame: store relative offsets
                    if (!window._groupDragActive) {
                        window._groupDragActive = true;
                        window._groupDragOffsets = new Map();
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            if (SELECTED_NODE_IDS.has(n.id) && n.id !== node.id) {
                                window._groupDragOffsets.set(n.id, {
                                    dx: (n.x || 0) - (node.x || 0),
                                    dy: (n.y || 0) - (node.y || 0),
                                    dz: (n.z || 0) - (node.z || 0)
                                });
                            }
                        });
                    }
                    // Move all other selected nodes with their offsets
                    if (window._groupDragOffsets) {
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            const offset = window._groupDragOffsets.get(n.id);
                            if (offset) {
                                n.fx = node.x + offset.dx;
                                n.fy = node.y + offset.dy;
                                n.fz = node.z + offset.dz;
                            }
                        });
                    }
                }
            })
            .onNodeDragEnd(node => {
                // Clear group drag state
                window._groupDragActive = false;
                window._groupDragOffsets = null;
                // Fix all selected nodes at their final positions
                if (SELECTED_NODE_IDS.size > 0) {
                    const nodes = Graph.graphData().nodes;
                    nodes.forEach(n => {
                        if (SELECTED_NODE_IDS.has(n.id)) {
                            n.fx = n.x; n.fy = n.y; n.fz = n.z;
                        }
                    });
                }
            })
            .onEngineStop(() => {
                // Physics-dependent operations (run after simulation stabilizes)
                drawFileBoundaries(data);
                // LAYOUT STABILITY: Freeze layout after initial simulation completes
                if (!LAYOUT_FROZEN) {
                    saveNodePositions();
                    freezeLayout();
                }
            });
    } catch (err) {
        console.error('[WebGL] Failed to initialize 3D graph:', err);
        initFallback2D(div, filtered, data);
        return;
    }

    window.Graph = Graph;

    // FIX: Drift on resize
    // Updates Graph renderer size when window creates
    window.addEventListener('resize', () => {
        if (Graph) {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        }
    });

    // OPTIMIZATION: Hide loader immediately after Graph creation (don't wait for physics)
    // This makes the visualization appear 200-500ms faster
    document.getElementById('loader').style.display = 'none';

    // =================================================================
    // RENDERER QUALITY: Enable anti-aliasing and high DPI
    // =================================================================
    const renderer = Graph.renderer();
    if (renderer) {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Enable high quality rendering
        renderer.antialias = true;
        renderer.alpha = true;
        renderer.powerPreference = 'high-performance';
    }

    initSelectionState(data);
    setupSelectionInteractions();
    updateSelectionVisuals();

    // =================================================================
    // CONTROLS: keep default camera behavior, enable damping
    // =================================================================
    const controls = Graph.controls();
    if (controls) {
        // TOKEN-DRIVEN: Read from payload (if available), else use defaults
        // Allow remote configuration of mouse buttons and damping
        const navConfig = data.config?.controls || data.controls || {};

        controls.enableDamping = navConfig.enableDamping !== undefined ? navConfig.enableDamping : true;
        controls.dampingFactor = navConfig.dampingFactor || 0.1;
        controls.enableRotate = navConfig.enableRotate !== undefined ? navConfig.enableRotate : true;
        controls.enablePan = navConfig.enablePan !== undefined ? navConfig.enablePan : true;

        // Mouse Buttons: Map generic names to integer constants
        // 0: ROTATE, 1: DOLLY (Zoom), 2: PAN
        const defaultButtons = {
            LEFT: 2, // PAN
            MIDDLE: 1, // DOLLY
            RIGHT: 0 // ROTATE
        };

        if (navConfig.mouseButtons) {
            controls.mouseButtons = {
                LEFT: navConfig.mouseButtons.LEFT ?? defaultButtons.LEFT,
                MIDDLE: navConfig.mouseButtons.MIDDLE ?? defaultButtons.MIDDLE,
                RIGHT: navConfig.mouseButtons.RIGHT ?? defaultButtons.RIGHT
            };
        } else {
            controls.mouseButtons = defaultButtons;
        }

        // Spacebar toggling disabled to ensure stability
    }

    // =================================================================
    // TOKEN-DRIVEN: Force Configuration
    // =================================================================
    const forces = physicsConfig.forces || {};
    if (forces.charge?.enabled) {
        Graph.d3Force('charge').strength(forces.charge.strength || -120);
        Graph.d3Force('charge').distanceMax(forces.charge.distanceMax || 500);
    }
    if (forces.link?.enabled) {
        const linkDistance = forces.link.distance || 50;
        Graph.d3Force('link').distance(linkDistance);
        DEFAULT_LINK_DISTANCE = linkDistance;
    }
    if (forces.center?.enabled) {
        Graph.d3Force('center').strength(forces.center.strength || 0.05);
    }

    // =================================================================
    // STARFIELD REMOVED - Nodes ARE the stars
    // Rationale: Adding background dots creates visual confusion with actual data nodes.
    // The cosmos metaphor works better when the data itself forms the starfield.
    // =================================================================

    // =================================================================
    // TOKEN-DRIVEN: Bloom Post-Processing (DISABLED - UMD build compatibility)
    // Post-processing addons require ES modules; using UMD for file:// support
    // =================================================================
    // Bloom disabled for compatibility - visualization works without it

    // Setup Hud Controls (TOKEN-DRIVEN)
    // OPTIMIZATION: Defer UI setup to next frame so graph renders first
    // This makes the visualization appear 150-200ms faster
    Promise.resolve().then(() => {
        setupControls(data);
        setupReport(data);
        setupAIInsights(data);
        setupMetrics(data);
        setupHudFade();
        setupDimensionToggle();
        applyEdgeMode();

        // SELF-TEST: Deterministic validation of UI controls (deferred)
        runSelfTest(data);
    });
}

function runSelfTest(data) {
    const results = {
        timestamp: new Date().toISOString(),
        passed: [],
        failed: []
    };

    const test = (name, condition) => {
        if (condition) {
            results.passed.push(name);
        } else {
            results.failed.push(name);
        }
    };

    // Test 1: Core UI structure (dual-sidebar layout)

    // Main layout containers
    test('header-exists', !!document.getElementById('header'));
    test('left-sidebar-exists', !!document.getElementById('left-sidebar'));
    test('right-sidebar-exists', !!document.getElementById('right-sidebar'));
    test('graph-container-exists', !!document.getElementById('3d-graph'));

    // Header stats
    test('stat-nodes-exists', !!document.getElementById('stat-nodes'));
    test('stat-edges-exists', !!document.getElementById('stat-edges'));
    test('target-name-exists', !!document.getElementById('target-name'));

    // Left sidebar configuration sections
    test('section-node-config-exists', !!document.getElementById('section-node-config'));
    test('section-edge-config-exists', !!document.getElementById('section-edge-config'));
    test('section-layout-exists', !!document.getElementById('section-layout'));
    test('section-physics-exists', !!document.getElementById('section-physics'));
    test('section-filters-exists', !!document.getElementById('section-filters'));
    test('section-actions-exists', !!document.getElementById('section-actions'));

    // Left sidebar action buttons
    test('btn-reset-exists', !!document.getElementById('btn-reset'));
    test('btn-screenshot-exists', !!document.getElementById('btn-screenshot'));
    test('btn-2d-exists', !!document.getElementById('btn-2d'));
    test('btn-freeze-exists', !!document.getElementById('btn-freeze'));

    // Right sidebar panels
    test('hover-panel-exists', !!document.getElementById('hover-panel'));
    test('section-schemes-exists', !!document.getElementById('section-schemes'));
    test('section-color-exists', !!document.getElementById('section-color'));

    // Selection elements
    test('selection-count-exists', !!document.getElementById('selection-count'));
    test('selection-list-exists', !!document.getElementById('selection-list'));

    // Stats panel
    test('stats-nodes-exists', !!document.getElementById('stats-nodes'));
    test('stats-edges-exists', !!document.getElementById('stats-edges'));

    // Performance HUD
    test('perf-hud-exists', !!document.getElementById('perf-hud'));
    test('perf-fps-exists', !!document.getElementById('perf-fps'));

    // Test 1b: Color mode buttons exist
    const colorButtons = document.querySelectorAll('.color-btn[data-preset]');
    test('color-mode-buttons-exist', colorButtons.length >= 4);

    // Test 1c: HUD Layout Manager tests
    test('hud-layout-manager-exists', typeof HudLayoutManager === 'object' && HudLayoutManager !== null);
    test('hud-layout-manager-has-reflow', typeof HudLayoutManager.reflow === 'function');
    test('hud-layout-manager-has-placePanel', typeof HudLayoutManager.placePanel === 'function');

    // Test 1d: HUD placement with synthetic rects (collision avoidance)
    if (typeof HudLayoutManager.placePanel === 'function') {
        // Create a test scenario: occupied rect on top-left, panel should avoid it
        const fakeOccupied = [{ left: 0, top: 0, right: 300, bottom: 200 }];
        const fakeCandidates = [
            { left: 20, top: 100 },   // Would overlap with occupied
            { left: 400, top: 100 }   // Should be clear
        ];
        // Create a mock panel element
        const mockPanel = document.createElement('div');
        mockPanel.style.width = '200px';
        mockPanel.style.height = '150px';
        mockPanel.style.position = 'fixed';
        document.body.appendChild(mockPanel);

        const result = HudLayoutManager.placePanel(mockPanel, fakeCandidates, fakeOccupied);
        // Should choose the second candidate (no overlap)
        const pickedNonOverlapping = result && result.left >= 300;
        test('hud-placement-avoids-overlap', pickedNonOverlapping);

        document.body.removeChild(mockPanel);
    }

    // Test 1e: Canonical taxonomy field tests
    // Test that node.tier is preferred over atom prefix inference
    const mockNodeWithTier = { tier: 'T2', atom: 'CORE.001', ring: 'DOMAIN' };
    const tierResult = getNodeTier(mockNodeWithTier);
    test('node-tier-prefers-field', tierResult === 'T2');  // Should use tier field, not infer T0 from CORE.

    // Test that node.ring is used when present
    const mockNodeWithRing = { ring: 'PRESENTATION', layer: 'APPLICATION' };
    const ringResult = getNodeRing(mockNodeWithRing);
    test('node-ring-prefers-field', ringResult === 'PRESENTATION');  // Should use ring, not layer

    // Test tier aliases work (CORE → T0, EXT → T2)
    test('tier-alias-core-to-t0', normalizeTier('CORE') === 'T0');
    test('tier-alias-ext-to-t2', normalizeTier('EXT') === 'T2');

    // Test atom_family extraction
    const mockNodeWithFamily = { atom_family: 'LOG', atom: 'ORG.AGG.M' };
    const familyResult = getNodeAtomFamily(mockNodeWithFamily);
    test('node-atom-family-prefers-field', familyResult === 'LOG');  // Should use atom_family, not infer ORG

    // Test 1f: Hover panel tests
    test('hover-panel-exists', document.getElementById('hover-panel') !== null);

    // Test hover panel uses canonical fields
    const mockCanonicalNode = {
        name: 'TestNode',
        atom_family: 'LOG',
        ring: 'PRESENTATION',
        tier: 'T2',
        atom: 'ORG.AGG.M',
        kind: 'function',
        role: 'Utility'
    };
    // Simulate updateHoverPanel with mock node
    if (typeof updateHoverPanel === 'function') {
        updateHoverPanel(mockCanonicalNode);
        const hoverFamily = document.getElementById('hover-family')?.textContent;
        const hoverRing = document.getElementById('hover-ring')?.textContent;
        const hoverTier = document.getElementById('hover-tier')?.textContent;
        // Verify canonical fields are used (LOG not ORG, PRESENTATION, T2)
        test('hover-panel-uses-canonical-fields',
            hoverFamily === 'LOG' && hoverRing === 'PRESENTATION' && hoverTier === 'T2');
        // Clean up: hide panel
        updateHoverPanel(null);
    }

    // Test 2: Header stats populated (stat-* elements - these are set early)
    const headerNodes = document.getElementById('stat-nodes');
    const headerEdges = document.getElementById('stat-edges');
    test('header-nodes-populated', headerNodes && headerNodes.textContent !== '0');
    test('header-edges-populated', headerEdges && headerEdges.textContent !== '0');

    // Test 3: Data integrity
    test('nodes-count-positive', data.nodes && data.nodes.length > 0);
    test('links-count-positive', data.links && data.links.length > 0);
    test('graph-initialized', !!window.Graph);

    // Test 4: Controls config loaded
    test('controls-config-exists', !!data.controls);
    test('appearance-config-exists', !!data.appearance);
    test('physics-config-exists', !!data.physics);

    // Test 5: Initial state correct
    const physicsCharge = document.getElementById('physics-charge');
    test('physics-slider-has-value', physicsCharge && physicsCharge.value !== undefined);
    test('3d-mode-default', IS_3D === true);

    // Test 6: VIS_STATE module loaded
    test('vis-state-module-exists', typeof VIS_STATE !== 'undefined');
    test('vis-state-has-applyState', typeof VIS_STATE?.applyState === 'function');
    test('vis-state-has-getState', typeof VIS_STATE?.getState === 'function');

    // Expose results to window for external testing
    window.SELF_TEST_RESULTS = results;

    // Log summary
    const total = results.passed.length + results.failed.length;
    const passRate = ((results.passed.length / total) * 100).toFixed(1);

    if (results.failed.length === 0) {
        console.log(`%c✅ SELF-TEST PASSED: ${results.passed.length}/${total} tests (${passRate}%)`, 'color: #00ff00; font-weight: bold');
    } else {
        console.warn(`%c⚠️ SELF-TEST: ${results.passed.length}/${total} passed (${passRate}%)`, 'color: #ffaa00; font-weight: bold');
        console.warn('Failed tests:', results.failed);
    }

    return results;
}

// TIER_ALIASES, normalizeTier, getNodeTier, getNodeAtomFamily, normalizeRingValue,
// getNodeRing, getNodeLayer, getNodeEffect - provided by node-accessors.js module

// getNodeColorByMode, getSubsystem, getPhase, getFileType, getRoleCategory, applyNodeColors - MOVED TO modules/node-helpers.js
// normalize - MOVED TO modules/utils.js

function filterGraph(data, minVal, datamapSet, filters) {
    // ALL DATA FROM DM - the processing pipeline
    const allNodes = DM ? DM.getNodes() : (data?.nodes || []);
    const allLinks = DM ? DM.getLinks() : (data?.links || []);

    const tierFilter = filters?.tiers || new Set();
    const ringFilter = filters?.rings || new Set();
    const roleFilter = filters?.roles || new Set();
    const edgeFilter = filters?.edges || new Set();
    const familyFilter = filters?.families || new Set();
    const layerFilter = filters?.layers || new Set();
    const effectFilter = filters?.effects || new Set();
    const edgeFamilyFilter = filters?.edgeFamilies || new Set();
    const showEdges = filters?.metadata?.showEdges !== false;

    const availableRings = Array.from(new Set(allNodes.map(n => getNodeRing(n)))).sort();
    let ringFilterValues = Array.from(ringFilter);
    let ringIntersection = ringFilterValues.filter(r => availableRings.includes(r));
    if (ringFilterValues.length > 0 && ringIntersection.length === 0) {
        console.warn('[Filters] Ring filter values not present in dataset; clearing.', {
            ringValues: ringFilterValues,
            availableRings
        });
        ringFilter.clear();
        ringFilterValues = [];
        ringIntersection = [];
    }

    // Filter nodes by size/importance
    let visibleNodes = allNodes.filter(n => (n.val ?? 1) >= minVal);

    if (datamapSet && datamapSet.size > 0) {
        visibleNodes = visibleNodes.filter(n => {
            for (const id of datamapSet) {
                const config = DATAMAP_INDEX[id];
                if (config && datamapMatches(n, config)) return true;
            }
            return false;
        });
    }

    const tierFilterActive = tierFilter.size > 0;
    const ringFilterActive = ringFilter.size > 0;
    const roleFilterActive = roleFilter.size > 0;
    const familyFilterActive = familyFilter.size > 0;
    const layerFilterActive = layerFilter.size > 0;
    const effectFilterActive = effectFilter.size > 0;

    const filterSummary = {
        active: {
            tier: tierFilter.size,
            ring: ringFilter.size,
            role: roleFilter.size,
            family: familyFilter.size,
            layer: layerFilter.size,
            effect: effectFilter.size
        },
        ringValues: ringFilterValues.slice().sort(),
        availableRings,
        ringIntersectionSize: ringIntersection.length
    };
    const filterSummaryKey = JSON.stringify(filterSummary);
    if (filterSummaryKey !== LAST_FILTER_SUMMARY) {
        console.log('[Filters] summary', filterSummary);
        LAST_FILTER_SUMMARY = filterSummaryKey;
    }

    visibleNodes = visibleNodes.filter(n => {
        if (tierFilterActive && !tierFilter.has(getNodeTier(n))) return false;
        if (ringFilterActive && !ringFilter.has(getNodeRing(n))) return false;
        if (roleFilterActive && !roleFilter.has(String(n.role || 'Unknown'))) return false;
        if (familyFilterActive && !familyFilter.has(getNodeAtomFamily(n))) return false;
        if (layerFilterActive && !layerFilter.has(getNodeLayer(n))) return false;
        if (effectFilterActive && !effectFilter.has(getNodeEffect(n))) return false;
        return true;
    });



    // Zero-node protection: warn when dimension filters result in empty graph
    if (visibleNodes.length === 0 && (tierFilterActive || ringFilterActive || roleFilterActive || familyFilterActive || layerFilterActive || effectFilterActive)) {
        const activeFilters = [];
        if (tierFilterActive) activeFilters.push(`tiers: [${Array.from(tierFilter).join(', ')}]`);
        if (ringFilterActive) activeFilters.push(`rings: [${Array.from(ringFilter).join(', ')}]`);
        if (roleFilterActive) activeFilters.push(`roles: [${Array.from(roleFilter).join(', ')}]`);
        if (familyFilterActive) activeFilters.push(`families: [${Array.from(familyFilter).join(', ')}]`);
        if (layerFilterActive) activeFilters.push(`layers: [${Array.from(layerFilter).join(', ')}]`);
        if (effectFilterActive) activeFilters.push(`effects: [${Array.from(effectFilter).join(', ')}]`);
        console.warn('[filterGraph] Zero nodes match filters:', activeFilters.join(', '));
    }

    const visibleIds = new Set(visibleNodes.map(n => n.id));

    // Keep edges only between visible nodes
    let visibleLinks = allLinks.filter(l =>
        visibleIds.has(l.source.id || l.source) &&
        visibleIds.has(l.target.id || l.target)
    );

    if (edgeFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFilter.has(String(l.edge_type || l.type || 'default')));
    }

    if (edgeFamilyFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFamilyFilter.has(l.family || 'Dependency'));
    }

    if (!showEdges) {
        visibleLinks = [];
    }

    return { nodes: visibleNodes, links: visibleLinks };
}

// ====================================================================
// LAYOUT STABILITY: saveNodePositions, restoreNodePositions, freezeLayout, unfreezeLayout, resetLayout - MOVED TO modules/layout-helpers.js
// showModeToast - MOVED TO modules/tooltips.js
// getLinkEndpointId, getFileTarget - MOVED TO modules/layout-helpers.js
// stableOffset - MOVED TO modules/utils.js

// buildFileGraph - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.buildFileGraph)
// captureFileNodePositions - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.captureFileNodePositions)

function buildHybridGraph(data) {
    // ALL DATA FROM DM - the reaction chamber for data chemistry
    if (!FILE_GRAPH) {
        FILE_GRAPH = buildFileGraph(data);
    }
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const nodes = DM ? DM.getNodes() : (data?.nodes || []);
    const links = DM ? DM.getLinks() : (data?.links || []);

    const totalFiles = boundaries.length;
    const clusterConfig = data?.physics?.cluster || {};
    const detachRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius * 1.3 : 200;
    const detachZ = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing * 2 : 80;
    const expandRadius = 30;
    const expandedSet = new Set(EXPANDED_FILES);

    const fileNodes = FILE_GRAPH.nodes.map(node => {
        const copy = Object.assign({}, node);
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach' && expandedSet.has(node.fileIdx))
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        copy.x = anchor.x + detachOffset.x;
        copy.y = anchor.y + detachOffset.y;
        copy.z = (anchor.z || 0) + detachOffset.z;
        return copy;
    });

    const nodeFileIdx = new Map();
    nodes.forEach(n => {
        if (n && n.id) {
            nodeFileIdx.set(n.id, n.fileIdx ?? -1);
        }
    });

    const childNodes = [];
    nodes.forEach(node => {
        if (!expandedSet.has(node.fileIdx)) return;
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach')
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        const local = stableOffset(node, `file-${node.fileIdx}`, expandRadius);
        const copy = Object.assign({}, node);
        copy.x = anchor.x + detachOffset.x + local.x;
        copy.y = anchor.y + detachOffset.y + local.y;
        copy.z = (anchor.z || 0) + detachOffset.z + (IS_3D ? local.z : 0);
        childNodes.push(copy);
    });

    const childLinks = [];
    links.forEach(link => {
        const srcId = getLinkEndpointId(link, 'source');
        const tgtId = getLinkEndpointId(link, 'target');
        const srcIdx = nodeFileIdx.get(srcId) ?? -1;
        const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;
        if (srcIdx < 0 || tgtIdx < 0 || srcIdx !== tgtIdx) return;
        if (!expandedSet.has(srcIdx)) return;
        childLinks.push({
            source: srcId,
            target: tgtId,
            color: link.color,
            opacity: link.opacity,
            edge_type: link.edge_type,
            weight: link.weight,
            confidence: link.confidence,
            resolution: link.resolution
        });
    });

    return {
        nodes: fileNodes.concat(childNodes),
        links: FILE_GRAPH.links.concat(childLinks)
    };
}

function setupControls(data) {
    // Initialize the Unified UI Manager
    UIManager.init(data);

    // HudLayoutManager.init() - REMOVED: Now handled by LAYOUT.init() in main.js
    // The LAYOUT module is initialized via initializeModules() to avoid double-init

    // Initialize Command Bar and Floating Panels
    initCommandBar();

    // Initialize Selection Detail Modal
    initSelectionModal();

    // Initialize Node & Edge Config Controls (PRIME SECTIONS)
    setupConfigControls();

    // Render color-coded legends with counts
    renderAllLegends();

    // Flow mode button (attached here for proper DOM timing)
    const btnFlow = document.getElementById('btn-flow');
    if (btnFlow) btnFlow.onclick = () => toggleFlowMode();
}

/**
 * =================================================================
 * setupConfigControls: Initialize NODE CONFIG and EDGE CONFIG panels
 * =================================================================
 * These are the "prime position" controls at the top of the sidebar
 */
function setupConfigControls() {
    // Helper: Bind slider with value display
    const bindSlider = (id, valueId, onChange, decimals = 1) => {
        const slider = document.getElementById(id);
        const valueEl = document.getElementById(valueId);
        if (!slider) return;
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (valueEl) valueEl.textContent = decimals === 0 ? val.toString() : val.toFixed(decimals);
            onChange(val);
        });
    };

    // Helper: Bind toggle switch
    const bindToggle = (id, initialState, onChange) => {
        const toggle = document.getElementById(id);
        if (!toggle) return;
        if (initialState) toggle.classList.add('active');
        else toggle.classList.remove('active');
        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            onChange(isActive);
        });
    };

    // Helper: Bind button group (radio-like selection)
    const bindButtonGroup = (container, dataAttr, onChange) => {
        const buttons = container.querySelectorAll(`[${dataAttr}]`);
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                onChange(btn.getAttribute(dataAttr));
            });
        });
    };

    // ═══════════════════════════════════════════════════════════════════
    // NODE CONFIG
    // ═══════════════════════════════════════════════════════════════════

    // Size Mode Selector
    const nodeCfg = document.getElementById('section-node-config');
    if (nodeCfg) {
        bindButtonGroup(nodeCfg, 'data-size-mode', (mode) => {
            APPEARANCE_STATE.sizeMode = mode;
            applyNodeSizeMode(mode);
            console.log('[CONFIG] Size mode:', mode);
        });
    }

    // Node Base Size
    bindSlider('cfg-node-size', 'cfg-node-size-val', (val) => {
        APPEARANCE_STATE.nodeScale = val;
        applyNodeSizeMode(APPEARANCE_STATE.sizeMode || 'uniform');
    });

    // Node Opacity
    bindSlider('cfg-node-opacity', 'cfg-node-opacity-val', (val) => {
        APPEARANCE_STATE.nodeOpacity = val;
        if (Graph) Graph.nodeOpacity(val);
    });

    // Node Resolution (sphere segments)
    bindSlider('cfg-node-res', 'cfg-node-res-val', (val) => {
        APPEARANCE_STATE.nodeResolution = Math.round(val);
        if (Graph) Graph.nodeResolution(Math.round(val));
    }, 0);

    // Label Size
    bindSlider('cfg-label-size', 'cfg-label-size-val', (val) => {
        APPEARANCE_STATE.labelSize = val;
        if (Graph && APPEARANCE_STATE.showLabels) {
            Graph.nodeLabel(node => val > 0.2 ? (node.name || node.id) : null);
        }
    });

    // Show Labels Toggle
    bindToggle('cfg-toggle-labels', APPEARANCE_STATE.showLabels, (active) => {
        APPEARANCE_STATE.showLabels = active;
        if (Graph) Graph.nodeLabel(node => active ? (node.name || node.id) : null);
    });

    // Highlight Selected Toggle
    bindToggle('cfg-toggle-highlight', APPEARANCE_STATE.highlightSelected, (active) => {
        APPEARANCE_STATE.highlightSelected = active;
        if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();
    });

    // Pulse Animation Toggle
    bindToggle('cfg-toggle-pulse', false, (active) => {
        APPEARANCE_STATE.pulseAnimation = active;
        console.log('[CONFIG] Pulse animation:', active ? 'ON' : 'OFF');
    });

    // 3D Depth Shading Toggle
    bindToggle('cfg-toggle-depth', true, (active) => {
        APPEARANCE_STATE.depthShading = active;
        console.log('[CONFIG] Depth shading:', active ? 'ON' : 'OFF');
    });

    // ═══════════════════════════════════════════════════════════════════
    // EDGE CONFIG - Enhanced with better visibility and flow animation
    // ═══════════════════════════════════════════════════════════════════

    // Edge Style Selector
    const edgeCfg = document.getElementById('section-edge-config');
    if (edgeCfg) {
        bindButtonGroup(edgeCfg, 'data-edge-style', (style) => {
            APPEARANCE_STATE.edgeStyle = style;
            applyEdgeStyle(style);
            console.log('[CONFIG] Edge style:', style);
        });
    }

    // Edge Opacity - ENHANCED: Higher default for visibility
    bindSlider('cfg-edge-opacity', 'cfg-edge-opacity-val', (val) => {
        APPEARANCE_STATE.edgeOpacity = val;
        // Use applyEdgeMode to ensure consistent function-based opacity
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Width - ENHANCED: Thicker default
    bindSlider('cfg-edge-width', 'cfg-edge-width-val', (val) => {
        APPEARANCE_STATE.edgeWidth = val;
        // Use applyEdgeMode to ensure consistent function-based width
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Curvature - Direct Graph API (not handled by EDGE module)
    bindSlider('cfg-edge-curve', 'cfg-edge-curve-val', (val) => {
        APPEARANCE_STATE.edgeCurvature = val;
        if (Graph) Graph.linkCurvature(val);
    });

    // Particle Speed - For FLOW visualization
    bindSlider('cfg-particle-speed', 'cfg-particle-speed-val', (val) => {
        APPEARANCE_STATE.particleSpeed = val;
        if (Graph) Graph.linkDirectionalParticleSpeed(val);
    }, 3);

    // Particle Density - For FLOW visualization
    bindSlider('cfg-particle-count', 'cfg-particle-count-val', (val) => {
        APPEARANCE_STATE.particleCount = Math.round(val);
        if (Graph) Graph.linkDirectionalParticles(Math.round(val));
    }, 0);

    // Show Arrows Toggle
    bindToggle('cfg-toggle-arrows', APPEARANCE_STATE.showArrows, (active) => {
        APPEARANCE_STATE.showArrows = active;
        if (Graph) {
            Graph.linkDirectionalArrowLength(active ? 6 : 0);
            Graph.linkDirectionalArrowRelPos(0.9);
        }
    });

    // Gradient Colors Toggle
    bindToggle('cfg-toggle-gradient', APPEARANCE_STATE.gradientEdges, (active) => {
        APPEARANCE_STATE.gradientEdges = active;
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Highlight Edges on Hover Toggle
    bindToggle('cfg-toggle-edge-hover', true, (active) => {
        APPEARANCE_STATE.edgeHoverHighlight = active;
    });

    // ═══════════════════════════════════════════════════════════════════
    // Section Collapse Handlers
    // ═══════════════════════════════════════════════════════════════════
    document.querySelectorAll('.section-header[data-section]').forEach(header => {
        header.addEventListener('click', () => {
            const sectionId = header.dataset.section;
            const content = document.getElementById(`section-${sectionId}`);
            if (!content) return;
            const isCollapsed = header.classList.toggle('collapsed');
            content.classList.toggle('collapsed', isCollapsed);
        });
    });

    console.log('[CONFIG] Node & Edge config controls initialized');
}

// applyNodeSizeMode - MOVED TO modules/node-helpers.js

/**
 * Apply edge style - controls edge rendering mode
 */
function applyEdgeStyle(style) {
    if (!Graph) return;
    const opacity = APPEARANCE_STATE.edgeOpacity || 0.4;
    const speed = APPEARANCE_STATE.particleSpeed || 0.01;
    const count = APPEARANCE_STATE.particleCount || 0;

    switch (style) {
        case 'solid':
            Graph.linkLineDash(null);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'dashed':
            Graph.linkLineDash([4, 4]);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'particle':
            // Particle mode: dim lines, bright particles for flow effect
            Graph.linkLineDash(null);
            Graph.linkOpacity(Math.max(0.1, opacity * 0.3));
            Graph.linkDirectionalParticles(Math.max(4, count));
            Graph.linkDirectionalParticleSpeed(speed);
            Graph.linkDirectionalParticleWidth(3);
            Graph.linkDirectionalParticleColor(link => {
                // Use source node color for particles
                if (link.source && typeof link.source === 'object') {
                    return link.source.__threeObj?.material?.color?.getStyle() || '#00d4ff';
                }
                return '#00d4ff';
            });
            break;
    }
}

// UIManager - provided by ui-manager.js module (window.UI_MANAGER, window.UIManager)

function refreshGraph() {
    if (!DM || !Graph) return;  // ALL DATA FROM DM

    // LAYOUT STABILITY: Save current positions before any graph update
    saveNodePositions();

    if (GRAPH_MODE === 'files') {
        if (!FILE_GRAPH) {
            FILE_GRAPH = buildFileGraph(null);  // Uses DM internally
        }
        restoreNodePositions(FILE_GRAPH.nodes);
        Graph.graphData(FILE_GRAPH);
        applyFileColors(FILE_GRAPH.nodes);
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel('name');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    if (GRAPH_MODE === 'hybrid') {
        const hybrid = buildHybridGraph(null);  // Uses DM internally
        restoreNodePositions(hybrid.nodes);
        Graph.graphData(hybrid);
        applyFileColors(hybrid.nodes);
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    const subset = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);  // Uses DM internally
    if (ACTIVE_DATAMAPS.size > 0 && subset.nodes.length === 0) {
        showToast('No nodes for that datamap selection.');
        ACTIVE_DATAMAPS.clear();
        const fallback = filterGraph(null, CURRENT_DENSITY, new Set(), VIS_FILTERS);  // Uses DM internally
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        // Force re-evaluation of accessors
        Graph.nodeColor(Graph.nodeColor());
        Graph.nodeRelSize(Graph.nodeRelSize());
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        if (fileMode && GRAPH_MODE === 'atoms') {
            applyFileVizMode();
        }
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    // Zero-node protection for VIS_FILTERS (tier/ring/family/role)
    const hasActiveFilters = VIS_FILTERS.tiers.size > 0 || VIS_FILTERS.rings.size > 0 ||
        VIS_FILTERS.families.size > 0 || VIS_FILTERS.roles.size > 0;
    if (subset.nodes.length === 0 && hasActiveFilters) {
        showToast('No nodes match current filters. Clearing filters.');
        clearAllFilters();
        const fallback = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    applyNodeColors(subset.nodes);
    restoreNodePositions(subset.nodes);
    Graph.graphData(subset);
    Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
    Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
    applyEdgeMode();
    if (fileMode && GRAPH_MODE === 'atoms') {
        applyFileVizMode();
    }
    updateDatamapControls();
    syncSelectionAfterGraphUpdate();
    if (LAYOUT_FROZEN) freezeLayout();
}

// ═══════════════════════════════════════════════════════════════════════
// 3D TOPOLOGICAL MINIMAP - Interactive filter visualization
// THE STANDARD MODEL TOPOLOGY: 16 Levels × 3 Layers × Families
// ═══════════════════════════════════════════════════════════════════════

// THE 16 ABSTRACTION LEVELS (vertical axis: L-3 to L12)
const SCALE_16_LEVELS = {
    // COSMOLOGICAL (L8-L12) - Beyond scope, shown as outer haze
    'L12': { name: 'UNIVERSE', symbol: '🌐', zone: 'COSMOLOGICAL', y: 1.4, color: { h: 260, s: 30, l: 25 } },
    'L11': { name: 'DOMAIN', symbol: '🏛️', zone: 'COSMOLOGICAL', y: 1.3, color: { h: 250, s: 35, l: 30 } },
    'L10': { name: 'ORGANIZATION', symbol: '🏢', zone: 'COSMOLOGICAL', y: 1.2, color: { h: 240, s: 40, l: 35 } },
    'L9': { name: 'PLATFORM', symbol: '☁️', zone: 'COSMOLOGICAL', y: 1.1, color: { h: 230, s: 45, l: 40 } },
    'L8': { name: 'ECOSYSTEM', symbol: '🔗', zone: 'COSMOLOGICAL', y: 1.0, color: { h: 220, s: 50, l: 45 } },
    // ARCHITECTURAL (L4-L7) - Primary visible zone (teal - virtual depths)
    'L7': { name: 'SYSTEM', symbol: '⬡', zone: 'ARCHITECTURAL', y: 0.7, color: { h: 175, s: 60, l: 52 } },
    'L6': { name: 'PACKAGE', symbol: '📦', zone: 'ARCHITECTURAL', y: 0.5, color: { h: 178, s: 62, l: 48 } },
    'L5': { name: 'FILE', symbol: '📄', zone: 'ARCHITECTURAL', y: 0.3, color: { h: 180, s: 65, l: 44 } },
    'L4': { name: 'CONTAINER', symbol: '⬢', zone: 'ARCHITECTURAL', y: 0.1, color: { h: 182, s: 68, l: 40 } },
    // SEMANTIC (L1-L3) - The operational core (silver/white - surface light)
    'L3': { name: 'NODE', symbol: '★', zone: 'SEMANTIC', y: -0.1, color: { h: 210, s: 25, l: 92 } },  // Brightest - fundamental unit
    'L2': { name: 'BLOCK', symbol: '▣', zone: 'SEMANTIC', y: -0.3, color: { h: 210, s: 30, l: 85 } },
    'L1': { name: 'STATEMENT', symbol: '─', zone: 'SEMANTIC', y: -0.5, color: { h: 210, s: 35, l: 78 } },
    // SYNTACTIC (L0) - The event horizon between meaning and data
    'L0': { name: 'TOKEN', symbol: '·', zone: 'SYNTACTIC', y: -0.7, color: { h: 60, s: 90, l: 55 } },  // Bright yellow - event horizon
    // PHYSICAL (L-1 to L-3) - The substrate (deep blue - ocean floor)
    'L-1': { name: 'CHARACTER', symbol: 'a', zone: 'PHYSICAL', y: -0.9, color: { h: 220, s: 70, l: 42 } },
    'L-2': { name: 'BYTE', symbol: '01', zone: 'PHYSICAL', y: -1.1, color: { h: 220, s: 75, l: 35 } },
    'L-3': { name: 'BIT/QUBIT', symbol: '⚡', zone: 'PHYSICAL', y: -1.3, color: { h: 220, s: 80, l: 28 } }  // Deepest
};

// THE THREE PARALLEL LAYERS (shells around the structure) - Depth/Elevation palette
const THREE_LAYERS = {
    'PHYSICAL': { order: 0, radius: 1.8, opacity: 0.15, color: { h: 220, s: 75, l: 35 }, description: 'Hardware, bits, memory, I/O' },
    'VIRTUAL': { order: 1, radius: 1.4, opacity: 0.25, color: { h: 175, s: 65, l: 45 }, description: 'Code, structures, algorithms' },
    'SEMANTIC': { order: 2, radius: 1.0, opacity: 0.35, color: { h: 210, s: 30, l: 88 }, description: 'Meaning, business logic, intent' }
};

// ═══════════════════════════════════════════════════════════════════════
// STANDARD MODEL THEORY CONTENT - Semantic descriptions for tooltips
// The codespace is a high-dimensional space where all software artifacts exist
// ═══════════════════════════════════════════════════════════════════════

const SMC_THEORY = {
    // THE THREE FUNDAMENTAL LAYERS
    layers: {
        'PHYSICAL': {
            icon: '⚡',
            title: 'Physical Layer',
            subtitle: 'The Substrate',
            body: 'The hardware reality: electrons, circuits, memory cells. Everything that exists in physical space-time.',
            theory: '"Matter is the canvas upon which computation paints its patterns."',
            examples: ['CPU registers', 'RAM cells', 'disk sectors', 'network signals']
        },
        'VIRTUAL': {
            icon: '💠',
            title: 'Virtual Layer',
            subtitle: 'The Structure',
            body: 'Pure information structures: code, data, algorithms. The mathematical forms that live in computational space.',
            theory: '"Between the physical and the meaningful lies the virtual — pure form without matter or purpose."',
            examples: ['variables', 'functions', 'classes', 'data structures']
        },
        'SEMANTIC': {
            icon: '🎯',
            title: 'Semantic Layer',
            subtitle: 'The Meaning',
            body: 'Intent and purpose: business logic, user goals, system behavior. The "why" behind the code.',
            theory: '"Semantics is where computation meets human intention — the bridge between bits and understanding."',
            examples: ['user stories', 'business rules', 'API contracts', 'domain models']
        }
    },

    // ATOM FAMILIES
    families: {
        'LOG': {
            icon: '📊',
            title: 'Logic Family',
            subtitle: 'The Reasoners',
            body: 'Elements that transform data through computation: conditionals, loops, calculations.',
            theory: '"Logic atoms are the decision-makers — they take inputs and produce outputs through transformation."',
            examples: ['if/else', 'for loops', 'calculations', 'validators']
        },
        'DAT': {
            icon: '📦',
            title: 'Data Family',
            subtitle: 'The Containers',
            body: 'Elements that hold and organize information: variables, structures, databases.',
            theory: '"Data atoms store state — they are the nouns in the grammar of code."',
            examples: ['variables', 'arrays', 'objects', 'databases']
        },
        'ORG': {
            icon: '🏗️',
            title: 'Organization Family',
            subtitle: 'The Architects',
            body: 'Elements that structure code: modules, classes, packages. They create boundaries.',
            theory: '"Organization atoms create order from chaos — the folders in the file system of abstraction."',
            examples: ['modules', 'classes', 'packages', 'namespaces']
        },
        'EXE': {
            icon: '⚙️',
            title: 'Execution Family',
            subtitle: 'The Doers',
            body: 'Elements that perform actions: function calls, I/O, system operations.',
            theory: '"Execution atoms are the verbs — where potential becomes actual."',
            examples: ['function calls', 'API requests', 'file writes', 'renders']
        },
        'EXT': {
            icon: '🔌',
            title: 'External Family',
            subtitle: 'The Connectors',
            body: 'Elements that interface with the outside: APIs, imports, system calls.',
            theory: '"External atoms are portals — they connect isolated systems into larger ecosystems."',
            examples: ['imports', 'API calls', 'env vars', 'dependencies']
        }
    },

    // TIERS
    tiers: {
        'T0': {
            icon: '🔬',
            title: 'Tier 0 — Foundation',
            subtitle: 'Low-level primitives',
            body: 'The atomic building blocks: individual statements, expressions, basic operations.',
            theory: '"T0 is where code meets silicon — the ground floor of abstraction."',
            examples: ['assignments', 'operators', 'literals', 'basic types']
        },
        'T1': {
            icon: '🔧',
            title: 'Tier 1 — Components',
            subtitle: 'Functional units',
            body: 'Grouped functionality: functions, methods, small modules.',
            theory: '"T1 is the sweet spot — complex enough to be useful, simple enough to understand."',
            examples: ['functions', 'methods', 'handlers', 'utilities']
        },
        'T2': {
            icon: '🏛️',
            title: 'Tier 2 — Architecture',
            subtitle: 'System structure',
            body: 'High-level organization: classes, modules, services. The skeleton of the codebase.',
            theory: '"T2 defines the shape of software — patterns emerge that echo through every line."',
            examples: ['classes', 'modules', 'services', 'controllers']
        }
    },

    // SPECIAL ELEMENTS
    special: {
        'core': {
            icon: '✨',
            title: 'The Nexus',
            subtitle: 'Singularity Point',
            body: 'The center of the topology: where all paths converge.',
            theory: '"Every codebase has a heart — the central modules that everything depends upon."',
            examples: ['main.js', 'app.py', 'index.ts', 'core.rs']
        },
        'elevator': {
            icon: '🚀',
            title: 'Data Elevator',
            subtitle: 'Cross-tier Highway',
            body: 'Vertical connections that move data between abstraction levels.',
            theory: '"Elevators are the call stacks of architecture."',
            examples: ['API layers', 'ORMs', 'serializers', 'adapters']
        },
        'hub-star': {
            icon: '⭐',
            title: 'Hub Node',
            subtitle: 'High-connectivity Center',
            body: 'A node with many incoming connections. Often a critical dependency.',
            theory: '"Hubs are the load-bearing walls — remove them and everything collapses."',
            examples: ['utils', 'config', 'logger', 'database']
        }
    }
};

// Tooltip state - shared with modules/tooltips.js
const TOOLTIP_STATE = { visible: false, currentKey: null, element: null, hideTimeout: null };

// initTooltips, showTopoTooltip, hideTopoTooltip - MOVED TO modules/tooltips.js

// ZONES define which levels belong to which visual band
const LEVEL_ZONES = {
    'COSMOLOGICAL': { levels: ['L12', 'L11', 'L10', 'L9', 'L8'], opacity: 0.2, blur: true },
    'ARCHITECTURAL': { levels: ['L7', 'L6', 'L5', 'L4'], opacity: 0.6, blur: false },
    'SEMANTIC': { levels: ['L3', 'L2', 'L1'], opacity: 1.0, blur: false },        // Primary focus
    'SYNTACTIC': { levels: ['L0'], opacity: 0.8, blur: false },                   // Event horizon
    'PHYSICAL': { levels: ['L-1', 'L-2', 'L-3'], opacity: 0.4, blur: true }
};

// ═══════════════════════════════════════════════════════════════════════
// getTopoColor - MOVED TO modules/color-helpers.js


// ═══════════════════════════════════════════════════════════════════════
// VISUALIZATION PRESETS - Different ways to see the topology
// ═══════════════════════════════════════════════════════════════════════
const VIS_PRESETS = {
    'tier': {
        name: 'By Tier (T0/T1/T2)',
        description: 'Core → Architecture → External',
        colorBy: 'tier',
        sizeBy: 'fanout',
        edgeBy: 'type'
    },
    'family': {
        name: 'By Atom Family',
        description: 'LOG, DAT, ORG, EXE, EXT',
        colorBy: 'family',
        sizeBy: 'fanout',
        edgeBy: 'type'
    },
    'layer': {
        name: 'By Layer',
        description: 'Physical → Virtual → Semantic',
        colorBy: 'layer',
        sizeBy: 'uniform',
        edgeBy: 'resolution'
    },
    'ring': {
        name: 'By Ring (Domain)',
        description: 'Domain architecture layers',
        colorBy: 'ring',
        sizeBy: 'fanout',
        edgeBy: 'type'
    },
    'file': {
        name: 'By File',
        description: 'Each file gets unique hue',
        colorBy: 'file',
        sizeBy: 'uniform',
        edgeBy: 'resolution'
    },
    'flow': {
        name: 'Markov Flow',
        description: 'Edge width = transition probability',
        colorBy: 'tier',
        sizeBy: 'entropy',
        edgeBy: 'weight'
    },
    'depth': {
        name: 'By Depth (Call Distance)',
        description: 'Distance from entry points',
        colorBy: 'depth',
        sizeBy: 'fanout',
        edgeBy: 'type'
    }
    // NOTE: Color schemes (viridis, plasma, thermal, etc.) are now in color-engine.js schemePaths
    // Access via COLOR.listSchemes(), COLOR.applyScheme(), COLOR.getSchemeColor()
};

// ═══════════════════════════════════════════════════════════════════════
// LAYOUT PRESETS - MOVED TO modules/animation.js
// ═══════════════════════════════════════════════════════════════════════
// LAYOUT_PRESETS, STAGGER_PATTERNS, CURRENT_LAYOUT, LAYOUT_ANIMATION_ID,
// LAYOUT_TIME, CURRENT_STAGGER_PATTERN, applyLayoutPreset, cycleStaggerPattern,
// startLayoutMotion, startFlockSimulation, groupNodesByTier
// All now provided by ANIM module with O(n) spatial hashing (fixes ARCH-002)








// Count nodes by tier and family







// Hermite basis functions for C¹ continuous color interpolation




// ═══════════════════════════════════════════════════════════════









// OKLCH-inspired colors (converted to linear RGB for Three.js)
// Chaos (bottom): OKLCH(0.25, 0.12, 240) ≈ deep cosmic blue




// ═══════════════════════════════════════════════════════════════


























// clearAllFilters - MOVED TO modules/visibility.js







// collectCounts, buildCheckboxRow, buildFilterGroup - MOVED TO modules/ui-builders.js
// resolveDefaults - MOVED TO modules/utils.js
// normalizeDatamapConfig, resolveDatamapConfigs, datamapMatches - MOVED TO modules/datamap.js
// buildDatamapToggle, buildExclusiveOptions - MOVED TO modules/ui-builders.js

function buildMetadataControls(containerId, metadata) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.innerHTML = '';

    const toggles = [
        { id: 'meta-labels', label: 'LABELS', key: 'showLabels' },
        { id: 'meta-file-panel', label: 'FILE PANEL', key: 'showFilePanel' },
        { id: 'meta-report', label: 'REPORT', key: 'showReportPanel' },
        { id: 'meta-edges', label: 'EDGES', key: 'showEdges' }
    ];

    toggles.forEach((toggle) => {
        buildCheckboxRow(container, toggle.id, toggle.label, null, metadata[toggle.key], (checked) => {
            metadata[toggle.key] = checked;
            applyMetadataVisibility();
            refreshGraph();
        });
    });
}

function buildAppearanceSliders(containerId, sliderConfigs) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.innerHTML = '';

    const resolveSlider = (key, fallback) => {
        const config = (sliderConfigs && sliderConfigs[key]) ? sliderConfigs[key] : {};
        return {
            label: config.label || fallback.label,
            min: (config.min !== undefined) ? config.min : fallback.min,
            max: (config.max !== undefined) ? config.max : fallback.max,
            step: (config.step !== undefined) ? config.step : fallback.step,
            default: (config.default !== undefined) ? config.default : fallback.value
        };
    };

    const sliderDefs = [
        (() => {
            const config = resolveSlider('edgeOpacity', {
                label: 'EDGE OPACITY',
                min: 0.02,
                max: 0.4,
                step: 0.01,
                value: EDGE_DEFAULT_OPACITY
            });
            return {
                id: 'edge-opacity',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.edgeOpacity ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.edgeOpacity = val;
                    applyEdgeMode();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('nodeScale', {
                label: 'NODE SCALE',
                min: 0.6,
                max: 2.5,
                step: 0.1,
                value: 1
            });
            return {
                id: 'node-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.nodeScale ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.nodeScale = val;
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('backgroundBrightness', {
                label: 'BACKGROUND',
                min: 0,
                max: 1,
                step: 0.05,
                value: 1
            });
            return {
                id: 'bg-brightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.backgroundBrightness ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.backgroundBrightness = val;
                    updateBackgroundBrightness();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('fileLightness', {
                label: 'FILE LIGHT',
                min: 20,
                max: 80,
                step: 1,
                value: 50
            });
            return {
                id: 'file-lightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.fileLightness ?? config.default,
                onChange: (val) => {
                    FILE_COLOR_CONFIG.lightness = val;
                    APPEARANCE_STATE.fileLightness = val;
                    if (fileMode) {
                        applyFileVizMode();
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hueShift', {
                label: 'HUE SHIFT',
                min: -180,
                max: 180,
                step: 1,
                value: 0
            });
            return {
                id: 'hue-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.hueShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.hueShift = val;
                    Color.setTransform('hueShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('chromaScale', {
                label: 'CHROMA SCALE',
                min: 0,
                max: 2,
                step: 0.05,
                value: 1
            });
            return {
                id: 'chroma-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.chromaScale ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.chromaScale = val;
                    Color.setTransform('chromaScale', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('lightnessShift', {
                label: 'LIGHT SHIFT',
                min: -20,
                max: 20,
                step: 1,
                value: 0
            });
            return {
                id: 'lightness-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.lightnessShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.lightnessShift = val;
                    Color.setTransform('lightnessShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('boundaryOpacity', {
                label: 'HULL OPACITY',
                min: 0.02,
                max: 0.25,
                step: 0.01,
                value: 0.1
            });
            return {
                id: 'boundary-fill',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryFill ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryFill = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hullWireOpacity', {
                label: 'HULL WIRE',
                min: 0.05,
                max: 0.6,
                step: 0.02,
                value: 0.35
            });
            return {
                id: 'boundary-wire',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryWire ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryWire = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('clusterStrength', {
                label: 'CLUSTER FORCE',
                min: 0,
                max: 1,
                step: 0.1,
                value: 0.45
            });
            return {
                id: 'cluster-strength',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.clusterStrength ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.clusterStrength = val;
                    if (fileMode && fileVizMode === 'cluster') {
                        applyClusterForce(null);  // Uses DM internally
                    }
                }
            };
        })(),
        // ═══════════════════════════════════════════════════════════
        // AMPLIFIER SLIDER - Power law exponent for visual contrast
        // γ=1 linear, γ>1 amplifies small differences, γ<1 compresses
        // Formula: amplified = value^(1/γ)
        // ═══════════════════════════════════════════════════════════
        (() => {
            const config = resolveSlider('amplifier', {
                label: 'AMPLIFIER (γ)',
                min: 0.3,
                max: 5.0,
                step: 0.1,
                value: 1.0
            });
            return {
                id: 'amplifier',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.amplifier ?? config.default,
                className: 'meta-amplifier',  // Special styling for meta-slider
                description: 'γ>1 amplifies differences, γ<1 compresses',
                onChange: (val) => {
                    APPEARANCE_STATE.amplifier = val;
                    // Re-apply edge mode to update widths with new amplification
                    applyEdgeMode();
                    // If in flow mode, re-apply flow visualization
                    if (flowMode) {
                        applyFlowVisualization();
                    }
                }
            };
        })()
    ];

    sliderDefs.forEach(def => {
        const wrapper = document.createElement('div');
        wrapper.className = 'slider-row' + (def.className ? ' ' + def.className : '');

        // Header row with label and value
        const header = document.createElement('div');
        header.className = 'slider-header';
        const label = document.createElement('span');
        label.className = 'slider-label';
        label.textContent = def.label;
        const valueDisplay = document.createElement('span');
        valueDisplay.className = 'slider-value';
        valueDisplay.id = def.id + '-value';
        const safeValue = def.value ?? def.min ?? 0;  // Fallback to min or 0 if value is null
        valueDisplay.textContent = safeValue.toFixed(def.step < 1 ? 2 : 0);
        header.appendChild(label);
        header.appendChild(valueDisplay);

        // The slider input
        const input = document.createElement('input');
        input.type = 'range';
        input.className = 'slider-input';
        input.id = def.id;
        input.min = def.min;
        input.max = def.max;
        input.step = def.step;
        input.value = safeValue;
        input.oninput = () => {
            const val = parseFloat(input.value);
            valueDisplay.textContent = val.toFixed(def.step < 1 ? 2 : 0);
            def.onChange(val);
        };

        wrapper.appendChild(header);
        wrapper.appendChild(input);

        // Optional description for meta-sliders
        if (def.description) {
            const desc = document.createElement('div');
            desc.className = 'slider-desc';
            desc.textContent = def.description;
            wrapper.appendChild(desc);
        }

        container.appendChild(wrapper);
    });
}

// ═══════════════════════════════════════════════════════════════════════
// PHYSICS CONTROLS - Real-time force simulation adjustment
// ═══════════════════════════════════════════════════════════════════════
const PHYSICS_STATE = {
    charge: -120,
    linkDistance: 50,
    centerStrength: 0.05,
    velocityDecay: 0.4
};

const PHYSICS_PRESETS = {
    default: { charge: -120, linkDistance: 50, centerStrength: 0.05, velocityDecay: 0.4, label: 'DEFAULT' },
    tight: { charge: -80, linkDistance: 30, centerStrength: 0.1, velocityDecay: 0.5, label: 'TIGHT' },
    loose: { charge: -200, linkDistance: 80, centerStrength: 0.02, velocityDecay: 0.3, label: 'LOOSE' },
    explosive: { charge: -400, linkDistance: 120, centerStrength: 0.01, velocityDecay: 0.2, label: 'EXPLOSIVE' }
};

// applyPhysicsState, applyPhysicsPreset, updatePhysicsSliders, buildPhysicsControls - MOVED TO modules/physics.js

// updateBackgroundBrightness, applyMetadataVisibility - MOVED TO modules/visibility.js

// Deprecated setupSidebar - replaced by UIManager
// Deprecated buildDatamapControls - replaced by UIManager


// ═══════════════════════════════════════════════════════════════
// PRESET BUTTONS - Quick visualization mode selection (Tier, Family, etc.)
// Uses VIS_STATE for unified state management
// ═══════════════════════════════════════════════════════════════
const presetGrid = document.getElementById('dock-presets');
const presetBtnGrid = document.getElementById('preset-grid');
if (presetBtnGrid) {
    presetBtnGrid.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const presetKey = btn.dataset.preset;

            // Use VIS_STATE for unified state management
            if (typeof VIS_STATE !== 'undefined') {
                VIS_STATE.applyPreset(presetKey);
                return;
            }

            // Fallback for when VIS_STATE not loaded
            const preset = VIS_PRESETS[presetKey];
            if (!preset) return;

            presetBtnGrid.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            APPEARANCE_STATE.currentPreset = presetKey;
            APPEARANCE_STATE.colorMode = preset.colorBy;

            setNodeColorMode(preset.colorBy);

            const edgeModes = { 'type': 'gradient-tier', 'weight': 'weight', 'resolution': 'gradient-file' };
            EDGE_MODE = edgeModes[preset.edgeBy] || preset.edgeBy || 'gradient-tier';
            applyEdgeMode();

            if (presetKey === 'flow') {
                if (!flowMode && typeof toggleFlowMode === 'function') toggleFlowMode();
            } else if (flowMode && typeof disableFlowMode === 'function') {
                disableFlowMode();
            }

            if (typeof window.refreshGradientEdgeColors === 'function') {
                window.refreshGradientEdgeColors();
            }

            if (typeof renderAllLegends === 'function') {
                renderAllLegends();
            }

            console.log('[Preset] Applied:', preset.name, '| colorBy:', preset.colorBy, '| edgeBy:', preset.edgeBy);
        });
    });
}

// ═══════════════════════════════════════════════════════════════
// NOTE: Color scheme buttons are now handled by sidebar.js via SIDEBAR.initSchemeNavigator()
// The 33 named schemes (viridis, plasma, thermal, etc.) are defined in color-engine.js schemePaths
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// LAYOUT BUTTONS - Graph layout presets with perpetual motion
// ═══════════════════════════════════════════════════════════════
const layoutGrid = document.getElementById('layout-grid');
if (layoutGrid) {
    layoutGrid.querySelectorAll('.layout-btn').forEach(btn => {
        const layoutKey = btn.dataset.layout;
        // Assign ID if missing for Registry
        if (!btn.id) btn.id = `layout-btn-${layoutKey}`;

        REGISTRY.register(btn.id, () => {
            if (!layoutKey || !LAYOUT_PRESETS[layoutKey]) return;

            // Update active state
            layoutGrid.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Apply the layout
            applyLayoutPreset(layoutKey, true);

            console.log('[Layout] Applied:', LAYOUT_PRESETS[layoutKey].name);
        }, { desc: `Activate ${layoutKey} layout` });
    });
}

// VIEW section controls
buildExclusiveOptions('filter-node-color', [
    { label: 'TIER', value: 'tier' },
    { label: 'RING', value: 'ring' },
    { label: 'FAMILY', value: 'family' },
    { label: 'LAYER', value: 'layer' },
    { label: 'FILE', value: 'file' },
    { label: 'ATOM', value: 'atom' },
    { label: 'COMPLEXITY', value: 'complexity' },
    { label: 'CHURN', value: 'churn' }
], NODE_COLOR_MODE, setNodeColorMode);
buildExclusiveOptions('filter-edge-mode', [
    { label: 'GRAD-FILE', value: 'gradient-file' },
    { label: 'GRAD-TIER', value: 'gradient-tier' },
    { label: 'GRAD-FLOW', value: 'gradient-flow' },
    { label: 'TYPE', value: 'type' },
    { label: 'WEIGHT', value: 'weight' },
    { label: 'MONO', value: 'mono' }
], EDGE_MODE, setEdgeMode);
buildMetadataControls('filter-metadata', VIS_FILTERS.metadata);
buildAppearanceSliders('appearance-sliders', {}); // controlsConfig removed - sliders built dynamically
buildPhysicsControls('physics-sliders');  // Physics/forces controls

applyMetadataVisibility();
updateBackgroundBrightness();
refreshGraph();

// setupCollapsibleSections - MOVED TO modules/visibility.js

// setupReport, setupAIInsights, setupMetrics - MOVED TO modules/report.js

// escapeHtml - MOVED TO modules/utils.js

// setupHudFade, updateHudStats - MOVED TO modules/hud.js

// showToast - MOVED TO modules/tooltips.js
// updateDatamapControls - MOVED TO modules/datamap.js

// toggleDimensions, setupDimensionToggle, animateDimensionChange - MOVED TO modules/dimension.js

// stableSeed, stableZ - MOVED TO modules/utils.js

// ====================================================================
// EDGE VISUALIZATION MODES - GRADIENT & DATA-DRIVEN SYSTEM
// ====================================================================
// NEW: Edge modes with gradients showing data progression & regions
const EDGE_MODE_ORDER = [
    'gradient-tier',      // Source→Target tier flow (architecture layers)
    'gradient-file',      // File boundaries (module regions)
    'gradient-flow',      // Markov probability (hot paths)
    'gradient-depth',     // Call depth progression
    'gradient-semantic',  // Semantic distance (type similarity)
    'type',               // Classic type-based
    'weight',             // Weight intensity
    'mono'                // Minimal monochrome
];
const EDGE_MODE_LABELS = {
    'gradient-tier': '▼ TIER FLOW',
    'gradient-file': '▼ FILE REGIONS',
    'gradient-flow': '▼ HOT PATHS',
    'gradient-depth': '▼ CALL DEPTH',
    'gradient-semantic': '▼ SEMANTIC',
    type: 'EDGE: TYPE',
    weight: 'EDGE: WEIGHT',
    mono: 'EDGE: MONO'
};
const EDGE_MODE_HINTS = {
    'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
    'gradient-file': 'Color by file region - shows module boundaries',
    'gradient-flow': 'Hot paths - markov probability gradient',
    'gradient-depth': 'Color by call chain depth',
    'gradient-semantic': 'Color by semantic similarity of endpoints',
    type: 'Edge color by type (calls, imports, etc.)',
    weight: 'Edge width & color by weight',
    mono: 'Minimal monochrome'
};

// Gradient color palettes for different modes
const GRADIENT_PALETTES = {
    tier: {
        // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
        T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
        T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
        T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
        UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
    },
    file: {
        // Rainbow hues distributed across files
        saturation: 65,
        lightness: 48
    },
    flow: {
        // Cold (low prob) to Hot (high prob)
        cold: { h: 220, s: 60, l: 45 },   // Blue
        warm: { h: 45, s: 85, l: 50 },    // Yellow
        hot: { h: 0, s: 90, l: 55 }       // Red
    },
    depth: {
        // Shallow (bright) to Deep (dark, saturated)
        shallow: { h: 180, s: 50, l: 65 },  // Light cyan
        mid: { h: 260, s: 70, l: 50 },      // Purple
        deep: { h: 320, s: 80, l: 40 }      // Magenta
    },
    semantic: {
        // Similar (harmonious) to Different (contrasting)
        similar: { h: 150, s: 60, l: 50 },    // Green - same type
        related: { h: 200, s: 65, l: 48 },    // Cyan - related
        different: { h: 340, s: 75, l: 50 }   // Pink - different
    }
};

// FILE_HUE_MAP, buildFileHueMap - provided by edge-system.js module

// Get node tier value (0=T0, 1=T1, 2=T2)
// getNodeTierValue, getNodeDepth, getSemanticSimilarity - MOVED TO modules/node-helpers.js

// interpolateColor, applyColorTweaks, oklchToSrgb, oklchColor - MOVED TO modules/color-engine.js
// Use COLOR.interpolate() and COLOR.get() instead

// getGradientEdgeColor - MOVED TO modules/edge-system.js
// clamp01, clampValue - MOVED TO modules/utils.js
// hslColor REMOVED - Using OKLCH Native via Color.interpolate
// parseOklchString - MOVED TO modules/utils.js
// normalizeColorInput, toColorNumber - MOVED TO modules/color-helpers.js

// updateEdgeRanges, refreshNodeFileIndex, getLinkFileIdx - MOVED TO modules/edge-system.js
// (shims delegate to EDGE.updateRanges, EDGE.refreshNodeFileIndex; getLinkFileIdx is internal)

// normalizeMetric - MOVED TO modules/utils.js
// getEdgeColor, getEdgeWidth, applyEdgeMode, cycleEdgeMode, setEdgeMode - MOVED TO modules/edge-system.js
// (backward compat shims in edge-system.js)

// Datamap toggles are wired in buildDatamapControls().
const btnReport = document.getElementById('btn-report');
if (btnReport) {
    btnReport.onclick = () => {
        const panel = document.getElementById('report-panel');
        const btn = document.getElementById('btn-report');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// AI INSIGHTS PANEL TOGGLE
const btnInsights = document.getElementById('btn-insights');
if (btnInsights) {
    btnInsights.onclick = () => {
        const panel = document.getElementById('insights-panel');
        const btn = document.getElementById('btn-insights');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// setStarsVisible, STARS_STORAGE_KEY, stars toggle binding - MOVED TO modules/stars.js
// Call STARS.init() to initialize (done in modules/main.js)

// Reset Layout button - explicitly re-run physics
const btnResetLayout = document.getElementById('btn-reset-layout');
if (btnResetLayout) {
    btnResetLayout.onclick = () => resetLayout();
}

// Hints toggle - enable/disable mode toasts
const btnHints = document.getElementById('btn-hints');
if (btnHints) {
    btnHints.onclick = () => {
        HINTS_ENABLED = !HINTS_ENABLED;
        btnHints.classList.toggle('active', HINTS_ENABLED);
        if (HINTS_ENABLED) {
            showModeToast('Hints enabled');
        }
    };
}

const btnEdgeMode = document.getElementById('btn-edge-mode');
if (btnEdgeMode) {
    btnEdgeMode.onclick = () => cycleEdgeMode();
}

// ====================================================================
// FLOW MODE: Markov Chain Visualization (Token-Driven)
// ====================================================================
// flowMode hoisted to top
let originalLinkWidths = new Map();
let highEntropyNodes = new Set();
// FLOW_CONFIG is set in initGraph() from THE REMOTE CONTROL tokens

// getFlowPresetColor, getFlowPresetValue - MOVED TO modules/flow.js

// FLOW_PRESETS, currentFlowPreset - MOVED TO modules/flow.js

// toggleFlowMode, disableFlowMode, applyFlowVisualization, clearFlowVisualization - MOVED TO modules/flow.js

// setDatamap, setNodeColorMode, applyDatamap - MOVED TO modules/datamap.js

// ====================================================================
// FILE BOUNDARIES & HOVER SYSTEM
// ====================================================================
// NOTE: fileBoundaryMeshes, fileMode, fileVizMode, etc. declared at top of file

// hashToUnit - MOVED TO modules/utils.js
// getFileHue, getFileColor - MOVED TO modules/color-helpers.js
// updateHoverPanel, handleNodeHover, handleNodeClick - MOVED TO modules/hover.js
// buildDatasetKey - MOVED TO modules/utils.js
// loadGroups, saveGroups, getNextGroupColor, getGroupById, getPrimaryGroupForNode - MOVED TO modules/groups.js
// renderGroupList, updateGroupButtonState, createGroupFromSelection - MOVED TO modules/groups.js

// getSelectedNodes, setSelection, toggleSelection, clearSelection, maybeClearSelection - MOVED TO modules/selection.js
// Use SELECT.getSelectedNodes(), SELECT.set(), SELECT.toggle(), SELECT.clear(), SELECT.maybeClear()
// Shims in selection.js provide global function names for backward compatibility

function formatCountList(items, limit = 4) {
    return items.slice(0, limit).map(([key, count]) => `${key} ${count}`).join(' · ') || '--';
}

function appendSelectionRow(container, label, value) {
    const row = document.createElement('div');
    row.className = 'selection-row';
    const labelEl = document.createElement('span');
    labelEl.className = 'label';
    labelEl.textContent = label;
    const valueEl = document.createElement('span');
    valueEl.textContent = value || '--';
    row.appendChild(labelEl);
    row.appendChild(valueEl);
    container.appendChild(row);
}

function updateSelectionPanel() {
    const panel = document.getElementById('selection-panel');
    const body = document.getElementById('selection-body');
    const title = document.getElementById('selection-title');
    if (!panel || !body) return;

    const nodes = getSelectedNodes();
    if (!nodes.length) {
        panel.classList.remove('visible');
        body.innerHTML = '';
        return;
    }

    panel.classList.add('visible');
    if (title) title.textContent = `SELECTION (${nodes.length})`;
    body.innerHTML = '';

    if (nodes.length <= 3) {
        nodes.forEach(node => {
            const item = document.createElement('div');
            item.className = 'selection-item';
            const name = document.createElement('div');
            name.className = 'selection-name';
            name.textContent = node.name || node.id || 'Unknown';
            item.appendChild(name);
            appendSelectionRow(item, 'Family', getNodeAtomFamily(node));
            appendSelectionRow(item, 'Ring', getNodeRing(node));
            appendSelectionRow(item, 'Tier', getNodeTier(node));
            appendSelectionRow(item, 'Role', node.role || '--');
            const filePath = node.file_path || node.file || '';
            if (filePath) {
                const shortPath = filePath.length > 48 ? '...' + filePath.slice(-45) : filePath;
                appendSelectionRow(item, 'File', shortPath);
            }
            body.appendChild(item);
        });
    } else {
        const summary = document.createElement('div');
        summary.className = 'selection-summary';

        const families = collectCounts(nodes, n => getNodeAtomFamily(n));
        const rings = collectCounts(nodes, n => getNodeRing(n));
        const tiers = collectCounts(nodes, n => getNodeTier(n));

        const total = document.createElement('div');
        total.textContent = `Total: ${nodes.length} nodes`;
        summary.appendChild(total);

        const familyRow = document.createElement('div');
        familyRow.textContent = `Family: ${formatCountList(families)}`;
        summary.appendChild(familyRow);

        const ringRow = document.createElement('div');
        ringRow.textContent = `Ring: ${formatCountList(rings)}`;
        summary.appendChild(ringRow);

        const tierRow = document.createElement('div');
        tierRow.textContent = `Tier: ${formatCountList(tiers)}`;
        summary.appendChild(tierRow);

        const numericKeys = [
            ['tokens', 'TOKENS'],
            ['bytes', 'BYTES'],
            ['loc', 'LOC'],
            ['lines', 'LINES'],
            ['lines_of_code', 'LOC'],
            ['size', 'SIZE']
        ];
        const totals = {};
        nodes.forEach(node => {
            numericKeys.forEach(([key]) => {
                const value = Number(node[key]);
                if (Number.isFinite(value)) {
                    totals[key] = (totals[key] || 0) + value;
                }
            });
        });
        numericKeys.forEach(([key, label]) => {
            if (totals[key]) {
                const row = document.createElement('div');
                row.textContent = `${label}: ${Math.round(totals[key])}`;
                summary.appendChild(row);
            }
        });

        body.appendChild(summary);
    }

    HudLayoutManager.reflow();
}

// ═══════════════════════════════════════════════════════════════════════
// SELECTION DETAIL MODAL: Consolidated view of selected nodes
// ═══════════════════════════════════════════════════════════════════════
function showSelectionModal() {
    const nodes = getSelectedNodes();
    if (!nodes.length) {
        showToast('No nodes selected');
        return;
    }

    const overlay = document.getElementById('selection-modal-overlay');
    const title = document.getElementById('selection-modal-title');
    const statsContainer = document.getElementById('selection-modal-stats');
    const body = document.getElementById('selection-modal-body');

    if (!overlay || !body) return;

    // Calculate aggregates
    let totalTokens = 0, totalBytes = 0, totalLoc = 0;
    const tierCounts = {};
    const ringCounts = {};
    const familyCounts = {};
    const levelCounts = {};

    nodes.forEach(node => {
        totalTokens += Number(node.tokens) || 0;
        totalBytes += Number(node.bytes) || 0;
        totalLoc += Number(node.loc || node.lines || node.lines_of_code) || 0;

        const tier = getNodeTier(node);
        const ring = getNodeRing(node);
        const family = getNodeAtomFamily(node);
        const level = node.level || node.scale_level || 'L3';

        tierCounts[tier] = (tierCounts[tier] || 0) + 1;
        ringCounts[ring] = (ringCounts[ring] || 0) + 1;
        familyCounts[family] = (familyCounts[family] || 0) + 1;
        levelCounts[level] = (levelCounts[level] || 0) + 1;
    });

    // Calculate max relevance for normalization
    const maxVal = Math.max(...nodes.map(n => n.val || n.size || 1));

    // Update title
    title.textContent = `SELECTED NODES (${nodes.length})`;

    // Build stats bar
    statsContainer.innerHTML = '';
    const stats = [
        ['NODES', nodes.length.toLocaleString()],
        ['TOKENS', totalTokens.toLocaleString()],
        ['BYTES', totalBytes.toLocaleString()],
        ['LOC', totalLoc.toLocaleString()],
        ['TIERS', Object.keys(tierCounts).join(', ')],
        ['FAMILIES', Object.keys(familyCounts).length]
    ];
    stats.forEach(([label, value]) => {
        if (value && value !== '0') {
            const stat = document.createElement('div');
            stat.className = 'selection-modal-stat';
            stat.innerHTML = `
                        <span class="selection-modal-stat-label">${label}</span>
                        <span class="selection-modal-stat-value">${value}</span>
                    `;
            statsContainer.appendChild(stat);
        }
    });

    // Build table
    const sortedNodes = [...nodes].sort((a, b) => (b.val || b.size || 1) - (a.val || a.size || 1));

    body.innerHTML = `
                <table class="selection-modal-table">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Tier</th>
                            <th>Ring</th>
                            <th>Family</th>
                            <th>Level</th>
                            <th>Tokens</th>
                            <th>LOC</th>
                            <th>Relevance</th>
                        </tr>
                    </thead>
                    <tbody id="selection-modal-tbody"></tbody>
                </table>
            `;

    const tbody = document.getElementById('selection-modal-tbody');
    sortedNodes.forEach(node => {
        const tier = getNodeTier(node);
        const ring = getNodeRing(node);
        const family = getNodeAtomFamily(node);
        const level = node.level || node.scale_level || 'L3';
        const tokens = Number(node.tokens) || '--';
        const loc = Number(node.loc || node.lines || node.lines_of_code) || '--';
        const relevance = ((node.val || node.size || 1) / maxVal * 100).toFixed(0);

        const row = document.createElement('tr');
        row.innerHTML = `
                    <td class="node-name" title="${node.name || node.id}">${node.name || node.id}</td>
                    <td><span class="level-badge tier-badge">${tier}</span></td>
                    <td><span class="level-badge ring-badge">${ring}</span></td>
                    <td><span class="level-badge family-badge">${family}</span></td>
                    <td>${level}</td>
                    <td class="numeric">${typeof tokens === 'number' ? tokens.toLocaleString() : tokens}</td>
                    <td class="numeric">${typeof loc === 'number' ? loc.toLocaleString() : loc}</td>
                    <td>
                        <div class="relevance-bar">
                            <div class="relevance-fill" style="width: ${relevance}%"></div>
                        </div>
                    </td>
                `;
        tbody.appendChild(row);
    });

    // Show modal
    overlay.classList.add('visible');
}

function hideSelectionModal() {
    const overlay = document.getElementById('selection-modal-overlay');
    if (overlay) overlay.classList.remove('visible');
}

function initSelectionModal() {
    const overlay = document.getElementById('selection-modal-overlay');
    const closeBtn = document.getElementById('selection-modal-close');
    const selectionTitle = document.getElementById('selection-title');

    if (closeBtn) {
        closeBtn.addEventListener('click', hideSelectionModal);
    }

    if (overlay) {
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) hideSelectionModal();
        });
    }

    // Click on selection panel title to open modal
    if (selectionTitle) {
        selectionTitle.style.cursor = 'pointer';
        selectionTitle.addEventListener('click', showSelectionModal);
    }

    // Keyboard shortcut: 'i' for info when nodes selected
    document.addEventListener('keydown', (e) => {
        if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey) {
            const activeEl = document.activeElement;
            if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
            if (getSelectedNodes().length > 0) {
                e.preventDefault();
                showSelectionModal();
            }
        }
        if (e.key === 'Escape') {
            hideSelectionModal();
        }
        // Wave Pattern Cycling
        if (e.key === 'w' || e.key === 'W') {
            const activeEl = document.activeElement;
            if (!activeEl || (activeEl.tagName !== 'INPUT' && activeEl.tagName !== 'TEXTAREA')) {
                cycleStaggerPattern();
            }
        }
    });
}

function updateOverlayScale(node) {
    const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE.nodeScale || 1));
    const selectionScale = base * 2.5;  // BIGGER halo - was 1.9
    const groupScale = base * 1.8;      // Slightly bigger group halo
    if (node.__selectionHalo) {
        node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
    }
    if (node.__groupHalo) {
        node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
    }
}

function ensureNodeOverlays(node) {
    if (!node) return null;
    if (node.__overlayGroup) return node.__overlayGroup;

    const group = new THREE.Group();

    const selectionMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,      // BRIGHT CYAN - unmissable!
        transparent: true,
        opacity: 0.85,        // MUCH BRIGHTER - was 0.35
        depthWrite: false
    });
    const selectionHalo = new THREE.Mesh(SELECTION_HALO_GEOMETRY, selectionMaterial);
    selectionHalo.visible = false;
    selectionHalo.renderOrder = 3;

    const groupMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.45,        // BRIGHTER - was 0.18
        depthWrite: false
    });
    const groupHalo = new THREE.Mesh(GROUP_HALO_GEOMETRY, groupMaterial);
    groupHalo.visible = false;
    groupHalo.renderOrder = 2;

    group.add(selectionHalo);
    group.add(groupHalo);

    node.__selectionHalo = selectionHalo;
    node.__groupHalo = groupHalo;
    node.__overlayGroup = group;
    return group;
}

// Store original colors/sizes for selection restore
// (selectionOriginals declared early at top of file to avoid TDZ)
// SELECTION_SIZE_MULT moved to top
// PENDULUM moved to top

// Initialize from Config (if available)
// We call this immediately to load overrides from the graph data
if (typeof graph !== 'undefined' && graph.appearance && graph.appearance.animation) {
    const cfg = graph.appearance.animation;
    if (cfg.hue) Object.assign(PENDULUM.hue, cfg.hue);
    if (cfg.chroma) Object.assign(PENDULUM.chroma, cfg.chroma);
    if (cfg.lightness) Object.assign(PENDULUM.lightness, cfg.lightness);
    if (cfg.ripple) Object.assign(PENDULUM.ripple, cfg.ripple);
    console.log("Animation Config Loaded:", PENDULUM);
}

// Store original colors for dimming non-selected nodes
// NOTE: originalColorsForDim declared at top of file

// oklchToHex - MOVED TO modules/color-engine.js (use COLOR.get() instead)
// updatePendulums, getSelectionColor, getNodeSpatialPhase, animateSelectionColors - MOVED TO modules/selection.js
// startSelectionAnimation, stopSelectionAnimation - MOVED TO modules/selection.js (shims provide global names)
// dimColor - MOVED TO modules/color-helpers.js

function updateSelectionVisuals() {
    if (!Graph || !Graph.graphData) return;
    const nodes = Graph.graphData().nodes || [];
    const hasSelection = SELECTED_NODE_IDS.size > 0;

    nodes.forEach(node => {
        const isSelected = SELECTED_NODE_IDS.has(node.id);

        // Save original color/size for ALL nodes when selection starts
        if (hasSelection && !originalColorsForDim.has(node.id)) {
            originalColorsForDim.set(node.id, {
                color: node.color,
                val: node.val || 1
            });
        }

        // Also track selected nodes separately for size restore
        if (isSelected && !selectionOriginals.has(node.id)) {
            selectionOriginals.set(node.id, {
                color: node.color,
                val: node.val || 1
            });
        }

        // Apply styling based on selection state
        if (hasSelection) {
            if (isSelected) {
                // SELECTED: Make bigger, color will be animated
                const orig = selectionOriginals.get(node.id);
                node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
            } else {
                // NOT SELECTED: Dim by 33%
                const orig = originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = dimColor(orig.color, 0.33);
                }
            }
        } else {
            // NO SELECTION: Restore all original colors and sizes
            if (originalColorsForDim.has(node.id)) {
                const orig = originalColorsForDim.get(node.id);
                node.color = orig.color;
                node.val = orig.val;
            }
            if (selectionOriginals.has(node.id)) {
                const orig = selectionOriginals.get(node.id);
                node.color = orig.color;
                node.val = orig.val;
                selectionOriginals.delete(node.id);
            }
        }

        // Also update overlays (halos)
        ensureNodeOverlays(node);
        updateOverlayScale(node);
        if (node.__selectionHalo) {
            node.__selectionHalo.visible = isSelected;
        }
        if (node.__groupHalo) {
            const group = getPrimaryGroupForNode(node.id);
            if (group) {
                node.__groupHalo.visible = group.visible !== false;
                node.__groupHalo.material.color.set(group.color || '#88d0ff');
                node.__groupHalo.material.opacity =
                    (group.id === ACTIVE_GROUP_ID) ? 0.7 : 0.45;
            } else {
                node.__groupHalo.visible = false;
            }
        }
    });

    // Clear dim cache when no selection
    if (!hasSelection) {
        originalColorsForDim.clear();
    }

    // Start/stop animation based on selection state
    if (hasSelection) {
        startSelectionAnimation();
    } else {
        stopSelectionAnimation();
    }

    // Force re-render with new colors
    Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
}

function syncSelectionAfterGraphUpdate() {
    if (!Graph || !Graph.graphData) return;
    const visibleIds = new Set((Graph.graphData().nodes || []).map(n => n.id));
    const idsToRemove = [];
    Array.from(SELECTED_NODE_IDS).forEach(id => {
        if (!visibleIds.has(id)) {
            idsToRemove.push(id);
        }
    });
    if (idsToRemove.length > 0) {
        // Use SELECT.remove() for proper module integration
        // This triggers updateSelectionVisuals via the hook
        SELECT.remove(idsToRemove);
    } else {
        // No changes to selection, but still need to update visuals
        updateSelectionVisuals();
    }
    updateGroupButtonState();
}

function updateSelectionBox(rect) {
    if (!SELECTION_BOX) return;
    SELECTION_BOX.style.display = 'block';
    SELECTION_BOX.style.left = `${rect.left}px`;
    SELECTION_BOX.style.top = `${rect.top}px`;
    SELECTION_BOX.style.width = `${rect.width}px`;
    SELECTION_BOX.style.height = `${rect.height}px`;
}

// getBoxRect - MOVED TO modules/utils.js

function getNodeScreenPosition(node) {
    if (!Graph || !Graph.camera || !node) return null;
    if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return null;
    const camera = Graph.camera();
    const vector = new THREE.Vector3(node.x, node.y, node.z || 0);
    vector.project(camera);
    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
    const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
    return { x, y };
}

function selectNodesInBox(rect, additive = true) {
    if (!Graph || !Graph.graphData) return;
    const nodes = Graph.graphData().nodes || [];
    const selected = [];
    nodes.forEach(node => {
        const pos = getNodeScreenPosition(node);
        if (!pos) return;
        if (pos.x >= rect.left && pos.x <= rect.right &&
            pos.y >= rect.top && pos.y <= rect.bottom) {
            if (node.id) selected.push(node.id);
        }
    });
    if (selected.length) {
        setSelection(selected, additive);
    }
}

function setupSelectionInteractions() {
    const clearBtn = document.getElementById('selection-clear');
    if (clearBtn) {
        clearBtn.onclick = () => clearSelection();
    }

    const groupBtn = document.getElementById('btn-create-group');
    if (groupBtn) {
        groupBtn.onclick = () => createGroupFromSelection();
    }

    SELECTION_BOX = document.getElementById('selection-box');
    if (!Graph || !Graph.renderer || !SELECTION_BOX) return;

    const canvas = Graph.renderer().domElement;
    if (!canvas) return;

    const onPointerDown = (e) => {
        // Left-drag = marquee selection (space+drag reserved for pan)
        if (e.button !== 0) return;
        if (SPACE_PRESSED) return;
        if (e.target !== canvas) return;
        if (HOVERED_NODE) return;
        MARQUEE_ACTIVE = true;
        MARQUEE_ADDITIVE = !!e.shiftKey;
        MARQUEE_START = { x: e.clientX, y: e.clientY };
        updateSelectionBox(getBoxRect(MARQUEE_START, MARQUEE_START));
        if (Graph.controls()) {
            Graph.controls().enabled = false;
        }
        e.preventDefault();
    };

    const onPointerMove = (e) => {
        if (!MARQUEE_ACTIVE || !MARQUEE_START) return;
        updateSelectionBox(getBoxRect(MARQUEE_START, { x: e.clientX, y: e.clientY }));
    };

    const finishSelection = (e) => {
        if (!MARQUEE_ACTIVE || !MARQUEE_START) return;
        const rect = getBoxRect(MARQUEE_START, { x: e.clientX, y: e.clientY });
        SELECTION_BOX.style.display = 'none';
        const additive = MARQUEE_ADDITIVE;
        MARQUEE_ACTIVE = false;
        MARQUEE_START = null;
        MARQUEE_ADDITIVE = false;
        if (Graph.controls()) {
            Graph.controls().enabled = true;
        }
        const didDrag = rect.width > 4 && rect.height > 4;
        if (didDrag) {
            LAST_MARQUEE_END_TS = Date.now();
            selectNodesInBox(rect, additive);
        }
    };

    canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
    canvas.addEventListener('pointermove', onPointerMove, { passive: true });
    canvas.addEventListener('pointerup', finishSelection, { passive: true });
    canvas.addEventListener('pointerleave', finishSelection, { passive: true });
}

function initSelectionState(data) {
    DATASET_KEY = buildDatasetKey(data);
    GROUPS_STORAGE_KEY = `collider_groups_${DATASET_KEY}`;
    loadGroups();
    renderGroupList();
    updateSelectionPanel();
    updateGroupButtonState();
}

function handleNodeHover(node, data) {
    const filePanel = document.getElementById('file-panel');
    HOVERED_NODE = node || null;

    // Always update hover panel (separate from file panel)
    updateHoverPanel(node);

    // Guard: file-panel may not exist in minimal template
    if (!filePanel) return;

    if (!VIS_FILTERS.metadata.showFilePanel) {
        filePanel.classList.remove('visible');
        return;
    }

    if (!node) {
        // Mouse left node - hide panel after delay
        setTimeout(() => {
            if (!fileMode) filePanel.classList.remove('visible');
        }, 300);
        return;
    }

    // Get file info from boundaries
    const boundaries = data.file_boundaries || [];
    const fileIdx = node.fileIdx;

    if (fileIdx < 0 || fileIdx >= boundaries.length) {
        return;
    }

    const fileInfo = boundaries[fileIdx];

    // Update panel content (with null checks for minimal template)
    const setEl = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.textContent = val;
    };
    setEl('file-name', fileInfo.file_name || 'unknown');
    setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
    setEl('file-purpose', fileInfo.purpose || '--');
    setEl('file-atom-count', fileInfo.atom_count || 0);
    setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
    setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
    setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

    // Show code preview from node body
    const code = node.body || '// no source available';
    setEl('file-code', code);

    // Show panel and trigger smart placement
    filePanel.classList.add('visible');
    HudLayoutManager.reflow();
}

function handleNodeClick(node, event) {
    if (!node) return;
    const additive = event && event.shiftKey;
    if (additive) {
        toggleSelection(node);
        return;
    }
    if (node.id) {
        setSelection([node.id]);
    }
    if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
        toggleFileExpand(node.fileIdx);
    }
}

function toggleFileExpand(fileIdx) {
    if (!Number.isFinite(fileIdx)) return;
    captureFileNodePositions();
    const fileInfo = DM ? DM.getFile(fileIdx) : {};  // ALL DATA FROM DM
    const fileLabel = fileInfo?.file_name || fileInfo?.file || `file-${fileIdx}`;
    if (EXPANDED_FILES.has(fileIdx)) {
        EXPANDED_FILES.delete(fileIdx);
        showToast(`Collapsed ${fileLabel}`);
    } else {
        EXPANDED_FILES.clear();
        EXPANDED_FILES.add(fileIdx);
        showToast(`Expanded ${fileLabel}`);
    }
    window.GRAPH_MODE = (EXPANDED_FILES.size > 0) ? 'hybrid' : 'files';
    refreshGraph();
}

// sampleFileNodes, buildHull2D, computeCentroid - MOVED TO modules/spatial.js
// quantile - MOVED TO modules/utils.js

function drawFileBoundaries(data) {
    // ALL DATA FROM DM - the rendering pipeline
    let drawn = 0;
    const boundaryConfig = data?.appearance?.boundary || {};
    const fillOpacity =
        (typeof APPEARANCE_STATE.boundaryFill === 'number')
            ? APPEARANCE_STATE.boundaryFill
            : (boundaryConfig.fill_opacity || 0.08);
    const wireOpacity =
        (typeof APPEARANCE_STATE.boundaryWire === 'number')
            ? APPEARANCE_STATE.boundaryWire
            : (boundaryConfig.wire_opacity || 0.3);
    const padding = boundaryConfig.padding || 1.2;
    const minExtent = boundaryConfig.min_extent || 6;
    const quantileRange = boundaryConfig.quantile || 0.9;
    const lowQ = Math.max(0, (1 - quantileRange) / 2);
    const highQ = Math.min(1, 1 - lowQ);
    const boundaryPhysics = data?.physics?.boundary || {};
    const hullType = String(boundaryPhysics.hullType || 'convex').toLowerCase();
    const fileBoundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const totalFiles = fileBoundaries.length;

    const graphNodes = DM ? DM.getVisibleNodes() : (Graph?.graphData()?.nodes || []);
    const scene = Graph.scene();

    // Clear existing boundary meshes
    fileBoundaryMeshes.forEach(mesh => scene.remove(mesh));
    fileBoundaryMeshes = [];

    if (!fileMode) return drawn;

    // Group nodes by file (only use nodes with stable positions)
    const fileGroups = {};
    const validNodes = graphNodes.filter(node => {
        if (!node) return false;
        if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return false;
        if (IS_3D && !Number.isFinite(node.z)) return false;
        return true;
    });

    if (!validNodes.length) return drawn;

    validNodes.forEach(node => {
        const idx = node.fileIdx;
        if (idx >= 0) {
            if (!fileGroups[idx]) fileGroups[idx] = [];
            fileGroups[idx].push(node);
        }
    });

    // Draw boundary for each file group
    Object.entries(fileGroups).forEach(([fileIdx, nodes]) => {
        const sampled = sampleFileNodes(nodes, 180);
        const xs = sampled.map(n => n.x || 0);
        const ys = sampled.map(n => n.y || 0);
        const zs = sampled.map(n => n.z || 0);

        const minX = quantile(xs, lowQ);
        const maxX = quantile(xs, highQ);
        const minY = quantile(ys, lowQ);
        const maxY = quantile(ys, highQ);
        const minZ = quantile(zs, lowQ);
        const maxZ = quantile(zs, highQ);

        const filtered = sampled.filter(n => {
            const x = n.x || 0;
            const y = n.y || 0;
            const z = n.z || 0;
            return x >= minX && x <= maxX && y >= minY && y <= maxY && z >= minZ && z <= maxZ;
        });
        const hullNodes = filtered.length >= 3 ? filtered : sampled;
        const positions = hullNodes.map(n => new THREE.Vector3(n.x || 0, n.y || 0, n.z || 0));
        const centroid = computeCentroid(positions);
        const zRange = maxZ - minZ;
        const extentX = Math.max(0.001, maxX - minX);
        const extentY = Math.max(0.001, maxY - minY);
        const extentZ = Math.max(0.001, maxZ - minZ);
        const scaleFixX = Math.max(1, minExtent / extentX);
        const scaleFixY = Math.max(1, minExtent / extentY);
        const scaleFixZ = IS_3D ? Math.max(1, minExtent / extentZ) : 1;
        const scaleX = padding * scaleFixX;
        const scaleY = padding * scaleFixY;
        const scaleZ = padding * scaleFixZ;
        const sizeX = extentX * scaleX;
        const sizeY = extentY * scaleY;
        const sizeZ = extentZ * scaleZ;

        const fileIndex = Number.parseInt(fileIdx, 10);
        const safeFileIdx = Number.isFinite(fileIndex) ? fileIndex : 0;
        const fileInfo = (data.file_boundaries || [])[safeFileIdx] || {};
        const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
        const color = new THREE.Color(
            getFileColor(safeFileIdx, totalFiles, fileLabel)
        );

        let mesh = null;
        let wireMesh = null;

        if (nodes.length < 3) {
            const rawPositions = nodes.map(n => new THREE.Vector3(n.x || 0, n.y || 0, n.z || 0));
            const smallCentroid = computeCentroid(rawPositions);
            const maxRadius = rawPositions.reduce((acc, p) => {
                return Math.max(acc, p.distanceTo(smallCentroid));
            }, 0);
            const bubbleRadius = Math.max(minExtent * 0.5, maxRadius + minExtent * 0.35);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: fillOpacity,
                wireframe: false,
                side: THREE.DoubleSide
            });
            if (IS_3D) {
                const geometry = new THREE.SphereGeometry(bubbleRadius, 14, 10);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(smallCentroid);
                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const edges = new THREE.EdgesGeometry(geometry);
                wireMesh = new THREE.LineSegments(edges, wireMaterial);
                wireMesh.position.copy(mesh.position);
            } else {
                const geometry = new THREE.CircleGeometry(bubbleRadius, 32);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(smallCentroid.x, smallCentroid.y, smallCentroid.z);
                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const edges = new THREE.EdgesGeometry(geometry);
                wireMesh = new THREE.LineSegments(edges, wireMaterial);
                wireMesh.position.copy(mesh.position);
            }
        }

        if (!mesh && hullType === 'convex') {
            if (IS_3D && zRange > 0.001 && positions.length >= 4) {
                const ConvexCtor =
                    (typeof ConvexGeometry !== 'undefined')
                        ? ConvexGeometry
                        : (THREE.ConvexGeometry || null);
                const relPoints = positions.map(p => p.clone().sub(centroid));
                let boundaryGeometry = null;
                if (ConvexCtor) {
                    try {
                        boundaryGeometry = new ConvexCtor(relPoints);
                    } catch (err) {
                        boundaryGeometry = null;
                    }
                }
                if (boundaryGeometry) {
                    const material = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: fillOpacity,
                        wireframe: false,
                        side: THREE.DoubleSide
                    });
                    mesh = new THREE.Mesh(boundaryGeometry, material);
                    mesh.position.copy(centroid);
                    mesh.scale.set(scaleX, scaleY, scaleZ);

                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(boundaryGeometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(centroid);
                    wireMesh.scale.copy(mesh.scale);
                }
            }

            if (!mesh) {
                const hull2d = buildHull2D(positions.map(p => new THREE.Vector2(p.x, p.y)));
                if (!hull2d || hull2d.length < 3) return;
                const localHull = hull2d.map(p => new THREE.Vector2(p.x - centroid.x, p.y - centroid.y));
                const shape = new THREE.Shape(localHull);
                const boundaryGeometry = new THREE.ShapeGeometry(shape);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: fillOpacity,
                    wireframe: false,
                    side: THREE.DoubleSide
                });
                mesh = new THREE.Mesh(boundaryGeometry, material);
                mesh.position.set(centroid.x, centroid.y, centroid.z);
                mesh.scale.set(scaleX, scaleY, 1);

                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const wireGeometry = new THREE.BufferGeometry().setFromPoints(
                    localHull.map(p => new THREE.Vector3(p.x, p.y, 0))
                );
                wireMesh = new THREE.LineLoop(wireGeometry, wireMaterial);
                wireMesh.position.copy(mesh.position);
                wireMesh.scale.copy(mesh.scale);
            }
        } else if (!mesh && hullType === 'box') {
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: fillOpacity,
                wireframe: false,
                side: THREE.DoubleSide
            });
            if (IS_3D) {
                const geometry = new THREE.BoxGeometry(sizeX, sizeY, sizeZ);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(centroid);
                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const edges = new THREE.EdgesGeometry(geometry);
                wireMesh = new THREE.LineSegments(edges, wireMaterial);
                wireMesh.position.copy(mesh.position);
            } else {
                const geometry = new THREE.PlaneGeometry(sizeX, sizeY);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(centroid.x, centroid.y, centroid.z);
                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const edges = new THREE.EdgesGeometry(geometry);
                wireMesh = new THREE.LineSegments(edges, wireMaterial);
                wireMesh.position.copy(mesh.position);
            }
        } else if (!mesh) {
            const radius = 0.5 * Math.max(sizeX, sizeY, IS_3D ? sizeZ : 0);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: fillOpacity,
                wireframe: false,
                side: THREE.DoubleSide
            });
            if (IS_3D) {
                const geometry = new THREE.SphereGeometry(radius, 18, 14);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(centroid);
                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const edges = new THREE.EdgesGeometry(geometry);
                wireMesh = new THREE.LineSegments(edges, wireMaterial);
                wireMesh.position.copy(mesh.position);
            } else {
                const geometry = new THREE.CircleGeometry(radius, 40);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(centroid.x, centroid.y, centroid.z);
                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const edges = new THREE.EdgesGeometry(geometry);
                wireMesh = new THREE.LineSegments(edges, wireMaterial);
                wireMesh.position.copy(mesh.position);
            }
        }

        if (!mesh) return;
        scene.add(mesh);
        fileBoundaryMeshes.push(mesh);
        drawn += 1;
        if (wireMesh) {
            scene.add(wireMesh);
            fileBoundaryMeshes.push(wireMesh);
        }
    });
    return drawn;
}

// ═══════════════════════════════════════════════════════════════════════
// FILE CONTAINMENT SYSTEM - Spherical fields with particle physics
// "Metaphysical force from another dimension" - holding particles together
// ═══════════════════════════════════════════════════════════════════════

const FILE_CONTAINMENT = {
    spheres: [],              // Three.js sphere meshes
    directoryTree: null,      // Parsed directory hierarchy
    particleActivity: {},    // FileIdx → activity level (0-1)
    boundariesPopped: false,  // Animation state
    popProgress: 0,           // 0 = contained, 1 = fully free
    slowMotionFactor: 0.15,   // Time multiplier for dreamy slow motion
    collisionEnabled: true,   // Enable soft collisions
    spatialGrid: null,        // For efficient collision detection
    gridCellSize: 20,         // Size of spatial hash cells
    animationFrame: null,
    isAnimating: false
};

// SPATIAL HASHING: buildSpatialGrid, getNeighborCells, applySoftCollisions - MOVED TO modules/spatial.js

// Build directory tree from file paths
function buildDirectoryTree(fileBoundaries) {
    const tree = { name: '/', path: '', depth: 0, children: {}, files: [], totalNodes: 0 };

    fileBoundaries.forEach((file, idx) => {
        const filePath = file.file || file.file_name || '';
        const parts = filePath.split('/').filter(p => p);
        let current = tree;

        parts.forEach((part, partIdx) => {
            const isFile = partIdx === parts.length - 1;
            if (isFile) {
                current.files.push({
                    name: part, path: filePath, fileIdx: idx,
                    nodeCount: (file.atom_ids || []).length, activity: 0
                });
            } else {
                if (!current.children[part]) {
                    current.children[part] = {
                        name: part, path: parts.slice(0, partIdx + 1).join('/'),
                        depth: partIdx + 1, children: {}, files: [], totalNodes: 0
                    };
                }
                current = current.children[part];
            }
        });
    });

    FILE_CONTAINMENT.directoryTree = tree;
    return tree;
}

// Compute activity levels from markov transitions
function computeFileActivity(data) {
    const markov = data.markov || {};
    const highEntropy = markov.high_entropy_nodes || [];
    const transitions = markov.transitions || {};
    const fileActivity = {};

    (data.file_boundaries || []).forEach((file, idx) => {
        const atomIds = file.atom_ids || [];
        let activity = 0;
        atomIds.forEach(atomId => {
            if (highEntropy.some(h => h.node === atomId)) activity += 0.3;
            const fanout = Object.keys(transitions[atomId] || {}).length;
            activity += Math.min(fanout / 10, 0.5);
        });
        fileActivity[idx] = Math.min(1, activity / Math.max(1, atomIds.length));
    });

    FILE_CONTAINMENT.particleActivity = fileActivity;
    return fileActivity;
}

// Draw containment spheres
// Draw containment hulls (Optimized for performance and aesthetics)
function drawContainmentSpheres(_data) {
    const scene = Graph.scene();
    if (!scene) return;
    const graphNodes = DM ? DM.getVisibleNodes() : (Graph?.graphData()?.nodes || []);

    // Clear existing
    FILE_CONTAINMENT.spheres.forEach(s => {
        if (s.mesh) scene.remove(s.mesh);
        if (s.wireframe) scene.remove(s.wireframe);
        if (s.glow) scene.remove(s.glow);
    });
    FILE_CONTAINMENT.spheres = [];

    // ONLY DRAW IF: 
    // 1. File Mode is ON
    // 2. We are NOT in Flow Mode (Flow is exclusive)
    // 3. Hulls button is active (explicit user choice)
    const hullsActive = document.getElementById('btn-file-hulls')?.classList.contains('active');

    if (!fileMode || flowMode || !hullsActive || FILE_CONTAINMENT.boundariesPopped) return;

    // Group nodes by file
    const fileGroups = {};
    graphNodes.filter(n => n && Number.isFinite(n.x)).forEach(node => {
        if (node.fileIdx >= 0) {
            if (!fileGroups[node.fileIdx]) fileGroups[node.fileIdx] = [];
            fileGroups[node.fileIdx].push(node);
        }
    });

    Object.entries(fileGroups).forEach(([fileIdx, nodes]) => {
        if (nodes.length < 3) return; // Cull singletons/pairs

        // Calculate Bounding Box
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        let minZ = Infinity, maxZ = -Infinity;

        nodes.forEach(n => {
            minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x);
            minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y);
            minZ = Math.min(minZ, n.z || 0); maxZ = Math.max(maxZ, n.z || 0);
        });

        // Add padding
        const pad = 10;
        const width = (maxX - minX) + pad * 2;
        const height = (maxY - minY) + pad * 2;
        const depth = (maxZ - minZ) + pad * 2;

        if (width < 5 || height < 5 || depth < 5) return;

        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY) / 2;
        const cz = (minZ + maxZ) / 2;

        const geometry = new THREE.BoxGeometry(width, height, depth);
        const color = new THREE.Color(nodes[0].color || '#4488ff');

        const material = new THREE.MeshLambertMaterial({
            color: color,
            transparent: true,
            opacity: 0.15,
            depthWrite: false,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(cx, cy, cz);
        scene.add(mesh);

        // Wireframe
        const wireGeo = new THREE.EdgesGeometry(geometry);
        const wireMat = new THREE.LineBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending
        });
        const wireframe = new THREE.LineSegments(wireGeo, wireMat);
        wireframe.position.set(cx, cy, cz);
        scene.add(wireframe);

        FILE_CONTAINMENT.spheres.push({
            mesh, wireframe,
            fileIdx: parseInt(fileIdx),
            velocity: new THREE.Vector3(0, 0, 0),
            // FIX: Add activity and nodes for animation (was missing, caused crashes)
            activity: FILE_CONTAINMENT.particleActivity[fileIdx] || 0,
            nodes: nodes.map(n => n.id)
        });
    });
}
// ═══════════════════════════════════════════════════════════════════════
// SLOW MOTION PARTICLE ANIMATION - Dreamy physics with collisions
// ═══════════════════════════════════════════════════════════════════════

function startContainmentAnimation() {
    if (FILE_CONTAINMENT.isAnimating) return;
    FILE_CONTAINMENT.isAnimating = true;

    function animate() {
        if (!FILE_CONTAINMENT.isAnimating) return;

        const time = Date.now() * 0.001 * FILE_CONTAINMENT.slowMotionFactor;
        const graphNodes = Graph.graphData().nodes;

        if (FILE_CONTAINMENT.boundariesPopped) {
            // FREE PARTICLE MODE - Brownian motion with collisions
            applySoftCollisions(graphNodes, FILE_CONTAINMENT.gridCellSize, 0.4);

            graphNodes.forEach(node => {
                if (!node || !node.__physics) return;
                const p = node.__physics;

                // Perlin-like wandering
                const wander = 0.08;
                p.vx += (Math.sin(time * 0.7 + (node.__wanderPhase || 0)) - 0.5) * wander;
                p.vy += (Math.cos(time * 0.5 + (node.__wanderPhase || 0) * 1.3) - 0.5) * wander;
                if (IS_3D) p.vz += (Math.sin(time * 0.6 + (node.__wanderPhase || 0) * 0.7) - 0.5) * wander;

                // Damping
                p.vx *= 0.985;
                p.vy *= 0.985;
                p.vz *= 0.985;

                // Apply velocity
                node.x += p.vx;
                node.y += p.vy;
                if (IS_3D) node.z = (node.z || 0) + p.vz;
            });

        } else {
            // CONTAINED MODE - Activity-based oscillation inside spheres
            FILE_CONTAINMENT.spheres.forEach(sphere => {
                const activity = sphere.activity;

                // Pulse sphere opacity
                const pulse = Math.sin(time * 2 + sphere.fileIdx) * 0.5 + 0.5;
                if (sphere.mesh?.material) {
                    sphere.mesh.material.opacity = 0.04 + activity * 0.12 * pulse;
                }
                if (sphere.wireframe?.material) {
                    sphere.wireframe.material.opacity = 0.08 + activity * 0.2 * pulse;
                }

                if (activity < 0.05) return;

                // Perturb particles inside based on activity
                sphere.nodes.forEach(nodeId => {
                    const node = graphNodes.find(n => n.id === nodeId);
                    if (!node || !Number.isFinite(node.x)) return;

                    if (!node.__activityPhase) {
                        node.__activityPhase = {
                            x: Math.random() * Math.PI * 2,
                            y: Math.random() * Math.PI * 2,
                            z: Math.random() * Math.PI * 2
                        };
                    }

                    const amp = activity * 0.4;
                    const freq = 0.5 + activity * 0.5;
                    const phase = node.__activityPhase;

                    node.__renderOffsetX = Math.sin(time * freq + phase.x) * amp;
                    node.__renderOffsetY = Math.sin(time * freq * 1.2 + phase.y) * amp;
                    if (IS_3D) node.__renderOffsetZ = Math.sin(time * freq * 0.9 + phase.z) * amp;
                });
            });
        }

        if (Graph) Graph.refresh();
        FILE_CONTAINMENT.animationFrame = requestAnimationFrame(animate);
    }

    animate();
}

function stopContainmentAnimation() {
    FILE_CONTAINMENT.isAnimating = false;
    if (FILE_CONTAINMENT.animationFrame) {
        cancelAnimationFrame(FILE_CONTAINMENT.animationFrame);
    }
}

// ═══════════════════════════════════════════════════════════════════════
// POP THE BOUNDARIES - Release particles into free Brownian motion
// ═══════════════════════════════════════════════════════════════════════

function popBoundaries(duration = 3000) {
    if (FILE_CONTAINMENT.boundariesPopped) {
        restoreBoundaries(duration);
        return;
    }

    console.log('[Containment] Popping boundaries...');
    FILE_CONTAINMENT.boundariesPopped = true;
    const startTime = Date.now();
    const scene = Graph.scene();
    const graphNodes = Graph.graphData().nodes;

    // Initialize physics for each node
    graphNodes.forEach(node => {
        if (!node || !Number.isFinite(node.x)) return;
        node.__physics = {
            vx: (Math.random() - 0.5) * 1.5,
            vy: (Math.random() - 0.5) * 1.5,
            vz: IS_3D ? (Math.random() - 0.5) * 1.5 : 0
        };
        node.__wanderPhase = Math.random() * Math.PI * 2;
    });

    function animatePop() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(1, elapsed / duration);
        FILE_CONTAINMENT.popProgress = progress;
        const eased = 1 - Math.pow(1 - progress, 3);

        // Fade out spheres
        FILE_CONTAINMENT.spheres.forEach(s => {
            if (s.mesh?.material) s.mesh.material.opacity = (1 - eased) * 0.1;
            if (s.wireframe?.material) s.wireframe.material.opacity = (1 - eased) * 0.25;
            if (s.glow?.material) s.glow.material.opacity = (1 - eased) * 0.08;
        });

        if (progress < 1) {
            requestAnimationFrame(animatePop);
        } else {
            // Remove spheres
            FILE_CONTAINMENT.spheres.forEach(s => {
                if (s.mesh) scene.remove(s.mesh);
                if (s.wireframe) scene.remove(s.wireframe);
                if (s.glow) scene.remove(s.glow);
            });
            FILE_CONTAINMENT.spheres = [];
            console.log('[Containment] Particles now FREE - Brownian motion with collisions');
        }

        if (Graph) Graph.refresh();
    }

    animatePop();
    startContainmentAnimation();
}

function restoreBoundaries(duration = 2000) {
    if (!FILE_CONTAINMENT.boundariesPopped) return;

    console.log('[Containment] Restoring boundaries...');
    const startTime = Date.now();
    const graphNodes = Graph.graphData().nodes;

    graphNodes.forEach(node => {
        if (!node || !Number.isFinite(node.x)) return;
        node.__freePos = { x: node.x, y: node.y, z: node.z || 0 };
    });

    function animateRestore() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(1, elapsed / duration);
        FILE_CONTAINMENT.popProgress = 1 - progress;
        const eased = Math.pow(progress, 2);

        graphNodes.forEach(node => {
            if (!node || !node.__freePos || !node.__originalPos) return;
            node.x = node.__freePos.x + (node.__originalPos.x - node.__freePos.x) * eased;
            node.y = node.__freePos.y + (node.__originalPos.y - node.__freePos.y) * eased;
            if (IS_3D) node.z = node.__freePos.z + ((node.__originalPos.z || 0) - node.__freePos.z) * eased;
        });

        if (progress < 1) {
            requestAnimationFrame(animateRestore);
        } else {
            FILE_CONTAINMENT.boundariesPopped = false;
            if (DM) drawContainmentSpheres(null);  // Uses DM internally
            console.log('[Containment] Boundaries restored');
        }

        if (Graph) Graph.refresh();
    }

    animateRestore();
}

// Expose to global for button binding
window.popBoundaries = popBoundaries;
window.restoreBoundaries = restoreBoundaries;
window.FILE_CONTAINMENT = FILE_CONTAINMENT;

// ====================================================================
// FILE MODE HANDLERS
// ====================================================================

// setFileModeState - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setEnabled)

const btnFiles = document.getElementById('btn-files');
if (btnFiles) btnFiles.onclick = () => setFileModeState(!fileMode);

// COLOR mode - atoms colored by file
const btnFileColor = document.getElementById('btn-file-color');
if (btnFileColor) btnFileColor.onclick = () => setFileVizMode('color');

// HULLS mode - draw boundary spheres
const btnFileHulls = document.getElementById('btn-file-hulls');
if (btnFileHulls) btnFileHulls.onclick = () => setFileVizMode('hulls');

// CLUSTER mode - force clustering by file
const btnFileCluster = document.getElementById('btn-file-cluster');
if (btnFileCluster) btnFileCluster.onclick = () => setFileVizMode('cluster');

// MAP mode - show file nodes
const btnFileMap = document.getElementById('btn-file-map');
if (btnFileMap) btnFileMap.onclick = () => setFileVizMode('map');

// SPHERES mode - show containment spheres (button may be hidden)
const spheresBtn = document.getElementById('btn-file-spheres');
if (spheresBtn) spheresBtn.onclick = () => setFileVizMode('spheres');

// POP button - toggle boundary pop/restore (button may be hidden)
const popBtn = document.getElementById('btn-file-pop');
if (popBtn) {
    popBtn.onclick = () => {
        if (!FILE_CONTAINMENT.boundariesPopped) {
            popBoundaries(3000);
            popBtn.classList.add('active');
            popBtn.textContent = 'RESTORE';
            showToast('Boundaries popped! Particles in slow-motion chaos...');
        } else {
            restoreBoundaries(2000);
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
            showToast('Boundaries restored. Order from chaos.');
        }
    };
}

// Expand mode toggles (only relevant in MAP mode)
const btnExpandInline = document.getElementById('btn-expand-inline');
if (btnExpandInline) {
    btnExpandInline.onclick = () => {
        FILE_EXPAND_MODE = 'inline';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}

const btnExpandDetach = document.getElementById('btn-expand-detach');
if (btnExpandDetach) {
    btnExpandDetach.onclick = () => {
        FILE_EXPAND_MODE = 'detach';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}

function updateExpandButtons() {
    const inlineBtn = document.getElementById('btn-expand-inline');
    const detachBtn = document.getElementById('btn-expand-detach');
    if (inlineBtn) inlineBtn.classList.toggle('active', FILE_EXPAND_MODE === 'inline');
    if (detachBtn) detachBtn.classList.toggle('active', FILE_EXPAND_MODE === 'detach');
}

// setFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setMode)

// applyFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.apply)

// scheduleHullRedraw - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.scheduleHullRedraw)

// applyFileColors - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.applyColors)

// clearFileBoundaries - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearBoundaries)

// Moved here to avoid temporal dead zone issue
let fileCohesionActive = false;

// clearAllFileModes - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearAllModes)

// applyClusterForce, applyFileCohesion, clearFileCohesion - MOVED TO modules/file-viz.js

// ════════════════════════════════════════════════════════════════════════
// SURFACE PARITY HANDLERS - Architectural Enforcements
// ════════════════════════════════════════════════════════════════════════

// Panel Handlers - use togglePanel('view') etc. or PANELS.toggle('view')
// togglePanelView/Filter/Style/Settings - simplified via modules/panels.js


// Action Handlers
function handleCmdFiles() {
    const btn = document.getElementById('cmd-files');
    const isActive = btn ? btn.classList.contains('active') : false;
    setFileModeState(!isActive);
}
function handleCmdFlow() { toggleFlowMode(); }
function handleCmd3d() { toggleDimensions(); }

// PanelManager - provided by panels.js module (window.PANEL_DRAG, window.PanelManager)

// =================================================================
// THEME SWITCHING - MOVED TO modules/theme.js
// setTheme, getTheme, getAvailableThemes, cycleTheme, initTheme

// Initialize theme on DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        // Small delay to ensure CSS vars are loaded
        setTimeout(initTheme, 50);
    });
} else {
    setTimeout(initTheme, 50);
}

// Expose theme functions globally
window.setTheme = setTheme;
window.getTheme = getTheme;
window.getAvailableThemes = getAvailableThemes;
window.cycleTheme = cycleTheme;
window.THEME_CONFIG = THEME_CONFIG;

// Expose filtering/graph globals for module access
window.VIS_FILTERS = VIS_FILTERS;
window.refreshGraph = refreshGraph;

    </script>
</body>

</html>