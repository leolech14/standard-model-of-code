<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Collider v4.0.0</title>
    <style>
        /* ═══════════════════════════════════════════════════════════════════
           COLLIDER UI - Dual Sidebar Layout
           ═══════════════════════════════════════════════════════════════════ */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #0a0a0f;
            --surface: rgba(15, 15, 22, 0.85);
            --surface-hover: rgba(25, 25, 35, 0.9);
            --border: rgba(255, 255, 255, 0.08);
            --border-accent: rgba(74, 158, 255, 0.3);
            --text: rgba(255, 255, 255, 0.9);
            --text-dim: rgba(255, 255, 255, 0.5);
            --text-muted: rgba(255, 255, 255, 0.3);
            --accent: #4a9eff;
            --accent-dim: rgba(74, 158, 255, 0.15);
            --accent-glow: rgba(74, 158, 255, 0.25);
            --green: #5a9a70;
            --yellow: #a09060;
            --red: #b07070;
            --cyan: #7090a0;
            --sidebar-width: 300px;
            --right-panel-width: 280px;
            --min-sidebar-width: 240px;
            --max-sidebar-width: 500px;
            --header-height: 48px;
            --radius: 8px;
            --radius-sm: 4px;
            --glass: blur(12px);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            font-size: 12px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LOADER
           ═══════════════════════════════════════════════════════════════════ */
        #loader {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            z-index: 9999;
            font-size: 14px;
            letter-spacing: 2px;
        }

        #loader-status {
            font-size: 11px;
            opacity: 0.5;
        }

        /* ═══════════════════════════════════════════════════════════════════
           HEADER - Top bar spanning full width
           ═══════════════════════════════════════════════════════════════════ */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height);
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 24px;
            z-index: 200;
        }

        .logo {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 1px;
            color: var(--accent);
        }

        .logo span {
            opacity: 0.5;
            font-size: 10px;
            margin-left: 6px;
            color: var(--text);
        }

        .header-stats {
            display: flex;
            gap: 20px;
            font-size: 11px;
        }

        .stat {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .stat-label {
            opacity: 0.4;
            text-transform: uppercase;
            font-size: 9px;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            color: var(--cyan);
        }

        .target-name {
            margin-left: auto;
            font-size: 11px;
            opacity: 0.5;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ═══════════════════════════════════════════════════════════════════
           MAIN LAYOUT - Graph container
           ═══════════════════════════════════════════════════════════════════ */
        #3d-graph {
            position: fixed;
            top: var(--header-height);
            left: var(--sidebar-width);
            right: var(--right-panel-width);
            bottom: 0;
        }

        /* ═══════════════════════════════════════════════════════════════════
           LEFT SIDEBAR - Controls & Filters
           ═══════════════════════════════════════════════════════════════════ */
        #left-sidebar {
            position: fixed;
            top: var(--header-height);
            left: 0;
            bottom: 0;
            width: var(--sidebar-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
        }

        #left-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #left-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #left-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           RIGHT SIDEBAR - Info Panels
           ═══════════════════════════════════════════════════════════════════ */
        #right-sidebar {
            position: fixed;
            top: var(--header-height);
            right: 0;
            bottom: 0;
            width: var(--right-panel-width);
            background: var(--surface);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #right-sidebar::-webkit-scrollbar {
            width: 4px;
        }

        #right-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        #right-sidebar::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SIDEBAR RESIZE DIVIDERS - Horizontal drag handles
           ═══════════════════════════════════════════════════════════════════ */
        .sidebar-resize-handle {
            position: fixed;
            top: var(--header-height);
            bottom: 0;
            width: 6px;
            cursor: ew-resize;
            z-index: 101;
            background: transparent;
            transition: background 0.15s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.25);
        }

        .sidebar-resize-handle.left {
            left: calc(var(--sidebar-width) - 3px);
        }

        .sidebar-resize-handle.right {
            right: calc(var(--right-panel-width) - 3px);
        }

        /* Visual indicator line */
        .sidebar-resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 40px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .sidebar-resize-handle:hover::after {
            opacity: 1;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION - Collapsible sections
           ═══════════════════════════════════════════════════════════════════ */
        .section {
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            padding: 12px 14px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: all 0.15s;
        }

        .section-header:hover {
            opacity: 0.9;
            background: var(--surface-hover);
        }

        .section-header .arrow {
            transition: transform 0.2s;
            font-size: 8px;
        }

        .section-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        /* PRIME SECTIONS - Highlighted config sections (muted) */
        .section.prime {
            background: linear-gradient(180deg, rgba(100, 110, 130, 0.03) 0%, transparent 100%);
            border-left: 2px solid rgba(100, 110, 130, 0.3);
        }

        .section.prime .section-header {
            opacity: 0.75;
            color: var(--text-secondary);
        }

        .section.prime .section-header:hover {
            opacity: 0.9;
        }

        .section-content {
            padding: 8px 14px 14px;
            overflow-y: auto;
            transition: max-height 0.2s ease;
        }

        .section-content.collapsed {
            display: none;
        }

        /* RESIZABLE SECTIONS - Vertical drag handles */
        .section-resize-handle {
            height: 4px;
            cursor: ns-resize;
            background: transparent;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
            position: relative;
        }

        .section-resize-handle:hover,
        .section-resize-handle.dragging {
            background: rgba(100, 110, 130, 0.2);
        }

        .section-resize-handle::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 2px;
            background: rgba(100, 110, 130, 0.3);
            border-radius: 1px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .section-resize-handle:hover::after {
            opacity: 1;
        }

        /* Section content height constraints when resizing */
        .section-content.resizable {
            min-height: 60px;
            max-height: 400px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           VIEW MODE TOGGLE - ATOMS vs FILES (top of left sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .view-mode-toggle {
            display: flex;
            gap: 0;
            padding: 8px 10px;
            background: linear-gradient(180deg, rgba(74, 158, 255, 0.08) 0%, rgba(74, 158, 255, 0.02) 100%);
            border-bottom: 2px solid var(--accent);
        }

        .view-mode-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }

        .view-mode-btn:first-child {
            border-radius: var(--radius-sm) 0 0 var(--radius-sm);
            border-right: none;
        }

        .view-mode-btn:last-child {
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        }

        .view-mode-btn:hover {
            background: rgba(74, 158, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
        }

        .view-mode-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
            box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
        }

        .view-mode-icon {
            font-size: 14px;
        }

        .view-mode-label {
            font-size: 10px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        /* ═══════════════════════════════════════════════════════════════════
           BUTTON GRID - For presets and actions
           ═══════════════════════════════════════════════════════════════════ */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .btn-grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        .btn-grid-4 {
            grid-template-columns: repeat(4, 1fr);
        }

        .btn-grid-6 {
            grid-template-columns: repeat(6, 1fr);
        }

        .btn {
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            font-size: 9px;
            font-weight: 500;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            text-transform: uppercase;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: var(--border-accent);
        }

        .btn.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        /* Icon buttons */
        .btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SLIDERS
           ═══════════════════════════════════════════════════════════════════ */
        .slider-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 12px;
        }

        .slider-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
        }

        .slider-label {
            opacity: 0.6;
        }

        .slider-value {
            display: none;
            /* Replaced by input */
        }

        .number-input {
            width: 48px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--cyan);
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 10px;
            padding: 2px 4px;
            text-align: right;
            -moz-appearance: textfield;
        }

        .number-input::-webkit-outer-spin-button,
        .number-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-input:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.4);
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 0 8px var(--accent-glow);
        }

        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }

        /* ═══════════════════════════════════════════════════════════════════
           FILTER CHIPS
           ═══════════════════════════════════════════════════════════════════ */
        .filter-group {
            margin-bottom: 12px;
        }

        .filter-group:last-child {
            margin-bottom: 0;
        }

        .filter-label {
            font-size: 9px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .chip {
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 14px;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .chip:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .chip.active {
            background: var(--accent-dim);
            border-color: var(--accent);
            color: var(--accent);
        }

        .chip .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOGGLE SWITCHES
           ═══════════════════════════════════════════════════════════════════ */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            padding: 6px 0;
        }

        .toggle-row .toggle-label {
            opacity: 0.7;
        }

        .toggle {
            width: 36px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--text);
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle.active::after {
            transform: translateX(16px);
        }

        /* ═══════════════════════════════════════════════════════════════════
           INFO PANEL - Right sidebar node info
           ═══════════════════════════════════════════════════════════════════ */
        .info-panel {
            padding: 14px;
            border-bottom: 1px solid var(--border);
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .info-panel-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .node-info {
            display: none;
        }

        .node-info.visible {
            display: block;
        }

        .node-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
            word-break: break-all;
            color: var(--cyan);
        }

        .node-kind {
            font-size: 10px;
            opacity: 0.5;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row .label {
            opacity: 0.4;
        }

        .info-row .value {
            text-align: right;
        }

        .node-file {
            font-size: 9px;
            opacity: 0.3;
            margin-top: 10px;
            word-break: break-all;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .placeholder-text {
            font-size: 10px;
            opacity: 0.3;
            text-align: center;
            padding: 20px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SELECTION PANEL
           ═══════════════════════════════════════════════════════════════════ */
        .selection-panel {
            flex: 1;
            padding: 14px;
            overflow-y: auto;
        }

        .selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .selection-title {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.5;
        }

        .selection-count {
            font-size: 9px;
            padding: 2px 8px;
            background: var(--accent-dim);
            border-radius: 10px;
            color: var(--accent);
        }

        .selection-clear {
            font-size: 9px;
            padding: 4px 8px;
            background: none;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            color: var(--text-dim);
            cursor: pointer;
        }

        .selection-clear:hover {
            color: var(--text);
            border-color: var(--text-dim);
        }

        .selection-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .selection-item {
            font-size: 10px;
            padding: 6px 8px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            margin-bottom: 2px;
            background: rgba(255, 255, 255, 0.02);
        }

        .selection-item:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--accent);
        }

        /* ═══════════════════════════════════════════════════════════════════
           STATS PANEL (bottom of right sidebar)
           ═══════════════════════════════════════════════════════════════════ */
        .stats-panel {
            padding: 14px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid var(--border);
            margin-top: auto;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stats-item {
            text-align: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--radius-sm);
        }

        .stats-item .value {
            font-size: 16px;
            font-weight: 600;
            color: var(--cyan);
            font-variant-numeric: tabular-nums;
        }

        .stats-item .label {
            font-size: 8px;
            opacity: 0.4;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        /* ═══════════════════════════════════════════════════════════════════
           COLOR PANELS (right sidebar color controls)
           ═══════════════════════════════════════════════════════════════════ */
        .color-panel,
        .schemes-panel {
            padding: 12px 14px;
            border-bottom: 1px solid var(--border);
        }

        .color-panel .section-content,
        .schemes-panel .section-content {
            padding: 0;
            margin-top: 10px;
        }

        .color-panel .btn-grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
        }

        .color-panel .btn {
            padding: 6px 8px;
            font-size: 9px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all 0.15s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .color-panel .btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
        }

        .color-panel .btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: #000;
        }

        /* Collapsible header for schemes panel */
        .info-panel-header.collapsible {
            cursor: pointer;
            user-select: none;
        }

        .info-panel-header.collapsible:hover {
            opacity: 0.9;
        }

        .info-panel-header .collapse-icon {
            font-size: 8px;
            transition: transform 0.2s;
        }

        .info-panel-header.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .schemes-panel .section-content {
            max-height: 250px;
            overflow-y: auto;
        }

        .schemes-panel .section-content::-webkit-scrollbar {
            width: 4px;
        }

        .schemes-panel .section-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 2px;
        }

        .schemes-panel .section-content.collapsed {
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           PERFORMANCE HUD (optional overlay)
           ═══════════════════════════════════════════════════════════════════ */
        #perf-hud {
            position: fixed;
            top: calc(var(--header-height) + 8px);
            left: calc(var(--sidebar-width) + 8px);
            background: rgba(0, 0, 0, 0.8);
            padding: 6px 10px;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-family: 'SF Mono', Monaco, monospace;
            z-index: 150;
            display: none;
        }

        #perf-hud.visible {
            display: block;
        }

        .perf-row {
            display: flex;
            gap: 12px;
        }

        .perf-label {
            opacity: 0.5;
        }

        .perf-value {
            font-variant-numeric: tabular-nums;
        }

        .perf-good {
            color: var(--green);
        }

        .perf-warn {
            color: var(--yellow);
        }

        .perf-bad {
            color: var(--red);
        }

        /* ═══════════════════════════════════════════════════════════════════
           TOAST NOTIFICATIONS
           ═══════════════════════════════════════════════════════════════════ */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--surface);
            border: 1px solid var(--border-accent);
            padding: 12px 24px;
            border-radius: var(--radius);
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s;
        }

        #toast.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Selection box for drag select */
        #selection-box {
            position: fixed;
            border: 1px solid var(--accent);
            background: rgba(74, 158, 255, 0.1);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        /* ═══════════════════════════════════════════════════════════════════
           SECTION-SPECIFIC STYLING
           ═══════════════════════════════════════════════════════════════════ */

        /* Color mode buttons with color indicators */
        .color-btn {
            position: relative;
        }

        .color-btn::before {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .color-btn[data-preset="tier"]::before {
            background: #ff6b6b;
        }

        .color-btn[data-preset="family"]::before {
            background: #4ecdc4;
        }

        .color-btn[data-preset="layer"]::before {
            background: #95e1d3;
        }

        .color-btn[data-preset="ring"]::before {
            background: #f9ed69;
        }

        .color-btn[data-preset="file"]::before {
            background: #a8e6cf;
        }

        .color-btn[data-preset="flow"]::before {
            background: #dcd6f7;
        }

        /* Layout buttons with mini icons */
        .layout-btn {
            height: 32px;
        }
    </style>

    <script>
        window.process = window.process || { env: { NODE_ENV: "production" } };
        window.global = window.global || window;
    </script>
    <!-- THREE.js r149 (last version without deprecation warning) + 3d-force-graph -->
    <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
    <script src="https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js"></script>
    <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
</head>

<body>
    <!-- Loader -->
    <div id="loader">
        <div>INITIALIZING...</div>
        <div id="loader-status">Loading data...</div>
    </div>

    <!-- Header -->
    <div id="header">
        <div class="logo">COLLIDER <span>v4.0.0</span></div>
        <div class="header-stats">
            <div class="stat">
                <span class="stat-label">Nodes</span>
                <span class="stat-value" id="stat-nodes">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Edges</span>
                <span class="stat-value" id="stat-edges">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Entropy</span>
                <span class="stat-value" id="stat-entropy">--</span>
            </div>
        </div>
        <div class="target-name" id="target-name"></div>
    </div>

    <!-- Left Sidebar -->
    <div id="left-sidebar">
        <!-- VIEW MODE TOGGLE - TOP PRIORITY -->
        <div class="view-mode-toggle" id="view-mode-toggle">
            <button class="view-mode-btn active" data-mode="atoms">
                <span class="view-mode-icon">◉</span>
                <span class="view-mode-label">ATOMS</span>
            </button>
            <button class="view-mode-btn" data-mode="files">
                <span class="view-mode-icon">◫</span>
                <span class="view-mode-label">FILES</span>
            </button>
        </div>

        <!-- MAPPING CONTROL (Docked) -->
        <div class="section prime" id="control-bar-container">
            <!-- Injected by control-bar.js -->
        </div>

        <!-- NODE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="node-config">
                <span>⬢ Node Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-node-config">
                <!-- Size Mode Selector -->
                <div class="filter-group">
                    <div class="filter-label">Size Mode</div>
                    <div class="btn-grid btn-grid-4">
                        <button class="btn active" data-size-mode="uniform">Uniform</button>
                        <button class="btn" data-size-mode="degree">Degree</button>
                        <button class="btn" data-size-mode="fanout">Fanout</button>
                        <button class="btn" data-size-mode="complexity">Complex</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Base Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-size" min="0.2" max="4" step="0.1" value="1">
                        <input type="number" id="cfg-node-size-num" class="number-input" min="0.2" max="4" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-opacity" min="0.1" max="1" step="0.05" value="1">
                        <input type="number" id="cfg-node-opacity-num" class="number-input" min="0.1" max="1"
                            step="0.05" value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Resolution</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-node-res" min="4" max="32" step="4" value="8">
                        <input type="number" id="cfg-node-res-num" class="number-input" min="4" max="32" step="4"
                            value="8">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Label Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-label-size" min="0" max="3" step="0.1" value="1">
                        <input type="number" id="cfg-label-size-num" class="number-input" min="0" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="cfg-toggle-labels"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight Selected</span>
                    <div class="toggle active" id="cfg-toggle-highlight"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Pulse Animation</span>
                    <div class="toggle" id="cfg-toggle-pulse"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">3D Depth Shading</span>
                    <div class="toggle active" id="cfg-toggle-depth"></div>
                </div>
            </div>
        </div>

        <!-- EDGE CONFIG - PRIME POSITION -->
        <div class="section prime">
            <div class="section-header" data-section="edge-config">
                <span>⟷ Edge Config</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-edge-config">
                <!-- Edge Style Selector -->
                <div class="filter-group">
                    <div class="filter-label">Edge Style</div>
                    <div class="btn-grid">
                        <button class="btn active" data-edge-style="solid">Solid</button>
                        <button class="btn" data-edge-style="dashed">Dashed</button>
                        <button class="btn" data-edge-style="particle">Particle</button>
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-opacity" min="0" max="1" step="0.05" value="0.6">
                        <input type="number" id="cfg-edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.6">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Width</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-width" min="0.2" max="5" step="0.2" value="1.5">
                        <input type="number" id="cfg-edge-width-num" class="number-input" min="0.2" max="5" step="0.1"
                            value="1.5">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Curvature</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-edge-curve" min="0" max="1" step="0.05" value="0">
                        <input type="number" id="cfg-edge-curve-num" class="number-input" min="0" max="1" step="0.05"
                            value="0">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Speed</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-speed" min="0" max="0.05" step="0.005" value="0.01">
                        <input type="number" id="cfg-particle-speed-num" class="number-input" min="0" max="0.05"
                            step="0.005" value="0.01">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Particle Density</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="cfg-particle-count" min="0" max="10" step="1" value="0">
                        <input type="number" id="cfg-particle-count-num" class="number-input" min="0" max="10" step="1"
                            value="0">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Arrows</span>
                    <div class="toggle" id="cfg-toggle-arrows"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Gradient Colors</span>
                    <div class="toggle active" id="cfg-toggle-gradient"></div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Highlight on Hover</span>
                    <div class="toggle active" id="cfg-toggle-edge-hover"></div>
                </div>
            </div>
        </div>

        <!-- LAYOUT -->
        <div class="section">
            <div class="section-header" data-section="layout">
                <span>Layout</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-layout">
                <div class="btn-grid">
                    <button class="btn layout-btn active" data-layout="force">Force</button>
                    <button class="btn layout-btn" data-layout="radial">Radial</button>
                    <button class="btn layout-btn" data-layout="orbital">Orbital</button>
                    <button class="btn layout-btn" data-layout="sphere">Sphere</button>
                    <button class="btn layout-btn" data-layout="grid">Grid</button>
                    <button class="btn layout-btn" data-layout="spiral">Spiral</button>
                </div>
            </div>
        </div>

        <!-- PHYSICS -->
        <div class="section">
            <div class="section-header" data-section="physics">
                <span>Physics</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-physics">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Repulsion</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-charge" min="-500" max="0" value="-120">
                        <input type="number" id="physics-charge-num" class="number-input" min="-500" max="0"
                            value="-120">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Link Distance</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-link" min="10" max="200" value="50">
                        <input type="number" id="physics-link-num" class="number-input" min="10" max="200" value="50">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Center Pull</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="physics-center" min="0" max="0.5" step="0.01" value="0.05">
                        <input type="number" id="physics-center-num" class="number-input" min="0" max="0.5" step="0.01"
                            value="0.05">
                    </div>
                </div>
                <div class="btn-grid btn-grid-4" style="margin-top: 8px;">
                    <button class="btn" data-physics="default">Def</button>
                    <button class="btn" data-physics="tight">Tight</button>
                    <button class="btn" data-physics="loose">Loose</button>
                    <button class="btn" data-physics="explosive">Boom</button>
                </div>
            </div>
        </div>

        <!-- APPEARANCE -->
        <div class="section">
            <div class="section-header" data-section="appearance">
                <span>Appearance</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-appearance">
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Node Size</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="node-size" min="0.2" max="3" step="0.1" value="1">
                        <input type="number" id="node-size-num" class="number-input" min="0.2" max="3" step="0.1"
                            value="1">
                    </div>
                </div>
                <div class="slider-row">
                    <div class="slider-header">
                        <span class="slider-label">Edge Opacity</span>
                    </div>
                    <div class="slider-controls">
                        <input type="range" id="edge-opacity" min="0" max="1" step="0.05" value="0.4">
                        <input type="number" id="edge-opacity-num" class="number-input" min="0" max="1" step="0.05"
                            value="0.4">
                    </div>
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Show Labels</span>
                    <div class="toggle active" id="toggle-labels"></div>
                </div>
                <!-- Starfield toggle REMOVED - nodes ARE the stars -->
            </div>
        </div>

        <!-- FILTERS -->
        <div class="section">
            <div class="section-header" data-section="filters">
                <span>Filters</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content" id="section-filters">
                <div class="filter-group">
                    <div class="filter-label">Tiers</div>
                    <div class="chips" id="filter-tiers"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Rings</div>
                    <div class="chips" id="filter-rings"></div>
                </div>
                <div class="filter-group">
                    <div class="filter-label">Edge Types</div>
                    <div class="chips" id="filter-edges"></div>
                </div>
            </div>
        </div>

        <!-- ACTIONS -->
        <div class="section">
            <div class="section-header collapsed" data-section="actions">
                <span>Actions</span>
                <span class="arrow">▼</span>
            </div>
            <div class="section-content collapsed" id="section-actions">
                <div class="btn-grid btn-grid-2">
                    <button class="btn" id="btn-reset">Reset View</button>
                    <button class="btn" id="btn-screenshot">Screenshot</button>
                    <button class="btn" id="btn-2d">Toggle 2D</button>
                    <button class="btn" id="btn-freeze">Freeze</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Graph Container -->
    <div id="3d-graph"></div>

    <!-- Sidebar Resize Handles -->
    <div class="sidebar-resize-handle left" id="left-resize-handle"></div>
    <div class="sidebar-resize-handle right" id="right-resize-handle"></div>

    <!-- Right Sidebar -->
    <div id="right-sidebar">
        <!-- Hover Info Panel -->
        <div class="info-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Node Info</span>
            </div>
            <div class="node-info" id="hover-panel">
                <div class="node-name" id="hover-name">Node Name</div>
                <div class="node-kind" id="hover-kind">function</div>
                <div class="info-row"><span class="label">Atom</span><span class="value" id="hover-atom">--</span></div>
                <div class="info-row"><span class="label">Family</span><span class="value" id="hover-family">--</span>
                </div>
                <div class="info-row"><span class="label">Ring</span><span class="value" id="hover-ring">--</span></div>
                <div class="info-row"><span class="label">Tier</span><span class="value" id="hover-tier">--</span></div>
                <div class="info-row"><span class="label">Role</span><span class="value" id="hover-role">--</span></div>
                <div class="node-file" id="hover-file"></div>
            </div>
            <div class="placeholder-text" id="hover-placeholder">Hover over a node to see details</div>
        </div>

        <!-- Selection Panel -->
        <div class="selection-panel">
            <div class="selection-header">
                <span class="selection-title">Selection</span>
                <span class="selection-count" id="selection-count">0</span>
            </div>
            <div id="selection-actions" style="display: none; margin-bottom: 10px;">
                <button class="selection-clear" id="selection-clear">Clear</button>
            </div>
            <div class="selection-list" id="selection-list">
                <div class="placeholder-text">Click nodes to select</div>
            </div>
        </div>

        <!-- Stats Panel -->
        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stats-item">
                    <div class="value" id="stats-nodes">0</div>
                    <div class="label">Visible</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-edges">0</div>
                    <div class="label">Edges</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-files">0</div>
                    <div class="label">Files</div>
                </div>
                <div class="stats-item">
                    <div class="value" id="stats-density">--</div>
                    <div class="label">Density</div>
                </div>
            </div>
        </div>

        <!-- COLOR SCHEMES (33 Named Gradients) - Primary color selection -->
        <div class="info-panel schemes-panel">
            <div class="info-panel-header collapsible" data-target="section-schemes">
                <span class="info-panel-title">Color Schemes</span>
                <span class="collapse-icon">▼</span>
            </div>
            <div class="section-content" id="section-schemes">
                <!-- Populated dynamically by sidebar.js -->
            </div>
        </div>

        <!-- COLOR MODE (Presets) - What dimension to color by -->
        <div class="info-panel color-panel">
            <div class="info-panel-header">
                <span class="info-panel-title">Color Mode</span>
            </div>
            <div class="section-content" id="section-color">
                <div class="btn-grid btn-grid-3">
                    <button class="btn color-btn active" data-preset="tier">Tier</button>
                    <button class="btn color-btn" data-preset="family">Family</button>
                    <button class="btn color-btn" data-preset="layer">Layer</button>
                    <button class="btn color-btn" data-preset="ring">Ring</button>
                    <button class="btn color-btn" data-preset="file">File</button>
                    <button class="btn color-btn" data-preset="flow">Flow</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Performance HUD -->
    <div id="perf-hud">
        <div class="perf-row">
            <span class="perf-label">FPS:</span>
            <span class="perf-value" id="perf-fps">60</span>
            <span class="perf-label">Frame:</span>
            <span class="perf-value" id="perf-frame">0ms</span>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast"></div>

    <!-- Core Application Injection -->
    <div id="selection-box"></div>
    <script>
        // ═══ MODULE: performance.js ═══
/**
 * COLLIDER PERFORMANCE SUBSYSTEM
 *
 * Provides frame-budget-aware animation scheduling, adaptive quality management,
 * and real-time performance monitoring for the WebGL visualization.
 *
 * Architecture:
 *   PerformanceMonitor  → measures frame times, detects stuttering
 *   AnimationScheduler  → manages animation queue, enforces frame budget
 *   AdaptiveQuality     → degrades/upgrades quality based on performance
 *   PositionOwnership   → enforces single-owner invariant for node positions
 *
 * Usage:
 *   PERF.monitor.start()
 *   PERF.scheduler.requestTransition(nodes, targetPositions, duration)
 *   PERF.quality.current  // 'ultra' | 'high' | 'medium' | 'low' | 'minimal'
 */

const PERF = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION (loaded from performance.tokens.json or defaults)
    // =========================================================================

    const CONFIG = {
        frameBudget: {
            targetFps: 60,
            targetFrameMs: 16.67,
            warningThreshold: 0.8,   // 80% of budget
            criticalThreshold: 1.5   // 150% of budget
        },
        nodeThresholds: {
            small: 100,
            medium: 500,
            large: 1000,
            massive: 5000
        },
        monitoring: {
            sampleWindowMs: 1000,
            sampleCount: 60,
            degradeAfterConsecutiveDrops: 10,
            upgradeAfterConsecutiveGood: 30
        }
    };

    // =========================================================================
    // PERFORMANCE MONITOR
    // Tracks frame times using a rolling window
    // =========================================================================

    const PerformanceMonitor = {
        _frameTimes: [],
        _lastFrameTime: 0,
        _frameCount: 0,
        _droppedFrames: 0,
        _consecutiveDrops: 0,
        _consecutiveGood: 0,
        _isRunning: false,
        _rafId: null,

        start() {
            if (this._isRunning) return;
            this._isRunning = true;
            this._lastFrameTime = performance.now();
            this._tick();
        },

        stop() {
            this._isRunning = false;
            if (this._rafId) {
                cancelAnimationFrame(this._rafId);
                this._rafId = null;
            }
        },

        _tick() {
            if (!this._isRunning) return;

            const now = performance.now();
            const frameTime = now - this._lastFrameTime;
            this._lastFrameTime = now;

            // Record frame time
            this._frameTimes.push(frameTime);
            if (this._frameTimes.length > CONFIG.monitoring.sampleCount) {
                this._frameTimes.shift();
            }

            this._frameCount++;

            // Check for dropped frame
            const budget = CONFIG.frameBudget.targetFrameMs;
            if (frameTime > budget * CONFIG.frameBudget.criticalThreshold) {
                this._droppedFrames++;
                this._consecutiveDrops++;
                this._consecutiveGood = 0;

                // Trigger quality degradation check
                if (this._consecutiveDrops >= CONFIG.monitoring.degradeAfterConsecutiveDrops) {
                    AdaptiveQuality.degrade();
                    this._consecutiveDrops = 0;
                }
            } else if (frameTime < budget * CONFIG.frameBudget.warningThreshold) {
                this._consecutiveGood++;
                this._consecutiveDrops = 0;

                // Trigger quality upgrade check
                if (this._consecutiveGood >= CONFIG.monitoring.upgradeAfterConsecutiveGood) {
                    AdaptiveQuality.upgrade();
                    this._consecutiveGood = 0;
                }
            }

            this._rafId = requestAnimationFrame(() => this._tick());
        },

        get fps() {
            if (this._frameTimes.length < 2) return 0;
            const avg = this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
            return Math.round(1000 / avg);
        },

        get avgFrameTime() {
            if (this._frameTimes.length === 0) return 0;
            return this._frameTimes.reduce((a, b) => a + b, 0) / this._frameTimes.length;
        },

        get lastFrameTime() {
            return this._frameTimes[this._frameTimes.length - 1] || 0;
        },

        get droppedFramePercent() {
            if (this._frameCount === 0) return 0;
            return Math.round((this._droppedFrames / this._frameCount) * 100);
        },

        get stats() {
            return {
                fps: this.fps,
                avgFrameTime: this.avgFrameTime.toFixed(2),
                lastFrameTime: this.lastFrameTime.toFixed(2),
                droppedPercent: this.droppedFramePercent,
                quality: AdaptiveQuality.current,
                owner: PositionOwnership.current
            };
        },

        reset() {
            this._frameTimes = [];
            this._frameCount = 0;
            this._droppedFrames = 0;
            this._consecutiveDrops = 0;
            this._consecutiveGood = 0;
        }
    };

    // =========================================================================
    // ADAPTIVE QUALITY MANAGER
    // Adjusts rendering quality based on performance
    // =========================================================================

    const QUALITY_TIERS = ['minimal', 'low', 'medium', 'high', 'ultra'];

    const QUALITY_SETTINGS = {
        ultra:   { refreshEvery: 1, flockEnabled: true,  labelDensity: 1.0, animDuration: 1500 },
        high:    { refreshEvery: 1, flockEnabled: false, labelDensity: 0.8, animDuration: 1200 },
        medium:  { refreshEvery: 2, flockEnabled: false, labelDensity: 0.5, animDuration: 800  },
        low:     { refreshEvery: 3, flockEnabled: false, labelDensity: 0.2, animDuration: 500  },
        minimal: { refreshEvery: 5, flockEnabled: false, labelDensity: 0.1, animDuration: 200  }
    };

    const AdaptiveQuality = {
        _current: 'high',
        _locked: false,
        _nodeCount: 0,
        _callbacks: [],

        init(nodeCount) {
            this._nodeCount = nodeCount;
            // Auto-select initial tier based on node count
            if (nodeCount <= CONFIG.nodeThresholds.small) {
                this._current = 'ultra';
            } else if (nodeCount <= CONFIG.nodeThresholds.medium) {
                this._current = 'high';
            } else if (nodeCount <= CONFIG.nodeThresholds.large) {
                this._current = 'medium';
            } else if (nodeCount <= CONFIG.nodeThresholds.massive) {
                this._current = 'low';
            } else {
                this._current = 'minimal';
            }
            console.log(`[PERF] Quality auto-set to '${this._current}' for ${nodeCount} nodes`);
            this._notify();
        },

        get current() { return this._current; },

        get settings() { return QUALITY_SETTINGS[this._current]; },

        set(tier) {
            if (!QUALITY_TIERS.includes(tier)) {
                console.warn(`[PERF] Unknown quality tier: ${tier}`);
                return;
            }
            this._current = tier;
            console.log(`[PERF] Quality set to '${tier}'`);
            this._notify();
        },

        degrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            if (idx > 0) {
                this._current = QUALITY_TIERS[idx - 1];
                console.log(`[PERF] Quality degraded to '${this._current}'`);
                this._notify();
            }
        },

        upgrade() {
            if (this._locked) return;
            const idx = QUALITY_TIERS.indexOf(this._current);
            // Don't upgrade beyond what node count allows
            const maxTier = this._getMaxTierForNodeCount();
            const maxIdx = QUALITY_TIERS.indexOf(maxTier);
            if (idx < maxIdx) {
                this._current = QUALITY_TIERS[idx + 1];
                console.log(`[PERF] Quality upgraded to '${this._current}'`);
                this._notify();
            }
        },

        lock() { this._locked = true; },
        unlock() { this._locked = false; },

        _getMaxTierForNodeCount() {
            const n = this._nodeCount;
            if (n <= CONFIG.nodeThresholds.small) return 'ultra';
            if (n <= CONFIG.nodeThresholds.medium) return 'high';
            if (n <= CONFIG.nodeThresholds.large) return 'medium';
            if (n <= CONFIG.nodeThresholds.massive) return 'low';
            return 'minimal';
        },

        onChange(callback) {
            this._callbacks.push(callback);
        },

        _notify() {
            this._callbacks.forEach(cb => cb(this._current, this.settings));
        }
    };

    // =========================================================================
    // POSITION OWNERSHIP
    // Enforces single-owner invariant for node positions (fx/fy/fz)
    // =========================================================================

    const OWNERS = ['none', 'transition', 'motion', 'flock', 'force'];

    const PositionOwnership = {
        _current: 'none',
        _animationId: null,

        get current() { return this._current; },

        acquire(owner, animationId = null) {
            if (!OWNERS.includes(owner)) {
                console.warn(`[PERF] Unknown position owner: ${owner}`);
                return false;
            }

            // Cancel any existing animation
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }

            this._current = owner;
            this._animationId = animationId;
            console.log(`[PERF] Position ownership: ${owner}`);
            return true;
        },

        release(owner) {
            if (this._current === owner) {
                if (this._animationId) {
                    cancelAnimationFrame(this._animationId);
                    this._animationId = null;
                }
                this._current = 'none';
                console.log(`[PERF] Position ownership released by ${owner}`);
            }
        },

        setAnimationId(id) {
            this._animationId = id;
        },

        cancelAnimation() {
            if (this._animationId) {
                cancelAnimationFrame(this._animationId);
                this._animationId = null;
            }
        }
    };

    // =========================================================================
    // ANIMATION SCHEDULER
    // Frame-budget-aware animation with throttling
    // =========================================================================

    const AnimationScheduler = {
        _refreshFrameCounter: 0,

        /**
         * Run a layout transition with frame budget awareness
         * @param {Object} options
         * @param {Array} options.nodes - Array of node objects
         * @param {Function} options.getTargetPosition - (node, index, total) => {x, y, z}
         * @param {number} options.duration - Animation duration in ms
         * @param {Function} options.onFrame - Called each frame with progress (0-1)
         * @param {Function} options.onComplete - Called when animation finishes
         * @param {Function} options.refresh - Function to call to refresh the graph
         */
        runTransition(options) {
            const { nodes, getTargetPosition, duration, onFrame, onComplete, refresh } = options;

            // Acquire ownership
            PositionOwnership.acquire('transition');

            const total = nodes.length;
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => getTargetPosition(n, i, total));

            const startTime = performance.now();
            const settings = AdaptiveQuality.settings;
            const actualDuration = Math.min(duration, settings.animDuration);

            this._refreshFrameCounter = 0;

            const animate = () => {
                // Check if we still own positions
                if (PositionOwnership.current !== 'transition') {
                    console.log('[PERF] Transition interrupted - lost ownership');
                    return;
                }

                const now = performance.now();
                const elapsed = now - startTime;
                const progress = Math.min(1, elapsed / actualDuration);

                // Smoothstep easing
                const eased = progress * progress * (3 - 2 * progress);

                // Update positions
                for (let i = 0; i < nodes.length; i++) {
                    const n = nodes[i];
                    const s = startPos[i];
                    const t = targetPos[i];
                    n.fx = s.x + (t.x - s.x) * eased;
                    n.fy = s.y + (t.y - s.y) * eased;
                    n.fz = s.z + (t.z - s.z) * eased;
                }

                // Throttled refresh based on quality settings
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                if (onFrame) onFrame(progress);

                if (progress < 1) {
                    const id = requestAnimationFrame(animate);
                    PositionOwnership.setAnimationId(id);
                } else {
                    PositionOwnership.release('transition');
                    if (onComplete) onComplete();
                }
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Run continuous motion (rotate/orbit) with throttling
         */
        runMotion(options) {
            const { nodes, getPosition, speed, refresh } = options;

            PositionOwnership.acquire('motion');

            const total = nodes.length;
            const settings = AdaptiveQuality.settings;
            let time = 0;

            this._refreshFrameCounter = 0;

            const animate = () => {
                if (PositionOwnership.current !== 'motion') {
                    console.log('[PERF] Motion interrupted - lost ownership');
                    return;
                }

                time += speed;

                for (let i = 0; i < nodes.length; i++) {
                    const pos = getPosition(nodes[i], i, total, time);
                    nodes[i].fx = pos.x;
                    nodes[i].fy = pos.y;
                    nodes[i].fz = pos.z;
                }

                // Throttled refresh
                this._refreshFrameCounter++;
                if (this._refreshFrameCounter >= settings.refreshEvery) {
                    this._refreshFrameCounter = 0;
                    if (refresh) refresh();
                }

                const id = requestAnimationFrame(animate);
                PositionOwnership.setAnimationId(id);
            };

            const id = requestAnimationFrame(animate);
            PositionOwnership.setAnimationId(id);
        },

        /**
         * Stop any running animation
         */
        stop() {
            PositionOwnership.cancelAnimation();
            PositionOwnership._current = 'none';
        }
    };

    // =========================================================================
    // HUD OVERLAY
    // Real-time performance display (toggleable)
    // =========================================================================

    const HUD = {
        _element: null,
        _visible: false,
        _updateInterval: null,

        init() {
            this._element = document.createElement('div');
            this._element.id = 'perf-hud';
            this._element.style.cssText = `
                position: fixed;
                bottom: 10px;
                left: 10px;
                background: rgba(0, 0, 0, 0.8);
                color: #0f0;
                font-family: 'SF Mono', Monaco, monospace;
                font-size: 11px;
                padding: 8px 12px;
                border-radius: 4px;
                z-index: 10000;
                display: none;
                min-width: 140px;
                border: 1px solid #333;
            `;
            document.body.appendChild(this._element);
        },

        show() {
            if (!this._element) this.init();
            this._element.style.display = 'block';
            this._visible = true;
            this._startUpdates();
        },

        hide() {
            if (this._element) {
                this._element.style.display = 'none';
            }
            this._visible = false;
            this._stopUpdates();
        },

        toggle() {
            if (this._visible) this.hide();
            else this.show();
        },

        _startUpdates() {
            if (this._updateInterval) return;
            this._updateInterval = setInterval(() => this._update(), 100);
        },

        _stopUpdates() {
            if (this._updateInterval) {
                clearInterval(this._updateInterval);
                this._updateInterval = null;
            }
        },

        _update() {
            if (!this._element || !this._visible) return;

            const stats = PerformanceMonitor.stats;
            const fpsColor = stats.fps >= 55 ? '#0f0' : stats.fps >= 30 ? '#ff0' : '#f00';

            this._element.innerHTML = `
                <div style="color: ${fpsColor}; font-weight: bold;">${stats.fps} FPS</div>
                <div style="color: #888;">Frame: ${stats.lastFrameTime}ms</div>
                <div style="color: #888;">Avg: ${stats.avgFrameTime}ms</div>
                <div style="color: #888;">Drops: ${stats.droppedPercent}%</div>
                <div style="color: #0af;">Quality: ${stats.quality}</div>
                <div style="color: #a0f;">Owner: ${stats.owner}</div>
            `;
        }
    };

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        monitor: PerformanceMonitor,
        quality: AdaptiveQuality,
        ownership: PositionOwnership,
        scheduler: AnimationScheduler,
        hud: HUD,
        config: CONFIG,

        /**
         * Initialize the performance subsystem
         * @param {number} nodeCount - Number of nodes in the graph
         * @param {Object} tokens - Optional performance tokens from JSON
         */
        init(nodeCount, tokens = null) {
            if (tokens) {
                Object.assign(CONFIG, tokens);
            }
            AdaptiveQuality.init(nodeCount);
            PerformanceMonitor.start();
            HUD.init();
            console.log('[PERF] Performance subsystem initialized');
        },

        /**
         * Check if flock simulation should be enabled
         */
        isFlockAllowed() {
            return AdaptiveQuality.settings.flockEnabled;
        },

        /**
         * Get current animation duration (adjusted for quality)
         */
        getAnimationDuration(requested) {
            return Math.min(requested, AdaptiveQuality.settings.animDuration);
        }
    };
})();

// Export for module systems if available
if (typeof module !== 'undefined' && module.exports) {
    module.exports = PERF;
}


// ═══ MODULE: modules/utils.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UTILS MODULE - Pure Utility Functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Zero-dependency pure functions for math, string, and data operations.
 * These functions have NO external state dependencies and can be used anywhere.
 *
 * @module UTILS
 * @version 1.0.0
 * @confidence 99%
 */

window.UTILS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // MATH UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clamp value to [0, 1] range
     * @param {number} value - Value to clamp
     * @returns {number} Clamped value
     */
    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    /**
     * Clamp value to [min, max] range
     * @param {number} value - Value to clamp
     * @param {number} min - Minimum bound
     * @param {number} max - Maximum bound
     * @returns {number} Clamped value
     */
    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Normalize value to [0, 1] based on max
     * @param {number} val - Value to normalize
     * @param {number} max - Maximum value
     * @returns {number} Normalized value
     */
    function normalize(val, max) {
        return Math.min(1, Math.max(0, val / max));
    }

    /**
     * Normalize metric value based on range
     * Handles degenerate ranges gracefully
     * @param {number} value - Value to normalize
     * @param {min: number, max: number} range - Range object
     * @returns {number} Normalized value in [0, 1]
     */
    function normalizeMetric(value, range) {
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }
        return clamp01((value - range.min) / (range.max - range.min));
    }

    /**
     * Calculate quantile from sorted values
     * @param {number[]} values - Array of numbers
     * @param {number} q - Quantile (0-1)
     * @returns {number} Quantile value
     */
    function quantile(values, q) {
        if (!values.length) return 0;
        const sorted = values.slice().sort((a, b) => a - b);
        const pos = (sorted.length - 1) * q;
        const base = Math.floor(pos);
        const rest = pos - base;
        if (sorted[base + 1] !== undefined) {
            return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
        }
        return sorted[base];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HASH & SEED UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Convert any value to a unit float [0, 1] via hashing
     * @param {*} value - Any value to hash
     * @returns {number} Hash as unit float
     */
    function hashToUnit(value) {
        const str = String(value || '');
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return (hash >>> 0) / 0xffffffff;
    }

    /**
     * Generate stable seed from node and salt
     * @param {Object} node - Node object with id/name
     * @param {string} salt - Salt string
     * @returns {number} Stable seed in [0, 1]
     */
    function stableSeed(node, salt) {
        const id = String(node.id || node.name || '');
        const combined = `${id}|${salt}`;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
            hash = ((hash << 5) - hash + combined.charCodeAt(i)) | 0;
        }
        return ((hash >>> 0) % 1000) / 1000;
    }

    /**
     * Generate stable Z offset for node
     * @param {Object} node - Node object
     * @returns {number} Z offset
     */
    function stableZ(node) {
        const normalized = stableSeed(node, 'z');
        return (normalized - 0.5) * 60;
    }

    /**
     * Generate stable offset vector for node positioning
     * @param {Object} node - Node object
     * @param {string} salt - Salt string
     * @param {number} radius - Base radius
     * @returns {x: number, y: number, z: number} Offset vector
     */
    function stableOffset(node, salt, radius) {
        const angle = stableSeed(node, `${salt}:angle`) * Math.PI * 2;
        const spread = 0.3 + stableSeed(node, `${salt}:radius`) * 0.7;
        const zJitter = (stableSeed(node, `${salt}:z`) - 0.5) * radius * 0.6;
        const dist = radius * spread;
        return {
            x: Math.cos(angle) * dist,
            y: Math.sin(angle) * dist,
            z: zJitter
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STRING UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Escape HTML special characters
     * @param {string} text - Text to escape
     * @returns {string} Escaped HTML
     */
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    /**
     * Parse OKLCH color string
     * @param {string} value - OKLCH color string
     * @returns {L: number, C: number, H: number, A: number}|null} Parsed values or null
     */
    function parseOklchString(value) {
        if (typeof value !== 'string') return null;
        const match = value.trim().match(/^oklch\(\s*([\d.]+)%\s+([\d.]+)\s+([\d.]+)(?:\s*\/\s*([\d.]+))?\s*\)$/i);
        if (!match) return null;
        return {
            L: parseFloat(match[1]),
            C: parseFloat(match[2]),
            H: parseFloat(match[3]),
            A: match[4] !== undefined ? parseFloat(match[4]) : 1
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Resolve defaults against available values
     * @param {Array} defaults - Preferred defaults
     * @param {Array} available - Available values
     * @returns {Array} Resolved values
     */
    function resolveDefaults(defaults, available) {
        if (!Array.isArray(defaults) || defaults.length === 0) {
            return available;
        }
        const availableSet = new Set(available);
        const intersection = defaults.filter(value => availableSet.has(value));
        return intersection.length ? intersection : available;
    }

    /**
     * Build dataset key from data object
     * @param {Object} data - Data object with meta, nodes, links
     * @returns {string} Dataset key
     */
    function buildDatasetKey(data) {
        const meta = (data && data.meta) ? data.meta : {};
        const target = meta.target || meta.project || 'dataset';
        const version = meta.version || '';
        const nodeCount = Array.isArray(data?.nodes) ? data.nodes.length : 0;
        const edgeCount = Array.isArray(data?.links)
            ? data.links.length
            : (Array.isArray(data?.edges) ? data.edges.length : 0);
        const raw = `${target}|${nodeCount}|${edgeCount}|${version}`;
        return raw.replace(/[^a-zA-Z0-9_.-]/g, '_').slice(0, 180);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GEOMETRY UTILITIES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Calculate bounding box from two points
     * @param {x: number, y: number} start - Start point
     * @param {x: number, y: number} end - End point
     * @returns {left: number, top: number, width: number, height: number, right: number, bottom: number} Box rect
     */
    function getBoxRect(start, end) {
        const left = Math.min(start.x, end.x);
        const top = Math.min(start.y, end.y);
        const width = Math.abs(start.x - end.x);
        const height = Math.abs(start.y - end.y);
        return {
            left,
            top,
            width,
            height,
            right: left + width,
            bottom: top + height
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Math
        clamp01,
        clampValue,
        normalize,
        normalizeMetric,
        quantile,

        // Hash & Seed
        hashToUnit,
        stableSeed,
        stableZ,
        stableOffset,

        // String
        escapeHtml,
        parseOklchString,

        // Data
        resolveDefaults,
        buildDatasetKey,

        // Geometry
        getBoxRect
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════
// These ensure existing code continues to work without modification

window.clamp01 = UTILS.clamp01;
window.clampValue = UTILS.clampValue;
window.normalize = UTILS.normalize;
window.normalizeMetric = UTILS.normalizeMetric;
window.quantile = UTILS.quantile;
window.hashToUnit = UTILS.hashToUnit;
window.stableSeed = UTILS.stableSeed;
window.stableZ = UTILS.stableZ;
window.stableOffset = UTILS.stableOffset;
window.escapeHtml = UTILS.escapeHtml;
window.parseOklchString = UTILS.parseOklchString;
window.resolveDefaults = UTILS.resolveDefaults;
window.buildDatasetKey = UTILS.buildDatasetKey;
window.getBoxRect = UTILS.getBoxRect;

console.log('[Module] UTILS loaded - 14 pure functions');


// ═══ MODULE: modules/registry.js ═══
/**
 * @module registry
 * @description Centralized UI and command registration system
 * @responsibility Manage DOM element and command handler registration
 */

const REGISTRY = (function() {
    'use strict';

    // Private state
    const _items = new Map();
    const _commands = new Map();

    /**
     * Register a command handler or DOM element
     * @param {string} id - The identifier
     * @param {Function|Element} item - Handler function or DOM element
     * @param {Object} options - Additional options
     */
    function register(id, item, options = {}) {
        // CASE 1: Registering a Command Identifier + Handler Function
        // e.g. REGISTRY.register('cmd-files', () => toggleFiles(), { desc: '...' })
        if (typeof item === 'function') {
            _commands.set(id, { handler: item, options });

            // Auto-wire if DOM element exists with this ID
            const btn = document.getElementById(id);
            if (btn) {
                btn.onclick = (e) => {
                    item(e);
                };
                btn.setAttribute('data-command-id', id);
            }
            return;
        }

        // CASE 2: Registering a DOM Element directly
        let element = item;
        let elementId = id;

        // Overload: register(element) -> id comes from element.id
        if ((item instanceof Element) && arguments.length === 1) {
            element = item;
            elementId = element.id;
        }
        // Overload: register(id, element)
        else if (item instanceof Element) {
            element = item;
        }
        // Fallback: mismatched args
        else if (!element && (typeof id === 'object' && id instanceof Element)) {
            element = id;
            elementId = element.id;
        }

        if (!element || !element.setAttribute) {
            return;
        }

        if (!elementId) {
            return;
        }

        _items.set(elementId, element);
        element.setAttribute('data-registry-id', elementId);
    }

    /**
     * Get a registered element by ID (falls back to document.getElementById)
     * @param {string} id - The element ID
     * @returns {Element|null}
     */
    function get(id) {
        return _items.get(id) || document.getElementById(id);
    }

    /**
     * Get a registered command handler
     * @param {string} id - The command ID
     * @returns {Object|undefined} - { handler, options }
     */
    function getCommand(id) {
        return _commands.get(id);
    }

    /**
     * Execute a registered command
     * @param {string} id - The command ID
     * @param {Event} event - Optional event object
     * @returns {*} - Result of handler execution
     */
    function execute(id, event) {
        const cmd = _commands.get(id);
        if (cmd && typeof cmd.handler === 'function') {
            return cmd.handler(event);
        }
        console.warn(`[Registry] Command not found: ${id}`);
        return undefined;
    }

    /**
     * Check if a command is registered
     * @param {string} id - The command ID
     * @returns {boolean}
     */
    function hasCommand(id) {
        return _commands.has(id);
    }

    /**
     * Check if an element is registered
     * @param {string} id - The element ID
     * @returns {boolean}
     */
    function hasElement(id) {
        return _items.has(id);
    }

    /**
     * Get all registered command IDs
     * @returns {string[]}
     */
    function listCommands() {
        return Array.from(_commands.keys());
    }

    /**
     * Get all registered element IDs
     * @returns {string[]}
     */
    function listElements() {
        return Array.from(_items.keys());
    }

    // Public API
    return {
        register,
        get,
        getCommand,
        execute,
        hasCommand,
        hasElement,
        listCommands,
        listElements,
        // Expose maps for backward compatibility (read-only access pattern)
        get items() { return _items; },
        get commands() { return _commands; }
    };
})();

// Expose globally for backward compatibility
window.REGISTRY = REGISTRY;


// ═══ MODULE: modules/perf-monitor.js ═══
/**
 * @module perf-monitor
 * @description Real-time performance monitoring and FPS diagnostics
 * @responsibility Track frame delivery, detect dropped frames, display HUD
 */

const PERF = (function() {
    'use strict';

    // Configuration
    const _config = {
        enabled: true,
        maxFrames: 60,
        droppedFrameThreshold: 50  // ms (>50ms = <20fps)
    };

    // State
    const _state = {
        fps: 0,
        frameTime: 0,
        lastFrameTime: 0,
        frameTimes: [],
        renderCalls: 0,
        droppedFrames: 0,
        lastSecond: 0,
        framesThisSecond: 0,
        hudElement: null,
        monitoring: false
    };

    /**
     * Initialize the performance monitor
     */
    function init() {
        if (!_config.enabled) return;

        // Create HUD element
        _state.hudElement = document.createElement('div');
        _state.hudElement.id = 'perf-hud';
        _state.hudElement.style.cssText = `
            position: fixed; top: 10px; right: 10px; z-index: 99999;
            background: rgba(0,0,0,0.85); color: #0f0; font-family: monospace;
            font-size: 11px; padding: 8px 12px; border-radius: 4px;
            border: 1px solid #333; min-width: 140px; pointer-events: none;
        `;
        document.body.appendChild(_state.hudElement);
        _startMonitoring();
    }

    /**
     * Start the monitoring loop
     */
    function _startMonitoring() {
        if (_state.monitoring) return;
        _state.monitoring = true;

        const monitor = () => {
            if (!_state.monitoring) return;

            const now = performance.now();

            // Calculate frame time
            if (_state.lastFrameTime > 0) {
                _state.frameTime = now - _state.lastFrameTime;
                _state.frameTimes.push(_state.frameTime);
                if (_state.frameTimes.length > _config.maxFrames) {
                    _state.frameTimes.shift();
                }

                // Detect dropped frames
                if (_state.frameTime > _config.droppedFrameThreshold) {
                    _state.droppedFrames++;
                }
            }
            _state.lastFrameTime = now;

            // Calculate FPS every second
            const second = Math.floor(now / 1000);
            if (second !== _state.lastSecond) {
                _state.fps = _state.framesThisSecond;
                _state.framesThisSecond = 0;
                _state.lastSecond = second;
            }
            _state.framesThisSecond++;

            // Update HUD
            _updateHUD();
            requestAnimationFrame(monitor);
        };
        requestAnimationFrame(monitor);
    }

    /**
     * Update the HUD display
     */
    function _updateHUD() {
        if (!_state.hudElement) return;

        const avgFrameTime = _state.frameTimes.length > 0
            ? (_state.frameTimes.reduce((a, b) => a + b, 0) / _state.frameTimes.length).toFixed(1)
            : '0.0';

        // Color code FPS
        let fpsColor = '#0f0';  // Green = good
        if (_state.fps < 30) fpsColor = '#ff0';  // Yellow = warning
        if (_state.fps < 15) fpsColor = '#f00';  // Red = bad

        // Animation state - use ANIM module if available
        const isAnimating = typeof ANIM !== 'undefined' && ANIM.isAnimating;
        const animating = isAnimating ? '▶ ANIMATING' : '■ IDLE';
        const animColor = isAnimating ? '#0ff' : '#666';
        const staggerPattern = (typeof ANIM !== 'undefined' && ANIM.staggerPattern) || 'none';

        _state.hudElement.innerHTML = `
            <div style="color:${fpsColor};font-size:14px;font-weight:bold">${_state.fps} FPS</div>
            <div>Frame: ${avgFrameTime}ms</div>
            <div>Dropped: <span style="color:${_state.droppedFrames > 10 ? '#f00' : '#0f0'}">${_state.droppedFrames}</span></div>
            <div style="color:${animColor}">${animating}</div>
            <div style="font-size:9px;color:#666;margin-top:4px">Pattern: ${staggerPattern}</div>
        `;
    }

    /**
     * Log a performance resistance point
     * @param {string} location - Where the resistance occurred
     * @param {number} duration - Duration in milliseconds
     */
    function logResistance(location, duration) {
        if (duration > 16) {
            console.warn(`[PERF RESISTANCE] ${location}: ${duration.toFixed(1)}ms (>${Math.floor(duration / 16.67)} frames)`);
        }
    }

    /**
     * Stop monitoring
     */
    function stop() {
        _state.monitoring = false;
        if (_state.hudElement && _state.hudElement.parentNode) {
            _state.hudElement.parentNode.removeChild(_state.hudElement);
        }
        _state.hudElement = null;
    }

    /**
     * Reset statistics
     */
    function reset() {
        _state.fps = 0;
        _state.frameTime = 0;
        _state.frameTimes = [];
        _state.droppedFrames = 0;
        _state.framesThisSecond = 0;
    }

    /**
     * Toggle HUD visibility
     */
    function toggle() {
        if (_state.hudElement) {
            _state.hudElement.style.display =
                _state.hudElement.style.display === 'none' ? 'block' : 'none';
        }
    }

    /**
     * Enable/disable monitoring
     * @param {boolean} enabled
     */
    function setEnabled(enabled) {
        _config.enabled = enabled;
        if (!enabled) {
            stop();
        } else if (!_state.monitoring) {
            init();
        }
    }

    // Public API
    return {
        init,
        stop,
        reset,
        toggle,
        setEnabled,
        logResistance,
        // Read-only state access
        get fps() { return _state.fps; },
        get frameTime() { return _state.frameTime; },
        get droppedFrames() { return _state.droppedFrames; },
        get enabled() { return _config.enabled; },
        get monitoring() { return _state.monitoring; }
    };
})();

// Backward compatibility alias
const PERF_MONITOR = PERF;

// Expose globally
window.PERF = PERF;
window.PERF_MONITOR = PERF_MONITOR;


// ═══ MODULE: modules/core.js ═══
/**
 * CORE MODULE
 *
 * Foundation constants and utility functions for the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   CORE.SELECTION_SIZE_MULT      // Node size multiplier when selected
 *   CORE.PENDULUM                 // OKLCH color oscillator state
 *   CORE.amplify(value, gamma)    // Power law amplification
 *   CORE.amplifyContrast(value)   // S-curve contrast expansion
 */

const CORE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

    // OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
    const PENDULUM = {
        hue: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,        // Set from appearance.tokens
            gravity: null,        // Set from appearance.tokens
            length: 1.0,
            rotationSpeed: null   // Set from appearance.tokens
        },
        chroma: {
            angle: Math.random() * Math.PI * 2,
            velocity: 0,
            damping: null,
            gravity: null,
            length: 1.0,
            center: null,
            amplitude: null
        },
        lightness: {
            phase: 0,
            speed: null,
            center: null,
            amplitude: null
        },
        ripple: {
            speed: null,
            scale: null
        },
        currentHue: Math.random() * 360,
        lastTime: 0,
        running: false
    };

    // =========================================================================
    // AMPLIFICATION UTILITIES
    // =========================================================================

    /**
     * Amplification function using power law: f(x) = x^(1/gamma)
     * Maps normalized [0,1] input to amplified [0,1] output
     * @param {number} value - Input value (0-1)
     * @param {number} gamma - Amplification factor (default from APPEARANCE_STATE)
     * @returns {number} Amplified value (0-1)
     */
    function amplify(value, gamma) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const g = gamma !== undefined ? gamma :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (g === 1) return value;
        // Clamp to valid range
        const v = Math.max(0, Math.min(1, value));
        // Power law: v^(1/gamma) - when gamma>1, small diffs become larger
        // Using 1/gamma so that higher slider = more amplification
        return Math.pow(v, 1 / g);
    }

    /**
     * Contrast amplification: expands values away from midpoint
     * Uses S-curve (tanh) for smooth contrast expansion
     * @param {number} value - Input value (0-1)
     * @param {number} strength - Contrast strength (default from APPEARANCE_STATE)
     * @returns {number} Contrast-enhanced value (0-1)
     */
    function amplifyContrast(value, strength) {
        // Use global APPEARANCE_STATE if available, otherwise default to 1
        const s = strength !== undefined ? strength :
            (typeof APPEARANCE_STATE !== 'undefined' ? APPEARANCE_STATE.amplifier : 1);
        if (s === 1) return value;
        const v = Math.max(0, Math.min(1, value));
        // S-curve using tanh for smooth contrast expansion
        const centered = (v - 0.5) * 2;  // [-1, 1]
        const amplified = Math.tanh(centered * s) / Math.tanh(s);
        return (amplified + 1) / 2;  // Back to [0, 1]
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Constants
        SELECTION_SIZE_MULT,
        PENDULUM,

        // Utilities
        amplify,
        amplifyContrast
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'SELECTION_SIZE_MULT', {
    get: () => CORE.SELECTION_SIZE_MULT,
    configurable: true
});
Object.defineProperty(window, 'PENDULUM', {
    get: () => CORE.PENDULUM,
    configurable: true
});
Object.defineProperty(window, 'amplify', {
    get: () => CORE.amplify,
    configurable: true
});
Object.defineProperty(window, 'amplifyContrast', {
    get: () => CORE.amplifyContrast,
    configurable: true
});


// ═══ MODULE: modules/node-accessors.js ═══
/**
 * NODE ACCESSORS MODULE
 *
 * Provides standardized access to node properties across the visualization.
 * Zero dependencies - this is a foundation module.
 *
 * Usage:
 *   NODE.getTier(node)       // Returns 'T0', 'T1', 'T2', or 'UNKNOWN'
 *   NODE.getFamily(node)     // Returns 'LOG', 'DAT', 'ORG', 'EXE', 'EXT', or 'UNKNOWN'
 *   NODE.getRing(node)       // Returns ring/layer value
 *   NODE.getLayer(node)      // Returns D2_LAYER value
 *   NODE.getEffect(node)     // Returns D6_EFFECT value
 */

const NODE = (function() {
    'use strict';

    // =========================================================================
    // TIER SYSTEM
    // =========================================================================

    // Tier aliases: legacy names -> canonical T0/T1/T2
    const TIER_ALIASES = {
        'CORE': 'T0', 'T0': 'T0',
        'ARCH': 'T1', 'T1': 'T1',
        'EXT': 'T2', 'T2': 'T2',
        'DISCOVERED': 'T2',  // EXT.DISCOVERED -> T2
        'UNKNOWN': 'UNKNOWN'
    };

    function normalizeTier(tier) {
        if (!tier) return 'UNKNOWN';
        const upper = String(tier).toUpperCase();
        return TIER_ALIASES[upper] || upper;
    }

    // Prefer canonical node.tier field; fallback to atom prefix inference
    function getTier(node) {
        // If node is a string (backward compat: called with atomId), infer from prefix
        if (typeof node === 'string') {
            const atomId = node;
            if (!atomId) return 'UNKNOWN';
            if (atomId.startsWith('CORE.')) return 'T0';
            if (atomId.startsWith('ARCH.')) return 'T1';
            if (atomId.startsWith('EXT.')) return 'T2';
            return 'UNKNOWN';
        }
        // Prefer canonical field
        if (node.tier) {
            return normalizeTier(node.tier);
        }
        // Fallback: infer from atom prefix
        const atomId = String(node.atom || '');
        if (atomId.startsWith('CORE.')) return 'T0';
        if (atomId.startsWith('ARCH.')) return 'T1';
        if (atomId.startsWith('EXT.')) return 'T2';
        return 'UNKNOWN';
    }

    // =========================================================================
    // FAMILY SYSTEM
    // =========================================================================

    // Get atom family from canonical field or infer from atom prefix
    function getFamily(node) {
        // Prefer canonical field
        if (node.atom_family) {
            return String(node.atom_family).toUpperCase();
        }
        // Fallback: infer from atom (e.g., "LOG.FNC.M" -> "LOG")
        const atomId = String(node.atom || '');
        const dotIdx = atomId.indexOf('.');
        if (dotIdx > 0) {
            return atomId.substring(0, dotIdx).toUpperCase();
        }
        return 'UNKNOWN';
    }

    // =========================================================================
    // RING SYSTEM
    // =========================================================================

    function normalizeRing(value) {
        if (value === null || value === undefined) return null;
        const ring = String(value).trim().toUpperCase();
        if (!ring) return null;
        const aliases = {
            TEST: 'TESTING'
        };
        return aliases[ring] || ring;
    }

    function getRing(node) {
        const ring = node.ring || node.layer || 'UNKNOWN';
        return normalizeRing(ring) || 'UNKNOWN';
    }

    // =========================================================================
    // LAYER SYSTEM (D2_LAYER)
    // =========================================================================

    function getLayer(node) {
        if (!node) return 'Unknown';
        return node.layer || node.dimensions?.D2_LAYER || 'Unknown';
    }

    // =========================================================================
    // EFFECT SYSTEM (D6_EFFECT)
    // =========================================================================

    function getEffect(node) {
        if (!node) return 'Unknown';
        return node.effect || node.dimensions?.D6_EFFECT || 'Unknown';
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Tier
        getTier,
        normalizeTier,
        TIER_ALIASES,

        // Family
        getFamily,

        // Ring
        getRing,
        normalizeRing,

        // Layer
        getLayer,

        // Effect
        getEffect
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'getNodeTier', { get: () => NODE.getTier, configurable: true });
Object.defineProperty(window, 'getNodeAtomFamily', { get: () => NODE.getFamily, configurable: true });
Object.defineProperty(window, 'getNodeRing', { get: () => NODE.getRing, configurable: true });
Object.defineProperty(window, 'getNodeLayer', { get: () => NODE.getLayer, configurable: true });
Object.defineProperty(window, 'getNodeEffect', { get: () => NODE.getEffect, configurable: true });
Object.defineProperty(window, 'normalizeTier', { get: () => NODE.normalizeTier, configurable: true });
Object.defineProperty(window, 'normalizeRingValue', { get: () => NODE.normalizeRing, configurable: true });
Object.defineProperty(window, 'TIER_ALIASES', { get: () => NODE.TIER_ALIASES, configurable: true });


// ═══ MODULE: modules/node-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * NODE-HELPERS MODULE - Node classification and color functions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node color mode selection, data enrichment helpers, and tier grouping.
 * Depends on: COLOR (ColorOrchestrator), NODE (node-accessors), DM, Graph
 *
 * @module NODE_HELPERS
 * @version 1.0.0
 */

window.NODE_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR BY MODE
    // ═══════════════════════════════════════════════════════════════════════

    // =========================================================================
    // MODE_ACCESSORS: Declarative map replacing the mega-switch
    // Each mode maps to a function: (node, Color) => colorString
    // =========================================================================

    const MODE_ACCESSORS = {
        // 1. ARCHITECTURE
        tier:           (n, C) => C.get('tier', window.getNodeTier(n)),
        layer:          (n, C) => C.get('layer', (n.layer || n.dimensions?.D2_LAYER || 'UNKNOWN').toUpperCase()),
        subsystem:      (n, C) => C.get('subsystem', getSubsystem(n)),
        boundary_score: (n, C) => C.getInterval('boundary_score', window.normalize(n.rpbl?.boundary ?? 1, 9)),
        phase:          (n, C) => C.get('phase', getPhase(n)),

        // 2. TAXONOMY
        atom:           (n, C) => C.get('atom', (n.kind || n.type || 'unknown').toLowerCase()),
        family:         (n, C) => C.get('family', window.getNodeAtomFamily(n)),
        role:           (n, C) => C.get('roleCategory', n.role_cat || 'Unknown'),
        roleCategory:   (n, C) => C.get('roleCategory', n.role_cat || getRoleCategory(n)),
        fileType:       (n, C) => C.get('fileType', getFileType(n)),

        // 3. METRICS
        complexity:     (n, C) => C.getInterval('complexity', window.normalize(n.complexity || 0, 20)),
        loc:            (n, C) => C.getInterval('loc', window.normalize(n.lines_of_code || 0, 500)),
        fan_in:         (n, C) => C.getInterval('fan_in', window.normalize(n.in_degree || 0, 20)),
        fan_out:        (n, C) => C.getInterval('fan_out', window.normalize(n.out_degree || 0, 20)),
        trust:          (n, C) => C.getInterval('trust', n.trust || n.confidence || 0),

        // 4. RPBL DNA
        responsibility: (n, C) => C.getInterval('responsibility', window.normalize(n.rpbl?.responsibility ?? 1, 9)),
        purity:         (n, C) => C.getInterval('purity', window.normalize(n.rpbl?.purity ?? 1, 9)),
        lifecycle_score:(n, C) => C.getInterval('lifecycle_score', window.normalize(n.rpbl?.lifecycle ?? 1, 9)),
        state:          (n, C) => C.get('state', (n.dimensions?.D5_STATE === 'Stateful') ? 'Stateful' : 'Stateless'),
        visibility:     (n, C) => C.get('visibility', n.dimensions?.D4_BOUNDARY === 'External' ? 'Public' : 'Private'),

        // 5. TOPOLOGY
        centrality:     (n, C) => C.getInterval('centrality', n.centrality || 0),
        rank:           (n, C) => C.getInterval('centrality', n.pagerank || 0),
        ring:           (n, C) => C.get('ring', window.getNodeRing(n)),

        // 6. EVOLUTION (Placeholders)
        churn:          (n, C) => C.getInterval('churn', Math.random() * 0.5),
        age:            (n, C) => C.getInterval('churn', 0.2)
    };

    function getNodeColorByMode(node) {
        const Color = window.Color;
        const NODE_COLOR_MODE = window.NODE_COLOR_MODE;
        const DM = window.DM;

        // Special case: file coloring needs extra context
        if (NODE_COLOR_MODE === 'file') {
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx < 0) return Color.get('tier', 'UNKNOWN');
            const fileBoundaries = DM ? DM.getFileBoundaries() : [];
            const totalFiles = fileBoundaries.length;
            const fileInfo = fileBoundaries[fileIdx] || {};
            const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
            return window.getFileColor(fileIdx, totalFiles, fileLabel);
        }

        // Use MODE_ACCESSORS map - O(1) lookup instead of if-chain
        const accessor = MODE_ACCESSORS[NODE_COLOR_MODE];
        if (accessor) return accessor(node, Color);

        // Default fallback
        return Color.get('tier', window.getNodeTier(node));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATA ENRICHMENT HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getSubsystem(node) {
        if (!node.file_path) return 'Unknown';
        if (node.file_path.includes('/api/')) return 'Ingress';
        if (node.file_path.includes('/db/') || node.file_path.includes('repository')) return 'Persistence';
        if (node.file_path.includes('/core/') || node.file_path.includes('domain')) return 'Domain';
        if (node.file_path.includes('/ui/') || node.file_path.includes('frontend')) return 'Presentation';
        if (node.file_path.includes('config')) return 'Config';
        return 'Domain';
    }

    function getPhase(node) {
        const kind = (node.kind || '').toLowerCase();
        if (kind.includes('data') || kind.includes('entity') || kind.includes('schema')) return 'DATA';
        if (kind.includes('function') || kind.includes('logic')) return 'LOGIC';
        if (kind.includes('module') || kind.includes('package')) return 'ORGANIZATION';
        if (kind.includes('script') || kind.includes('main')) return 'EXECUTION';
        return 'LOGIC';
    }

    function getFileType(node) {
        const p = node.file_path || node.id || '';
        const ext = p.split('.').pop().toLowerCase();
        return ext || 'unknown';
    }

    function getRoleCategory(node) {
        const r = (node.role || '').toLowerCase();
        if (r.includes('service') || r.includes('manager')) return 'Orchestration';
        if (r.includes('repo') || r.includes('store')) return 'Storage';
        if (r.includes('controller') || r.includes('handler')) return 'Ingress';
        if (r.includes('util') || r.includes('helper')) return 'Utility';
        return 'Unknown';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE COLOR APPLICATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeColors(nodes) {
        const DM = window.DM;
        const fileBoundaries = DM ? DM.getFileBoundaries() : [];
        nodes.forEach(node => {
            if (node && node.isFileNode) {
                if (!node.color) {
                    const totalFiles = fileBoundaries.length;
                    const fileInfo = fileBoundaries[node.fileIdx] || {};
                    const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                    node.color = window.getFileColor(node.fileIdx, totalFiles, fileLabel);
                }
                return;
            }
            if (window.fileMode) {
                return;
            }
            node.color = getNodeColorByMode(node);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SIZE MODE
    // ═══════════════════════════════════════════════════════════════════════

    function applyNodeSizeMode(mode) {
        const Graph = window.Graph;
        if (!Graph) return;
        const scale = window.APPEARANCE_STATE?.nodeScale || 1;
        switch (mode) {
            case 'uniform':
                Graph.nodeVal(() => 1 * scale);
                break;
            case 'degree':
                Graph.nodeVal(n => Math.max(1, ((n.in_degree || 0) + (n.out_degree || 0)) * 0.5) * scale);
                break;
            case 'fanout':
                Graph.nodeVal(n => (n.val || n.fanout || 1) * scale);
                break;
            case 'complexity':
                Graph.nodeVal(n => Math.max(1, (n.complexity || n.loc || 10) * 0.05) * scale);
                break;
            default:
                Graph.nodeVal(n => (n.val || 1) * scale);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER/DEPTH/SIMILARITY HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNodeTierValue(node) {
        if (!node) return 1;
        const tier = window.getNodeTier(node);
        if (tier === 'T0') return 0;
        if (tier === 'T1') return 1;
        if (tier === 'T2') return 2;
        return 1;
    }

    function getNodeDepth(node) {
        if (node && typeof node.y === 'number') {
            return Math.abs(node.y) / 500;
        }
        return 0.5;
    }

    function getSemanticSimilarity(srcNode, tgtNode) {
        if (!srcNode || !tgtNode) return 0.5;
        let score = 0;
        if (srcNode.type === tgtNode.type) score += 0.4;
        if (srcNode.fileIdx === tgtNode.fileIdx) score += 0.3;
        if (window.getNodeTier(srcNode) === window.getNodeTier(tgtNode)) score += 0.2;
        if (srcNode.ring === tgtNode.ring) score += 0.1;
        return score;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TIER GROUPING
    // ═══════════════════════════════════════════════════════════════════════

    function groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = window.getNodeTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getColorByMode: getNodeColorByMode,
        getSubsystem: getSubsystem,
        getPhase: getPhase,
        getFileType: getFileType,
        getRoleCategory: getRoleCategory,
        applyColors: applyNodeColors,
        applySizeMode: applyNodeSizeMode,
        getTierValue: getNodeTierValue,
        getDepth: getNodeDepth,
        getSemanticSimilarity: getSemanticSimilarity,
        groupByTier: groupNodesByTier
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getNodeColorByMode = NODE_HELPERS.getColorByMode;
window.getSubsystem = NODE_HELPERS.getSubsystem;
window.getPhase = NODE_HELPERS.getPhase;
window.getFileType = NODE_HELPERS.getFileType;
window.getRoleCategory = NODE_HELPERS.getRoleCategory;
window.applyNodeColors = NODE_HELPERS.applyColors;
window.applyNodeSizeMode = NODE_HELPERS.applySizeMode;
window.getNodeTierValue = NODE_HELPERS.getTierValue;
window.getNodeDepth = NODE_HELPERS.getDepth;
window.getSemanticSimilarity = NODE_HELPERS.getSemanticSimilarity;
window.groupNodesByTier = NODE_HELPERS.groupByTier;

console.log('[Module] NODE_HELPERS loaded - 11 functions');


// ═══ MODULE: modules/color-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * COLOR-HELPERS MODULE - Color utilities and conversions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Topology colors, color normalization, file hue generation.
 * Depends on: UTILS (parseOklchString, hashToUnit, clampValue), COLOR (oklchColor)
 *
 * @module COLOR_HELPERS
 * @version 1.0.0
 */

window.COLOR_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // TOPOLOGY COLOR LOOKUP
    // ═══════════════════════════════════════════════════════════════════════

    function getTopoColor(category, key) {
        const APPEARANCE_CONFIG = window.APPEARANCE_CONFIG;
        if (!APPEARANCE_CONFIG || !APPEARANCE_CONFIG.color) return { l: 50, c: 0, h: 0 };

        let tokenKey = key;
        let section = 'atom-family'; // Default

        // Map legacy/UI keys to Token keys
        if (category === 'tiers') {
            section = 'atom';
            if (key === 'T0') tokenKey = 't0-core';
            else if (key === 'T1') tokenKey = 't1-arch';
            else if (key === 'T2') tokenKey = 't2-eco';
            else if (key === 'UNKNOWN') tokenKey = 'unknown';
        } else if (category === 'rings') {
            section = 'ring';
            if (key === 'KERNEL') tokenKey = 'DOMAIN';
            if (key === 'CORE') tokenKey = 'APPLICATION';
            if (key === 'SERVICE') tokenKey = 'PRESENTATION';
            if (key === 'ADAPTER') tokenKey = 'INTERFACE';
        } else if (category === 'families') {
            section = 'atom-family';
        }

        // Lookup token
        const tokenStr = APPEARANCE_CONFIG.color[section]?.[tokenKey] || APPEARANCE_CONFIG.color[section]?.['UNKNOWN'];

        // Parse OKLCH
        const parsed = window.parseOklchString(tokenStr);
        if (!parsed) return { l: 50, c: 0, h: 0 }; // Fallback gray

        // Normalize to internal l,c,h format (lowercase)
        return { l: parsed.L * 100, c: parsed.C, h: parsed.H };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLOR NORMALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeColorInput(color, fallback = 'rgb(128, 128, 128)') {
        if (color === null || color === undefined) {
            return fallback;
        }
        if (typeof color !== 'string') {
            return color;
        }
        const parsed = window.parseOklchString(color);
        if (parsed) {
            return window.oklchColor(parsed.L, parsed.C, parsed.H, parsed.A);
        }
        return color;
    }

    function toColorNumber(color, fallback = '#777777') {
        // Returns CSS hex string (polished-compatible) instead of JS hex int
        if (typeof color === 'number') {
            return '#' + color.toString(16).padStart(6, '0');
        }
        if (typeof color !== 'string') {
            return fallback;
        }
        const normalized = normalizeColorInput(color);
        if (typeof normalized === 'string') {
            color = normalized;
        }
        if (color.startsWith('#') || color.startsWith('rgb') || color.startsWith('hsl')) {
            return color;  // Already valid CSS color
        }
        try {
            const hex = new THREE.Color(color).getHex();
            return '#' + hex.toString(16).padStart(6, '0');
        } catch (err) {
            return fallback;
        }
    }

    function dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILE COLOR GENERATION
    // ═══════════════════════════════════════════════════════════════════════

    function getFileHue(fileIdx, totalFiles, fileName) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const strategy = FILE_COLOR_CONFIG.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return window.hashToUnit(seed) * 360;
        }
        const angle = FILE_COLOR_CONFIG.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const FILE_COLOR_CONFIG = window.FILE_COLOR_CONFIG || {};
        const COLOR_TWEAKS = window.COLOR_TWEAKS || {};
        const saturation = FILE_COLOR_CONFIG.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (FILE_COLOR_CONFIG.lightness ?? 50);
        const hue = getFileHue(fileIdx, totalFiles, fileName);
        if (typeof FILE_COLOR_CONFIG.chroma === 'number') {
            return window.oklchColor(lightness, FILE_COLOR_CONFIG.chroma, hue);
        }
        const adjustedHue = hue + (COLOR_TWEAKS.hueShift || 0);
        const adjustedLightness = window.clampValue(lightness + (COLOR_TWEAKS.lightnessShift || 0), 0, 100);
        return `hsl(${adjustedHue}, ${saturation}%, ${adjustedLightness}%)`;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getTopoColor: getTopoColor,
        normalizeInput: normalizeColorInput,
        toNumber: toColorNumber,
        dim: dimColor,
        getFileHue: getFileHue,
        getFileColor: getFileColor
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getTopoColor = COLOR_HELPERS.getTopoColor;
window.normalizeColorInput = COLOR_HELPERS.normalizeInput;
window.toColorNumber = COLOR_HELPERS.toNumber;
window.dimColor = COLOR_HELPERS.dim;
window.getFileHue = COLOR_HELPERS.getFileHue;
window.getFileColor = COLOR_HELPERS.getFileColor;

console.log('[Module] COLOR_HELPERS loaded - 6 functions');


// ═══ MODULE: modules/color-engine.js ═══
/**
 * COLOR ENGINE MODULE
 *
 * Centralized Color Intelligence System using OKLCH color space.
 * Single source of truth for ALL colors in the visualization.
 * Everything reads from here. OKLCH transforms apply here.
 *
 * Usage:
 *   COLOR.get('tier', 'T0')              // Get hex color for tier T0
 *   COLOR.getInterval('markov', 0.5)     // Get interpolated color
 *   COLOR.setTransform('hueShift', 30)   // Shift all hues by 30 degrees
 *   COLOR.subscribe(callback)            // React to transform changes
 */

const COLOR = (function () {
    'use strict';

    // =========================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =========================================================================

    const palette = {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        atom: {
            // Function-like (Green-Cyan)
            'function': { h: 160, c: 0.20, l: 0.65, label: 'Function', semantic: 'logic' },
            'method': { h: 175, c: 0.20, l: 0.62, label: 'Method', semantic: 'logic' },
            'closure': { h: 190, c: 0.20, l: 0.60, label: 'Closure', semantic: 'logic' },
            // Class-like (Blue-Purple)
            'class': { h: 260, c: 0.22, l: 0.60, label: 'Class', semantic: 'structure' },
            'interface': { h: 280, c: 0.20, l: 0.65, label: 'Interface', semantic: 'abstraction' },
            'struct': { h: 240, c: 0.20, l: 0.60, label: 'Struct', semantic: 'data' },
            // Module/Package (Orange-Yellow)
            'module': { h: 45, c: 0.22, l: 0.70, label: 'Module', semantic: 'container' },
            'package': { h: 30, c: 0.24, l: 0.65, label: 'Package', semantic: 'container' },
            // Variables/Fields (Pink-Red)
            'variable': { h: 340, c: 0.18, l: 0.65, label: 'Variable', semantic: 'state' },
            'field': { h: 350, c: 0.18, l: 0.62, label: 'Field', semantic: 'state' },
            // Unknown
            'unknown': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        roleCategory: {
            'Query': { h: 190, c: 0.20, l: 0.65, label: 'Query', semantic: 'read' },         // Cyan
            'Command': { h: 25, c: 0.24, l: 0.60, label: 'Command', semantic: 'write' },     // Orange/Red
            'Factory': { h: 280, c: 0.22, l: 0.60, label: 'Factory', semantic: 'create' },   // Purple
            'Storage': { h: 140, c: 0.20, l: 0.65, label: 'Storage', semantic: 'persist' },  // Green
            'Orchestration': { h: 240, c: 0.22, l: 0.60, label: 'Orchestration', semantic: 'manage' }, // Blue
            'Validation': { h: 45, c: 0.24, l: 0.70, label: 'Validation', semantic: 'check' }, // Yellow
            'Transform': { h: 320, c: 0.20, l: 0.60, label: 'Transform', semantic: 'change' }, // Pink
            'Event': { h: 260, c: 0.22, l: 0.65, label: 'Event', semantic: 'async' },        // Violet
            'Utility': { h: 200, c: 0.10, l: 0.70, label: 'Utility', semantic: 'helper' },   // Light Blue
            'Internal': { h: 0, c: 0.00, l: 0.60, label: 'Internal', semantic: 'private' },  // Gray
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        subsystem: {
            'Ingress': { h: 220, c: 0.24, l: 0.60, label: 'Ingress', semantic: 'entry' },
            'Egress': { h: 20, c: 0.24, l: 0.60, label: 'Egress', semantic: 'exit' },
            'Domain': { h: 260, c: 0.24, l: 0.55, label: 'Domain Core', semantic: 'core' },
            'Persistence': { h: 142, c: 0.22, l: 0.65, label: 'Persistence', semantic: 'store' },
            'Async': { h: 300, c: 0.22, l: 0.60, label: 'Async', semantic: 'bg' },
            'Presentation': { h: 190, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'ui' },
            'Security': { h: 0, c: 0.26, l: 0.55, label: 'Security', semantic: 'guard' },
            'Observability': { h: 60, c: 0.22, l: 0.75, label: 'Observability', semantic: 'monitor' },
            'Config': { h: 290, c: 0.18, l: 0.65, label: 'config', semantic: 'setup' },
            'Delivery': { h: 30, c: 0.20, l: 0.70, label: 'Delivery', semantic: 'ops' },
            'Unknown': { h: 0, c: 0.00, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        phase: {
            'DATA': { h: 142, c: 0.22, l: 0.65, label: 'Data', semantic: 'structure' },
            'LOGIC': { h: 240, c: 0.24, l: 0.60, label: 'Logic', semantic: 'flow' },
            'ORGANIZATION': { h: 280, c: 0.22, l: 0.60, label: 'Organization', semantic: 'arch' },
            'EXECUTION': { h: 20, c: 0.26, l: 0.60, label: 'Execution', semantic: 'run' }
        },
        state: {
            'Stateless': { h: 220, c: 0.20, l: 0.70, label: 'Stateless', semantic: 'pure' }, // Light Blue
            'Stateful': { h: 20, c: 0.24, l: 0.60, label: 'Stateful', semantic: 'impure' }   // Orange
        },
        effect: {
            'Pure': { h: 142, c: 0.22, l: 0.70, label: 'Pure', semantic: 'safe' },          // Green
            'SideEffect': { h: 340, c: 0.22, l: 0.60, label: 'Side Effect', semantic: 'risk' } // Pink/Red
        },
        visibility: {
            'Public': { h: 220, c: 0.20, l: 0.65, label: 'Public', semantic: 'open' },
            'Private': { h: 0, c: 0.05, l: 0.55, label: 'Private', semantic: 'closed' },
            'Internal': { h: 280, c: 0.15, l: 0.60, label: 'Internal', semantic: 'module' }
        },
        fileType: {
            'js': { h: 60, c: 0.24, l: 0.70, label: 'JavaScript', semantic: 'code' },    // Yellow
            'ts': { h: 240, c: 0.22, l: 0.60, label: 'TypeScript', semantic: 'code' },    // Blue
            'py': { h: 220, c: 0.20, l: 0.62, label: 'Python', semantic: 'code' },        // Blue
            'go': { h: 190, c: 0.22, l: 0.68, label: 'Go', semantic: 'code' },            // Cyan
            'rs': { h: 30, c: 0.24, l: 0.60, label: 'Rust', semantic: 'code' },           // Orange
            'java': { h: 40, c: 0.24, l: 0.62, label: 'Java', semantic: 'code' },         // Orange/Red
            'c': { h: 210, c: 0.18, l: 0.60, label: 'C', semantic: 'code' },             // Blue
            'cpp': { h: 210, c: 0.20, l: 0.55, label: 'C++', semantic: 'code' },          // Blue
            'h': { h: 280, c: 0.16, l: 0.60, label: 'Header', semantic: 'code' },         // Purple
            'html': { h: 20, c: 0.25, l: 0.60, label: 'HTML', semantic: 'markup' },       // Orange
            'css': { h: 230, c: 0.24, l: 0.60, label: 'CSS', semantic: 'style' },         // Blue
            'json': { h: 60, c: 0.18, l: 0.75, label: 'JSON', semantic: 'data' },         // Yellow
            'yaml': { h: 300, c: 0.18, l: 0.65, label: 'YAML', semantic: 'config' },      // Magenta
            'md': { h: 0, c: 0.04, l: 0.70, label: 'Markdown', semantic: 'doc' },         // Gray
            'unknown': { h: 0, c: 0.02, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    };

    // =========================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =========================================================================

    const transform = {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    };

    // =========================================================================
    // INTERVAL MAPPINGS: For numeric data -> color gradients
    // =========================================================================

    const intervals = {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        },
        complexity: {
            stops: [
                { value: 0.0, h: 142, c: 0.18, l: 0.70 },  // Low complexity (0) - Green
                { value: 0.3, h: 100, c: 0.18, l: 0.75 },  // Moderate (5-10) - Yellow-Green
                { value: 0.6, h: 50, c: 0.20, l: 0.70 },   // High (10-20) - Orange
                { value: 1.0, h: 15, c: 0.24, l: 0.60 }    // Very High (20+) - Red
            ]
        },
        churn: {
            stops: [
                { value: 0.0, h: 230, c: 0.10, l: 0.45 },  // Stale/Cold - Blue
                { value: 0.5, h: 300, c: 0.14, l: 0.60 },  // Active - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // Hot - Orange/Red
            ]
        },
        loc: {
            stops: [
                { value: 0.0, h: 200, c: 0.10, l: 0.75 },  // Small - Light Blue
                { value: 0.3, h: 240, c: 0.18, l: 0.60 },  // Medium - Blue
                { value: 0.7, h: 280, c: 0.20, l: 0.50 },  // Large - Purple
                { value: 1.0, h: 320, c: 0.22, l: 0.40 }   // Massive - Dark Purple
            ]
        },
        trust: {
            stops: [
                { value: 0.0, h: 0, c: 0.24, l: 0.50 },    // Untrusted - Red
                { value: 0.5, h: 60, c: 0.20, l: 0.70 },   // Warning - Yellow
                { value: 1.0, h: 142, c: 0.22, l: 0.65 }   // Trusted - Green
            ]
        },
        responsibility: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Single Purpose (1) - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.75 },   // Moderate (5) - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // God Object (9) - Red
            ]
        },
        purity: {
            stops: [
                { value: 0.0, h: 142, c: 0.20, l: 0.70 },  // Pure (1) - Green
                { value: 0.5, h: 220, c: 0.18, l: 0.65 },  // Mixed (5) - Blue
                { value: 1.0, h: 320, c: 0.24, l: 0.55 }   // I/O Heavy (9) - Purple/Red
            ]
        },
        boundary_score: {
            stops: [
                { value: 0.0, h: 240, c: 0.15, l: 0.65 },  // Internal (1) - Blue
                { value: 0.5, h: 280, c: 0.18, l: 0.60 },  // Module (5) - Purple
                { value: 1.0, h: 20, c: 0.24, l: 0.60 }    // External API (9) - Orange
            ]
        },
        lifecycle_score: {
            stops: [
                { value: 0.0, h: 180, c: 0.15, l: 0.70 },  // Ephemeral (1) - Cyan
                { value: 0.5, h: 220, c: 0.18, l: 0.60 },  // Managed (5) - Blue
                { value: 1.0, h: 280, c: 0.22, l: 0.50 }   // Singleton (9) - Purple
            ]
        },
        centrality: {
            stops: [
                { value: 0.0, h: 240, c: 0.05, l: 0.40 },  // Periphery - Gray/Blue
                { value: 0.5, h: 280, c: 0.20, l: 0.60 },  // Bridge - Purple
                { value: 1.0, h: 340, c: 0.25, l: 0.65 }   // Core - Pink/Red
            ]
        },
        fan_in: {
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.65 },  // Low - Blue
                { value: 0.5, h: 300, c: 0.18, l: 0.60 },  // Med - Purple
                { value: 1.0, h: 30, c: 0.24, l: 0.65 }    // High - Orange
            ]
        },
        fan_out: {
            stops: [
                { value: 0.0, h: 142, c: 0.15, l: 0.65 },  // Low - Green
                { value: 0.5, h: 60, c: 0.18, l: 0.70 },   // Med - Yellow
                { value: 1.0, h: 0, c: 0.24, l: 0.60 }     // High - Red
            ]
        }
    };

    // =========================================================================
    // SCHEME PATHS: 33 Named Color Gradients (OKLCH 3D Paths)
    // Each scheme is a path through OKLCH color space mapping normalized values to colors
    // =========================================================================

    const schemePaths = {
        // =====================================================================
        // PART A: FAMOUS SCIENTIFIC GRADIENTS (15 schemes)
        // Source: matplotlib/viridis family - perceptually uniform
        // =====================================================================

        // === SEQUENTIAL (monotonic lightness) ===
        viridis: {
            name: 'Viridis',
            semantic: 'The gold standard - blue→green→yellow',
            stops: [
                { value: 0.0, h: 280, c: 0.12, l: 0.25 },  // Dark purple
                { value: 0.25, h: 240, c: 0.16, l: 0.40 }, // Blue
                { value: 0.5, h: 170, c: 0.18, l: 0.55 },  // Teal
                { value: 0.75, h: 120, c: 0.20, l: 0.70 }, // Green
                { value: 1.0, h: 65, c: 0.22, l: 0.90 }    // Yellow
            ]
        },
        plasma: {
            name: 'Plasma',
            semantic: 'Purple→pink→orange→yellow arc',
            stops: [
                { value: 0.0, h: 280, c: 0.15, l: 0.20 },  // Deep purple
                { value: 0.25, h: 300, c: 0.22, l: 0.40 }, // Magenta
                { value: 0.5, h: 340, c: 0.25, l: 0.55 },  // Pink-red
                { value: 0.75, h: 30, c: 0.28, l: 0.72 },  // Orange
                { value: 1.0, h: 60, c: 0.24, l: 0.92 }    // Bright yellow
            ]
        },
        magma: {
            name: 'Magma',
            semantic: 'Black→purple→orange→white (lava)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.08 },  // Near black
                { value: 0.25, h: 300, c: 0.18, l: 0.30 }, // Deep purple
                { value: 0.5, h: 340, c: 0.24, l: 0.50 },  // Magenta
                { value: 0.75, h: 30, c: 0.26, l: 0.75 },  // Orange
                { value: 1.0, h: 60, c: 0.08, l: 0.98 }    // Near white
            ]
        },
        inferno: {
            name: 'Inferno',
            semantic: 'Black→purple→red→yellow (fire)',
            stops: [
                { value: 0.0, h: 280, c: 0.04, l: 0.05 },  // Black
                { value: 0.2, h: 300, c: 0.16, l: 0.25 },  // Purple
                { value: 0.4, h: 350, c: 0.24, l: 0.45 },  // Red-purple
                { value: 0.6, h: 20, c: 0.28, l: 0.60 },   // Red-orange
                { value: 0.8, h: 50, c: 0.26, l: 0.78 },   // Orange-yellow
                { value: 1.0, h: 65, c: 0.18, l: 0.95 }    // Bright yellow
            ]
        },
        cividis: {
            name: 'Cividis',
            semantic: 'Blue→yellow (colorblind optimized)',
            stops: [
                { value: 0.0, h: 240, c: 0.10, l: 0.25 },  // Dark blue
                { value: 0.33, h: 220, c: 0.08, l: 0.45 }, // Steel blue
                { value: 0.66, h: 80, c: 0.08, l: 0.65 },  // Olive
                { value: 1.0, h: 60, c: 0.14, l: 0.88 }    // Yellow
            ]
        },
        turbo: {
            name: 'Turbo',
            semantic: 'Improved rainbow (no banding)',
            stops: [
                { value: 0.0, h: 260, c: 0.18, l: 0.35 },  // Blue-purple
                { value: 0.2, h: 210, c: 0.22, l: 0.55 },  // Cyan-blue
                { value: 0.4, h: 150, c: 0.24, l: 0.65 },  // Green
                { value: 0.6, h: 60, c: 0.26, l: 0.75 },   // Yellow
                { value: 0.8, h: 30, c: 0.28, l: 0.65 },   // Orange
                { value: 1.0, h: 0, c: 0.24, l: 0.50 }     // Red
            ]
        },
        mako: {
            name: 'Mako',
            semantic: 'Deep ocean blue→teal',
            stops: [
                { value: 0.0, h: 260, c: 0.08, l: 0.12 },  // Abyss
                { value: 0.33, h: 240, c: 0.14, l: 0.35 }, // Deep blue
                { value: 0.66, h: 200, c: 0.18, l: 0.58 }, // Ocean blue
                { value: 1.0, h: 170, c: 0.16, l: 0.82 }   // Light teal
            ]
        },
        rocket: {
            name: 'Rocket',
            semantic: 'Dark→red→white (heat)',
            stops: [
                { value: 0.0, h: 280, c: 0.06, l: 0.10 },  // Dark
                { value: 0.33, h: 340, c: 0.20, l: 0.35 }, // Purple-red
                { value: 0.66, h: 15, c: 0.26, l: 0.60 },  // Red-orange
                { value: 1.0, h: 30, c: 0.08, l: 0.95 }    // Near white
            ]
        },

        // === DIVERGING (center-outward) ===
        coolwarm: {
            name: 'Coolwarm',
            semantic: 'Blue↔neutral↔red (diverging)',
            stops: [
                { value: 0.0, h: 230, c: 0.22, l: 0.45 },  // Cool blue
                { value: 0.25, h: 220, c: 0.12, l: 0.60 }, // Light blue
                { value: 0.5, h: 0, c: 0.02, l: 0.75 },    // Neutral gray
                { value: 0.75, h: 20, c: 0.14, l: 0.60 },  // Light red
                { value: 1.0, h: 15, c: 0.24, l: 0.45 }    // Warm red
            ]
        },
        spectral: {
            name: 'Spectral',
            semantic: 'Full rainbow diverging',
            stops: [
                { value: 0.0, h: 10, c: 0.22, l: 0.50 },   // Red
                { value: 0.25, h: 40, c: 0.24, l: 0.70 },  // Orange-yellow
                { value: 0.5, h: 60, c: 0.20, l: 0.85 },   // Yellow (center)
                { value: 0.75, h: 140, c: 0.20, l: 0.65 }, // Green
                { value: 1.0, h: 240, c: 0.18, l: 0.50 }   // Blue
            ]
        },

        // === APPLICATION-SPECIFIC ===
        thermal: {
            name: 'Thermal',
            semantic: 'Cold→hot temperature map',
            stops: [
                { value: 0.0, h: 240, c: 0.18, l: 0.30 },  // Cold blue
                { value: 0.25, h: 200, c: 0.20, l: 0.45 }, // Cool cyan
                { value: 0.5, h: 60, c: 0.22, l: 0.65 },   // Warm yellow
                { value: 0.75, h: 30, c: 0.26, l: 0.58 },  // Hot orange
                { value: 1.0, h: 0, c: 0.28, l: 0.50 }     // Burning red
            ]
        },
        nightvision: {
            name: 'Night Vision',
            semantic: 'Phosphor green display',
            stops: [
                { value: 0.0, h: 140, c: 0.02, l: 0.05 },  // Black
                { value: 0.33, h: 140, c: 0.12, l: 0.25 }, // Dark green
                { value: 0.66, h: 130, c: 0.22, l: 0.55 }, // Bright green
                { value: 1.0, h: 120, c: 0.28, l: 0.85 }   // Glowing green
            ]
        },
        ocean: {
            name: 'Ocean',
            semantic: 'Bathymetry depth map',
            stops: [
                { value: 0.0, h: 250, c: 0.12, l: 0.15 },  // Abyss
                { value: 0.33, h: 230, c: 0.18, l: 0.35 }, // Deep
                { value: 0.66, h: 200, c: 0.20, l: 0.55 }, // Mid-depth
                { value: 1.0, h: 180, c: 0.16, l: 0.80 }   // Shallow
            ]
        },
        terrain: {
            name: 'Terrain',
            semantic: 'Water→land→mountain',
            stops: [
                { value: 0.0, h: 220, c: 0.16, l: 0.40 },  // Water blue
                { value: 0.3, h: 140, c: 0.18, l: 0.55 },  // Lowland green
                { value: 0.5, h: 80, c: 0.16, l: 0.60 },   // Plains yellow-green
                { value: 0.7, h: 40, c: 0.14, l: 0.50 },   // Hills brown
                { value: 1.0, h: 0, c: 0.04, l: 0.90 }     // Snow white
            ]
        },
        electric: {
            name: 'Electric',
            semantic: 'Neon cyberpunk glow',
            stops: [
                { value: 0.0, h: 280, c: 0.25, l: 0.30 },  // Deep purple
                { value: 0.33, h: 320, c: 0.30, l: 0.50 }, // Hot pink
                { value: 0.66, h: 190, c: 0.28, l: 0.65 }, // Electric cyan
                { value: 1.0, h: 60, c: 0.26, l: 0.85 }    // Neon yellow
            ]
        },

        // =====================================================================
        // PART B: ROLE-SEMANTIC GRADIENTS (18 schemes)
        // Named after canonical roles with meaningful color journeys
        // =====================================================================

        // === GROUP 1: QUERIES & ACCESS (Cool blues/cyans - passive reads) ===
        query: {
            name: 'Query',
            semantic: 'Retrieve data calmly',
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },  // Deep blue - start
                { value: 0.5, h: 200, c: 0.15, l: 0.55 },  // Sky blue - middle
                { value: 1.0, h: 190, c: 0.20, l: 0.70 }   // Light cyan - found
            ]
        },
        finder: {
            name: 'Finder',
            semantic: 'Search and seek',
            stops: [
                { value: 0.0, h: 200, c: 0.05, l: 0.35 },  // Dim - searching
                { value: 0.3, h: 180, c: 0.12, l: 0.50 },  // Teal - hunting
                { value: 0.7, h: 160, c: 0.18, l: 0.65 },  // Cyan-green - close
                { value: 1.0, h: 140, c: 0.24, l: 0.75 }   // Bright green - found!
            ]
        },

        // === GROUP 2: COMMANDS & MUTATIONS (Warm - active writes) ===
        command: {
            name: 'Command',
            semantic: 'Execute with authority',
            stops: [
                { value: 0.0, h: 30, c: 0.15, l: 0.45 },   // Amber ready
                { value: 0.5, h: 20, c: 0.22, l: 0.58 },   // Orange active
                { value: 1.0, h: 10, c: 0.28, l: 0.65 }    // Red-orange fired
            ]
        },
        creator: {
            name: 'Creator',
            semantic: 'Bring into existence',
            stops: [
                { value: 0.0, h: 180, c: 0.10, l: 0.40 },  // Seed teal
                { value: 0.4, h: 150, c: 0.18, l: 0.55 },  // Sprout green
                { value: 0.8, h: 120, c: 0.24, l: 0.68 },  // Growth lime
                { value: 1.0, h: 90, c: 0.28, l: 0.75 }    // Full bloom yellow-green
            ]
        },
        destroyer: {
            name: 'Destroyer',
            semantic: 'Remove from existence',
            stops: [
                { value: 0.0, h: 0, c: 0.08, l: 0.60 },    // Pale warning
                { value: 0.4, h: 10, c: 0.18, l: 0.50 },   // Red alert
                { value: 0.7, h: 350, c: 0.26, l: 0.40 },  // Crimson
                { value: 1.0, h: 340, c: 0.20, l: 0.25 }   // Dark destruction
            ]
        },

        // === GROUP 3: FACTORIES (Construction - blue→green) ===
        factory: {
            name: 'Factory',
            semantic: 'Assembly line production',
            stops: [
                { value: 0.0, h: 220, c: 0.10, l: 0.45 },  // Blueprint blue
                { value: 0.3, h: 200, c: 0.16, l: 0.55 },  // Processing
                { value: 0.6, h: 170, c: 0.20, l: 0.62 },  // Assembly
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Product green
            ]
        },

        // === GROUP 4: STORAGE (Solid, grounded - deep blues/purples) ===
        repository: {
            name: 'Repository',
            semantic: 'Deep data vault',
            stops: [
                { value: 0.0, h: 240, c: 0.12, l: 0.30 },  // Database depths
                { value: 0.5, h: 230, c: 0.18, l: 0.45 },  // Data layer
                { value: 1.0, h: 220, c: 0.22, l: 0.60 }   // Accessible
            ]
        },
        cache: {
            name: 'Cache',
            semantic: 'Fast temporary',
            stops: [
                { value: 0.0, h: 300, c: 0.08, l: 0.50 },  // Magenta flash
                { value: 0.5, h: 320, c: 0.16, l: 0.62 },  // Pink speed
                { value: 1.0, h: 340, c: 0.22, l: 0.75 }   // Hot pink hit
            ]
        },

        // === GROUP 5: ORCHESTRATION (Purple/magenta - control flow) ===
        service: {
            name: 'Service',
            semantic: 'Coordinate operations',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Purple quiet
                { value: 0.5, h: 280, c: 0.16, l: 0.55 },  // Active violet
                { value: 1.0, h: 290, c: 0.22, l: 0.68 }   // Bright orchid
            ]
        },
        orchestrator: {
            name: 'Orchestrator',
            semantic: 'See all, conduct all',
            stops: [
                { value: 0.0, h: 200, c: 0.12, l: 0.40 },  // Start blue
                { value: 0.25, h: 270, c: 0.18, l: 0.50 }, // Through purple
                { value: 0.5, h: 330, c: 0.22, l: 0.58 },  // To pink
                { value: 0.75, h: 30, c: 0.24, l: 0.62 },  // Through orange
                { value: 1.0, h: 60, c: 0.26, l: 0.70 }    // End gold (full spectrum)
            ]
        },

        // === GROUP 6: VALIDATION (Yellow/green - pass/fail semantics) ===
        validator: {
            name: 'Validator',
            semantic: 'Check and verify',
            stops: [
                { value: 0.0, h: 0, c: 0.20, l: 0.50 },    // Red fail
                { value: 0.4, h: 45, c: 0.22, l: 0.65 },   // Yellow warning
                { value: 1.0, h: 140, c: 0.24, l: 0.70 }   // Green pass
            ]
        },
        guard: {
            name: 'Guard',
            semantic: 'Protect and defend',
            stops: [
                { value: 0.0, h: 350, c: 0.18, l: 0.40 },  // Dark red blocked
                { value: 0.5, h: 30, c: 0.20, l: 0.55 },   // Orange caution
                { value: 1.0, h: 120, c: 0.22, l: 0.65 }   // Green allowed
            ]
        },

        // === GROUP 7: TRANSFORMATION (Rainbow arc - any to any) ===
        transformer: {
            name: 'Transformer',
            semantic: 'Complete metamorphosis',
            stops: [
                { value: 0.0, h: 220, c: 0.14, l: 0.45 },  // Blue input
                { value: 0.3, h: 280, c: 0.18, l: 0.52 },  // Purple process
                { value: 0.6, h: 340, c: 0.22, l: 0.58 },  // Pink transition
                { value: 1.0, h: 30, c: 0.26, l: 0.65 }    // Orange output
            ]
        },
        parser: {
            name: 'Parser',
            semantic: 'Decode from wire',
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.85 },    // White wire
                { value: 0.5, h: 180, c: 0.10, l: 0.70 },  // Decoding
                { value: 1.0, h: 160, c: 0.20, l: 0.55 }   // Data teal
            ]
        },

        // === GROUP 8: EVENTS (Signals - purple/yellow pulses) ===
        handler: {
            name: 'Handler',
            semantic: 'React to event',
            stops: [
                { value: 0.0, h: 270, c: 0.08, l: 0.40 },  // Waiting purple
                { value: 0.5, h: 290, c: 0.18, l: 0.55 },  // Triggered
                { value: 1.0, h: 310, c: 0.26, l: 0.68 }   // Handling pink
            ]
        },
        emitter: {
            name: 'Emitter',
            semantic: 'Broadcast signal',
            stops: [
                { value: 0.0, h: 50, c: 0.18, l: 0.55 },   // Yellow charge
                { value: 0.5, h: 45, c: 0.24, l: 0.68 },   // Bright emit
                { value: 1.0, h: 40, c: 0.30, l: 0.78 }    // Golden broadcast
            ]
        },

        // === GROUP 9: UTILITIES (Neutral supporting - grays/pastels) ===
        utility: {
            name: 'Utility',
            semantic: 'General tool',
            stops: [
                { value: 0.0, h: 220, c: 0.04, l: 0.45 },  // Gray-blue tool
                { value: 0.5, h: 200, c: 0.08, l: 0.58 },  // Soft cyan
                { value: 1.0, h: 180, c: 0.12, l: 0.72 }   // Light teal
            ]
        },
        lifecycle: {
            name: 'Lifecycle',
            semantic: 'Birth to death cycle',
            stops: [
                { value: 0.0, h: 120, c: 0.20, l: 0.65 },  // Birth green
                { value: 0.25, h: 60, c: 0.22, l: 0.70 },  // Youth yellow
                { value: 0.5, h: 30, c: 0.24, l: 0.60 },   // Maturity orange
                { value: 0.75, h: 0, c: 0.20, l: 0.50 },   // Aging red
                { value: 1.0, h: 280, c: 0.10, l: 0.35 }   // Death purple
            ]
        },

        // =====================================================================
        // PART C: OKLCH GEOMETRY GENERATORS (Function-based paths)
        // These use mathematical functions instead of discrete stops.
        // Each has a `generator` function: (t) => { h, c, l }
        // =====================================================================

        // === LOOPS (Full 360° hue cycles) ===
        'rainbow-loop': {
            name: 'Rainbow Loop',
            semantic: 'Full hue circle at constant L/C',
            generator: (t) => ({
                h: t * 360,           // Full hue rotation
                c: 0.20,              // Constant chroma
                l: 0.65               // Constant lightness
            })
        },
        'rainbow-bright': {
            name: 'Rainbow Bright',
            semantic: 'Vivid rainbow with high chroma',
            generator: (t) => ({
                h: t * 360,
                c: 0.28,              // High chroma for vivid colors
                l: 0.70
            })
        },
        'rainbow-dark': {
            name: 'Rainbow Dark',
            semantic: 'Subdued rainbow for dark themes',
            generator: (t) => ({
                h: t * 360,
                c: 0.18,
                l: 0.45               // Lower lightness
            })
        },

        // === ARCS (Partial hue sweeps) ===
        'arc-warm': {
            name: 'Warm Arc',
            semantic: 'Red→Yellow→Orange (warm sector)',
            generator: (t) => ({
                h: 0 + t * 60,        // 0° to 60° (red to yellow)
                c: 0.24,
                l: 0.55 + t * 0.15    // Slight lightness increase
            })
        },
        'arc-cool': {
            name: 'Cool Arc',
            semantic: 'Cyan→Blue→Purple (cool sector)',
            generator: (t) => ({
                h: 180 + t * 100,     // 180° to 280° (cyan to purple)
                c: 0.22,
                l: 0.50 + t * 0.15
            })
        },
        'arc-nature': {
            name: 'Nature Arc',
            semantic: 'Green→Teal→Cyan (nature)',
            generator: (t) => ({
                h: 120 + t * 60,      // 120° to 180° (green to cyan)
                c: 0.20,
                l: 0.60 + t * 0.10
            })
        },

        // === SPIRALS (Hue + varying L or C) ===
        'spiral-up': {
            name: 'Spiral Up',
            semantic: 'Hue rotates as lightness increases',
            generator: (t) => ({
                h: t * 270,           // 3/4 hue rotation
                c: 0.18,
                l: 0.30 + t * 0.55    // Dark to light
            })
        },
        'spiral-down': {
            name: 'Spiral Down',
            semantic: 'Hue rotates as lightness decreases',
            generator: (t) => ({
                h: t * 270,
                c: 0.20,
                l: 0.85 - t * 0.55    // Light to dark
            })
        },
        'spiral-chroma': {
            name: 'Spiral Chroma',
            semantic: 'Hue rotates as saturation increases',
            generator: (t) => ({
                h: t * 360,
                c: 0.06 + t * 0.22,   // Gray to vivid
                l: 0.60
            })
        },

        // === SINUSOIDAL (Wave patterns) ===
        'wave-lightness': {
            name: 'Wave Lightness',
            semantic: 'Sinusoidal lightness oscillation',
            generator: (t) => ({
                h: t * 180,           // Half hue rotation
                c: 0.20,
                l: 0.50 + Math.sin(t * Math.PI * 2) * 0.20  // Wave between 0.30 and 0.70
            })
        },
        'wave-chroma': {
            name: 'Wave Chroma',
            semantic: 'Sinusoidal saturation oscillation',
            generator: (t) => ({
                h: t * 180,
                c: 0.15 + Math.sin(t * Math.PI * 2) * 0.12, // Wave between 0.03 and 0.27
                l: 0.60
            })
        },
        'pulse': {
            name: 'Pulse',
            semantic: 'Both L and C oscillate together',
            generator: (t) => {
                const wave = Math.sin(t * Math.PI * 3); // 1.5 full waves
                return {
                    h: t * 120,       // Partial hue sweep
                    c: 0.15 + wave * 0.10,
                    l: 0.55 + wave * 0.15
                };
            }
        },

        // === LINEAR RAMPS (Simple mathematical paths) ===
        'ramp-hue': {
            name: 'Hue Ramp',
            semantic: 'Pure hue change, constant L/C',
            generator: (t) => ({
                h: 220 + t * 140,     // Blue to pink (220° to 360°)
                c: 0.22,
                l: 0.60
            })
        },
        'ramp-lightness': {
            name: 'Lightness Ramp',
            semantic: 'Dark to light, constant H/C',
            generator: (t) => ({
                h: 220,               // Fixed blue
                c: 0.18,
                l: 0.25 + t * 0.60    // 0.25 to 0.85
            })
        },
        'ramp-chroma': {
            name: 'Chroma Ramp',
            semantic: 'Gray to vivid, constant H/L',
            generator: (t) => ({
                h: 280,               // Fixed purple
                c: 0.02 + t * 0.26,   // 0.02 to 0.28
                l: 0.60
            })
        },

        // === SPECIAL GEOMETRIC PATHS ===
        'helix': {
            name: 'Helix',
            semantic: 'Full 3D path through OKLCH cylinder',
            generator: (t) => ({
                h: t * 540,           // 1.5 hue rotations
                c: 0.10 + t * 0.15,   // Increasing chroma
                l: 0.30 + t * 0.50    // Rising lightness
            })
        },
        'convergent': {
            name: 'Convergent',
            semantic: 'Colors converge toward gray',
            generator: (t) => ({
                h: t * 180,           // Half rotation
                c: 0.26 * (1 - t),    // Chroma decreases to 0
                l: 0.55
            })
        },
        'divergent': {
            name: 'Divergent',
            semantic: 'Colors diverge from gray',
            generator: (t) => ({
                h: 180 + t * 180,     // Second half of hue wheel
                c: 0.26 * t,          // Chroma increases from 0
                l: 0.55
            })
        },
        'bicone': {
            name: 'Bicone',
            semantic: 'Center peak, edges dark (HSL-like)',
            generator: (t) => {
                // Lightness peaks at center, dark at edges
                const l = t < 0.5 ? 0.30 + t * 0.70 : 0.65 - (t - 0.5) * 0.70;
                return {
                    h: t * 360,
                    c: 0.20,
                    l: Math.max(0.30, l)
                };
            }
        }
    };

    // Current active scheme
    let _activeScheme = null;

// =========================================================================
// SUBSCRIBERS: Reactive notifications
// =========================================================================

let _subscribers = [];

function subscribe(callback) {
    _subscribers.push(callback);
    return () => {
        _subscribers = _subscribers.filter(cb => cb !== callback);
    };
}

function _notifySubscribers(event, data) {
    _subscribers.forEach(cb => cb(event, data));
}

// =========================================================================
// OKLCH -> HEX CONVERSION
// =========================================================================

function _toHex(oklch) {
    const { h, c, l } = oklch;

    // Convert OKLCH to approximate RGB
    const hRad = h * Math.PI / 180;
    const a = c * Math.cos(hRad);
    const b = c * Math.sin(hRad);

    // Simplified OKLab to linear RGB (approximate)
    const L = l;
    const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    const l3 = l_ * l_ * l_;
    const m3 = m_ * m_ * m_;
    const s3 = s_ * s_ * s_;

    let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
    let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
    let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

    // Clamp and convert to sRGB
    const toSRGB = (x) => {
        x = Math.max(0, Math.min(1, x));
        return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
    };

    r = Math.round(toSRGB(r) * 255);
    g = Math.round(toSRGB(g) * 255);
    bl = Math.round(toSRGB(bl) * 255);

    r = Math.max(0, Math.min(255, r));
    g = Math.max(0, Math.min(255, g));
    bl = Math.max(0, Math.min(255, bl));

    return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
}

function _applyTransform(oklch) {
    const t = transform;

    // Apply transforms
    let h = (oklch.h + t.hueShift + 360) % 360;
    let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
    let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

    // Apply amplifier to chroma for contrast
    if (t.amplifier !== 1) {
        c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
    }

    return _toHex({ h, c, l });
}

// =========================================================================
// CORE API
// =========================================================================

/**
 * Get color with transforms applied
 * @param {string} dimension - Palette dimension (tier, family, ring, layer, edgeType)
 * @param {string} category - Category within dimension
 * @returns {string} Hex color string
 */
function get(dimension, category) {
    const base = palette[dimension]?.[category];
    if (!base) return _toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray
    return _applyTransform(base);
}

/**
 * Get color for a numeric value using interval mapping
 * @param {string} intervalName - Interval name (markov, weight, confidence)
 * @param {number} value - Value (0-1)
 * @returns {string} Hex color string
 */
function getInterval(intervalName, value) {
    const v = Math.max(0, Math.min(1, value));

    // =========================================================================
    // SCHEME OVERRIDE: If an active scheme is selected, use it for ALL intervals
    // This makes the 33 named schemes (viridis, plasma, thermal, etc.) work
    // =========================================================================
    if (_activeScheme && schemePaths[_activeScheme]) {
        return getSchemeColor(_activeScheme, v);
    }

    // Fall back to hardcoded interval if no scheme active
    const interval = intervals[intervalName];
    if (!interval) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const stops = interval.stops;

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const t = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * t,
        c: lower.c + (upper.c - lower.c) * t,
        l: lower.l + (upper.l - lower.l) * t
    };

    return _applyTransform(interpolated);
}

/**
 * Interpolate between two hex colors in OKLCH space
 * @param {string} color1 - Hex color 1
 * @param {string} color2 - Hex color 2
 * @param {number} t - Interpolation factor (0-1)
 * @returns {string} Hex result
 */
function interpolate(color1, color2, t) {
    // We assume input hexes can be approximated back to OKLCH or treated as sRGB->OKLCH
    // For simplicity in this engine which mostly generates from OKLCH, we'll assume
    // specific OKLCH-derived palettes unless provided raw hex.
    // If we really need robust hex->oklch, we need a converter.
    // BUT, for edge gradients in app.js, we often have raw HSL or OKLCH objects.
    // Let's support passing Objects {h,c,l} or hex strings (naive interpolation for hex if needed).
    // Best approach: app.js should use COLOR.get() to get objects if possible, or we expose a helper
    // that takes our internal palette objects.

    // Actually, let's keep it simple: assume app.js will partial refactoring.
    // We will accept object {h,c,l} inputs for maximum precision.
    const c1 = (typeof color1 === 'string') ? parseOklchString(color1) || { h: 0, c: 0, l: 0.5 } : color1;
    const c2 = (typeof color2 === 'string') ? parseOklchString(color2) || { h: 0, c: 0, l: 0.5 } : color2;

    t = Math.max(0, Math.min(1, t));

    // Shortest path hue interpolation
    let h1 = c1.h || c1.H || 0;
    let h2 = c2.h || c2.H || 0;
    let dh = h2 - h1;
    if (Math.abs(dh) > 180) {
        if (dh > 0) h1 += 360;
        else h2 += 360;
    }

    const h = (h1 + (h2 - h1) * t) % 360;
    const c = (c1.c !== undefined ? c1.c : c1.C) + ((c2.c !== undefined ? c2.c : c2.C) - (c1.c !== undefined ? c1.c : c1.C)) * t;
    const l = (c1.l !== undefined ? c1.l : c1.L) + ((c2.l !== undefined ? c2.l : c2.L) - (c1.l !== undefined ? c1.l : c1.L)) * t;

    return _applyTransform({ h, c, l });
}

/**
 * Get raw OKLCH values (for advanced use)
 */
function getRaw(dimension, category) {
    return palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
}

/**
 * Get all categories for a dimension
 */
function getCategories(dimension) {
    return Object.keys(palette[dimension] || {});
}

/**
 * Get label for a category
 */
function getLabel(dimension, category) {
    return palette[dimension]?.[category]?.label || category;
}

// =========================================================================
// TRANSFORM CONTROLS
// =========================================================================

function setTransform(key, value) {
    if (key in transform) {
        transform[key] = value;
        _notifySubscribers('transform-change', { key, value });
    }
}

function setAllTransforms(transforms) {
    Object.assign(transform, transforms);
    _notifySubscribers('transform-change', transforms);
}

function resetTransforms() {
    transform.hueShift = 0;
    transform.chromaScale = 1.0;
    transform.lightnessShift = 0;
    transform.amplifier = 1.0;
    _notifySubscribers('transform-change', transform);
}

function getTransform() {
    return { ...transform };
}

// =========================================================================
// SCHEME API: Named Color Gradients
// =========================================================================

/**
 * List all available scheme names
 * @returns {string[]} Array of scheme names
 */
function listSchemes() {
    return Object.keys(schemePaths);
}

/**
 * Get scheme definition
 * @param {string} schemeName - Name of the scheme
 * @returns {object|null} Scheme definition with name, semantic, and stops
 */
function getScheme(schemeName) {
    return schemePaths[schemeName] || null;
}

/**
 * Get color at position t (0-1) along a scheme path
 * Supports both:
 *   - stops: Array of discrete points (interpolated)
 *   - generator: Function (t) => { h, c, l } (direct mathematical path)
 *
 * @param {string} schemeName - Name of the scheme
 * @param {number} t - Position along path (0-1)
 * @returns {string} Hex color string
 */
function getSchemeColor(schemeName, t) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    const v = Math.max(0, Math.min(1, t));

    // GENERATOR MODE: Mathematical function (OKLCH geometry)
    if (scheme.generator && typeof scheme.generator === 'function') {
        const oklch = scheme.generator(v);
        return _applyTransform(oklch);
    }

    // STOPS MODE: Discrete points with interpolation
    const stops = scheme.stops;
    if (!stops || stops.length === 0) return _toHex({ h: 0, c: 0.02, l: 0.40 });

    // Find surrounding stops
    let lower = stops[0];
    let upper = stops[stops.length - 1];

    for (let i = 0; i < stops.length - 1; i++) {
        if (v >= stops[i].value && v <= stops[i + 1].value) {
            lower = stops[i];
            upper = stops[i + 1];
            break;
        }
    }

    // Interpolate between stops
    const range = upper.value - lower.value;
    const interp = range > 0 ? (v - lower.value) / range : 0;

    const interpolated = {
        h: lower.h + (upper.h - lower.h) * interp,
        c: lower.c + (upper.c - lower.c) * interp,
        l: lower.l + (upper.l - lower.l) * interp
    };

    return _applyTransform(interpolated);
}

/**
 * Apply a scheme as the active color scheme
 * This sets transforms and notifies subscribers
 * @param {string} schemeName - Name of the scheme
 */
function applyScheme(schemeName) {
    // Allow null/undefined to clear the active scheme
    if (!schemeName) {
        _activeScheme = null;
        _notifySubscribers('scheme-change', { scheme: null, definition: null });
        console.log('[COLOR] Cleared active scheme, using default intervals');
        return;
    }

    const scheme = schemePaths[schemeName];
    if (!scheme) {
        console.warn('[COLOR] Unknown scheme:', schemeName);
        return;
    }

    _activeScheme = schemeName;
    _notifySubscribers('scheme-change', { scheme: schemeName, definition: scheme });
    console.log('[COLOR] Applied scheme:', schemeName, '-', scheme.semantic);
}

/**
 * Get the currently active scheme name
 * @returns {string|null} Active scheme name or null
 */
function getActiveScheme() {
    return _activeScheme;
}

/**
 * Generate a CSS gradient string for a scheme (for UI previews)
 * @param {string} schemeName - Name of the scheme
 * @param {string} direction - CSS gradient direction (default: 'to right')
 * @returns {string} CSS linear-gradient string
 */
function getSchemeGradientCSS(schemeName, direction = 'to right') {
    const scheme = schemePaths[schemeName];
    if (!scheme) return 'linear-gradient(to right, #333, #666)';

    const colorStops = scheme.stops.map(stop => {
        const color = _applyTransform(stop);
        const percent = Math.round(stop.value * 100);
        return `${color} ${percent}%`;
    });

    return `linear-gradient(${direction}, ${colorStops.join(', ')})`;
}

/**
 * Get scheme metadata (name, semantic description)
 * @param {string} schemeName - Name of the scheme
 * @returns {object} {name, semantic}
 */
function getSchemeInfo(schemeName) {
    const scheme = schemePaths[schemeName];
    if (!scheme) return { name: schemeName, semantic: 'Unknown' };
    return { name: scheme.name, semantic: scheme.semantic };
}

// =========================================================================
// DEBUG
// =========================================================================

function debug() {
    console.log('[COLOR] Transform state:', transform);
    console.log('[COLOR] Palette dimensions:', Object.keys(palette));
    console.log('[COLOR] Interval mappings:', Object.keys(intervals));
    console.log('[COLOR] Schemes:', Object.keys(schemePaths).length, 'available');
    console.log('[COLOR] Active scheme:', _activeScheme);
}

// =========================================================================
// PUBLIC API
// =========================================================================

return {
    // Core API
    get,
    getInterval,
    getRaw,
    getCategories,
    getLabel,
    interpolate,

    // Transform controls
    setTransform,
    setAllTransforms,
    resetTransforms,
    getTransform,

    // Scheme API (33 named color gradients)
    listSchemes,
    getScheme,
    getSchemeColor,
    applyScheme,
    getActiveScheme,
    getSchemeGradientCSS,
    getSchemeInfo,

    // Subscriptions
    subscribe,

    // Internal access (for migration)
    palette,
    intervals,
    transform,
    schemePaths,

    // Debug
    debug
};
}) ();

// Export to window for global access
window.COLOR = COLOR;

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'ColorOrchestrator', { get: () => COLOR, configurable: true });
Object.defineProperty(window, 'Color', { get: () => COLOR, configurable: true });

console.log('[Module] COLOR loaded - OKLCH color engine with', Object.keys(COLOR.schemePaths || {}).length, 'schemes');


// ═══ MODULE: modules/refresh-throttle.js ═══
/**
 * REFRESH THROTTLE MODULE
 *
 * Prevents excessive Graph.refresh() calls that can cause performance issues.
 * Implements frame-budget-aware throttling at 60fps max.
 *
 * Fixes ARCH-003: Unthrottled Graph.refresh() calls
 *
 * Usage:
 *   REFRESH.throttled()     // Request a throttled refresh
 *   REFRESH.force()         // Force immediate refresh (use sparingly)
 *   REFRESH.stats           // Get refresh statistics
 */

const REFRESH = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        minInterval: 16,      // 60fps max (1000ms / 60 = 16.67ms)
        maxPending: 3,        // Max queued refresh requests before forcing
        logThreshold: 100     // Log warning if more than N refreshes/second
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _pending = false;
    let _lastRefresh = 0;
    let _rafId = null;
    let _pendingCount = 0;

    // Statistics
    let _stats = {
        totalCalls: 0,
        throttledCalls: 0,
        actualRefreshes: 0,
        lastSecondRefreshes: 0,
        currentSecondRefreshes: 0,
        lastSecond: 0
    };

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Request a throttled graph refresh.
     * Multiple calls within the same frame are coalesced into one refresh.
     */
    function throttled() {
        _stats.totalCalls++;
        _pendingCount++;

        // Track calls per second for diagnostics
        const now = performance.now();
        const currentSecond = Math.floor(now / 1000);
        if (currentSecond !== _stats.lastSecond) {
            _stats.lastSecondRefreshes = _stats.currentSecondRefreshes;
            _stats.currentSecondRefreshes = 0;
            _stats.lastSecond = currentSecond;

            // Warn if too many refreshes
            if (_stats.lastSecondRefreshes > CONFIG.logThreshold) {
                console.warn(`[REFRESH] High refresh rate: ${_stats.lastSecondRefreshes}/s`);
            }
        }

        // If already pending, don't queue another
        if (_pending) {
            _stats.throttledCalls++;

            // Force refresh if too many pending
            if (_pendingCount >= CONFIG.maxPending) {
                _doRefresh();
            }
            return;
        }

        // Check if enough time has passed since last refresh
        const elapsed = now - _lastRefresh;
        if (elapsed >= CONFIG.minInterval) {
            // Enough time passed, refresh immediately
            _doRefresh();
        } else {
            // Schedule refresh for next frame
            _pending = true;
            _rafId = requestAnimationFrame(() => {
                _pending = false;
                _doRefresh();
            });
        }
    }

    /**
     * Force an immediate refresh, bypassing throttle.
     * Use sparingly - for critical updates only.
     */
    function force() {
        // Cancel any pending throttled refresh
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _doRefresh();
    }

    /**
     * Internal: Perform the actual refresh
     */
    function _doRefresh() {
        _lastRefresh = performance.now();
        _pendingCount = 0;
        _stats.actualRefreshes++;
        _stats.currentSecondRefreshes++;

        // Call the global Graph.refresh() if available
        if (typeof Graph !== 'undefined' && Graph && Graph.refresh) {
            Graph.refresh();
        }
    }

    /**
     * Cancel any pending refresh
     */
    function cancel() {
        if (_rafId) {
            cancelAnimationFrame(_rafId);
            _rafId = null;
        }
        _pending = false;
        _pendingCount = 0;
    }

    /**
     * Reset statistics
     */
    function resetStats() {
        _stats = {
            totalCalls: 0,
            throttledCalls: 0,
            actualRefreshes: 0,
            lastSecondRefreshes: 0,
            currentSecondRefreshes: 0,
            lastSecond: 0
        };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        throttled,
        force,
        cancel,
        resetStats,

        // Config (read-only access, can be modified via setConfig)
        get config() { return { ...CONFIG }; },
        setConfig(key, value) {
            if (key in CONFIG) {
                CONFIG[key] = value;
            }
        },

        // Statistics
        get stats() {
            return {
                ..._stats,
                throttleRatio: _stats.totalCalls > 0
                    ? (_stats.throttledCalls / _stats.totalCalls * 100).toFixed(1) + '%'
                    : '0%',
                pending: _pending,
                pendingCount: _pendingCount
            };
        },

        // Debug
        debug() {
            console.log('[REFRESH] Stats:', this.stats);
            console.log('[REFRESH] Config:', CONFIG);
        }
    };
})();


// ═══ MODULE: modules/legend-manager.js ═══
/**
 * LEGEND MANAGER MODULE
 *
 * Manages legend data, counts, and visibility for all visualization dimensions.
 * Delegates all color operations to the COLOR module.
 *
 * Depends on: COLOR, NODE
 *
 * Usage:
 *   LEGEND.init(nodes, links)           // Initialize with graph data
 *   LEGEND.getLegendData('tier')        // Get legend items for a dimension
 *   LEGEND.getColor('tier', 'T0')       // Get color (delegates to COLOR)
 *   LEGEND.subscribe(callback)          // React to legend changes
 */

const LEGEND = (function() {
    'use strict';

    // =========================================================================
    // DIMENSION METADATA
    // =========================================================================

    const dimensions = {
        tier: {
            name: 'TIERS',
            icon: '◐',
            extract: (node) => NODE.getTier(node)
        },
        family: {
            name: 'FAMILIES',
            icon: '⬡',
            extract: (node) => NODE.getFamily(node)
        },
        ring: {
            name: 'RINGS',
            icon: '◎',
            extract: (node) => NODE.getRing(node)
        },
        layer: {
            name: 'LAYERS',
            icon: '☰',
            extract: (node) => NODE.getLayer(node).toUpperCase()
        },
        effect: {
            name: 'EFFECTS',
            icon: '⚡',
            extract: (node) => NODE.getEffect(node)
        },
        edgeType: {
            name: 'EDGE TYPES',
            icon: '→',
            extract: (link) => (link.edge_type || link.type || 'unknown').toLowerCase()
        },
        edgeFamily: {
            name: 'EDGE FAMILIES',
            icon: '⇢',
            extract: (link) => (link.family || 'Dependency')
        }
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _counts = {};
    let _subscribers = [];

    // =========================================================================
    // CORE FUNCTIONS
    // =========================================================================

    /**
     * Initialize legend with nodes and links data
     */
    function init(nodes, links) {
        _computeCounts(nodes, links);
        return LEGEND;
    }

    /**
     * Compute counts for all dimensions
     */
    function _computeCounts(nodes, links) {
        _counts = {};

        // Node dimensions
        ['tier', 'family', 'ring', 'layer', 'effect'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (nodes || []).forEach(node => {
                const cat = extract(node);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        // Edge dimensions
        ['edgeType', 'edgeFamily'].forEach(dim => {
            const extract = dimensions[dim]?.extract;
            if (!extract) return;

            _counts[dim] = {};
            (links || []).forEach(link => {
                const cat = extract(link);
                _counts[dim][cat] = (_counts[dim][cat] || 0) + 1;
            });
        });

        console.log('[LEGEND] Counts computed:', Object.keys(_counts));
        _notifySubscribers('counts-updated', _counts);
    }

    /**
     * Get legend data for a dimension
     * Returns array of { id, label, color, count, dimension }
     */
    function getLegendData(dimension) {
        const counts = _counts[dimension] || {};

        return Object.keys(counts)
            .filter(cat => counts[cat] > 0)
            .sort((a, b) => (counts[b] || 0) - (counts[a] || 0))
            .map(cat => ({
                id: cat,
                label: COLOR.getLabel(dimension, cat),
                color: COLOR.get(dimension, cat),
                count: counts[cat] || 0,
                dimension: dimension
            }));
    }

    /**
     * Get color for a dimension/category (delegates to COLOR)
     */
    function getColor(dimension, category) {
        return COLOR.get(dimension, category);
    }

    /**
     * Get counts for a dimension
     */
    function getCounts(dimension) {
        return _counts[dimension] || {};
    }

    /**
     * Get all available dimensions
     */
    function getDimensions() {
        return Object.keys(dimensions);
    }

    /**
     * Get dimension metadata
     */
    function getDimensionMeta(dimension) {
        return dimensions[dimension] || null;
    }

    // =========================================================================
    // SUBSCRIPTIONS
    // =========================================================================

    function subscribe(callback) {
        _subscribers.push(callback);
        return () => {
            _subscribers = _subscribers.filter(cb => cb !== callback);
        };
    }

    function _notifySubscribers(event, data) {
        _subscribers.forEach(cb => cb(event, data));
    }

    // =========================================================================
    // DOM RENDERING
    // =========================================================================

    /**
     * Render a legend section to the DOM
     * @param {string} containerId - DOM container ID
     * @param {string} dimension - Dimension to render (tier, family, etc.)
     * @param {Set} stateSet - Filter state set (items to show)
     * @param {Function} onUpdate - Callback when filter changes
     */
    function renderSection(containerId, dimension, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        const legendData = getLegendData(dimension);
        if (!legendData || legendData.length === 0) return;

        // Build legend items
        legendData.forEach(item => {
            const el = document.createElement('div');
            el.className = 'topo-legend-item' + (stateSet && !stateSet.has(item.id) ? ' filtered' : '');
            el.dataset.category = item.id;
            el.dataset.dimension = dimension;

            // Color swatch
            const swatch = document.createElement('span');
            swatch.className = 'topo-legend-swatch';
            swatch.style.backgroundColor = item.color;

            // Label with count
            const label = document.createElement('span');
            label.className = 'topo-legend-label';
            label.textContent = item.id;

            const count = document.createElement('span');
            count.className = 'topo-legend-count';
            count.textContent = `(${item.count})`;

            el.appendChild(swatch);
            el.appendChild(label);
            el.appendChild(count);

            // Click to toggle filter
            if (stateSet) {
                el.addEventListener('click', () => {
                    if (stateSet.has(item.id)) {
                        stateSet.delete(item.id);
                        el.classList.add('filtered');
                    } else {
                        stateSet.add(item.id);
                        el.classList.remove('filtered');
                    }
                    if (onUpdate) onUpdate();
                });
            }

            container.appendChild(el);
        });

        console.log(`[Legend] Rendered ${dimension}: ${legendData.length} items`);
    }

    /**
     * Render all legend sections
     * @param {Object} filters - VIS_FILTERS object with filter Sets
     * @param {Function} onUpdate - Callback when any filter changes (typically refreshGraph)
     */
    function renderAll(filters, onUpdate) {
        // Render node legends
        renderSection('topo-tiers', 'tier', filters?.tiers, onUpdate);
        renderSection('topo-families', 'family', filters?.families, onUpdate);
        renderSection('topo-rings', 'ring', filters?.rings, onUpdate);
        renderSection('topo-layers', 'layer', filters?.layers, onUpdate);
        renderSection('topo-effects', 'effect', filters?.effects, onUpdate);

        // Render edge legends
        renderSection('topo-edges', 'edgeType', filters?.edges, onUpdate);
        renderSection('topo-edge-families', 'edgeFamily', filters?.edgeFamilies, onUpdate);

        console.log('[Legend] All sections rendered');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        getLegendData,
        getColor,
        getCounts,
        getDimensions,
        getDimensionMeta,
        subscribe,
        renderSection,
        renderAll,

        // Direct access to dimensions (for migration)
        dimensions,

        // Computed counts
        get counts() { return _counts; }
    };
})();

// Backward compatibility - LegendManager class wrapper
class LegendManager {
    constructor() {
        this.dimensions = LEGEND.dimensions;
        this.counts = {};
        this._subscribers = [];
    }

    init(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
        return this;
    }

    _computeCounts(nodes, links) {
        LEGEND.init(nodes, links);
        this.counts = LEGEND.counts;
    }

    getLegendData(dimension) {
        return LEGEND.getLegendData(dimension);
    }

    getColor(dimension, category) {
        return LEGEND.getColor(dimension, category);
    }

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    }

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    }
}

// Global Legend instance - defined by app.js (not duplicated here to avoid redeclaration)
// Legend is accessed as a global variable provided by app.js

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

// renderLegendSection calls LEGEND.renderSection with Legend (global) as source
window.renderLegendSection = function(containerId, dimension, stateSet, onUpdate) {
    LEGEND.renderSection(containerId, dimension, stateSet, onUpdate);
};

// renderAllLegends uses VIS_FILTERS and refreshGraph from app.js globals
window.renderAllLegends = function() {
    const VIS_FILTERS = window.VIS_FILTERS;
    const refreshGraph = window.refreshGraph;
    if (VIS_FILTERS && refreshGraph) {
        LEGEND.renderAll(VIS_FILTERS, refreshGraph);
    } else {
        console.warn('[Legend] VIS_FILTERS or refreshGraph not available');
    }
};

console.log('[Module] LEGEND loaded - 10 functions');


// ═══ MODULE: modules/data-manager.js ═══
/**
 * DATA MANAGER MODULE
 *
 * Single gate for ALL data access in the visualization.
 * Replaces direct access to FULL_GRAPH and Graph.graphData().
 * Provides O(1) indexed lookups and cached aggregations.
 *
 * Depends on: NODE, COLOR, LEGEND
 *
 * Usage:
 *   DATA.init(graphData)                // Initialize with payload data
 *   DATA.getNodes()                     // Get all raw nodes
 *   DATA.getNode(id)                    // O(1) node lookup
 *   DATA.getNodesByTier('T0')           // O(1) tier lookup
 *   DATA.getEdgesFrom(nodeId)           // O(1) edge lookup
 *   DATA.getTierCounts()                // Cached aggregation
 */

const DATA = (function() {
    'use strict';

    // =========================================================================
    // RAW DATA (immutable after init)
    // =========================================================================

    const raw = {
        nodes: [],
        links: [],
        fileBoundaries: [],
        markov: {},
        kpis: {},
        meta: {},
        physics: {},
        config: {}
    };

    // =========================================================================
    // ANALYTICS DATA (all Collider sections)
    // =========================================================================

    const analytics = {
        counts: {},
        stats: {},
        coverage: {},
        performance: {},
        classification: {},
        auto_discovery: {},
        ecosystem_discovery: {},
        dependencies: {},
        architecture: {},
        topology: {},
        execution_flow: {},
        data_flow: {},
        knots: {},
        warnings: [],
        recommendations: [],
        theory_completeness: {},
        distributions: {},
        edge_types: {},
        rpbl_profile: {},
        purpose_field: {},
        top_hubs: [],
        orphans_list: [],
        files: [],
        semantics: {},
        llm_enrichment: {},
        brain_download: {},
        ai_insights: null
    };

    // =========================================================================
    // INDEXES (O(1) lookups - built once)
    // =========================================================================

    const index = {
        nodeById: new Map(),           // id -> node
        nodesByTier: new Map(),        // tier -> [nodes]
        nodesByFamily: new Map(),      // family -> [nodes]
        nodesByRing: new Map(),        // ring -> [nodes]
        nodesByLayer: new Map(),       // layer -> [nodes]
        nodesByEffect: new Map(),      // effect -> [nodes]
        nodesByFile: new Map(),        // fileIdx -> [nodes]
        edgesBySource: new Map(),      // nodeId -> [edges from]
        edgesByTarget: new Map(),      // nodeId -> [edges to]
        edgeByKey: new Map(),          // "src|tgt" -> edge
        fileByIndex: new Map(),        // idx -> fileBoundary
        markovBySource: new Map()      // nodeId -> sorted edges by weight
    };

    // =========================================================================
    // CACHED AGGREGATIONS (computed once, invalidated on filter)
    // =========================================================================

    const cache = {
        tierCounts: null,
        familyCounts: null,
        ringCounts: null,
        layerCounts: null,
        effectCounts: null,
        edgeTypeCounts: null,
        edgeFamilyCounts: null,
        edgeRanges: null
    };

    // =========================================================================
    // CURRENT STATE (filtered view)
    // =========================================================================

    const filtered = {
        nodes: [],
        links: []
    };

    // Legend manager instance
    let _legend = null;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    function init(data) {
        // Store raw data
        raw.nodes = Array.isArray(data?.nodes) ? data.nodes : [];
        raw.links = Array.isArray(data?.links) ? data.links : [];
        raw.fileBoundaries = Array.isArray(data?.file_boundaries) ? data.file_boundaries : [];
        raw.markov = data?.markov || {};
        raw.kpis = data?.kpis || {};
        raw.meta = data?.meta || {};
        raw.physics = data?.physics || {};
        raw.config = data?.config || {};

        // Store analytics data
        Object.keys(analytics).forEach(key => {
            if (data?.[key] !== undefined) {
                analytics[key] = data[key];
            }
        });

        // Build all indexes
        _buildAllIndexes();

        // Initialize legend
        _legend = new LegendManager();
        _legend.init(raw.nodes, raw.links);

        // Set global Legend reference
        if (typeof Legend !== 'undefined') {
            Legend = _legend;
        }

        console.log('%c[DATA] Initialized', 'color: #4ade80; font-weight: bold',
            `${raw.nodes.length} nodes, ${raw.links.length} edges, ${raw.fileBoundaries.length} files`);

        return DATA;
    }

    // =========================================================================
    // INDEX BUILDING
    // =========================================================================

    function _buildAllIndexes() {
        _buildNodeIndex();
        _buildSemanticIndexes();
        _buildEdgeIndexes();
        _buildFileIndex();
        _buildMarkovIndex();
        _invalidateCache();
    }

    function _buildNodeIndex() {
        index.nodeById.clear();
        for (const node of raw.nodes) {
            if (node?.id) {
                index.nodeById.set(node.id, node);
            }
        }
    }

    function _buildSemanticIndexes() {
        index.nodesByTier.clear();
        index.nodesByFamily.clear();
        index.nodesByRing.clear();
        index.nodesByLayer.clear();
        index.nodesByEffect.clear();
        index.nodesByFile.clear();

        for (const node of raw.nodes) {
            if (!node) continue;

            // Tier index
            const tier = NODE.getTier(node);
            if (!index.nodesByTier.has(tier)) {
                index.nodesByTier.set(tier, []);
            }
            index.nodesByTier.get(tier).push(node);

            // Family index
            const family = NODE.getFamily(node);
            if (!index.nodesByFamily.has(family)) {
                index.nodesByFamily.set(family, []);
            }
            index.nodesByFamily.get(family).push(node);

            // Ring index
            const ring = NODE.getRing(node);
            if (!index.nodesByRing.has(ring)) {
                index.nodesByRing.set(ring, []);
            }
            index.nodesByRing.get(ring).push(node);

            // Layer index
            const layer = NODE.getLayer(node);
            if (!index.nodesByLayer.has(layer)) {
                index.nodesByLayer.set(layer, []);
            }
            index.nodesByLayer.get(layer).push(node);

            // Effect index
            const effect = NODE.getEffect(node);
            if (!index.nodesByEffect.has(effect)) {
                index.nodesByEffect.set(effect, []);
            }
            index.nodesByEffect.get(effect).push(node);

            // File index
            const fileIdx = node.fileIdx ?? -1;
            if (fileIdx >= 0) {
                if (!index.nodesByFile.has(fileIdx)) {
                    index.nodesByFile.set(fileIdx, []);
                }
                index.nodesByFile.get(fileIdx).push(node);
            }
        }
    }

    function _buildEdgeIndexes() {
        index.edgesBySource.clear();
        index.edgesByTarget.clear();
        index.edgeByKey.clear();

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');

            if (srcId) {
                if (!index.edgesBySource.has(srcId)) {
                    index.edgesBySource.set(srcId, []);
                }
                index.edgesBySource.get(srcId).push(link);
            }

            if (tgtId) {
                if (!index.edgesByTarget.has(tgtId)) {
                    index.edgesByTarget.set(tgtId, []);
                }
                index.edgesByTarget.get(tgtId).push(link);
            }

            if (srcId && tgtId) {
                index.edgeByKey.set(`${srcId}|${tgtId}`, link);
            }
        }
    }

    function _buildFileIndex() {
        index.fileByIndex.clear();
        for (let i = 0; i < raw.fileBoundaries.length; i++) {
            index.fileByIndex.set(i, raw.fileBoundaries[i]);
        }
    }

    function _buildMarkovIndex() {
        index.markovBySource.clear();
        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const mw = link.markov_weight || 0;
            if (srcId && mw > 0) {
                if (!index.markovBySource.has(srcId)) {
                    index.markovBySource.set(srcId, []);
                }
                index.markovBySource.get(srcId).push(link);
            }
        }
        // Sort each list by markov weight descending
        for (const [, edges] of index.markovBySource) {
            edges.sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0));
        }
    }

    function _invalidateCache() {
        Object.keys(cache).forEach(key => {
            cache[key] = null;
        });
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }

    // =========================================================================
    // RAW DATA ACCESSORS
    // =========================================================================

    function getNodes() { return raw.nodes; }
    function getLinks() { return raw.links; }
    function getFileBoundaries() { return raw.fileBoundaries; }
    function getMarkov() { return raw.markov; }
    function getKpis() { return raw.kpis; }
    function getMeta() { return raw.meta; }
    function getPhysics() { return raw.physics; }
    function getConfig() { return raw.config; }
    function getAnalytics(key) { return analytics[key]; }

    // =========================================================================
    // INDEXED LOOKUPS (O(1))
    // =========================================================================

    function getNode(id) {
        return index.nodeById.get(id) || null;
    }

    function getNodesByTier(tier) {
        return index.nodesByTier.get(tier) || [];
    }

    function getNodesByFamily(family) {
        return index.nodesByFamily.get(family) || [];
    }

    function getNodesByRing(ring) {
        return index.nodesByRing.get(ring) || [];
    }

    function getNodesByLayer(layer) {
        return index.nodesByLayer.get(layer) || [];
    }

    function getNodesByEffect(effect) {
        return index.nodesByEffect.get(effect) || [];
    }

    function getNodesByFile(fileIdx) {
        return index.nodesByFile.get(fileIdx) || [];
    }

    function getEdgesFrom(nodeId) {
        return index.edgesBySource.get(nodeId) || [];
    }

    function getEdgesTo(nodeId) {
        return index.edgesByTarget.get(nodeId) || [];
    }

    function getEdgeBetween(srcId, tgtId) {
        return index.edgeByKey.get(`${srcId}|${tgtId}`) || null;
    }

    function getFile(idx) {
        return index.fileByIndex.get(idx) || null;
    }

    function getTopMarkovEdges(nodeId, k = 5) {
        const edges = index.markovBySource.get(nodeId) || [];
        return edges.slice(0, k);
    }

    function isHighEntropyNode(nodeId) {
        const highEntropy = raw.markov?.high_entropy_nodes || [];
        return highEntropy.some(h => h.node === nodeId);
    }

    // =========================================================================
    // FILTERED DATA
    // =========================================================================

    function setFiltered(nodes, links) {
        filtered.nodes = nodes || [];
        filtered.links = links || [];
    }

    function getVisibleNodes() {
        if (filtered.nodes.length > 0) {
            return filtered.nodes;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().nodes || [])
            : [];
    }

    function getVisibleLinks() {
        if (filtered.links.length > 0) {
            return filtered.links;
        }
        return (typeof Graph !== 'undefined' && Graph?.graphData)
            ? (Graph.graphData().links || [])
            : [];
    }

    // =========================================================================
    // AGGREGATIONS (cached)
    // =========================================================================

    function getTierCounts() {
        if (!cache.tierCounts) {
            cache.tierCounts = new Map();
            for (const [tier, nodes] of index.nodesByTier) {
                cache.tierCounts.set(tier, nodes.length);
            }
        }
        return cache.tierCounts;
    }

    function getFamilyCounts() {
        if (!cache.familyCounts) {
            cache.familyCounts = new Map();
            for (const [family, nodes] of index.nodesByFamily) {
                cache.familyCounts.set(family, nodes.length);
            }
        }
        return cache.familyCounts;
    }

    function getRingCounts() {
        if (!cache.ringCounts) {
            cache.ringCounts = new Map();
            for (const [ring, nodes] of index.nodesByRing) {
                cache.ringCounts.set(ring, nodes.length);
            }
        }
        return cache.ringCounts;
    }

    function getLayerCounts() {
        if (!cache.layerCounts) {
            cache.layerCounts = new Map();
            for (const [layer, nodes] of index.nodesByLayer) {
                cache.layerCounts.set(layer, nodes.length);
            }
        }
        return cache.layerCounts;
    }

    function getEffectCounts() {
        if (!cache.effectCounts) {
            cache.effectCounts = new Map();
            for (const [effect, nodes] of index.nodesByEffect) {
                cache.effectCounts.set(effect, nodes.length);
            }
        }
        return cache.effectCounts;
    }

    function getEdgeTypeCounts() {
        if (!cache.edgeTypeCounts) {
            cache.edgeTypeCounts = new Map();
            for (const link of raw.links) {
                const type = link.edge_type || link.type || 'unknown';
                cache.edgeTypeCounts.set(type, (cache.edgeTypeCounts.get(type) || 0) + 1);
            }
        }
        return cache.edgeTypeCounts;
    }

    function getEdgeFamilyCounts() {
        if (!cache.edgeFamilyCounts) {
            cache.edgeFamilyCounts = new Map();
            for (const link of raw.links) {
                const family = link.family || 'Dependency';
                cache.edgeFamilyCounts.set(family, (cache.edgeFamilyCounts.get(family) || 0) + 1);
            }
        }
        return cache.edgeFamilyCounts;
    }

    function getEdgeRanges() {
        if (!cache.edgeRanges) {
            let minW = Infinity, maxW = -Infinity;
            let minC = Infinity, maxC = -Infinity;
            for (const link of raw.links) {
                const w = link.weight ?? 1;
                const c = link.confidence ?? 1;
                if (w < minW) minW = w;
                if (w > maxW) maxW = w;
                if (c < minC) minC = c;
                if (c > maxC) maxC = c;
            }
            cache.edgeRanges = {
                weight: { min: minW === Infinity ? 0 : minW, max: maxW === -Infinity ? 1 : maxW },
                confidence: { min: minC === Infinity ? 0 : minC, max: maxC === -Infinity ? 1 : maxC }
            };
        }
        return cache.edgeRanges;
    }

    // =========================================================================
    // SELF-TEST
    // =========================================================================

    function selfTest() {
        const errors = [];
        const warnings = [];
        const seenIds = new Set();

        for (const node of raw.nodes) {
            if (!node?.id) {
                errors.push('Node missing id');
                continue;
            }
            if (seenIds.has(node.id)) {
                errors.push(`Duplicate node id: ${node.id}`);
                continue;
            }
            seenIds.add(node.id);
        }

        for (const link of raw.links) {
            const srcId = _endpointId(link, 'source');
            const tgtId = _endpointId(link, 'target');
            if (srcId && !index.nodeById.has(srcId)) {
                warnings.push(`Edge source not in graph: ${srcId}`);
            }
            if (tgtId && !index.nodeById.has(tgtId)) {
                warnings.push(`Edge target not in graph: ${tgtId}`);
            }
        }

        const status = errors.length === 0 ? 'PASS' : 'FAIL';
        const style = errors.length === 0
            ? 'color: #4ade80; font-weight: bold'
            : 'color: #f87171; font-weight: bold';

        console.log(`%c[DATA] Self-Test: ${status}`, style);
        console.log(`  Raw: ${raw.nodes.length} nodes, ${raw.links.length} edges`);
        console.log(`  Indexes: nodeById=${index.nodeById.size}, tiers=${index.nodesByTier.size}`);

        if (errors.length > 0) console.error('[DATA] Errors:', errors);
        if (warnings.length > 0) {
            console.warn('[DATA] Warnings:', warnings.slice(0, 5));
            if (warnings.length > 5) console.warn(`  ... and ${warnings.length - 5} more`);
        }

        return { errors, warnings, pass: errors.length === 0 };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Init
        init,

        // Raw data
        getNodes,
        getLinks,
        getFileBoundaries,
        getMarkov,
        getKpis,
        getMeta,
        getPhysics,
        getConfig,
        getAnalytics,

        // Indexed lookups
        getNode,
        getNodesByTier,
        getNodesByFamily,
        getNodesByRing,
        getNodesByLayer,
        getNodesByEffect,
        getNodesByFile,
        getEdgesFrom,
        getEdgesTo,
        getEdgeBetween,
        getFile,
        getTopMarkovEdges,
        isHighEntropyNode,

        // Filtered data
        setFiltered,
        getVisibleNodes,
        getVisibleLinks,

        // Aggregations
        getTierCounts,
        getFamilyCounts,
        getRingCounts,
        getLayerCounts,
        getEffectCounts,
        getEdgeTypeCounts,
        getEdgeFamilyCounts,
        getEdgeRanges,

        // Self-test
        selfTest,

        // Direct access (for migration)
        raw,
        index,
        cache,
        filtered,

        // Legend reference
        get legend() { return _legend; },

        // Color access (convenience)
        get color() { return COLOR; }
    };
})();

// Backward compatibility - DataManager class wrapper
class DataManager {
    constructor() {
        this.raw = DATA.raw;
        this.analytics = {};
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = null;
        this.color = COLOR;
    }

    init(data) {
        DATA.init(data);
        this.raw = DATA.raw;
        this.index = DATA.index;
        this.cache = DATA.cache;
        this.filtered = DATA.filtered;
        this.legend = DATA.legend;
        return this;
    }

    // Delegate all methods to DATA module
    getNodes() { return DATA.getNodes(); }
    getLinks() { return DATA.getLinks(); }
    getFileBoundaries() { return DATA.getFileBoundaries(); }
    getMarkov() { return DATA.getMarkov(); }
    getKpis() { return DATA.getKpis(); }
    getMeta() { return DATA.getMeta(); }
    getNode(id) { return DATA.getNode(id); }
    getNodesByTier(tier) { return DATA.getNodesByTier(tier); }
    getNodesByFamily(family) { return DATA.getNodesByFamily(family); }
    getNodesByRing(ring) { return DATA.getNodesByRing(ring); }
    getNodesByFile(fileIdx) { return DATA.getNodesByFile(fileIdx); }
    getEdgesFrom(nodeId) { return DATA.getEdgesFrom(nodeId); }
    getEdgesTo(nodeId) { return DATA.getEdgesTo(nodeId); }
    getEdgeBetween(srcId, tgtId) { return DATA.getEdgeBetween(srcId, tgtId); }
    getFile(idx) { return DATA.getFile(idx); }
    getTopMarkovEdges(nodeId, k) { return DATA.getTopMarkovEdges(nodeId, k); }
    isHighEntropyNode(nodeId) { return DATA.isHighEntropyNode(nodeId); }
    setFiltered(nodes, links) { DATA.setFiltered(nodes, links); }
    getVisibleNodes() { return DATA.getVisibleNodes(); }
    getVisibleLinks() { return DATA.getVisibleLinks(); }
    getTierCounts() { return DATA.getTierCounts(); }
    getFamilyCounts() { return DATA.getFamilyCounts(); }
    getRingCounts() { return DATA.getRingCounts(); }
    getLayerCounts() { return DATA.getLayerCounts(); }
    getEffectCounts() { return DATA.getEffectCounts(); }
    getEdgeTypeCounts() { return DATA.getEdgeTypeCounts(); }
    getEdgeFamilyCounts() { return DATA.getEdgeFamilyCounts(); }
    getEdgeRanges() { return DATA.getEdgeRanges(); }
    selfTest() { return DATA.selfTest(); }

    // Internal methods
    _buildAllIndexes() {}
    _buildNodeIndex() {}
    _buildSemanticIndexes() {}
    _buildEdgeIndexes() {}
    _buildFileIndex() {}
    _buildMarkovIndex() {}
    _invalidateCache() {}
    _endpointId(link, side) {
        if (!link) return '';
        let value = link[side];
        if (value && typeof value === 'object') value = value.id;
        return (value === undefined || value === null) ? '' : String(value).trim();
    }
    _getNodeTier(node) { return NODE.getTier(node); }
    _getNodeFamily(node) { return NODE.getFamily(node); }
    _getNodeRing(node) { return NODE.getRing(node); }
    _getNodeLayer(node) { return NODE.getLayer(node); }
    _getNodeEffect(node) { return NODE.getEffect(node); }
}

// Global DM instance - defined by app.js (not duplicated here to avoid redeclaration)
// DM is accessed as a global variable provided by app.js

// Parity check function
function runDmParity(dm, data) {
    if (!dm) return;
    const checks = [];
    const rawNodes = Array.isArray(data?.nodes) ? data.nodes.length : 0;
    const rawEdges = Array.isArray(data?.links) ? data.links.length : 0;
    const dmNodes = dm.raw.nodes.length;
    const dmEdges = dm.raw.links.length;

    checks.push({ name: 'Node count', dm: dmNodes, old: rawNodes, pass: dmNodes === rawNodes });
    checks.push({ name: 'Edge count', dm: dmEdges, old: rawEdges, pass: dmEdges === rawEdges });
    checks.push({ name: 'Node index size', dm: dm.index.nodeById.size, old: rawNodes, pass: dm.index.nodeById.size === rawNodes });

    const allPass = checks.every(c => c.pass);
    const style = allPass ? 'color: #4ade80; font-weight: bold' : 'color: #f87171; font-weight: bold';
    console.log(`%c[DM Parity] ${allPass ? 'ALL PASS' : 'MISMATCH'}`, style);
    checks.forEach(c => {
        const icon = c.pass ? '✓' : '✗';
        console.log(`  ${icon} ${c.name}: DM=${c.dm}, Raw=${c.old}`);
    });
}


// ═══ MODULE: modules/vis-state.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VIS-STATE MODULE - Unified visualization state management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Single source of truth for visualization state. All controls funnel through
 * applyState() to ensure consistency.
 *
 * KEY DESIGN DECISIONS:
 * 1. Palette selection NEVER auto-switches colorBy mode
 * 2. Palette is "armed" - it applies when colorBy changes to interval mode
 * 3. Presets are macros that call applyState() with multiple properties
 * 4. syncUIFromState() updates all UI elements to match state
 *
 * @module VIS_STATE
 * @version 1.0.0
 */

window.VIS_STATE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CATEGORICAL vs INTERVAL MODE CLASSIFICATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Categorical modes use discrete color palettes (tier, family, atom...)
     * Interval modes use continuous gradients (complexity, fan_in, loc...)
     */
    const CATEGORICAL_MODES = new Set([
        'tier', 'family', 'atom', 'ring', 'layer', 'role', 'roleCategory',
        'subsystem', 'phase', 'fileType', 'file', 'state', 'visibility'
    ]);

    const INTERVAL_MODES = new Set([
        'complexity', 'loc', 'fan_in', 'fan_out', 'trust',
        'responsibility', 'purity', 'lifecycle_score', 'boundary_score',
        'centrality', 'rank', 'churn', 'age', 'depth'
    ]);

    function isIntervalMode(mode) {
        return INTERVAL_MODES.has(mode);
    }

    function isCategoricalMode(mode) {
        return CATEGORICAL_MODES.has(mode);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATE OBJECT - Single source of truth
    // ═══════════════════════════════════════════════════════════════════════

    const state = {
        colorBy: 'fan_in',         // Default to interval mode to show OKLCH schemes
        sizeBy: 'fanout',          // 'uniform', 'degree', 'fanout', 'complexity'
        edgeBy: 'type',            // 'type', 'resolution', 'weight', 'gradient-tier', etc.
        palette: 'helix',          // OKLCH helix path - visually striking default
        paletteType: 'interval'    // Derived: 'categorical' or 'interval'
    };

    // ═══════════════════════════════════════════════════════════════════════
    // VIEW PRESETS - Macros that set multiple properties at once
    // ═══════════════════════════════════════════════════════════════════════

    const VIEW_PRESETS = {
        tier: {
            label: 'Tier',
            description: 'T0/T1/T2 architectural height',
            colorBy: 'tier',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        family: {
            label: 'Family',
            description: 'LOG, DAT, ORG, EXE, EXT',
            colorBy: 'family',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        layer: {
            label: 'Layer',
            description: 'Physical/Virtual/Semantic',
            colorBy: 'layer',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        ring: {
            label: 'Ring',
            description: 'Domain architecture rings',
            colorBy: 'ring',
            sizeBy: 'fanout',
            edgeBy: 'type'
        },
        file: {
            label: 'File',
            description: 'Each file gets unique hue',
            colorBy: 'file',
            sizeBy: 'uniform',
            edgeBy: 'resolution'
        },
        flow: {
            label: 'Flow',
            description: 'Markov transition probability',
            colorBy: 'fan_in',  // Use interval mode for flow
            sizeBy: 'degree',
            edgeBy: 'weight',
            special: 'flow'    // Triggers flow visualization
        }
    };

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY STATE - Central function all controls use
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply state changes. This is THE function all UI controls call.
     *
     * @param {Object} nextState - Partial state to merge
     * @param {string} reason - Debug label for console (e.g., 'preset:tier', 'control:colorBy')
     */
    function applyState(nextState, reason = 'unknown') {
        const prevColorBy = state.colorBy;
        const prevPalette = state.palette;

        // Merge new state
        if (nextState.colorBy !== undefined) state.colorBy = nextState.colorBy;
        if (nextState.sizeBy !== undefined) state.sizeBy = nextState.sizeBy;
        if (nextState.edgeBy !== undefined) state.edgeBy = nextState.edgeBy;
        if (nextState.palette !== undefined) state.palette = nextState.palette;

        // Derive paletteType from colorBy
        state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';

        console.log(`[VIS_STATE] applyState(${reason}):`, {
            colorBy: state.colorBy,
            sizeBy: state.sizeBy,
            edgeBy: state.edgeBy,
            palette: state.palette,
            paletteType: state.paletteType
        });

        // ─── Apply color mode ───
        if (nextState.colorBy !== undefined && nextState.colorBy !== prevColorBy) {
            _applyColorMode(state.colorBy);
        }

        // ─── Apply size mode ───
        if (nextState.sizeBy !== undefined) {
            _applySizeMode(state.sizeBy);
        }

        // ─── Apply edge mode ───
        if (nextState.edgeBy !== undefined) {
            _applyEdgeMode(state.edgeBy);
        }

        // ─── Apply palette (only if in interval mode) ───
        if (nextState.palette !== undefined || nextState.colorBy !== undefined) {
            _applyPalette();
        }

        // ─── Handle special modes (flow) ───
        if (nextState.special === 'flow') {
            _enableFlowMode();
        } else if (prevColorBy === 'flow' && nextState.colorBy !== 'flow') {
            _disableFlowMode();
        }

        // ─── Sync UI to match state ───
        syncUIFromState();

        // ─── Refresh visualization ───
        _refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INTERNAL APPLY FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════

    function _applyColorMode(mode) {
        // Update globals for backward compatibility
        window.NODE_COLOR_MODE = mode;

        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.colorMode = mode;
            window.APPEARANCE_STATE.currentPreset = mode;
        }

        // Disable flow mode if switching away from flow
        if (mode !== 'flow' && typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _applySizeMode(mode) {
        if (typeof window.APPEARANCE_STATE !== 'undefined') {
            window.APPEARANCE_STATE.sizeMode = mode;
        }

        if (typeof window.applyNodeSizeMode === 'function') {
            window.applyNodeSizeMode(mode);
        } else if (typeof window.NODE_HELPERS !== 'undefined') {
            window.NODE_HELPERS.applySizeMode(mode);
        }
    }

    function _applyEdgeMode(mode) {
        if (typeof window.EDGE_GRADIENT_MODE !== 'undefined') {
            // Edge gradient modes
            if (mode.startsWith('gradient-')) {
                window.EDGE_GRADIENT_MODE = mode.replace('gradient-', '');
            }
        }

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
    }

    function _applyPalette() {
        // Only apply scheme coloring if in interval mode
        if (state.paletteType === 'interval' && state.palette) {
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(state.palette);
            }
        } else {
            // In categorical mode, clear active scheme
            if (typeof window.COLOR !== 'undefined' && window.COLOR.applyScheme) {
                window.COLOR.applyScheme(null);
            }
        }
    }

    function _enableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && !window.flowMode) {
            if (typeof window.toggleFlowMode === 'function') {
                window.toggleFlowMode();
            }
        }
    }

    function _disableFlowMode() {
        if (typeof window.flowMode !== 'undefined' && window.flowMode) {
            if (typeof window.disableFlowMode === 'function') {
                window.disableFlowMode();
            }
        }
    }

    function _refreshGraph() {
        // Recompute node colors
        const DM = window.DM;
        const Graph = window.Graph;
        const nodes = DM ? DM.getNodes() : (Graph?.graphData ? Graph.graphData().nodes : []);

        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render with new function reference to force update
        if (Graph) {
            Graph.nodeColor(n => n.color);
        }

        // Refresh edge gradients
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        // Re-render legends
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SYNC UI FROM STATE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all UI elements to reflect current state.
     * Called after every applyState() and on initialization.
     */
    function syncUIFromState() {
        // ─── View Preset buttons ───
        document.querySelectorAll('.preset-btn[data-preset]').forEach(btn => {
            const presetKey = btn.dataset.preset;
            const preset = VIEW_PRESETS[presetKey];
            const isActive = preset && preset.colorBy === state.colorBy;
            btn.classList.toggle('active', isActive);
        });

        // ─── Color Mode buttons (PRESET_CONFIG grid) ───
        document.querySelectorAll('.color-btn[data-preset]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.preset === state.colorBy);
        });

        // ─── Size Mode buttons ───
        document.querySelectorAll('[data-size-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.sizeMode === state.sizeBy);
        });

        // ─── Edge Mode buttons ───
        document.querySelectorAll('[data-edge-mode]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.edgeMode === state.edgeBy);
        });

        // ─── Palette buttons ───
        document.querySelectorAll('.scheme-btn[data-scheme]').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.scheme === state.palette);
        });

        // ─── Palette panel enabled/disabled state ───
        const schemesPanel = document.getElementById('section-schemes');
        if (schemesPanel) {
            const isDisabled = state.paletteType === 'categorical';
            schemesPanel.classList.toggle('disabled', isDisabled);

            // Update scheme buttons opacity/interactivity
            schemesPanel.querySelectorAll('.scheme-btn').forEach(btn => {
                btn.disabled = isDisabled;
                btn.style.opacity = isDisabled ? '0.4' : '1';
                btn.style.pointerEvents = isDisabled ? 'none' : 'auto';
            });

            // Show hint when disabled
            let hint = schemesPanel.querySelector('.scheme-hint');
            if (isDisabled) {
                if (!hint) {
                    hint = document.createElement('div');
                    hint.className = 'scheme-hint';
                    hint.style.cssText = 'padding: 8px; font-size: 10px; opacity: 0.6; text-align: center; font-style: italic;';
                    hint.textContent = 'Switch to a metric mode (Fan-In, Complexity, etc.) to enable color schemes';
                    schemesPanel.insertBefore(hint, schemesPanel.firstChild);
                }
            } else if (hint) {
                hint.remove();
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVENIENCE METHODS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply a view preset by name
     */
    function applyPreset(presetKey) {
        const preset = VIEW_PRESETS[presetKey];
        if (!preset) {
            console.warn('[VIS_STATE] Unknown preset:', presetKey);
            return;
        }

        applyState({
            colorBy: preset.colorBy,
            sizeBy: preset.sizeBy,
            edgeBy: preset.edgeBy,
            special: preset.special
        }, `preset:${presetKey}`);
    }

    /**
     * Set color mode only
     */
    function setColorBy(mode) {
        applyState({ colorBy: mode }, `colorBy:${mode}`);
    }

    /**
     * Set size mode only
     */
    function setSizeBy(mode) {
        applyState({ sizeBy: mode }, `sizeBy:${mode}`);
    }

    /**
     * Set edge mode only
     */
    function setEdgeBy(mode) {
        applyState({ edgeBy: mode }, `edgeBy:${mode}`);
    }

    /**
     * Set palette (arms the palette, applies if in interval mode)
     */
    function setPalette(schemeName) {
        applyState({ palette: schemeName }, `palette:${schemeName}`);
    }

    /**
     * Get current state (read-only copy)
     */
    function getState() {
        return { ...state };
    }

    /**
     * Initialize from saved preferences or defaults
     */
    function init() {
        try {
            const savedScheme = localStorage.getItem('collider_scheme');
            const savedColorMode = localStorage.getItem('collider_color_mode');

            if (savedScheme) state.palette = savedScheme;
            if (savedColorMode) state.colorBy = savedColorMode;

            state.paletteType = isIntervalMode(state.colorBy) ? 'interval' : 'categorical';
        } catch (e) { /* ignore localStorage errors */ }

        // Apply initial state to globals (critical for NODE_COLOR_MODE)
        _applyColorMode(state.colorBy);
        _applyPalette();

        console.log('[VIS_STATE] Initialized:', state);
    }

    /**
     * Save current preferences
     */
    function savePreferences() {
        try {
            localStorage.setItem('collider_scheme', state.palette);
            localStorage.setItem('collider_color_mode', state.colorBy);
        } catch (e) { /* ignore */ }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // State access
        getState,
        isIntervalMode,
        isCategoricalMode,

        // Main API
        applyState,
        applyPreset,
        syncUIFromState,

        // Convenience setters
        setColorBy,
        setSizeBy,
        setEdgeBy,
        setPalette,

        // Lifecycle
        init,
        savePreferences,

        // Constants
        VIEW_PRESETS,
        CATEGORICAL_MODES,
        INTERVAL_MODES
    };
})();

console.log('[Module] VIS_STATE loaded - unified visualization state');


// ═══ MODULE: modules/ui-manager.js ═══
/**
 * @module ui-manager
 * @description Orchestrates the "One Dock" unified interface
 * @responsibility Manage sidebar, dock, modes, and filters UI
 * @depends_on vis-state, data-manager, refresh-throttle
 */

const UI_MANAGER = (function() {
    'use strict';

    // Private state
    let _data = null;
    let _initialized = false;

    /**
     * Initialize the UI Manager
     * @param {Object} data - Graph data object
     */
    function init(data) {
        _data = data;
        _setupSidebar();
        _setupDock();
        _setupModes();
        _populateFilters();
        _updateStatus();
        _initialized = true;
    }

    /**
     * Setup sidebar toggle and accordion behavior
     */
    function _setupSidebar() {
        const sidebar = document.getElementById('sidebar');
        const btnFilters = document.getElementById('btn-filters');
        const btnClose = document.getElementById('sidebar-close');

        const toggle = () => {
            sidebar.classList.toggle('open');
            _updateFilterBadge();
        };

        if (btnFilters) btnFilters.onclick = (e) => {
            e.stopPropagation();
            toggle();
        };
        if (btnClose) btnClose.onclick = () => sidebar.classList.remove('open');

        // Accordion Logic
        document.querySelectorAll('.accordion-header').forEach(header => {
            header.onclick = () => {
                const accordion = header.parentElement;
                accordion.classList.toggle('open');
            };
        });
    }

    /**
     * Setup dock controls
     */
    function _setupDock() {
        // Reset Layout
        const btnReset = document.getElementById('btn-reset-layout');
        if (btnReset) btnReset.onclick = () => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.zoomToFit(1000);
            }
        };

        // Dimensions Toggle (2D/3D - stub)
        const btnDim = document.getElementById('btn-dimensions');
        if (btnDim) btnDim.onclick = () => {
            console.log("Dimension toggle requested");
        };

        // Report Button
        const btnReport = document.getElementById('btn-report');
        if (btnReport) btnReport.onclick = () => {
            const reportPanel = document.getElementById('report-panel');
            if (reportPanel) {
                const isHidden = reportPanel.style.display === 'none';
                reportPanel.style.display = isHidden ? 'block' : 'none';
                btnReport.classList.toggle('active', isHidden);
            }
        };
    }

    /**
     * Setup mode buttons (explore, files, flow)
     */
    function _setupModes() {
        const modes = ['explore', 'files', 'flow'];

        const setMode = (mode) => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = document.getElementById(`mode-${mode}`);
            if (activeBtn) activeBtn.classList.add('active');

            document.querySelectorAll('.mode-control-group').forEach(g => g.style.display = 'none');
            const group = document.getElementById(`${mode}-controls`);
            if (group) group.style.display = 'flex';
        };

        modes.forEach(mode => {
            const btn = document.getElementById(`mode-${mode}`);
            if (btn) btn.onclick = () => setMode(mode);
        });

        // Files Sub-controls wiring
        const bindToggle = (id, onClick) => {
            const el = document.getElementById(id);
            if (el) el.onclick = (e) => {
                e.target.classList.toggle('active');
                if (onClick) onClick(e.target.classList.contains('active'));
            };
        };

        bindToggle('btn-file-hulls', (_active) => {
            // Toggle hull visibility
        });
    }

    /**
     * Populate filter chips for all categories
     */
    function _populateFilters() {
        if (!_data) return;

        // Helper: Create Filter Chips
        const createChips = (containerId, counts, activeSet) => {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            counts.forEach(([key, count]) => {
                const chip = document.createElement('div');
                const isActive = activeSet.has(key);
                chip.className = `filter-chip ${isActive ? 'active' : ''}`;
                chip.innerHTML = `${key} <span class="chip-count">${count}</span>`;
                chip.onclick = () => {
                    if (activeSet.has(key)) activeSet.delete(key);
                    else activeSet.add(key);

                    chip.classList.toggle('active');
                    _updateFilterBadge();
                    // Call refreshGraph if available
                    if (typeof refreshGraph === 'function') refreshGraph();
                };
                container.appendChild(chip);
            });

            const type = containerId.replace('filter-', '');
            const countEl = document.getElementById(`count-${type}`);
            if (countEl) countEl.innerText = activeSet.size;
        };

        // Get accessor functions
        const getNodeRing = typeof window.getNodeRing === 'function' ? window.getNodeRing :
            (typeof NODE !== 'undefined' ? NODE.getRing : (n => n.ring || 'Unknown'));
        const getNodeTier = typeof window.getNodeTier === 'function' ? window.getNodeTier :
            (typeof NODE !== 'undefined' ? NODE.getTier : (n => n.tier || 'Unknown'));
        const getNodeAtomFamily = typeof window.getNodeAtomFamily === 'function' ? window.getNodeAtomFamily :
            (typeof NODE !== 'undefined' ? NODE.getFamily : (n => n.atom_family || 'Unknown'));
        const normalizeRingValue = typeof window.normalizeRingValue === 'function' ? window.normalizeRingValue :
            (typeof NODE !== 'undefined' ? NODE.normalizeRing : (v => v));
        const collectCounts = typeof window.collectCounts === 'function' ? window.collectCounts :
            _defaultCollectCounts;

        // Get VIS_FILTERS
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set(), edges: new Set(), families: new Set() };

        // 1. LAYERS (Rings)
        const ringCounts = collectCounts(_data.nodes, getNodeRing);
        const rawRingDefaults = _data.controls?.filters?.rings || [];
        const ringDefaults = rawRingDefaults
            .map(v => normalizeRingValue(v))
            .filter(v => v !== null);

        if (VIS_FILTERS.rings.size === 0 && ringDefaults.length > 0) {
            const availableRings = new Set(ringCounts.map(([ring]) => ring));
            const matchedRings = ringDefaults.filter(r => availableRings.has(r));
            if (matchedRings.length > 0) {
                matchedRings.forEach(r => VIS_FILTERS.rings.add(r));
            } else {
                const familyCounts = collectCounts(_data.nodes, getNodeAtomFamily);
                const availableFamilies = new Set(familyCounts.map(([family]) => family));
                const matchedFamilies = ringDefaults.filter(f => availableFamilies.has(f));
                if (matchedFamilies.length > 0 && VIS_FILTERS.families.size === 0) {
                    matchedFamilies.forEach(f => VIS_FILTERS.families.add(f));
                    console.warn('[Filters] Ring defaults matched families; applying as family filters.');
                }
            }
        }
        createChips('filter-rings', ringCounts, VIS_FILTERS.rings);

        // 2. TIERS
        const tierCounts = collectCounts(_data.nodes, getNodeTier);
        createChips('filter-tiers', tierCounts, VIS_FILTERS.tiers);

        // 3. ROLES
        const roleCounts = collectCounts(_data.nodes, n => String(n.role || 'Unknown'));
        createChips('filter-roles', roleCounts, VIS_FILTERS.roles);

        // 4. EDGES
        const edgeCounts = collectCounts(_data.links, l => String(l.edge_type || l.type || 'default'));
        createChips('filter-edges', edgeCounts, VIS_FILTERS.edges);

        // 5. DATAMAPS
        _populateDatamaps();

        _updateFilterBadge();
    }

    /**
     * Default collectCounts implementation
     */
    function _defaultCollectCounts(items, accessor) {
        const counts = new Map();
        items.forEach(item => {
            const key = accessor(item);
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    /**
     * Populate datamap chips
     */
    function _populateDatamaps() {
        const container = document.getElementById('filter-datamaps');
        if (!container) return;
        container.innerHTML = '';

        const controls = _data.controls || {};
        const resolveDatamapConfigs = typeof window.resolveDatamapConfigs === 'function'
            ? window.resolveDatamapConfigs
            : () => [];
        const configs = resolveDatamapConfigs(controls);
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS || new Set();
        const setDatamap = typeof window.setDatamap === 'function' ? window.setDatamap : () => {};

        configs.forEach(cfg => {
            const chip = document.createElement('div');
            const isActive = ACTIVE_DATAMAPS.has(cfg.id);
            chip.className = `filter-chip ${isActive ? 'active' : ''}`;
            chip.style.width = '100%';
            chip.style.marginBottom = '4px';
            chip.innerHTML = `${cfg.label}`;

            chip.onclick = () => {
                setDatamap(cfg.id);
                Array.from(container.children).forEach(c => c.classList.remove('active'));
                chip.classList.add('active');
            };
            container.appendChild(chip);
        });

        const countEl = document.getElementById('count-datamaps');
        if (countEl) countEl.innerText = configs.length;
    }

    /**
     * Update filter badge count
     */
    function _updateFilterBadge() {
        const VIS_FILTERS = window.VIS_FILTERS || { rings: new Set(), tiers: new Set(), roles: new Set() };

        let total = 0;
        total += VIS_FILTERS.rings.size;
        total += VIS_FILTERS.tiers.size;
        total += VIS_FILTERS.roles.size;

        const badge = document.getElementById('filter-badge');
        const miniBadge = document.getElementById('filter-badge-mini');

        if (badge) badge.innerText = total;
        if (miniBadge) {
            miniBadge.innerText = total;
            miniBadge.classList.toggle('visible', total > 0);
        }

        const summary = document.getElementById('filter-summary');
        if (summary) {
            summary.innerText = total > 0 ? `${total} filters active` : "No filters active";
        }
    }

    /**
     * Update status display (node/edge counts)
     */
    function _updateStatus() {
        if (_data && _data.nodes) {
            const n = _data.nodes.length;
            const e = _data.links.length;
            const statusNodes = document.getElementById('status-nodes');
            const statusEdges = document.getElementById('status-edges');

            if (statusNodes) statusNodes.innerText = n;
            if (statusEdges) statusEdges.innerText = e;
        }
    }

    /**
     * Refresh filters (re-populate from current data)
     */
    function refreshFilters() {
        _populateFilters();
    }

    /**
     * Update badge count (public interface)
     */
    function updateFilterBadge() {
        _updateFilterBadge();
    }

    // Public API
    return {
        init,
        refreshFilters,
        updateFilterBadge,
        get data() { return _data; },
        get initialized() { return _initialized; }
    };
})();

// Backward compatibility - expose as UIManager
const UIManager = {
    data: null,
    init(data) {
        this.data = data;
        UI_MANAGER.init(data);
    },
    setupSidebar() { /* Now internal */ },
    setupDock() { /* Now internal */ },
    setupModes() { /* Now internal */ },
    populateFilters() { UI_MANAGER.refreshFilters(); },
    populateDatamaps() { UI_MANAGER.refreshFilters(); },
    updateFilterBadge() { UI_MANAGER.updateFilterBadge(); },
    updateStatus() { /* Now internal */ }
};

// Expose globally
window.UI_MANAGER = UI_MANAGER;
window.UIManager = UIManager;


// ═══ MODULE: modules/physics.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * PHYSICS MODULE - Force simulation controls
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Physics presets, sliders, and force parameter management.
 * Depends on: Graph, PHYSICS_STATE, PHYSICS_PRESETS (globals)
 *
 * @module PHYSICS
 * @version 1.0.0
 */

window.PHYSICS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS STATE
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsState() {
        const Graph = window.Graph;
        const PHYSICS_STATE = window.PHYSICS_STATE;
        if (!Graph) return;
        try {
            Graph.d3Force('charge')?.strength(PHYSICS_STATE.charge);
            Graph.d3Force('link')?.distance(PHYSICS_STATE.linkDistance);
            Graph.d3Force('center')?.strength(PHYSICS_STATE.centerStrength);
            Graph.d3VelocityDecay?.(PHYSICS_STATE.velocityDecay);
            Graph.d3ReheatSimulation();
        } catch (e) {
            console.warn('[Physics] Could not apply:', e.message);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY PHYSICS PRESET
    // ═══════════════════════════════════════════════════════════════════════

    function applyPhysicsPreset(presetName) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const preset = PHYSICS_PRESETS[presetName];
        if (!preset) return;
        Object.assign(PHYSICS_STATE, {
            charge: preset.charge,
            linkDistance: preset.linkDistance,
            centerStrength: preset.centerStrength,
            velocityDecay: preset.velocityDecay
        });
        applyPhysicsState();
        updatePhysicsSliders();
        window.showModeToast(`Physics: ${preset.label}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE PHYSICS SLIDERS
    // ═══════════════════════════════════════════════════════════════════════

    function updatePhysicsSliders() {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const sliders = {
            'physics-charge': PHYSICS_STATE.charge,
            'physics-link-distance': PHYSICS_STATE.linkDistance,
            'physics-center': PHYSICS_STATE.centerStrength,
            'physics-damping': PHYSICS_STATE.velocityDecay
        };
        for (const [id, value] of Object.entries(sliders)) {
            const input = document.getElementById(id);
            const display = document.getElementById(id + '-value');
            if (input) input.value = value;
            if (display) display.textContent = typeof value === 'number' && value % 1 !== 0 ? value.toFixed(2) : value;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // BUILD PHYSICS CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function buildPhysicsControls(containerId) {
        const PHYSICS_STATE = window.PHYSICS_STATE;
        const PHYSICS_PRESETS = window.PHYSICS_PRESETS;
        const container = document.getElementById(containerId);
        if (!container) return;

        // Preset buttons
        const presetRow = document.createElement('div');
        presetRow.className = 'physics-presets';
        presetRow.style.cssText = 'display:flex;gap:4px;margin-bottom:8px;flex-wrap:wrap;';
        Object.entries(PHYSICS_PRESETS).forEach(([key, preset]) => {
            const btn = document.createElement('button');
            btn.className = 'preset-btn physics-preset-btn';
            btn.textContent = preset.label;
            btn.style.cssText = 'font-size:9px;padding:2px 6px;';
            btn.onclick = () => applyPhysicsPreset(key);
            presetRow.appendChild(btn);
        });
        container.appendChild(presetRow);

        // Sliders
        const sliderDefs = [
            {
                id: 'physics-charge',
                label: 'REPULSION',
                min: -500,
                max: 50,
                step: 10,
                value: PHYSICS_STATE.charge,
                onChange: (val) => { PHYSICS_STATE.charge = val; applyPhysicsState(); }
            },
            {
                id: 'physics-link-distance',
                label: 'LINK DIST',
                min: 10,
                max: 200,
                step: 5,
                value: PHYSICS_STATE.linkDistance,
                onChange: (val) => { PHYSICS_STATE.linkDistance = val; applyPhysicsState(); }
            },
            {
                id: 'physics-center',
                label: 'CENTER PULL',
                min: 0,
                max: 0.3,
                step: 0.01,
                value: PHYSICS_STATE.centerStrength,
                onChange: (val) => { PHYSICS_STATE.centerStrength = val; applyPhysicsState(); }
            },
            {
                id: 'physics-damping',
                label: 'DAMPING',
                min: 0,
                max: 1,
                step: 0.05,
                value: PHYSICS_STATE.velocityDecay,
                onChange: (val) => { PHYSICS_STATE.velocityDecay = val; applyPhysicsState(); }
            }
        ];

        sliderDefs.forEach(def => {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-row';

            const header = document.createElement('div');
            header.className = 'slider-header';
            const label = document.createElement('span');
            label.className = 'slider-label';
            label.textContent = def.label;
            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'slider-value';
            valueDisplay.id = def.id + '-value';
            valueDisplay.textContent = def.step < 1 ? def.value.toFixed(2) : def.value;
            header.appendChild(label);
            header.appendChild(valueDisplay);

            const input = document.createElement('input');
            input.type = 'range';
            input.className = 'slider-input';
            input.id = def.id;
            input.min = def.min;
            input.max = def.max;
            input.step = def.step;
            input.value = def.value;
            input.oninput = () => {
                const val = parseFloat(input.value);
                valueDisplay.textContent = def.step < 1 ? val.toFixed(2) : val;
                def.onChange(val);
            };

            wrapper.appendChild(header);
            wrapper.appendChild(input);
            container.appendChild(wrapper);
        });

        console.log('[Physics] Controls initialized');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        applyState: applyPhysicsState,
        applyPreset: applyPhysicsPreset,
        updateSliders: updatePhysicsSliders,
        buildControls: buildPhysicsControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.applyPhysicsState = PHYSICS.applyState;
window.applyPhysicsPreset = PHYSICS.applyPreset;
window.updatePhysicsSliders = PHYSICS.updateSliders;
window.buildPhysicsControls = PHYSICS.buildControls;

console.log('[Module] PHYSICS loaded - 4 functions');


// ═══ MODULE: modules/datamap.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DATAMAP MODULE - Data mapping and filtering
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Datamap configuration, matching, and UI control updates.
 * Depends on: DM, VIS_FILTERS, ACTIVE_DATAMAPS, NODE (node-accessors)
 *
 * @module DATAMAP
 * @version 1.0.0
 */

window.DATAMAP = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NORMALIZE DATAMAP CONFIG
    // ═══════════════════════════════════════════════════════════════════════

    function normalizeDatamapConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const id = String(raw.id || raw.key || raw.label || '').trim();
        if (!id) return null;
        const normalizeList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => String(item).toUpperCase());
        };
        const normalizeTierList = (value) => {
            if (!Array.isArray(value)) return [];
            return value.map(item => window.normalizeTier(item));
        };
        const match = raw.match || {};
        return {
            id: id.toUpperCase(),
            label: String(raw.label || raw.id || id).toUpperCase(),
            match: {
                atom_families: normalizeList(match.atom_families),
                atom_prefixes: normalizeList(match.atom_prefixes),
                tiers: normalizeTierList(match.tiers),
                rings: normalizeList(match.rings),
                roles: normalizeList(match.roles)
            },
            default: Boolean(raw.default)
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // RESOLVE DATAMAP CONFIGS
    // ═══════════════════════════════════════════════════════════════════════

    function resolveDatamapConfigs(controlsConfig) {
        const fromTokens = Array.isArray(controlsConfig.datamaps) ? controlsConfig.datamaps : [];
        const normalized = fromTokens
            .map(normalizeDatamapConfig)
            .filter(Boolean);
        if (normalized.length) return normalized;

        const fallback = controlsConfig.buttons?.datamaps || {};
        return Object.entries(fallback).map(([label, config]) => {
            const prefix = config.filter || null;
            return normalizeDatamapConfig({
                id: label.toUpperCase(),
                label: label.toUpperCase(),
                match: prefix ? { atom_prefixes: [prefix] } : {},
                default: false
            });
        }).filter(Boolean);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP MATCHING
    // ═══════════════════════════════════════════════════════════════════════

    function datamapMatches(node, config) {
        const match = config.match || {};
        const atomId = String(node.atom || '');
        const atomFamily = window.getNodeAtomFamily(node);
        const tier = window.getNodeTier(node);
        const ring = window.getNodeRing(node);
        const role = String(node.role || 'Unknown').toUpperCase();

        if (Array.isArray(match.atom_families) && match.atom_families.length) {
            if (!match.atom_families.includes(atomFamily)) return false;
        }

        if (Array.isArray(match.atom_prefixes) && match.atom_prefixes.length) {
            const matchesFamily = match.atom_prefixes.includes(atomFamily);
            const matchesPrefix = match.atom_prefixes.some(prefix => atomId.startsWith(prefix));
            if (!matchesFamily && !matchesPrefix) return false;
        }

        if (Array.isArray(match.tiers) && match.tiers.length) {
            if (!match.tiers.includes(tier)) return false;
        }

        if (Array.isArray(match.rings) && match.rings.length) {
            if (!match.rings.includes(ring)) return false;
        }

        if (Array.isArray(match.roles) && match.roles.length) {
            if (!match.roles.includes(role)) return false;
        }
        return true;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET DATAMAP
    // ═══════════════════════════════════════════════════════════════════════

    function setDatamap(prefix) {
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const nextSet = new Set(ACTIVE_DATAMAPS);
        if (!prefix) {
            nextSet.clear();
        } else if (nextSet.has(prefix)) {
            nextSet.delete(prefix);
        } else {
            nextSet.add(prefix);
        }

        if (!window.DM) {
            window.ACTIVE_DATAMAPS = nextSet;
            updateDatamapControls();
            return;
        }

        const subset = window.filterGraph(null, window.CURRENT_DENSITY, nextSet, window.VIS_FILTERS);
        if (!subset.nodes.length) {
            window.showToast('No nodes for that datamap selection.');
            updateDatamapControls();
            return;
        }

        window.ACTIVE_DATAMAPS = nextSet;
        updateDatamapControls();
        window.refreshGraph();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SET NODE COLOR MODE
    // ═══════════════════════════════════════════════════════════════════════

    function setNodeColorMode(mode) {
        window.NODE_COLOR_MODE = mode;
        if (typeof window.renderAllLegends === 'function') {
            window.renderAllLegends();
        }
        window.refreshGraph();
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY DATAMAP (ALIAS)
    // ═══════════════════════════════════════════════════════════════════════

    function applyDatamap(prefix) {
        setDatamap(prefix);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE DATAMAP CONTROLS UI
    // ═══════════════════════════════════════════════════════════════════════

    function updateDatamapControls() {
        const DM = window.DM;
        const ACTIVE_DATAMAPS = window.ACTIVE_DATAMAPS;
        const DATAMAP_UI = window.DATAMAP_UI;
        const DATAMAP_CONFIGS = window.DATAMAP_CONFIGS;
        const GRAPH_MODE = window.GRAPH_MODE;
        const VIS_FILTERS = window.VIS_FILTERS;

        if (!DM) return;
        const datamapEnabled = GRAPH_MODE === 'atoms';
        const base = window.filterGraph(null, window.CURRENT_DENSITY, new Set(), VIS_FILTERS);
        const nodes = base.nodes || [];
        const totalCount = nodes.length;

        const allUI = DATAMAP_UI.get('__ALL__');
        if (allUI) {
            allUI.input.checked = ACTIVE_DATAMAPS.size === 0;
            if (allUI.count) {
                allUI.count.textContent = datamapEnabled ? String(totalCount) : '--';
            }
            allUI.input.disabled = !datamapEnabled;
            allUI.wrapper.classList.toggle('disabled', !datamapEnabled);
            allUI.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.size === 0);
        }

        DATAMAP_CONFIGS.forEach((config) => {
            const count = nodes.reduce((acc, node) => acc + (datamapMatches(node, config) ? 1 : 0), 0);
            const ui = DATAMAP_UI.get(config.id);
            if (!ui) return;
            if (ui.count) {
                ui.count.textContent = datamapEnabled ? String(count) : '--';
            }
            ui.input.disabled = !datamapEnabled || count === 0;
            ui.wrapper.classList.toggle('disabled', !datamapEnabled || count === 0);
            ui.input.checked = ACTIVE_DATAMAPS.has(config.id);
            ui.wrapper.classList.toggle('active', datamapEnabled && ACTIVE_DATAMAPS.has(config.id));
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        normalizeConfig: normalizeDatamapConfig,
        resolveConfigs: resolveDatamapConfigs,
        matches: datamapMatches,
        set: setDatamap,
        setColorMode: setNodeColorMode,
        apply: applyDatamap,
        updateControls: updateDatamapControls
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.normalizeDatamapConfig = DATAMAP.normalizeConfig;
window.resolveDatamapConfigs = DATAMAP.resolveConfigs;
window.datamapMatches = DATAMAP.matches;
window.setDatamap = DATAMAP.set;
window.setNodeColorMode = DATAMAP.setColorMode;
window.applyDatamap = DATAMAP.apply;
window.updateDatamapControls = DATAMAP.updateControls;

console.log('[Module] DATAMAP loaded - 7 functions');


// ═══ MODULE: modules/groups.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * GROUPS MODULE - Node grouping functionality
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Group creation, storage, rendering, and management.
 * Depends on: GROUPS, ACTIVE_GROUP_ID, SELECTED_NODE_IDS, GROUPS_STORAGE_KEY
 *
 * @module GROUPS_MODULE
 * @version 1.0.0
 */

window.GROUPS_MODULE = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    function loadGroups() {
        window.GROUPS = [];
        try {
            const stored = localStorage.getItem(window.GROUPS_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    window.GROUPS = parsed;
                }
            }
        } catch (e) {
            // localStorage unavailable
        }
        window.GROUPS = window.GROUPS.filter(group => group && group.id && Array.isArray(group.node_ids));
        window.GROUPS.forEach(group => {
            if (group.visible === undefined) group.visible = true;
        });
    }

    function saveGroups() {
        try {
            localStorage.setItem(window.GROUPS_STORAGE_KEY, JSON.stringify(window.GROUPS));
        } catch (e) {
            // localStorage unavailable
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getNextGroupColor() {
        const hue = (window.GROUPS.length * 137.5) % 360;
        return window.hslColor(hue, 65, 55);
    }

    function getGroupById(groupId) {
        return window.GROUPS.find(group => group.id === groupId) || null;
    }

    function getPrimaryGroupForNode(nodeId) {
        const visibleGroups = window.GROUPS.filter(group =>
            group.visible !== false && Array.isArray(group.node_ids) && group.node_ids.includes(nodeId)
        );
        if (!visibleGroups.length) return null;
        if (window.ACTIVE_GROUP_ID) {
            const active = visibleGroups.find(group => group.id === window.ACTIVE_GROUP_ID);
            if (active) return active;
        }
        return visibleGroups[0];
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP LIST RENDERING
    // ═══════════════════════════════════════════════════════════════════════

    function renderGroupList() {
        const container = document.getElementById('group-list');
        if (!container) return;
        container.innerHTML = '';

        if (!window.GROUPS.length) {
            const empty = document.createElement('div');
            empty.style.fontSize = '9px';
            empty.style.color = 'rgba(255,255,255,0.4)';
            empty.textContent = 'No groups yet';
            container.appendChild(empty);
            return;
        }

        window.GROUPS.forEach(group => {
            const row = document.createElement('div');
            row.className = 'group-item';
            row.classList.toggle('active', group.id === window.ACTIVE_GROUP_ID);

            const dot = document.createElement('span');
            dot.className = 'group-color';
            dot.style.background = group.color || '#6fe8ff';

            const name = document.createElement('span');
            name.className = 'group-name';
            name.textContent = group.name || 'Group';

            const count = document.createElement('span');
            count.className = 'group-count';
            count.textContent = String((group.node_ids || []).length);

            const toggle = document.createElement('input');
            toggle.type = 'checkbox';
            toggle.className = 'group-toggle';
            toggle.checked = group.visible !== false;
            toggle.onchange = (e) => {
                e.stopPropagation();
                group.visible = toggle.checked;
                saveGroups();
                window.updateSelectionVisuals();
                renderGroupList();
            };

            row.onclick = (e) => {
                if (e.target === toggle) return;
                window.ACTIVE_GROUP_ID = group.id;
                renderGroupList();
                window.setSelection(group.node_ids || []);
                window.updateSelectionVisuals();
            };

            row.appendChild(dot);
            row.appendChild(name);
            row.appendChild(count);
            row.appendChild(toggle);
            container.appendChild(row);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // GROUP BUTTON STATE
    // ═══════════════════════════════════════════════════════════════════════

    function updateGroupButtonState() {
        const btn = document.getElementById('btn-create-group');
        if (!btn) return;
        const hasSelection = window.SELECTED_NODE_IDS.size > 0;
        btn.classList.toggle('disabled', !hasSelection);
        btn.disabled = !hasSelection;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CREATE GROUP FROM SELECTION
    // ═══════════════════════════════════════════════════════════════════════

    function createGroupFromSelection() {
        if (window.SELECTED_NODE_IDS.size === 0) return;
        const nodeIds = Array.from(window.SELECTED_NODE_IDS);
        const groupId = `group_${Date.now().toString(36)}`;
        const groupName = `Group ${window.GROUPS.length + 1}`;
        const groupColor = getNextGroupColor();
        window.GROUPS.push({
            id: groupId,
            name: groupName,
            color: groupColor,
            node_ids: nodeIds,
            visible: true
        });
        window.ACTIVE_GROUP_ID = groupId;
        saveGroups();
        renderGroupList();
        window.updateSelectionVisuals();
        window.showToast(`Created ${groupName} (${nodeIds.length})`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        load: loadGroups,
        save: saveGroups,
        getNextColor: getNextGroupColor,
        getById: getGroupById,
        getPrimaryForNode: getPrimaryGroupForNode,
        renderList: renderGroupList,
        updateButtonState: updateGroupButtonState,
        createFromSelection: createGroupFromSelection
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.loadGroups = GROUPS_MODULE.load;
window.saveGroups = GROUPS_MODULE.save;
window.getNextGroupColor = GROUPS_MODULE.getNextColor;
window.getGroupById = GROUPS_MODULE.getById;
window.getPrimaryGroupForNode = GROUPS_MODULE.getPrimaryForNode;
window.renderGroupList = GROUPS_MODULE.renderList;
window.updateGroupButtonState = GROUPS_MODULE.updateButtonState;
window.createGroupFromSelection = GROUPS_MODULE.createFromSelection;

console.log('[Module] GROUPS_MODULE loaded - 8 functions');


// ═══ MODULE: modules/hover.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HOVER MODULE - Node hover and click interactions
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Node hover panel updates, click handling, and interaction management.
 * Depends on: HOVERED_NODE, VIS_FILTERS, GRAPH_MODE, DM, Graph
 *
 * @module HOVER
 * @version 1.0.0
 */

window.HOVER = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // UPDATE HOVER PANEL
    // ═══════════════════════════════════════════════════════════════════════

    function updateHoverPanel(node) {
        const hoverPanel = document.getElementById('hover-panel');
        const placeholder = document.getElementById('hover-placeholder');
        if (!hoverPanel) return;

        if (!node) {
            hoverPanel.classList.remove('has-node');
            if (placeholder) placeholder.style.display = '';
            return;
        }

        hoverPanel.classList.add('has-node');
        if (placeholder) placeholder.style.display = 'none';

        // Helper to set element text safely
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val ?? '--';
        };

        // Basic info
        setEl('hover-name', node.label || node.id || 'Unknown');
        setEl('hover-type', node.type || node.kind || '--');
        setEl('hover-file', node.file_path || '--');

        // Tier/Ring/Family
        setEl('hover-tier', window.getNodeTier ? window.getNodeTier(node) : (node.tier || '--'));
        setEl('hover-ring', window.getNodeRing ? window.getNodeRing(node) : (node.ring || '--'));
        setEl('hover-family', window.getNodeAtomFamily ? window.getNodeAtomFamily(node) : (node.atom_family || '--'));

        // Metrics
        setEl('hover-complexity', node.complexity ?? '--');
        setEl('hover-loc', node.lines_of_code ?? node.loc ?? '--');
        setEl('hover-fanin', node.in_degree ?? '--');
        setEl('hover-fanout', node.out_degree ?? '--');

        // Role
        setEl('hover-role', node.role || '--');

        // Code preview (if available)
        const codeEl = document.getElementById('hover-code');
        if (codeEl) {
            const code = node.body_source || node.body || '';
            codeEl.textContent = code ? code.substring(0, 500) : '// no source';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE HOVER
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeHover(node, data) {
        const filePanel = document.getElementById('file-panel');
        window.HOVERED_NODE = node || null;

        // Always update hover panel
        updateHoverPanel(node);

        // Guard: file-panel may not exist
        if (!filePanel) return;

        const VIS_FILTERS = window.VIS_FILTERS;
        if (!VIS_FILTERS.metadata.showFilePanel) {
            filePanel.classList.remove('visible');
            return;
        }

        if (!node) {
            setTimeout(() => {
                if (!window.fileMode) filePanel.classList.remove('visible');
            }, 300);
            return;
        }

        // Get file info from boundaries
        const boundaries = data.file_boundaries || [];
        const fileIdx = node.fileIdx;

        if (fileIdx < 0 || fileIdx >= boundaries.length) {
            return;
        }

        const fileInfo = boundaries[fileIdx];

        // Update panel content
        const setEl = (id, val) => {
            const el = document.getElementById(id);
            if (el) el.textContent = val;
        };
        setEl('file-name', fileInfo.file_name || 'unknown');
        setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
        setEl('file-purpose', fileInfo.purpose || '--');
        setEl('file-atom-count', fileInfo.atom_count || 0);
        setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
        setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
        setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

        // Code preview from node body
        const code = node.body || '// no source available';
        setEl('file-code', code);

        // Show panel
        filePanel.classList.add('visible');
        if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HANDLE NODE CLICK
    // ═══════════════════════════════════════════════════════════════════════

    function handleNodeClick(node, event) {
        if (!node) return;
        const additive = event && event.shiftKey;
        if (additive) {
            window.toggleSelection(node);
            return;
        }
        if (node.id) {
            window.setSelection([node.id]);
        }
        const GRAPH_MODE = window.GRAPH_MODE;
        if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
            window.toggleFileExpand(node.fileIdx);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updatePanel: updateHoverPanel,
        onNodeHover: handleNodeHover,
        onNodeClick: handleNodeClick
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateHoverPanel = HOVER.updatePanel;
window.handleNodeHover = HOVER.onNodeHover;
window.handleNodeClick = HOVER.onNodeClick;

console.log('[Module] HOVER loaded - 3 functions');


// ═══ MODULE: modules/flow.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * FLOW MODULE - Flow visualization mode with presets
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Flow mode highlights high-entropy nodes and edge transition probabilities.
 * Cycles through visual presets (EMBER, OCEAN, PLASMA, MATRIX, PULSE, AURORA).
 * Depends on: Graph, DM, THEME_CONFIG, APPEARANCE_CONFIG, FLOW_CONFIG
 *
 * @module FLOW
 * @version 1.0.0
 */

window.FLOW = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // PRESET COLOR/VALUE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    function getFlowPresetColor(presetName, property, fallback) {
        const schemes = (window.THEME_CONFIG && window.THEME_CONFIG.colors && window.THEME_CONFIG.colors.schemes) || {};
        const scheme = schemes[presetName.toLowerCase()] || {};
        return scheme[property] || fallback;
    }

    function getFlowPresetValue(presetName, property, fallback) {
        const presets = (typeof window.APPEARANCE_CONFIG !== 'undefined' && window.APPEARANCE_CONFIG && window.APPEARANCE_CONFIG['flow-presets']) || {};
        const preset = presets[presetName.toLowerCase()] || {};
        const value = preset[property];
        return (value !== undefined && value !== null) ? value : fallback;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FLOW PRESETS
    // ═══════════════════════════════════════════════════════════════════════

    const PRESETS = [
        {
            name: 'EMBER',
            highlightColor: getFlowPresetColor('EMBER', 'highlightColor', getFlowPresetValue('ember', 'highlightColor', '#ff8c00')),
            particleColor: getFlowPresetColor('EMBER', 'particleColor', getFlowPresetValue('ember', 'particleColor', '#ffaa00')),
            dimColor: getFlowPresetColor('EMBER', 'dimColor', getFlowPresetValue('ember', 'dimColor', '#331100')),
            edgeColor: getFlowPresetColor('EMBER', 'edgeColor', getFlowPresetValue('ember', 'edgeColor', '#ff6600')),
            particleCount: getFlowPresetValue('ember', 'particleCount', 3),
            particleWidth: getFlowPresetValue('ember', 'particleWidth', 2.5),
            particleSpeed: getFlowPresetValue('ember', 'particleSpeed', 0.008),
            edgeWidthScale: getFlowPresetValue('ember', 'edgeWidthScale', 3.0),
            sizeMultiplier: getFlowPresetValue('ember', 'sizeMultiplier', 1.8),
            edgeOpacityMin: getFlowPresetValue('ember', 'edgeOpacityMin', 0.3),
            dimOpacity: getFlowPresetValue('ember', 'dimOpacity', 0.05)
        },
        {
            name: 'OCEAN',
            highlightColor: getFlowPresetColor('OCEAN', 'highlightColor', getFlowPresetValue('ocean', 'highlightColor', '#00d4ff')),
            particleColor: getFlowPresetColor('OCEAN', 'particleColor', getFlowPresetValue('ocean', 'particleColor', '#4df0ff')),
            dimColor: getFlowPresetColor('OCEAN', 'dimColor', getFlowPresetValue('ocean', 'dimColor', '#001122')),
            edgeColor: getFlowPresetColor('OCEAN', 'edgeColor', getFlowPresetValue('ocean', 'edgeColor', '#0088cc')),
            particleCount: getFlowPresetValue('ocean', 'particleCount', 4),
            particleWidth: getFlowPresetValue('ocean', 'particleWidth', 2.0),
            particleSpeed: getFlowPresetValue('ocean', 'particleSpeed', 0.006),
            edgeWidthScale: getFlowPresetValue('ocean', 'edgeWidthScale', 2.5),
            sizeMultiplier: getFlowPresetValue('ocean', 'sizeMultiplier', 1.6),
            edgeOpacityMin: getFlowPresetValue('ocean', 'edgeOpacityMin', 0.25),
            dimOpacity: getFlowPresetValue('ocean', 'dimOpacity', 0.03)
        },
        {
            name: 'PLASMA',
            highlightColor: getFlowPresetColor('PLASMA', 'highlightColor', getFlowPresetValue('plasma', 'highlightColor', '#ff00ff')),
            particleColor: getFlowPresetColor('PLASMA', 'particleColor', getFlowPresetValue('plasma', 'particleColor', '#ff66ff')),
            dimColor: getFlowPresetColor('PLASMA', 'dimColor', getFlowPresetValue('plasma', 'dimColor', '#110011')),
            edgeColor: getFlowPresetColor('PLASMA', 'edgeColor', getFlowPresetValue('plasma', 'edgeColor', '#cc00cc')),
            particleCount: getFlowPresetValue('plasma', 'particleCount', 5),
            particleWidth: getFlowPresetValue('plasma', 'particleWidth', 3.0),
            particleSpeed: getFlowPresetValue('plasma', 'particleSpeed', 0.012),
            edgeWidthScale: getFlowPresetValue('plasma', 'edgeWidthScale', 4.0),
            sizeMultiplier: getFlowPresetValue('plasma', 'sizeMultiplier', 2.0),
            edgeOpacityMin: getFlowPresetValue('plasma', 'edgeOpacityMin', 0.35),
            dimOpacity: getFlowPresetValue('plasma', 'dimOpacity', 0.04)
        },
        {
            name: 'MATRIX',
            highlightColor: getFlowPresetColor('MATRIX', 'highlightColor', getFlowPresetValue('matrix', 'highlightColor', '#00ff00')),
            particleColor: getFlowPresetColor('MATRIX', 'particleColor', getFlowPresetValue('matrix', 'particleColor', '#88ff88')),
            dimColor: getFlowPresetColor('MATRIX', 'dimColor', getFlowPresetValue('matrix', 'dimColor', '#001100')),
            edgeColor: getFlowPresetColor('MATRIX', 'edgeColor', getFlowPresetValue('matrix', 'edgeColor', '#00cc00')),
            particleCount: getFlowPresetValue('matrix', 'particleCount', 6),
            particleWidth: getFlowPresetValue('matrix', 'particleWidth', 1.5),
            particleSpeed: getFlowPresetValue('matrix', 'particleSpeed', 0.015),
            edgeWidthScale: getFlowPresetValue('matrix', 'edgeWidthScale', 2.0),
            sizeMultiplier: getFlowPresetValue('matrix', 'sizeMultiplier', 1.4),
            edgeOpacityMin: getFlowPresetValue('matrix', 'edgeOpacityMin', 0.2),
            dimOpacity: getFlowPresetValue('matrix', 'dimOpacity', 0.02)
        },
        {
            name: 'PULSE',
            highlightColor: getFlowPresetColor('PULSE', 'highlightColor', getFlowPresetValue('pulse', 'highlightColor', '#ff4444')),
            particleColor: getFlowPresetColor('PULSE', 'particleColor', getFlowPresetValue('pulse', 'particleColor', '#ff8888')),
            dimColor: getFlowPresetColor('PULSE', 'dimColor', getFlowPresetValue('pulse', 'dimColor', '#110000')),
            edgeColor: getFlowPresetColor('PULSE', 'edgeColor', getFlowPresetValue('pulse', 'edgeColor', '#cc2222')),
            particleCount: getFlowPresetValue('pulse', 'particleCount', 2),
            particleWidth: getFlowPresetValue('pulse', 'particleWidth', 4.0),
            particleSpeed: getFlowPresetValue('pulse', 'particleSpeed', 0.004),
            edgeWidthScale: getFlowPresetValue('pulse', 'edgeWidthScale', 5.0),
            sizeMultiplier: getFlowPresetValue('pulse', 'sizeMultiplier', 2.2),
            edgeOpacityMin: getFlowPresetValue('pulse', 'edgeOpacityMin', 0.4),
            dimOpacity: getFlowPresetValue('pulse', 'dimOpacity', 0.06)
        },
        {
            name: 'AURORA',
            highlightColor: getFlowPresetColor('AURORA', 'highlightColor', getFlowPresetValue('aurora', 'highlightColor', '#33ccbb')),
            particleColor: getFlowPresetColor('AURORA', 'particleColor', getFlowPresetValue('aurora', 'particleColor', '#66ffee')),
            dimColor: getFlowPresetColor('AURORA', 'dimColor', getFlowPresetValue('aurora', 'dimColor', '#002222')),
            edgeColor: getFlowPresetColor('AURORA', 'edgeColor', getFlowPresetValue('aurora', 'edgeColor', '#22aa99')),
            particleCount: getFlowPresetValue('aurora', 'particleCount', 4),
            particleWidth: getFlowPresetValue('aurora', 'particleWidth', 2.2),
            particleSpeed: getFlowPresetValue('aurora', 'particleSpeed', 0.007),
            edgeWidthScale: getFlowPresetValue('aurora', 'edgeWidthScale', 3.5),
            sizeMultiplier: getFlowPresetValue('aurora', 'sizeMultiplier', 1.7),
            edgeOpacityMin: getFlowPresetValue('aurora', 'edgeOpacityMin', 0.28),
            dimOpacity: getFlowPresetValue('aurora', 'dimOpacity', 0.04)
        }
    ];

    let currentPresetIndex = 0;

    // ═══════════════════════════════════════════════════════════════════════
    // TOGGLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function toggle() {
        const flowMode = window.flowMode;

        // If already in flow mode, cycle to next preset
        if (flowMode) {
            currentPresetIndex = (currentPresetIndex + 1) % PRESETS.length;
            const preset = PRESETS[currentPresetIndex];
            console.log(`[Flow] Cycling to preset: ${preset.name}`);
            applyVisualization();
            window.showModeToast(`FLOW: ${preset.name}`);
            return;
        }

        window.flowMode = true;
        currentPresetIndex = 0;
        console.log('[Flow] Toggled to:', window.flowMode);

        // Sync BOTH potential buttons (Dock vs CommandBar)
        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.toggle('active', window.flowMode);

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.toggle('active', window.flowMode);

        // Show/hide flow legend
        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.toggle('visible', window.flowMode);

        // EXCLUSIVE MODE: Clear other visual noise
        if (typeof window.clearAllFileModes === 'function') {
            window.clearAllFileModes();
        }
        // Ensure standard file/hull buttons are off
        document.querySelectorAll('.file-mode-btn').forEach(b => b.classList.remove('active'));

        applyVisualization();
        const preset = PRESETS[currentPresetIndex];
        window.showModeToast(`FLOW: ${preset.name}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DISABLE FLOW MODE
    // ═══════════════════════════════════════════════════════════════════════

    function disable() {
        if (!window.flowMode) return;
        window.flowMode = false;
        currentPresetIndex = 0;

        const btnDock = document.getElementById('btn-flow');
        if (btnDock) btnDock.classList.remove('active');

        const btnCmd = document.getElementById('cmd-flow2');
        if (btnCmd) btnCmd.classList.remove('active');

        const legend = document.getElementById('flow-legend');
        if (legend) legend.classList.remove('visible');

        clearVisualization();
        window.showModeToast('Flow mode off');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // APPLY FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function applyVisualization() {
        const Graph = window.Graph;
        const DM = window.DM;

        // Guard: Ensure Graph is ready
        if (!Graph || !DM) {
            console.warn('[Flow] Graph or DM not ready');
            return;
        }

        // Get current preset settings
        const preset = PRESETS[currentPresetIndex];
        const markov = DM.getMarkov ? DM.getMarkov() : {};
        const highEntropy = markov.high_entropy_nodes || [];

        // Use preset values (fallback to FLOW_CONFIG for topK/minWeight if not in preset)
        const flowCfg = window.FLOW_CONFIG || {};
        const highlightColor = preset.highlightColor;
        const particleColor = preset.particleColor;
        const sizeMult = preset.sizeMultiplier;
        const edgeScale = preset.edgeWidthScale;
        const particleCount = preset.particleCount;
        const particleWidth = preset.particleWidth;
        const particleSpeed = preset.particleSpeed;
        const edgeOpacityMin = preset.edgeOpacityMin;
        const dimOpacity = preset.dimOpacity;
        const topK = flowCfg.topKEdges || 3;
        const minWeight = flowCfg.minWeight || 0.01;

        // Build set of high entropy node names
        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();
        highEntropy.forEach(n => highEntropyNodes.add(n.node));
        window.highEntropyNodes = highEntropyNodes;

        const graphNodes = Graph.graphData().nodes;
        const graphLinks = Graph.graphData().links;

        // THRESHOLDING: Build a map of top-K outgoing edges per source node
        const edgesBySource = new Map();
        graphLinks.forEach(link => {
            const srcId = typeof link.source === 'object' ? link.source.id : link.source;
            if (!edgesBySource.has(srcId)) {
                edgesBySource.set(srcId, []);
            }
            edgesBySource.get(srcId).push(link);
        });

        // For each source, keep only top-K by markov_weight (transition probability)
        const visibleEdges = new Set();
        edgesBySource.forEach((edges, srcId) => {
            const sorted = edges
                .filter(e => (e.markov_weight || 0) >= minWeight)
                .sort((a, b) => (b.markov_weight || 0) - (a.markov_weight || 0))
                .slice(0, topK);
            sorted.forEach(e => visibleEdges.add(e));
        });

        // Store original colors and sizes, then apply flow coloring
        const originalNodeColors = window.originalNodeColors || new Map();
        window.originalNodeColors = originalNodeColors;

        graphNodes.forEach(node => {
            if (!originalNodeColors.has(node.id)) {
                originalNodeColors.set(node.id, node.color);
            }
            // Restore original size first (in case switching presets)
            if (node._originalVal) {
                node.val = node._originalVal;
            } else {
                node._originalVal = node.val || 1;
            }
            // High entropy nodes highlighted (decision points)
            if (highEntropyNodes.has(node.name)) {
                node.color = highlightColor;
                node.val = node._originalVal * sizeMult;
            }
        });

        // Update link widths based on markov_weight (with amplification)
        const maxMarkov = Math.max(0.001, ...graphLinks.map(l => l.markov_weight || 0));
        const amplify = window.amplify || (x => x);

        Graph.linkWidth(link => {
            if (!visibleEdges.has(link)) return 0.1;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return 0.5 + amplified * edgeScale * 2;
        });

        // Update link opacity to emphasize important edges
        Graph.linkOpacity(link => {
            if (!visibleEdges.has(link)) return dimOpacity;
            const mw = link.markov_weight || 0;
            const normalized = mw / maxMarkov;
            const amplified = amplify(normalized);
            return edgeOpacityMin + amplified * (1.0 - edgeOpacityMin);
        });

        // Add directional particles only on visible edges
        Graph.linkDirectionalParticles(link => {
            if (!visibleEdges.has(link)) return 0;
            return particleCount;
        });
        Graph.linkDirectionalParticleWidth(particleWidth);
        Graph.linkDirectionalParticleSpeed(particleSpeed);
        Graph.linkDirectionalParticleColor(() => particleColor);

        // Update node coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }

        // Debug: count edges with markov weights
        const edgesWithMarkov = graphLinks.filter(l => l.markov_weight > 0).length;
        console.log(`[Flow] Preset: ${preset.name} | ${highEntropyNodes.size} high entropy nodes, ${visibleEdges.size} visible edges (top-${topK}), ${edgesWithMarkov}/${graphLinks.length} edges with markov`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CLEAR FLOW VISUALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    function clearVisualization() {
        const Graph = window.Graph;

        // Guard: Ensure Graph is ready
        if (!Graph) return;

        const graphNodes = Graph.graphData().nodes;
        const originalNodeColors = window.originalNodeColors || new Map();

        // Restore original node colors and sizes
        graphNodes.forEach(node => {
            if (originalNodeColors.has(node.id)) {
                node.color = originalNodeColors.get(node.id);
            }
            // Restore original size from saved value
            if (node._originalVal) {
                node.val = node._originalVal;
                delete node._originalVal;
            }
        });

        // Reset link widths
        Graph.linkWidth(1);

        // Reset link opacity
        Graph.linkOpacity(0.6);

        // Remove directional particles
        Graph.linkDirectionalParticles(0);

        // Update coloring
        const toColorNumber = window.toColorNumber || (c => c);
        Graph.nodeColor(n => toColorNumber(n.color, '#888888'));

        const highEntropyNodes = window.highEntropyNodes || new Set();
        highEntropyNodes.clear();

        if (typeof window.applyEdgeMode === 'function') {
            window.applyEdgeMode();
        }
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        getPresetColor: getFlowPresetColor,
        getPresetValue: getFlowPresetValue,
        toggle: toggle,
        disable: disable,
        apply: applyVisualization,
        clear: clearVisualization,
        PRESETS: PRESETS,
        getCurrentPreset: () => PRESETS[currentPresetIndex],
        getCurrentPresetIndex: () => currentPresetIndex
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.getFlowPresetColor = FLOW.getPresetColor;
window.getFlowPresetValue = FLOW.getPresetValue;
window.toggleFlowMode = FLOW.toggle;
window.disableFlowMode = FLOW.disable;
window.applyFlowVisualization = FLOW.apply;
window.clearFlowVisualization = FLOW.clear;
window.FLOW_PRESETS = FLOW.PRESETS;

console.log('[Module] FLOW loaded - 6 functions');


// ═══ MODULE: modules/ui-builders.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * UI-BUILDERS MODULE - DOM element construction utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Factory functions for building common UI elements: checkboxes, toggles,
 * filter groups, and option selectors.
 *
 * @module UI_BUILDERS
 * @version 1.0.0
 */

window.UI_BUILDERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // COUNT COLLECTION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Collect counts by key from items
     * @param {Array} items - Items to count
     * @param {Function} keyFn - Function to extract key from item
     * @returns {Array} Array of [key, count] pairs sorted by count desc
     */
    function collectCounts(items, keyFn) {
        const counts = new Map();
        items.forEach(item => {
            const key = keyFn(item);
            if (!key) return;
            counts.set(key, (counts.get(key) || 0) + 1);
        });
        return Array.from(counts.entries()).sort((a, b) => b[1] - a[1]);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CHECKBOX ROW
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a checkbox row element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Element ID
     * @param {string} label - Display label
     * @param {number|null} count - Optional count to display
     * @param {boolean} checked - Initial checked state
     * @param {Function} onChange - Callback when checkbox changes
     * @returns {HTMLInputElement} The checkbox input element
     */
    function buildCheckboxRow(container, id, label, count, checked, onChange) {
        const row = document.createElement('div');
        row.className = 'filter-item';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = id;
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('label');
        text.setAttribute('for', id);
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'filter-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        row.appendChild(input);
        row.appendChild(text);
        if (countEl.textContent) {
            row.appendChild(countEl);
        }
        container.appendChild(row);

        return input;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER GROUP
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a filter group with ALL checkbox and individual items
     * @param {string} containerId - Container element ID
     * @param {Array} items - Array of [value, count] pairs
     * @param {Set} stateSet - Set to track selected values
     * @param {Function} onUpdate - Callback when selection changes
     */
    function buildFilterGroup(containerId, items, stateSet, onUpdate) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const allId = `${containerId}-all`;
        let allCheckbox = null;

        allCheckbox = buildCheckboxRow(container, allId, 'ALL', null, true, (checked) => {
            stateSet.clear();
            if (checked) {
                items.forEach(([value]) => stateSet.add(value));
            }
            container.querySelectorAll('input[type="checkbox"]').forEach(box => {
                if (box.id !== allId) box.checked = checked;
            });
            onUpdate();
        });

        items.forEach(([value, count], index) => {
            const id = `${containerId}-${index}`;
            const checked = stateSet.has(value);
            buildCheckboxRow(container, id, value, count, checked, (isChecked) => {
                if (isChecked) {
                    stateSet.add(value);
                } else {
                    stateSet.delete(value);
                }
                const allChecked = items.every(([v]) => stateSet.has(v));
                allCheckbox.checked = allChecked;
                onUpdate();
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DATAMAP TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build a datamap toggle element
     * @param {HTMLElement} container - Parent container
     * @param {string} id - Toggle ID
     * @param {string} label - Display label
     * @param {boolean} checked - Initial checked state
     * @param {number|null} count - Optional count to display
     * @param {Function} onChange - Callback when toggle changes
     * @returns {Object} Object with wrapper, input, and count elements
     */
    function buildDatamapToggle(container, id, label, checked, count, onChange) {
        const wrapper = document.createElement('label');
        wrapper.className = 'datamap-toggle';
        wrapper.setAttribute('data-id', id);

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = checked;
        input.onchange = () => onChange(input.checked);

        const text = document.createElement('span');
        text.textContent = label;

        const countEl = document.createElement('span');
        countEl.className = 'datamap-count';
        countEl.textContent = (typeof count === 'number') ? String(count) : '';

        wrapper.appendChild(input);
        wrapper.appendChild(text);
        wrapper.appendChild(countEl);
        container.appendChild(wrapper);

        return { wrapper, input, count: countEl };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // EXCLUSIVE OPTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build exclusive (radio-like) options using checkboxes
     * @param {string} containerId - Container element ID
     * @param {Array} options - Array of {label, value} objects
     * @param {*} activeValue - Currently active value
     * @param {Function} onSelect - Callback when option is selected
     */
    function buildExclusiveOptions(containerId, options, activeValue, onSelect) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';

        const inputs = [];
        options.forEach((option, index) => {
            const id = `${containerId}-${index}`;
            const input = buildCheckboxRow(
                container,
                id,
                option.label,
                null,
                option.value === activeValue,
                (checked) => {
                    if (!checked) {
                        input.checked = true;
                        return;
                    }
                    inputs.forEach(other => {
                        if (other !== input) other.checked = false;
                    });
                    onSelect(option.value);
                }
            );
            inputs.push(input);
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        collectCounts: collectCounts,
        buildCheckboxRow: buildCheckboxRow,
        buildFilterGroup: buildFilterGroup,
        buildDatamapToggle: buildDatamapToggle,
        buildExclusiveOptions: buildExclusiveOptions
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.collectCounts = UI_BUILDERS.collectCounts;
window.buildCheckboxRow = UI_BUILDERS.buildCheckboxRow;
window.buildFilterGroup = UI_BUILDERS.buildFilterGroup;
window.buildDatamapToggle = UI_BUILDERS.buildDatamapToggle;
window.buildExclusiveOptions = UI_BUILDERS.buildExclusiveOptions;

console.log('[Module] UI_BUILDERS loaded - 5 functions');


// ═══ MODULE: modules/layout-helpers.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT-HELPERS MODULE - Layout stability and position utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Functions for saving/restoring node positions, freezing/unfreezing layout,
 * and calculating file positions.
 * Depends on: Graph, NODE_POSITION_CACHE, LAYOUT_FROZEN, IS_3D
 *
 * @module LAYOUT_HELPERS
 * @version 1.0.0
 */

window.LAYOUT_HELPERS = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // POSITION PERSISTENCE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Save current node positions to cache
     */
    function saveNodePositions() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;
        if (!Graph || !cache) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined && node.y !== undefined) {
                cache.set(node.id, {
                    x: node.x, y: node.y, z: node.z || 0,
                    vx: node.vx || 0, vy: node.vy || 0, vz: node.vz || 0,
                    fx: node.fx, fy: node.fy, fz: node.fz
                });
            }
        });
    }

    /**
     * Restore node positions from cache
     * @param {Array} nodes - Nodes to restore positions for
     */
    function restoreNodePositions(nodes) {
        const cache = window.NODE_POSITION_CACHE;
        const frozen = window.LAYOUT_FROZEN;
        if (!cache) return;

        nodes.forEach(node => {
            const cached = cache.get(node.id);
            if (cached) {
                node.x = cached.x;
                node.y = cached.y;
                node.z = cached.z;
                node.vx = cached.vx;
                node.vy = cached.vy;
                node.vz = cached.vz;
                // Pin nodes in place when layout is frozen
                if (frozen) {
                    node.fx = cached.x;
                    node.fy = cached.y;
                    node.fz = cached.z;
                }
            }
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LAYOUT FREEZE/UNFREEZE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Freeze layout by pinning all nodes in place
     */
    function freezeLayout() {
        window.LAYOUT_FROZEN = true;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            if (node.x !== undefined) {
                node.fx = node.x;
                node.fy = node.y;
                node.fz = node.z;
            }
        });
        Graph.cooldownTicks(0);  // Stop simulation immediately
    }

    /**
     * Unfreeze layout by unpinning all nodes
     */
    function unfreezeLayout() {
        window.LAYOUT_FROZEN = false;
        const Graph = window.Graph;
        if (!Graph) return;

        const nodes = Graph.graphData().nodes || [];
        nodes.forEach(node => {
            node.fx = undefined;
            node.fy = undefined;
            node.fz = undefined;
        });
    }

    /**
     * Reset layout - clear cache and reheat simulation
     */
    function resetLayout() {
        const Graph = window.Graph;
        const cache = window.NODE_POSITION_CACHE;

        // Clear position cache
        if (cache) cache.clear();

        // Unfreeze and restart simulation
        unfreezeLayout();

        if (Graph) {
            Graph.cooldownTicks(200);  // Allow simulation to run
            Graph.d3ReheatSimulation();
        }

        if (typeof window.showModeToast === 'function') {
            window.showModeToast('Layout reset - physics running');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LINK/FILE HELPERS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get the ID of a link endpoint (source or target)
     * @param {Object} link - The link object
     * @param {string} side - 'source' or 'target'
     * @returns {string|undefined} The endpoint ID
     */
    function getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.id || endpoint;
        }
        return endpoint;
    }

    /**
     * Calculate target position for a file node in radial layout
     * @param {number} fileIdx - Index of the file
     * @param {number} totalFiles - Total number of files
     * @param {number} radius - Radius of the circle
     * @param {number} zSpacing - Z-axis spacing between files
     * @returns {Object} Position {x, y, z}
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpacing) {
        if (totalFiles <= 0) {
            return { x: 0, y: 0, z: 0 };
        }
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        const is3D = window.IS_3D;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: is3D ? (fileIdx - totalFiles / 2) * zSpacing : 0
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        savePositions: saveNodePositions,
        restorePositions: restoreNodePositions,
        freeze: freezeLayout,
        unfreeze: unfreezeLayout,
        reset: resetLayout,
        getLinkEndpointId: getLinkEndpointId,
        getFileTarget: getFileTarget
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.saveNodePositions = LAYOUT_HELPERS.savePositions;
window.restoreNodePositions = LAYOUT_HELPERS.restorePositions;
window.freezeLayout = LAYOUT_HELPERS.freeze;
window.unfreezeLayout = LAYOUT_HELPERS.unfreeze;
window.resetLayout = LAYOUT_HELPERS.reset;
window.getLinkEndpointId = LAYOUT_HELPERS.getLinkEndpointId;
window.getFileTarget = LAYOUT_HELPERS.getFileTarget;

console.log('[Module] LAYOUT_HELPERS loaded - 7 functions');


// ═══ MODULE: modules/spatial.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * SPATIAL MODULE - Spatial algorithms and collision detection
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Spatial hashing for O(n) collision detection, convex hull calculation,
 * and node sampling utilities.
 * Depends on: IS_3D, FILE_CONTAINMENT, THREE
 *
 * @module SPATIAL
 * @version 1.0.0
 */

window.SPATIAL = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // NODE SAMPLING
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Sample nodes evenly if there are too many
     * @param {Array} nodes - Array of nodes
     * @param {number} maxPoints - Maximum number of points to return
     * @returns {Array} Sampled nodes
     */
    function sampleFileNodes(nodes, maxPoints) {
        if (nodes.length <= maxPoints) return nodes;
        const step = Math.ceil(nodes.length / maxPoints);
        return nodes.filter((_, idx) => idx % step === 0);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CONVEX HULL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build 2D convex hull using Andrew's monotone chain algorithm
     * @param {Array} points - Array of {x, y} points
     * @returns {Array|null} Hull points or null if insufficient points
     */
    function buildHull2D(points) {
        if (points.length < 3) return null;

        // Remove duplicates
        const unique = new Map();
        points.forEach(p => {
            const key = `${p.x.toFixed(4)},${p.y.toFixed(4)}`;
            if (!unique.has(key)) unique.set(key, p);
        });

        // Sort by x, then y
        const pts = Array.from(unique.values()).sort((a, b) => {
            if (a.x === b.x) return a.y - b.y;
            return a.x - b.x;
        });

        if (pts.length < 3) return null;

        // Cross product of vectors OA and OB
        const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

        // Build lower hull
        const lower = [];
        for (const p of pts) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                lower.pop();
            }
            lower.push(p);
        }

        // Build upper hull
        const upper = [];
        for (let i = pts.length - 1; i >= 0; i--) {
            const p = pts[i];
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                upper.pop();
            }
            upper.push(p);
        }

        // Remove last point of each half (it's the starting point of the other)
        upper.pop();
        lower.pop();

        return lower.concat(upper);
    }

    /**
     * Compute centroid of points
     * @param {Array} points - Array of THREE.Vector3-like objects
     * @returns {THREE.Vector3} Centroid
     */
    function computeCentroid(points) {
        const THREE = window.THREE;
        const centroid = new THREE.Vector3();
        points.forEach(p => centroid.add(p));
        return centroid.divideScalar(Math.max(1, points.length));
    }

    // ═══════════════════════════════════════════════════════════════════════
    // SPATIAL HASHING - O(n) collision detection
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Build spatial hash grid for efficient neighbor queries
     * @param {Array} nodes - Array of nodes with x, y, z coordinates
     * @param {number} cellSize - Size of each grid cell
     * @returns {Map} Grid map with cell keys to node arrays
     */
    function buildSpatialGrid(nodes, cellSize) {
        const is3D = window.IS_3D;
        const grid = new Map();

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) grid.set(key, []);
            grid.get(key).push(node);
        });

        // Store for file containment
        if (window.FILE_CONTAINMENT) {
            window.FILE_CONTAINMENT.spatialGrid = grid;
        }

        return grid;
    }

    /**
     * Get keys for neighboring cells (3x3x3 in 3D, 3x3 in 2D)
     * @param {number} cellX - Cell X coordinate
     * @param {number} cellY - Cell Y coordinate
     * @param {number} cellZ - Cell Z coordinate
     * @returns {Array} Array of neighbor cell keys
     */
    function getNeighborCells(cellX, cellY, cellZ) {
        const is3D = window.IS_3D;
        const neighbors = [];

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dz = is3D ? -1 : 0; dz <= (is3D ? 1 : 0); dz++) {
                    neighbors.push(`${cellX + dx},${cellY + dy},${cellZ + dz}`);
                }
            }
        }

        return neighbors;
    }

    /**
     * Apply soft collision forces to push overlapping nodes apart
     * @param {Array} nodes - Array of nodes
     * @param {number} cellSize - Spatial grid cell size
     * @param {number} repulsionStrength - Strength of repulsion (0-1)
     */
    function applySoftCollisions(nodes, cellSize, repulsionStrength = 0.5) {
        const containment = window.FILE_CONTAINMENT;
        const is3D = window.IS_3D;

        if (!containment || !containment.collisionEnabled) return;

        const grid = buildSpatialGrid(nodes, cellSize);
        const minDist = 8;  // Minimum distance between particles
        const minDistSq = minDist * minDist;

        nodes.forEach(node => {
            if (!node || !Number.isFinite(node.x)) return;
            if (!node.__physics) {
                node.__physics = { vx: 0, vy: 0, vz: 0 };
            }

            const cellX = Math.floor(node.x / cellSize);
            const cellY = Math.floor(node.y / cellSize);
            const cellZ = is3D ? Math.floor((node.z || 0) / cellSize) : 0;
            const neighborKeys = getNeighborCells(cellX, cellY, cellZ);

            neighborKeys.forEach(key => {
                const cellNodes = grid.get(key);
                if (!cellNodes) return;

                cellNodes.forEach(other => {
                    if (other === node) return;

                    const dx = node.x - other.x;
                    const dy = node.y - other.y;
                    const dz = is3D ? ((node.z || 0) - (other.z || 0)) : 0;
                    const distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq < minDistSq && distSq > 0.001) {
                        const dist = Math.sqrt(distSq);
                        const overlap = minDist - dist;
                        const force = (overlap / minDist) * repulsionStrength;

                        // Push apart along normal
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = is3D ? dz / dist : 0;

                        node.__physics.vx += nx * force;
                        node.__physics.vy += ny * force;
                        if (is3D) node.__physics.vz += nz * force;
                    }
                });
            });
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        sampleFileNodes: sampleFileNodes,
        buildHull2D: buildHull2D,
        computeCentroid: computeCentroid,
        buildSpatialGrid: buildSpatialGrid,
        getNeighborCells: getNeighborCells,
        applySoftCollisions: applySoftCollisions
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.sampleFileNodes = SPATIAL.sampleFileNodes;
window.buildHull2D = SPATIAL.buildHull2D;
window.computeCentroid = SPATIAL.computeCentroid;
window.buildSpatialGrid = SPATIAL.buildSpatialGrid;
window.getNeighborCells = SPATIAL.getNeighborCells;
window.applySoftCollisions = SPATIAL.applySoftCollisions;

console.log('[Module] SPATIAL loaded - 6 functions');


// ═══ MODULE: modules/layout.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * LAYOUT MODULE - Unified UI Layout Engine
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * MIGRATED FROM: app.js HudLayoutManager (390 lines)
 * This is the SINGLE SOURCE OF TRUTH for UI layout intelligence.
 *
 * Features:
 *   - Panel placement with collision avoidance (from HudLayoutManager)
 *   - Component registration system (NEW)
 *   - Toast/control-bar collision detection (NEW)
 *   - Min-width graph validation (NEW)
 *   - Debug overlay with Ctrl+Shift+L (NEW)
 *
 * @module LAYOUT
 * @version 2.0.0
 * @confidence 94%
 */

window.LAYOUT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // CONFIGURATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    const CONFIG = {
        MARGIN: 16,
        MIN_GRAPH_WIDTH: 320,
        REFLOW_THROTTLE_MS: 50,
        DEBUG_COLORS: {
            dock: 'rgba(100, 150, 255, 0.3)',
            overlay: 'rgba(255, 150, 100, 0.3)',
            floating: 'rgba(100, 255, 150, 0.3)',
            fixed: 'rgba(150, 150, 150, 0.3)'
        }
    };

    // Panels by priority (higher = more important, won't be moved)
    // MIGRATED from HudLayoutManager
    const FIXED_PANELS = ['top-left-header', 'stats-panel', 'metrics-panel', 'bottom-dock', 'report-panel', 'side-dock'];
    const DYNAMIC_PANELS = ['hover-panel', 'file-panel', 'selection-panel'];

    // ═══════════════════════════════════════════════════════════════════════
    // STATE
    // ═══════════════════════════════════════════════════════════════════════

    // Throttle state (from HudLayoutManager)
    let _rafPending = false;
    let _lastReflow = 0;

    // Mouse position for hover-panel placement (from HudLayoutManager)
    let _mouseX = 0;
    let _mouseY = 0;

    // Component registry (NEW)
    const _registry = new Map();

    // Debug overlay state (NEW)
    let _debugEnabled = false;
    let _debugOverlay = null;

    // ═══════════════════════════════════════════════════════════════════════
    // VIEWPORT & RECT UTILITIES (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Get viewport rectangle with margins
     */
    function getViewport() {
        return {
            left: CONFIG.MARGIN,
            top: CONFIG.MARGIN,
            right: window.innerWidth - CONFIG.MARGIN,
            bottom: window.innerHeight - CONFIG.MARGIN,
            width: window.innerWidth - 2 * CONFIG.MARGIN,
            height: window.innerHeight - 2 * CONFIG.MARGIN
        };
    }

    /**
     * Check if sidebar is effectively "open" (occupying space)
     */
    function isSidebarOpen() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock) return false;
        const state = window.SIDEBAR_STATE;
        return (state && (state.locked || state.open)) ||
            sideDock.classList.contains('locked') ||
            sideDock.classList.contains('expanded') ||
            sideDock.matches(':hover');
    }

    /**
     * Get rectangle for an element (returns null if hidden/missing)
     */
    function getRect(el) {
        if (!el) return null;
        if (typeof el === 'string') {
            el = document.getElementById(el) || document.querySelector(el);
        }
        if (!el) return null;
        const style = window.getComputedStyle(el);
        if (style.display === 'none' || style.visibility === 'hidden') return null;
        const r = el.getBoundingClientRect();
        if (r.width === 0 && r.height === 0) return null;
        return { left: r.left, top: r.top, right: r.right, bottom: r.bottom, width: r.width, height: r.height };
    }

    /**
     * Get sidebar occupied region (full expanded width when open)
     */
    function getSidebarRect() {
        const sideDock = document.getElementById('side-dock');
        if (!sideDock || !isSidebarOpen()) return null;
        const sideWidth = parseInt(getComputedStyle(sideDock).getPropertyValue('--side-width')) || 260;
        return {
            left: 0,
            top: 0,
            right: 16 + sideWidth + 20,
            bottom: window.innerHeight,
            width: 16 + sideWidth + 20,
            height: window.innerHeight
        };
    }

    /**
     * Get all occupied rectangles (fixed panels + sidebar when open)
     */
    function getOccupiedRects() {
        const rects = [];

        // Sidebar takes priority when open
        const sidebarRect = getSidebarRect();
        if (sidebarRect) rects.push(sidebarRect);

        // Fixed panels
        FIXED_PANELS.forEach(id => {
            if (id === 'side-dock') return;
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (rect) rects.push(rect);
        });

        // Top-left header (special case - class-based)
        const topLeft = document.querySelector('.top-left');
        const topLeftRect = getRect(topLeft);
        if (topLeftRect) rects.push(topLeftRect);

        return rects;
    }

    /**
     * Calculate overlap area between two rectangles
     */
    function overlapArea(r1, r2) {
        if (!r1 || !r2) return 0;
        const xOverlap = Math.max(0, Math.min(r1.right, r2.right) - Math.max(r1.left, r2.left));
        const yOverlap = Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
        return xOverlap * yOverlap;
    }

    /**
     * Check if rect is fully inside viewport
     */
    function isInsideViewport(rect, viewport) {
        return rect.left >= viewport.left &&
            rect.top >= viewport.top &&
            rect.right <= viewport.right &&
            rect.bottom <= viewport.bottom;
    }

    /**
     * Clamp position to keep panel inside viewport
     */
    function clampToViewport(pos, panelWidth, panelHeight, viewport) {
        return {
            left: Math.max(viewport.left, Math.min(pos.left, viewport.right - panelWidth)),
            top: Math.max(viewport.top, Math.min(pos.top, viewport.bottom - panelHeight))
        };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // CANDIDATE GENERATION (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Generate candidate positions for file panel
     */
    function getFilePanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Generate candidate positions for selection panel
     */
    function getSelectionPanelCandidates(panelWidth, panelHeight) {
        const vp = getViewport();
        const margin = 20;
        const sidebarOpen = isSidebarOpen();
        const sidebarWidth = sidebarOpen ? 300 : 0;

        return sidebarOpen ? [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: sidebarWidth + margin, top: vp.bottom - panelHeight - margin },
            { left: sidebarWidth + margin, top: vp.top + margin }
        ] : [
            { left: vp.right - panelWidth - margin, top: vp.bottom - panelHeight - margin },
            { left: vp.right - panelWidth - margin, top: vp.top + margin },
            { left: vp.left + margin, top: vp.bottom - panelHeight - margin },
            { left: vp.left + margin, top: vp.top + margin }
        ];
    }

    /**
     * Get screen centroid of selected nodes
     */
    function getSelectionCentroid() {
        const Graph = window.Graph;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (!Graph || !Graph.graphData || !selectedIds || selectedIds.size === 0) return null;

        const nodes = Graph.graphData().nodes || [];
        const selectedNodes = nodes.filter(n => selectedIds.has(n.id));
        if (selectedNodes.length === 0) return null;

        let sumX = 0, sumY = 0, sumZ = 0;
        selectedNodes.forEach(n => {
            sumX += n.x || 0;
            sumY += n.y || 0;
            sumZ += n.z || 0;
        });
        const centroid3D = {
            x: sumX / selectedNodes.length,
            y: sumY / selectedNodes.length,
            z: sumZ / selectedNodes.length
        };

        const camera = Graph.camera();
        if (!camera || !window.THREE) return null;
        const vector = new window.THREE.Vector3(centroid3D.x, centroid3D.y, centroid3D.z);
        vector.project(camera);
        return {
            x: (vector.x * 0.5 + 0.5) * window.innerWidth,
            y: (-vector.y * 0.5 + 0.5) * window.innerHeight
        };
    }

    /**
     * Generate candidate positions for hover panel
     */
    function getHoverPanelCandidates(mouseX, mouseY, panelWidth, panelHeight) {
        const vp = getViewport();
        const offset = 16;

        let anchorX = mouseX;
        let anchorY = mouseY;

        const hoveredNode = window.HOVERED_NODE;
        const selectedIds = window.SELECTED_NODE_IDS;
        if (hoveredNode && selectedIds && selectedIds.has(hoveredNode.id)) {
            const centroid = getSelectionCentroid();
            if (centroid) {
                anchorX = mouseX * 0.3 + centroid.x * 0.7;
                anchorY = mouseY * 0.3 + centroid.y * 0.7;
            }
        }

        const sidebarOpen = isSidebarOpen();
        const sidebarRect = sidebarOpen ? getSidebarRect() : null;
        const minLeft = sidebarRect ? sidebarRect.right + offset : vp.left;

        let candidates = [
            { left: anchorX + offset, top: anchorY - panelHeight - offset },
            { left: anchorX + offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY + offset },
            { left: anchorX - panelWidth - offset, top: anchorY - panelHeight - offset }
        ];

        if (sidebarRect) {
            candidates = candidates.map(c => ({
                left: Math.max(c.left, minLeft),
                top: c.top
            }));
        }

        return candidates;
    }

    /**
     * Update mouse position
     */
    function updateMousePosition(x, y) {
        _mouseX = x;
        _mouseY = y;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PANEL PLACEMENT (from HudLayoutManager)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Place a panel at the best position (least overlap)
     */
    function placePanel(panelEl, candidates, occupiedRects) {
        if (!panelEl) return null;

        const rect = panelEl.getBoundingClientRect();
        const panelWidth = rect.width || 400;
        const panelHeight = rect.height || 350;
        const viewport = getViewport();

        let bestPos = candidates[0];
        let bestOverlap = Infinity;

        for (const pos of candidates) {
            const clampedPos = clampToViewport(pos, panelWidth, panelHeight, viewport);
            const panelRect = {
                left: clampedPos.left,
                top: clampedPos.top,
                right: clampedPos.left + panelWidth,
                bottom: clampedPos.top + panelHeight
            };

            let totalOverlap = 0;
            for (const occRect of occupiedRects) {
                totalOverlap += overlapArea(panelRect, occRect);
            }

            if (!isInsideViewport(panelRect, viewport)) {
                totalOverlap += 10000;
            }

            if (totalOverlap < bestOverlap) {
                bestOverlap = totalOverlap;
                bestPos = clampedPos;
                if (totalOverlap === 0) break;
            }
        }

        return bestPos;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST/CONTROL-BAR COLLISION (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Check and resolve toast/control-bar collision
     * Returns offset to apply to toast if collision detected
     */
    function resolveToastCollision() {
        const toast = document.getElementById('toast') ||
                      document.getElementById('hud-toast') ||
                      document.getElementById('mode-toast');
        const controlBar = document.querySelector('.control-bar');

        if (!toast || !controlBar) return 0;

        const toastRect = getRect(toast);
        const barRect = getRect(controlBar);

        if (!toastRect || !barRect) return 0;

        const overlap = overlapArea(toastRect, barRect);
        if (overlap > 0) {
            // Move toast above control bar
            const offset = barRect.height + CONFIG.MARGIN;
            console.log(`[LAYOUT] Toast/control-bar collision: ${overlap}px², offset: -${offset}px`);
            return -offset;
        }
        return 0;
    }

    /**
     * Apply toast offset if needed
     */
    function applyToastOffset() {
        const offset = resolveToastCollision();
        if (offset !== 0) {
            const toast = document.getElementById('toast') ||
                          document.getElementById('hud-toast');
            if (toast) {
                toast.style.transform = `translateX(-50%) translateY(${offset}px)`;
            }
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MIN-WIDTH VALIDATOR (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Validate graph has minimum width, adjust sidebars if needed
     */
    function validateGraphWidth() {
        const leftSidebar = document.getElementById('left-sidebar');
        const rightSidebar = document.getElementById('right-sidebar');
        const viewport = getViewport();

        const leftWidth = leftSidebar ? (getRect(leftSidebar)?.width || 0) : 0;
        const rightWidth = rightSidebar ? (getRect(rightSidebar)?.width || 0) : 0;
        const graphWidth = viewport.width - leftWidth - rightWidth;

        if (graphWidth < CONFIG.MIN_GRAPH_WIDTH) {
            const deficit = CONFIG.MIN_GRAPH_WIDTH - graphWidth;
            console.warn(`[LAYOUT] Graph width ${graphWidth}px < ${CONFIG.MIN_GRAPH_WIDTH}px minimum`);

            // Try to reduce right sidebar
            if (rightSidebar && rightWidth > 200) {
                const newWidth = Math.max(200, rightWidth - deficit);
                document.documentElement.style.setProperty('--right-panel-width', newWidth + 'px');
                return { adjusted: true, component: 'right-sidebar', newWidth };
            }
        }
        return { adjusted: false };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // REFLOW (from HudLayoutManager, enhanced)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Reflow all dynamic panels
     */
    function reflow() {
        const now = Date.now();
        if (now - _lastReflow < CONFIG.REFLOW_THROTTLE_MS) {
            if (!_rafPending) {
                _rafPending = true;
                requestAnimationFrame(() => {
                    _rafPending = false;
                    reflow();
                });
            }
            return;
        }
        _lastReflow = now;

        const occupiedRects = getOccupiedRects();

        // Place hover panel first (higher priority)
        const hoverPanel = document.getElementById('hover-panel');
        let hoverPanelRect = null;
        if (hoverPanel && hoverPanel.classList.contains('visible')) {
            const hoverWidth = hoverPanel.offsetWidth || 280;
            const hoverHeight = hoverPanel.offsetHeight || 200;
            const candidates = getHoverPanelCandidates(_mouseX, _mouseY, hoverWidth, hoverHeight);
            const pos = placePanel(hoverPanel, candidates, occupiedRects);
            if (pos) {
                hoverPanel.style.left = pos.left + 'px';
                hoverPanel.style.top = pos.top + 'px';
                hoverPanel.style.right = 'auto';
                hoverPanelRect = {
                    left: pos.left, top: pos.top,
                    right: pos.left + hoverWidth, bottom: pos.top + hoverHeight
                };
            }
        }

        const filePanelOccupied = [...occupiedRects];
        if (hoverPanelRect) filePanelOccupied.push(hoverPanelRect);

        // Place selection panel
        const selectionPanel = document.getElementById('selection-panel');
        if (selectionPanel && selectionPanel.classList.contains('visible')) {
            const candidates = getSelectionPanelCandidates(
                selectionPanel.offsetWidth || 320,
                selectionPanel.offsetHeight || 280
            );
            const pos = placePanel(selectionPanel, candidates, filePanelOccupied);
            if (pos) {
                selectionPanel.style.left = pos.left + 'px';
                selectionPanel.style.top = pos.top + 'px';
                selectionPanel.style.right = 'auto';
                filePanelOccupied.push({
                    left: pos.left, top: pos.top,
                    right: pos.left + (selectionPanel.offsetWidth || 320),
                    bottom: pos.top + (selectionPanel.offsetHeight || 280)
                });
            }
        }

        // Place file panel
        const filePanel = document.getElementById('file-panel');
        if (filePanel && filePanel.classList.contains('visible')) {
            const candidates = getFilePanelCandidates(
                filePanel.offsetWidth || 400,
                filePanel.offsetHeight || 350
            );
            const pos = placePanel(filePanel, candidates, filePanelOccupied);
            if (pos) {
                filePanel.style.left = pos.left + 'px';
                filePanel.style.top = pos.top + 'px';
                filePanel.style.bottom = 'auto';
            }
        }

        // NEW: Check toast/control-bar collision
        applyToastOffset();

        // NEW: Validate graph width
        validateGraphWidth();

        // NEW: Update debug overlay
        if (_debugEnabled) updateDebugOverlay();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // DEBUG OVERLAY (NEW)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle debug overlay
     */
    function toggleDebugOverlay() {
        _debugEnabled = !_debugEnabled;

        if (_debugEnabled) {
            if (!_debugOverlay) {
                _debugOverlay = document.createElement('div');
                _debugOverlay.id = 'layout-debug-overlay';
                _debugOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0;
                    width: 100%; height: 100%;
                    pointer-events: none; z-index: 10001;
                `;
                document.body.appendChild(_debugOverlay);
            }
            updateDebugOverlay();
            console.log('[LAYOUT] Debug overlay ON (Ctrl+Shift+L)');
        } else {
            if (_debugOverlay) {
                _debugOverlay.remove();
                _debugOverlay = null;
            }
            console.log('[LAYOUT] Debug overlay OFF');
        }
    }

    /**
     * Update debug overlay with current component bounds
     */
    function updateDebugOverlay() {
        if (!_debugOverlay) return;

        let html = '';
        const allPanels = [...FIXED_PANELS, ...DYNAMIC_PANELS, 'toast', 'control-bar', 'left-sidebar', 'right-sidebar'];

        allPanels.forEach(id => {
            const el = document.getElementById(id) || document.querySelector('.' + id);
            const rect = getRect(el);
            if (!rect) return;

            const kind = FIXED_PANELS.includes(id) ? 'fixed' :
                         DYNAMIC_PANELS.includes(id) ? 'floating' : 'overlay';
            const color = CONFIG.DEBUG_COLORS[kind] || 'rgba(128,128,128,0.3)';

            html += `
                <div style="
                    position: fixed;
                    left: ${rect.left}px; top: ${rect.top}px;
                    width: ${rect.width}px; height: ${rect.height}px;
                    background: ${color};
                    border: 1px solid ${color.replace('0.3', '0.8')};
                    font-size: 10px; color: white; text-shadow: 0 0 2px black;
                    padding: 2px 4px; box-sizing: border-box; overflow: hidden;
                ">${id}</div>
            `;
        });

        _debugOverlay.innerHTML = html;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COMPONENT REGISTRATION (NEW - for future explicit constraints)
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Register a component (for explicit constraint tracking)
     */
    function register(descriptor) {
        const { id, selector, kind = 'dock' } = descriptor;
        if (!id) return null;

        let element = typeof selector === 'string' ?
            (document.getElementById(selector.replace('#', '')) || document.querySelector(selector)) :
            selector;

        _registry.set(id, { ...descriptor, element });
        console.log(`[LAYOUT] Registered: ${id} (${kind})`);
        return _registry.get(id);
    }

    /**
     * Get registered component
     */
    function get(id) {
        return _registry.get(id) || null;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize layout system
     */
    function init() {
        // Window resize
        window.addEventListener('resize', () => reflow());

        // Track mouse position
        window.addEventListener('mousemove', (e) => {
            updateMousePosition(e.clientX, e.clientY);
        }, { passive: true });

        // Sidebar state changes
        const sideDock = document.getElementById('side-dock');
        if (sideDock) {
            sideDock.addEventListener('mouseenter', () => reflow());
            sideDock.addEventListener('mouseleave', () => {
                setTimeout(() => reflow(), 200);
            });
        }

        // Debug overlay shortcut (Ctrl+Shift+L)
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                e.preventDefault();
                toggleDebugOverlay();
            }
        });

        console.log('[LAYOUT] Initialized (replaces HudLayoutManager)');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        // Core utilities
        getViewport,
        getRect,
        overlapArea,
        isInsideViewport,
        clampToViewport,

        // Panel placement (backward compatible with HudLayoutManager)
        getOccupiedRects,
        placePanel,
        getFilePanelCandidates,
        getSelectionPanelCandidates,
        getHoverPanelCandidates,
        getSelectionCentroid,
        updateMousePosition,

        // Main entry points
        reflow,
        init,

        // NEW: Validation
        validateGraphWidth,
        resolveToastCollision,

        // NEW: Debug
        toggleDebugOverlay,

        // NEW: Registration
        register,
        get,

        // Config (read-only)
        CONFIG: Object.freeze({ ...CONFIG })
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY: HudLayoutManager alias
// ═══════════════════════════════════════════════════════════════════════════

window.HudLayoutManager = LAYOUT;
window.Layout = LAYOUT;

console.log('[Module] LAYOUT loaded - Unified Layout Engine v2.0.0');


// ═══ MODULE: modules/hud.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * HUD MODULE - Heads-up display management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles HUD fade behavior and stats panel updates.
 * Depends on: DOM elements (stat-nodes, stat-edges, stat-entropy, etc.)
 *
 * @module HUD
 * @version 1.0.0
 */

window.HUD = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // HUD FADE BEHAVIOR
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup HUD auto-fade on idle
     * Fades HUD elements after period of inactivity
     */
    function setupFade() {
        const idleDelay = 2200;
        let timer = null;

        const activate = () => {
            document.body.classList.remove('hud-quiet');
            if (timer) {
                clearTimeout(timer);
            }
            timer = setTimeout(() => {
                document.body.classList.add('hud-quiet');
            }, idleDelay);
        };

        ['mousemove', 'mousedown', 'keydown', 'touchstart'].forEach((evt) => {
            window.addEventListener(evt, activate, { passive: true });
        });

        activate();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STATS UPDATES
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update all HUD stats elements
     * @param {Object} data - Graph data with nodes, links, meta
     */
    function updateStats(data) {
        if (!data) return;

        // Stats panel: NODES, EDGES, ENTROPY
        const nodeCount = (data.nodes || []).length;
        const edgeCount = (data.links || []).length;

        const statNodes = document.getElementById('stat-nodes');
        const statEdges = document.getElementById('stat-edges');
        const statEntropy = document.getElementById('stat-entropy');

        if (statNodes) statNodes.textContent = nodeCount.toLocaleString();
        if (statEdges) statEdges.textContent = edgeCount.toLocaleString();
        if (statEntropy) {
            const entropy = data.meta?.entropy ?? data.entropy ?? '--';
            statEntropy.textContent = typeof entropy === 'number' ? entropy.toFixed(2) : entropy;
        }

        // Header panel: target name and timestamp
        const targetName = document.getElementById('target-name');
        const timestamp = document.getElementById('timestamp');

        if (targetName) {
            const target = data.meta?.target || data.target || 'Unknown';
            // Show just the last part of the path
            const shortTarget = target.split('/').pop() || target;
            targetName.textContent = shortTarget;
        }

        if (timestamp) {
            const ts = data.meta?.timestamp || data.timestamp || '';
            // Format: 2024-01-15T10:30:00 -> 2024-01-15 10:30
            const formatted = ts.replace('T', ' ').substring(0, 16);
            timestamp.textContent = formatted || 'Live';
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupFade: setupFade,
        updateStats: updateStats
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupHudFade = HUD.setupFade;
window.updateHudStats = HUD.updateStats;

console.log('[Module] HUD loaded - 2 functions');


// ═══ MODULE: modules/dimension.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * DIMENSION MODULE - 2D/3D dimension switching with animation
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles smooth animated transitions between 2D and 3D graph views.
 * Depends on: Graph, IS_3D, DIMENSION_TRANSITION, STARFIELD, STARFIELD_OPACITY,
 *             BLOOM_PASS, BLOOM_STRENGTH, stableSeed, stableZ, fileMode,
 *             GRAPH_MODE, applyFileVizMode
 *
 * @module DIMENSION
 * @version 1.0.0
 */

window.DIMENSION = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // DIMENSION TOGGLE
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Toggle between 2D and 3D dimensions
     */
    function toggle() {
        if (window.DIMENSION_TRANSITION) return;
        window.DIMENSION_TRANSITION = true;

        const target3d = !window.IS_3D;
        const button = document.getElementById('btn-dimensions');

        animateChange(target3d, () => {
            window.IS_3D = target3d;
            window.DIMENSION_TRANSITION = false;
            if (button) button.textContent = window.IS_3D ? '2D' : '3D';

            // Re-apply file viz mode if active
            if (window.fileMode && window.GRAPH_MODE === 'atoms') {
                if (typeof window.applyFileVizMode === 'function') {
                    window.applyFileVizMode();
                }
            }
        });
    }

    /**
     * Setup the dimension toggle button
     */
    function setup() {
        const button = document.getElementById('btn-dimensions');
        if (!button) return;

        const updateLabel = () => {
            button.textContent = window.IS_3D ? '2D' : '3D';
        };
        updateLabel();
        button.onclick = toggle;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ANIMATED TRANSITION
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Animate transition between 2D and 3D
     * @param {boolean} target3d - Whether transitioning to 3D
     * @param {Function} done - Callback when animation completes
     */
    function animateChange(target3d, done) {
        const Graph = window.Graph;
        const STARFIELD = window.STARFIELD;
        const STARFIELD_OPACITY = window.STARFIELD_OPACITY;
        const BLOOM_PASS = window.BLOOM_PASS;
        const BLOOM_STRENGTH = window.BLOOM_STRENGTH;
        const stableSeed = window.stableSeed;
        const stableZ = window.stableZ;

        const nodes = (Graph && Graph.graphData().nodes) ? Graph.graphData().nodes : [];
        const startTime = performance.now();
        const duration = 3000;
        const delayMin = 0;
        const delayMax = 2000;
        const lockPositionsAfterTransition = true;

        const easeInOutSine = (t) => 0.5 - 0.5 * Math.cos(Math.PI * t);

        const starStart = STARFIELD ? STARFIELD.material.opacity : 0;
        const starTarget = target3d ? STARFIELD_OPACITY : 0;
        const bloomStart = BLOOM_PASS ? BLOOM_PASS.strength : 0;
        const bloomTarget = BLOOM_PASS ? (target3d ? BLOOM_STRENGTH : 0) : 0;

        // Store previous simulation settings
        const previousVelocityDecay = (Graph && Graph.d3VelocityDecay) ? Graph.d3VelocityDecay() : null;
        const previousAlphaTarget = (Graph && Graph.d3AlphaTarget) ? Graph.d3AlphaTarget() : null;
        const previousCooldownTicks = (Graph && Graph.cooldownTicks) ? Graph.cooldownTicks() : null;
        const previousCooldownTime = (Graph && Graph.cooldownTime) ? Graph.cooldownTime() : null;

        // Freeze simulation during transition
        if (Graph && Graph.cooldownTicks) Graph.cooldownTicks(Infinity);
        if (Graph && Graph.cooldownTime) Graph.cooldownTime(Infinity);
        if (Graph && Graph.d3VelocityDecay) Graph.d3VelocityDecay(1);
        if (Graph && Graph.d3AlphaTarget) Graph.d3AlphaTarget(0);
        if (Graph && Graph.d3ReheatSimulation) Graph.d3ReheatSimulation();

        // Initialize node animation state
        nodes.forEach((node) => {
            node.__xStart = node.x || 0;
            node.__yStart = node.y || 0;
            node.__zStart = node.z || 0;
            node.__delay = delayMin + (stableSeed(node, 'delay') * (delayMax - delayMin));
            node.fx = node.__xStart;
            node.fy = node.__yStart;
            node.vx = 0;
            node.vy = 0;
            node.vz = 0;

            if (target3d) {
                if (node.__z3d === undefined || node.__z3d === null) {
                    node.__z3d = node.__zStart || stableZ(node);
                }
            } else {
                node.__z3d = node.__zStart;
            }
        });

        const maxDistance = nodes.reduce((acc, node) => Math.max(acc, Math.abs(node.__zStart || 0)), 1);

        Graph.numDimensions(3);

        const animate = (now) => {
            const elapsed = now - startTime;
            const t = Math.min(1, elapsed / duration);
            const eased = easeInOutSine(t);

            // Animate each node's Z position
            nodes.forEach((node) => {
                const startZ = node.__zStart || 0;
                const targetZ = target3d ? (node.__z3d || 0) : 0;
                const delay = node.__delay || 0;
                const localDuration = Math.max(600, duration - delay);
                const localElapsed = Math.max(0, elapsed - delay);
                const localT = Math.min(1, localElapsed / localDuration);
                const localEase = easeInOutSine(localT);
                const distanceRatio = maxDistance > 0 ? Math.abs(startZ) / maxDistance : 0;
                const distanceCurve = 0.6 + (1 - distanceRatio) * 0.6;
                const progress = Math.pow(localEase, distanceCurve);
                const nextZ = startZ + (targetZ - startZ) * progress;
                node.z = nextZ;
                node.fz = nextZ;
                node.vz = 0;
            });

            // Animate starfield and bloom
            if (STARFIELD) {
                const nextOpacity = starStart + (starTarget - starStart) * eased;
                STARFIELD.material.opacity = nextOpacity;
                STARFIELD.visible = nextOpacity > 0.02;
            }
            if (BLOOM_PASS) {
                BLOOM_PASS.strength = bloomStart + (bloomTarget - bloomStart) * eased;
            }

            if (t < 1) {
                requestAnimationFrame(animate);
            } else {
                // Animation complete - clean up
                nodes.forEach((node) => {
                    delete node.fz;
                    delete node.__zStart;
                    delete node.__xStart;
                    delete node.__yStart;
                    delete node.__delay;

                    if (!target3d) {
                        node.z = 0;
                        node.fz = 0;
                    } else if (lockPositionsAfterTransition) {
                        node.z = node.__z3d || node.z || 0;
                        node.fz = node.z;
                    } else {
                        delete node.fx;
                        delete node.fy;
                    }
                });

                Graph.numDimensions(target3d ? 3 : 2);

                if (!target3d && STARFIELD) {
                    STARFIELD.visible = false;
                }

                // Restore simulation settings
                if (Graph && Graph.d3VelocityDecay && previousVelocityDecay !== null) {
                    Graph.d3VelocityDecay(previousVelocityDecay);
                }
                if (Graph && Graph.d3AlphaTarget && previousAlphaTarget !== null) {
                    Graph.d3AlphaTarget(previousAlphaTarget);
                }
                if (Graph && Graph.cooldownTicks && previousCooldownTicks !== null) {
                    Graph.cooldownTicks(previousCooldownTicks);
                }
                if (Graph && Graph.cooldownTime && previousCooldownTime !== null) {
                    Graph.cooldownTime(previousCooldownTime);
                }

                if (done) done();
            }
        };

        requestAnimationFrame(animate);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        toggle: toggle,
        setup: setup,
        animateChange: animateChange
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.toggleDimensions = DIMENSION.toggle;
window.setupDimensionToggle = DIMENSION.setup;
window.animateDimensionChange = DIMENSION.animateChange;

console.log('[Module] DIMENSION loaded - 3 functions');


// ═══ MODULE: modules/report.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * REPORT MODULE - Report panel, AI insights, and metrics display
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles the brain download report, AI insights panel, and metrics/KPI display.
 * Depends on: escapeHtml (from utils.js), DOM elements
 *
 * @module REPORT
 * @version 1.0.0
 */

window.REPORT = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BRAIN DOWNLOAD REPORT
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the brain download report panel
     * @param {Object} data - Data object with brain_download field
     */
    function setupReport(data) {
        const panel = document.getElementById('report-panel');
        const content = document.getElementById('report-content');
        // Guard: elements may not exist in minimal template
        if (!content) return;
        const report = (data && data.brain_download) ? data.brain_download : '';
        content.textContent = report || 'No report available.';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // AI INSIGHTS PANEL
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup the AI insights panel
     * @param {Object} data - Data object with ai_insights field
     */
    function setupAIInsights(data) {
        const escapeHtml = window.escapeHtml || ((s) => String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])));

        const panel = document.getElementById('insights-panel');
        const content = document.getElementById('insights-content');
        const btn = document.getElementById('btn-insights');

        const insights = (data && data.ai_insights) ? data.ai_insights : null;

        if (!insights) {
            // Hide the button if no insights available
            if (btn) btn.style.display = 'none';
            return;
        }

        // Show the button
        if (btn) btn.style.display = 'inline-flex';

        // Render insights
        let html = '';

        // Executive Summary
        if (insights.executive_summary) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Executive Summary</div>
                <div class="insights-summary">${escapeHtml(insights.executive_summary)}</div>
            </div>`;
        }

        // Patterns Detected
        if (insights.patterns_detected && insights.patterns_detected.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Patterns Detected</div>`;
            for (const pattern of insights.patterns_detected) {
                const confidencePercent = Math.round((pattern.confidence || 0) * 100);
                html += `<div class="insights-pattern">
                    <div class="insights-pattern-header">
                        <span class="insights-pattern-name">${escapeHtml(pattern.pattern_name || 'Unknown')}</span>
                        <span class="insights-pattern-type ${pattern.pattern_type || ''}">${escapeHtml(pattern.pattern_type || '')}</span>
                    </div>
                    <div class="insights-confidence">
                        <div class="insights-confidence-bar">
                            <div class="insights-confidence-fill" style="width: ${confidencePercent}%"></div>
                        </div>
                        <span>${confidencePercent}%</span>
                    </div>
                    ${pattern.evidence ? `<div class="insights-pattern-evidence">${escapeHtml(pattern.evidence)}</div>` : ''}
                    ${pattern.recommendation ? `<div class="insights-pattern-evidence" style="color: var(--color-accent-secondary);">Tip: ${escapeHtml(pattern.recommendation)}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Refactoring Opportunities
        if (insights.refactoring_opportunities && insights.refactoring_opportunities.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Refactoring Opportunities</div>`;
            for (const refactor of insights.refactoring_opportunities) {
                html += `<div class="insights-refactor">
                    <div class="insights-refactor-title">
                        ${escapeHtml(refactor.title || 'Untitled')}
                        <span class="insights-refactor-priority ${refactor.priority || 'LOW'}">${refactor.priority || 'LOW'}</span>
                    </div>
                    ${refactor.description ? `<div class="insights-refactor-desc">${escapeHtml(refactor.description)}</div>` : ''}
                    ${refactor.affected_files && refactor.affected_files.length > 0 ?
                        `<div class="insights-refactor-desc" style="margin-top: 4px; color: var(--color-text-muted);">Files: ${refactor.affected_files.slice(0, 3).map(f => escapeHtml(f)).join(', ')}${refactor.affected_files.length > 3 ? '...' : ''}</div>` : ''}
                </div>`;
            }
            html += '</div>';
        }

        // Topology Analysis
        if (insights.topology_analysis) {
            const topo = insights.topology_analysis;
            html += `<div class="insights-section">
                <div class="insights-section-title">Topology Analysis</div>
                ${topo.shape_interpretation ? `<div class="insights-summary">${escapeHtml(topo.shape_interpretation)}</div>` : ''}
                ${topo.health_assessment ? `<div class="insights-pattern-evidence">Health: ${escapeHtml(topo.health_assessment)}</div>` : ''}
                ${topo.coupling_analysis ? `<div class="insights-pattern-evidence">Coupling: ${escapeHtml(topo.coupling_analysis)}</div>` : ''}
            </div>`;
        }

        // Risk Areas
        if (insights.risk_areas && insights.risk_areas.length > 0) {
            html += `<div class="insights-section">
                <div class="insights-section-title">Risk Areas</div>`;
            for (const risk of insights.risk_areas) {
                html += `<div class="insights-risk">
                    <span class="insights-risk-level ${risk.risk_level || 'LOW'}">${risk.risk_level || 'LOW'}</span>
                    <div class="insights-risk-content">
                        <div class="insights-risk-area">${escapeHtml(risk.area || 'Unknown')}</div>
                        ${risk.description ? `<div class="insights-risk-desc">${escapeHtml(risk.description)}</div>` : ''}
                        ${risk.mitigation ? `<div class="insights-risk-desc" style="color: var(--color-accent-secondary); margin-top: 4px;">Tip: ${escapeHtml(risk.mitigation)}</div>` : ''}
                    </div>
                </div>`;
            }
            html += '</div>';
        }

        // Meta information
        if (insights.meta) {
            const meta = insights.meta;
            html += `<div class="insights-meta">
                Generated: ${meta.generated_at ? new Date(meta.generated_at).toLocaleString() : 'Unknown'}
                | Model: ${escapeHtml(meta.model || 'Unknown')}
                ${meta.confidence ? ` | Confidence: ${Math.round(meta.confidence * 100)}%` : ''}
            </div>`;
        }

        content.innerHTML = html || '<div class="insights-placeholder">No insights data available.</div>';
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METRICS / KPI DISPLAY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup metrics and health indicators
     * @param {Object} data - Data object with kpis field
     */
    function setupMetrics(data) {
        const kpis = (data && data.kpis) ? data.kpis : {};

        const setText = (id, value) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = value;
        };

        const asNumber = (val) => {
            const num = Number(val);
            return Number.isFinite(num) ? num : null;
        };

        const formatPercent = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}%`;
        };

        const formatCount = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${Math.round(num)}`;
        };

        const formatScore = (val) => {
            const num = asNumber(val);
            return num === null ? '--' : `${num.toFixed(1)}/10`;
        };

        // Set metric values
        setText('metric-edge-resolution', formatPercent(kpis.edge_resolution_percent));
        setText('metric-call-ratio', formatPercent(kpis.call_ratio_percent));
        setText('metric-reachability', formatPercent(kpis.reachability_percent));
        setText('metric-dead-code', formatPercent(kpis.dead_code_percent));
        setText('metric-knot-score', formatScore(kpis.knot_score));
        setText('metric-topology', kpis.topology_shape || 'UNKNOWN');
        setText('metric-orphans', formatCount(kpis.orphan_count));
        setText('metric-top-hubs', formatCount(kpis.top_hub_count));

        // Set health indicators (traffic light bars)
        const setHealth = (id, level) => {
            const el = document.getElementById(id);
            if (el) {
                el.classList.remove('good', 'medium', 'bad', 'neutral');
                el.classList.add(level);
            }
        };

        // Edge Resolution: >90% good, 70-90% medium, <70% bad
        const edgeRes = asNumber(kpis.edge_resolution_percent);
        setHealth('health-edge-resolution', edgeRes === null ? 'neutral' : edgeRes >= 90 ? 'good' : edgeRes >= 70 ? 'medium' : 'bad');

        // Call Ratio: >60% good, 40-60% medium, <40% bad
        const callRatio = asNumber(kpis.call_ratio_percent);
        setHealth('health-call-ratio', callRatio === null ? 'neutral' : callRatio >= 60 ? 'good' : callRatio >= 40 ? 'medium' : 'bad');

        // Reachability: >90% good, 70-90% medium, <70% bad
        const reach = asNumber(kpis.reachability_percent);
        setHealth('health-reachability', reach === null ? 'neutral' : reach >= 90 ? 'good' : reach >= 70 ? 'medium' : 'bad');

        // Dead Code: <5% good, 5-15% medium, >15% bad (INVERTED - lower is better)
        const dead = asNumber(kpis.dead_code_percent);
        setHealth('health-dead-code', dead === null ? 'neutral' : dead <= 5 ? 'good' : dead <= 15 ? 'medium' : 'bad');

        // Knot Score: <3 good, 3-6 medium, >6 bad (INVERTED - lower is better)
        const knot = asNumber(kpis.knot_score);
        setHealth('health-knot-score', knot === null ? 'neutral' : knot <= 3 ? 'good' : knot <= 6 ? 'medium' : 'bad');

        // Topology: neutral (informational only)
        setHealth('health-topology', 'neutral');

        // Orphans: <10 good, 10-50 medium, >50 bad (INVERTED - lower is better)
        const orphans = asNumber(kpis.orphan_count);
        setHealth('health-orphans', orphans === null ? 'neutral' : orphans <= 10 ? 'good' : orphans <= 50 ? 'medium' : 'bad');

        // Top Hubs: neutral (informational only)
        setHealth('health-top-hubs', 'neutral');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        setupReport: setupReport,
        setupAIInsights: setupAIInsights,
        setupMetrics: setupMetrics
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setupReport = REPORT.setupReport;
window.setupAIInsights = REPORT.setupAIInsights;
window.setupMetrics = REPORT.setupMetrics;

console.log('[Module] REPORT loaded - 3 functions');


// ═══ MODULE: modules/visibility.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * VISIBILITY MODULE - UI visibility controls and filter utilities
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles background brightness, metadata visibility, filter clearing,
 * and collapsible section management.
 * Depends on: Graph, APPEARANCE_STATE, VIS_FILTERS, THREE
 *
 * @module VISIBILITY
 * @version 1.0.0
 */

window.VISIBILITY = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // BACKGROUND CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Update background brightness based on APPEARANCE_STATE
     */
    function updateBackgroundBrightness() {
        const Graph = window.Graph;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const THREE = window.THREE;

        if (!Graph || !APPEARANCE_STATE.backgroundBase) return;
        const baseColor = new THREE.Color(APPEARANCE_STATE.backgroundBase);
        const brightness = APPEARANCE_STATE.backgroundBrightness ?? 1;
        const adjusted = baseColor.clone().multiplyScalar(brightness);
        Graph.backgroundColor(`#${adjusted.getHexString()}`);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // METADATA VISIBILITY
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Apply metadata visibility settings (report panel, file panel, etc.)
     */
    function applyMetadataVisibility() {
        const VIS_FILTERS = window.VIS_FILTERS;

        const reportPanel = document.getElementById('report-panel');
        const reportButton = document.getElementById('btn-report');
        const filePanel = document.getElementById('file-panel');

        // Guard: elements may not exist in minimal template
        if (!reportPanel && !reportButton) return;

        if (!VIS_FILTERS.metadata.showReportPanel) {
            if (reportPanel) reportPanel.style.display = 'none';
            if (reportButton) {
                reportButton.classList.remove('active');
                reportButton.style.display = 'none';
            }
        } else {
            if (reportButton) reportButton.style.display = 'inline-flex';
        }
        if (!VIS_FILTERS.metadata.showFilePanel && filePanel) {
            filePanel.classList.remove('visible');
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FILTER CONTROLS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Clear all dimension filters (tier, ring, family, role, file, edge)
     * Used for zero-node recovery and manual reset
     */
    function clearAllFilters() {
        const VIS_FILTERS = window.VIS_FILTERS;

        VIS_FILTERS.tiers.clear();
        VIS_FILTERS.rings.clear();
        VIS_FILTERS.families.clear();
        VIS_FILTERS.roles.clear();
        VIS_FILTERS.files.clear();
        VIS_FILTERS.edges.clear();
        VIS_FILTERS.layers.clear();
        VIS_FILTERS.effects.clear();
        VIS_FILTERS.edgeFamilies.clear();

        // Update legend UI
        document.querySelectorAll('.topo-legend-item.filtered').forEach(el => el.classList.remove('filtered'));

        // Update chip UI
        document.querySelectorAll('.filter-chip.active').forEach(el => el.classList.remove('active'));

        console.log('[Filters] All filters cleared');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // COLLAPSIBLE SECTIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Setup collapsible sections in sidebar and panels
     */
    function setupCollapsibleSections() {
        // Standard sidebar sections
        const titles = document.querySelectorAll('.side-title.collapsible');
        titles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('collapsed', isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });

        // Topology section collapsibles (GEOMETRY panel)
        const topoTitles = document.querySelectorAll('.topo-section-title.collapsible');
        topoTitles.forEach(title => {
            title.onclick = () => {
                const targetId = title.dataset.target;
                const content = document.getElementById(targetId);
                const icon = title.querySelector('.collapse-icon');
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    title.classList.toggle('expanded', !isCollapsed);
                    if (icon) icon.textContent = isCollapsed ? '>' : 'v';
                }
            };
        });
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        updateBackgroundBrightness: updateBackgroundBrightness,
        applyMetadataVisibility: applyMetadataVisibility,
        clearAllFilters: clearAllFilters,
        setupCollapsibleSections: setupCollapsibleSections
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.updateBackgroundBrightness = VISIBILITY.updateBackgroundBrightness;
window.applyMetadataVisibility = VISIBILITY.applyMetadataVisibility;
window.clearAllFilters = VISIBILITY.clearAllFilters;
window.setupCollapsibleSections = VISIBILITY.setupCollapsibleSections;

console.log('[Module] VISIBILITY loaded - 4 functions');


// ═══ MODULE: modules/animation.js ═══
/**
 * ANIMATION MODULE
 *
 * Unified animation controller for all layout transitions and continuous motions.
 * Addresses ARCH-002 (O(n^2) flock), ARCH-003 (unthrottled refresh), ARCH-004 (conflicts).
 *
 * Key improvements:
 * - Single animation ownership prevents conflicts
 * - Spatial hashing reduces flock from O(n^2) to O(n)
 * - Integration with REFRESH module for throttled updates
 *
 * Usage:
 *   ANIM.applyLayout('orbital')           // Apply a layout preset
 *   ANIM.stop()                           // Stop all animations
 *   ANIM.setStaggerPattern('radial')      // Change wave pattern
 */

const ANIM = (function() {
    'use strict';

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    const CONFIG = {
        baseDuration: 1200,      // Base animation duration (ms)
        staggerSpread: 800,      // Stagger spread (ms)
        flockMaxNodes: 500,      // Max nodes for flock simulation
        spatialGridSize: 50,     // Grid cell size for spatial hashing
        motionFrameSkip: 0       // Skip frames for motion (0 = no skip)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _currentLayout = 'force';
    let _animationId = null;
    let _layoutTime = 0;
    let _currentStaggerPattern = 'tier';
    let _owner = 'none';  // Current animation owner

    // =========================================================================
    // STAGGER PATTERNS - Wave-based node transitions
    // =========================================================================

    const STAGGER_PATTERNS = {
        // Radial ripple: center nodes move first, ripples outward
        radial: (node, startPos, targetPos) => {
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2 + startPos.z ** 2);
            return Math.min(1, dist / 500);
        },
        // Tier cascade: T0 first, then T1, then T2
        tier: (node) => {
            const tier = NODE.getTier(node);
            const tierNum = tier === 'T0' ? 0 : tier === 'T1' ? 1 : 2;
            return tierNum / 2;
        },
        // Distance-based: shortest travel first
        distance: (node, startPos, targetPos) => {
            const dx = targetPos.x - startPos.x;
            const dy = targetPos.y - startPos.y;
            const dz = targetPos.z - startPos.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            return Math.min(1, dist / 400);
        },
        // File grouping: nodes in same file move together
        file: (node) => {
            const fileIdx = node.fileIdx ?? 0;
            return (fileIdx % 8) / 8;
        },
        // Spiral pattern
        spiral: (node, startPos) => {
            const angle = Math.atan2(startPos.y, startPos.x);
            const dist = Math.sqrt(startPos.x ** 2 + startPos.y ** 2);
            return ((angle + Math.PI) / (2 * Math.PI) + dist / 1000) % 1;
        },
        // Random stagger
        random: () => Math.random() * 0.6
    };

    // =========================================================================
    // LAYOUT PRESETS
    // =========================================================================

    const LAYOUT_PRESETS = {
        'force': {
            name: 'FORCE', icon: '?', description: 'Physics-based clustering',
            motion: 'settle', cooldown: 300, warmupTicks: 40, getPosition: null
        },
        'orbital': {
            name: 'ORBITAL', icon: '?', description: 'Planetary orbit bands',
            motion: 'orbit', cooldown: Infinity, orbitSpeed: 0.002,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const r = { T0: 80, T1: 160, T2: 280, UNKNOWN: 200 }[tier] || 200;
                const fOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const angle = (fOff / 5) * Math.PI * 2 + (idx / Math.max(1, total)) * Math.PI * 0.3 + (time || 0) * (0.5 + r * 0.001);
                const wobble = Math.sin(idx * 0.7 + (time || 0) * 2) * 15;
                return {
                    x: Math.cos(angle) * (r + wobble),
                    y: Math.sin(idx * 0.3) * 40 + (tier === 'T0' ? -50 : tier === 'T2' ? 50 : 0),
                    z: Math.sin(angle) * (r + wobble)
                };
            }
        },
        'radial': {
            name: 'RADIAL', icon: '?', description: 'Concentric tier rings',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total, time, tierGroups) => {
                const tier = NODE.getTier(node);
                const r = { T0: 60, T1: 150, T2: 280, UNKNOWN: 220 }[tier] || 180;
                const tierNodes = tierGroups?.[tier] || [];
                const tierIdx = tierNodes.indexOf(node);
                const tierTotal = tierNodes.length || 1;
                const angle = (tierIdx / tierTotal) * Math.PI * 2;
                return { x: Math.cos(angle) * r, y: 0, z: Math.sin(angle) * r };
            }
        },
        'spiral': {
            name: 'SPIRAL', icon: '?', description: 'DNA-like helix',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.003,
            getPosition: (node, idx, total, time) => {
                const t = idx / Math.max(1, total);
                const angle = t * Math.PI * 2 * 4 + (time || 0);
                const r = 100 + t * 150;
                return { x: Math.cos(angle) * r, y: (t - 0.5) * 400, z: Math.sin(angle) * r };
            }
        },
        'sphere': {
            name: 'SPHERE', icon: '?', description: 'Globe surface',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const latBase = { T0: 0.8, T1: 0.5, T2: 0.2, UNKNOWN: 0.5 }[tier] || 0.5;
                const lat = (latBase + (idx % 10) * 0.02) * Math.PI;
                const lonBase = { LOG: 0, DAT: 72, ORG: 144, EXE: 216, EXT: 288, UNKNOWN: 180 }[family] || 0;
                const lon = ((lonBase + idx * 3) % 360) * Math.PI / 180 + (time || 0);
                const r = 200;
                return {
                    x: Math.sin(lat) * Math.cos(lon) * r,
                    y: Math.cos(lat) * r,
                    z: Math.sin(lat) * Math.sin(lon) * r
                };
            }
        },
        'grid': {
            name: 'GRID', icon: '?', description: '3D lattice',
            motion: 'static', cooldown: 0,
            getPosition: (node, idx, total) => {
                const tier = NODE.getTier(node);
                const family = NODE.getFamily(node);
                const tierX = { T0: -150, T1: 0, T2: 150, UNKNOWN: 0 }[tier] || 0;
                const famZ = { LOG: -120, DAT: -60, ORG: 0, EXE: 60, EXT: 120, UNKNOWN: 0 }[family] || 0;
                const row = Math.floor(idx / 15);
                const col = idx % 15;
                return { x: tierX + (col - 7) * 20, y: row * 25 - 100, z: famZ + Math.sin(idx * 0.5) * 20 };
            }
        },
        'flock': {
            name: 'FLOCK', icon: '?', description: 'Swarming birds',
            motion: 'flock', cooldown: Infinity,
            flockParams: { separation: 25, alignment: 0.05, cohesion: 0.01, maxSpeed: 2 },
            getPosition: null
        },
        'galaxy': {
            name: 'GALAXY', icon: '?', description: 'Spiral arms',
            motion: 'rotate', cooldown: Infinity, rotateSpeed: 0.001,
            getPosition: (node, idx, total, time) => {
                const family = NODE.getFamily(node);
                const tier = NODE.getTier(node);
                const armOff = { LOG: 0, DAT: 1, ORG: 2, EXE: 3, EXT: 4, UNKNOWN: 2.5 }[family] || 0;
                const baseAngle = (armOff / 5) * Math.PI * 2;
                const dist = 50 + (idx / total) * 250;
                const spiralAngle = baseAngle + dist * 0.015 + (time || 0);
                const tierY = { T0: -30, T1: 0, T2: 30, UNKNOWN: 0 }[tier] || 0;
                return {
                    x: Math.cos(spiralAngle) * dist,
                    y: tierY + Math.sin(idx * 0.5) * 20,
                    z: Math.sin(spiralAngle) * dist
                };
            }
        }
    };

    // =========================================================================
    // SPATIAL HASHING - O(n) neighbor lookup for flock simulation
    // =========================================================================

    function _buildSpatialGrid(nodes, cellSize) {
        const grid = new Map();

        nodes.forEach((node, idx) => {
            const x = node.x || 0;
            const y = node.y || 0;
            const z = node.z || 0;

            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const cellZ = Math.floor(z / cellSize);
            const key = `${cellX},${cellY},${cellZ}`;

            if (!grid.has(key)) {
                grid.set(key, []);
            }
            grid.get(key).push({ node, idx });
        });

        return grid;
    }

    function _getNeighborsFromGrid(grid, node, cellSize, radius) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);

        const neighbors = [];
        const cellRadius = Math.ceil(radius / cellSize);

        // Check neighboring cells
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                for (let dz = -cellRadius; dz <= cellRadius; dz++) {
                    const key = `${cellX + dx},${cellY + dy},${cellZ + dz}`;
                    const cell = grid.get(key);
                    if (cell) {
                        cell.forEach(entry => {
                            if (entry.node !== node) {
                                neighbors.push(entry.node);
                            }
                        });
                    }
                }
            }
        }

        return neighbors;
    }

    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================

    function _groupNodesByTier(nodes) {
        const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
        nodes.forEach(n => {
            const tier = NODE.getTier(n);
            (groups[tier] || groups.UNKNOWN).push(n);
        });
        return groups;
    }

    function _acquireOwnership(owner) {
        // Cancel any existing animation
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = owner;
        return true;
    }

    function _releaseOwnership(owner) {
        if (_owner === owner) {
            if (_animationId) {
                cancelAnimationFrame(_animationId);
                _animationId = null;
            }
            _owner = 'none';
        }
    }

    // =========================================================================
    // LAYOUT APPLICATION
    // =========================================================================

    function applyLayout(presetKey, animate = true) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset) return;

        _currentLayout = presetKey;
        _acquireOwnership('layout');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);

        // Handle force layout specially
        if (presetKey === 'force') {
            nodes.forEach(n => {
                n.fx = undefined;
                n.fy = undefined;
                n.fz = undefined;
            });
            Graph.cooldownTicks(preset.cooldown);
            Graph.d3ReheatSimulation();
            _releaseOwnership('layout');
            if (typeof showModeToast === 'function') {
                showModeToast('? FORCE layout');
            }
            return;
        }

        // Handle flock specially
        if (preset.motion === 'flock') {
            _startFlockSimulation(preset.flockParams);
            Graph.cooldownTicks(preset.cooldown);
            if (typeof showModeToast === 'function') {
                showModeToast(`${preset.icon} ${preset.name} layout`);
            }
            return;
        }

        // Position-based layouts
        if (preset.getPosition) {
            const startPos = nodes.map(n => ({ x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
            const targetPos = nodes.map((n, i) => preset.getPosition(n, i, total, 0, tierGroups));

            if (animate && total > 100) {
                // STAGGERED ANIMATION for large graphs
                _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey);
            } else if (animate) {
                // SIMPLE ANIMATION for small graphs
                _animateSimple(nodes, startPos, targetPos, preset, presetKey);
            } else {
                // INSTANT
                nodes.forEach((n, i) => {
                    const p = targetPos[i];
                    n.fx = p.x;
                    n.fy = p.y;
                    n.fz = p.z;
                });
                if (typeof REFRESH !== 'undefined') {
                    REFRESH.force();
                } else if (Graph) {
                    Graph.refresh();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                }
            }
        }

        Graph.cooldownTicks(preset.cooldown);
        if (typeof showModeToast === 'function') {
            showModeToast(`${preset.icon} ${preset.name} layout`);
        }
    }

    function _animateStaggered(nodes, startPos, targetPos, preset, tierGroups, presetKey) {
        const baseDuration = CONFIG.baseDuration;
        const staggerSpread = CONFIG.staggerSpread;
        const startTime = Date.now();

        // Hide edges during animation for performance
        Graph.linkOpacity(0);

        // Calculate delay for each node
        const pattern = STAGGER_PATTERNS[_currentStaggerPattern] || STAGGER_PATTERNS.tier;
        const delays = nodes.map((n, i) => pattern(n, startPos[i], targetPos[i]) * staggerSpread);

        function animateFrame() {
            if (_owner !== 'layout') return;

            const elapsed = Date.now() - startTime;

            nodes.forEach((n, i) => {
                const nodeStart = delays[i];
                const nodeElapsed = elapsed - nodeStart;

                if (nodeElapsed <= 0) {
                    n.fx = startPos[i].x;
                    n.fy = startPos[i].y;
                    n.fz = startPos[i].z;
                } else if (nodeElapsed >= baseDuration) {
                    n.fx = targetPos[i].x;
                    n.fy = targetPos[i].y;
                    n.fz = targetPos[i].z;
                } else {
                    const progress = nodeElapsed / baseDuration;
                    const eased = progress * progress * (3 - 2 * progress);
                    n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                    n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                    n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
                }
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                Graph.refresh();
            }

            const totalDuration = baseDuration + staggerSpread;
            if (elapsed < totalDuration) {
                _animationId = requestAnimationFrame(animateFrame);
            } else {
                // Restore edges
                if (typeof applyEdgeMode === 'function') {
                    applyEdgeMode();
                }
                if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                    _startLayoutMotion(presetKey);
                } else {
                    _releaseOwnership('layout');
                }
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _animateSimple(nodes, startPos, targetPos, preset, presetKey) {
        const duration = 1500;
        const startTime = Date.now();

        function animateFrame() {
            if (_owner !== 'layout') return;

            const progress = Math.min(1, (Date.now() - startTime) / duration);
            const eased = progress * progress * (3 - 2 * progress);

            nodes.forEach((n, i) => {
                n.fx = startPos[i].x + (targetPos[i].x - startPos[i].x) * eased;
                n.fy = startPos[i].y + (targetPos[i].y - startPos[i].y) * eased;
                n.fz = startPos[i].z + (targetPos[i].z - startPos[i].z) * eased;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                Graph.refresh();
            }

            if (progress < 1) {
                _animationId = requestAnimationFrame(animateFrame);
            } else if (preset.motion === 'rotate' || preset.motion === 'orbit') {
                _startLayoutMotion(presetKey);
            } else {
                _releaseOwnership('layout');
            }
        }

        _animationId = requestAnimationFrame(animateFrame);
    }

    function _startLayoutMotion(presetKey) {
        const preset = LAYOUT_PRESETS[presetKey];
        if (!preset || !preset.getPosition) return;

        _acquireOwnership('motion');

        const nodes = Graph?.graphData()?.nodes || [];
        const total = nodes.length;
        const tierGroups = _groupNodesByTier(nodes);
        const speed = preset.rotateSpeed || preset.orbitSpeed || 0.002;

        function animate() {
            if (_owner !== 'motion') return;

            _layoutTime += speed;

            nodes.forEach((n, i) => {
                const pos = preset.getPosition(n, i, total, _layoutTime, tierGroups);
                n.fx = pos.x;
                n.fy = pos.y;
                n.fz = pos.z;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                Graph.refresh();
            }

            _animationId = requestAnimationFrame(animate);
        }

        _animationId = requestAnimationFrame(animate);
    }

    // =========================================================================
    // FLOCK SIMULATION - O(n) with spatial hashing
    // =========================================================================

    function _startFlockSimulation(params) {
        const nodes = Graph?.graphData()?.nodes || [];

        // Performance guard
        if (nodes.length > CONFIG.flockMaxNodes) {
            console.warn(`[ANIM] Flock disabled: ${nodes.length} nodes exceeds ${CONFIG.flockMaxNodes} limit`);
            if (typeof showModeToast === 'function') {
                showModeToast('Warning: Flock disabled (too many nodes)');
            }
            return;
        }

        _acquireOwnership('flock');

        const { separation, alignment, cohesion, maxSpeed } = params;

        // Initialize velocities
        nodes.forEach(n => {
            n._vx = (Math.random() - 0.5) * 2;
            n._vy = (Math.random() - 0.5) * 2;
            n._vz = (Math.random() - 0.5) * 2;
        });

        function flockStep() {
            if (_owner !== 'flock') return;

            // Build spatial grid for O(n) neighbor lookup
            const grid = _buildSpatialGrid(nodes, CONFIG.spatialGridSize);
            const neighborRadius = separation * 3;

            nodes.forEach(n => {
                // Get nearby neighbors from spatial grid (O(1) per node)
                const neighbors = _getNeighborsFromGrid(grid, n, CONFIG.spatialGridSize, neighborRadius);

                let sepX = 0, sepY = 0, sepZ = 0, sepCount = 0;
                let alignX = 0, alignY = 0, alignZ = 0, alignCount = 0;
                let cohX = 0, cohY = 0, cohZ = 0, cohCount = 0;

                const myFamily = NODE.getFamily(n);

                neighbors.forEach(other => {
                    const dx = (other.x || 0) - (n.x || 0);
                    const dy = (other.y || 0) - (n.y || 0);
                    const dz = (other.z || 0) - (n.z || 0);
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) || 0.001;

                    // Separation
                    if (dist < separation * 2) {
                        sepX -= dx / dist;
                        sepY -= dy / dist;
                        sepZ -= dz / dist;
                        sepCount++;
                    }

                    // Alignment and cohesion (same family only)
                    if (NODE.getFamily(other) === myFamily && dist < 150) {
                        alignX += other._vx || 0;
                        alignY += other._vy || 0;
                        alignZ += other._vz || 0;
                        alignCount++;

                        cohX += other.x || 0;
                        cohY += other.y || 0;
                        cohZ += other.z || 0;
                        cohCount++;
                    }
                });

                // Apply forces
                if (sepCount > 0) {
                    n._vx += (sepX / sepCount) * separation * 0.05;
                    n._vy += (sepY / sepCount) * separation * 0.05;
                    n._vz += (sepZ / sepCount) * separation * 0.05;
                }
                if (alignCount > 0) {
                    n._vx += ((alignX / alignCount) - n._vx) * alignment;
                    n._vy += ((alignY / alignCount) - n._vy) * alignment;
                    n._vz += ((alignZ / alignCount) - n._vz) * alignment;
                }
                if (cohCount > 0) {
                    n._vx += (cohX / cohCount - (n.x || 0)) * cohesion;
                    n._vy += (cohY / cohCount - (n.y || 0)) * cohesion;
                    n._vz += (cohZ / cohCount - (n.z || 0)) * cohesion;
                }

                // Center attraction
                n._vx -= (n.x || 0) * 0.0005;
                n._vy -= (n.y || 0) * 0.0005;
                n._vz -= (n.z || 0) * 0.0005;

                // Speed limit
                const speed = Math.sqrt(n._vx * n._vx + n._vy * n._vy + n._vz * n._vz);
                if (speed > maxSpeed) {
                    n._vx = (n._vx / speed) * maxSpeed;
                    n._vy = (n._vy / speed) * maxSpeed;
                    n._vz = (n._vz / speed) * maxSpeed;
                }

                // Update position
                n.fx = (n.x || 0) + n._vx;
                n.fy = (n.y || 0) + n._vy;
                n.fz = (n.z || 0) + n._vz;
            });

            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (Graph) {
                Graph.refresh();
            }

            _animationId = requestAnimationFrame(flockStep);
        }

        _animationId = requestAnimationFrame(flockStep);
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    function stop() {
        if (_animationId) {
            cancelAnimationFrame(_animationId);
            _animationId = null;
        }
        _owner = 'none';
    }

    function setStaggerPattern(pattern) {
        if (STAGGER_PATTERNS[pattern]) {
            _currentStaggerPattern = pattern;
            if (typeof showModeToast === 'function') {
                showModeToast(`Wave pattern: ${pattern.toUpperCase()}`);
            }
        }
    }

    function cycleStaggerPattern() {
        const patterns = Object.keys(STAGGER_PATTERNS);
        const currentIdx = patterns.indexOf(_currentStaggerPattern);
        _currentStaggerPattern = patterns[(currentIdx + 1) % patterns.length];
        if (typeof showModeToast === 'function') {
            showModeToast(`Wave pattern: ${_currentStaggerPattern.toUpperCase()}`);
        }
        return _currentStaggerPattern;
    }

    return {
        // Layout control
        applyLayout,
        stop,

        // Stagger patterns
        setStaggerPattern,
        cycleStaggerPattern,
        get staggerPattern() { return _currentStaggerPattern; },
        get staggerPatterns() { return Object.keys(STAGGER_PATTERNS); },

        // State
        get currentLayout() { return _currentLayout; },
        get isAnimating() { return _animationId !== null; },
        get owner() { return _owner; },

        // Layout presets
        presets: LAYOUT_PRESETS,

        // Config
        config: CONFIG
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// Note: CURRENT_LAYOUT, LAYOUT_ANIMATION_ID, LAYOUT_TIME, CURRENT_STAGGER_PATTERN
// are managed by app.js (separate animation system) - not duplicated here
Object.defineProperty(window, 'LAYOUT_PRESETS', { get: () => ANIM.presets, configurable: true });
Object.defineProperty(window, 'STAGGER_PATTERNS', { get: () => ANIM.staggerPatterns, configurable: true });

function applyLayoutPreset(presetKey, animate) {
    ANIM.applyLayout(presetKey, animate);
}

function cycleStaggerPattern() {
    ANIM.cycleStaggerPattern();
}

function startFlockSimulation(params) {
    // Handled internally by ANIM
    ANIM.applyLayout('flock');
}

function groupNodesByTier(nodes) {
    const groups = { T0: [], T1: [], T2: [], UNKNOWN: [] };
    nodes.forEach(n => {
        const tier = NODE.getTier(n);
        (groups[tier] || groups.UNKNOWN).push(n);
    });
    return groups;
}


// ═══ MODULE: modules/selection.js ═══
/**
 * SELECTION MODULE
 *
 * Manages node selection, multi-select, marquee selection, and selection visuals.
 * Includes animated selection colors using OKLCH pendulum system.
 *
 * Depends on: CORE (PENDULUM, SELECTION_SIZE_MULT), NODE, COLOR
 *
 * Usage:
 *   SELECT.set([id1, id2])              // Set selection
 *   SELECT.toggle(node)                 // Toggle node selection
 *   SELECT.clear()                      // Clear selection
 *   SELECT.getSelectedNodes()           // Get selected node objects
 *   SELECT.ids                          // Get Set of selected IDs
 */

const SELECT = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    const _ids = new Set();
    let _marqueeActive = false;
    let _marqueeStart = null;
    let _marqueeAdditive = false;
    let _lastMarqueeEndTs = 0;

    // Selection visuals state
    const _selectionOriginals = new Map();
    const _originalColorsForDim = new Map();

    // THREE.js geometries (created lazily)
    let _selectionHaloGeometry = null;
    let _groupHaloGeometry = null;

    // =========================================================================
    // CORE SELECTION FUNCTIONS
    // =========================================================================

    /**
     * Get currently selected nodes
     */
    function getSelectedNodes() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return [];
        const nodes = Graph.graphData().nodes || [];
        return nodes.filter(node => node && node.id && _ids.has(node.id));
    }

    /**
     * Set selection (optionally additive)
     */
    function set(ids, additive = false) {
        if (!additive) {
            _ids.clear();
        }
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        // Use app.js's updateSelectionVisuals if available (has group halo logic)
        // Otherwise fall back to internal _updateVisuals
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Toggle a node's selection state
     */
    function toggle(node) {
        if (!node || !node.id) return;
        if (_ids.has(node.id)) {
            _ids.delete(node.id);
        } else {
            _ids.add(node.id);
        }
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Clear all selection
     */
    function clear() {
        _ids.clear();
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Maybe clear selection (with marquee debounce)
     */
    function maybeClear() {
        const now = Date.now();
        if (_marqueeActive) return;
        if (now - _lastMarqueeEndTs < 250) return;
        clear();
    }

    /**
     * Add nodes to selection
     */
    function add(ids) {
        (ids || []).forEach(id => {
            if (id) _ids.add(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    /**
     * Remove nodes from selection
     */
    function remove(ids) {
        (ids || []).forEach(id => {
            _ids.delete(id);
        });
        _updatePanel();
        if (typeof window.updateSelectionVisuals === 'function') {
            window.updateSelectionVisuals();
        } else {
            _updateVisuals();
        }
        _updateGroupButtonState();
    }

    // =========================================================================
    // OKLCH COLOR UTILITIES
    // =========================================================================

    function _oklchToHex(L, C, H) {
        const hRad = H * Math.PI / 180;
        const a = C * Math.cos(hRad);
        const b = C * Math.sin(hRad);

        const l_ = L / 100 + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L / 100 - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L / 100 - 0.0894841775 * a - 1.2914855480 * b;

        const l = l_ * l_ * l_;
        const m = m_ * m_ * m_;
        const s = s_ * s_ * s_;

        let rLin = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
        let gLin = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
        let bLin = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

        const gamma = x => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;

        let rOut = Math.round(gamma(rLin) * 255);
        let gOut = Math.round(gamma(gLin) * 255);
        let bOut = Math.round(gamma(bLin) * 255);

        rOut = Math.max(0, Math.min(255, rOut));
        gOut = Math.max(0, Math.min(255, gOut));
        bOut = Math.max(0, Math.min(255, bOut));

        return '#' + [rOut, gOut, bOut].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function _dimColor(hexColor, factor = 0.33) {
        const hex = hexColor.replace('#', '');
        const r = Math.round(parseInt(hex.substr(0, 2), 16) * (1 - factor));
        const g = Math.round(parseInt(hex.substr(2, 2), 16) * (1 - factor));
        const b = Math.round(parseInt(hex.substr(4, 2), 16) * (1 - factor));
        return '#' + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join('');
    }

    // =========================================================================
    // PENDULUM ANIMATION
    // =========================================================================

    function _updatePendulums(dt) {
        const PENDULUM = CORE.PENDULUM;
        const p1 = PENDULUM.hue;
        const p2 = PENDULUM.chroma;

        // Pendulum 1: Modulates hue rotation speed
        const accel1 = -(p1.gravity / p1.length) * Math.sin(p1.angle);
        p1.velocity += accel1 * dt;
        p1.velocity *= p1.damping;
        p1.angle += p1.velocity * dt;

        // Continuous hue rotation
        const speedMod = 1 + Math.sin(p1.angle) * 0.5;
        PENDULUM.currentHue = (PENDULUM.currentHue + p1.rotationSpeed * speedMod * (dt / 16)) % 360;

        // Pendulum 2: Chroma with coupling
        const coupling = 0.00015 * Math.sin(p1.angle);
        const accel2 = -(p2.gravity / p2.length) * Math.sin(p2.angle) + coupling;
        p2.velocity += accel2 * dt;
        p2.velocity *= p2.damping;
        p2.angle += p2.velocity * dt;

        // Lightness phase
        PENDULUM.lightness.phase += PENDULUM.lightness.speed * dt;
    }

    function _getSelectionColor(phaseOffset = 0) {
        const PENDULUM = CORE.PENDULUM;
        const p2 = PENDULUM.chroma;
        const p3 = PENDULUM.lightness;

        const H = (PENDULUM.currentHue + phaseOffset * 45) % 360;
        const C = Math.max(0.18, p2.center + Math.sin(p2.angle + phaseOffset * Math.PI * 2) * p2.amplitude);
        const L = p3.center + Math.sin(p3.phase + phaseOffset * Math.PI * 4) * p3.amplitude;

        return _oklchToHex(L, C, H);
    }

    function _getNodeSpatialPhase(node) {
        const x = node.x || 0;
        const y = node.y || 0;
        const z = node.z || 0;

        const distance = Math.sqrt(x * x + y * y + z * z);
        const PENDULUM = CORE.PENDULUM;
        const scale = PENDULUM.ripple ? (PENDULUM.ripple.scale || 200) : 200;
        const ripplePhase = (distance / scale) % 1;

        const angle = Math.atan2(y, x);
        const angularOffset = Math.sin(angle * 3) * 0.1;

        return (ripplePhase + angularOffset + 1) % 1;
    }

    function _animateSelectionColors(timestamp) {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) return;

        const dt = PENDULUM.lastTime ? Math.min(timestamp - PENDULUM.lastTime, 50) : 16;
        PENDULUM.lastTime = timestamp;

        _updatePendulums(dt);

        if (_ids.size > 0 && typeof Graph !== 'undefined' && Graph?.graphData) {
            const nodes = Graph.graphData().nodes || [];

            nodes.forEach(node => {
                if (_ids.has(node.id)) {
                    const spatialPhase = _getNodeSpatialPhase(node);
                    node.color = _getSelectionColor(spatialPhase);
                }
            });

            if (typeof toColorNumber === 'function') {
                Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
            }
        }

        requestAnimationFrame(_animateSelectionColors);
    }

    function startAnimation() {
        const PENDULUM = CORE.PENDULUM;
        if (!PENDULUM.running) {
            PENDULUM.running = true;
            PENDULUM.hue.velocity = 0.02 + Math.random() * 0.01;
            PENDULUM.chroma.velocity = 0.015 + Math.random() * 0.01;
            PENDULUM.lastTime = 0;
            requestAnimationFrame(_animateSelectionColors);
        }
    }

    function stopAnimation() {
        CORE.PENDULUM.running = false;
    }

    // =========================================================================
    // VISUAL UPDATES
    // =========================================================================

    function _updateVisuals() {
        if (typeof Graph === 'undefined' || !Graph?.graphData) return;

        const nodes = Graph.graphData().nodes || [];
        const hasSelection = _ids.size > 0;
        const SELECTION_SIZE_MULT = CORE.SELECTION_SIZE_MULT;

        nodes.forEach(node => {
            const isSelected = _ids.has(node.id);

            // Save original for restoration
            if (hasSelection && !_originalColorsForDim.has(node.id)) {
                _originalColorsForDim.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            if (isSelected && !_selectionOriginals.has(node.id)) {
                _selectionOriginals.set(node.id, {
                    color: node.color,
                    val: node.val || 1
                });
            }

            // Apply styling
            if (hasSelection) {
                if (isSelected) {
                    const orig = _selectionOriginals.get(node.id);
                    node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
                } else {
                    const orig = _originalColorsForDim.get(node.id);
                    if (orig) {
                        node.color = _dimColor(orig.color, 0.5);
                        node.val = orig.val * 0.7;
                    }
                }
            } else {
                // Restore originals
                const orig = _originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = orig.color;
                    node.val = orig.val;
                }
            }

            // Update halo visibility
            if (node.__selectionHalo) {
                node.__selectionHalo.visible = isSelected;
            }
        });

        // Handle animation state
        if (hasSelection) {
            startAnimation();
        } else {
            stopAnimation();
            _selectionOriginals.clear();
            _originalColorsForDim.clear();
        }

        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (Graph) {
            Graph.refresh();
        }
    }

    function _updatePanel() {
        if (typeof updateSelectionPanel === 'function') {
            updateSelectionPanel();
        }
    }

    function _updateGroupButtonState() {
        if (typeof updateGroupButtonState === 'function') {
            updateGroupButtonState();
        }
    }

    // =========================================================================
    // NODE OVERLAYS (3D halos)
    // =========================================================================

    function ensureOverlays(node) {
        if (!node) return null;
        if (node.__overlayGroup) return node.__overlayGroup;

        // Lazy init geometry
        if (!_selectionHaloGeometry) {
            _selectionHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
            _groupHaloGeometry = new THREE.SphereGeometry(1, 12, 12);
        }

        const group = new THREE.Group();

        const selectionMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.85,
            depthWrite: false
        });
        const selectionHalo = new THREE.Mesh(_selectionHaloGeometry, selectionMaterial);
        selectionHalo.visible = false;
        selectionHalo.renderOrder = 3;

        const groupMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.45,
            depthWrite: false
        });
        const groupHalo = new THREE.Mesh(_groupHaloGeometry, groupMaterial);
        groupHalo.visible = false;
        groupHalo.renderOrder = 2;

        group.add(selectionHalo);
        group.add(groupHalo);

        node.__selectionHalo = selectionHalo;
        node.__groupHalo = groupHalo;
        node.__overlayGroup = group;

        return group;
    }

    function updateOverlayScale(node) {
        const APPEARANCE_STATE = typeof window !== 'undefined' ? window.APPEARANCE_STATE : { nodeScale: 1 };
        const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE?.nodeScale || 1));
        const selectionScale = base * 2.5;
        const groupScale = base * 1.8;

        if (node.__selectionHalo) {
            node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
        }
        if (node.__groupHalo) {
            node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
        }
    }

    // =========================================================================
    // MARQUEE STATE
    // =========================================================================

    function setMarqueeActive(active) {
        _marqueeActive = active;
        if (!active) {
            _lastMarqueeEndTs = Date.now();
        }
    }

    function setMarqueeStart(pos) {
        _marqueeStart = pos;
    }

    function setMarqueeAdditive(additive) {
        _marqueeAdditive = additive;
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core selection
        set,
        toggle,
        clear,
        maybeClear,
        add,
        remove,
        getSelectedNodes,

        // State access
        get ids() { return _ids; },
        get size() { return _ids.size; },
        has(id) { return _ids.has(id); },

        // Animation
        startAnimation,
        stopAnimation,

        // Overlays
        ensureOverlays,
        updateOverlayScale,

        // Marquee
        setMarqueeActive,
        setMarqueeStart,
        setMarqueeAdditive,
        get marqueeActive() { return _marqueeActive; },
        get marqueeStart() { return _marqueeStart; },
        get marqueeAdditive() { return _marqueeAdditive; },
        get lastMarqueeEndTs() { return _lastMarqueeEndTs; },

        // Internal access (for migration)
        _selectionOriginals,
        _originalColorsForDim
    };
})();

// Backward compatibility aliases - Using getters to ensure live updates
// Note: All variables use Object.defineProperty to avoid duplicate declarations with app.js
// SELECTED_NODE_IDS - selection.js is now the SINGLE SOURCE OF TRUTH (unified in modularization)
Object.defineProperty(window, 'SELECTED_NODE_IDS', { get: () => SELECT.ids, configurable: true });
Object.defineProperty(window, 'MARQUEE_ACTIVE', { get: () => SELECT.marqueeActive, configurable: true });
Object.defineProperty(window, 'MARQUEE_START', { get: () => SELECT.marqueeStart, configurable: true });
Object.defineProperty(window, 'MARQUEE_ADDITIVE', { get: () => SELECT.marqueeAdditive, configurable: true });
Object.defineProperty(window, 'LAST_MARQUEE_END_TS', { get: () => SELECT.lastMarqueeEndTs, configurable: true });
// selectionOriginals, originalColorsForDim - app.js owns these, not duplicated here

function getSelectedNodes() { return SELECT.getSelectedNodes(); }
function setSelection(ids, additive) { SELECT.set(ids, additive); }
function toggleSelection(node) { SELECT.toggle(node); }
function clearSelection() { SELECT.clear(); }
function maybeClearSelection() { SELECT.maybeClear(); }
function startSelectionAnimation() { SELECT.startAnimation(); }
function stopSelectionAnimation() { SELECT.stopAnimation(); }
function ensureNodeOverlays(node) { return SELECT.ensureOverlays(node); }
function updateOverlayScale(node) { SELECT.updateOverlayScale(node); }


// ═══ MODULE: modules/panels.js ═══
/**
 * PANELS MODULE
 *
 * Manages floating panels and HUD layout for the visualization.
 * Handles panel open/close, command bar, and UI dimming.
 *
 * Usage:
 *   PANELS.open('view')       // Open a panel
 *   PANELS.close('view')      // Close a panel
 *   PANELS.toggle('view')     // Toggle panel visibility
 *   PANELS.initCommandBar()   // Wire up command bar buttons
 */

const PANELS = (function() {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _activePanelId = null;

    // =========================================================================
    // PANEL FUNCTIONS
    // =========================================================================

    /**
     * Open a panel by ID
     */
    function open(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        // Close any already-open panel
        if (_activePanelId && _activePanelId !== panelId) {
            close(_activePanelId);
        }

        if (panel) {
            panel.classList.add('visible');
            setTimeout(() => { panel.style.opacity = '1'; }, 10);
        }
        if (btn) btn.classList.add('active');
        _activePanelId = panelId;

        // Dim the universe when panel opens
        document.body.classList.add('ui-active');

        // Dim starfield via JS
        if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
            const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
            STARFIELD.material.opacity = baseOpacity * 0.3;
        }
    }

    /**
     * Close a panel by ID
     */
    function close(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        const btn = document.getElementById('cmd-' + panelId);

        if (panel) {
            panel.classList.remove('visible');
        }
        if (btn) btn.classList.remove('active');
        if (_activePanelId === panelId) _activePanelId = null;

        // Restore universe when all panels closed
        if (!_activePanelId) {
            document.body.classList.remove('ui-active');

            // Restore starfield
            if (typeof STARFIELD !== 'undefined' && STARFIELD?.material) {
                const starsBtn = document.getElementById('btn-stars');
                const starsVisible = starsBtn && starsBtn.classList.contains('active');
                const baseOpacity = typeof STARFIELD_OPACITY !== 'undefined' ? STARFIELD_OPACITY : 0.5;
                STARFIELD.material.opacity = starsVisible ? baseOpacity : 0;
            }
        }
    }

    /**
     * Toggle a panel
     */
    function toggle(panelId) {
        const panel = document.getElementById('panel-' + panelId);
        if (panel && panel.classList.contains('visible')) {
            close(panelId);
        } else {
            open(panelId);
        }
    }

    /**
     * Get active panel ID
     */
    function getActive() {
        return _activePanelId;
    }

    // =========================================================================
    // COMMAND BAR INITIALIZATION
    // =========================================================================

    function initCommandBar() {
        const cmdBtns = {
            'cmd-view': 'view',
            'cmd-filter': 'filter',
            'cmd-style': 'style',
            'cmd-settings': 'settings'
        };

        Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', () => toggle(panelId));
            }
        });

        // Settings panel: Oval margin slider
        _initOvalMarginSlider();
        _initOvalDebugToggle();
    }

    function _initOvalMarginSlider() {
        const ovalSlider = document.getElementById('oval-margin-slider');
        const ovalValue = document.getElementById('oval-margin-value');
        let ovalDebounceTimer = null;

        if (ovalSlider) {
            ovalSlider.addEventListener('input', (e) => {
                if (ovalValue) ovalValue.textContent = e.target.value + '%';
            });

            const applyOvalMargin = () => {
                clearTimeout(ovalDebounceTimer);
                ovalDebounceTimer = setTimeout(() => {
                    const val = ovalSlider.value;
                    document.documentElement.style.setProperty('--oval-margin', val + '%');
                }, 300);
            };

            ovalSlider.addEventListener('mouseup', applyOvalMargin);
            ovalSlider.addEventListener('touchend', applyOvalMargin);
            ovalSlider.addEventListener('change', applyOvalMargin);
        }
    }

    function _initOvalDebugToggle() {
        const toggleOvalDebug = document.getElementById('toggle-oval-debug');
        if (toggleOvalDebug) {
            toggleOvalDebug.addEventListener('click', () => {
                toggleOvalDebug.classList.toggle('active');
                const ovalDebug = document.querySelector('.oval-debug');
                if (ovalDebug) {
                    ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
                }
            });
        }
    }

    // =========================================================================
    // HUD LAYOUT MANAGER - REMOVED, USE LAYOUT MODULE
    // =========================================================================
    // The HudLayoutManager has been unified into modules/layout.js
    // Use LAYOUT.reflow() instead of PANELS.HudLayoutManager.reflow()

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        open,
        close,
        toggle,
        getActive,
        initCommandBar,

        // State access
        get activePanelId() { return _activePanelId; }
    };
})();

// Backward compatibility - _activePanelId is managed by app.js
function openPanel(panelId) { PANELS.open(panelId); }
function closePanel(panelId) { PANELS.close(panelId); }
function togglePanel(panelId) { PANELS.toggle(panelId); }
function initCommandBar() { PANELS.initCommandBar(); }
// HudLayoutManager - app.js owns this, not duplicated here

// ════════════════════════════════════════════════════════════════════════
// PANEL DRAG & RESIZE - Make panels movable and resizable
// ════════════════════════════════════════════════════════════════════════

const PANEL_DRAG = (function() {
    'use strict';

    const _panels = new Map();
    let _dragState = null;
    let _resizeState = null;
    const STORAGE_KEY = 'collider-panel-positions';

    function init() {
        // Initialize draggable/resizable panels (use actual element IDs)
        initPanel('side-dock', { draggable: true, resizable: true, minWidth: 150, maxWidth: 400 });
        initPanel('header-panel', { draggable: true, resizable: false });
        initPanel('stats-panel', { draggable: true, resizable: false });
        initPanel('metrics-panel', { draggable: true, resizable: true, minWidth: 180, maxWidth: 350 });

        // Restore saved positions
        restorePositions();

        // Global mouse handlers
        document.addEventListener('mousemove', (e) => _onMouseMove(e));
        document.addEventListener('mouseup', (e) => _onMouseUp(e));
    }

    function initPanel(id, options = {}) {
        const panel = document.getElementById(id) || document.querySelector('.' + id);
        if (!panel) return;

        const config = {
            el: panel,
            id: id,
            draggable: options.draggable !== false,
            resizable: options.resizable === true,
            minWidth: options.minWidth || 100,
            maxWidth: options.maxWidth || 600,
            minHeight: options.minHeight || 50,
            maxHeight: options.maxHeight || window.innerHeight - 100
        };

        _panels.set(id, config);

        // Make panel positioned if not already
        const style = window.getComputedStyle(panel);
        if (style.position === 'static') {
            panel.style.position = 'absolute';
        }

        // Add drag handle (the panel header or title)
        if (config.draggable) {
            const header = panel.querySelector('.side-title, .hud-title, .panel-header') || panel;
            header.style.cursor = 'move';
            header.addEventListener('mousedown', (e) => _startDrag(e, id));
        }

        // Add resize handle
        if (config.resizable) {
            const handle = document.createElement('div');
            handle.className = 'panel-resize-handle';
            handle.addEventListener('mousedown', (e) => _startResize(e, id));
            panel.appendChild(handle);
            panel.style.position = 'absolute';
        }
    }

    function _startDrag(e, panelId) {
        // Don't drag if clicking on interactive elements
        if (e.target.closest('input, button, select, .collapsible-content, .preset-btn, .layout-btn, .scheme-btn')) {
            return;
        }

        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        const rect = config.el.getBoundingClientRect();

        _dragState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startLeft: rect.left,
            startTop: rect.top
        };

        config.el.classList.add('panel-dragging');
    }

    function _startResize(e, panelId) {
        const config = _panels.get(panelId);
        if (!config) return;

        e.preventDefault();
        e.stopPropagation();

        const rect = config.el.getBoundingClientRect();

        _resizeState = {
            panelId,
            startX: e.clientX,
            startY: e.clientY,
            startWidth: rect.width,
            startHeight: rect.height
        };

        config.el.classList.add('panel-resizing');
    }

    function _onMouseMove(e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (!config) return;

            const dx = e.clientX - _dragState.startX;
            const dy = e.clientY - _dragState.startY;

            let newLeft = _dragState.startLeft + dx;
            let newTop = _dragState.startTop + dy;

            // Keep within viewport
            newLeft = Math.max(0, Math.min(window.innerWidth - 50, newLeft));
            newTop = Math.max(0, Math.min(window.innerHeight - 50, newTop));

            config.el.style.left = newLeft + 'px';
            config.el.style.top = newTop + 'px';
            config.el.style.right = 'auto';
            config.el.style.bottom = 'auto';
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (!config) return;

            const dx = e.clientX - _resizeState.startX;
            const dy = e.clientY - _resizeState.startY;

            let newWidth = _resizeState.startWidth + dx;
            let newHeight = _resizeState.startHeight + dy;

            // Apply constraints
            newWidth = Math.max(config.minWidth, Math.min(config.maxWidth, newWidth));
            newHeight = Math.max(config.minHeight, Math.min(config.maxHeight, newHeight));

            config.el.style.width = newWidth + 'px';
            // Only resize height for certain panels
            if (config.el.classList.contains('side-dock') || config.el.classList.contains('side-content')) {
                // Don't change height for sidebar - it's auto
            } else {
                config.el.style.height = newHeight + 'px';
            }
        }
    }

    function _onMouseUp(_e) {
        if (_dragState) {
            const config = _panels.get(_dragState.panelId);
            if (config) {
                config.el.classList.remove('panel-dragging');
                savePositions();
            }
            _dragState = null;
        }

        if (_resizeState) {
            const config = _panels.get(_resizeState.panelId);
            if (config) {
                config.el.classList.remove('panel-resizing');
                savePositions();
            }
            _resizeState = null;
        }
    }

    function savePositions() {
        const positions = {};
        _panels.forEach((config, id) => {
            const rect = config.el.getBoundingClientRect();
            const style = config.el.style;
            positions[id] = {
                left: style.left || rect.left + 'px',
                top: style.top || rect.top + 'px',
                width: style.width || null,
                height: style.height || null
            };
        });
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not save positions:', e);
        }
    }

    function restorePositions() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (!saved) return;

            const positions = JSON.parse(saved);
            Object.entries(positions).forEach(([id, pos]) => {
                const config = _panels.get(id);
                if (!config) return;

                if (pos.left) config.el.style.left = pos.left;
                if (pos.top) config.el.style.top = pos.top;
                if (pos.width) config.el.style.width = pos.width;
                if (pos.height) config.el.style.height = pos.height;

                // Clear right/bottom if we're setting left/top
                if (pos.left) config.el.style.right = 'auto';
                if (pos.top) config.el.style.bottom = 'auto';
            });
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not restore positions:', e);
        }
    }

    function resetPositions() {
        try {
            localStorage.removeItem(STORAGE_KEY);
            location.reload();
        } catch (e) {
            console.warn('[PANEL_DRAG] Could not reset positions:', e);
        }
    }

    return {
        init,
        initPanel,
        savePositions,
        restorePositions,
        resetPositions,
        get panels() { return _panels; }
    };
})();

// Backward compatibility wrapper
const PanelManager = {
    panels: PANEL_DRAG.panels,
    init() { PANEL_DRAG.init(); },
    initPanel(id, opts) { PANEL_DRAG.initPanel(id, opts); },
    savePositions() { PANEL_DRAG.savePositions(); },
    restorePositions() { PANEL_DRAG.restorePositions(); },
    resetPositions() { PANEL_DRAG.resetPositions(); }
};

// Initialize after DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => PANEL_DRAG.init());
} else {
    setTimeout(() => PANEL_DRAG.init(), 100);
}

// Expose globally
window.PANEL_DRAG = PANEL_DRAG;
window.PanelManager = PanelManager;


// ═══ MODULE: modules/sidebar.js ═══
/**
 * SIDEBAR MODULE
 *
 * Manages sidebar controls including color presets, layout presets,
 * physics controls, appearance controls, filters, and panel updates.
 *
 * Depends on: ANIM (for layouts), REFRESH (for throttled updates)
 *
 * Usage:
 *   SIDEBAR.init()                         // Initialize after DOM ready
 *   SIDEBAR.setColorMode('tier')           // Change color mode
 *   SIDEBAR.setLayout('force')             // Change layout
 *   SIDEBAR.setPhysicsPreset('tight')      // Apply physics preset
 *   SIDEBAR.updateStats(nodes, edges)      // Update stat displays
 */

// Note: Using window assignment instead of const to avoid duplicate declaration with app.js
window.SIDEBAR = (function () {
    'use strict';

    // =========================================================================
    // STATE
    // =========================================================================

    let _refreshTimer = null;
    let _bound = false;

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    /**
     * Initialize sidebar - call after DOM is ready
     */
    function init() {
        if (_bound) return;
        _bound = true;

        // Initialize unified state manager first
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.init();
        }

        _bindSectionHeaders();
        _bindColorPresets();
        _bindLayoutPresets();
        _bindPhysicsControls();
        _bindAppearanceControls();
        _bindActionButtons();
        initSchemeNavigator();
        initViewModeToggle();
        initSectionResize();   // Enable vertical section resizing
        initSidebarResize();   // Enable horizontal sidebar resizing

        // Sync UI to initial state
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.syncUIFromState();
        }

        console.log('[SIDEBAR] Initialized');
    }

    // =========================================================================
    // SECTION COLLAPSE/EXPAND
    // =========================================================================

    function _bindSectionHeaders() {
        document.querySelectorAll('.section-header[data-section]').forEach(header => {
            header.addEventListener('click', () => {
                const sectionId = header.dataset.section;
                const content = document.getElementById(`section-${sectionId}`);
                if (!content) return;

                const isCollapsed = header.classList.toggle('collapsed');
                content.classList.toggle('collapsed', isCollapsed);
            });
        });
    }

    // =========================================================================
    // COLOR PRESETS (TIER, FAMILY, LAYER, RING, FILE, FLOW)
    // =========================================================================

    // =========================================================================
    // COLOR PRESETS: SMART SIDEBAR CONFIGURATION
    // =========================================================================

    const PRESET_CONFIG = [
        {
            category: 'Architecture',
            presets: [
                { id: 'tier', label: 'Tier', desc: 'Auto-detected architectural height' },
                { id: 'layer', label: 'Layer', desc: 'Business logic strata' },
                { id: 'subsystem', label: 'Subsystem', desc: 'Functional domain grouping' },
                { id: 'boundary_score', label: 'Boundary', desc: 'Internal vs External (1-9)' },
                { id: 'phase', label: 'Phase', desc: 'Data-Logic-Org-Exec (MIPO)' }
            ]
        },
        {
            category: 'Taxonomy',
            presets: [
                { id: 'atom', label: 'Atom', desc: 'Function, Class, Module types' },
                { id: 'family', label: 'Family', desc: 'Logic, Data, Execution' },
                { id: 'role', label: 'Role', desc: 'Service, Repo, Controller' },
                { id: 'roleCategory', label: 'Role Cat', desc: 'Query, Command, Event' },
                { id: 'fileType', label: 'File Type', desc: 'Extension-based coloring' }
            ]
        },
        {
            category: 'Metrics',
            presets: [
                { id: 'complexity', label: 'Complexity', desc: 'Cyclomatic complexity' },
                { id: 'loc', label: 'LOC', desc: 'Lines of Code' },
                { id: 'fan_in', label: 'Fan-In', desc: 'Incoming dependencies' },
                { id: 'fan_out', label: 'Fan-Out', desc: 'Outgoing dependencies' },
                { id: 'trust', label: 'Trust', desc: 'Detection confidence' }
            ]
        },
        {
            category: 'RPBL DNA',
            presets: [
                { id: 'responsibility', label: 'Responsibility', desc: 'SRP alignment (1-9)' },
                { id: 'purity', label: 'Purity', desc: 'Side-effect profile (1-9)' },
                { id: 'lifecycle_score', label: 'Lifecycle', desc: 'Static vs Dynamic (1-9)' },
                { id: 'state', label: 'State', desc: 'Stateful vs Stateless' },
                { id: 'visibility', label: 'Visibility', desc: 'Public vs Private' }
            ]
        },
        {
            category: 'Topology',
            presets: [
                { id: 'centrality', label: 'Centrality', desc: 'Graph importance' },
                { id: 'rank', label: 'PageRank', desc: 'Algorithmic influence' }, // mapped to centrality logic or similar
                { id: 'ring', label: 'Ring', desc: 'Concentric architecture rings' },
                { id: 'flow', label: 'Flow', desc: 'Dependency direction' }
            ]
        },
        {
            category: 'Evolution',
            presets: [
                { id: 'churn', label: 'Churn', desc: 'Change frequency (Simulated)' },
                { id: 'age', label: 'Age', desc: 'Time since creation (Simulated)' }
            ]
        }
    ];

    // =========================================================================
    // SCHEME NAVIGATOR: 33 Named Color Schemes
    // =========================================================================

    const SCHEME_CONFIG = [
        // PART A: Famous Scientific (15)
        { category: 'Sequential', schemes: ['viridis', 'plasma', 'magma', 'inferno', 'cividis', 'turbo', 'mako', 'rocket'] },
        { category: 'Diverging', schemes: ['coolwarm', 'spectral'] },
        { category: 'Thematic', schemes: ['thermal', 'nightvision', 'ocean', 'terrain', 'electric'] },

        // PART B: Role-Semantic (18 key roles)
        { category: 'Access', schemes: ['query', 'finder'] },
        { category: 'Mutation', schemes: ['command', 'creator', 'destroyer'] },
        { category: 'Construction', schemes: ['factory'] },
        { category: 'Storage', schemes: ['repository', 'cache'] },
        { category: 'Control', schemes: ['service', 'orchestrator'] },
        { category: 'Validation', schemes: ['validator', 'guard'] },
        { category: 'Transform', schemes: ['transformer', 'parser'] },
        { category: 'Events', schemes: ['handler', 'emitter'] },
        { category: 'Support', schemes: ['utility', 'lifecycle'] },

        // PART C: OKLCH Geometry (Mathematical paths through color space)
        { category: 'Loops', schemes: ['rainbow-loop', 'rainbow-bright', 'rainbow-dark'] },
        { category: 'Arcs', schemes: ['arc-warm', 'arc-cool', 'arc-nature'] },
        { category: 'Spirals', schemes: ['spiral-up', 'spiral-down', 'spiral-chroma'] },
        { category: 'Waves', schemes: ['wave-lightness', 'wave-chroma', 'pulse'] },
        { category: 'Ramps', schemes: ['ramp-hue', 'ramp-lightness', 'ramp-chroma'] },
        { category: 'Paths', schemes: ['helix', 'convergent', 'divergent', 'bicone'] }
    ];

    function _bindColorPresets() {
        // Init Smart Sidebar
        const container = document.getElementById('section-color');
        if (!container) return;

        // Clear existing static buttons if any (except header)
        const contentDiv = container.querySelector('.section-content');
        if (contentDiv) {
            contentDiv.innerHTML = ''; // Rebuild from scratch
            renderSmartSidebar(contentDiv);
        }
    }

    function renderSmartSidebar(container) {
        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Presets...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.preset-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.btn').forEach(btn => {
                    const match = btn.textContent.toLowerCase().includes(term) || btn.title.toLowerCase().includes(term);
                    btn.style.display = match ? 'block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        searchContainer.appendChild(searchInput);
        container.appendChild(searchContainer);

        // Render Categories
        PRESET_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'preset-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'btn-grid btn-grid-3'; // Default to 3-col

            section.presets.forEach(p => {
                const btn = document.createElement('button');
                btn.className = 'btn color-btn';
                btn.textContent = p.label;
                btn.title = p.desc;
                btn.dataset.preset = p.id;

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    setColorMode(p.id);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    // =========================================================================
    // SCHEME NAVIGATOR RENDERER
    // =========================================================================

    function renderSchemeNavigator(container) {
        if (!container) return;
        container.innerHTML = '';

        // Search bar
        const searchContainer = document.createElement('div');
        searchContainer.style.cssText = 'padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid var(--border);';
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Filter Schemes...';
        searchInput.style.cssText = 'width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--border); padding: 4px 8px; color: var(--text); border-radius: 4px; font-size: 10px;';

        searchInput.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.scheme-category').forEach(cat => {
                let hasMatch = false;
                cat.querySelectorAll('.scheme-btn').forEach(btn => {
                    const match = btn.dataset.scheme.toLowerCase().includes(term) ||
                        (btn.title && btn.title.toLowerCase().includes(term));
                    btn.style.display = match ? 'inline-block' : 'none';
                    if (match) hasMatch = true;
                });
                cat.style.display = hasMatch ? 'block' : 'none';
            });
        });

        // Clear button
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'Clear';
        clearBtn.title = 'Remove scheme, use default colors';
        clearBtn.style.cssText = 'margin-left: 8px; padding: 4px 8px; font-size: 9px; background: rgba(255,100,100,0.2); border: 1px solid rgba(255,100,100,0.3); color: var(--text); border-radius: 4px; cursor: pointer;';
        clearBtn.addEventListener('click', clearColorScheme);

        searchContainer.appendChild(searchInput);
        searchContainer.appendChild(clearBtn);
        container.appendChild(searchContainer);

        // Render Categories
        SCHEME_CONFIG.forEach(section => {
            const catDiv = document.createElement('div');
            catDiv.className = 'scheme-category';
            catDiv.style.marginBottom = '12px';

            const catTitle = document.createElement('div');
            catTitle.textContent = section.category;
            catTitle.style.cssText = 'font-size: 9px; opacity: 0.5; text-transform: uppercase; margin-bottom: 6px; letter-spacing: 0.5px;';
            catDiv.appendChild(catTitle);

            const grid = document.createElement('div');
            grid.className = 'scheme-grid';
            grid.style.cssText = 'display: flex; flex-wrap: wrap; gap: 4px;';

            section.schemes.forEach(schemeName => {
                const btn = document.createElement('button');
                btn.className = 'scheme-btn';
                btn.dataset.scheme = schemeName;

                // Get scheme info from COLOR engine
                let info = { name: schemeName, semantic: '' };
                if (typeof COLOR !== 'undefined' && COLOR.getSchemeInfo) {
                    info = COLOR.getSchemeInfo(schemeName);
                }

                btn.title = info.semantic || schemeName;

                // Create clean color swatches (5 stops) instead of ugly gradient
                const swatchContainer = document.createElement('div');
                swatchContainer.className = 'scheme-swatches';

                if (typeof COLOR !== 'undefined' && COLOR.getSchemeColor) {
                    // Sample 5 colors from the scheme path
                    [0, 0.25, 0.5, 0.75, 1].forEach(t => {
                        const swatch = document.createElement('span');
                        swatch.className = 'scheme-swatch';
                        swatch.style.backgroundColor = COLOR.getSchemeColor(schemeName, t);
                        swatchContainer.appendChild(swatch);
                    });
                }

                btn.appendChild(swatchContainer);

                // Label below swatches
                const label = document.createElement('span');
                label.className = 'scheme-label';
                label.textContent = info.name;
                btn.appendChild(label);

                // Click handler - VIS_STATE.syncUIFromState() handles active states
                btn.addEventListener('click', () => {
                    applyColorScheme(schemeName);
                });

                grid.appendChild(btn);
            });

            catDiv.appendChild(grid);
            container.appendChild(catDiv);
        });
    }

    /**
     * Apply a named color scheme (palette)
     *
     * NEW BEHAVIOR (via VIS_STATE):
     * - Palette is "armed" but does NOT auto-switch colorBy mode
     * - Palette only visually applies when colorBy is an interval mode
     * - When user switches to interval mode, the armed palette becomes active
     */
    function applyColorScheme(schemeName) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(schemeName);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(schemeName);
        }

        try {
            localStorage.setItem('collider_scheme', schemeName);
        } catch (e) { /* ignore */ }

        _refreshGraphColors();
        console.log('[SIDEBAR] Applied scheme:', schemeName);
    }

    /**
     * Clear active scheme, return to default interval colors
     */
    function clearColorScheme() {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setPalette(null);
            return;
        }

        // Fallback
        if (typeof COLOR !== 'undefined' && COLOR.applyScheme) {
            COLOR.applyScheme(null);
        }

        try {
            localStorage.removeItem('collider_scheme');
        } catch (e) { /* ignore */ }

        document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));

        _refreshGraphColors();

        console.log('[SIDEBAR] Cleared color scheme');
    }

    /**
     * Internal: Refresh all node colors and re-render the graph
     */
    function _refreshGraphColors() {
        if (typeof Graph === 'undefined' || !Graph) return;

        // Get current nodes from DataManager or Graph
        const DM = window.DM;
        const nodes = DM ? DM.getNodes() : (Graph.graphData ? Graph.graphData().nodes : []);

        // Recompute colors using current mode
        if (typeof window.applyNodeColors === 'function' && nodes.length > 0) {
            window.applyNodeColors(nodes);
        }

        // Trigger WebGL re-render
        Graph.nodeColor(Graph.nodeColor());

        // Also refresh edges if in gradient mode
        if (typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }
    }

    /**
     * Initialize scheme navigator in sidebar
     */
    function initSchemeNavigator() {
        const container = document.getElementById('section-schemes');
        if (container) {
            renderSchemeNavigator(container);
        }

        // Setup collapsible header for schemes panel
        const collapsibleHeaders = document.querySelectorAll('.info-panel-header.collapsible');
        collapsibleHeaders.forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.dataset.target;
                const content = document.getElementById(targetId);
                if (content) {
                    const isCollapsed = content.classList.toggle('collapsed');
                    header.classList.toggle('collapsed', isCollapsed);
                }
            });
        });

        // Setup color mode buttons (for right sidebar)
        const colorBtns = document.querySelectorAll('.color-panel .color-btn');
        colorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                if (!preset) return;

                // Apply color mode via VIS_STATE (handles UI sync)
                setColorMode(preset);
            });
        });

        // NOTE: Saved preferences are now loaded by VIS_STATE.init()
        // UI sync is handled by VIS_STATE.syncUIFromState()
    }

    // =========================================================================
    // VIEW MODE TOGGLE (ATOMS vs FILES)
    // =========================================================================

    let _currentViewMode = 'atoms';
    let _deferredViewMode = null;  // Stores mode to apply after data loads

    /**
     * Initialize the view mode toggle (Atoms vs Files)
     * Note: Only sets up event handlers and button visual state.
     * Actual mode application for 'files' is deferred until data is loaded.
     */
    function initViewModeToggle() {
        const toggle = document.getElementById('view-mode-toggle');
        if (!toggle) return;

        const buttons = toggle.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                if (!mode || mode === _currentViewMode) return;

                setViewMode(mode);
            });
        });

        // Load saved preference - but only update button state, defer actual mode switch
        try {
            const saved = localStorage.getItem('collider_view_mode');
            if (saved && (saved === 'atoms' || saved === 'files')) {
                // Update button visual state immediately
                buttons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.mode === saved);
                });
                _currentViewMode = saved;

                // If files mode, defer application until data is loaded
                if (saved === 'files') {
                    _deferredViewMode = 'files';
                    console.log('[SIDEBAR] Files mode saved - deferring until data loads');
                }
            }
        } catch (e) { /* ignore */ }
    }

    /**
     * Apply deferred view mode after data is loaded
     * Call this from initGraph() after DM.init() completes
     */
    function applyDeferredViewMode() {
        if (_deferredViewMode === 'files') {
            console.log('[SIDEBAR] Applying deferred files mode now that data is loaded');
            _deferredViewMode = null;  // Clear to prevent re-application

            // Apply files mode (data is now available)
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
                console.log('[SIDEBAR] View mode: FILES - showing file nodes');

                if (typeof showToast === 'function') {
                    showToast('FILE VIEW: Each node is a file. Click to expand.');
                }
            }
        }
    }

    /**
     * Set the view mode (atoms or files)
     */
    function setViewMode(mode) {
        if (mode !== 'atoms' && mode !== 'files') return;
        _currentViewMode = mode;

        // Update button states
        const buttons = document.querySelectorAll('.view-mode-btn');
        buttons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });

        // Save preference
        try {
            localStorage.setItem('collider_view_mode', mode);
        } catch (e) { /* ignore */ }

        // Apply view mode via FILE_VIZ module
        if (mode === 'files') {
            // Switch to file-nodes view
            if (typeof FILE_VIZ !== 'undefined') {
                // Build the file graph first (required before switching mode)
                FILE_VIZ.buildFileGraph();
                window.GRAPH_MODE = 'files';
                FILE_VIZ.graphMode = 'files';
                FILE_VIZ.setMode('map');
                FILE_VIZ.setEnabled(true);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'files';
                if (typeof buildFileGraph === 'function') buildFileGraph(null);
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: FILES - showing file nodes');
        } else {
            // Switch to atoms view
            if (typeof FILE_VIZ !== 'undefined') {
                FILE_VIZ.graphMode = 'atoms';
                FILE_VIZ.setEnabled(false);
            } else if (typeof window.GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = 'atoms';
                if (typeof refreshGraph === 'function') refreshGraph();
            }
            console.log('[SIDEBAR] View mode: ATOMS - showing individual atoms');
        }

        // Show toast notification
        if (typeof showToast === 'function') {
            const msg = mode === 'files'
                ? 'FILE VIEW: Each node is a file. Click to expand.'
                : 'ATOM VIEW: Each node is a code element.';
            showToast(msg);
        }
    }

    /**
     * Get current view mode
     */
    function getViewMode() {
        return _currentViewMode;
    }

    function setColorMode(mode) {
        // Use VIS_STATE for unified state management
        if (typeof VIS_STATE !== 'undefined') {
            VIS_STATE.setColorBy(mode);
            return;
        }

        // Fallback for when VIS_STATE not loaded yet
        if (typeof APPEARANCE_STATE !== 'undefined') {
            APPEARANCE_STATE.colorMode = mode;
            APPEARANCE_STATE.currentPreset = mode;
        }

        if (typeof setNodeColorMode === 'function') {
            setNodeColorMode(mode);
        }

        // Handle flow mode specially
        if (mode === 'flow') {
            if (typeof flowMode !== 'undefined' && !flowMode && typeof toggleFlowMode === 'function') {
                toggleFlowMode();
            }
        } else if (typeof flowMode !== 'undefined' && flowMode && typeof disableFlowMode === 'function') {
            disableFlowMode();
        }

        if (typeof window !== 'undefined' && typeof window.refreshGradientEdgeColors === 'function') {
            window.refreshGradientEdgeColors();
        }

        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        console.log('[SIDEBAR] Color mode:', mode);
    }

    // =========================================================================
    // LAYOUT PRESETS (FORCE, RADIAL, ORBITAL, SPHERE, GRID, SPIRAL)
    // =========================================================================

    function _bindLayoutPresets() {
        const container = document.getElementById('section-layout');
        if (!container) return;

        container.querySelectorAll('.btn[data-layout]').forEach(btn => {
            btn.addEventListener('click', () => {
                const layout = btn.dataset.layout;
                setLayout(layout);

                // Update active state
                container.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });
    }

    function setLayout(layout) {
        // Prefer ANIM module if available
        if (typeof ANIM !== 'undefined' && ANIM.applyLayout) {
            ANIM.applyLayout(layout, true);
        } else if (typeof applyLayoutPreset === 'function') {
            applyLayoutPreset(layout, true);
        }
        console.log('[SIDEBAR] Layout:', layout);
    }

    // =========================================================================
    // PHYSICS CONTROLS
    // =========================================================================

    const PHYSICS_PRESETS = {
        default: { charge: -120, link: 50, center: 0.05, damping: 0.4 },
        tight: { charge: -80, link: 30, center: 0.1, damping: 0.5 },
        loose: { charge: -200, link: 80, center: 0.02, damping: 0.3 },
        explosive: { charge: -400, link: 120, center: 0.01, damping: 0.2 }
    };

    function _bindPhysicsControls() {
        // Charge (repulsion)
        _bindSlider('physics-charge', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('charge').strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Link distance
        _bindSlider('physics-link', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3Force('link').distance(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Center pull
        _bindSlider('physics-center', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                const center = Graph.d3Force('center');
                if (center && center.strength) center.strength(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Damping (velocity decay)
        _bindSlider('physics-damping', (val) => {
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.d3VelocityDecay(val);
                Graph.d3ReheatSimulation();
            }
        });

        // Physics presets
        const container = document.getElementById('section-physics');
        if (container) {
            container.querySelectorAll('.btn[data-physics]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.physics;
                    setPhysicsPreset(preset);
                });
            });
        }
    }

    function setPhysicsPreset(preset) {
        const p = PHYSICS_PRESETS[preset];
        if (!p) return;

        // Update sliders
        _setSliderValue('physics-charge', p.charge);
        _setSliderValue('physics-link', p.link);
        _setSliderValue('physics-center', p.center);
        _setSliderValue('physics-damping', p.damping);

        // Apply to graph
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('charge').strength(p.charge);
            Graph.d3Force('link').distance(p.link);
            const center = Graph.d3Force('center');
            if (center && center.strength) center.strength(p.center);
            Graph.d3VelocityDecay(p.damping);
            Graph.d3ReheatSimulation();
        }

        console.log('[SIDEBAR] Physics preset:', preset);
    }

    // =========================================================================
    // APPEARANCE CONTROLS
    // =========================================================================

    function _bindAppearanceControls() {
        // Auto-bind all sliders that have a matching numeric input
        // This covers cfg-node-size, cfg-node-opacity, etc.
        const ranges = document.querySelectorAll('input[type="range"]');
        ranges.forEach(range => {
            if (range.id) {
                _bindSlider(range.id, (val) => {
                    // Dispatch to specific handlers based on ID
                    // This creates a centralized handler dispatch
                    _handleSliderChange(range.id, val);
                });
            }
        });

        // Toggles
        _bindToggle('cfg-toggle-labels', (active) => {
            if (typeof VIS_FILTERS !== 'undefined' && VIS_FILTERS.metadata) {
                VIS_FILTERS.metadata.showLabels = active;
            }
            if (typeof Graph !== 'undefined' && Graph) {
                Graph.nodeLabel(n => active ? n.name : null);
            }
        });

        _bindToggle('cfg-toggle-highlight', (active) => {
            // Handled by VIS_STATE or interactions
        });

        _bindToggle('cfg-toggle-pulse', (active) => {
            if (typeof ANIM !== 'undefined') {
                ANIM.togglePulse(active);
            }
        });

        _bindToggle('cfg-toggle-depth', (active) => {
            // 3D shading toggle
        });

        _bindToggle('cfg-toggle-arrows', (active) => {
            if (typeof Graph !== 'undefined' && Graph) {
                const linkDirectionalArrowLength = active ? 3.5 : 0;
                Graph.linkDirectionalArrowLength(linkDirectionalArrowLength);
            }
        });

        _bindToggle('cfg-toggle-gradient', (active) => {
            if (typeof VIS_STATE !== 'undefined') {
                // Trigger re-render of edges
                window.refreshGradientEdgeColors && window.refreshGradientEdgeColors();
            }
        });
    }

    // Centralized handler for all sliders
    function _handleSliderChange(id, val) {
        // Map ID to logic
        switch (id) {
            // Node Config
            case 'cfg-node-size':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeScale = val;
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeVal(n => (n.val || 1) * val);
                break;
            case 'cfg-node-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.nodeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode(); // Re-apply colors with new alpha
                break;
            case 'cfg-node-res':
                if (typeof Graph !== 'undefined' && Graph) Graph.nodeResolution(val);
                break;
            case 'cfg-label-size':
                // Note: 3d-force-graph doesn't have a direct dynamic label size multiplier, 
                // but we can trigger a re-render or update state.
                break;

            // Edge Config    
            case 'cfg-edge-opacity':
                if (typeof APPEARANCE_STATE !== 'undefined') APPEARANCE_STATE.edgeOpacity = val;
                if (typeof applyEdgeMode === 'function') applyEdgeMode();
                break;
            case 'cfg-edge-width':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkWidth(val);
                break;
            case 'cfg-edge-curve':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkCurvature(val);
                break;
            case 'cfg-particle-speed':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticleSpeed(val);
                break;
            case 'cfg-particle-count':
                if (typeof Graph !== 'undefined' && Graph) Graph.linkDirectionalParticles(val);
                break;

            // Physics (Updated IDs)
            case 'physics-charge':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('charge').strength(val);
                    Graph.d3ReheatSimulation();
                }
                break;
            case 'physics-link':
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.d3Force('link').distance(val);
                    Graph.d3ReheatSimulation();
                }
                break;
        }
    }


    // =========================================================================
    // ACTION BUTTONS
    // =========================================================================

    function _bindActionButtons() {
        // Reset view
        const resetBtn = document.getElementById('btn-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (typeof Graph !== 'undefined' && Graph) {
                    Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
                }
            });
        }

        // Screenshot
        const screenshotBtn = document.getElementById('btn-screenshot');
        if (screenshotBtn) {
            screenshotBtn.addEventListener('click', () => {
                if (typeof takeScreenshot === 'function') {
                    takeScreenshot();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    const link = document.createElement('a');
                    link.download = 'collider-screenshot.png';
                    link.href = Graph.renderer().domElement.toDataURL('image/png');
                    link.click();
                }
            });
        }

        // Toggle 2D
        const toggle2dBtn = document.getElementById('btn-2d');
        if (toggle2dBtn) {
            toggle2dBtn.addEventListener('click', () => {
                if (typeof toggle2DMode === 'function') toggle2DMode();
            });
        }

        // Freeze simulation
        const freezeBtn = document.getElementById('btn-freeze');
        if (freezeBtn) {
            freezeBtn.addEventListener('click', () => {
                if (typeof toggleFreeze === 'function') {
                    toggleFreeze();
                } else if (typeof Graph !== 'undefined' && Graph) {
                    // Simple freeze toggle
                    const alpha = Graph.d3AlphaTarget();
                    Graph.d3AlphaTarget(alpha === 0 ? 0.3 : 0);
                    freezeBtn.classList.toggle('active', alpha !== 0);
                }
            });
        }
    }

    // =========================================================================
    // FILTER CHIPS
    // =========================================================================

    function populateFilterChips(data) {
        if (!data || !data.nodes) return;

        // Tiers
        const tiers = [...new Set(data.nodes.map(n => n.tier).filter(Boolean))].sort();
        _populateChipGroup('filter-tiers', tiers, 'tiers');

        // Rings
        const rings = [...new Set(data.nodes.map(n => n.ring).filter(Boolean))].sort();
        _populateChipGroup('filter-rings', rings, 'rings');

        // Edge types
        const edgeTypes = [...new Set(data.links?.map(e => e.type).filter(Boolean) || [])].sort();
        _populateChipGroup('filter-edges', edgeTypes, 'edges');
    }

    function _populateChipGroup(containerId, items, filterKey) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';
        items.forEach(item => {
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.textContent = item;
            chip.addEventListener('click', () => {
                const isActive = chip.classList.toggle('active');
                setFilter(filterKey, item, !isActive); // active = filtered OUT
                _scheduleRefresh();
            });
            container.appendChild(chip);
        });
    }

    function setFilter(dimension, value, visible) {
        if (typeof VIS_FILTERS === 'undefined') return;
        const set = VIS_FILTERS[dimension];
        if (!set) return;

        if (visible) {
            set.delete(value); // Remove from filter = show
        } else {
            set.add(value);    // Add to filter = hide
        }
    }

    // =========================================================================
    // HOVER PANEL
    // =========================================================================

    function showHoverPanel(node) {
        const panel = document.getElementById('hover-panel');
        if (!panel || !node) return;

        const setField = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value || '--';
        };

        setField('hover-name', node.name);
        setField('hover-kind', node.kind || node.type || 'unknown');
        setField('hover-atom', node.atom);
        setField('hover-family', node.family || (node.atom ? node.atom.split('.')[0] : null));
        setField('hover-ring', node.ring);
        setField('hover-tier', node.tier);
        setField('hover-role', node.role);

        const fileEl = document.getElementById('hover-file');
        if (fileEl) fileEl.textContent = node.file_path || node.file || '';

        panel.classList.add('visible');
    }

    function hideHoverPanel() {
        const panel = document.getElementById('hover-panel');
        if (panel) panel.classList.remove('visible');
    }

    // =========================================================================
    // SELECTION PANEL
    // =========================================================================

    function updateSelectionPanel(selectedNodes) {
        const panel = document.getElementById('selection-panel');
        const title = document.getElementById('selection-title');
        const list = document.getElementById('selection-list');
        const clearBtn = document.getElementById('selection-clear');

        if (!panel || !list) return;

        if (!selectedNodes || selectedNodes.length === 0) {
            panel.classList.remove('visible');
            return;
        }

        if (title) title.textContent = `SELECTED (${selectedNodes.length})`;

        list.innerHTML = selectedNodes.slice(0, 20).map(n =>
            `<div class="selection-item">${n.name || n.id}</div>`
        ).join('');

        if (selectedNodes.length > 20) {
            list.innerHTML += `<div class="selection-item" style="opacity:0.5">...and ${selectedNodes.length - 20} more</div>`;
        }

        panel.classList.add('visible');

        // Bind clear button
        if (clearBtn) {
            clearBtn.onclick = () => {
                if (typeof SELECT !== 'undefined') {
                    SELECT.clear();
                } else if (typeof clearSelection === 'function') {
                    clearSelection();
                }
                panel.classList.remove('visible');
            };
        }
    }

    // =========================================================================
    // STATS DISPLAY
    // =========================================================================

    function updateStats(nodes, edges, entropy) {
        const nodeEl = document.getElementById('stat-nodes');
        const edgeEl = document.getElementById('stat-edges');
        const entropyEl = document.getElementById('stat-entropy');

        if (nodeEl) nodeEl.textContent = nodes?.toLocaleString() || '0';
        if (edgeEl) edgeEl.textContent = edges?.toLocaleString() || '0';
        if (entropyEl) entropyEl.textContent = entropy?.toFixed(2) || '--';
    }

    // =========================================================================
    // HELPER: SLIDERS
    // =========================================================================

    function _bindSlider(id, callback) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);

        // Handle deprecated value span if it exists (for backward compat)
        const valSpan = document.getElementById(`${id}-val`);

        if (!slider) return;

        // Slider -> Number
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (numberInput) numberInput.value = val;
            if (valSpan) valSpan.textContent = val;
            callback(val);
        });

        // Number -> Slider
        if (numberInput) {
            numberInput.addEventListener('change', () => { // Change triggers on enter/blur
                let val = parseFloat(numberInput.value);

                // Clamp
                if (slider.min) val = Math.max(parseFloat(slider.min), val);
                if (slider.max) val = Math.min(parseFloat(slider.max), val);

                numberInput.value = val;
                slider.value = val;
                if (valSpan) valSpan.textContent = val;
                callback(val);
            });

            // Optional: Live update while typing? Maybe too heavy. Use change for now.
        }
    }

    function _setSliderValue(id, value) {
        const slider = document.getElementById(id);
        const numberInput = document.getElementById(`${id}-num`);
        const valSpan = document.getElementById(`${id}-val`);

        if (slider) slider.value = value;
        if (numberInput) numberInput.value = value;
        if (valSpan) valSpan.textContent = value;
    }

    // =========================================================================
    // HELPER: TOGGLES
    // =========================================================================

    function _bindToggle(id, callback) {
        const toggle = document.getElementById(id);
        if (!toggle) return;

        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            callback(isActive);
        });
    }

    // =========================================================================
    // DEBOUNCED REFRESH
    // =========================================================================

    function _scheduleRefresh() {
        clearTimeout(_refreshTimer);
        _refreshTimer = setTimeout(() => {
            if (typeof REFRESH !== 'undefined') {
                REFRESH.throttled();
            } else if (typeof refreshGraph === 'function') {
                refreshGraph();
            }
        }, 16); // ~1 frame
    }

    // =========================================================================
    // SECTION RESIZING - Vertical drag handles
    // =========================================================================

    const SECTION_HEIGHT_KEY = 'viz_section_heights';
    let _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };

    function initSectionResize() {
        // Add resize handles to each section
        document.querySelectorAll('.section-content').forEach(content => {
            const sectionId = content.id;
            if (!sectionId) return;

            // Make content resizable
            content.classList.add('resizable');

            // Create resize handle
            const handle = document.createElement('div');
            handle.className = 'section-resize-handle';
            handle.dataset.section = sectionId;

            // Insert after section-content (before next section)
            const section = content.closest('.section');
            if (section && section.nextElementSibling) {
                section.parentNode.insertBefore(handle, section.nextElementSibling);
            }

            // Bind drag events
            handle.addEventListener('mousedown', _startResize);
        });

        // Global mouse events
        document.addEventListener('mousemove', _onResize);
        document.addEventListener('mouseup', _endResize);

        // Restore saved heights
        _restoreSectionHeights();

        console.log('[SIDEBAR] Section resize initialized');
    }

    function _startResize(e) {
        const sectionId = e.target.dataset.section;
        const content = document.getElementById(sectionId);
        if (!content) return;

        _resizeState = {
            active: true,
            section: content,
            startY: e.clientY,
            startHeight: content.offsetHeight
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ns-resize';
        e.preventDefault();
    }

    function _onResize(e) {
        if (!_resizeState.active || !_resizeState.section) return;

        const delta = e.clientY - _resizeState.startY;
        const newHeight = Math.max(60, Math.min(400, _resizeState.startHeight + delta));

        _resizeState.section.style.maxHeight = newHeight + 'px';
    }

    function _endResize() {
        if (!_resizeState.active) return;

        // Save height
        if (_resizeState.section) {
            _saveSectionHeight(_resizeState.section.id, _resizeState.section.style.maxHeight);
        }

        // Cleanup
        document.querySelectorAll('.section-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _resizeState = { active: false, section: null, startY: 0, startHeight: 0 };
    }

    function _saveSectionHeight(sectionId, height) {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            heights[sectionId] = height;
            localStorage.setItem(SECTION_HEIGHT_KEY, JSON.stringify(heights));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save section height:', e);
        }
    }

    function _restoreSectionHeights() {
        try {
            const heights = JSON.parse(localStorage.getItem(SECTION_HEIGHT_KEY) || '{}');
            Object.entries(heights).forEach(([sectionId, height]) => {
                const content = document.getElementById(sectionId);
                if (content && height) {
                    content.style.maxHeight = height;
                }
            });
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore section heights:', e);
        }
    }

    // =========================================================================
    // SIDEBAR RESIZING - Horizontal drag handles
    // =========================================================================

    const SIDEBAR_WIDTH_KEY = 'viz_sidebar_widths';
    let _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };

    function initSidebarResize() {
        const leftHandle = document.getElementById('left-resize-handle');
        const rightHandle = document.getElementById('right-resize-handle');

        if (leftHandle) {
            leftHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'left'));
        }
        if (rightHandle) {
            rightHandle.addEventListener('mousedown', (e) => _startSidebarResize(e, 'right'));
        }

        // Global mouse events
        document.addEventListener('mousemove', _onSidebarResize);
        document.addEventListener('mouseup', _endSidebarResize);

        // Restore saved widths
        _restoreSidebarWidths();

        console.log('[SIDEBAR] Sidebar resize initialized');
    }

    function _startSidebarResize(e, side) {
        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        const currentWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue(cssVar)) || 280;

        _sidebarResizeState = {
            active: true,
            side: side,
            startX: e.clientX,
            startWidth: currentWidth
        };

        e.target.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        e.preventDefault();
    }

    function _onSidebarResize(e) {
        if (!_sidebarResizeState.active) return;

        const { side, startX, startWidth } = _sidebarResizeState;
        const delta = side === 'left' ? (e.clientX - startX) : (startX - e.clientX);
        const minWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--min-sidebar-width')) || 200;
        const maxWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--max-sidebar-width')) || 400;
        const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + delta));

        const cssVar = side === 'left' ? '--sidebar-width' : '--right-panel-width';
        document.documentElement.style.setProperty(cssVar, newWidth + 'px');

        // Update handle position
        const handle = document.getElementById(`${side}-resize-handle`);
        if (handle) {
            if (side === 'left') {
                handle.style.left = (newWidth - 3) + 'px';
            } else {
                handle.style.right = (newWidth - 3) + 'px';
            }
        }
    }

    function _endSidebarResize() {
        if (!_sidebarResizeState.active) return;

        // Save widths
        _saveSidebarWidths();

        // Cleanup
        document.querySelectorAll('.sidebar-resize-handle.dragging').forEach(h => {
            h.classList.remove('dragging');
        });
        document.body.style.cursor = '';

        _sidebarResizeState = { active: false, side: null, startX: 0, startWidth: 0 };
    }

    function _saveSidebarWidths() {
        try {
            const left = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width');
            const right = getComputedStyle(document.documentElement).getPropertyValue('--right-panel-width');
            localStorage.setItem(SIDEBAR_WIDTH_KEY, JSON.stringify({ left, right }));
        } catch (e) {
            console.warn('[SIDEBAR] Could not save sidebar widths:', e);
        }
    }

    function _restoreSidebarWidths() {
        try {
            const widths = JSON.parse(localStorage.getItem(SIDEBAR_WIDTH_KEY) || '{}');
            if (widths.left) {
                document.documentElement.style.setProperty('--sidebar-width', widths.left);
                const leftHandle = document.getElementById('left-resize-handle');
                if (leftHandle) leftHandle.style.left = `calc(${widths.left} - 3px)`;
            }
            if (widths.right) {
                document.documentElement.style.setProperty('--right-panel-width', widths.right);
                const rightHandle = document.getElementById('right-resize-handle');
                if (rightHandle) rightHandle.style.right = `calc(${widths.right} - 3px)`;
            }
        } catch (e) {
            console.warn('[SIDEBAR] Could not restore sidebar widths:', e);
        }
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Initialization
        init,
        initSectionResize,
        initSidebarResize,

        // Color modes
        setColorMode,

        // Color Schemes (33 named gradients)
        applyColorScheme,
        clearColorScheme,
        renderSchemeNavigator,
        initSchemeNavigator,
        SCHEME_CONFIG,

        // Layouts
        setLayout,

        // Physics
        setPhysicsPreset,
        PHYSICS_PRESETS,

        // Filters
        populateFilterChips,
        setFilter,
        renderSmartSidebar, // Export for debug/manual re-render

        // Panels
        showHoverPanel,
        hideHoverPanel,
        updateSelectionPanel,

        // Stats
        updateStats,

        // View Mode (ATOMS/FILES toggle)
        initViewModeToggle,
        setViewMode,
        getViewMode,
        applyDeferredViewMode
    };
})();

// Backward compatibility - SidebarManager class is defined in app.js, not duplicated here
// The SIDEBAR module provides all functionality via SIDEBAR.* calls


// ═══ MODULE: modules/edge-system.js ═══
/**
 * EDGE SYSTEM MODULE
 *
 * Manages edge coloring, width, modes, and gradient effects.
 * Includes gradient palettes for tier, file, flow, depth, and semantic modes.
 *
 * Depends on: COLOR (for type-based colors), NODE (for tier lookups)
 *
 * Usage:
 *   EDGE.getColor(link)           // Get color for a link
 *   EDGE.getWidth(link)           // Get width for a link
 *   EDGE.setMode('gradient-tier') // Change edge mode
 *   EDGE.apply()                  // Apply current mode to graph
 */

const EDGE = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODE_ORDER = [
        'gradient-tier',      // Source→Target tier flow (architecture layers)
        'gradient-file',      // File boundaries (module regions)
        'gradient-flow',      // Markov probability (hot paths)
        'gradient-depth',     // Call depth progression
        'gradient-semantic',  // Semantic distance (type similarity)
        'type',               // Classic type-based
        'weight',             // Weight intensity
        'mono'                // Minimal monochrome
    ];

    const MODE_LABELS = {
        'gradient-tier': '▼ TIER FLOW',
        'gradient-file': '▼ FILE REGIONS',
        'gradient-flow': '▼ HOT PATHS',
        'gradient-depth': '▼ CALL DEPTH',
        'gradient-semantic': '▼ SEMANTIC',
        type: 'EDGE: TYPE',
        weight: 'EDGE: WEIGHT',
        mono: 'EDGE: MONO'
    };

    const MODE_HINTS = {
        'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
        'gradient-file': 'Color by file region - shows module boundaries',
        'gradient-flow': 'Hot paths - markov probability gradient',
        'gradient-depth': 'Color by call chain depth',
        'gradient-semantic': 'Color by semantic similarity of endpoints',
        type: 'Edge color by type (calls, imports, etc.)',
        weight: 'Edge width & color by weight',
        mono: 'Minimal monochrome'
    };

    // Gradient color palettes for different modes
    const PALETTES = {
        tier: {
            // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
            T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
            T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
            T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
            UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
        },
        file: {
            // Rainbow hues distributed across files
            saturation: 65,
            lightness: 48
        },
        flow: {
            // Cold (low prob) to Hot (high prob)
            cold: { h: 220, s: 60, l: 45 },   // Blue
            warm: { h: 45, s: 85, l: 50 },    // Yellow
            hot: { h: 0, s: 90, l: 55 }       // Red
        },
        depth: {
            // Shallow (bright) to Deep (dark, saturated)
            shallow: { h: 180, s: 50, l: 65 },  // Light cyan
            mid: { h: 260, s: 70, l: 50 },      // Purple
            deep: { h: 320, s: 80, l: 40 }      // Magenta
        },
        semantic: {
            // Similar (harmonious) to Different (contrasting)
            similar: { h: 150, s: 60, l: 50 },    // Green - same type
            related: { h: 200, s: 65, l: 48 },    // Cyan - related
            different: { h: 340, s: 75, l: 50 }   // Pink - different
        }
    };

    const DEFAULT_OPACITY = 0.08;
    const MIN_WIDTH = 0.6;
    const MAX_WIDTH = 2.2;
    const BASE_WIDTH = 1.0;

    // =========================================================================
    // STATE
    // =========================================================================

    let _mode = 'gradient-file';  // Default mode
    let _ranges = { weight: { min: 1, max: 1 }, confidence: { min: 1, max: 1 } };
    let _nodeFileIndex = new Map();
    let _fileHueMap = new Map();
    let _config = {
        opacity: DEFAULT_OPACITY,
        dim: { interfile_factor: 0.25 }
    };

    // =========================================================================
    // UTILITY FUNCTIONS
    // =========================================================================

    function clamp01(value) {
        return Math.max(0, Math.min(1, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function interpolateHSL(hsl1, hsl2, t) {
        t = clamp01(t);
        // Handle hue interpolation (shortest path on color wheel)
        let h1 = hsl1.h, h2 = hsl2.h;
        let dh = h2 - h1;
        if (Math.abs(dh) > 180) {
            if (dh > 0) h1 += 360;
            else h2 += 360;
        }
        const h = (h1 + (h2 - h1) * t) % 360;
        const s = hsl1.s + (hsl2.s - hsl1.s) * t;
        const l = hsl1.l + (hsl2.l - hsl1.l) * t;
        return hslColor(h, s, l);
    }

    function normalizeMetric(value, range) {
        // If range is degenerate (all same values), return based on absolute value
        if (!range || range.max <= range.min) {
            return clamp01(value);
        }
        return clamp01((value - range.min) / (range.max - range.min));
    }

    // =========================================================================
    // NODE HELPERS (use canonical versions from node-helpers.js via window.*)
    // =========================================================================

    function getLinkFileIdx(link, side) {
        const endpoint = link?.[side];
        if (endpoint && typeof endpoint === 'object') {
            return endpoint.fileIdx ?? -1;
        }
        if (endpoint) {
            return _nodeFileIndex.get(endpoint) ?? -1;
        }
        return -1;
    }

    // =========================================================================
    // FILE HUE MAP
    // =========================================================================

    function buildFileHueMap() {
        _fileHueMap.clear();
        // Try DATA module first, then DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
                   (typeof DM !== 'undefined' ? DM : null);
        if (!dm || !dm.getFileBoundaries) return;

        const files = dm.getFileBoundaries();
        const goldenAngle = 137.508;  // Golden angle for good distribution
        files.forEach((file, idx) => {
            const hue = (idx * goldenAngle) % 360;
            _fileHueMap.set(idx, hue);
        });
    }

    // =========================================================================
    // RANGE UPDATES
    // =========================================================================

    function updateRanges() {
        const links = (typeof Graph !== 'undefined' && Graph?.graphData()?.links) || [];
        let minWeight = Infinity, maxWeight = -Infinity;
        let minConf = Infinity, maxConf = -Infinity;

        links.forEach(link => {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            minWeight = Math.min(minWeight, weight);
            maxWeight = Math.max(maxWeight, weight);
            minConf = Math.min(minConf, confidence);
            maxConf = Math.max(maxConf, confidence);
        });

        _ranges = {
            weight: {
                min: isFinite(minWeight) ? minWeight : 1,
                max: isFinite(maxWeight) ? maxWeight : 1
            },
            confidence: {
                min: isFinite(minConf) ? minConf : 1,
                max: isFinite(maxConf) ? maxConf : 1
            }
        };
    }

    function refreshNodeFileIndex() {
        _nodeFileIndex.clear();
        const nodes = (typeof Graph !== 'undefined' && Graph?.graphData()?.nodes) || [];
        nodes.forEach(node => {
            if (node && node.id) {
                _nodeFileIndex.set(node.id, node.fileIdx ?? -1);
            }
        });
    }

    // =========================================================================
    // GRADIENT EDGE COLOR
    // =========================================================================

    function getGradientColor(link, mode) {
        const srcNode = typeof link.source === 'object' ? link.source :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.source) : null);
        const tgtNode = typeof link.target === 'object' ? link.target :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes?.find(n => n.id === link.target) : null);

        if (mode === 'gradient-tier') {
            const srcTier = window.getNodeTierValue(srcNode);
            const tgtTier = window.getNodeTierValue(tgtNode);
            const avgTier = (srcTier + tgtTier) / 2;

            const palette = PALETTES.tier;
            let color;
            if (avgTier < 0.5) {
                color = interpolateHSL(palette.T0, palette.T1, avgTier * 2);
            } else if (avgTier < 1.5) {
                color = interpolateHSL(palette.T0, palette.T1, (avgTier - 0.5));
            } else {
                color = interpolateHSL(palette.T1, palette.T2, (avgTier - 1) / 2);
            }

            // Highlight tier transitions (edges crossing tiers)
            if (srcTier !== tgtTier) {
                return hslColor(
                    parseInt(color.slice(4)),
                    75,  // Higher saturation
                    55   // Brighter
                );
            }
            return color;
        }

        if (mode === 'gradient-file') {
            const srcFile = srcNode?.fileIdx ?? -1;
            const tgtFile = tgtNode?.fileIdx ?? -1;
            const palette = PALETTES.file;

            if (srcFile === tgtFile && srcFile >= 0) {
                const hue = _fileHueMap.get(srcFile) ?? (srcFile * 37 % 360);
                return hslColor(hue, palette.saturation, palette.lightness);
            } else {
                const srcHue = _fileHueMap.get(srcFile) ?? 0;
                const tgtHue = _fileHueMap.get(tgtFile) ?? 180;
                let midHue = (srcHue + tgtHue) / 2;
                if (Math.abs(srcHue - tgtHue) > 180) {
                    midHue = (midHue + 180) % 360;
                }
                return hslColor(midHue, palette.saturation * 0.6, palette.lightness * 1.1);
            }
        }

        if (mode === 'gradient-flow') {
            const mw = link.markov_weight ?? link.weight ?? 0;
            const palette = PALETTES.flow;

            if (mw < 0.3) {
                return interpolateHSL(palette.cold, palette.warm, mw / 0.3);
            } else if (mw < 0.7) {
                return interpolateHSL(palette.warm, palette.hot, (mw - 0.3) / 0.4);
            } else {
                return hslColor(palette.hot.h, palette.hot.s + 10, palette.hot.l + 10);
            }
        }

        if (mode === 'gradient-depth') {
            const srcDepth = window.getNodeDepth(srcNode);
            const tgtDepth = window.getNodeDepth(tgtNode);
            const avgDepth = (srcDepth + tgtDepth) / 2;
            const palette = PALETTES.depth;

            if (avgDepth < 0.33) {
                return interpolateHSL(palette.shallow, palette.mid, avgDepth * 3);
            } else if (avgDepth < 0.66) {
                return interpolateHSL(palette.mid, palette.deep, (avgDepth - 0.33) * 3);
            } else {
                return hslColor(palette.deep.h, palette.deep.s, palette.deep.l - 10);
            }
        }

        if (mode === 'gradient-semantic') {
            const similarity = window.getSemanticSimilarity(srcNode, tgtNode);
            const palette = PALETTES.semantic;

            if (similarity > 0.7) {
                return interpolateHSL(palette.related, palette.similar, (similarity - 0.7) / 0.3);
            } else if (similarity > 0.3) {
                return interpolateHSL(palette.different, palette.related, (similarity - 0.3) / 0.4);
            } else {
                return hslColor(palette.different.h, palette.different.s + 10, palette.different.l);
            }
        }

        return '#444444';
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(link) {
        // Gradient modes
        if (_mode.startsWith('gradient-')) {
            return getGradientColor(link, _mode);
        }

        const edgeKey = String(link.edge_type || link.type || 'unknown').toLowerCase();

        if (_mode === 'type') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', edgeKey) : '#666666';
        }

        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            const t = normalizeMetric(weight, _ranges.weight);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('weight', t) : hslColor(30, 70, 50 + t * 30);
        }

        if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            const t = normalizeMetric(confidence, _ranges.confidence);
            return typeof COLOR !== 'undefined' ?
                COLOR.getInterval('confidence', t) : hslColor(200, 70, 50 + t * 30);
        }

        if (_mode === 'mono') {
            return typeof COLOR !== 'undefined' ?
                COLOR.get('edgeType', 'unknown') : '#555555';
        }

        // Default: type-based coloring
        return typeof COLOR !== 'undefined' ?
            COLOR.get('edgeType', edgeKey) : '#666666';
    }

    // =========================================================================
    // EDGE WIDTH
    // =========================================================================

    function getWidth(link) {
        // For most modes, return uniform width for visual consistency
        if (_mode !== 'weight' && _mode !== 'confidence') {
            return BASE_WIDTH;
        }

        // Weight/confidence modes: subtle variation within tight bounds
        let t = 0.5;
        if (_mode === 'weight') {
            const weight = typeof link.weight === 'number' ? link.weight : 1;
            t = normalizeMetric(weight, _ranges.weight);
        } else if (_mode === 'confidence') {
            const confidence = typeof link.confidence === 'number' ? link.confidence : 1;
            t = normalizeMetric(confidence, _ranges.confidence);
        }

        return MIN_WIDTH + (t * (MAX_WIDTH - MIN_WIDTH));
    }

    // =========================================================================
    // APPLY MODE TO GRAPH
    // =========================================================================

    function apply() {
        updateRanges();
        refreshNodeFileIndex();
        buildFileHueMap();

        if (typeof Graph === 'undefined' || !Graph) return;

        Graph.linkColor(link => {
            const color = getColor(link);
            return typeof toColorNumber === 'function' ?
                toColorNumber(color, 0x222222) : color;
        });

        Graph.linkOpacity(link => {
            const overrideOpacity = (typeof APPEARANCE_STATE !== 'undefined' &&
                typeof APPEARANCE_STATE.edgeOpacity === 'number')
                ? APPEARANCE_STATE.edgeOpacity
                : null;
            const baseOpacity = (overrideOpacity !== null)
                ? overrideOpacity
                : (link.opacity ?? DEFAULT_OPACITY);

            // File mode dimming
            const fileMode = typeof window !== 'undefined' && window.fileMode;
            const graphMode = typeof GRAPH_MODE !== 'undefined' ? GRAPH_MODE : 'atoms';
            if (fileMode && graphMode === 'atoms') {
                const srcIdx = getLinkFileIdx(link, 'source');
                const tgtIdx = getLinkFileIdx(link, 'target');
                if (srcIdx >= 0 && tgtIdx >= 0 && srcIdx !== tgtIdx) {
                    const dimFactor = _config.dim?.interfile_factor ?? 0.25;
                    return baseOpacity * dimFactor;
                }
            }
            return baseOpacity;
        });

        // Don't override width in flow mode
        const flowMode = typeof window !== 'undefined' && window.flowMode;
        if (!flowMode) {
            Graph.linkWidth(link => {
                const baseWidth = getWidth(link);
                // Respect APPEARANCE_STATE.edgeWidth multiplier if set
                const widthMultiplier = (typeof APPEARANCE_STATE !== 'undefined' &&
                    typeof APPEARANCE_STATE.edgeWidth === 'number')
                    ? APPEARANCE_STATE.edgeWidth
                    : 1;
                return Math.max(0.5, baseWidth * widthMultiplier);
            });
        }
    }

    // =========================================================================
    // MODE MANAGEMENT
    // =========================================================================

    function setMode(mode) {
        if (!MODE_ORDER.includes(mode)) return;
        _mode = mode;

        const button = document.getElementById('btn-edge-mode');
        if (button) {
            button.textContent = MODE_LABELS[_mode] || 'EDGE';
        }

        apply();

        // Update legend to reflect edge mode colors
        if (typeof renderAllLegends === 'function') {
            renderAllLegends();
        }

        // Show mode toast hint
        if (typeof showModeToast === 'function') {
            showModeToast(MODE_HINTS[mode] || `Edge mode: ${mode}`);
        }
    }

    function cycleMode() {
        const currentIndex = MODE_ORDER.indexOf(_mode);
        const nextIndex = (currentIndex + 1) % MODE_ORDER.length;
        setMode(MODE_ORDER[nextIndex]);
    }

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getWidth,
        apply,

        // Mode management
        setMode,
        cycleMode,
        get mode() { return _mode; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Constants
        MODE_ORDER,
        MODE_LABELS,
        MODE_HINTS,
        PALETTES,

        // Internal access (for migration)
        get ranges() { return _ranges; },
        get nodeFileIndex() { return _nodeFileIndex; },
        get fileHueMap() { return _fileHueMap; },

        // Utility exports
        buildFileHueMap,
        updateRanges,
        refreshNodeFileIndex
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
// These create getters/setters that sync with EDGE module state
Object.defineProperty(window, 'EDGE_MODE', {
    get: () => EDGE.mode,
    set: (v) => EDGE.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'EDGE_RANGES', {
    get: () => EDGE.ranges,
    configurable: true
});
Object.defineProperty(window, 'NODE_FILE_INDEX', {
    get: () => EDGE.nodeFileIndex,
    configurable: true
});
Object.defineProperty(window, 'FILE_HUE_MAP', {
    get: () => EDGE.fileHueMap,
    configurable: true
});
// Static constants - app.js owns these, not duplicated here
// EDGE_MODE_ORDER, EDGE_MODE_LABELS, EDGE_MODE_HINTS, GRADIENT_PALETTES - defined in app.js

function getEdgeColor(link) { return EDGE.getColor(link); }
function getEdgeWidth(link) { return EDGE.getWidth(link); }
function applyEdgeMode() { EDGE.apply(); }
function setEdgeMode(mode) { EDGE.setMode(mode); }
function cycleEdgeMode() { EDGE.cycleMode(); }
function updateEdgeRanges() { EDGE.updateRanges(); }
function refreshNodeFileIndex() { EDGE.refreshNodeFileIndex(); }
function buildFileHueMap() { EDGE.buildFileHueMap(); }
function getGradientEdgeColor(link, mode) { return EDGE.getColor(link); }


// ═══ MODULE: modules/file-viz.js ═══
/**
 * FILE VIZ MODULE
 *
 * Manages file visualization modes: color, hulls, cluster, map, spheres.
 * Handles file coloring, boundaries, mode switching, and FILE GRAPH.
 *
 * FILE GRAPH: Shows repository structure as first-class nodes where each
 * file becomes a hoverable, selectable node. This provides:
 * - Clear view of the repository file system
 * - Hover to see file details (atom count, path, metrics)
 * - Click to expand and see atoms within
 * - Edge weights show inter-file dependencies
 *
 * Depends on: DATA (for file boundaries), COLOR (for transforms)
 *
 * Pattern: IIFE with State Unification (see docs/specs/VISUALIZATION_UI_SPEC.md)
 *
 * Usage:
 *   FILE_VIZ.setMode('map')          // Switch to file-nodes view
 *   FILE_VIZ.toggle()                // Toggle file mode on/off
 *   FILE_VIZ.getColor(idx, total)    // Get color for a file
 *   FILE_VIZ.buildFileGraph()        // Build file-level graph
 *   FILE_VIZ.apply()                 // Apply current mode
 */

const FILE_VIZ = (function() {
    'use strict';

    // =========================================================================
    // CONSTANTS
    // =========================================================================

    const MODES = ['color', 'hulls', 'cluster', 'map', 'spheres'];

    const MODE_HINTS = {
        color: 'Files colored by hue - each file gets unique color',
        hulls: 'Boundary hulls around file clusters',
        cluster: 'Force clustering groups files together',
        map: 'FILE NODES view - see repository structure as nodes! Click to expand.',
        spheres: 'Containment spheres with collision physics'
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _enabled = false;
    let _mode = 'color';
    let _config = {
        strategy: 'golden-angle',
        angle: 137.5,
        chroma: null,
        saturation: 70,
        lightness: 50
    };
    let _boundaryMeshes = [];
    let _hullRedrawTimer = null;
    let _hullRedrawAttempts = 0;

    // FILE GRAPH STATE - for file-as-nodes visualization
    let _fileGraph = null;          // { nodes: [], links: [] } for file-level view
    let _fileNodeIds = new Map();   // fileIdx -> nodeId mapping
    let _fileNodePositions = new Map(); // Preserve positions across mode switches
    let _expandedFiles = new Set(); // Files expanded to show atoms
    let _graphMode = 'atoms';       // atoms | files | hybrid
    let _expandMode = 'inline';     // inline | detach
    let _activeMapping = 'format';  // Current visual mapping mode

    // =========================================================================
    // VISUAL MAPPING SYSTEM - Map metadata to visual properties
    // =========================================================================

    /**
     * Visual dimension mappings - connect file metadata to visual properties.
     * Each mapping defines: source metadata field → visual property + scale
     */
    const VISUAL_MAPPINGS = {
        // Size-based mappings
        size_bytes: {
            property: 'nodeSize',
            scale: 'sqrt',
            min: 2,
            max: 20,
            label: 'File Size (bytes)'
        },
        token_estimate: {
            property: 'nodeSize',
            scale: 'log',
            min: 2,
            max: 18,
            label: 'Token Count'
        },
        line_count: {
            property: 'nodeSize',
            scale: 'sqrt',
            min: 2,
            max: 15,
            label: 'Line Count'
        },

        // Time-based mappings
        age_days: {
            property: 'opacity',
            scale: 'linear',
            invert: true,  // Older = more faded
            min: 0.3,
            max: 1.0,
            label: 'File Age'
        },

        // Categorical mappings (discrete colors)
        format_category: {
            property: 'hue',
            discrete: true,
            values: {
                code:   210,  // Blue - primary code
                config: 45,   // Orange - configuration
                doc:    120,  // Green - documentation
                data:   280,  // Purple - data files
                test:   340,  // Pink - test files
                style:  180,  // Cyan - stylesheets
                script: 30,   // Yellow-Orange - scripts
                build:  0,    // Red - build files
                other:  0     // Gray (handled by saturation)
            },
            label: 'File Format'
        },
        purpose: {
            property: 'hue',
            discrete: true,
            values: {
                test:       340,  // Pink
                config:     45,   // Orange
                model:      260,  // Purple
                service:    210,  // Blue
                controller: 180,  // Cyan
                utility:    90,   // Yellow-Green
                interface:  300,  // Magenta
                data:       30,   // Orange-Yellow
                general:    200   // Light Blue
            },
            label: 'File Purpose'
        },

        // Complexity mappings
        complexity_density: {
            property: 'saturation',
            scale: 'linear',
            min: 30,
            max: 90,
            label: 'Complexity'
        },
        cohesion: {
            property: 'lightness',
            scale: 'linear',
            min: 35,
            max: 65,
            label: 'Cohesion'
        },

        // Git mappings (if available)
        git_commits: {
            property: 'pulse',  // Animation intensity
            scale: 'log',
            min: 0,
            max: 1,
            label: 'Git Commits'
        }
    };

    /**
     * Apply a visual mapping to file nodes.
     * @param {string} mappingKey - Key from VISUAL_MAPPINGS
     * @param {Array} fileNodes - Array of file node objects
     */
    function applyVisualMapping(mappingKey, fileNodes) {
        const mapping = VISUAL_MAPPINGS[mappingKey];
        if (!mapping) {
            console.warn(`[FILE_VIZ] Unknown mapping: ${mappingKey}`);
            return;
        }

        _activeMapping = mappingKey;

        // Get data range for normalization
        const values = fileNodes.map(n => n[mappingKey]).filter(v => v !== undefined && v !== null);
        if (values.length === 0) {
            console.warn(`[FILE_VIZ] No data for mapping: ${mappingKey}`);
            return;
        }

        const dataMin = Math.min(...values);
        const dataMax = Math.max(...values);

        fileNodes.forEach(node => {
            const rawValue = node[mappingKey];
            if (rawValue === undefined || rawValue === null) return;

            if (mapping.discrete) {
                // Categorical mapping
                const discreteValue = mapping.values[rawValue] ?? mapping.values['other'] ?? 0;
                _applyVisualProperty(node, mapping.property, discreteValue);
            } else {
                // Continuous mapping
                let normalized = _normalizeValue(rawValue, dataMin, dataMax, mapping.scale);
                if (mapping.invert) normalized = 1 - normalized;

                const visualMin = mapping.min ?? 0;
                const visualMax = mapping.max ?? 1;
                const visualValue = visualMin + normalized * (visualMax - visualMin);

                _applyVisualProperty(node, mapping.property, visualValue);
            }
        });

        console.log(`[FILE_VIZ] Applied mapping: ${mappingKey} (${mapping.label})`);
    }

    function _normalizeValue(value, min, max, scale) {
        if (max === min) return 0.5;

        let normalized;
        switch (scale) {
            case 'log':
                const logMin = Math.log10(Math.max(1, min));
                const logMax = Math.log10(Math.max(1, max));
                const logVal = Math.log10(Math.max(1, value));
                normalized = (logVal - logMin) / (logMax - logMin);
                break;
            case 'sqrt':
                const sqrtMin = Math.sqrt(min);
                const sqrtMax = Math.sqrt(max);
                const sqrtVal = Math.sqrt(value);
                normalized = (sqrtVal - sqrtMin) / (sqrtMax - sqrtMin);
                break;
            default: // linear
                normalized = (value - min) / (max - min);
        }
        return Math.max(0, Math.min(1, normalized));
    }

    function _applyVisualProperty(node, property, value) {
        switch (property) {
            case 'nodeSize':
                node.val = value;
                break;
            case 'hue':
                // Rebuild color with new hue
                const sat = _config.saturation ?? 70;
                const light = _config.lightness ?? 50;
                node.color = hslColor(value, sat, light);
                break;
            case 'saturation':
                // Would need to parse existing color - simplified approach
                node._saturation = value;
                break;
            case 'lightness':
                node._lightness = value;
                break;
            case 'opacity':
                node._opacity = value;
                break;
            case 'pulse':
                node._pulseIntensity = value;
                break;
        }
    }

    /**
     * Get color for file based on active mapping or default
     */
    function getColorForMapping(node) {
        const mapping = VISUAL_MAPPINGS[_activeMapping];
        if (!mapping || mapping.property !== 'hue') {
            // Use default golden angle coloring
            return getColor(node.fileIdx, 100, node.file_name);
        }

        const rawValue = node[_activeMapping];
        if (rawValue === undefined || !mapping.discrete) {
            return getColor(node.fileIdx, 100, node.file_name);
        }

        const hue = mapping.values[rawValue] ?? 200;
        const sat = node._saturation ?? (_config.saturation ?? 70);
        const light = node._lightness ?? (_config.lightness ?? 50);
        return hslColor(hue, sat, light);
    }

    // =========================================================================
    // COLOR UTILITIES
    // =========================================================================

    function clampValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

    function hslColor(hue, saturation, lightness) {
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    function hashToUnit(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash = hash & hash;
        }
        return Math.abs(hash % 1000) / 1000;
    }

    function getHue(fileIdx, totalFiles, fileName) {
        const strategy = _config.strategy || 'golden-angle';
        if (strategy === 'sequential') {
            const denom = Math.max(1, totalFiles);
            return (fileIdx / denom) * 360;
        }
        if (strategy === 'hash') {
            const seed = fileName || String(fileIdx);
            return hashToUnit(seed) * 360;
        }
        const angle = _config.angle ?? 137.5;
        return (fileIdx * angle) % 360;
    }

    // =========================================================================
    // MAIN COLOR FUNCTION
    // =========================================================================

    function getColor(fileIdx, totalFiles, fileName, lightnessOverride = null) {
        const saturation = _config.saturation ?? 70;
        const lightness = (lightnessOverride !== null)
            ? lightnessOverride
            : (_config.lightness ?? 50);
        const hue = getHue(fileIdx, totalFiles, fileName);

        // Apply color tweaks if available
        const tweaks = typeof COLOR_TWEAKS !== 'undefined' ? COLOR_TWEAKS : {};

        if (typeof _config.chroma === 'number' && typeof oklchColor === 'function') {
            return oklchColor(lightness, _config.chroma, hue);
        }

        const adjustedHue = hue + (tweaks.hueShift || 0);
        const adjustedLightness = clampValue(lightness + (tweaks.lightnessShift || 0), 0, 100);
        return hslColor(adjustedHue, saturation, adjustedLightness);
    }

    // =========================================================================
    // APPLY COLORS TO NODES
    // =========================================================================

    function applyColors(graphNodes) {
        // Get file boundaries from DATA module or DM global
        const dm = typeof DATA !== 'undefined' ? DATA :
                   (typeof DM !== 'undefined' ? DM : null);
        const boundaries = dm?.getFileBoundaries ? dm.getFileBoundaries() : [];
        const totalFiles = boundaries.length;

        graphNodes.forEach(node => {
            if (node.fileIdx >= 0) {
                const fileInfo = boundaries[node.fileIdx] || {};
                const fileLabel = fileInfo.file || fileInfo.file_name || node.fileIdx;
                node.color = getColor(node.fileIdx, totalFiles, fileLabel);
            }
        });

        if (typeof Graph !== 'undefined' && Graph) {
            Graph.nodeColor(n => {
                return typeof toColorNumber === 'function' ?
                    toColorNumber(n.color, 0x888888) : n.color;
            });
        }
    }

    // =========================================================================
    // FILE GRAPH BUILDING - Repository as Nodes
    // =========================================================================

    /**
     * Build a file-level graph where each file is a node.
     * This creates a clear view of repository structure with:
     * - File nodes sized by atom count
     * - Edges weighted by inter-file dependencies
     * - Colors by file index (golden angle distribution)
     */
    function buildFileGraph() {
        const dm = typeof DATA !== 'undefined' ? DATA :
                   (typeof DM !== 'undefined' ? DM : null);
        const boundaries = dm?.getFileBoundaries ? dm.getFileBoundaries() : [];
        const nodes = dm?.getNodes ? dm.getNodes() : [];
        const links = dm?.getLinks ? dm.getLinks() : [];

        // Get current atom positions from Graph for centroid calculation
        const currentGraphNodes = (typeof Graph !== 'undefined' && Graph)
            ? (Graph.graphData()?.nodes || [])
            : [];
        const atomPositions = new Map();
        currentGraphNodes.forEach(n => {
            if (n && n.id && Number.isFinite(n.x) && Number.isFinite(n.y)) {
                atomPositions.set(n.id, { x: n.x, y: n.y, z: n.z || 0 });
            }
        });

        const totalFiles = boundaries.length;
        const fileNodes = [];
        _fileNodeIds.clear();
        const nodeFileIdx = new Map();

        // Build node -> fileIdx mapping
        nodes.forEach(n => {
            if (n && n.id) {
                nodeFileIdx.set(n.id, n.fileIdx ?? -1);
            }
        });

        // Build file -> atoms mapping for centroid calculation
        const fileAtoms = new Map(); // fileIdx -> [atom positions]
        nodes.forEach(n => {
            if (n && n.id && n.fileIdx !== undefined && n.fileIdx >= 0) {
                const pos = atomPositions.get(n.id);
                if (pos) {
                    if (!fileAtoms.has(n.fileIdx)) fileAtoms.set(n.fileIdx, []);
                    fileAtoms.get(n.fileIdx).push(pos);
                }
            }
        });

        // Create file nodes with centroid positions
        boundaries.forEach((boundary, idx) => {
            const label = boundary.file_name || boundary.file || `file-${idx}`;
            const atomCount = boundary.atom_count || 1;
            const nodeId = `file:${idx}`;
            _fileNodeIds.set(idx, nodeId);

            // Calculate centroid from atom positions (SMOOTH TRANSITION)
            const atoms = fileAtoms.get(idx) || [];
            let cx = 0, cy = 0, cz = 0;
            if (atoms.length > 0) {
                atoms.forEach(p => { cx += p.x; cy += p.y; cz += p.z; });
                cx /= atoms.length;
                cy /= atoms.length;
                cz /= atoms.length;
            } else {
                // Fallback: radial layout for files with no positioned atoms
                const angle = (idx / totalFiles) * Math.PI * 2;
                const radius = 200;
                cx = Math.cos(angle) * radius;
                cy = Math.sin(angle) * radius;
                cz = (Math.random() - 0.5) * 50;
            }

            fileNodes.push({
                id: nodeId,
                name: label,
                fileIdx: idx,
                isFileNode: true,
                // POSITION: Initialize at centroid of atoms for smooth transition
                x: cx, y: cy, z: cz,
                fx: undefined, fy: undefined, fz: undefined, // Allow physics to relax
                val: Math.max(2, Math.sqrt(atomCount) * 1.5), // Size by atom count
                color: getColor(idx, totalFiles, label),
                file_path: boundary.file || '',
                atom_count: atomCount,
                // Enriched file metadata for hover panel and visual mappings
                tier: boundary.tier || 'UNKNOWN',
                ring: boundary.ring || 'UNKNOWN',
                internal_edges: boundary.internal_edges || 0,
                external_edges: boundary.external_edges || 0,
                // Physical metadata
                size_bytes: boundary.size_bytes ?? 0,
                size_kb: boundary.size_kb ?? 0,
                token_estimate: boundary.token_estimate ?? 0,
                line_count: boundary.line_count ?? 0,
                code_lines: boundary.code_lines ?? 0,
                // Temporal metadata
                age_days: boundary.age_days ?? 0,
                modified_date: boundary.modified_date || '',
                is_stale: boundary.is_stale ?? false,
                is_recent: boundary.is_recent ?? false,
                // Categorical metadata
                format_category: boundary.format_category || 'other',
                purpose: boundary.purpose || 'general',
                extension: boundary.extension || '',
                is_test: boundary.is_test ?? false,
                is_config: boundary.is_config ?? false,
                // Complexity metadata
                complexity_density: boundary.complexity_density ?? 0,
                cohesion: boundary.cohesion ?? 0.5,
                code_ratio: boundary.code_ratio ?? 0.5
            });
        });

        // Build inter-file edges with weights
        const edgeMap = new Map();
        links.forEach(link => {
            const srcId = _getLinkEndpointId(link, 'source');
            const tgtId = _getLinkEndpointId(link, 'target');
            const srcIdx = nodeFileIdx.get(srcId) ?? -1;
            const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;

            // Skip internal edges and invalid indices
            if (srcIdx < 0 || tgtIdx < 0 || srcIdx === tgtIdx) return;

            const key = `${srcIdx}->${tgtIdx}`;
            const existing = edgeMap.get(key) || {
                source: _fileNodeIds.get(srcIdx),
                target: _fileNodeIds.get(tgtIdx),
                weight: 0,
                edge_type: 'file-dependency',
                resolution: 'file'
            };
            existing.weight += 1;
            edgeMap.set(key, existing);
        });

        _fileGraph = {
            nodes: fileNodes,
            links: Array.from(edgeMap.values())
        };

        console.log(`[FILE_VIZ] Built file graph: ${fileNodes.length} files, ${edgeMap.size} inter-file edges`);
        return _fileGraph;
    }

    function _getLinkEndpointId(link, side) {
        const endpoint = link?.[side];
        if (!endpoint) return null;
        if (typeof endpoint === 'object') return endpoint.id;
        return endpoint;
    }

    /**
     * Save current file node positions for smooth transitions
     */
    function captureFileNodePositions() {
        _fileNodePositions.clear();
        if (typeof Graph === 'undefined' || !Graph) return;

        const nodes = Graph.graphData()?.nodes || [];
        nodes.forEach(node => {
            if (node && node.isFileNode && Number.isFinite(node.x) && Number.isFinite(node.y)) {
                _fileNodePositions.set(node.fileIdx, {
                    x: node.x,
                    y: node.y,
                    z: Number.isFinite(node.z) ? node.z : 0
                });
            }
        });
    }

    /**
     * Restore saved positions to file nodes
     */
    function restoreFileNodePositions(nodes) {
        nodes.forEach(node => {
            if (node.isFileNode && _fileNodePositions.has(node.fileIdx)) {
                const pos = _fileNodePositions.get(node.fileIdx);
                node.x = pos.x;
                node.y = pos.y;
                node.z = pos.z;
            }
        });
    }

    /**
     * Get file target position for radial layout
     */
    function getFileTarget(fileIdx, totalFiles, radius, zSpread) {
        const angle = (fileIdx / totalFiles) * Math.PI * 2;
        return {
            x: Math.cos(angle) * radius,
            y: Math.sin(angle) * radius,
            z: (Math.random() - 0.5) * zSpread
        };
    }

    /**
     * Expand a file to show its atoms
     */
    function expandFile(fileIdx) {
        _expandedFiles.add(fileIdx);
        _graphMode = 'hybrid';
        if (typeof refreshGraph === 'function') refreshGraph();
    }

    /**
     * Collapse a file to hide its atoms
     */
    function collapseFile(fileIdx) {
        _expandedFiles.delete(fileIdx);
        _graphMode = _expandedFiles.size > 0 ? 'hybrid' : 'files';
        if (typeof refreshGraph === 'function') refreshGraph();
    }

    /**
     * Toggle file expansion
     */
    function toggleFileExpansion(fileIdx) {
        if (_expandedFiles.has(fileIdx)) {
            collapseFile(fileIdx);
        } else {
            expandFile(fileIdx);
        }
    }

    /**
     * Apply the file graph to the visualization
     */
    function applyFileGraphMode() {
        if (!_fileGraph) {
            buildFileGraph();
        }
        if (!_fileGraph || typeof Graph === 'undefined' || !Graph) return;

        restoreFileNodePositions(_fileGraph.nodes);
        Graph.graphData(_fileGraph);
        applyColors(_fileGraph.nodes);

        // Reheat simulation for nice spread
        Graph.d3ReheatSimulation();

        if (typeof showToast === 'function') {
            showToast(`File view: ${_fileGraph.nodes.length} files. Click to expand atoms.`);
        }
    }

    // =========================================================================
    // BOUNDARY MANAGEMENT
    // =========================================================================

    function clearBoundaries() {
        if (typeof Graph === 'undefined' || !Graph) return;
        const scene = Graph.scene();
        if (!scene) return;

        _boundaryMeshes.forEach(mesh => scene.remove(mesh));
        _boundaryMeshes = [];
    }

    function scheduleHullRedraw(delayMs = 1200) {
        if (_hullRedrawTimer) {
            clearTimeout(_hullRedrawTimer);
        }
        _hullRedrawTimer = setTimeout(() => {
            if (!(_enabled && _mode === 'hulls')) {
                _hullRedrawAttempts = 0;
                return;
            }

            // Call external drawFileBoundaries if available
            if (typeof drawFileBoundaries === 'function') {
                const drawn = drawFileBoundaries(null);
                if (drawn === 0 && _hullRedrawAttempts < 3) {
                    _hullRedrawAttempts += 1;
                    scheduleHullRedraw(1000);
                }
            }
        }, delayMs);
    }

    // =========================================================================
    // MODE CLEARING
    // =========================================================================

    function clearAllModes() {
        clearBoundaries();

        // Reset file cohesion force if active
        if (typeof clearFileCohesion === 'function') {
            clearFileCohesion();
        }

        // Reset cluster force if active
        if (typeof clusterForceActive !== 'undefined' && clusterForceActive &&
            typeof Graph !== 'undefined' && Graph) {
            Graph.d3Force('cluster', null);
            if (typeof DEFAULT_LINK_DISTANCE !== 'undefined' && DEFAULT_LINK_DISTANCE !== null) {
                Graph.d3Force('link').distance(DEFAULT_LINK_DISTANCE);
            }
            Graph.d3ReheatSimulation();
        }

        // Stop containment animation if active
        if (typeof stopContainmentAnimation === 'function') {
            stopContainmentAnimation();
        }

        // Clear containment spheres
        if (typeof FILE_CONTAINMENT !== 'undefined' && FILE_CONTAINMENT?.spheres) {
            const scene = typeof Graph !== 'undefined' ? Graph?.scene() : null;
            if (scene) {
                FILE_CONTAINMENT.spheres.forEach(s => {
                    if (s.mesh) scene.remove(s.mesh);
                });
            }
            FILE_CONTAINMENT.spheres = [];
            FILE_CONTAINMENT.boundariesPopped = false;
        }

        // Clear lingering filters
        if (typeof VIS_FILTERS !== 'undefined') {
            const filterSets = ['rings', 'tiers', 'families', 'files', 'roles', 'edges', 'layers', 'effects', 'edgeFamilies'];
            filterSets.forEach(key => {
                if (VIS_FILTERS[key]?.clear) VIS_FILTERS[key].clear();
            });
            document.querySelectorAll('.filter-chip.active').forEach(c => c.classList.remove('active'));
        }

        // Reset POP button state
        const popBtn = document.getElementById('btn-file-pop');
        if (popBtn) {
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
        }
    }

    // =========================================================================
    // SET FILE MODE STATE
    // =========================================================================

    function setEnabled(enabled) {
        _enabled = enabled;

        // Update UI buttons
        const cmdBtn = document.getElementById('cmd-files');
        if (cmdBtn) cmdBtn.classList.toggle('active', _enabled);
        const dockBtn = document.getElementById('btn-files');
        if (dockBtn) dockBtn.classList.toggle('active', _enabled);

        // Update panels
        const filePanel = document.getElementById('file-panel');
        const modeControls = document.getElementById('file-mode-controls');
        const expandControls = document.getElementById('file-expand-controls');

        if (_enabled) {
            if (filePanel) filePanel.classList.add('visible');
            if (modeControls) modeControls.classList.add('visible');
            if (expandControls) expandControls.classList.toggle('visible', _mode === 'map');
            apply();
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            // Use unified LAYOUT module for reflow
            if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();
        } else {
            if (filePanel) filePanel.classList.remove('visible');
            if (modeControls) modeControls.classList.remove('visible');
            if (expandControls) expandControls.classList.remove('visible');

            // Clear expanded files
            if (typeof EXPANDED_FILES !== 'undefined') EXPANDED_FILES.clear();
            if (typeof GRAPH_MODE !== 'undefined') window.GRAPH_MODE = 'atoms';

            // Use unified LAYOUT module for reflow
            if (typeof LAYOUT !== 'undefined') LAYOUT.reflow();

            clearAllModes();
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
            if (typeof refreshGraph === 'function') refreshGraph();
        }
    }

    function toggle() {
        setEnabled(!_enabled);
    }

    // =========================================================================
    // SET VIZ MODE
    // =========================================================================

    function setMode(mode) {
        if (!MODES.includes(mode)) return;
        _mode = mode;

        // Update button states
        document.querySelectorAll('.file-mode-btn').forEach(btn => btn.classList.remove('active'));
        const modeBtn = document.getElementById('btn-file-' + mode);
        if (modeBtn) modeBtn.classList.add('active');

        // Toggle expand controls visibility
        const expandControls = document.getElementById('file-expand-controls');
        if (expandControls) expandControls.classList.toggle('visible', _mode === 'map');
        if (_mode === 'map' && typeof updateExpandButtons === 'function') {
            updateExpandButtons();
        }

        // Update graph mode
        if (_mode === 'map') {
            const hasExpanded = typeof EXPANDED_FILES !== 'undefined' && EXPANDED_FILES.size > 0;
            if (typeof GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = hasExpanded ? 'hybrid' : 'files';
            }
        } else {
            if (typeof EXPANDED_FILES !== 'undefined') EXPANDED_FILES.clear();
            if (typeof GRAPH_MODE !== 'undefined') window.GRAPH_MODE = 'atoms';
        }

        // Apply mode
        if (!_enabled) {
            setEnabled(true);
        } else if (_mode === 'map') {
            apply();
        } else {
            if (typeof refreshGraph === 'function') refreshGraph();
        }
    }

    // =========================================================================
    // APPLY CURRENT MODE
    // =========================================================================

    function apply() {
        if (!_enabled) return;

        // Clear previous state
        clearBoundaries();
        if (_mode !== 'hulls') {
            _hullRedrawAttempts = 0;
        }

        // Get graph nodes
        const dm = typeof DATA !== 'undefined' ? DATA :
                   (typeof DM !== 'undefined' ? DM : null);
        const graphNodes = dm?.getVisibleNodes ?
            dm.getVisibleNodes() :
            (typeof Graph !== 'undefined' ? Graph?.graphData()?.nodes || [] : []);

        // Apply file cohesion for color/hulls/cluster modes
        if (_mode === 'color' || _mode === 'hulls' || _mode === 'cluster') {
            if (typeof applyFileCohesion === 'function' && dm?.raw) {
                const physicsPayload = { physics: dm.raw.physics, config: dm.raw.config };
                applyFileCohesion(physicsPayload);
            }
        }

        if (_mode === 'color') {
            applyColors(graphNodes);
        }
        else if (_mode === 'hulls') {
            applyColors(graphNodes);
            scheduleHullRedraw(1500);
        }
        else if (_mode === 'cluster') {
            applyColors(graphNodes);
            if (typeof applyClusterForce === 'function' && dm?.raw) {
                applyClusterForce(dm.raw);
            }
        }
        else if (_mode === 'map') {
            const hasExpanded = typeof EXPANDED_FILES !== 'undefined' && EXPANDED_FILES.size > 0;
            if (typeof GRAPH_MODE !== 'undefined') {
                window.GRAPH_MODE = hasExpanded ? 'hybrid' : 'files';
            }
            if (typeof refreshGraph === 'function') refreshGraph();
            if (typeof showToast === 'function') {
                showToast('File map active. Click a file node to expand.');
            }
        }
        else if (_mode === 'spheres') {
            applyColors(graphNodes);
            if (typeof buildDirectoryTree === 'function' && dm?.raw) {
                buildDirectoryTree(dm.raw);
            }
            if (typeof computeFileActivity === 'function' && dm?.raw) {
                computeFileActivity(dm.raw, graphNodes);
            }
            if (typeof drawContainmentSpheres === 'function' && dm?.raw) {
                drawContainmentSpheres(dm.raw, graphNodes);
            }
            if (typeof startContainmentAnimation === 'function') {
                startContainmentAnimation();
            }
            if (typeof showToast === 'function') {
                showToast('Containment spheres active. Files as force fields. Click POP! to release.');
            }
        }
    }

    // =========================================================================
    // FILE CLUSTERING FORCES - D3 force manipulation for file grouping
    // =========================================================================

    let _clusterForceActive = false;
    let _fileCohesionActive = false;

    /**
     * Apply cluster force to group nodes by file
     * Creates fixed target positions arranged in a circular pattern
     */
    function applyClusterForce(data) {
        const Graph = window.Graph;
        const DM = window.DM;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const IS_3D = window.IS_3D;

        const clusterConfig = data?.physics?.cluster || {};
        const modeStrength = (typeof clusterConfig.modes?.strong === 'number') ? clusterConfig.modes.strong : null;
        const sliderStrength = (typeof APPEARANCE_STATE?.clusterStrength === 'number') ? APPEARANCE_STATE.clusterStrength : null;
        const clusterStrength = (typeof sliderStrength === 'number')
            ? sliderStrength
            : ((typeof modeStrength === 'number')
                ? modeStrength
                : ((typeof clusterConfig.strength === 'number') ? clusterConfig.strength : 0.3));
        const clusterRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius : 150;
        const clusterZSpacing = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing : 30;
        const linkDistance = (typeof clusterConfig.linkDistance === 'number')
            ? clusterConfig.linkDistance
            : (data?.physics?.forces?.link?.distance || 50);

        const graphNodes = DM ? DM.getVisibleNodes() : (Graph?.graphData()?.nodes || []);
        const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
        const numFiles = boundaries.length;

        // Fixed target positions: arrange files in circular pattern
        const fileTargets = {};
        for (let i = 0; i < numFiles; i++) {
            fileTargets[i] = getFileTarget(i, numFiles, clusterRadius, clusterZSpacing);
        }

        // Reduce link distance to keep intra-file nodes tighter
        Graph.d3Force('link').distance(linkDistance);

        // Apply strong clustering force toward fixed targets
        Graph.d3Force('cluster', (alpha) => {
            const k = alpha * clusterStrength;
            graphNodes.forEach(node => {
                const target = fileTargets[node.fileIdx];
                if (target) {
                    node.vx = (node.vx || 0) + (target.x - node.x) * k;
                    node.vy = (node.vy || 0) + (target.y - node.y) * k;
                    if (IS_3D) {
                        node.vz = (node.vz || 0) + (target.z - node.z) * k;
                    }
                }
            });
        });

        _clusterForceActive = true;
        Graph.d3ReheatSimulation();
        scheduleHullRedraw(1500);
    }

    /**
     * Apply file cohesion force - nodes in same file attract each other
     * Also stretches inter-file links for better separation
     */
    function applyFileCohesion(data) {
        if (_fileCohesionActive) return;

        const Graph = window.Graph;
        const DM = window.DM;
        const APPEARANCE_STATE = window.APPEARANCE_STATE;
        const IS_3D = window.IS_3D;
        const DEFAULT_LINK_DISTANCE = window.DEFAULT_LINK_DISTANCE || 50;

        const config = data?.physics?.fileCohesion || {};
        const strength = (typeof APPEARANCE_STATE?.fileCohesionStrength === 'number')
            ? APPEARANCE_STATE.fileCohesionStrength
            : (config.strength ?? 0.15);
        const linkMult = config.interFileLinkMultiplier ?? 2.5;
        const minDist = config.minDistance ?? 20;

        const nodes = DM ? DM.getVisibleNodes() : (Graph?.graphData()?.nodes || []);
        if (!nodes.length) return;

        // Pre-compute file groups
        const groups = new Map();
        nodes.forEach(n => {
            const f = n.fileIdx ?? -1;
            if (f >= 0) (groups.get(f) || groups.set(f, []).get(f)).push(n);
        });

        // Intra-file centroid attraction
        Graph.d3Force('fileCohesion', (alpha) => {
            const k = strength * alpha;
            groups.forEach(g => {
                if (g.length < 2) return;
                let cx = 0, cy = 0, cz = 0;
                g.forEach(n => { cx += n.x || 0; cy += n.y || 0; cz += n.z || 0; });
                cx /= g.length; cy /= g.length; cz /= g.length;
                g.forEach(n => {
                    const dx = cx - (n.x || 0), dy = cy - (n.y || 0), dz = cz - (n.z || 0);
                    const d = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;
                    if (d > minDist) {
                        const f = k * Math.min(1, d / 100);
                        n.vx = (n.vx || 0) + dx * f;
                        n.vy = (n.vy || 0) + dy * f;
                        if (IS_3D) n.vz = (n.vz || 0) + dz * f;
                    }
                });
            });
        });

        // Inter-file links stretched
        const base = DEFAULT_LINK_DISTANCE;
        Graph.d3Force('link').distance(link => {
            const s = typeof link.source === 'object' ? link.source : nodes.find(n => n.id === link.source);
            const t = typeof link.target === 'object' ? link.target : nodes.find(n => n.id === link.target);
            if (!s || !t) return base;
            const sf = s.fileIdx ?? -1, tf = t.fileIdx ?? -1;
            return (sf >= 0 && tf >= 0 && sf !== tf) ? base * linkMult : base;
        });

        _fileCohesionActive = true;
        Graph.d3ReheatSimulation();
    }

    /**
     * Clear file cohesion force
     */
    function clearFileCohesion() {
        if (!_fileCohesionActive) return;

        const Graph = window.Graph;
        const DEFAULT_LINK_DISTANCE = window.DEFAULT_LINK_DISTANCE;

        Graph.d3Force('fileCohesion', null);
        if (DEFAULT_LINK_DISTANCE !== null) {
            Graph.d3Force('link').distance(DEFAULT_LINK_DISTANCE);
        }
        _fileCohesionActive = false;
        Graph.d3ReheatSimulation();
    }

    /**
     * Clear cluster force
     */
    function clearClusterForce() {
        if (!_clusterForceActive) return;

        const Graph = window.Graph;
        Graph.d3Force('cluster', null);
        _clusterForceActive = false;
        Graph.d3ReheatSimulation();
    }

    // =========================================================================
    // CONFIGURATION
    // =========================================================================

    function setConfig(config) {
        _config = { ..._config, ...config };
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        // Core functions
        getColor,
        getHue,
        applyColors,

        // Mode management
        setMode,
        get mode() { return _mode; },
        MODES,
        MODE_HINTS,

        // Enable/disable
        setEnabled,
        toggle,
        get enabled() { return _enabled; },

        // Apply
        apply,

        // FILE GRAPH - Repository as Nodes
        buildFileGraph,
        applyFileGraphMode,
        expandFile,
        collapseFile,
        toggleFileExpansion,
        captureFileNodePositions,
        restoreFileNodePositions,
        getFileTarget,
        get fileGraph() { return _fileGraph; },
        get fileNodeIds() { return _fileNodeIds; },
        get expandedFiles() { return _expandedFiles; },
        get graphMode() { return _graphMode; },
        set graphMode(val) { _graphMode = val; },
        get expandMode() { return _expandMode; },
        set expandMode(val) { _expandMode = val; },

        // VISUAL MAPPING - Metadata to Visual Properties
        applyVisualMapping,
        getColorForMapping,
        VISUAL_MAPPINGS,
        get activeMapping() { return _activeMapping; },
        set activeMapping(val) { _activeMapping = val; },

        // Boundaries
        clearBoundaries,
        clearAllModes,
        scheduleHullRedraw,

        // File Clustering Forces
        applyClusterForce,
        clearClusterForce,
        applyFileCohesion,
        clearFileCohesion,
        get clusterForceActive() { return _clusterForceActive; },
        get fileCohesionActive() { return _fileCohesionActive; },

        // Configuration
        setConfig,
        get config() { return _config; },

        // Internal state access (for migration)
        get boundaryMeshes() { return _boundaryMeshes; },
        set boundaryMeshes(val) { _boundaryMeshes = val; }
    };
})();

// Backward compatibility aliases - Using Object.defineProperty to avoid duplicate declarations
Object.defineProperty(window, 'fileMode', {
    get: () => FILE_VIZ.enabled,
    set: (v) => FILE_VIZ.setEnabled(v),
    configurable: true
});
Object.defineProperty(window, 'fileVizMode', {
    get: () => FILE_VIZ.mode,
    set: (v) => FILE_VIZ.setMode(v),
    configurable: true
});
Object.defineProperty(window, 'FILE_COLOR_CONFIG', {
    get: () => FILE_VIZ.config,
    configurable: true
});
Object.defineProperty(window, 'fileBoundaryMeshes', {
    get: () => FILE_VIZ.boundaryMeshes,
    set: (v) => { FILE_VIZ.boundaryMeshes = v; },
    configurable: true
});
// hullRedrawTimer, hullRedrawAttempts - app.js owns these, not duplicated here

function getFileColor(fileIdx, totalFiles, fileName, lightnessOverride) {
    return FILE_VIZ.getColor(fileIdx, totalFiles, fileName, lightnessOverride);
}
function getFileHue(fileIdx, totalFiles, fileName) {
    return FILE_VIZ.getHue(fileIdx, totalFiles, fileName);
}
function setFileModeState(enabled) {
    FILE_VIZ.setEnabled(enabled);
}
function setFileVizMode(mode) {
    FILE_VIZ.setMode(mode);
}
function applyFileVizMode() {
    FILE_VIZ.apply();
}
function applyFileColors(graphNodes) {
    FILE_VIZ.applyColors(graphNodes);
}
function clearFileBoundaries() {
    FILE_VIZ.clearBoundaries();
}
function clearAllFileModes() {
    FILE_VIZ.clearAllModes();
}
function scheduleHullRedraw(delayMs) {
    FILE_VIZ.scheduleHullRedraw(delayMs);
}

// File graph backward compatibility - Using getters for live updates
Object.defineProperty(window, 'FILE_GRAPH', {
    get: () => FILE_VIZ.fileGraph,
    set: (val) => { /* Ignore - module manages state */ },
    configurable: true
});
Object.defineProperty(window, 'FILE_NODE_IDS', {
    get: () => FILE_VIZ.fileNodeIds,
    configurable: true
});
// FILE_NODE_POSITIONS is managed by app.js (not in this module's scope)
Object.defineProperty(window, 'EXPANDED_FILES', {
    get: () => FILE_VIZ.expandedFiles,
    configurable: true
});
Object.defineProperty(window, 'FILE_EXPAND_MODE', {
    get: () => FILE_VIZ.expandMode,
    set: (val) => { FILE_VIZ.expandMode = val; },
    configurable: true
});

function buildFileGraph(data) {
    // Calls module's buildFileGraph - FILE_GRAPH getter will return the result
    FILE_VIZ.buildFileGraph();
    FILE_NODE_IDS = FILE_VIZ.fileNodeIds;
    return FILE_VIZ.fileGraph;  // Return directly from module
}
function captureFileNodePositions() {
    FILE_VIZ.captureFileNodePositions();
}
function restoreNodePositions(nodes) {
    FILE_VIZ.restoreFileNodePositions(nodes);
}
function getFileTarget(fileIdx, totalFiles, radius, zSpread) {
    return FILE_VIZ.getFileTarget(fileIdx, totalFiles, radius, zSpread);
}

// File clustering force shims
function applyClusterForce(data) {
    FILE_VIZ.applyClusterForce(data);
}
function clearClusterForce() {
    FILE_VIZ.clearClusterForce();
}
function applyFileCohesion(data) {
    FILE_VIZ.applyFileCohesion(data);
}
function clearFileCohesion() {
    FILE_VIZ.clearFileCohesion();
}
Object.defineProperty(window, 'clusterForceActive', {
    get: () => FILE_VIZ.clusterForceActive,
    configurable: true
});
Object.defineProperty(window, 'fileCohesionActive', {
    get: () => FILE_VIZ.fileCohesionActive,
    configurable: true
});


// ═══ MODULE: modules/tooltips.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * TOOLTIPS MODULE - Tooltip and Toast Notifications
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles topology tooltips and toast notifications.
 * Depends on: TOOLTIP_STATE, HINTS_ENABLED, SMC_THEORY (globals)
 *
 * @module TOOLTIPS
 * @version 1.0.0
 * @confidence 99%
 */

window.TOOLTIPS = (function() {
    'use strict';

    // Module-local timeout reference
    let _toastTimeout = null;

    // ═══════════════════════════════════════════════════════════════════════
    // TOOLTIP OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Initialize tooltip elements
     */
    function initTooltips() {
        const state = window.TOOLTIP_STATE;
        if (state) {
            state.element = document.getElementById('topo-tooltip');
        }
    }

    /**
     * Show topology tooltip with theory content
     * @param {string} category - Theory category (tiers, rings, families, etc.)
     * @param {string} key - Item key within category
     * @param {number} x - Screen X position
     * @param {number} y - Screen Y position
     */
    function showTopoTooltip(category, key, x, y) {
        const state = window.TOOLTIP_STATE;
        if (!state) return;

        if (!state.element) initTooltips();
        if (!state.element) return;

        const theory = window.SMC_THEORY;
        const content = theory?.[category]?.[key];
        if (!content) return;

        clearTimeout(state.hideTimeout);

        // Populate tooltip content
        const iconEl = document.getElementById('tooltip-icon');
        const titleEl = document.getElementById('tooltip-title');
        const subtitleEl = document.getElementById('tooltip-subtitle');
        const bodyEl = document.getElementById('tooltip-body');
        const theoryEl = document.getElementById('tooltip-theory');
        const examplesEl = document.getElementById('tooltip-examples');

        if (iconEl) iconEl.textContent = content.icon || '';
        if (titleEl) titleEl.textContent = content.title || key;
        if (subtitleEl) subtitleEl.textContent = content.subtitle || '';
        if (bodyEl) bodyEl.textContent = content.body || '';
        if (theoryEl) theoryEl.textContent = content.theory || '';
        if (examplesEl) {
            examplesEl.innerHTML = (content.examples || [])
                .map(ex => `<span class="topo-tooltip-example">${ex}</span>`)
                .join('');
        }

        // Position tooltip
        const tooltip = state.element;
        let left = x + 15, top = y + 15;
        if (left + 280 > window.innerWidth) left = x - 295;
        if (top + 200 > window.innerHeight) top = y - 215;
        if (left < 0) left = 15;
        if (top < 0) top = 15;

        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.classList.add('visible');

        state.visible = true;
        state.currentKey = `${category}:${key}`;
    }

    /**
     * Hide topology tooltip
     * @param {boolean} immediate - Hide immediately without delay
     */
    function hideTopoTooltip(immediate = false) {
        const state = window.TOOLTIP_STATE;
        if (!state || !state.element) return;

        if (immediate) {
            state.element.classList.remove('visible');
            state.visible = false;
        } else {
            state.hideTimeout = setTimeout(() => {
                state.element.classList.remove('visible');
                state.visible = false;
            }, 150);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // TOAST OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Show a toast notification
     * @param {string} message - Message to display
     */
    function showToast(message) {
        const toast = document.getElementById('hud-toast');
        if (!toast) return;

        toast.textContent = message;
        toast.classList.add('visible');

        clearTimeout(toast._timer);
        toast._timer = setTimeout(() => {
            toast.classList.remove('visible');
        }, 2200);
    }

    /**
     * Show mode change toast (respects hints setting)
     * @param {string} message - Message to display
     */
    function showModeToast(message) {
        if (!window.HINTS_ENABLED) return;

        let toast = document.getElementById('mode-toast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'mode-toast';
            toast.className = 'mode-toast';
            document.body.appendChild(toast);
        }

        toast.textContent = message;
        toast.classList.add('visible');

        if (_toastTimeout) clearTimeout(_toastTimeout);
        _toastTimeout = setTimeout(() => {
            toast.classList.remove('visible');
        }, 1200);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        init: initTooltips,
        showTopo: showTopoTooltip,
        hideTopo: hideTopoTooltip,
        toast: showToast,
        modeToast: showModeToast
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.initTooltips = TOOLTIPS.init;
window.showTopoTooltip = TOOLTIPS.showTopo;
window.hideTopoTooltip = TOOLTIPS.hideTopo;
window.showToast = TOOLTIPS.toast;
window.showModeToast = TOOLTIPS.modeToast;

console.log('[Module] TOOLTIPS loaded - 5 functions');


// ═══ MODULE: modules/theme.js ═══
/**
 * ═══════════════════════════════════════════════════════════════════════════
 * THEME MODULE - Runtime Theme Management
 * ═══════════════════════════════════════════════════════════════════════════
 *
 * Handles theme switching, persistence, and initialization.
 * Depends on: THEME_CONFIG (global), Graph (global), THREE (global)
 *
 * @module THEME
 * @version 1.0.0
 * @confidence 99%
 */

window.THEME = (function() {
    'use strict';

    // ═══════════════════════════════════════════════════════════════════════
    // THEME OPERATIONS
    // ═══════════════════════════════════════════════════════════════════════

    /**
     * Set the active theme by name.
     * Updates document data-theme attribute and stores preference.
     * @param {string} themeName - Theme name: 'dark', 'light', or 'high-contrast'
     */
    function setTheme(themeName) {
        const config = window.THEME_CONFIG;
        if (!config || !config.available.includes(themeName)) {
            console.warn(`[Theme] Unknown theme: ${themeName}. Available: ${config?.available?.join(', ') || 'none'}`);
            return;
        }

        // Update document attribute for CSS variable switching
        document.documentElement.setAttribute('data-theme', themeName);

        // Update global state
        config.current = themeName;

        // Store preference in localStorage
        try {
            localStorage.setItem('collider-theme', themeName);
        } catch (e) {
            console.warn('[Theme] Could not save preference:', e);
        }

        // Update canvas background if WebGL renderer is active
        const Graph = window.Graph;
        if (Graph && Graph.scene && Graph.scene()) {
            const scene = Graph.scene();
            if (scene.background) {
                const vizColors = window.VIZ_COLORS || {};
                const bgColor = getComputedStyle(document.documentElement)
                    .getPropertyValue('--color-viz-canvas-bg')?.trim() || vizColors.canvasBg || '#0a0a0f';
                scene.background = new THREE.Color(bgColor);
            }
        }

        // Update theme toggle buttons
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.theme === themeName);
        });

        const consoleColors = window.CONSOLE_COLORS || { success: '#4caf50' };
        console.log(`%c[Theme] Switched to: ${themeName}`, `color: ${consoleColors.success}; font-weight: bold`);

        // Show toast if available
        if (typeof window.showToast === 'function') {
            window.showToast(`Theme: ${themeName}`);
        }
    }

    /**
     * Get the current theme name.
     * @returns {string} Current theme name
     */
    function getTheme() {
        const config = window.THEME_CONFIG;
        return config ? config.current : 'dark';
    }

    /**
     * Get list of available themes.
     * @returns {string[]} Array of theme names
     */
    function getAvailableThemes() {
        const config = window.THEME_CONFIG;
        return config ? config.available : ['dark'];
    }

    /**
     * Cycle to the next theme in the list.
     */
    function cycleTheme() {
        const config = window.THEME_CONFIG;
        if (!config) return;

        const current = config.current;
        const themes = config.available;
        const currentIndex = themes.indexOf(current);
        const nextIndex = (currentIndex + 1) % themes.length;
        setTheme(themes[nextIndex]);
    }

    /**
     * Initialize theme from saved preference or default.
     */
    function initTheme() {
        const config = window.THEME_CONFIG;
        if (!config) {
            console.warn('[Theme] THEME_CONFIG not available');
            return;
        }

        // Check for saved preference
        let savedTheme = null;
        try {
            savedTheme = localStorage.getItem('collider-theme');
        } catch (e) {
            // Ignore storage errors
        }

        // Use saved preference if valid
        if (savedTheme && config.available.includes(savedTheme)) {
            setTheme(savedTheme);
            return;
        }

        // Fall back to default theme
        setTheme(config.default || 'dark');
    }

    // ═══════════════════════════════════════════════════════════════════════
    // MODULE EXPORT
    // ═══════════════════════════════════════════════════════════════════════

    return {
        set: setTheme,
        get: getTheme,
        available: getAvailableThemes,
        cycle: cycleTheme,
        init: initTheme
    };
})();

// ═══════════════════════════════════════════════════════════════════════════
// BACKWARD COMPATIBILITY SHIMS
// ═══════════════════════════════════════════════════════════════════════════

window.setTheme = THEME.set;
window.getTheme = THEME.get;
window.getAvailableThemes = THEME.available;
window.cycleTheme = THEME.cycle;
window.initTheme = THEME.init;

console.log('[Module] THEME loaded - 5 functions');


// ═══ MODULE: modules/control-bar.js ═══
/**
 * CONTROL BAR MODULE - Visual Mapping Command Center
 *
 * A persistent control bar (like ChatGPT/Claude input) that allows dynamic
 * mapping of any data characteristic to any visual/physics property.
 *
 * Features:
 * - Always visible at bottom of screen
 * - Works with selected nodes or node groups
 * - Dropdown to choose data source (any field)
 * - Dropdown to choose visual target (size, color, position, physics...)
 * - Group comparison with numbered badges
 * - Real-time preview as you adjust
 *
 * Depends on: DATA, COLOR, ANIM, SELECT
 */

const CONTROL_BAR = (function () {
    'use strict';

    // =========================================================================
    // AVAILABLE DATA SOURCES (what we can map FROM)
    // =========================================================================

    const DATA_SOURCES = {
        // Structural metrics
        size_bytes: { label: 'File Size (bytes)', type: 'continuous', domain: 'file' },
        token_estimate: { label: 'Token Count', type: 'continuous', domain: 'file' },
        line_count: { label: 'Line Count', type: 'continuous', domain: 'file' },
        code_lines: { label: 'Code Lines', type: 'continuous', domain: 'file' },
        complexity_density: { label: 'Complexity Density', type: 'continuous', domain: 'file' },
        cohesion: { label: 'Cohesion', type: 'continuous', domain: 'file' },
        code_ratio: { label: 'Code Ratio', type: 'continuous', domain: 'file' },

        // Temporal metrics
        age_days: { label: 'Age (days)', type: 'continuous', domain: 'file' },

        // Graph metrics
        in_degree: { label: 'In-Degree (callers)', type: 'continuous', domain: 'node' },
        out_degree: { label: 'Out-Degree (calls)', type: 'continuous', domain: 'node' },
        pagerank: { label: 'PageRank', type: 'continuous', domain: 'node' },

        // Categorical
        tier: { label: 'Tier (T0-T4)', type: 'discrete', values: ['T0', 'T1', 'T2', 'T3', 'T4'] },
        ring: { label: 'Ring', type: 'discrete', values: ['CORE', 'NEAR', 'FAR', 'OUTER'] },
        layer: { label: 'Layer', type: 'discrete', values: ['Core', 'Domain', 'Application', 'Interface', 'Infrastructure'] },
        role: { label: 'Role', type: 'discrete', domain: 'node' },
        format_category: { label: 'Format', type: 'discrete', values: ['code', 'config', 'doc', 'data', 'test', 'style', 'script', 'build'] },
        purpose: { label: 'Purpose', type: 'discrete', domain: 'file' },
        effect: { label: 'Effect', type: 'discrete', values: ['Pure', 'Read', 'Write', 'ReadWrite'] },

        // Boolean
        is_test: { label: 'Is Test?', type: 'boolean' },
        is_config: { label: 'Is Config?', type: 'boolean' },
        is_stale: { label: 'Is Stale?', type: 'boolean' },
        is_recent: { label: 'Is Recent?', type: 'boolean' }
    };

    // =========================================================================
    // AVAILABLE TARGETS (what we can map TO)
    // =========================================================================

    const VISUAL_TARGETS = {
        // Size
        nodeSize: { label: 'Node Size', category: 'appearance', range: [1, 30] },

        // Color components
        hue: { label: 'Color Hue', category: 'appearance', range: [0, 360] },
        saturation: { label: 'Saturation', category: 'appearance', range: [0, 100] },
        lightness: { label: 'Lightness', category: 'appearance', range: [20, 80] },
        opacity: { label: 'Opacity', category: 'appearance', range: [0.1, 1.0] },

        // Position
        xPosition: { label: 'X Position', category: 'position', range: [-500, 500] },
        yPosition: { label: 'Y Position', category: 'position', range: [-500, 500] },
        zPosition: { label: 'Z Position (depth)', category: 'position', range: [-300, 300] },
        radius: { label: 'Radial Distance', category: 'position', range: [50, 400] },

        // Physics
        charge: { label: 'Charge (repel)', category: 'physics', range: [-500, 0] },
        linkStrength: { label: 'Link Strength', category: 'physics', range: [0, 1] },
        mass: { label: 'Mass (inertia)', category: 'physics', range: [1, 10] },

        // Animation
        pulseSpeed: { label: 'Pulse Speed', category: 'animation', range: [0, 5] },
        rotationSpeed: { label: 'Rotation Speed', category: 'animation', range: [0, 2] }
    };

    // =========================================================================
    // SCALE FUNCTIONS
    // =========================================================================

    const SCALES = {
        linear: (v, min, max) => (v - min) / (max - min || 1),
        log: (v, min, max) => {
            const logMin = Math.log10(Math.max(1, min));
            const logMax = Math.log10(Math.max(1, max));
            const logVal = Math.log10(Math.max(1, v));
            return (logVal - logMin) / (logMax - logMin || 1);
        },
        sqrt: (v, min, max) => {
            const sqrtMin = Math.sqrt(Math.max(0, min));
            const sqrtMax = Math.sqrt(Math.max(0, max));
            const sqrtVal = Math.sqrt(Math.max(0, v));
            return (sqrtVal - sqrtMin) / (sqrtMax - sqrtMin || 1);
        },
        inverse: (v, min, max) => 1 - (v - min) / (max - min || 1)
    };

    // =========================================================================
    // STATE
    // =========================================================================

    let _visible = false;
    let _container = null;
    let _activeMapping = null;
    let _groups = [];         // [{id, name, nodeIds, color}]
    let _groupCounter = 0;

    // Current mapping configuration
    let _config = {
        source: 'token_estimate',
        target: 'nodeSize',
        scale: 'sqrt',
        scope: 'selection',   // 'selection' | 'all' | 'group:X'
        invert: false
    };

    // =========================================================================
    // UI BUILDING
    // =========================================================================

    let _isDocked = false;

    function createUI() {
        if (_container) return _container;

        const dockContainer = document.getElementById('control-bar-container');
        _isDocked = !!dockContainer;

        _container = document.createElement('div');
        _container.id = 'control-bar';
        _container.className = _isDocked ? 'control-bar docked' : 'control-bar';

        // Scope Section
        const scopeHTML = `
            <div class="control-section scope-section">
                <label>SCOPE</label>
                <div class="row-group">
                    <select id="cb-scope" class="cb-select">
                        <option value="selection">Selected Nodes</option>
                        <option value="all">All Nodes</option>
                        <optgroup label="Groups" id="cb-groups-optgroup"></optgroup>
                    </select>
                    <button id="cb-add-group" class="cb-btn cb-btn-small" title="Create group from selection">+G</button>
                    <span id="cb-node-count" class="cb-badge">0</span>
                </div>
            </div>
        `;

        // Map FROM
        const sourceHTML = `
            <div class="control-section">
                <label>MAP DATA SOURCE</label>
                <select id="cb-source" class="cb-select full-width">
                    <optgroup label="Structural">
                        <option value="token_estimate">Token Count</option>
                        <option value="line_count">Line Count</option>
                        <option value="size_bytes">File Size</option>
                        <option value="code_lines">Code Lines</option>
                        <option value="complexity_density">Complexity</option>
                        <option value="cohesion">Cohesion</option>
                    </optgroup>
                    <optgroup label="Temporal">
                        <option value="age_days">Age (days)</option>
                    </optgroup>
                    <optgroup label="Graph">
                        <option value="in_degree">In-Degree</option>
                        <option value="out_degree">Out-Degree</option>
                    </optgroup>
                    <optgroup label="Categorical">
                        <option value="tier">Tier</option>
                        <option value="ring">Ring</option>
                        <option value="layer">Layer</option>
                        <option value="role">Role</option>
                        <option value="format_category">Format</option>
                        <option value="effect">Effect</option>
                    </optgroup>
                    <optgroup label="Boolean">
                        <option value="is_test">Is Test?</option>
                        <option value="is_config">Is Config?</option>
                        <option value="is_stale">Is Stale?</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Arrow (only for float mode, skip or style differently in dock)
        const arrowHTML = _isDocked ? '' : `
            <div class="control-section arrow-section">
                <span class="arrow">&#8594;</span>
            </div>
        `;

        // Map TO
        const targetHTML = `
            <div class="control-section">
                <label>TO VISUAL PROPERTY</label>
                <select id="cb-target" class="cb-select full-width">
                    <optgroup label="Appearance">
                        <option value="nodeSize">Node Size</option>
                        <option value="hue">Color Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="lightness">Lightness</option>
                        <option value="opacity">Opacity</option>
                    </optgroup>
                    <optgroup label="Position">
                        <option value="xPosition">X Position</option>
                        <option value="yPosition">Y Position</option>
                        <option value="zPosition">Z Depth</option>
                        <option value="radius">Radial Distance</option>
                    </optgroup>
                    <optgroup label="Physics">
                        <option value="charge">Charge (repel)</option>
                        <option value="mass">Mass</option>
                    </optgroup>
                    <optgroup label="Animation">
                        <option value="pulseSpeed">Pulse Speed</option>
                    </optgroup>
                </select>
            </div>
        `;

        // Scale
        const scaleHTML = `
            <div class="control-section">
                <label>SCALING</label>
                <select id="cb-scale" class="cb-select full-width">
                    <option value="linear">Linear</option>
                    <option value="sqrt" selected>Sqrt</option>
                    <option value="log">Log</option>
                    <option value="inverse">Inverse</option>
                </select>
            </div>
        `;

        // Actions
        const actionsHTML = `
            <div class="control-section actions-section">
                <button id="cb-apply" class="cb-btn cb-btn-primary full-width">APPLY MAPPING</button>
                <button id="cb-reset" class="cb-btn full-width" style="margin-top:4px">Reset</button>
            </div>
        `;

        // Groups Display
        const groupsHTML = `
            <div class="control-section groups-section" id="cb-groups-display"></div>
        `;

        // Toggle (only for float mode)
        const toggleHTML = _isDocked ? '' : `
            <button id="cb-toggle" class="cb-toggle" title="Toggle Control Bar">
                <span class="chevron">&#9660;</span>
            </button>
        `;

        _container.innerHTML = `
            <div class="control-bar-inner">
                ${scopeHTML}
                ${sourceHTML}
                ${arrowHTML}
                ${targetHTML}
                ${scaleHTML}
                ${actionsHTML}
                ${groupsHTML}
                ${toggleHTML}
            </div>
        `;

        // Add styles
        addStyles();

        // Attach event listeners
        attachListeners();

        if (_isDocked) {
            dockContainer.appendChild(_container);
        } else {
            document.body.appendChild(_container);
        }

        _visible = true;

        return _container;
    }

    function addStyles() {
        if (document.getElementById('control-bar-styles')) return;

        const style = document.createElement('style');
        style.id = 'control-bar-styles';
        style.textContent = `
            /* BASE STYLES */
            .control-bar {
                font-family: 'SF Mono', 'Consolas', monospace;
            }

            /* FLOATING MODE */
            .control-bar:not(.docked) {
                position: fixed;
                bottom: 16px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 900px;
                width: calc(100% - 48px);
                z-index: 9999;
                background: linear-gradient(180deg, rgba(28, 30, 35, 0.95) 0%, rgba(22, 24, 28, 0.98) 100%);
                backdrop-filter: blur(12px);
                border: 1px solid rgba(100, 105, 115, 0.15);
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.35);
                transition: transform 0.3s ease, opacity 0.3s ease;
            }

            .control-bar:not(.docked) .control-bar-inner {
                display: flex;
                align-items: center;
                gap: 16px;
                padding: 12px 20px;
                overflow-x: auto;
            }

            /* DOCKED MODE */
            .control-bar.docked {
                position: static;
                width: 100%;
                background: transparent;
                border: none;
                box-shadow: none;
                padding: 0;
            }

            .control-bar.docked .control-bar-inner {
                display: flex;
                flex-direction: column;
                gap: 12px;
                padding: 0;
            }

            /* SHARED COMPONENTS */
            .control-section {
                display: flex;
                flex-direction: column;
                gap: 4px;
                width: 100%; /* Full width when docked */
            }

            .control-section label {
                font-size: 9px;
                font-weight: 600;
                color: rgba(140, 145, 155, 0.6);
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .row-group {
                display: flex;
                gap: 6px;
                align-items: center;
            }

            .cb-select {
                background: rgba(35, 38, 45, 0.85);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #c8ccd5;
                padding: 6px 10px;
                font-size: 11px;
                font-family: inherit;
                cursor: pointer;
                transition: all 0.2s;
                flex: 1;
            }

            .cb-select:hover {
                background: rgba(45, 48, 55, 0.9);
                border-color: rgba(120, 125, 135, 0.35);
            }
            
            .cb-select:focus {
                outline: none;
                border-color: var(--accent, #4a9eff);
            }

            .full-width {
                width: 100%;
            }

            .cb-btn {
                background: rgba(50, 55, 65, 0.6);
                border: 1px solid rgba(100, 105, 115, 0.2);
                border-radius: 6px;
                color: #b0b5c0;
                padding: 6px 12px;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                text-transform: uppercase;
            }
            .actions-section {
                width: 100%;
            }
            .cb-btn:hover {
                background: rgba(65, 70, 80, 0.75);
                color: #fff;
            }

            .cb-btn-primary {
                background: var(--accent-dim, rgba(74, 158, 255, 0.15));
                color: var(--accent, #4a9eff);
                border-color: var(--accent, #4a9eff);
            }

            .cb-btn-primary:hover {
                background: var(--accent, #4a9eff);
                color: #000;
            }

            .cb-btn-small {
                padding: 4px 8px;
                min-width: 30px;
            }

            .cb-badge {
                font-size: 10px;
                color: #666;
                min-width: 15px;
                text-align: center;
            }

            /* GROUP CHIPS */
            .groups-section {
                flex-direction: row;
                flex-wrap: wrap;
                gap: 4px;
            }

            .group-chip {
                display: inline-flex;
                align-items: center;
                gap: 4px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 10px;
                padding: 2px 8px;
                font-size: 10px;
                cursor: default;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .group-color {
                width: 6px;
                height: 6px;
                border-radius: 50%;
            }

            .group-remove {
                margin-left: 4px;
                cursor: pointer;
                opacity: 0.5;
            }
            .group-remove:hover { opacity: 1; }
        `;

        document.head.appendChild(style);
    }

    function attachListeners() {
        // Toggle collapse
        const toggleBtn = document.getElementById('cb-toggle');
        if (toggleBtn) {
            toggleBtn.addEventListener('click', toggle);
        }

        // Scope change
        const scopeSelect = document.getElementById('cb-scope');
        if (scopeSelect) {
            scopeSelect.addEventListener('change', (e) => {
                _config.scope = e.target.value;
                updateNodeCount();
            });
        }

        // Source change
        const sourceSelect = document.getElementById('cb-source');
        if (sourceSelect) {
            sourceSelect.addEventListener('change', (e) => {
                _config.source = e.target.value;
            });
        }

        // Target change
        const targetSelect = document.getElementById('cb-target');
        if (targetSelect) {
            targetSelect.addEventListener('change', (e) => {
                _config.target = e.target.value;
            });
        }

        // Scale change
        const scaleSelect = document.getElementById('cb-scale');
        if (scaleSelect) {
            scaleSelect.addEventListener('change', (e) => {
                _config.scale = e.target.value;
            });
        }

        // Apply button
        const applyBtn = document.getElementById('cb-apply');
        if (applyBtn) {
            applyBtn.addEventListener('click', applyMapping);
        }

        // Reset button
        const resetBtn = document.getElementById('cb-reset');
        if (resetBtn) {
            resetBtn.addEventListener('click', resetMapping);
        }

        // Add group button
        const addGroupBtn = document.getElementById('cb-add-group');
        if (addGroupBtn) {
            addGroupBtn.addEventListener('click', createGroupFromSelection);
        }

        // Update node count periodically
        setInterval(updateNodeCount, 1000);
    }

    // =========================================================================
    // GROUP MANAGEMENT
    // =========================================================================

    const GROUP_COLORS = [
        '#4a9eff', '#ff6b6b', '#51cf66', '#ffd43b',
        '#cc5de8', '#20c997', '#ff922b', '#748ffc'
    ];

    function createGroupFromSelection() {
        const selectedIds = getSelectedNodeIds();
        if (selectedIds.length === 0) {
            showToast('Select nodes first to create a group');
            return;
        }

        _groupCounter++;
        const groupId = `group-${_groupCounter}`;
        const color = GROUP_COLORS[(_groupCounter - 1) % GROUP_COLORS.length];

        const group = {
            id: groupId,
            name: `Group ${_groupCounter}`,
            nodeIds: [...selectedIds],
            color: color
        };

        _groups.push(group);
        updateGroupsUI();
        showToast(`Created ${group.name} with ${selectedIds.length} nodes`);
    }

    function removeGroup(groupId) {
        _groups = _groups.filter(g => g.id !== groupId);
        updateGroupsUI();
    }

    function updateGroupsUI() {
        // Update dropdown
        const optgroup = document.getElementById('cb-groups-optgroup');
        if (optgroup) {
            optgroup.innerHTML = _groups.map(g =>
                `<option value="group:${g.id}">${g.name} (${g.nodeIds.length})</option>`
            ).join('');
        }

        // Update chips display
        const display = document.getElementById('cb-groups-display');
        if (display) {
            display.innerHTML = _groups.map(g => `
                <div class="group-chip" data-group="${g.id}">
                    <span class="group-color" style="background: ${g.color}"></span>
                    <span class="group-name">${g.name}</span>
                    <span class="group-count">${g.nodeIds.length}</span>
                    <span class="group-remove" onclick="CONTROL_BAR.removeGroup('${g.id}')">&times;</span>
                </div>
            `).join('');
        }
    }

    // =========================================================================
    // MAPPING APPLICATION
    // =========================================================================

    function getTargetNodes() {
        const dm = typeof DATA !== 'undefined' ? DATA : null;
        const allNodes = dm?.getNodes ? dm.getNodes() : (typeof graphNodes !== 'undefined' ? graphNodes : []);

        if (_config.scope === 'all') {
            return allNodes;
        }

        if (_config.scope === 'selection') {
            const selectedIds = getSelectedNodeIds();
            return allNodes.filter(n => selectedIds.includes(n.id));
        }

        if (_config.scope.startsWith('group:')) {
            const groupId = _config.scope.replace('group:', '');
            const group = _groups.find(g => g.id === groupId);
            if (group) {
                return allNodes.filter(n => group.nodeIds.includes(n.id));
            }
        }

        return [];
    }

    function applyMapping() {
        const nodes = getTargetNodes();
        if (nodes.length === 0) {
            showToast('No nodes to map. Select nodes or change scope.');
            return;
        }

        const sourceKey = _config.source;
        const targetKey = _config.target;
        const scaleFn = SCALES[_config.scale] || SCALES.linear;
        const targetInfo = VISUAL_TARGETS[targetKey];

        // Get value range
        const values = nodes.map(n => getNodeValue(n, sourceKey)).filter(v => v !== null && v !== undefined);
        if (values.length === 0) {
            showToast(`No data for "${sourceKey}" on selected nodes`);
            return;
        }

        const sourceInfo = DATA_SOURCES[sourceKey];
        const isDiscrete = sourceInfo?.type === 'discrete' || sourceInfo?.type === 'boolean';

        let dataMin, dataMax;
        if (!isDiscrete) {
            dataMin = Math.min(...values);
            dataMax = Math.max(...values);
        }

        // Apply to each node
        nodes.forEach(node => {
            const rawValue = getNodeValue(node, sourceKey);
            if (rawValue === null || rawValue === undefined) return;

            let mappedValue;
            if (isDiscrete) {
                // Map discrete values to evenly spaced range
                const uniqueValues = sourceInfo.values || [...new Set(values)];
                const idx = uniqueValues.indexOf(rawValue);
                mappedValue = idx >= 0 ? idx / Math.max(1, uniqueValues.length - 1) : 0.5;
            } else {
                mappedValue = scaleFn(rawValue, dataMin, dataMax);
            }

            // Map to target range
            const [tMin, tMax] = targetInfo.range;
            const targetValue = tMin + mappedValue * (tMax - tMin);

            applyToNode(node, targetKey, targetValue);
        });

        // Refresh graph
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            Graph.refresh();
        }

        showToast(`Mapped ${sourceKey} -> ${targetKey} on ${nodes.length} nodes`);
        console.log(`[CONTROL_BAR] Applied: ${sourceKey} -> ${targetKey}, scale=${_config.scale}, nodes=${nodes.length}`);
    }

    function getNodeValue(node, key) {
        // Direct property
        if (node[key] !== undefined) return node[key];

        // Nested in dimensions
        if (node.dimensions && node.dimensions[key] !== undefined) {
            return node.dimensions[key];
        }

        // Check common dimension mappings
        const dimMap = {
            'tier': 'D1_TIER',
            'ring': 'D2_RING',
            'layer': 'D2_LAYER',
            'effect': 'D6_EFFECT'
        };

        if (dimMap[key] && node.dimensions) {
            return node.dimensions[dimMap[key]];
        }

        return null;
    }

    function applyToNode(node, targetKey, value) {
        switch (targetKey) {
            case 'nodeSize':
                node.val = value;
                break;

            case 'hue':
                const currentColor = node.color || 'hsl(200, 70%, 50%)';
                node.color = setHSLComponent(currentColor, 'h', value);
                break;

            case 'saturation':
                node.color = setHSLComponent(node.color || 'hsl(200, 70%, 50%)', 's', value);
                break;

            case 'lightness':
                node.color = setHSLComponent(node.color || 'hsl(200, 70%, 50%)', 'l', value);
                break;

            case 'opacity':
                node.opacity = value;
                // Update color alpha if using rgba
                if (node.color && !node.color.startsWith('hsl')) {
                    node.color = setAlpha(node.color, value);
                }
                break;

            case 'xPosition':
                node.fx = value;
                break;

            case 'yPosition':
                node.fy = value;
                break;

            case 'zPosition':
                node.fz = value;
                break;

            case 'radius':
                // Position on a circle at given radius
                const angle = (node.fileIdx || Math.random() * 100) * 0.618 * Math.PI * 2;
                node.fx = Math.cos(angle) * value;
                node.fy = Math.sin(angle) * value;
                break;

            case 'charge':
                node.__charge = value;
                break;

            case 'mass':
                node.__mass = value;
                break;

            case 'pulseSpeed':
                node.__pulseSpeed = value;
                break;

            default:
                node[targetKey] = value;
        }
    }

    function setHSLComponent(colorStr, component, value) {
        // Parse existing HSL or convert
        let h = 200, s = 70, l = 50;

        const hslMatch = colorStr.match(/hsl\((\d+),\s*(\d+)%?,\s*(\d+)%?\)/);
        if (hslMatch) {
            h = parseInt(hslMatch[1]);
            s = parseInt(hslMatch[2]);
            l = parseInt(hslMatch[3]);
        }

        switch (component) {
            case 'h': h = value; break;
            case 's': s = value; break;
            case 'l': l = value; break;
        }

        return `hsl(${Math.round(h)}, ${Math.round(s)}%, ${Math.round(l)}%)`;
    }

    function setAlpha(colorStr, alpha) {
        // Simple alpha injection
        if (colorStr.startsWith('rgba')) {
            return colorStr.replace(/[\d.]+\)$/, `${alpha})`);
        }
        if (colorStr.startsWith('rgb')) {
            return colorStr.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
        }
        return colorStr;
    }

    function resetMapping() {
        // Clear fixed positions
        const nodes = getTargetNodes();
        nodes.forEach(n => {
            delete n.fx;
            delete n.fy;
            delete n.fz;
            delete n.__charge;
            delete n.__mass;
            delete n.__pulseSpeed;
        });

        // Reheat simulation
        if (typeof Graph !== 'undefined' && Graph) {
            Graph.d3ReheatSimulation();
        }

        showToast('Reset node positions and custom properties');
    }

    // =========================================================================
    // HELPERS
    // =========================================================================

    function getSelectedNodeIds() {
        if (typeof SELECT !== 'undefined' && SELECT.getSelectedNodes) {
            return SELECT.getSelectedNodes().map(n => n.id);
        }
        if (typeof SELECTED_NODE_IDS !== 'undefined') {
            return Array.from(SELECTED_NODE_IDS);
        }
        return [];
    }

    function updateNodeCount() {
        const badge = document.getElementById('cb-node-count');
        if (!badge) return;

        const nodes = getTargetNodes();
        badge.textContent = nodes.length;
    }

    function showToast(msg) {
        if (typeof window.showToast === 'function') {
            window.showToast(msg);
        } else {
            console.log(`[CONTROL_BAR] ${msg}`);
        }
    }

    function toggle() {
        if (_container) {
            _container.classList.toggle('collapsed');
            _visible = !_container.classList.contains('collapsed');
        }
    }

    function show() {
        if (_container) {
            _container.classList.remove('collapsed');
            _visible = true;
        }
    }

    function hide() {
        if (_container) {
            _container.classList.add('collapsed');
            _visible = false;
        }
    }

    // =========================================================================
    // INIT
    // =========================================================================

    function init() {
        createUI();
        updateNodeCount();
        console.log('[CONTROL_BAR] Initialized');
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        init,
        toggle,
        show,
        hide,
        applyMapping,
        resetMapping,
        createGroupFromSelection,
        removeGroup,
        get visible() { return _visible; },
        get config() { return _config; },
        get groups() { return _groups; },
        DATA_SOURCES,
        VISUAL_TARGETS,
        SCALES
    };

})();

// Auto-init when DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => CONTROL_BAR.init());
} else {
    // Small delay to ensure other modules are loaded
    setTimeout(() => CONTROL_BAR.init(), 100);
}


// ═══ MODULE: modules/main.js ═══
/**
 * MAIN.JS - MODULE INTEGRATION ENTRY POINT
 *
 * This file wires up all modules and provides backward compatibility
 * for HTML onclick handlers and global function calls.
 *
 * Module Loading Order (already handled by visualize_graph_webgl.py):
 * 1. performance.js       - Performance subsystem
 * 2. core.js              - Constants & utilities
 * 3. node-accessors.js    - Node property functions
 * 4. color-engine.js      - OKLCH color system
 * 5. refresh-throttle.js  - Throttled graph updates
 * 6. legend-manager.js    - Legend system
 * 7. data-manager.js      - Data access layer
 * 8. animation.js         - Layout & animation controller
 * 9. selection.js         - Selection system
 * 10. panels.js           - Panel management
 * 11. sidebar.js          - Sidebar controls
 * 12. edge-system.js      - Edge coloring & modes
 * 13. file-viz.js         - File visualization modes
 * 14. control-bar.js      - Visual mapping command bar
 * 15. main.js             - This file (wiring)
 * 16. app.js              - Legacy monolith (shrinking)
 */

;(function() {
    'use strict';

    // =========================================================================
    // VERIFY MODULE LOADING
    // =========================================================================

    const REQUIRED_MODULES = [
        { name: 'CORE', module: typeof CORE !== 'undefined' ? CORE : null },
        { name: 'NODE', module: typeof NODE !== 'undefined' ? NODE : null },
        { name: 'COLOR', module: typeof COLOR !== 'undefined' ? COLOR : null },
        { name: 'REFRESH', module: typeof REFRESH !== 'undefined' ? REFRESH : null },
        { name: 'LEGEND', module: typeof LEGEND !== 'undefined' ? LEGEND : null },
        { name: 'DATA', module: typeof DATA !== 'undefined' ? DATA : null },
        { name: 'LAYOUT', module: typeof LAYOUT !== 'undefined' ? LAYOUT : null },  // UI Layout Engine
        { name: 'ANIM', module: typeof ANIM !== 'undefined' ? ANIM : null },
        { name: 'SELECT', module: typeof SELECT !== 'undefined' ? SELECT : null },
        { name: 'PANELS', module: typeof PANELS !== 'undefined' ? PANELS : null },
        { name: 'SIDEBAR', module: typeof SIDEBAR !== 'undefined' ? SIDEBAR : null },
        { name: 'EDGE', module: typeof EDGE !== 'undefined' ? EDGE : null },
        { name: 'FILE_VIZ', module: typeof FILE_VIZ !== 'undefined' ? FILE_VIZ : null },
        { name: 'CONTROL_BAR', module: typeof CONTROL_BAR !== 'undefined' ? CONTROL_BAR : null },
        // STARS module removed - nodes ARE the stars
        { name: 'HUD', module: typeof HUD !== 'undefined' ? HUD : null },
        { name: 'DIMENSION', module: typeof DIMENSION !== 'undefined' ? DIMENSION : null }
    ];

    const loaded = REQUIRED_MODULES.filter(m => m.module !== null);
    const missing = REQUIRED_MODULES.filter(m => m.module === null);

    console.log(`[MAIN] Modules loaded: ${loaded.length}/${REQUIRED_MODULES.length}`);
    if (missing.length > 0) {
        console.warn('[MAIN] Missing modules:', missing.map(m => m.name).join(', '));
    }

    // =========================================================================
    // WINDOW-LEVEL EXPORTS FOR HTML ONCLICK HANDLERS
    // =========================================================================

    // Selection functions
    if (typeof SELECT !== 'undefined') {
        window.clearSelection = SELECT.clear;
        window.setSelection = SELECT.set;
        window.toggleSelection = SELECT.toggle;
        window.getSelectedNodes = SELECT.getSelectedNodes;
    }

    // Animation functions
    if (typeof ANIM !== 'undefined') {
        window.applyLayoutPreset = ANIM.applyLayout;
        window.stopAnimation = ANIM.stop;
    }

    // Edge functions
    if (typeof EDGE !== 'undefined') {
        window.setEdgeMode = EDGE.setMode;
        window.cycleEdgeMode = EDGE.cycleMode;
        window.applyEdgeMode = EDGE.apply;
    }

    // File visualization functions
    if (typeof FILE_VIZ !== 'undefined') {
        window.setFileVizMode = FILE_VIZ.setMode;
        window.toggleFileMode = FILE_VIZ.toggle;
    }

    // Panel functions
    if (typeof PANELS !== 'undefined') {
        window.openPanel = PANELS.open;
        window.closePanel = PANELS.close;
        window.togglePanel = PANELS.toggle;
    }

    // Sidebar functions
    if (typeof SIDEBAR !== 'undefined') {
        window.setColorMode = SIDEBAR.setColorMode;
        window.setLayout = SIDEBAR.setLayout;
    }

    // Refresh function
    if (typeof REFRESH !== 'undefined') {
        window.throttledRefresh = REFRESH.throttled;
    }

    // Control bar functions
    if (typeof CONTROL_BAR !== 'undefined') {
        window.toggleControlBar = CONTROL_BAR.toggle;
        window.showControlBar = CONTROL_BAR.show;
        window.hideControlBar = CONTROL_BAR.hide;
        window.applyVisualMapping = CONTROL_BAR.applyMapping;
    }

    // =========================================================================
    // CROSS-MODULE INTEGRATION
    // =========================================================================

    /**
     * Initialize all modules with data
     * Called from app.js after data is loaded
     */
    window.initializeModules = function(data) {
        console.log('[MAIN] Initializing modules with data...');

        // Initialize DATA module
        if (typeof DATA !== 'undefined' && DATA.init) {
            DATA.init(data);
            console.log('[MAIN] DATA module initialized');
        }

        // Initialize LEGEND module
        if (typeof LEGEND !== 'undefined' && LEGEND.init) {
            LEGEND.init(data.nodes, data.links || data.edges);
            console.log('[MAIN] LEGEND module initialized');
        }

        // Initialize SIDEBAR
        if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
            SIDEBAR.init();
            console.log('[MAIN] SIDEBAR module initialized');
        }

        // Initialize PANELS command bar
        if (typeof PANELS !== 'undefined' && PANELS.initCommandBar) {
            PANELS.initCommandBar();
            console.log('[MAIN] PANELS module initialized');
        }

        // Initialize LAYOUT (replaces HudLayoutManager from app.js)
        if (typeof LAYOUT !== 'undefined' && LAYOUT.init) {
            LAYOUT.init();
            console.log('[MAIN] LAYOUT module initialized (Ctrl+Shift+L for debug overlay)');
        }

        // STARS module removed - nodes ARE the stars

        // Initialize HUD (fade behavior)
        if (typeof HUD !== 'undefined' && HUD.setupFade) {
            HUD.setupFade();
            console.log('[MAIN] HUD module initialized');
        }

        // Initialize DIMENSION toggle
        if (typeof DIMENSION !== 'undefined' && DIMENSION.setup) {
            DIMENSION.setup();
            console.log('[MAIN] DIMENSION module initialized');
        }

        console.log('[MAIN] Module initialization complete');
    };

    /**
     * Global refresh function that uses the throttled refresher
     */
    window.moduleRefresh = function() {
        if (typeof REFRESH !== 'undefined') {
            REFRESH.throttled();
        } else if (typeof Graph !== 'undefined' && Graph) {
            Graph.refresh();
        }
    };

    // =========================================================================
    // MODULE HEALTH CHECK
    // =========================================================================

    window.checkModuleHealth = function() {
        console.log('=== MODULE HEALTH CHECK ===');
        REQUIRED_MODULES.forEach(({ name, module }) => {
            const status = module ? 'OK' : 'MISSING';
            const color = module ? 'color: green' : 'color: red';
            console.log(`%c[${status}] ${name}`, color);
        });

        if (typeof REFRESH !== 'undefined') {
            console.log('REFRESH stats:', REFRESH.stats);
        }

        console.log('===========================');
    };

    // =========================================================================
    // KEYBOARD SHORTCUTS INTEGRATION
    // =========================================================================

    // The main keyboard handler remains in app.js, but modules can register
    // their own shortcuts here if needed
    window.MODULE_SHORTCUTS = {
        'KeyM': () => typeof CONTROL_BAR !== 'undefined' && CONTROL_BAR.toggle(),  // M for Mapping
        'Backquote': () => typeof CONTROL_BAR !== 'undefined' && CONTROL_BAR.toggle(),  // ` (backtick)
    };

    // =========================================================================
    // INITIALIZATION MESSAGE
    // =========================================================================

    console.log('[MAIN] Entry point loaded. Modules ready for initialization.');

})();


// ═══ MODULE: modules/circuit-breaker.js ═══
/**
 * CIRCUIT BREAKER MODULE
 *
 * Runtime self-test system that validates all UI controls work.
 * Runs a sequence of interactions and checks if they produce effects.
 *
 * Usage:
 *   CIRCUIT.runAll()           // Run all tests
 *   CIRCUIT.test('edge-opacity') // Test specific control
 *   CIRCUIT.report()           // Get test results
 */

const CIRCUIT = (function() {
    'use strict';

    // Test results storage
    const _results = new Map();
    let _running = false;

    // =========================================================================
    // TEST DEFINITIONS
    // Each test: { name, type, trigger, validate, cleanup? }
    // =========================================================================

    const TESTS = [
        // --- EDGE CONTROLS ---
        {
            name: 'edge-opacity',
            type: 'slider',
            elementId: 'cfg-edge-opacity',
            trigger: (el) => {
                el.value = '0.8';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                return typeof APPEARANCE_STATE !== 'undefined' &&
                       APPEARANCE_STATE.edgeOpacity === 0.8;
            },
            cleanup: (el) => {
                el.value = '0.6';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            }
        },
        {
            name: 'edge-width',
            type: 'slider',
            elementId: 'cfg-edge-width',
            trigger: (el) => {
                el.value = '3.0';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                return typeof APPEARANCE_STATE !== 'undefined' &&
                       APPEARANCE_STATE.edgeWidth === 3.0;
            },
            cleanup: (el) => {
                el.value = '1.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            }
        },
        {
            name: 'edge-curvature',
            type: 'slider',
            elementId: 'cfg-edge-curve',
            trigger: (el) => {
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                return typeof APPEARANCE_STATE !== 'undefined' &&
                       APPEARANCE_STATE.edgeCurvature === 0.5;
            },
            cleanup: (el) => {
                el.value = '0';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            }
        },

        // --- NODE CONTROLS ---
        {
            name: 'node-size',
            type: 'slider',
            elementId: 'cfg-node-size',
            trigger: (el) => {
                el.value = '8';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                return typeof APPEARANCE_STATE !== 'undefined' &&
                       APPEARANCE_STATE.nodeScale === 8;
            },
            cleanup: (el) => {
                el.value = '5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            }
        },
        {
            name: 'node-opacity',
            type: 'slider',
            elementId: 'cfg-node-opacity',
            trigger: (el) => {
                el.value = '0.5';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            },
            validate: () => {
                return typeof APPEARANCE_STATE !== 'undefined' &&
                       APPEARANCE_STATE.nodeOpacity === 0.5;
            },
            cleanup: (el) => {
                el.value = '1';
                el.dispatchEvent(new Event('input', { bubbles: true }));
            }
        },

        // --- TOGGLES ---
        {
            name: 'toggle-arrows',
            type: 'toggle',
            elementId: 'cfg-toggle-arrows',
            trigger: (el) => {
                window._arrowsActiveBefore = el.classList.contains('active');
                el.click();
            },
            validate: () => {
                const el = document.getElementById('cfg-toggle-arrows');
                if (!el) return false;
                // Check if toggle state actually changed
                const isActiveNow = el.classList.contains('active');
                return isActiveNow !== window._arrowsActiveBefore;
            },
            cleanup: (el) => {
                // Toggle back to original state
                el.click();
                delete window._arrowsActiveBefore;
            }
        },

        // --- PHYSICS CONTROLS ---
        {
            name: 'physics-charge',
            type: 'slider',
            elementId: 'physics-charge',
            trigger: (el) => {
                const originalValue = el.value;
                el.value = '-200';
                el.dispatchEvent(new Event('input', { bubbles: true }));
                el._originalValue = originalValue;
            },
            validate: () => {
                // NOTE: sidebar.js bypasses PHYSICS_STATE and calls Graph directly
                // So we validate via Graph API, not PHYSICS_STATE
                if (typeof Graph === 'undefined' || !Graph.d3Force) return false;
                const chargeForce = Graph.d3Force('charge');
                if (!chargeForce || !chargeForce.strength) return false;
                // d3 charge force stores strength as function, call it to get value
                const strength = chargeForce.strength();
                return strength === -200;
            },
            cleanup: (el) => {
                if (el._originalValue) {
                    el.value = el._originalValue;
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }
        },

        // --- BUTTONS ---
        {
            name: 'btn-edge-mode',
            type: 'button',
            elementId: 'btn-edge-mode',
            trigger: (el) => {
                window._edgeModeBefore = typeof EDGE !== 'undefined' ? EDGE.mode : null;
                el.click();
            },
            validate: () => {
                if (typeof EDGE === 'undefined') return false;
                return EDGE.mode !== window._edgeModeBefore;
            },
            cleanup: () => {
                delete window._edgeModeBefore;
            }
        },
        // NOTE: btn-color-mode test REMOVED - element doesn't exist in template.html
        // Color mode is controlled via dropdown, not a button
        // See CIRCUIT_BREAKER_RECONNAISSANCE.md for details

        // --- DIMENSION TOGGLE ---
        {
            name: 'dimension-toggle',
            type: 'button',
            elementId: 'btn-2d',  // Fixed: was 'btn-dimension' which doesn't exist
            trigger: (el) => {
                window._is3dBefore = typeof IS_3D !== 'undefined' ? IS_3D : null;
                el.click();
            },
            validate: () => {
                // Check if IS_3D actually changed (may be async)
                if (typeof IS_3D === 'undefined') return false;
                return IS_3D !== window._is3dBefore;
            },
            cleanup: () => {
                // Toggle back
                const el = document.getElementById('btn-2d');
                if (el) el.click();
                delete window._is3dBefore;
            }
        },

        // --- VIEW MODE ---
        {
            name: 'view-mode-files',
            type: 'button',
            elementId: null, // Uses selector
            selector: '[data-mode="files"]',
            trigger: (el) => {
                el.click();
            },
            validate: () => {
                return typeof GRAPH_MODE !== 'undefined' && GRAPH_MODE === 'files';
            },
            cleanup: () => {
                const atomsBtn = document.querySelector('[data-mode="atoms"]');
                if (atomsBtn) atomsBtn.click();
            }
        }
    ];

    // =========================================================================
    // TEST RUNNER
    // =========================================================================

    async function runTest(testDef) {
        const result = {
            name: testDef.name,
            type: testDef.type,
            passed: false,
            error: null,
            elementFound: false
        };

        try {
            // Find element
            const el = testDef.elementId
                ? document.getElementById(testDef.elementId)
                : document.querySelector(testDef.selector);

            if (!el) {
                result.error = 'Element not found';
                return result;
            }
            result.elementFound = true;

            // Run trigger
            testDef.trigger(el);

            // Small delay for async effects
            await new Promise(r => setTimeout(r, 50));

            // Validate
            result.passed = testDef.validate();

            // Cleanup
            if (testDef.cleanup) {
                await new Promise(r => setTimeout(r, 50));
                testDef.cleanup(el);
            }

        } catch (err) {
            result.error = err.message;
            result.passed = false;
        }

        return result;
    }

    async function runAll() {
        if (_running) {
            console.warn('[CIRCUIT] Already running');
            return;
        }
        _running = true;
        _results.clear();

        console.log('%c[CIRCUIT] Starting control validation...', 'color: #4dd4ff; font-weight: bold');

        const startTime = performance.now();
        let passed = 0;
        let failed = 0;

        for (const test of TESTS) {
            const result = await runTest(test);
            _results.set(test.name, result);

            if (result.passed) {
                passed++;
                console.log(`  %c✓ ${test.name}`, 'color: #4ade80');
            } else {
                failed++;
                const reason = result.error || (!result.elementFound ? 'Element not found' : 'Validation failed');
                console.log(`  %c✗ ${test.name}: ${reason}`, 'color: #f87171');
            }

            // Small delay between tests
            await new Promise(r => setTimeout(r, 100));
        }

        const elapsed = (performance.now() - startTime).toFixed(0);
        const total = passed + failed;
        const pct = ((passed / total) * 100).toFixed(1);

        console.log('%c─────────────────────────────────────', 'color: #666');
        if (failed === 0) {
            console.log(`%c[CIRCUIT] ALL PASS: ${passed}/${total} controls (${elapsed}ms)`,
                'color: #4ade80; font-weight: bold');
        } else {
            console.log(`%c[CIRCUIT] ${passed}/${total} passed (${pct}%), ${failed} FAILED (${elapsed}ms)`,
                'color: #f87171; font-weight: bold');
        }

        _running = false;
        return { passed, failed, total, results: Object.fromEntries(_results) };
    }

    async function test(name) {
        const testDef = TESTS.find(t => t.name === name);
        if (!testDef) {
            console.error(`[CIRCUIT] Unknown test: ${name}`);
            return null;
        }
        const result = await runTest(testDef);
        _results.set(name, result);
        return result;
    }

    function report() {
        return Object.fromEntries(_results);
    }

    function listTests() {
        return TESTS.map(t => ({ name: t.name, type: t.type }));
    }

    // =========================================================================
    // PUBLIC API
    // =========================================================================

    return {
        runAll,
        test,
        report,
        listTests,
        get isRunning() { return _running; },
        TESTS
    };
})();

// Global shortcut
window.CIRCUIT = CIRCUIT;

console.log('[Module] CIRCUIT loaded - UI control validator');


// ═══ MAIN APPLICATION ═══
window.process = window.process || { env: { NODE_ENV: "production" } };
window.global = window.global || window;
// UMD globals: THREE, ForceGraph3D, pako already loaded
// Three.js addons attach to THREE global: THREE.ConvexGeometry
const ConvexGeometry = THREE.ConvexGeometry;
// Note: Post-processing (bloom) removed for simplicity - addons not available in r149+ UMD builds

// COMPRESSED_PAYLOAD: Base64-encoded gzipped JSON data
const COMPRESSED_PAYLOAD = "H4sIAAAAAAAC/+y9i1vbSLI3/K/0kvN8tmeMwy2ZxGeZfRkgGfYkwAFmdvcFXq2wZKyJLHklGcIQ/vevqrpb6tbNsjHENt7nnInpS/VFVb+urq6uvl/xfMsOV9rs/H7FseDflY7rtAZ37XbfdLyVJlvxzL6N6fJvM/L7+Peno4+tD4e7rc+YeGO6kLbRege/O77rB1giuL6qr69tNJn8TwOLuuadTdkHXmQHXbNjY2rgeNfZRN+lpnd9L4LfLtSD1K7DU3lHZcqB9RUS1+CvK9+6w3zL7jLsdL3RvvAY/G9gBqEdsG1mBtf0u7UTXA/7thcdU06dF6OigX+9fYFDcR3LDi5WmkkezFcncAaR43tQ5GJovdu04L/WRoftivJslZ1GpmeZgcU+wwS7zO9CpmVDxo5nund/2sz07lgHkq7M0GZhFAw70TCwgSA11OD/hMMr3usQus1/tUzLMpL0OnQnoq72+9Ai9JT1bHcAKbs8hUU+s7/anWEExIEsJ/yKbVf+n6yxc7jz6V//d58JwpMSMvkEGPHnSAZDYxukP8bFiqiifQYxyng6WWAP/NCJ/OCO4bDtvhOxqGezjun5ntMx4SMMo8EKccgQvw1xieNjShiZETEV/XDtMCRWdbp2567D2W0YEk86nmHZ14FtC24DmknC+gZyo+kZICo8G/+AIjIPvtLAtb860Z3Id/0O/Hrz5g38Bh4IseRa6z0yvx0OfC90rhyXF8cig2GQ/BF3zwg7fmCLVDk4LbEDTB6YbtJuYHpfxE/LHkQ98bvTGway6+Y1jfGhySQ0RL7vhq9vnHAIpOALXgfmoGfc2lfXLkHGte3ZAcwfTzJ6Ud9VEaQguwRQ3owFKDuDgQvfGQVThZR0sgCVD2YHeUVFlPLx6UizvrWRwpqc4dX/CH3PCP1h0LHbIPl3TeJBYJmBGfXaKPYSnEDwV6TwfxSUQuDqkHDE9T2b/cO++viJye7RgNivZ58/MexVS5Ch/wKuhe1EVLReHEPLiAkoGo4HfWF/Pz06JBrMDyjZMiOTWU4nYk4U2m63lZDSuk+kbnt2YFM1npd0id06rsuu4F9g2sj2WtmROl3mhI6Hg+zY6mw1WR0mp0lNNBptFZkdL6p3L1Y++aYFX5jDSeiEvNfdwO+ze4XQQ6vVItyTBG4d6LQ/sD29uVpQazAzZF2lLUJ7pLpNU9hyocl6V9Cy3dBWyopy04SX9TS8bGrwsq7By2YJvLxdW9fg5ac3C4MvLSOwXWLHEUijFyzBnPXW+psxQGcXJ0FBm/hvATOk0ACLTgdnuP7RZfFg6vgfA0SFgwlb/ZkdkWpiuueQcKlwKMia50dMVkBhx78D3xfyrDN+YIM+4rFDQJ4kIwru8osBwfqx2p9GCxjMd2/sOv5yAa1ubCPy63FzDUUm7a8dYBK2T/9A54u7kpEvZXqnJGXrxUK2XiJjuoQtkIB5ftDnxYnHR4lZtvjcC5s+pDp0fciX81HyRiVhhSPWrSJfSB81YpAmqttowU9nADI0HAxAKW5kxBlrVKEM/YeNBm4j7vXSFytn+6dnFzBg/uvg8KNcnfF/D0rnOF1BqXVtR3VsvUl9aGQlE5SBycVyo1QsN6qK5fsFFkurskRaFYVxcx5kUQymjr/abA/U1HNSFUEeL0kgcTXMiBSWJpa9oB6DSsgXwDiVBiaSL1Z+O/yfw6N/HKqSEKOABeTSmEAikBEVpYpOdcrCklnDShTFEj1xc7GFpWv2HfeumrgkZRdg9YrHU1VmcMyiii46Soa2qYLFSMkqVhGVQiVLG5VyLLEQppqPRTTdgYsV2OjBllZWz++FyGyFA2DEOtWBT9U4X7vM9kNUeUa5nUz3/GlR5TYBWWJiIDRCeHMrTE+Cx7Mw/Rbx2Z+qOGdGSPLRBL637K+qoSQwb7kMxfJTc6yavurVhDTUcvRKqp6SIewcbd40snFqmjpm8LTa0Pvi+bdeTaeHn1IjhQlpKuFd/8p306lfYMCCNiamCIMUBpHhOp5OPklOk0vSaCJT0CGnsnuxch+P9qHdvsf+PrTvE7oPqDEktdG4nyAZpxMDH7YGFAmT76nZB1Xf6IAsRqL7gpNnD3rWtzTsebuI2GNb1/Afzxr4jhdVR6BMtenh0ADmGCYmA0SZ9NIDtGmCkTZYsXfV98KKnZeym2RhbqQQhu+Yt/m/CWqV7KpZhc3vF/sud1edQT0oWGmbzhPjkyUQT6NvDqi/QKKJdBqzKbDv5sgSbH8FUh0Yst+h1S4kYd3zO4fwhyqISpIUsqOTj62djx91IVsbQ8YsX554S+lSUkZq7HldT0uUelhd3a7ZHboTsctaMbusFbPLmg7vc8guHdcMQ6d7Z3gmHrCrbJOTNXO64riMhLCcGle9A/AP85wcESS7PX4Ytysq0DEer4QeC6JeSz2xE2mG69/S4b0sQ3/XFf+C3Z7d+cK6eKRoXgHIxQd+tW813KWJinRWL4mQylOHAg32M9tq5+zEzn75lGhYaiPoSsGugGm/KC39+9//VtvKI7h7tJdPECbS8Rz8TglB07urf1UIilnA4pR8Xktq1ZqM/2WH+BMPKOkvi5mU8MMPStnLRl7f9vY/5PfNG/btwOngh3b6SfcCuxXaZtDp1YPaxcXVxYX148VF+EN9Zg9NNt/Oj/aYjy4ylVIMPH02SH4VlCkpoi5Wp7+n0Obtk4HNqR3cONzF6vFgUzC8Ov4ncRMg2PnkhNG5WKsvNQDa50SY6bqsb5se9B/WOdr6hPxM32R9M/hiwR5SuDsomMSLbbPzS/43FhBbS9mLFv6d5BoEF9vsw8GnfQMgYP+UdDdZsRmTOG9vxoahGNwSFwJJnvwHmsz2gC70fbs2jLqr77IeBbhFxJ52W4FtWvRXgpmdYRAgqPRs7tmwzRTYFXmh3SG/DzVPpBmEngTK9w+SpgN/rYle99Anw2F/ZTC0OrXdSHUNClP6uXOp7mJfsTP4Ol+Y6Fioqc1YoUUb4PD2qVXerWKU2SrZo26szb3SO4E35npr680zumNOjiCakyZUDA3LQS4mfwKD0MQwGq2BiRIg/mGvQQCwrBSCwL4GdIHvwuvGZLCczMsr2+p/gf/WgWvCyPC/bJ8FsD+UzA9wZKjgIlfi48DvAA9Tz6kpVsfdYzi8Alo2+pU5iFtOEEZij4mrdt+isaCiEPpBZFt12cvWtetf1S9Wfmj1rYuVfH8n0SYCw72gRKCWcXCSHS4CZlFZtbfLYbagDmziyaQYNnI6AXg93Fh/v8EEYIM2c49owis88LY1N9NT88ZGdzN0MuNpwk1MO4i+WLmxgxBAjJ9DP6mT5maxj+ZmiaoyTx6aoByC9g/LaJ/WfkKQdCIsF17X0U6PS4pM7djY8bqBGbs7q1iTkyP1lUiclKUsV9lhpqFmPQU1BSOM0cf2rvkyCJoTaNJordqnJGkr4uVRuigZtYYcaqovJpcd2Gig9o7SuyOLs10qrspvLGg8C+1IYRtEDMCpzom3MAl0kYe4jpS032lsDHmK6gkIC0M7iECmekObH49xOk1I+uxwPIEskSoRMq4VOKBCFlbkuam6qf6EA7vjdGGzQqY3QEr4DubQjaReNxi0/gjZFegXwwGgtWffAlx8sT2JP7wNA8jQwTtv6zzp2SX8pkz4mZrEE969U8yFWVQpielLAw3HpimCTYlDeMlBfEpheTejYGOHUfgaPwj+IpAZBP4fsP4Z6OWnIks6vRROxrHSnUHLKojEfxdCR7rTKcjYeJ+CDLXrdd1b+4Rv1NFoIkqRNyWTSsCdtksR2/oyrWb6G/W1UjPgWlUz4Ia++L2fG4YMTRyPMbiLeoTPut04P3dqzIm9EG5Xkj/VJMGiO4S1KWV6XC7NjiTFq6dUgB1TAW4tI9sc708eo9ZqtQsPafds1/WNWz9wrQzRO56r1Zcr3q+Y02T/wIp/EUohmSbZrul2hi7Ms26GPHWoj504NyYr9gbQGdOy6ngnocnMNixKUZNd0b9kYHA0Gx+vvGNZLLr10WZ2hVeM1J6qfiHsR3alNgTKPKm447V2KmqxK7G8Fbe3iu3BJD/5GjSZyK//NOcyn7bDpZLnWMppGxf1BwY3PWVlX5fS3cAG9sG7RBoG0F60CANUTw/ZEu2lOQ3oa6ZkC6/52EYEe8h6Tpc0bIkrzeyKtzWv3N/3O1+MCIZuhHjrKqCdvWY6KiowvbOvp9fKcgeRWp0+Qxngeiy1yksxtDwz/wpVtYwFGTgda8jdG/kGRXcDTK91hx63sSpnNkox7v9Dvg9QGmamydZUMrZnKblv0OEwU/vqLsKm1t+spSqKjA0tA6UMEq9qNBl3BnYQhs8GsLyqPev0HNcC1VKxjlO6sKJtK44NlO6EBvIJ7rTQEqYuiEQKegPwY8MPLFZPfubcP8LZTF2ISMqzbZhWcvdqZ33CjJzvkcmHOXgG9FgvudFboi+/XSj4aOV8+5GQUlTp2fZ+j15yZ5jzhfQLya8VFhT45VjALw70IajlujfFNZQ7eW6214Aa8BOmNEz3nXLCst4rJfJQKdUhpXRGdX6ae4DvS/WG95XV5nk13WRkGH+XCrksMEfGnNwx1HPha6QucQa/83QJLJOSAUxq0c1XISC5LWoaspzcpXL8pEzOg42UsnlSpNS3cKoK8v8O7VRoikdzugirkisBObyucjoPj5PH63EMF5XbRZwa1/Suh/BVYiUzUSWpRJ2HXiD9Nmwz+kc9+cztaSJFchFUqWSWilwasiein/SPDK+jyWDy5WdSyUwtNfMvhvxTVBDGpOD8KZPfl/enz8wb5WvKxoRnDHOsOP1HgnchF8cl5trkQqOorDypCwotb2I94d50HXOAp/66eZ4aUBYXxRYhitfVxhTeP9c3FfmdbCZ2nZZi12koQcZinx/qSks2i+fQ4qe2YMTfdblePIOIxZ9jtKxpRefQAPFc7D593t0sXR02qy4Om4uyOPR9a+iW6zhJkXk8oyoYTr1AlWsWrCv6CnJsRp0eQxsWxppLyjJOnI6xnNB3TfRIzDvPokVmgFRaeO0QbxWHLV4Zb2Pc1xSitbZYcR60K4z9gR9ELLxTNK0oNLD3qIkl5M41WpeZ0q1jbdPERdgg76jtgklqZIl8SnZXaWubLPK/6vJZ3gyf8oTEHdr9JKGZNUO8m+v1zHdds28aosdZSMjJnzdLW2oIeedz4bCDbs1424OXlrfXxL0VJivnuahoHsTYd+4+fBJHgtUixmKQXK+LpvAOFQSWeaNlB7YZ+h5FB0Iy1L9Ub5TzctmXh5mVj7eLIB8YHZi7vhdJiF5iTmUkGUQ9T3RyJEeIS1IRHafcMCUn4dCNUmsET2xxGRIXoda0rDCyfHLRp7Cn1rA/KOhVupYdBNrVJCGnvMBSTp5STgoUy0zunMqHqkVmRCZPWeSFVin2KCiFpWKSaIegGMYFW8HQ41f4qFX4K22hg6SWqljJk51MB9Oalay9POF5EpHoRdGgWLHK5E5NJKrEjPgdRm2hc+vjRUMbSJ5y9evZ2XGsQJHu8tvJJ9bBmyiZdYKXyawUXPdCFhyi2WtjbS2VhRdZ00JwVbu/WOF1uCrlf7lYeailahqGjexuGLl7lOwaE9cCbi2ohAdNjfTSE3/nmZS0n+Za0oaBixehMzKmpM/bgiO6Xs+KWI6EQWHXuQL+hx00NCHqFi4u+cWTRSa1wOQuLlqX8haWKd/CXq4oMOmuGVzzqAEY0i3D7tnsuTXd6UOJ3cwLXMrJ/JV9xqbQr/wVE1XjO1LK2zc8mkHQEXe4db/zoBPHO+AlxM3t+FyIhptXlTJi7xxZKl097pnwkseJEnpbXfYJqeF6Tu7vDdXh/UK9yU5euPH9TK32MHLcsKg6PmmDgSbacvHa2kioJMOTYzLKuhIXQHLiOid59K5kR3yyv7P3eV+2o04d5szsyrk+30sn3rrH+/Y4lzAVg6x9I7fE3AJLZjT1gqOCZs7Gr6mtzXm+ea7LJHUG1G0P7XwUhkE9Gxh6+CpU8aU3xaKYOhIo6qxSgfdYltX7rxTz7OjWD77IcmJMzaU1cXrSRujHT2wMeodkGMdBwG23IR8NUkUuk/F8zhm5cQTLB5ISuc2tlMhpo6l3na+4wuLyweMxxQ9RxSnkwY5nY23tmTZ8hkmt3lBrbmNm8qd80kU2Ky+QJSX4GuihJ7oV966FVsaUHMbvLYV1jRptN/k612g8w2n1evFp9fq8B9IfJSlqlpxaQ7zqo0nOyILTi1I0ucvFxJJUOrpYXRJC1JaXIklgKMLYP89+O9k/NfYOTrjm5t+lqUneV+QkpcLG7UIRWVq8OJYr6KqQxvoexuilSEb4g5ZF+oEhjICUCLFPhTAm/vllA++t4N9KloE3SjAE/zaa+fk4wjjyhv11YGNQICn4CA+ySzSOwZfrixX6dSUU1/iVqCToEldWMdaichsl6Uby8eJ+CCJWZkY5GlnUEYVEhHucCEdJzwg0ZPwy2Klj3JB7bRwPbS28Es7bU++wJwtRtD4fIYrGgR2zf+VcD/1hCIVwMxMaQ09+7CIEGlVnaqGMvjMWlY3zUbAUEx6NS0kfZhuY4n5iKzqqaO3xRtR7e+XAk8x4GnGUen07MnEg2Pn7h4ZIzXz+mGhm/i/T0BgX8J4aiSaLX7SASCQXfCPyeeye9LX6SoUXRhHKHeGjUCemMhp14qKLow515lMdWipCU4Ef6MjAD21+v5ygB8X5mKd+wMQ9OyJzuYo4ZWVKripuoNvbs9ku0kNLg8zbp3wEIXtxooSh1jerPoPw7s0CcVTLGoO1tMLTs49V8ZvIe699MjaTtyrkWCjCVyMTykscjnThQ/fiskw+YlMU1ytv1uqNmY3Av7GwSNmi8p04VrWBfrzXHq5iyitJBufBKqw/Jr3v99rTCNVvElEZY+wiXp4UmBy5ismELOz5Q9diV6R2qbQY0coIWRyM+x60LYv7Fq1zxYUC/FPCbzD8pBGei8/F8Vxy6OaJice4WvxBubKhmH3IvWI7HpdAQj6LmYDZirrF1Tc+2VTsnLp82aIRosL2iYZ6DHrx/uHZztnB0eGcvHK+eHAR8pcxEv42kxc0xoWKarSmBxNm/hsgZv4bIE8FEqNHPRIgxPMkKXRQ6DwWHEQDlZBBeUIlrvadEGLn+PjTwe4SIL4nQOAVxOgu4W6up44LDaOoPK9m/VRQUDbKkSCwj5WdNAhwEo+V/0qCTx24+27Cvnf0eedgKeffS86D+Aphwr/6AxXjyvw4FKcn/5M8t/FUeFB1BkZiQ3y/M4MPOrnH4oR2j3Q0YqjFvxNqHBx+ONk5PTv5bRft7Ev0+F5WB2QPA+3n/Ga9YXoWbJ/7ffzXCRVJGMPyMBbNxUSQ6nMw2gpBDxHQ3QweJ+FHtssJsTg6aQItiWgXo4keg6UKtlRCld+8L55/6wGkNAtb2ChqoRWf6ySt9O2o51vpZmgSShvZLGwkNG/saq2IKdbb0d4arAaRI6BxZoEvHYJpkZHP99w7g99aANHkxoGhE9kTQV4Zselh3WNd4qeGbkXDHQfWkAbDCc4DNEw/RYrTwDMkVnlfNRGeyRY4X2A00Upwg9XGwzS9oejWn7Shp9P/luD2vcCNf60wvWnBeAIAEUb6PKYayI1J9PkuJTwVzI0x4NGmYg5ovAC7cfCWDxqIb3t2ZjNIYR+0Q6YJsC+I1bbpbRWL4akTBe60T7fyMSp2hsr0hceYTY9eugwlvXygNx/lF/jLxOrd7MLb5oLDm+cbsQQZXT+AnVUQ0Mdx/dvqgDaSzPxDWOkQq4IWvhidAS50QxTEkluMdwzpToBWT4wfqdbCm86TnLY1vxcaj42PyXzH+Di7cLb1IrQ1vZrBvbRC/te4StooWouim5WNs8BZLq+i3G7meMbN0Nmd3ueKmzDmhITfyetpSgnX9uqKPYqcstdnFgd+WnSXnmG/j53qmaERO7Lj++hjePKUkZiV62STe+wUjW6kIiNq1htS0nvmjR3feqBH6KdlLn8ajWXjsfpKrpIyBdOPmFkozz9nPNMlwIS3aSLTpYsx0FE8DhXVcooS140sBTz1DLi1UYxbGy94O2b3B9Ed/5rxEszTxlReKhCaf81lxCBH+xthWf4OrOuEUUp3IUpCFtOIVi7Z55dlMpunKqyVlIo3iqLozGoVbxZcOHumZ7l4/XGI71zT7rC6QBZUnn8hzBlYVWsIr8qoJlpB+mbEN90TaBBmelkXy/TO5Gt6qoWrghZ+mYrWEBsb6vFYoMHGJVpYz5QJmlDPaPIGcnHpFVOsU53ADHslaBTzievfNtjPMwxH6+vzdiEdenbdi2AN864dz44R6UCk71NyGnKyuaX3QDe33qv/e/uMEa0yw0tjzJtnvRf6vvha6PsFuhVajatadgXmUgrN0j3Q8RhLLl68cJV7oLzkyFug+lwt738+NwdrB819JwzxZDlQ3IZHMHel+jOjr03G9CPHKFQ3TnTU2bsgwBIXTIx5jVzOD+NteZ/jZ15kDLUuzwCcY+ttllQ8CqwJax4HvjXsRJPVNe/6MO6J6h54N35shRqz7i7Is9+fcMB552ecxOyC2EtAMdCxDXEN+8YOkPwYEJZbecb8JqeAYplhjgVhUJvIMVmbIxd1kf0Vsq+dzgSw1Y03fPfOQ8v+aneGkV3sGM10QhS9GK20wHMwno01Zdt2yX4shUvdWbKCW2Sqauz+OLajo/yWMDHia8pwssXna6/YB9g2p76AIKQ8bqiwClD3KOK5/vqpg5M2u2C19gLA6tq3uDvzOCClVVok5Soe2FhwBLX464MchvjPnhkCB/3IuBtyOBkcffQt8hNvcSoASxPD0ZvG0yFBMgEZFMAZrQACvKtxF5wuo8HzYy+nBdqQazdSMKgf6ZcZ79VOlPkDzK5V7KcXAEUDdC6WD18b/iBy+s6fuT7ak1NZJLAqHmk19AqH19e4hA/oGRhBh6l0SDLx/h5uB39k+CQKbQ0nA7NrOzJyEEzeZ3uEAtXlz7XkUf+N+jya/pQRUZ/TDCrSp5sQFo/xAR6Bi7MLWO8WGLCubQ903shOKslzbDoUq4JWFUjMv7G2ykgLTLmZWqlj/rpMb5KRKogapY6KFQ1TuSgQv8yb6dNoF0QnlPbnOifT5OemjdyzOl6E/AU2sigkRwo94QXLWksqoY9Eo7xjSLWJoWYbyxtr3wNP8jxiPD8mUQVPKpBYBNVnxDBH6D3lnkOeH4taBkuKNQHNa0gKV1wa0OdyZmVqc4FFqmebbtS7i19HNPqO5/RNdyyhqkRkEcRq5EBHCNY/bNddje9vWsozk4q3saBZLGQFm4hX7BfTxZXKSo6mMPgHHU49xRFU8blKhQuh0zjJopqT9eAV++j7KdPsiKEKk3erQ6fnWfvS7OoE7xcYwERZ8vXH9xjJj6sSahXXXASoyh/dqIXf7PQk7miYhG9R4hPPDqIWJzVb50bTMkt0eUB0bgFNLAptvSu6/tLCJzPy7aU5hQeB46OcVa5ANt3SEjCYTuAM6MUMpdzsAtK8+VIjd4IefQ3KcHAXw9EJpJ6IxDTgpPNKvBY3WxvP+HpFeihpQHn3vK9XvCl5veLNAvkpjuYgvijRA6HG5qbRMT3fczr4MCMUCsv4a3TNWbnRNw7zaatZ0eAKrGJyZlgfWIRhZWZ/NTuRe8c2N1lMgxGNHI9HURtNWalO17O72Hg8HeCkqE5mqU2YVFjt9uXFwWyrTXYN4H+frvzwLE5Jk91P21w41OaSA4LgWGivHFvmympOTeaqWKV/5x3xpy54RSMsELwd0BNTjM5lUNIBoWFnwdCeWOgS6hlNsyaUy1qT1ZLrsvhXshPEv4QJH3/+Snd0oEyK0q+2O+BVP9C9lIj/QUdwlOp4Fk/6BODCf320ebEUKaHPUqdw5+hT4c/DSP7cg3kO/DtO5Jeh41o5VE6hMB8YqOj04zMos9e80lEAaUBEUoy5IUPm49AMqCsSqPH3GQhaiPdv+J+fzeUN2e8GQcDcqqjJOBWmG9pjwNEIKgsGTSWjLYAp2HOtjoSpD0hgYpzSOpWDVXtnRyR7MBISOt8auiTXIpok/uRGsBxE8brO9TAg1wMqdwN8G0MZgAVoHU5XRB2q5e6ScZ+LfcdNrtbV/J1u/H3kBNWxcgP3sDRNpO3U7jHxoSYtB4dHZxiYMyY9w6rNuwXFFQ9XL9f5U12/h16nhxYUazSgjKw+M6+/TowipUMs0XKyGj1HEP5yNYtJMLMLvWaymfwojVVBRZXaeLB4RGfgdwzrjRHSGw9WiC/sVPAHSe9uPJpYjm8BBcUwnkV2N4tlt+Qly62Fl119geubg1CG53PvxhHiUXTm3kxQbajjKgVQm0U+i3q2k4QyTEqiWRwmCdhkclMCNDGAuUJT9X2OotBmNWnWy2gDpEG0VY0+VUCoFlBE+PhlSmj6Q7t4V6QrHu14V5Leq2jqR7tsPwIaTnB37AOWYDl105Ztmp+b+tTDT1J+RcHZ3bEsvmYx5AorKtzuldn5gg+oq/NfFZ1G0VkgdCobagE6iW2BikuyNoJTgg8TY5DsFG8hu2PZJQ4HCboTfcGPmRV+H69gwMyeAIj4/Uz+oR/tnNimm1v5g+//Yga/mH/WmiN3LVp3x9d7FEBlFxd6dWpKn3KW3tzkT/4Mb3HmLmDI+EjEvd7w5RxYm+1xsCdbc4HQRh9cAb5wnz9oBK+8o9sQnkuvus4XFLbBMHEsnjLqFItqrZYS1CqVsNepajMrkVsvwOgQkhe4DWOKnBtljz2e7aGMygIJavFAiwK5aNsVRkYA5Umcvhl1euhmCHRXFbru3cTi+oolba4SYaYQriTW4j1lId3yzKZS1dP9k98Pdvcnqjp5q8kr8aK2sk+pRGD36PDs5OjTp/2TmMDSEjo7oKTZCh4FTBlKiwxO2mAr21SeB6T0dicEKivyJ1FByGIzUb0J28MPJSrGRqBKFc/2T8/SFZfA9MzAhDGmYFsNwiSiS41GoNwqM+O0PDHWZIZVeOcxI/vy7IUuKEU9m4UwgSUx7dZHQUiwUXXjso6HoMEGOjHndUy/OxUPcYZjTy3qtgS94LVjOIM/aRMaZjDWzmQMQnO//lcca5FR4QbfIRaHG4zX5KIKC7/JvS1Sx6iPOhvlLxc1ZUuOx0Dt3jcOj04+73w6+L87ZwdHhy0nsvujj0pjRwdOq1FoJTxUZ4fV7nkfHmps9Wf4i9eGv8S0obNFSiOaYZvhm4XdDKT8GWFeUmye957KowgtwFag0lgrmSrECQZ6CAE42GaADlcaLSHL4RTwoAAHqLMFMIAXc7JQwMkVQ0HKHKNgQZiEIL8SPlfqWLErSxh4/ssWsedM7DUY+iA6FTyjSqvO/3WLotEVCLfqgpTWeKkeyzMCTO5bSSaE7XwXqIyGLkpvi67U6W8U4grdxhJqD5UgJJwMv+yxlNxnllwnVNYi6IBZYa3OrzM9D8bv6gydHVyBqKoFE65HddxjVI8WznjJa0ztYE9rWDfHZ1faJL8qwdjolkOM8pb+i88so8gdYwtpQaX59zPOGViJeauCiCZ23OnJqN50jkylrdyVSeXLe9753FJOn1xONZPFZ26dyRPNonIll9mnLI1zdZl9s/gu++aLuMqexy8c1oUJUH+RFTvm5F+znZxS6UqxNgcLRdkAi667Z4wbevAW3LCYYcS21mJH88ySoexssuQa7OdtqJ01fKh33POaEbfcC6g+z2X3tWK0X3sJl92LZcnzDWQoyXJjSmJe7bmXvvSgCv0auB1DiJm4IeJEWDr7nOpUTiaELfMv24JGk4dTcrur8nyli4zWLjyCWArbdxW2DvRdXkYi1gJ0dzhTV5e5EiJzL3oFYyt8w46XTh2oCc8Bcb7A4ykWLXmyQbzrMNZ97PRNqIIbCpJ+wUmjKJXFgeLzBdlhKfHyiTJsVV5QmGExnzdrJLffwYIwMPmXNq4xfkZgOm5IUm8EQ88Yek7XAR2NgsuFjraKFhZ4Pm+dEVuoEWNMS++GIr0oubkDFGfmhuUEbXZsRr0mI+6RfzZwYbKcTiQkQ2ixQ7zUQ5SYpCQCmMZuPX8/Bd0WaA2GkSbOgnyr/wX+W4eh4G3MbQw002SEIob/hf5sXIgQebZ3A3Lvhy344QS+1+r4g9g2gkyFTkg9KAIwVj/ZPz4yTo6Ozthr6GwYdC5W6BeWu1hpxBTPL1aO/3X269Hh8c7Zrxcrl1A9IfUjq0Nz+BMmG/6C8mglqet1mjQbjbifnb6l38UK70IROtG8cu2miour0C8loStnyOlTPHSoeeFhdexDC70hg6gOQlC7jzv5gCadbuD3WfqbMkFEhFC88OJw7zKootQ0jAz++JMjz2apT9Nm5Seq9HdhfloA6EHzt+9FUMoOKNK3hju5uc/7UsKos47HIk9miHX8+G0CFkKYK993NYTZ7dmdL/g4iMmwqO/BV0PvPfxTEGJ1bPN1n5b/BsU01YAGGZ7aEaKLoT9BXJkfMCWVv5ZOqSTNLde/tQOJLiTRSum+HZkwUaaocf/Ai8kXHJSX4lBfuIcK1DuOFdhd/isew8XKQ1IHCOI81PuWaA0r0HRxlCktd6gVyzHNAg5/d9l+t4iijaLqdHLlOpU1U8GcpiDTyvAmF2iiAbIsHhZ6zZ+Fe01vr+nHJU4hkqh7DiGLFOuIp75ix4HdBcCoobDXGMYQZzWEgxp6+cJOXfwB3fG7ke0lO4l8JFEwIx9fcpBEakYCF+RwOR7wMQtswIELwBCFYL55ghneeZ1MKtWgvx6mLPYbpa4NG1VdG94unNjTkZlkY30bkc1amA2EPrS60DsVqd+DH+eghTcp6VIDgP2v8JEwGktMAB0JsRy7umOOpYm6DFAumhASRqlCxPSchKjIPr+MMUN5F4gI8M7lQAYn72kPJMkVno5xuTegpcUw8BxUETzRD0figkz4Yt/Fuw7RH6iRMjPw1s4hA7chngYYPG82l/PUC0aLIti2dW1nZTpOXShxplHlSPIn2IifFwsxVWPq7jNvqy9YWBdVqhpL6Wwy9sbC8fUg8P1uDmen0p/NHfaJWVsZVnXm/uC4GP8v8hlVXw2A7W5MT3B7m3VM18U3Q4EXfPfGtuI4QHlMr5iBbFo9yIKclTl9bbAVITGkQrm9jUoeNn6xQlY2WYo6MuRqpCiW6Zvs1rQlba1UNVybzOt1ASQNGf3Q/yB25OGBd4y89DEwB730+VFJsVK3nTlZY57hSYqSFykWyIvnMTzHzyI5HPI3BvEyoNi4+142KOVj6MyM6+cjuFY75ywZb8FZJ53yUzVto6O8nBwKC0fITRy4H/FstEhwU2H27PNGGnJgb4Dk6aPE1p36h4N/nv12sn9q7B2c0ElH5N8ZHf6OlDAfGmHPtPxbcRIy+HKtbUnivU7cUAsGcGPXbQ/WrY5tSKPnNtlU4uMOblrBALt8vHzPprjACsvOp83Xn7ZSt73owUpH7m5ayjyntkbUfXq0aZtbeFVbSzPP0JK5HiYJ/AXXx8Qei4e0sSmZP6Bpm19AkQWcEhpAe8pr5pS8W98v2tksSvcu6jeHKAgnXIU5S4AojVGjypaunpvLxfMR+tpiLp5lDCW8ebCEIbRrjAHK0W0s1hxNqXQB/WkOF9CiwYrHDaP+gM6ys+toZh9Duy9hdxCeeYeCGsP1OOvK53zFl1th3ZhshVTO27jHAlCS/aVSkIyl1Kis3BKyXeBqIXoUe1ikzIJ+JCmk1sDBHc5lK/ziDOq4aMnryUGeF4bvyZHTIq+4UIFAo0m1wIqb7QxVKO3Koa8qOU5eb556BX1TvIKWvEm3sfHSllDhkU/aD7/SxCUAZv8uBFaV8jY+nlWjuXDINnrYIzEO55ZCuArVX9wYq/foRauGGolA0ETbFPYu6+zwXIi3MVeQhyPmS8Y2Oy83w1Wyvl3qe58ZBbe3CwluvufZtIHeFW+A73/tuEOAoXgXl1XGKtZZWtuW1rbpc6NqMuvbUQBqrwHzLI1Ilu3Bv5700BmXb8ejvqCWufKBF5joyH7GRFVm85lV3Aq5HYvONhVi4RMutyMsfKKhqZnsznq24oNFr9nGdjvcSsEKyeeELHeqW0TK5Gfkm/yUm4r8m1AT6J897Nf1dX49cazImgL1oqgv0Po8m0a59YW0yh2QJ3m45+NbIF3obES8eUodS6HWqLLLVXa5yk6P+9T1j3oKM3ZjBo7pRfRED686Do9WpzgrQcOmu5gWj7lgIT279eUiiI58MJ30IgktIejSxytr99sp1q/SXNGiCgtA0brKa3PicW87WEMk5pG7oy3gWPRunainUMxZrddLl2voUGbFXleX7PXqa3ZcZ6O8SRhmps0Ntc2NVJszGw1tY20Rl9M9KnQalzmQwpbGqdKC01tIq9wjWC6mC857LYUGd3OwnPAPfOixMleWkyhdLt9OmV2facnMG+tIg++hzx0Nkg3TlR/1pKMEevbFu9DvYtyNR7JY51q660nHsZpUie79Y+WCYB7xBScknrnt9Awr51bxyrm1QM+Y0ptNZicyhAc5+SuDogiDE0max3Im59miaYxYCbPjSKPJetpNWRuLvIqPEtnGu+ySIYVH8b0KJ7zsBVBSamk3zCOnD72CBrDQxcrG2sbb1bV1+L+ztbU2/Z92A/1i5cYOQnIlxuJrrbXWeqqAuH7TTj83ep+NgMFvwrTRyepe6eDDa3MweI3IiV/5M/4Lwq41ozQHX5x3ZkRBgj0kP6rFgvrIQLyhmIUKSiJnxCULynQw3ohlwxYCS75byyeEkVdGlHzAv6cPM5ulAUI2K8cBmrc7Enkwk3o3i+fEJVXYGV1yalrOI40C48NQ+djidVGRKoZnoq9BfXgN28k/7E6858b9Ky6XhcDWkPf7RGt0eS7VdB2pxOv2K/YZNsbxUyQD4DJgDXE936bmEmrKNX308bx/EO0JZ1BMlx6kAkDpgFfpYGH5BE4LacYIqnR+NxbyeAhJCKS1VmudoaGBBeYtH1pwY1vJHUjCCG2E5zEOX56vXZ7reHOp9QwwnP11W6EDf8CKqJXJEH7qayJbxVuyEqVmc20BlJp8OYNvBzprZHsV8EYvOytmyGkhTjK6J8EcH2WwGG2ouVsnvwzW1cWeU9vmVaa/Sj/J9apFEptY6aOAELBDrCZBhdVm5oR8WtKUO9KpC5Zc5k6d/tAF/mZ95ytu26/oZqL9OrAh1bmRL5O3EsqZhUxR4y+pT5rmnl9xvbDiMOIWnVRNKit42SEaesiuexmmZ+ROQm48km2Klof8xA++MXP9oVm9jaTrOY3omQWtXGpjfuolfbJg2hvzFqT9xvnTiPwvtieuVLu+aYkEzUCRSp+ZcAFa/9OY8j5tmlBGUecWiWPFpkk6qz+wPcprYCSPbjagxh+h77WQUL3beOrINOvFkWkW6KJ/igeTBcN3QwPFvW8OQnRKvvb6eevhiLIzswiOxaujRlYX65oR+H4c9yUuL5ZAtQwPHdnp2X1TmNChP+IX71UcVJITaYm+IsOnV09VkLRGG0k57C+UxZ9iKylTxS5WpP4XfIsh3V48v4wXX1oDumbfce9AhUY691Zfi0eDZm+rj/buuDE9Lo7VF0FxlGg3nKIIV8XNXTDivZ0z/uPoRKTs/3Nf/jjbPznc+XSx8tDOBKtPqKW6SxcxP4vguKJ71L5Srs3u+Y+H5GAicuzAoOnAEYcw2kbSd6s/zcCWU1rw5s4wnwc2/AlIcpBA0TZMz5Ifc2C6dhTptzXHqTMr29nxsafCAHMxSKn3GBRKyFTFoVTDcShdmN8UDlFabEoT5xEoqtuiuAxFQpbxrMXtYuX4ZP90//CMwmVDh9HTE8oiYEipJ3piokh89Soper8d/s/h0T+qkopL56BlegyYtcqztKFMhIazGW5lfX3OMAjp3Q3wTBpfWDE9tK8mXviu0/myH5fI3v/IyZ+ZB5EKRpYGnM3lu0jfmavEtW1MRf+CPqK7ZUf0ks4ojhtVd1bWvAmYUb/nnTvCAr/R/0OlW6J0vZGERqFAKbI2biptZSqnEReF6PHeVouBormPKLMk37VNnX3brXAAfAqLSbsNDZyvrl8mtw7FDQdlTEnlB7WdeK1DixJf6NJNN0UuzB7txfU5JTcaOY85T0dhzFinmDBkpuheB/5wkKI6s76j62uLvMipkMJvChuBbXZ6+MTAOHCUV3ex4Cg9wgI4+pWKpUAorsQvgtFEzhgavWJ8gNq7o0m/6yitFJMhScM3shuqY1+cVQRowwJAGyqAppAZBWi8x4A82c4l8FM6LPocKoQucej745D4PDQoY+CHDh75jANGhQQWC5Fyh1n0UqRSVpGEn9kaX5lnEZLil4UJF9TRYr9RtgtGJeeCD20+xPvNIkn32R1AbslWOi9/VsKszeRO+oWEVxuLqTjiY2CVYOROety6i7JQ5I+waCdtDgbfcR9NfV2wfbQyo6N30SjrUTFhyp6A8uxqtOuLvOapEFNJo52IwGIB1TQ1WprOGYOqpUY7r9L9wQyjneODEp02v8TygGh5QDQuZ3Hg70K6OXCMAObDDgs12wmqT23NELdn6OazypqZ9OdZQwqGXKbtXtvRa8DW6LUddYAQMAFF53omjVd0eB50XnQhKVZNMVfTTDGg8uhTI1gAI9vA+9Ilp0dJIa0F/GrLI6SZBazgcYAVvDzACkYCFi9GmGUBC0f2ErVGoBaeUGE4xyAsBpikTIwvyUSPBjH+JYhAcRtKIb2RJWTNBmRV2Z9PTGRR9uilA51wly4mdeagarlTn1tZd82wzI0zL3959rQ8exqLqQTyY+rIDfp4VRdW180bcNnWnIp+B+0W+zkPuq3jWfbXYpWTsrUdM5/QkQqteUVPERXRpexJ6OJGfnkU9f3RqpKqOwmBhVFzi4c5qZKLFGcMr5YK7rxK9zEFuizRcHMLLFXcpYo7HluJCPZ3vCp/2MQyru5g2romgMZItqtCYGqLBjaCHKlwppr0PEtH8ViLgt5D8ZSj1eHRmYqqGPte0GB18ZSKQV0Wkd2nuJbw7uON07yGZlUjfsXEpFNgIblS4TTiGzKqFqvMZVI9/vAOf9jNSx6RyYyAXo0BpAmiEFc/DOSHtaHvl08SXXOp3Y4NVIJzLf7iAmhH1+PhVH79hYSp7FCrodTOyb6GULc920shxlkwtJ8BmLCZ2d+pq/BUvLHOAzEAMAW9SOHOTsAM693vFwl3FMTYCewdit9+5Ll3aXwpKzczr1bNpBr+Qh7YmIjL+CJFT9AmJejBCP6SQFUurEJnZgJ3PXahKx5mwUqHjxHGNmZ1jZPRlgG85UPx2Uc1MLKLeFgDyp3n3IFr5rkRN/PPLJt5dp7L1LMS462p2bcfqy+bcoT05kjuC4vtbGx6erHDss957LDL/PUzp14csRqniPGo0zJ0Nr2k3KQP1mi5/i36VORToBV4Rh94XCiVXDUV7jnmteeDStvJGKZKipUujG9f+Lo4WZTzxVoXC3iHL2eBbYYwLiMc9g37P0PTDY3Ij/gnqMCAo4ksytlG0RgLlkN8YldUafHoiPUGPXGgRlogAi9wMbSAgaBczgmKYSW8pdcRe0Kq6oR0aHroezb5CCZ15PbPdG/Nu1B9p2Il3Qn+dfB7iheRkUwr883iSrNro9p4AQuieNkOFMyg73gOpuU8SjUxgUVBqbzxFSCUMjcY7tIadmwG7IuxXfzA4k/Imp3AD1GFdyMHjSvB0Asfj1cFGMThgCzJl1nl2SAN2PSu7fpmI0fvnQaCjUKxdNlJcEwZaQvDf3pW/T5fB79YEWCEIeUxKrCGUI3se1azi1BvXw5CJQmG5cPuDrbS9L61+rjzeJBVleLCYFiVAVcANTwS9K/wJSfy2DNdtsqinn3HLN+rRQxmHMCk/BHsKSHb82pXrxjRZzQmxR6OwjlE68yV3cUcKzVXZhQBG8pXrxJqJ/YqtoTrgSB2jU4sMJX8GXFqp2DAG+OMeHbxa/NF4hc+IC+PutRXV8OJ8auU4iLiV+GAS6yolE+PBCgCWhfnW2GTAbEQL73h1dGwwT0fXq5hVUyqeHDBi+2lsStC1tr6MNluNI2Luz0bA7+J76LkziyObczb1TT8GJERbQi3dy1oDEzEqRPBzO5/pXe6hFO+FhemoMzMhJbIHV8aaH5aBpb47pzVEj4G9HdIp2OxV4eBoVCNKPxahf0qE5qZk8SxeVRbDEeMtMhtBmZuNaSpY5ICAwqxKw3ebnHNwORuNRSL9uz0n5nlz/auHQ9PwZJP8Zvn4POwprtPefU8JxherUVv3v9p0wt+9TDK8bPp+f6XMHnsvgUjulhpaGvUwAxg+XDJWUYsMfw0Ls6InxGKj++Eb8354Fy+vs3XswGuZ3G9S92V7zOes3Ydz6KJinow4sTzKMe3BsBgFx+sk7evY3ca+YZHBwjCvOIYmVo4h1Y5oeU54gxAFogLfK1HgVUeiUWDqfQYxwEoqjsjyER9mTlkuvKjnpimuGt52LQfBH7wi5CqAlTRynCiE2CTyMX6MwpTay8BpjrmAHeBoYHSaYT+MOjY1RGqqPaCgFPe8CrgkqwGWgAoBEpdktizDZBXLOexvhl1ejCwBVGfQBb5U7w2WiA8gOd6fZCDUuhipeLY9nZKK2o06Yg57/Kf2kbqNDqhQMldFDp1UvFDQL8UCmJEyheKvbSSaksl6qnRCa2Y0dkGOnyCOOe83FpaaGlTWNoUxuQtsXjRNstALDQACEJBhvipCvNVorIoK2HxKAsWxF1tE4saHzDsKTIzQwJs/59nrZP9nd2z1tram+UC+BwLoOX0w9wFEDJsOm0JUw+dav5fM7oQbi34QigCWQiDkukmXPsI1KpKbkHgq8pwC3DsQ1w12Tnza21/P/1nFsrWFwTKzMFgfAjbGQxKsQuJpjALqpSClYjMWxmk+vIt4711Y3/36PRfp2f7n/EJeOjgEsC+p7al28Ueo3GNprQoWlf5SIs0LzLzgeTanoV6F01lazcGrwxmbSyIkdRGw6QhhWB8+EoZP0uALNVSCtN0A2kZuul0coBuCVnPAlm/whp6zI1yuT5WmQJLo8PS6DAGT7W4khbDz0gey6vwfIvaaSQ8m6e5oqVGxBcvtvoz++SE0fme04kuM0vZJ9+0FNCmQz2iI73XZkfbTkhCv7zyJWs2UX2RQZ1rjjB3NLGFgW/HqVcqjutzo2NmxkaC2UyLa1bNjM15wxA+E4sC5/oaxGyEYe+V4tGCP8PYLFjZjJbq2RjGtGqmNFXfs9aN254ZVbOaJTvPf/y6c5ZzlPSKnXI/fjr402eK1eVENBiMNHT6jmsG3H4qzguz213eOz28V0KVht6FlK8DHh0iyfqhya5huPdI4anRaL0YjUpCpLxbeDRK9nUUzIqz9ZjINJLGgqBU6TirIlayBeYHEvHtSq5S0L6Y5pk7tThdp0PeRBkQeyQ4jUamUajEd48jjfhjWcfo1mMn0sE6jdT7dB+siT8/232/ydEcinzliSfwwVbj20p2xEwxo8iHIzqkgWYOpi1x6olxCtiMPtaub8FHDQLIdu8Orj3oTQaPRpWdmahhM7hBfiExwybkNBHa0jVhDuW5Dd1FJXrj8OFoSgtiJy4aYoGB+BiLs2HEw6THnv2ItcCFArCFzhliaII7XBw9O8i551Ztv60tKfQ6IiwMkQ3LcYAmUuo/+/spw9EmZR3Mj6icnkHHbzK5dQjsYJ1JYh9o6z7sdp2v2xcrrT9oNewDd8Bft/ibP2wmAgTjoxzd1DW6busWJMiuy6HGE2RaVt1ssqsGD74pdvom+5Fd/feFR4E047JCt7jLrfBDXGEltUPg0X37A9AgYIjb0BfSHJQJjIK7dsGVPZtHZNXAy//uZoXNBfKjxeOoPSeEve7VEDPE5cqcG3DlJWclsv0MLo4vJK79REzGFzS+xRAGUDoINCyleHVOrExuQZbJESMtWC1zLL5yg9Mzb2wWDuwObhVpi8NUgoviCgLjwuJiL1gfjGP/GnpfPP/Wwz1m9hQ2pRnsRMy1zTBi0HvmdxleCGe2NF5REE1lcuQpOF2LMYm6idQprfXFvsPHUWH7bcZbyeU9k+8NXfzcX0pgzwwzLg709caFsDHILpRnyMgRF0BajvuFBmmac4gQqMVwEYkBozKINUZds0vuzqmzxm+9UXNFNnicW6SdvpYnTPNU92FWXUDeLeLlONgTuldm50vxBTi1xNLEtTRxjcNV8ult/pcR+Ubo4DQY/xna2NHIcV3j1g++hKP5bzxai+LFXWG4BSveP/C9F8F1jCqxrum4gLWckEgjQsm98hjw51yTzzmB5iONo1b00QCnXaC3b2xuEmRy2jNLnmt79USXZz9v44KhrnWmVOg3k96K1U2v+6BHCc6/7b68iPnUmIXny5/tyATd2tz3AqfTy7uJWVxqViLiz+CC+ELi4Y/NXNlLlLiZoR99Ubga/1UktID3MTPjHH0jM9S2e3yxAS62mCSxvJD5HBcycbZzXcvkZyi+6QQllncDvitk5XkkoShOBFtViC0KdI0aaxF8xQYS4b71koBsYhCrgmAF6FUFuiaALRMKzyh0vXmJ0IUTx5nW86cAXoXkFhK+ckc7GsCkq40GYShnCw5j3/1WuYCt5FZ5ZcjCwvGHmVH82ngZ+OX5nqiaxLUF8Zt401iV3oIgWJXhFkAYyNcqdw9MntbOQ6/H4tY8+wBO26Uvg9cxsVQj4xuEZ9BbcGOOMAw9f4REmsPIN4TLLDoVdXxg6TtCsx3IEpd29mSGik5F+bNwvFhlhGncWXtKu+qULm2k7KqLyWQtcYvpzri6k9VGMV5RndKlb22KvPgb90qfPivKJTBngOL+GM5Lm4E2TLfSoyEwjgLLgemENiiY0QFyFCoPtkWBPgBgT22bnRzt7H3eOWbHPRPKvYElYPqvkRA4auy/prL/xobG/2slmqLG/2/nn//JS2wE0JaVKQHbrWdyyJ45rM26Zpf5Zi+Ic/bj2K1ljcN4eunp3dS1fDzOV7lQSRF8+AGUeD94QpyNyxdZQ/g1oC5wQi8pzBwPWNTrZAN7CE07bx7rjWd4+GkyRWPhtNlCXqaKsN8wBoEN+y6Df6+Qe+hUkoaRFGbhLvu0xKN0sEIhiWlmpQdrMl5VfWhSXFtH15uQ/S+SysoRDLHJOr7XhW2iVab31XkzIByBtqEVdjEkxA101FDOExDUyM/b7N3azMrn1suSzzDLcDAxfdOzqktoOY2Fk9Hi4Y6W0rCClO5yYo+TU2yI28zL5FQ0tZTUOZDUDqlHac7rJlpbNWEdSWbBtM7Rgx4ttaL6KMEVY3mc4Iq2Rq+xorWnlF3el6X4TkN8xeu5GSaMX9WtLsKVSD2vGP+uNv2Egjxy6KOFOSYxSpzjMT1OoOP2bJg0t1ym4yaXK/IciLQTptlQ3vzODwDxGEILp0WPGPNoOQYCoyT4VKX4OCl2BMaUy6/W4FKG52L/G9w4Heg4+QYkvMiTx9kDj6IzPQk2BwNXgQYpyOnk594Vl03AaHH+4ZSXZJxAsUzzYo+T5t+gW4LQCIGWhZaiPPOiHNgDP3RwT5RmwiSnukBXpTY9sXa8bmCG8ME6GMJBleycnOcV7iqTUUHET+LCo6Q8Kfl4QU9olcu6Wm4p7rNvD/OhP77r2kGaJ5OcMcxiFalNT9xBdw1hSjPLeCb9eUW9ykRUEPXduPAoUU9KPl7UE1qj7N5JuaWoz7yo90zPymFIDEgQZ1YX9arUFlxhrzINFQT9V15ylJTvI1lR9nFy/hlEDZhN0CqXc7XVpaTPg0nNc6KYFZMprm5JK6y/eAa03KGOlliD1zQKRfWTpPU4OZXtlEto3FiJeL5fiuesWMuiIGa5YeKXXdFEll958fxDsuOsIpVYrVgohRf8Y0WSGimXSNHSUh7nYbmEtJjX8I/xDpILqy/eYpk30kprJVYsFssDQerRSyU1Uy6Ysq2lZM6BZPJXOPQDzkjwfjXhLKMwPflEig5/JUKKqJr0vFJaNOTRgko1Rx0H43w/TlDl+4iB4frXjlcur9jcctM5F5tOznl93xpC/ycT1xFEFlRiS0Y9Wmg/xBEDHI/IMU4mfGIJTt5wDfivpTAvjjD/Yd6YU1h9R5JZUIEuHXe1dRgPYj6hRLH634EaC6M71248sUzHjS7FeDEsTcQtj5PhchoLKsDFg65wO4nqnlAdFChW/2Vv7+nlN93sUoQXQoQtO+wEztWkCnVh9QUV3NzxjpZZWQ0WWyj/lGIqW1qK52LczPenoCaPILKgoloy6tECe6aryB/9p19gz5YK8sKJr90fRHd0xTs5bOQvK1aX3nIaC3cIVDzc0VK7j3UpIJiUUxF+5jdO4XECOuJEVr6YmS+WUGattZTLGZHLQeDc4G3Pvh31fCs5c1Q+RzXhrEBo4SR0xJhHi+kxJ8A4gZDVja7vFy+tMvbaI49v9W6POMUVTZYssj8thXlGhPk/Q+gMMgtfNeQzcGhkCXh8leryXI3Wwon06GGPlur/lTTEO3BCnAUtRqT42hy/njqla7/8QIpntpaxr2ZBusNOz+6br/Hx75BE+JN9Y2vrapxQGjB5c8ohMPLieKb6mhKa5w3VWRKps2qgzrdv5oQljl3T06A5TliyxAtliU/04VSUkAlTY4ldX7+2G/+9ZIeZY4df5FQqHKGmLXHihTLGaSRCnkmuiBOWLDFdlvhpTjhivws90M5EkpQlT7xUdSLvbuKnvAuHS9Z4YayB30J/Iz1JWTLFC2WKE1+HCvn31Bjit+TgTnKEmvSC1Ip5YYl969o+g780zUJJW+5LXyBOIAN8MPuOe5dmiyR1uYi8UObY8SKnT2cTn8zbA+2FhpysJZu8UDb53fFdOvs6tW/sIBWjITdzySovlFX2nL4NXYRuqjyip5Yyx9rLYo61YuZYWzwbh58NZK6mLRnjhTIGqqN5zJFOXzLIC2aQNGNMlSHmfEv7opjhWDw2/9mOTMuMTM0vIydviRrTZZSf5o1R8hjkhTPGeiljrC84guzGowGcCJyOtlnJzVxiyHQx5P3ccMpw4MKHyuWTTNaSS17oSrPr92y0b+SySSZrySYvlE1y2GPJFku22NvbOw78gQ2aqa3bTdMZSxaZMovM2wlM7snL0hLywi0h+18j27NsK2+jq+aVMsnU3/CdcU5ZL+aU9YVbYk5yX6w7yX15brm4vLQ9rtd1LNvr2Hg1IbV5yWQtueSFaqkfA3PQQzZwwii1icnJWrLJS2UT28s+G6ElLlnjJSNIBjde8O5lo5QdNhZ893I1dFzLiMyhyhJaYmnwkmkjxQezIzXhsTkDo5PEPa9bbZZ4vDXY6s8sjAIRhIRHDwG9ij+/zC6Ga5udLeb5/IFWLAk9ZN3A7zMrJqLGHBnAxi5k2+w8iQhitfbWjX/8unPG/ECN79XUimwaJ0ef9lswf0ObOd0kidluaBfX2zA+7fxr/0SrKNJG1Nwyfjn67XBv5+RfvPL52qWon+RIEqvpym+M07Ods/10TZFcWO2tsf/hw/7uWbqeTC+s+JPx6QAK/Gv3U6ZNJSu/Ony1OqBBHcq+M85Ofjs9azSg7iMDs3QCW1wVfoKj2/UNDTXezQtqAPuHtjEQ1g3D0YweuZlTW1zGe3aV4vZMjCaZkdQdgBXgM8KTaAif9Bz+amLSpYYtx1iTyZrsYI8B2/msjm01KapRgyFP+B58oFxkcaxWCEOK6hcr7XYcnAhEwbW9OhVqYGiiDSWukgheSJkgN03xa/2SFxHZjtWkTk4/YNGUFKs3ukzMiUg4oRE31wn8MBRRbKVUFOU/6/L6O4zbkluAiUQibxh1yedtJg2eJCBXvu/qK27P7nxBHo4Fg0jYITt4fcQkXVUaFJbG8q1kNdaWL4y5m8iBDPnROjCOgNdz0g+PfzvLzTn67QyyeEZjZiXk7XyuGnwpLVo28nPnSvvMDoEAH0PP9WjdaDI9cl6ymGSUUyLF8KEVEz+QpS4mORLSvVi5j9t6aLfv9YYeHo33+XrQlBhaV4Pez5EaxD905BuWo4cTycubXhzInXwtaCdfC/oteZh3Uj1IG0t9kEL6PUjkmtCOd3eZ3mXdYKREWZ6BGoQ0oIvwlSi2499Pjw5ZaAcOfKE/qfM6g4dDNwKN6F6NIOlYoBexQQu0GTUZZ5hn4C8tS93ItVViPFts3nhldZnh6QqpB42si3EJeS36ybctWpEBxqnjRehnThFXXLDI7Rp+GNGCKNYiPTJdznU8kIUIJjpVOsnIr2N7Vl4NSFaHzX+Kf/h/X7FnWCMnOyPcfK8bZOYAUqJQ2GPOcswxZ1O2xkwXQfixVIIgGwqCdMWLgEyOI2WbaUt7i2D8Dtplyi0s376xmjB31PLsKyUFpNGkuESiV/6theYHLLlay7WLFBeQlo7iEoo9o7iQMGT8rRX5pzRJ9YYox4td/remBfybW7Lq/3VP09f6w3e8eq1dazw0/g0lH2ZZB0jZQuZFYJ1Qbh52c3d9ebnzLMTZEeVt/9q0+bNNTwp1xY3c9vY2qx2sHtUSKQB2r1bLGwyjCeodDSOsOAXxeLoN39ZcigaZzyRLHGRthHrW1ITiwOsGJrfsD/WDqJwcIRpkrwseJxmpMUlbIbQN4nDPsLZM+G8W7/5w4XvQl77zxEp4qVoCa21Ach3wOVlelj3MNA9vzodfTuAMovC1iEJvhDZ/zJhHEeV/aHFEk6QZOFEv7LvOvVvLS23PwS789EAmZU9I1JypxWp59PHIBDyUHJXI4qrZ6xj+S0YC1wmjcyEweaclpusySYCfvZos6tl+cMcsvzOEFVx/MQ3AEiMwAkLGrbVAQbWMCHpfFwcmuJHFbYQoLJH04sKrNdSdbNww7DjEeUlnGARQRQ4Kcg592MerxfmmOjenb0cmGi20/TJaO5wmdQpt1rYHowpAturUTfWNjFfslEj7XUkxyXO6rG9GnR5rb8M60AptM+j06kHtr39ZXWX/5xR2HQdHh21Wv7i4/RFmfvXnGm9SpS/opMaYKsA7suv6eJYV2DeOPwyz3YnPX0X4XB1OQLeafOl5UxrH503VOD5vN+fjSKkETFB4crEkkzE9//LxdhfTwxJtSBko0ZDjExTVgQPECkAjHzEUIS/CKw0UBgH6E3Sh+oV3XzsKLDuotf+6vgb6Wk0AGfy9SX9/QgnG3Df413Hg3zgWJDzER7ecGNAabrxZW7tYYT+wd2uNNDrQAEI/iGyrLnvXZF/su23X7F9ZJvvaZl9bPnYF/Uxq79/XVLGWcIfHAWGL0MnAtIdV+NP2LP6H+pDNQPQUKgFM1LjJAL6RSD5vb1422I+sXmu1WjV5/pzkN9jPbJP7Y9RqDZWsmDpol3or5i1skebLJ416K6ZMEkwmLJ62NKj4tGP77g/rzI3zRgmspBJVYMnJUqHl9PfnO784tYMbp2NPBVxSFdLw0owX8OR8TkOcffE+lcnwRS18kUrWeBTUJLIvyrW19Z6LDTp8aN3TF2EVrkB/EEu6lLkH7YUrrfwrRthGRUlYS8vu2QNAkpAJ2hb/0/C90lqEj1ShGJVya1+sbBNYvl3LzQ5bQrVL5fINci6ai5lhtXuYzFkFl5/mxL24BFxuuLeJbfTN4IsdaGpLXt70jkcf4QszIaykx1Outoi2bVJVeA0W26UmxBE7CPxA3b/cmoEHo1eT9C0Kf3dvWwJEFoMeqiIUbBLItYdjge11HCAMTB1GKRRLwIKZnqUneH6kkOe9y+5YtCp/AaXFg61XLWfjwuejBTtfKJ0Sew6INdFfhDJo3VulHuOWsqbjWk2DpuywuTrW5aw0g2CytT7/mgpslK/tPD0lk7EIWoo2qHroD4OOrqXAGoovV46huHxGkqi2CDEgCwunzJ1TOUlW5xITsisbOBpRwY/soFERlZSu5tlXNFPJNHSehG6oZ1wFtvlF7QFQRITJWjry9YK4QYAJrNdFvuebMxxhS4MEYY3/YMI+SG1TfKXEUqV8tqytSvpUfHCgJVwZuv6MAsrm1nxEcCjDE6EOxDAi/i5VQt6OdQwFYtM1O6kTKDVRAMcusAf8du3pqCI4krqUfblhv4OVMLi+abC/ai7jnPcNw/I7hpFhaJUtO30LhUzQiZ3KoWJoWE4AeYhCQIr0EqPRAmBA+wv/h71mNSwqzme5WZfEAN/rlTSgEM9p9S295M1GcWHITMrHo6b+gnqAxqSaZiFRjUtKR6Qa5SqVxdzXSFnR5/FnbR7Tu0qFbjOZtI3LvEak6qj2MqNOjugorReimxkbrD/Fs7+t4rO/rZLdzPt5Ovy75hdlbSOwB74ROaCHRmZ/wHED4ZtY3PE4PEsAyWRM7UBwSnbYkmHpgPImBSjayGjfMcjsaD6C5hA6f9rEgjFthjVonTfpkKalCukJYUzI79G0WR2rG1d3kR022ZUTRD0D+tnpyT+c0G+yvm9xp2aRFf8NuUIufsP7BCDjVAt7gtp93+wcnVJHgAtt7qiNSz3l17um64K+Y4IqD3oQ1O1geqOlDlDAUXDXVm+cmbio+2TTiJKZUUrEY0LwhEItRB9IzN9O8G7GJlltFHHnsZl4BJrG1DNDM4qCOjbUZDW1ei19+KPMMPoYoCVFdC+uo4zjGV43n+yceGN9TlzHK0BL2POHrmWEX5wByZuKLnl5s3B16JHQkh5WHcfbZPkYE18f4mAiKsM+hWH9gW1pexTU93H/ACr76f8cHBsfDj7tn2Zvy52BSGkVuH0yvHVAm6m1NLnJVIFlXyo+cZdb4bDbdb62XP/WDurJvT0sK/uy/8+z/cPTg6PD0g6pu4qZFcD3c2VaKJW/udkSTCxu2taAdu6ouINuSr9bO8E1HZpyb7g6LEHUICwz2zURPUQsP8kKv3v6uzz34wRbpmUZpqBUr62u8j0rHi6u+vBf9Kjbprsi0CNz6EbbaBFoZg148n892x1sCzdNbI7RTqAuardxufwD1G4W+H7UkH2BDsTWiaDFjRSYlt5r79kw+330x8C5JBqgidCwmcONE+IC1iroGra76ndXO/DjtfwWgh7/M38nBPLguzd2Xe6JpHTDt6P2tpXaqW0T9PC3AYtufUaXS8LUJgdH1OLzqwAJT6DmZWfMYAZ3BZtztSu4gW0Y2oRwMPBxCDG6jge8DjB8Fzqh8UeoWybzc2dtW5Adl44h71MYkh1VHfjWppuTircX/tBW79iqNfS4yi5ptJAGOjMIvnXd/qofOPDxoNAPPJdvHpTV/RWsk3cFpLpOIA8eRAG0G8g+stfQodyKiuYg8lt0IhDWc5QAUeLCU/tTPALhjeb2SSwRmtAQkcxc69r1r+oXKyUUVhpKEABJKNsx4TwSl9C8RwZ4y4s2Kw1U9fuI402oiUxgb6Pq0Thfu5SDCkwntNkHoHLoRx9QxPbxUAVtpYczq5DMmVtGHqy4vpmwpubslc6YOWevcdFEG1E95TFacq30E9Rjsh6/QZrBCFThmT+geBlI0QxZNysvKFst7Ea925iy++K0rO1zz9DSPNrPxl7PyZqpa9KTsXVqVHV8Bqmd4udRLC49jQC+maAj3KIl2yNVjeM9n3vyUca1jc4zlHQBvT2Pjc/WdboQJWmFkM9ThSgJC90/iEId1wxDdIEyxRmcUlrPi6vJ1RKfSoc1GS/AXA0TQxZ+CpjkoUeN7+IP2Ih4gibmIiUl1lWD7GIeKuo0UqWJT8gFOW0QdxQ3QtlZwmQeSBVRGkuCtOa02HOue0ZnRsFlc64cjfLQRfzOQ5ecrFJ02ZwHcEkNqn5lhjZ60HGAaUqnfv4noQy6SZ/jX+nYDESI9pecGAttEAq04YvV0XK6XTtAvg41pMF06VkkZeC0Y7pmILrnhBhpIT7nRxADUTq/WIn8yHSNGJZkQgxBMoGUV57Q8WGKgCeMQSfiKaB9/2doGzi5UOZSWdWvDPiW0DE5KSSy0HqTqf6DHVFKTFV+IZB4Tu0v27xCyoRu2S7d8eDEVnnhlI9iB7f3dV7ytSD3A/DSWiMhT97TaynaOL/Seek+axy5WOEfLC+uy3RhZaMYVkquXLx7M/ewQmfjZGIL9MguqfQFUFfUIdWJ9doKZjRjYdL8jeTdoSInx2MkykzWG/ZNbxW9XcwrPLmK4YHxBjVciW9JAKyssB+Z9P79aS11jWL36NOng739E/b7/gla0tnu0efjnZMD3Amc7B8fnZxlbl7kUoK97C8xft5rA03f3YCiuxJa2b06/JySZw56YeH/7vEgHzfaLVBZYN8NQwdE7OMePHs7ZDXpo+a2xD9K2nGDz9Nw46e1N+zwiO0dfPiwf7J/uLt/yvb2z/Z3z/b3AJe46RRgHaAedZQImMmlCW4UnD4ItcUMgSeup2o6nJLW8ubtPDkg5aFLMMS/XRc+iBalO50+xWvxVQ8fSo/6xoUWdTx1Yd2ynED3YyR3RVgoL1bQry43duDJ0AMlm9PhvsPmjS0MbjymlLSkZeGkK+TEerdpwX+tjQ4DcugcnZAEKVp/v8Huky4mwsl9n3CbVpewY+x+3mugJtIdui7qJHwgmCJPPDAVqyQUG5epkFbh8GoQ+KBbhS2Ypzq0A7BqDtAL3ODVtun0r6EdCPLqLf4XHkagC9DatF0FpxQX+8282/jhoxhyWdC2Fqn0qe0rJo5UOOFuQhlHvZEXhFDmcuuDWPfQQoDLuWiucBGXQtfpvmNED6Uuphh65iDs+VGrxR1qY/OAKu0g3XGFWMy11VEDmV92Tvc/HRzuG3sHJ428JRPWy60O+2DClFhIvKMPs8SzN97pIPb0xfPWPFHe91ajunHCFFutWAfQ4sBdO+gt3O87FMItBQ/6LuCcSvPtUGDfrNIZJ//z1/2dPdgVpc5UU8CCKz3Alv2V/0zK4smABYVaaMYY8A5OUwXYKN1hbFTdYWy8m4+gOOXIIv5OA4uSPDVcETYzFVjUJIEsO2FoB5EdTAtaRNkUsqB8W/aNRA9a0DvSGpGIe8ahB2RdFe+887mUmB8q4EE+/C0Cl1p2LHG5Gj9BbFUAgjRORXYYVcGos/3Ts8r4BDU5YWn4rdAxYdrR9Ab8HLiPqKNWoqEkV1TiTjWeXJeYTORTR3tzaasU3yAt8DKtVNp/ejPz4k78lTIX0PGGbi3I3E5STZHJ+YYQJCdlfIzpK+42WpsNPYKLUkztRqxv6F69MSVyJtjOc3hQO6BaFQXx4opKj+RpzNcOMFb2kB1PK+28W0oCHu5TF6bzYCDppknKiX7Yqo0zPWN5FdThNTJtyCOqbTr8enIEeVOMIG9KlIa1hUAQXA3SCCLTpqYvIEERsFICiJr0RACCTaSUhQ+wxeYL4K0ffOm6/m2b2V4IumyytHNFoElrJSgWTalNPFKDeGuuXQy79lo3T4+ItzM+ppHK0NKVBtFg7har+O5g4RbKspi0VYpNC/Tis/nFZnf+MGCdnuldo8NP1LM9mok8LUf8rI2y/ilKQ6zDPfl1xMkOG97PvYPE3LgejyvS07yMWHgRMX3p72Il2cur13WGHdxL44mdJpDZ+3QX8uC4pH4sFHnVUQ26WMm7NrjNtgpJcuU8uS2oXB3cvMxtB1GxpI8cTGXF0B57srF9lLf6Gt3IFsTpwHK9sbxo+EgkIM3qT9twTfxQhtmJnBsgPTkijHXaOC1IKB6FDg2bZdDQCW+kw/rFyuvfQKcIX7t2p/f6+OTo7/u7Z6eG6bryDwPYCm8XhK+F73+cwH3ulRsRQFeu/kIMYCiOrQZF0bX/xGlQdqnJakEt4z3IZcW06AYFFG3hUekJJdS7qVhE6AAR+LfoAMGr5IUr4f2SR/5QXN8g7NM/ZCsp2BjwbQM2QAcbp7+3CzYJih3TDyJ2dZe6Vsnw4gd0Ashoc9ZC1+K6HosO2/56XtMJ1C4bKafi3DhMZ35kPimGTPZyxHxhiDhdwiN1gRzS9xC3acDAtmvlOlymsks9ibe+gydxemA6mLwtcLhURlWPt96JzUF3uTy16cdlvt8lUWE8SNIAOAAPPUCCydeYd07bXKR9jrXW8zFE7LJVD2SVVsabs0YpNcVNMzH3ATp3eChM7hvFux8yk55Y47QSsmKK2vEUoEplx7pCHC9/RDl5BDKiWOIGhm3HLpXKTCh9ag0HeFhSx6QWgA3szfQdVS2J5l+TtASpJ/VU2Czem2yWWBzmylOhGE16Ud81AozuFdhWHp5kCpRqKk+IKCVno5NhijayOv1VhChmkRP3bc+MYpEM8LYhJ4cM/OvZ50+lUBI3mQ8jmI3mRooolL7gKDtAkkdOz/wYN+4Atq4AA48srQeWrl9cWD82Li7CH3bOjj6fAgBhk7jEtw4+Hh6d7O/unO4r3uUjiPxydLhXTkTpD+8yj1CQdLB1HfjDQX2dXvhVO676UlJX1PpJ3/T6Sp/V+mIKn9rBcjJc2dqaK0tmFlikFzPPyfXaVrJm6cmcSbAkNaQ66SnJrRAuDEpCjCu5pySkg9yEJLvCWxs9KZnoTBZLuMtQqDso1BIB49xfa7O4X+dKbu0SrQ1xD/UsxcuglkhcHsEkN0NQzVIJUm2ltcIOqpWIrlapQteJrtKNwp5nWtIqFYxpZm9Lbm3Nt3oykZlk63uYScbDC804IoT/0wHtxO/YwHdSke1zLKubWnzWPR4tgWInKJESicdFZLUkMKNUKvJzkl+o0XcAfngsW7zeUXsd9Qev/W7X6Tima9w4f2LcBz7018gW8WkiBZuvXaYsIX/E57SSbAMDveVe167pVXv5VaXLhfBub+G4apmosn/E50AEp728Y6G8OUO3iT8a2TLq7GGZXk4ZJUKlPq3i1OiP8EmNI5vFxpEStePtu3kyjoioefL+ENc7TLczRFulkcrVNJCyQrN3gyw7Th1dfkprI0XDG20zyT7wK2nJx3okLf3Saq4Ia/HgKHAbvd6Zuldqov3F6ZtZ2qzu2tdm545uWK7GmeZgEPhmpyd9KwfuMGR2xwd4jOz+ahy4/2yD4bcMsYUQ8okdZbdzor99FxMP3YZDXwxoUF5x1YLAiALbbC17uf2+RmGwQTGpHfqiNTq9rjVn897Y+vrmPLl15gHM/JzcjAsbj1dKNvKUkjb75PtfSJvID+gCmgU6RcMv+UC1osLEy33qtWBS0IXmka8/pPyja9VKZTSc16O0k8vkp4YYGc2K9CkabTymbAB8ruM0yjSUdCud8ZUPfR3Q6s/gkc37t3N2y8Tp3hkD3727dv2Iv5XB0/j4YF0WtkdfuxtWWmgGw95nB6rjy7v0IxpF40ti1iVuUaurq+x3qsDvcfE6+7IKq//9FB+/W40PQGNqFPQhVVyaTUHxsCMtojUFvsiNABd0aEvzGjGA10u9XSVlKaZZ7G3WvVjZiyNUxfHm2+w+qVx2lIsdQocW4X1JQ2qJX+TunZBpNJlretdD4M/ti5U/zBuTf67su1u8Wx8oXpXsDkWtkq216I6+PKTJuQT7QbyNq9THg/W4usxupF/9ejVtT7MpAc3G1rz5jxYhDVmnylAmW2BxEEYf22h02YfyCrIci+Z0fJEnLp/9zhf299P49XGe/gcupTwhfU3MoRtiF/hIK6gObdODvU6EV7nUQvh1RLHc/Pg5IF4oB5xec/p0RUypiNNj8EcteFV+MlRv/Dds6Jz4OLbx31Kte0gP9IyuvobxODkBGmV6bDyL31JLRqSmpsYh+/wQU+f9yaXOs9LU1dRy6srAZhR/tt7OB/4A90W+74avA9vCVrzOHQw9ovWNUGhvyEXd/ogHcSr8ZHO+/8vaI4ajY876xrunfGB7Svey1xaEkY4A0ve9a8ezbfyop861mFzJT4UFlmz15O+2zy9b0c2n0O6bGC3FcKxsGM505uyE4nwEW8UhOdXR1WNbMPuWes7dysQUo8CcsjY72BPm3/wIncI+Qfss5d6eHriTLrjj8m1jsAuYDNi2DKPu6jsMFTKeufUV+xW2cqCBXfnQgkuPR3sWw1Ewfh8/jHduTuh4uPPr2BS9sUnFcwIBJyEAyDU/Uw2J6y+7H0CpqBYykzdMo63BPNcwSppmiUENB9QTNAmRa0DuzSE6bRYlL0va8eFPC78cPsqSGcZ5rE59abIffrh54GHbmrMZtXD9zXxc+RmJM9LHDKHFQEkBgcvzrkvnl+7F1p51K/ZIuMkbYV2Bn+QQCv7N9a2jp/KEKeE1nR3xlz94sFQVjFIhxD+QyLdZbJH/FsL47AD2BN8kwUOg9K2DDwS1t77h/T751AF50yj9bIUwY7h7/BbvCIUBnArT1Z/NLHxQ5vnGpXbpTiE7s54ji7IT8ZAJXHyniWROkb1szgx5oT1S6vSx1ZM3Q/ME7VAWxpd3hFyw+MngJKBfSrxO7L5/Y8ujm0Fgd52vdviav48Te6PTG5/kKTq8qsM6///q13YEghh9c8JvPTME4fO+Wf4334O/cPH+JmLiNPiWHv8rXg1yzetwG/1JGwW063z5D77tgkDje1/fPtGLv5DyjwBv3gTffrVd/AennP4TNv5rZDsU/hdwgwKR0bs/HbTF6pOjCTg9NCReCJoTCX87rwJOYRhiRLWkeSHMPNVRUKZUsX8/P3p90RjVxTZsK3o9XiSHL97zXViEu6BOox81KFuJ+q/bavSNAP9Nr37Edn6u64Kk3LHQ6TsYLZjfr4nQPb7vXPcifM4r6VvWQaQ7/PPPO0QotMuSkym/gZ8gmqVjVJ4jB3l/q3cAQ9v28u6sJP7zeLNGp8sHA8qHE+A+R1xyiYeaEEcccCK7z586VuZafScQLzVjIRFiHFXxJiU0UpsRTBO7Cu6tjgmpXcM3vmcAqqktg1zInlKjf1sMNm9L4gSuLYhGz8UMRtIBpDfdUsApKrUwtoTiYdY/ogHe+9racz7C0ttDdu/HfEUXS0EiNh6LNXG8W/R5c0Eirj0To+CFrB7y1wHRMZe/idDQ0AZ2zxiMKKFHBHCvYX9FQKDqABi4r/YhOUiKNuO3i+8UUPMRqLA+1YwQt3KgCc+Mv+LTY+gakt0uSEwpwDGJWr8MHddKDZlwyDY7PfIDE7iXzMc2u3/IXtT72CKnMe3EGrr4sZWIPHml0fZG+X467Lx6Bh1nMkPC1kLBDjpyGXZi7M4gTl6BxQKb9AjzcKZI4UnAJvfQIA9z9qh7DFtdVVpFyyZyuFzj+X/XW+zYDMNVUKv84XWP3fI9B/QhcZQgTYgEl2DGvWPrHCs4iY0W+83zbNz/oK+qeRWSeoJV2+yz6d2xyIH/pFCwa98STaGkbLbYR9/ibrYg5BZ+HF/vBlXrDa8BNUwPAxpnh07Y4WbRZwSCiWpFN4NzAYfkHhr62IohgKOO9uihKDSzWPN2UbBGeX80LpB9J6G81PS8YSeNl/xItCkeXl3uKTJbrXauKtOUTy7lqEmlNdJY1y4DL1lHXkPSj3RiX9RcA1D8+KsJW67gi+XfyscbUPtB3IV2wpx7hxhgKeWXe7HyiiWh2NcsdhLPH/v/GPZ9Vek85GIzKWcX7c8u7HfYLvTuGn3nvvEHndi3TJnV+H/iZztbhp1KY3E84+wjV7K+cee1nK/aeNBam1HXkXfvFsRgK+MNJfkq6uTnTi+s6qN97x8JO9nx1a9Rr8lItK7mFAl8NiwzPmjAEuqxJ7ju2t8n4Q/vpNkDj1qwCde5kpnUihmyY7kp2bEsJt41Tl5jjXx+CkxGEqoYJqHHMAeWfIwwWV/jQYqPlYeVtbeSZZQQHqQe2LLF50VMmKTOj7cpK+vuijEfVWQSj0QoCLUjZ0OJ9Mj/+1HGSyXaykdJGZTO+KARNLVz8tSiAd9M0aww+FrmawrAeXK8eVOMNyWhVrc25sInPxZHeQ7ZAQUchhrivp2/C78LKad2R+5fJNKkkmfInahoKGlseTt3DkVv38wvGx3wP1QWUpKmxj67fqCtTfHf88M6m6Wss/nyWAehZj/PVz+TUcJGG3wKnsaYMwdclXGcXV8v9pxdX18cH8eKfNUyINOJDKOQwbQSU/OFqPZQwaf4606Nw/gbnl0mRwV7O7fbZPEdAe2ZAq6cud1WnC0dF+OERqpkBzYANh1j6BUpTpeBL+/UY5fGGnk01tIk5P5ZpSccjWoXF16mfGhLWyA936ioKJeKNhkXlxMliovliBedVYXgzSKplYlo0fNNhvx+xSKYLVeqOYwTjsLMR3xzbPP9Y4RRHx+JZPKEscrPbd0gdLFyjDW5MyAGEgZ+9Zmko21eOftnjunV9y9EduaGtsxPRDuvNgXo31af9HUwYrplG1cu3pna1p/piH0EmmQvQyu47Q37ZHGrJzCQvumNW0kTqNELgEQ4zFwWp0eUxDte8C/6GqJlv17797//Xcu7Op7uKF5F1dLUTgvfp57d4bf35ayhjdAOsr3JEMvrwNRx521pZIq3VSNTpCLfvFuYVZ86YXDrCHqYlCz/eUWnpgc8/8YlVgDS4xKaAC7RiVckMGIGc06xImFOUhlN4ibV5VKZxR6qpOEDljbIHxDS8Q/pHJjGCHGu2GS3No6wyQzuVQQgcfAZXz3eOdzdN453zs72Tw5PU/JF7lKkT6AlO8D728CHrluPqSb9SAfmTAWw4mP4cTum+YPokdrhV+wX3w/pagVzfe8aRhcOr9CPKXLIMZRAVIm97gdWHLATu0gzwdWdVBDgN2vsr2r5v0LKWrugjxtJOt3RUOr9vM3eTP/AcEp39NbnI3bw2JAjy8HMBQa5n5UoPAWFZyiazlQwKGeYAoXQqwaE4Ro3JMIrai1RifaUG1jZqxEUDzxE4zdR5Mf6JHdfowwuiRVa30ikRArzUiqahlGiHV0vUnUDiVYFDZChm3JkCSO6G9ALx7Vkamo5ioO62+IE4v0S13/SmovQXj7t7xy2VV91vBFmdvC1BUJzz3fUh5mSmsccNNt8gv8zxLexfE+8vnSx8gM+YiEI4TuOvZg6nR2kKU4fhN6Unhu+qXpuuLmo5g5ZzrI7Tli+6cotWnoFa/P7XMGaBgLFg0xtvqR1oBBs4op0qZI7RgfUfzN173NaaJO0yAFHVT3imGL2V5xHJ+mf3J/wuGIpHWQMrCIVLwM32Q3SZzvq+RZbV+KcXQ1hFYl4zDSBytyLC53jr1I7J17YEEoaXmipna/+cImh1C8u8P/q5//vh0uMrY5/nLch4/KHeuvHvzXqf9u+uPCw8Dd8SO7C+/ZfjVr2bRoe+pxepwGVcPpItFW6A9uqvANbdCT6Yt8Z0plmNBilSz/zQ9Hobf2UipA6vHGRCOrGXknihndIUQ7TL8lOC4jixtI49DxwIqb4tegG69ErUykY4YkajNT/1v6f/X+xg8PTg4+/nn37cHC4d3D48dvewenu0e/7J//6BsrRyeH+XkOACiAIgg38c3m/sdbcXFt7GI0n0CVosK43z7ea6U0mn5HZBaC3i2l7luX4EmTghaIK+JMuPQsP1U8VgdQBjotAZ0d7Rxx6xLpOVJ4Ee8xcS7bovPRDz8ZGJenHboLY//Pz/rd//vOfQsx/FLpDWygMzXTFVXZxcQ7/jyrIyMIeTGdFupDl2bb1Lez5Q9f61gdBa1ATf2tHPv5o/K2YxLRh96m2ZVPCoo0Ftw3RIYF40Xg0FqVLz2J4jGlAkjrOFCSVG4LokIjOxfCdzHiTJkhlcEmkp+044gQ71h9w7/G39j4u8Na33x37Fv7Z5Q9Tk+ACTJC6cEm7k8uaKqKJMVoxRKstNLVT70aqG2S+pdDpPIg0XuCpO3o5VRURzaWEXyF1TiUu0V68noYS/gwotxgjnPiw8Fh1pXKLLxKNJtOfx1z9er5+mT5nk5Munvq8zxqXaki61ubtPh0UTcnPav3tgu7LrmHXjRMK4uV0SlAoW24G79Q9Bn70ASbAozxQpV4WAYUmLszMK7xgS+ZPvNoGnfB49NYnUYaw4dQzV6pAoQe57ozTaOaUNEKMjPLlCmvorjtIn47SqQh7jR9sK02CXmQgL4AQKPBbI/EpfrqwHAeUzEMC5TxA0DoPuXqTUWzIeF5qNr9Mt05NDFzT8+iFHJJZO9XQM6hA68Uq0Hpl3Hm/QLgjrpaFwz4+e1KGPNmSJfuwjdbGc16sexzk6CNLQCe5nJZ7QQ2ZJbB7+ELsjc1EbTyTrwJBEj5IrlKop2gWilDKwnnnd418S7VWPrG2N3LNSVphzSbWyNsCasW1DaxSXNUi03U0DVOHVjGVKT9CniqVmS5e70MeReckMcvslJfR4tdn66Fx6YdTCkTd/uEH9gyn8u+KT+XflTggvllwM/TVHTIaOkmM3njpZRd125WMUpzJi79IoWjKA3W+4stD+s2qW7N4+UYyAK9owDVZ/EiVaCoDVcmTnqo4itKxL5GsXeBONKbLISgYegNQj1wMBfmcY3lyOmToJ/QVr/A5bFWfrpyH8QAPGAUTqadVJ6j+o14d/l5vFDgDkF2H3KRbf/iOSumcetWGhi5zKouZnRu3oDkGoAneytpobW69V//3dm58fTJvaNFOBsXUDK7pd2snuB6ihYacmYO6ZfMlFPBhuyYBQ7YmrrrqKk1yQZ8eZ5E3BHhLLdOyDFM0Ueeboibr2e5gu0bXdSOf1CSNRimJ1VV+3RSf81z1Y2JHlMgNTrhvGkEDH9YhCn34b6fnA5iH2+c1oSNgTqwm4R+oY62KPVETd2xcI8LfQhPiyS69pFcjpY4yXVd7vzf1P2FJ2lba5aMRE0+uA9jT8sEIhKTxfBE0nvyO7vviO7rvS2ICvJ+vA60OhdkMSQEw+hQ8h78m4Ziufz20P8PX0d6SSKVPzyzz+Eu6+WNJw8fWU96Im1JkiXlzyyjiol0l/dS+RnnWFOD87Bm69z0DLPVCb31XYanP5qCInUTWkpVK0WmtGJ1eGCt9gP3WjohrUsRT6TLTuxn+uIs6swhS62UB3dZfLm/lXwmvUni2boePz3Mld8PlbekwCi5zb4eTTYZfDW/w42O0k1BO+gI27EgM+6swt7YVa1Hebe2QKx3x5e6sPjLbN7c3F2OzUcj//Fwy/pyVZCanzuzd555cfFLD44c4BTe3KcI6iQ9d3YYttB3YFosrZyyg0jODR2OQp6FcRFMeF/HdoLwgDCkToIy5kB9uIUVY3Pjmh62py+KjL4xrV86FoXQt3UahnTbXRKtf/E4ufL969YrRjaQDOgnOqyaqamMiJyF9DO1CA0oW06raPSYNDLRR7LBS5se7MV9XucdGIh5P0Ij8gdOpBEPpCrP40M3kKKSOLvdqd96RsojsjObQQeDQyScRUK53iwU5/4K3GlF9rCve1EpT3vSOce3s6PhgN77ZLR3Onu6Gt9ONqf3M1vJOdmiU59TdSxbfBNdugwqPHiqZ/3pdjR/0u5pvoMjDMyNel/vV8d94Lt+Y3cOZzfl6NWdSbPn/2XsXr7aRbF/4X6kh9/ssdxsHDOTBOpw5NJA0fcjjAumZucDVErbA6tiWR5IhnDTf3/7tveuhqlJJNo4htjsza6Wx6i3V/tWu/exbotZJ6y8lsuDiBLCQ/YdClwYLIt/EGl0mXQU6HVGPVA4EOgPFCxXtdeP+JZz4qDdVE2A/sxr8/2c5hRJ8suxlYbAi9rz7sH/w7dAjJzkj4MGpTo87+mdoHvzz49GH48P3b3+A0GKAUDvotUc9NA9rB8PUxxcPa8vuJkKkqsbLBU9lK3UyQZThq4BIe7IL1o1vWX/U7rLdoyO2t/vxBHM8wB7uME91jDgV9ofdII0wnY6FUqgWTSX3I8K6FIiWKrlpdq1pXI5oTbLPdNT31gnCbhG2+GOM9dKM0hG+Mq9OlxkEp9s6IEurXiT1aODRV9Z6fk4AsN7gDfFRvT6/hP9yyelecNy+3nAimi9rWEnvLxaN3l2rFLR+C6dxfEtW69JC7UVREkO5DnKRC5fEtONuSFHbpQCy0nLfFGmWmu/nMqG6GbfhYxAlxMSs7h7mM8lrDKHctnqLzGhat10KAMj+I7e9N2Zlsy7EMoVfpCmsUfcsuuBBaRwFZzWUkdQulJl9jWfkK4qBgAUr7R9N2GgM+qt80gRfpR2czVjUUoges1kePWazQtSyteSI5LfJ381Pqw0GxrWZGQ59s9H+N+hKzGUJ4CF61VUbDS7hEPcj5OK3DW6cmBGHcqPImtBwlOGbKsiE35gEhxgRQSJ8CmWgxefn5Dc4HVtm/8i8EP4MzzjNAwwIySggAcXoQwaEwxSMoarpztmR0U0QTdAJVjJ8nOV1ilwOTEvXfKJ1R/0gMmvL2dSd90lzmJ95QzLDVd3JWT0BW7RZzhZVoNDmy8Vylp4ChRSnXxLI88EtZxdg76ntBXI8ciytRExj3o9EuuOJrkVa4E8ecBKpN6iWDVMe5TWT79mDGbD8IgV3qwCnFg+uRco8u4+fd6xZs5/YhtXp/xZR6ciiV+X6Qz3Sv0dRcufoku5Aa9oLapKHs1f7e60OA7Qsbu3gS7sX9APXGPIe+JBB/kaDrDe3rGH+O7xjw24SpDoniN5Q4iECae0KKRNfetBD49voCeCoKoNAhXjm9ZLDEWXi7MYZrCmbTA9eaDGHHtTTI5GxOil8KeZWb22N8xmiFMfd6Lq7qsOOuJYxTw5RH+NbLexIHJcz5w3SIEY5hjPG57XmlOwchK5S18189nzjYhze/IUURb5y0IqYCcLzGjhL8tq+bnI9WklFsuPn9fDPJuysUVhWOZ+taGJPv6wh50CfIHDDerkevAqHXi1YQtIHA5HyIgYSu8UWE4GRs1UlP7S5tRhXtMLKxsZyMPyqe2FGYbvV6Ahdt3DwDx8RcJ6xU9K741CaOh2f0TIQiBS9l+KQFR0UL5oYFTBLossRjqkFpkEPaCwaG1xmArxTnZ2ZUENxZvCRJuHS5/erADwn7go7J/1MqTs0V3YMDO7W9ARc0UY5V7RRYR74agn9SNy4EqTtCC7dUT9EO62HYVKx7XIhk7m+CcM+7J7sHR6ymygdwff9Hw5N8VURqh4RplSq4wvrmeRZzld2zlfgdvNqrV5aY+/D+98Pjk92Tw8/vGdvjj78g50evjs4Onx/YARPeHC/1LoIqb0QXnvHBtX0rn8Z91xRdIKk3Y3QQmGUICtUo2ypbfj3qvPSDudXw22Z8lqtF68vi+VpZvaxsVGoI8MXqooiNWutUYSxb3KonBGGvXyxJBg2hWP2d0uk/HDQKThii9zA0g1b0srD/LPfBUMHcwTXmnh03bX9tMd7ZqPL8gAepTu1n5Ur8p7l7T3eybvgoa3cnPnz5+TBznmDiAY1XLhVpuYxgwA/1A/4IFeGE/cfaTwg52vEdfyjm/V7uTd2Ph38rVAK1w3vXQzGVYb4LMdcldd5h5Udmh624Abhdb3RvGZMXlssB4lO2BkNQzOgw6dB9O9R6Eh1WyiYI2fH4kJs8Nj64TP7JNtngCjSw+B7QhumbyFn4TwabD1sP+FhVFiaV2agzhnY97K+cm3B+yhuDABxAFyDz30ms9uQC8lg1L8EsGyglUQG+wMOW3YDrWiJ4r4pYuckYTMdXXoY5/Xs6Py88zPGcAXkrnHTsbq78hGOgrXHV8UYsViLOatxMzGRvFAZyxsrwow6cNAOk/Aq+hKWzP7/erchw2DSf8J/McA08Ll/9sIs/TP+fH7e/PnP6xij1f5UnK+4SOOTuY2++nqxDCxcVC/2sN8N0q5O8Pbz2akkv/mi+3AS1xczhrqFYQPWxFusAoeO8knTyVsr3ikBEnM7Y7+96LLZ72x5eeMm5SIOvXq92Q2/dKLrMM28+tn2euti9nt/vVKAvT5xbqrF3/tp1I96Ac7Pp1xJ+v53lc1VloWHU4G9JNqe60IJj3+33AbJttY974ddhtltGAJK38bUQ1qgjvVSwpCx47C0VVorV3oLcRHvFE5c+aO1XZC+agr+Z+wkwv1LVskM89D0giEvIovidZLpZkSM61a+S6rQ0iq0tArGpERXYla8XeW0iIzzTMfKwHmd/b+iuZjDaFCo8Wdew8AWo8/noiVMkP/xn2yNW0iuPQGktMohpTWxTuzlQrLR4pq1j0XEvcZGmJCS4soIIWtPZ/Ezb9exl+Ub6eVyX8ccG8UZEmRcvfmKBvKw/fVEkUBCGVo33SZV7BmdiEbQ3QvLo5jajUiuohYjZmRIW5zBRHiYexkt3+5VnFF+P4Dr1xeqMa9ij63FF5q5yAd4n45PO2UcoZk1K8Vqm9/Fbmo6esuXVRI15AgqkE+EIB1h/i2jiBRUfUNYQebxdhhjmdfCXLyWWv+qMpYIfgoMJNJMs7BvFvERrs5hDavsK1a8Nzp3EPsZ1kICNSjdwzwVV/VJmjqyYRTa5LSuhnP3ZUe8n7WgfEZatkUzW5qU5nN7ZYG/40jf2WBmN8TvJhEtuq+K5ZUgQX4tlNJQUV/dDasR4fx8ILuQwCB7KAAEfg5ycgca8Swqan4O71LtYqZF78Fm62b4HurJdkXD6ljQwrpU4yz6eX37wmETidfXEkpev3BWb5VUb12U5EYneXKoZ5B3BBui5ziTr8Xb80hza+Ec0IheAkzdnTHj3hjg0fGnVY4/VXfEl4svd3LBSUf9CMchj1X1seK1PwyCZiixzQN8qHWWgI+Mys4Z8Tw4e9BO4jSdgB8B9MlfLeKPmqKAHs1vrNfj2Vwc+c730EIC5oEDqklQZvGUcqrAw6vYxCX8wA2mwECxPRqiuWN9iFBiSfhv9C9JixAGJYLOrXwhBrE7QE2tcJylt4SVbRxLQ5mz7a21tbIg7zX8jtdozLDNamL2tTFW34+OQa/LMagqdPvL5ZRTKR507L3HqDgza4LvfOtRi5ogyV6OTShbzfn2AtJc3vly41s2zcjFWLcfMWEFBraAwaQWreszUaUpH1xIGhYFk9goE1T6wyRuAzmFHT19Hrfjcefa45PUa1vTLrTTJo6Z9z7zpjecSfncYDf4ArRKEgnv7Y5MUQn2BRfAr5/P1i7u2X/A54M/1y/gHrjN8PnNdnPt/4FfxjCayGV+k3y2FizZ3qR4E35BmPfRTG0c4lhVK7NdPaKLWmW6q+lgR1uZkG/yY45CpXKNnIPxIZtJjUPq5IxHFrPfTj68L0BRJ8gCh2ExT9Gybebdw3y6Vj3ZP1Q9Kx7b43mFSKYTLjv0UTeu1yN1/QTcRKRQbyInskhzIStrwNm2lGqLv6ur8lzEAgRVG0eCq3v70aPzOFP6yS6pLk4CiUyzNCHu6NWXD3vk6maGP+9EhwUMUp4aJhlg5sp9vTOytRbfIz1fadjVC4/ggP/ppzek91EcDKay/GrxMPfulqfIytj3SLO9zdXcTzItWNgzhtNiH4RYjAyk0TV/TOsLW5LlXQG5XrXqDSVhM9kXyQaV3BsNrxRY8yr76aevV+v3sEZklfBHgQGKvzsMbS7DVWuqTHtr38eh4+FmRbN35tCQoCDTeURXDgQugR0L4dXRpzx3l3HWNXw56MEDnDn4F8eP4zj/im4cojqpPh/dmeNluTNHhfnHxvpi6aVh092EhBTJaIAX8PhKhwvjYQVmbDQ3vwtkyOnbQPHSAgq1Di+DXRVqDEYDjp/Pt7jVSOrSyaUuOv9wPBrwROLSG/4EeHj4OB3yKO8x6pvFA3KY74SXAcCM6IW3J7EHxvZJQqjbGbWjS8yRSc06cZsoj8S2YvD1JtvrBWmKuYC5oEcm/vXIwbLB8BXBf44//nIkyKPVZLvt9igJ2nesH8J53BYi2g0oGGRRn7wq2U0U93Sr/80m+5iEuHBKR+z1Ixh2cE1rjQfoGSv632rKlN6a1Kn4roQ1Pr1noGyyg9Heer0JK4l7N6HUWQs7Rl4FmF7o12QhlH79fNR6udmmHqnJFVLINvvKm5pK9/Quxb4yT9p6CsDDvmbJbBSTKb6oyKb4ooLdeP1i4aGjmQZXIYkT/M6oP0ydUOKq9MSWYu/IW3R6SLHSxzJrRV58+YdLyyGEn1ixmVcEehj2APe82n/goXoO/xutrW20a1rJf+oloV7yXCtpXdXqT2BhO53B1vrCuUj3gaHAKB59jLMG3xa4y258HQ9oENr4ZKwEjA0AIUwRdoKx492lcxnhatxSbWLYsM7X4lI9pcTgJo35X7uDu4sL44wlky7ZGgkKTS7pMMLLJ55wMED8eWSGmxHnxsfd49PDvaMDf//gzQlmK/i18gz5R5AM4EVtwymSj5fmxwkD7vxrsU/zcJFajHvjxEvutgsST6J1fDup55iolozK0fvw7Bx25fnKxTYb5sFBsWOUlXrnK+qFYzxivNWzswtpShF+acOmx0B9IV1tWJCysPKF7MWjXodeRM/+HikcsmHJK5jlYToj/6D19YULcDUh1qCeXH6YItYUSpcXa4yleoI3hk6TbWIPzYB6lbiDhhOqJ25Mep0Ew24TSVdlplPst7pCG1iUd5DbXPN/uVnEMMa5af3gT5SWJfBfA6gEqskmzYiqFkRqqKeIBiMt3jhNmixnyQlWjPgclpovxxECJ2/mgk33UFrkGAPz3LinjeDGOxF5WFw2UFWdQ1z+HOHt673WbA6Bp/ViCYEnGlyFiU9I4CN50GmjY09phdk57s40zcK3ApBzvZ5xGJc7+R5iY6ZFVAp6jLri0KNOXUrD6PXCa7jNo4QtiW7Cjhng82j3XwfH/rvdj6Zm9RnbJ6dm3q2uPjkAQs7u0CbhXDg+I1Gdr/yOoek+XP4B8ykW7l4DSVwDLR3HsV2sd84HFYqiYje8+OAGNnCx8GQYtpWko2KMjzF8bscCjgHu0ghRubTxM6ZtluKr+ZSGe0Eq5q2lShXvIH9gLNCsqPe3F/f7M45VNSuMWrjUDFNAFAqaKiFKVpg/A7JHwKchuaLJFLjl2MT/HoNQxGFQ6l3v8P3+wccD+Of9KQYsQMiqG2LP025EOtGbqAOsUTBg+VJYPwzSURL2ZRQTPoRataCm4CaOyG2nHSVoqQ81QlQjhoP2HTdzxVFXUeDa4QuHEiV7NTi0rKvycObpgEV8EeSG8pzC5KtsCzRNWJW58lJ1Fw0Gd94Xnr1BjYTromdwk3vOQek5R5TnIWJxFKbyN8YI7Rk/sMjwLxRXrhze5MQKyGbMbm4lQhYSvVweJEIyr+KViuWzY5Umk4C+HQVJ53EByFzkw/ijq9GA1BGAE9iNgzcyOKHjD0cHTkYILyOkKCllg6BGGROkivZPPxiP9M5c7JFqqLM7eW8FTsju9Rn7R5x8Rkt7e+oGm3JLlQQHpbMleoGDLVPFes/CiaLYwS+jqNfBH3YBF6JXdGlzZXrjvOwQsAHL55Rbai2h2FrWwaHj4Z0Ze6lQNJ+5Mb8Vo6yFehSe2/DsL4lFw9uxk24wGMTo2EfteXrwTpS2E1QP6yHGXUJrMZo7TEvOc5BlZ0qhLkd4aotZynhpZDjG47MYBXJOO3Z/PFocdIU8Ce+cxyVPbRkUr1VMxDuk1FBY9pyPbxbLkVd3oOZPmKMXWazrljc0tLBitdomm0/j983luyrJOpgCLKtCgEKF5cYBY7menr3udAR7g4uQERfGAQN1pMMCBqiiSIuXtjtgSSq6CbGAmjmgQH/+l0eCWSmvN5eYDeiPslHQ89FRNOkXcutW13riuHRvaOysPCT4rOCguFrvi1/gERrszp+UceB/S5Tg/TOtfyOgnWIkNODQqObdoffPBvtXHUjwV++fdfYz/Ad+reIvfO4yPaN5kndbBLTOjkhAwSefJ2/rY1Im+CVlLC5JCmACwox8HXX2N4478lUYIosgSkNGV6uDJIkTjMOCSiaKy8q6wU3IUgysAu2vs65SMPN/u/4XnojSYNTUuLLSnaPSnV3pi17LxHoK6fA/0VD13HiCXClTRiBYMBOxh6BQHpLU70cuACpUmMeIJ7NDIGO5swUfLXSsA4e8NbRGX2dpO+hZ8tz37w4xXx2c5wqBnjNPg6B6cdDZUbGCH+zyZ95mx+BL3JxTP9L6rgD2/IWagXNxvdAHrFQNXJ/fQJYby3dnETkfzBIdIkorVLq5tL5T2pJvRQjnapV8VU+6rRm+NJhhnrdtGeRZ1nr4yAAQkVuDGWMqlkWtxbzfSP2EjJWiqkm+A28hYdDuqrmJ2wyas/Ek2ecr+ON8xciOLRZ6Ifv/lHKNlFADcRWIUgZRy9PjTwfW5DUFFO+I2qW5ygxn4NalDYV1ilIZcaEm8C/1qnn+dxgOdX2VGbyfeeGXYdjOKFA9S7vxLaX8BKjNFV11OdPHlpa+KgefV+Xg82IJ+RMntZGzejK87I1FIaPm0tnj6fFLcJHeEHdpA3M069cAqDLgnmA5AhEJieqGXdcNSTKwCVWBrhpsq47aHO5mxrYKBz7GTYRm9fnUIWwsWAiNSaiCzId9NDNMjGQt9vPlFBrqq5TGp84T9X08CI1z9CO2ZN1RPxisojUk3u0Z78g0KBVRwniOv5cyx598vH/47uD9CWYL/HB8+uuHtx/e7x4dnv6LHR98hAfMe7WvnL3r6lZd2ecVRSTjvui5NauANHSyEss8E6F3VJ3axXbj3rq5azHOngHdqmP/gBj7CDr2UAqRTw1PQvgcDdbVbGTh8A9lA+AAHM7lWuTVr9B8u7V2z35FJXB3u7lxdU+ijsqpvc9vQu/4TejQuAmtymtQ4SXyy9B/AEFvwIAkMpm1S+qMZJcbm8tnZjFVnsIXC8rvG17uD3Jnz7USOettM8HcT3SlwiFc1+mvrgriXO1Epr4fT/IdtL1vGOc+OYbvH7zZ/XR06gPPc3zwdvf0QKtDDuqAaNKunuzNYcVo9IXAyDEIgEzCgoTIiWfM6XDiySJmF+f3DyCOkIIbCbhGJh2/mjWdKqd3G4Wu8qjUhrcNN3dxeSE9utf7Zrnz6maFlcSrReH7sVMgzCHAwPUdnOABXLzg/ROonIrH0vE6NLJnuEsrOfrHk0GWZdIoX54JMlsvnzSVxnSirLWF0bk9bFc12/zPu+rtZVSbL1n3VNtMhfcWyxIRnwZxx5BZXTRY2Lk2H5VLp4zsTJ1C1H4VbnIl7QZDYf928O7j6b+4xEY7LHnZ+5j3w51Bz1fuzWi7GJZBeiQpDpt5h2kvGHT0mGuGPxNFSvKvgEn08+cejSMWq0caH/V9ozXq1gqxGLgUKMFsbXltP8XUkDvAMHzxqBWXRrW5jl/1wLX6agSemUljqsMEKQOI1RcjQJdeyWDPaXq0lHodbhXra2vmG2vBG1N0Bq/ssRN4T6dYe9FaFKn5A6HG3nVjIMdVvRJ6Np8iP9Q3wU2B7h4IO/RT6dd03HnGPg24OyilaJSwgOPB7LTw3Z0/rPi7aWiH38WxKXQ2zcFK5tFgSIJYRBIxEfexVm9oz3gMlJrlVgmUnlKylMwVdLvzx1l6gZyzl9XdxRkv1lFHE9RFaZRR+klMUlcGfnoKIg3l4PX7USeVGe7OalGnxoX8A8qBQIjiaklVoFTWwl62C6umGo+NNdOlMbGY5ZdzjjWpiHTkk1OKHw7gvtjFqw0AjoyCREGQDkSJDjGlFSqTzn1D5oBvyQo+ZrkW1jxtMrrX5Rz062VIRjfdVnNmpRtfc3Yn2iTbrTQt3fT7zZmcrpCKrh0M4JxsBz1fKlS/3qujCx8BdOIJ91XjghsM1TjwLyynweDTBmmY2mniqK0o03uljuk5dmsOb3WBo/CtZPdgze24wT422C8NduScRRb7OFWzD6OHxDiLqSVFULOHVfOHQjk4z5RBXxt9sNVbund06PeD4RDGSu25wNXgegS7nnpM7/qXcc//DDwC/haD3bsOOv4NFW8G3X4aRDfh42PNRjnWbEwcdOX18mENBR6xiGoC4ClrNrMr/fc58xQGudZXmbuv12Nbr3J4EOYeJPO0upFBS8wEOsK3leKbiPiCPsUX8f06SlwxUzr/D4U/Ub6wK6b8N5XBUowOsUXJLBw0KmMXqu7KgqjoMQxfBGvno6tw7Yo512vFosr7LmYV5OIN18TIYiQewt08b1/HGFBXY+K1eFdOrvsZI/UCoam4UVDMKYMtp+33mIGcp7vcb64tN8MtIIZOtUnxSFVeKhSiVVViD538PGMo/vloAEO9lwKMMXY5rOSdPBBW8v4tMMl7nA5M8vbfAiYGE6aCPdXoSc2yBnLyV3kb+bA2RXCoCfmjWdnuby45ComwvhYrMB6QytvNLDjLJNjktJH7dmByr04IIemagm/HFQ8hh65j3gcLeFQoSkWcxSzKUo2LQrOVQs4LjT/h4zjVI+fS1cqNRmjBg1JOdOJrd43OVccqIYTF0bgHVM3cw+3SFXKS0fSbqHuoQrUz1cuFe3QMsLAaDVK0l8jgwmVPRAaRUf3IIDLGXHktmufsfQU2Ky2DNie1DNpcMA3rwzFJ2qUKUcN4MHI0mJmK/zuikLWscvjJlaywSy+c+QcpHq8Q3SDXHxTjsZASQCGTUICWIKGaRDG4rC0poiNfNW8U0omZe7eGe9CqwTeyq0TuX1eZ2vFYmJfd1+dTmflqYeyNv4WqxV1zAnIWNZeGjmHQcgL+MORxk0hb6aRfzGNhRncjCeoTkLIusTVpeU4paeOvQElEFxNRkqw5OzeW70xKuBBBSppgXuSFwfHpT9j1ZBOqJPnyaW14l3XjQa2UcZfktgvjsMN9QWN8KEY6AJSkxYJkgUj6wSCL2jR0MX8djI6XYEmExqWYyEnOr1FWQU6YLsslcr71Zs7uU1MuLlFajFTEaqX5p6bEA/UmO2qiNKT2Xk0GWdR3c+2i0MpSZ5oVnci3dYwR4t6JyXqnXYzdeNIPkux8hR3hTqvrLaFiyjqPjTfTpZx7+WLZAYdXUd4j43HH0WBmTr2ToE+VBeQ34Y+1MAFD8ufk/rlaZkzqEQEGVkNBWoVNOcnvrka9np22iuRoEmd0IpESB1NJo3EEowTFn3Tsa459whQJHgImoh+s8RxfKX9eE/KGmoPHkH1WMRr68HVz5nvHh6eHe7tH27lvD8pKAL8pFhOAw8aGtiwrwuIzHrIWrv4jvN60kfBSTAgsEpMyjPWYdBAWsDtNO8ttsjS+B6NfQm0MBIexDYhzE88eVUfyqhx5Kjx3tzYWygByauAJer2JMUfUnV1o1nnAG1iUBTUlAQPGpdAo4o6RSIMwpwpudMWhQirdbd62gkQ8sEFT/lG8cBh5UB45mM+U+WWXhuJE5nZXuU5sY6o9LZ2JeLezozN5pyhpzPNhOfHGcBDGKwPa7CchxuPC84qf5hnFGuUNMDMt5ZA3iOm6F1/CiaZGVOFy/Lxdqnsk4//ysh335DwzFo7xxR7XDGk6Z/ut5eGgBdghklq7Sqeq6lpPqt6f+dmlnVuO9XnfeILJuJ2Dm3AQ8UgxIuw4cox83OoTzaA/jZIqccAKfFngOfJl1ec2EN1icYsZLNVPIzTCgO9wHQ142lIVBq2gqC6WzFcci/JVWcT0ypG0FInKXKCX1beVanb2e26tUlu5Nqm2cm0Z9hxZ0Z1G/TAeGXFT7OdPK2Ktdrx64D6bV85gbbF81N37hwcUoMMwK+4id2nlXtp84qhTU20pirlTWJvHgyw0hOzFv7zLkBWg/zSYqOSnYTsedOA5Bt7ZYRtrdTMgD5m18h5EnDXeEPMWoYaMIvgLEdMndHjIuhi4R6rM2kmcpqvDXpChAQ4P55aJHcW8QQzs+zVs/ubJ4dvdo+N3dUdAXR7XAl3lkDm/0PO3Ii+SP+cl+DK4t59hDlhMxcj7PVu7sOJRePr70m7O41LGGtPi3YZyUvyloFWMfDvNU/pLpH7f4f+p67WbAAKJchwUzzA2ryc+wY71DUnU9wSRN6dzgLCTPy4LwDT5p6vGGa3SnGV9nJpXmis6e4JdP92purkMXBl3YYl7vQgTbV4PhF+6kVy5WLwc56pjcR6GJxW5AlU25ZMw021KNKP6ptlambsLO3s9ZfLAjEkfoPM3KlJUEzRr5b14adSPMOEfPGpeR5l4zKOzuY5RXkHa3KslsOesZs2wplIC8kGVA7vK9CciTaoaQe82uEvFEB11DmMlX+tGM0ir4ZxrDVbz/eFdO4A7vu/jT3JZ78edEYbOg9834eAG/9vkf+gdkJHOTYil2p9qLfjjsodx+ulPDB6bYJSvLBXruzeX2RwNO4APnj3vuuNMjb//afp6YVIpVyFL2o1HvY4v9qadltRdOjNZwyRXv9/hFcC2iJOZAUpxUV4OJQ21HbcVojSYC28u47hnCuq6YfszWY7w9KN8HHYZSrJkPKpyPMi3vCTpk9EQY7ZJndIqHL48ILUMOodfBKZkEJ1BqrLh2158qa2h9lOzHw2afxAt//QciLgTJ89/UtVxOXCTCK+iL7x/Sb2+rKND2DOG4v8khNsEGp7TMglEcWWCTTbYD6gqQ1VTOlPZ1M/iHMTr+o1CS8ZR3o98bZTKlNs6YYhdWauulaKwMqWM87ysSQ+ehE2fSTjMRQWWU3h8Qk/JKzxJg94BlRoRfqoqVbAvG83W08X1+e7ipZcFTnjL2FkvTV54a2nibTx0aznDbUxWu/JMeznLzVYdbmPai2B1pI2UHy9hx5dmkhY3yBm6IXoXKBtMu/SP4CbAcvpvoRS4OigjnyqKQuGq8WVclT9SOUB5jS/jqvTH99IeX+U6xhrwb6EkobZIRcWyzxmWfY6zXuR4g21q2fbTbpAMHR1f8o4v74plw+6Qvk3X0W5CW9Fppdlb5cdYBdRsbC2DOLsCPLL4czhADRVwS4OsGI71wS1nxlY/6XGnAMixKhnKznAAUaHqCnZap6IHlveAQvGY+yq2gV1kNEgKd+9B8BmtLuHRz2wP+u+hV2S9zL+03LX07EI3z8yZxWY6hL3lJbUz//x89fw8vfi5xleiCcr4bLTsVlY4OWk6Js3GnHHgMipyhL/DONPRYBSaJXzMZvglA1beK7bKit6e+nQyHr++iUEAUZdfrEUvp3a2u/p/Ln72/r5Df5wFq/9z8efZ2urriz//V/1PevZ3evgzfwovZ35zYy5WPLsHI5FM60KkPBEC2S0qDda/IdjdLILUfxMo6QsVYKRSIrl8Sp1m6zK1lLJbJwkeEtNIvlemhdgo2Krvh1AEl/BQ+ajoovZMRvBQE6sDu3YF93HTs4Z8W3ZK2TmyYIfeDGtzgS/KLajcAd2/AjC4DNqffRnNXpuPbXofdPgrQIBSyancqoc8MofqrgEsDkBpOGjHqIbbqY2yq9VX+ATv/OlOTchAnQE8JC6GpCtF+/ug45WrLmYqN3xVHfPw1aRBDykK7DJzRiFPp5anYPHvgn5vQuaovPGTmgpWmd9OzSK51yaASWxr4dzngKk87m/Rwl0ksMuNAUkq96/dd0fUU9rgbnEilQxi13+PLgGwAJowkMUAdleayRy+pi8bGSCkvC9KKTHo6I3RA4ZsE2CFeAXFJHvM2w+HvfgOhf0NdhImN1E7bLCPcQeoPGs3NYJF/0JuS5zqs5d592TvTXvFGsj1KdtFEppsHO+oLLzvM3aC/B3rj3pZtNqJ25SXgy8Svgd0EGDk4Ms7trq6qk1X1rSYxP8LtYBH/Ol/1dR3hE/YC67THaj17tPR6eF8OhBvtZabN3KQnNbH1JBk9TEzh7/vc3OrXJ8TnQxH428HqxEyVgy/wCoflADgt5PnpyfPfzv5J/znn80SstdmWlXmc6FWZZXr2GR0ZKQCUTdlq4CUd8RRoU4HXRyAYe1UsT+OUXKZ09iquaRsbFWkYLNSN0j9P+BLplQGcHWajMICo3TYn0Nfv9arV38RVOrG8We/DdsofSAUmQ1nZ9H0fQEoX5WMH5LSDQdjHcSZj/pOE4kmhRq4s8C/2D2j7pkHu/cneWurc25p9+R0IpTRUm/hfP+N1i6wvfpAY3ZzD0eD5Q1h+2JyM51EpS/HNvNyeVed/Rd1agmaitfKItbkk0Erx3zCTTLH8dSrNCdtiYnaoySNE1cHe1Ti5a3tlsEwG/Fo2byTpnziqY9n3CTVnPkX2ZnPiAcbm38N4ZGyNHiYBMloNruw9XMjOFLrE4AEv3NGp8FICkt5xU0hMNpDT+6frARMvR5Toh1+b0NprctAjRup4Z0O+BLbvo2EMxFmgQ1TvNVAH+inqfdSdpkSKQyte5OwvCAxlXwDLkET2VeURIJ1ytufMTLQc9rlWavSBlOGO9KszWUiWJgjBYAGJKKPmDby9xunzdug95m3kLOevTR7o9LubGNSu7ONv5z0aNpb2kxlRnNyM3u621hBts3DjGKyikI4are0pQfrJHaAT1YIS2rn54NagTCjBlWnDFODUT9E8YtHHcC3sKHkGb8abrPPYThEmVQWD1d74Q1GcAjbPZTdcCnUIKbEx4OMHtSxanATRx0G/SLEYupUWCMXQmGoFEw32407uiBMhkuVIniY4VfDcMCwaLh3yKuxNa7tbzv032YPvko0LACkpfabW9farfUlv5zJ/I/8D3nOTIhC5Y0X/ZLmXpkAJNzYEo3gTx9omBzanGikQkC6EWkfdvQ1BZeI9QBGHnddY7dJMASqLer6dX1Wu5il1Jo3TjOfrDbP+ty6srT+KoQnr8bT0p6r/dKQn724B1KgxS58T4IsrKSUJvNJ/6DO706dgikNOz6PnflQ6nS1XxrqtBcnqPOnnz7fBsl1Oom9yWORW2FqalI/aOo733WzeNTuDuPIToD84JbLognQluW88roiKznjKdk5kc1LrzYM83Y/HsLls8N/Ntje0SFGS+hj4nQyWyhSnN7cvPs+YycR7GikwA7rxddR27IKrYokiKI7I1Lpzg6r5YLOGkUudVSgudYc10ptnk0Ej0HH++q+fJ6vUBxV+CbDM975RaOsJuVH4TXxz4qa6hyn6nzm6hneoGv1RqncbR60AOt/FSBKgltfqLsfCERWyyURvGmrerjoTSgEc1hyR0UWWARDSXUjbXFuZsSFcdxMScmgxOzipIBIgDufo6HsR9TDEA4IOpT9jIu9sy5wEv3oupvRggKUu/Uvw06HMsV3Qpw+RmU3RPxqdSQws41WKe8RAhFFUUUHm4kUAG9gYh/JOGMbFhuiFnaV+8lqs/e6MCKJ64UpRgSU18nj4aXwpe9WuU2DEUwdesOgkn1ULyRhLwouexi0MkAb+OvwC7sM2wGOGmVshI7qaTa/Ie1eLzkGFUyQJ0QgZ7sFd6YpmmNPa73+LhpEfUy/JnoUhuuWnrHsMmG7COan9rZ2O7fTEQmcQoe1kQikXkh0JHkfqHRmcw41jWFxlmuw7CwnzYEvlLjAEsFmtWq0u0Fi1tDyJj0BBqyVY0CVK8vaX8Vck04EzSIxSLOH6gFLuliWK5JrfSaPYgjQokG7N+qEPn1Gvx/C+d5Od94EvTSsb7uFCGKEnNsoGorimBOPNr9yhsVSacEtMOgHfrsXUaJfoKgP9ASuiFeRkXTMfv6kCUsrt7+9BnPnk5HDowVUmBEYry1UOL3STUMPHJtGPa/cNC+fDDDnasdsle+YicNvzH1kl+ot4wy2UVrhyeQB1eE1HrCJnJE16GwFMN3OdWY6xirbPzsAB2/FjWHwD+DB9XaenVDcb2MwKV9MN7gJoh5eXb364wcvbpWfoK1JJfWvF3xnu99++UYvrz9HsdKm2fsl29AOMmMFQOMvBwUvyWgwwFi7Bcl5SZBS9HAeXQ6TuA0MYBNaOwIUnJ2vtEdJ7xzmf76ymuJ/r85Xvmp01qTQYlDn/nkwjJ5nwTXUcomnhYm6z5Nn7aCLjKOWjPZr592tF8T2fBFNzkSTHO1vO2zNIZFPgigN2fFogH1TsDPvfCV/bWhMK18dpnTAEBIZOVNvM/4xACaSm/B8pej7rL0/Ea/94MswSsJCJsOKKcBrHIQi00TUn9/r8OZy8O0CRTArB4/E+Tm8KwebQrUnxZgqx+hpEMZYjcz8lcD31jx83KlLB2Qlyqgxg8bcbJy3VUECukHaLfPqwbJedFm4/IrnzbQbtLZeeLzHJgUsgBO43uyGXzrRdQhX3/rZ9vqLi7mlj41lIg9px1BKGHqFeYzxPQV1yCWpHMBpFvZ9jTwaqDNJ/EkIJv+9h44mAulzG5M7FlB2AGBfYXoup3nKLpAfL9QWuxInEirMuY9J767BbruYncjWvWgcACph0C3l19PTjwx177fdcMA1XcNeqFKIpeR0exnmrIRjZjJeM/aHerTfTj68FyosJra8HkLgEKmF69cQPbDWMMRQTfjv+WhtLXi51Wxtw4s7OnqnOkhZkAi4ocgANsSUvm+OS0GGoCKx5yNFMXUFJtiL+5doLs6/acqu5jZB4NbWQsVWH4MvUToBp29XWmz2Xl8N5+mtwMblvH3Kg3oggasuJuDyxe4H1hwP2CT89yi0Hdefsd/QYb3tuEzQ5sKgQQ3ikFWmb8pgltr3iX/DZcIcqHnM/+tV3xdQn4DOuit1RzAjq0f4SeGN4HcjvyhQ7CKcrov150wGlmKCkWyUota8tbZWnoDBrUkn2f1j28tMx3i8XnRBV+40IE9Enk2E19ThYXzNSox4Me+siM6GuNcoruh5WTtIOnZ+8IasNIH0DOqWa7Z1jClLjahxNCJkm5qcMKjhw8okDfQvJdaOKOcDZUbsYUruvFc0mGkDywKcyAitU/AFYBYmZDkwdTnvBPiFvdxkNxpcJQEsYNRGKYMjJQRxBr1e39fsfAVEaoKPPTn5PXixDcOQsB9kvsEVFos1BlErPLjBoAPtUJ0poqyuvxJgRnia17ZSBjxy5r3N8sx7m+Vw82Kxkrxcxx3hjNQJM3LJ9qFvrht/G3doA73jKlMdaRxF86PPK1+TiS2tp83EN13EUMvKYmsJ9tO+KDmCAtemsssrdtY3hQT9JhXgfGyyVmUcyNakYSAXLBb/QzeZUz04tuKTme1Vqwmn2mhjQ/E/Y6fKrg0d05FpixMe7RDeDKNXw/iIRrAguqrkczLdDmwTvXYcJ3BHIn4QjeMcN5Da+fml1w8G8Ln/VNXDP+MELl3AruDfbe5u8Gc6GuJNLw3r0KbWKOuM2+f+KSRDf4ZfwvYIeoG2yIX8mYwG1N5sXjDbu0TmDNr75DFRNfl20GuPenyi/SEOdcMZGfgjTID1+xOWMUhx8OqJyxkHwETf/RkOoEU7/DOSAqJJZo32zn7Qxm5wyvN6qL1YXygV7YPxRobsScJhnEZ2KKMHNKnEoNcPwCCT/dfRyFEyWTyjbwKm4nKFXBkfTBcTG+OWkXhX9miCWZgWgoXAKyD5y/mo82qjA/921jqMd8eltbKnbfZVzeueZDGuMEU2+vXDLECCBEp0uDjV8u6lFbMawwERNWl97SOyoDlza621tbreWl3bdEFKTX0UIULCJr+vt5rrq7jfLCC5t4EkHfX7QFUlU8/iLOjxj19t20y11UaBuldIrlZFG6W4BnyGhpgvykHqxcQ3uaUDKR/DJ/si7ypZ3o9nj5xN5sO/4dv4pMLCyuGoPGnIG4xHjVqoBPbqTQCclYhHTT3a8CNGy+O2od8mJT5qyAxHDZ7MqMHTETV4KqAGz/vT4Cl+GjyXz0WhX+5ctWM5OY2NPEauVGrV9ULoNIyfqMdgwwd1W2pOjl/osBoPVKi3KLSk4jiBs23KU1IEjY47ZUgHp4oNnaGNHI1QNg9NztzuoCLx6GNk4JuV2nyxvCweDkK8nkoeMR6CHA3mxI3i2xDIWle5k5WSVzsxiL8s1NheJ0G/j3yM8tUkES9FZFSgY4NSVRKQYjYf2bPfD4ZPn8RtHhKnaZ5aBdsd/e2onChz6lS+seQwU5aYaLLas4sm+x0BZmwCIlc4JmJ2LGn/Q9ISVVy/5i5DzwD7sDMTaZfE1otg7Xx0Fa5dMbJRZdgfAuxXNd17uC+F9wVtvdPfvDompRbvNk+83rtqKlBReZsRWeTTRkmlMwnCFzPOYN6qjCTbmjSS7NbmXwR/qNXkAKSqLxUCUQ/Sh4V6U2kZ5QMjtIWbeWcqOttlmDw8vtzDQY2HZTUl5Oi7jYGsEsBJ6MXGOEXj+qKejtJNW74RwKAIKpsX8AcwtRGBZI/sh1RKxrxXUU88qF1YHwpvyjy50NHh+4N6YezHZnumg52Xyw4718Iy3U/CKzKW99PRNZqLo7xhPAyNbT67m9e32vt/GzJVLlQmAFGqLk4tKbcrahgkJHAIthf9NUZgpBwH5LDITWgjMx59hiyJlLZOCoIL8iStnS32ia6K0z8ztEUX7D/ZhsX7aD3KWF16HhMlZ5dRuVVgH96nJSh3z8HSs+E0th4yjX3aJTKxG4dn2aeIdjZ+GnNr1tx6/dcBKJQXwrcNHo5NhZZz44U0M1QyligASdOrbLsvapOozxQGdaPrrghdb41XDMhjFDskP3BrinFH+jxoljsyTpC0uxG+lRFsQcXAuIPsROlnvx9l0bWyJSjWyTHU55YD13dU0ZDRFFkiWjcOwMTLzKu0YQ1RO1d1Ia5etwlj4D8AO9onQGC5bjcD9GEMeCI0nDRRG4Da6zVtHjgkLy7teG4l0ptLDkmK6IK0HUX+TZSOMFWpsmmuRKVxjZcDmKpWOTk2lSPR7sne4SEzumXx1WSqfKBwqc1vtwPR1e+HJ592jw7/z+7p4Yf37MMb9vbDPts72j05OTgxhDW8n/OVnfOVn9bX1lyJhfSVuURF5yvvY32qwogq7PyN0cza8O/Vq9clMiIToE7Q+vryjhE6EZHoaj7Kup0DCH/gafNroCvqTi/oX3YC9mWbfXGjE97d0EggJKdzVz4Ujkl5NhRz7LPt1toF5UZ5Al3+dAZHrZeLZUY7GlC4XhVyj+DqE3/4Pu4YImzr8fzYYTsWYYLLi7XHtI1dq9w6a9MZYL9Y5J1z0Ll27Rz5+MfO+bFzSnbOrnj2QcG5tYeKFSp308ajuZrN876aUXyjxTIJmXxbNbPY78Bldez20ivOjKM+LLWQPSy1kD2Vht0lJrIP22+SvRary72g8QZf9IJGh0PMBxwzrC3SlGOsgTCJFN9cFkw3SPMhZn/V3KoE0K2JubbFct19wE5Pg5tw/DaXtWYGpYEbSgM3lIosDjPc2bggcUHkFwPNtKmwwU+gMu5u2tTYcWEv5/YCWm8NVrt1mwP8kQI9dEb9IU1BgohXb7CrhkjOuANvDSYajHrZDs/ZATcdjAaU8rvRo6rOp4zFvlD+pk4aaZNnry/L4gKTUVphZv7s3ypPeRg9kCO7a03C0zoLEoxFlSuy+WPMW25kmRHPQ2DgXc9xO0otFX8SjGjXwwe+waTraOebZLxG7vBOFaW3AcaR8PspabOgypp0iHcilssvnnttB0wsVBA+t0WUo0gnCuGWfjBIKX17G3dxSuY7absb9gPMlBAkmH0hRYHQLTrCqz5ugeSFk1fYcTi483/F8DvuBWie7lLIBd8020GfC3wTzUF869WbURpzj3avrkmh7Xe2Yz/Q6sov/C16cb6DxjKZm+VM5mZVPDsrjOZCnr7C4kTHEu1Rxbm60WxtPdrB+r9H4cxgRCzHK0CGPGE7USIzwBB9s59+iskGJn0QHeeyy+CKnRy+f3t0wA7enx7/i338cPj+lNhPdH3YE6nPFTUYgS0+Hn48QAMR9uF4/+BYDLPepNwoH4MkDWGc1vrrFjsObvOcVLxaq8mOP/5yxGRQC/5eZQMV6qJjt9uA7gH20KiZtNT7Ev7UWGFn1IZ2Ij+EaLbZZCgYYQd56hc5FK7zOgmGImrWVpO9xV8MLgphQhFARE16AKCFJwlPZM1H4OinrhS8mxdNxt++bC0+jcA+/TXuJte68Nn49mi7jWwT7pmG8r64a8ySdVkvSEjWjSjU66aMZL0iDnXrxdpCuVk5YcYP+1FGhrU+ndE63rjKZubW+e2huh6OOPaCPGcCvIY80wtZ8bIR7AMDYfh5TztWKKCpYwa7Jc0UsqTtYDAAcuAZmhy5Yqg6an+jDjeiy6Sxb2WaOxwLmkALbqV/Dp/c0M4IxY+oZ10q8kRUeXstx1yDp90y2/D0VKo6T17nrFnIdEWGko6wwAVbatf8AHA827UDvlLcu8FYosX2Y2J/zT5F3qw8NxdLQobsu5bZBAHlt5N3cWfUC4/510l0QHGVzS4vwgylrYV1Warl1pPKWrfKt9LW0oTfmWArOYOhVFaak0AoD9lOE8Q/eRcMt9l1L74MemR+jkdTDpZe2LxuNlht78PRh+MaltVolasiP9Ifac3Ok3AbDTrxLcyQcoHpQefQ9hONpO4L4+uOLrDhxFR43Fzuxtun7yLn49XgSiF8gfnU6hPNjQdy82GjBWSRQXM7xYM4n2HVPPMXA6PxKfGXJt+TPQGalZihNRfqK4vFysa+J7oWJEK8bXU15GX8ZqPKZo4lm5Xi7M2JQ8RvLRSnOwmWlLnVja04O38WOoKugralstEfThbPZBp8mcCnTvdkIWLFvVrhbPLbCfeegyucmIwgOCaol/hAgTLFcPKcV9WpAwgHH8l5jLM6ErhzeZcZ3mki5Lzwv6tXufFhOjnpxMLnwP/j6V3XHxhi1rBKiiT8OFyVs7CPsOHApZreB369myiNMg/5ejvMwTMlLVjfZhzYm/+E0f6Jb1P7/fgB3aZzbHn1aumghj5WJcaoGjo3fPL73lOZHggfhJmAy+y26Ndms3lfuFVij010rqc0ySg6ux5gkDFkX2Cn8IBBxRthL7xC2Tm1bnejXgeIGcAvhD/ws3g1rFCrO6NzUFvELvwjH7uPyZ6TMeOS5P7yD3JQg8bOoaE8bDsH58aZ8bCyOVYIk+yurANYAc4AF0B94R/woJlRyIQddlnjL71s+hzpiA2T93/ohpo3OyHP5wEtZ38RWqu2OlmbVNH4cmP57kJC+uGLTYgpJCohpqR+5fX7EVN8lCsSpmFmHIvzTIZbU2BxatMcdwsupa4i7BO6xonYRVI0h3TJm+YXg1yCKJwoTFdeKqlIMiI+HzBXfGk8VUgv+hwyuqI009ElhhC5BBJEvivKUiFTV7Nq6ryDJX4vvI7TbigesMsQ5f60bPLjM++VFtQYLw474Q/MTmQPas52L8Y7xl6InUQ+TmghMEw4VjKazViSt1Hp/7Yxqf+bFShyKTAHVTWkma9EGqPWzCxzvye8qBWZhm2cwuGYK1LwsUgADY24ez0LLjHOvQCqjrgYTZwx3pTQ1LbJ290hu6nbrmWm+ERvaJYUGpqyDr2hWaI3vH+C1NRThm1dLIsABzHiHvwjFS/dTxzS9fIa8+Pr/hDqk5RXXJNHJGgDj6GYewsnINwmuKEJnRtcYIpCCiGUkL0ZNChqOQbl5cBLO8ow44UlHHHV2inMWar5BNmXfL/HvadPmbZq4SkKpjuWpqrqzEy5kIWk/NWpSn8kyGo3TeGSNwMJoGCYKyhL28ryOIPqOhWpLe2hdFvMFgnuCkq6yoKm/iDacpMMTmZeo4Ev/r3SH6A1YC8SkmASRRo2ICXlcxK48qH73rUczxGpMk/9yDfwe9mMX0mGwlIpyBm64BL+GMFZwxMmGhtfiLbzcQr8Xl7XFEonko8cb/5QIYsWvRgfcLZs2mblobI56aHyctGtHzQFo4+WcgV6Kq2w0BclJC3nyiahrf0wibiIg/NlJGPkRtY5tRn0pEdxzilC0RrVJ23Kzg6MITXp5ytFkqCqwyBBPRGNi+ZWsrnBmqmncxveYmvRiUcZ5tEm0qmmWDI7Lezs8gE+lGLMVXm2+lU3CtRy/Z2EPCSXzPPnpKk9ns+FOy/8eyQsFHEsTl4dorkOJ7OsG5YQmjot0caw+uwU5Idhv6CuGwzy7urGwWistECj2KWUYbaDQYcS1OB8+sFn8f6ijtZ3g1rkI+RtREj1KYaTig9MeYoV7ptf3xweHfjvP+wf+Cef3rw5/Oe9fGl5IzLNLJ9mW7ioPbLEZKOcta3Qw7ZaC+WdVQknUccNJvz57KDkqaUj+kpmCh+/jKJeBzOZB4N4gGGkNPyATU12zTODDElaJhrqhKIvxRKYlBIXWaPNLXVtLjpxGS/euDDaBXMTOOrBd0Vjb9nkpXSE7vNX+g4SyRzu47HDlVeKoMgLb5t9xbS3IgL3V+z0XqcmeXODY0eL1C3rPcE9bjp7wdais6I+90oSel1rhzvKKjf5xtxKQ6yVKH8YrsF27uy3QhCY72TY3fxAyDXOenJm3ctEVkDvkZoqQZPgmnkYmDXxoV7pGduTee1lRRb0MKb9HesGmHwaiQompl0J9f6iTq3uugvyOmdYflFxzGiWzyWnzDcpoF9XWr28ntjoZeFpsI0Wr23NYQvPf4MSS2vMSdD5BxOkc0FuNzVLDa1FaZZXQOrK4NxSDKsHnNnlnc6nuRm5fjAcwporrNzJN03SX4mLmswkaNP0+YosOV+po9RFN50X10JZQ/dNw4VAC8uGBU1EosEotAxtXbBT7eNWIal1jyPe0tkYThdfWynamiwt9fjY3mnTca3r6wuPKZQtT3kd8/dvQEpZhUVVeLjW40lBRa9XsHUrsXOb2Mat3L5NBxfKN2gZqgkuAifQYMMkvAoTHlUehlsljAKGGXMrK4u2026UMp40OWWdERfYQT+jAfd6x4kCN9BOYsx+QfkCpQ0aioSRpWj3gv5wbb1WF87+/+iGA+IfRBc4G/RbiIHnSfLHFL8H2SCcHGdagO+A6zTiIBrhxbdc3yJen6zK1yHymrK0G496aCQnl4tGckhRgNupFIcDgQzDulqzZcGnfUM0mKOZ6EZ3MwaSV5V6nleT6nk2Ft7NFQMs5PEVTkTQbh1Jymt8L5vb+XV5fVG5rV5Muq0W3+XVvWmaopJP4ZLGb7Ji/Uq/krWF8CvB08xYl/BaM++sjUlPqjy/yTgbbJmvo0ZnQY3cJ2ojtKbk4aukrlLkWpLj11KG0xepecdZYeerOBU2zojh6mj05MnznBtWP6cA1nV3H+bKJYsqTsMsZkeHJ6cYhErx6/I4CzKqVO4FQv/z0tGQjE21I7d40tbLX+hQZAabSy3q64XHEB5lBJHBdSy5S2cWp/HJmNvFCHH7Yin2T/n5M0ndyrPnEVX1C3n48BNlx8j9ghMpyES1s0UXjWpCDKzhdEjmg+gHkrj0cX31GDGFVn8iYa11qZxMDKw1gktSgp6b2pgyDWGzVj9bXb/ABcPfePXSJxb20lB/YCaoOIrjz3TjNK962/TbI5EUeTv051MUs/Vy8d2LVPrrsrOqvMaP82pWQXgX/7xy75LyM2vS+j/OrWU9tyY7h/TT4rcTip2pjocGOdDzuxj+yrpRqn7qDX8NRzzB7ja7jRM0nen14luugvHMieHr0xLYJjXv79vY7/l588+z8/Pbi5/hr/rfPfjz5/r5efrT+bkHc8XXVch8RG7C/Dycz/Nrc/HPr9O7YXhSeX6V15idCPCbM9bM16VrvXw3rS/zIfY2LttExZIfzM+Py7p735QzPePq/WB2fjA7kmd5G8u78MfP1803guHhjM94luUbWJWeLRUn631ejGGOADZ6A5zxVZ+Ut72QfvHM2vjXfPI6rVcLz+scw+TLDihX2Y8j6scRVbZ3yg+p8TV/HFM/jil5TOFuMYW2DWEzs70tf/NEFY6bedXptU3H15/iz+3t2R9kP86pR8KafZ4BreyoKin+cVr9OK0qdlD5gTVR5R+2N5MfWeJQObuY20hiix/W7xSWfxJhAN5SuWVpjUqkfP2XQMqNykwvG5Nmell8pHTvEmeSjgmqLkuqDgLBNEy22e7grsF6weB6BO81t7PXfVfMVBD8D6vU6ADDQOu/5zUuVmvRY7iXbFi8znCLe3TNwkDg6QTbvKTV0oRGtdaWB0mVsQZKw6NikMYrSqFIDmrUnNuhJiEGVcf8qaZ9TmnAVLLOJY8OnI0Wk/0RgpJuVFLJxpRUsjxHgGQV6WpfjObzsFaV7PP64ol8tOWJAwP3vjgu9Dwj24ynGzEcqpzkJC3UKZCPaShuRNMiEQRlQLCp6Bk7Te5YTTauMcovAP8macY8buXZYL+daBIUrEtUX5lVQfVoypRU40JqiH1K+8kizGmO+R2T7YLmwe4jz8iQt3LlMpDBFPJ2VgYDYyK7WZZElxREqd0GYNg2TD5y+8CCaKk4vbmNt7e+uaS3mfIr+6T1K2Cn1dzYfK3/78WPS/wjyp1lGiiNWZ4HUXRJ1imccTHl1JMnnRIfAXDsDSzqMnhsifPr8nvC6worsI1lxZ9Czqdx9ZZBszU+9ZORv0noSvitwXFec05JkoaLf8K+TKbJncCJtynLM4wbx+e3i6DT8XhlqyNS8CCDg7PO2Z0kdKQWFuunCvMbguzFkji65YRV7u7mrlN5AZ/PIDGPL/CZbjMti9dbcaM45ZkTVX66iCFPmH3YnbcWMfb0+ODAPzk8PT049nd/3z082v3l6ICcpZHB8VN6Uf6Q3lyBA3LlgEdJJwyktW4eCeGnV+xSCUqd+eDVtPXeeH5er7S66lKIXc1641PMl72sdDTEYdVm8Xg94Cv5UmpPcWhMZ2j9etEFu6WUO0a0+9B2f0nhrimLvV8QHe7rBfV5454l1ezPuHoV27TVbP01OaBX5Xvq1bL7UZbtFScXNHGDH5yQgxP6Q7mhzpQbyrtdCo4oX84Prug7kf4Yzmiatj+4I11DDdt8EN4+ss76B+s0yV6XQsayrNpTtF02/bWeY3ti/fXpCDbTmaHFbphK7UkisF3GWVemp8bjVKi4hXZby5BtRFvjxia2gNnT8l439PzVdZbhZBuMRwr1RMLrqrzVHp5mVicoMO5wXTb3NaCk3bYq217pNynVKXJxiWJdgI+YKSX+ML0p9vO5FjXu0Pnc6rBbW0sRCWcsrLRJj9f+7AfJdfpgUCq0lrB08M+D5q/7R80PTwRLv1K43uRRzGrUAicHJlJgO41qivAjh8hN0ihqbzhoyyCQZGADExj1Yc+kBgr9KsIUDwP8PgOOB9qgqyzodA5uoB1OKRwAP1xrwwv8DMjDQxzv4a+60SJJgrtmPxh6wyRGG5XDLOwbNeB5P0rDZtYNB148OBmRKUuDxYODJImTCiSSi7UV+fh6xyOUegcOiFI9uCFKDWz7V0E7VL6p5nzkJ7DuWy+37qvCpbW/Di45jPymaVvJKm38sPTLLf3+QN9HNPfTrfwoFzOSzm2QdBhuS1gq32r1gsWfoYlH2znrClLMfMB9KeOkkvC1erWiTZzeCzJw2u8HGvEZLd1mfL7kyGwLAp2DrbQgkBkZqJcnuJJN53P38q+BM844bpO3qrTne/XDgG8SBojblFGwaEqwJDIUUCbqETFEiEC/nRiMz8EA2Jd22GFZrA2x3oR7GSWw1u9tKbuJAujgHXV8bGSHx/+1muw0QQ5MsWI5B5bX2miS0RtBIca7zhMvDFV1mulooNJ30+jlb2BuTBof245vvQKD1itA6NWS38IK9nyT1a5EndZf0ajvmUITDiE58UPTq7jYIL78oyikefCR7jQL1DossQ2kl/U5RDr3nBOpu9tB56qpyDosrmhhZ7s8vr6qQ4aIsoeSMUT6HKlLcVd6xuSmZOvb7PCKRVktNYVltDLhx1BvMEAJJmDxscFmOk3r1sYShY6sVt+Pq1epR3nx11Tfb5Zvqs2ldseu2Ctup+xJG/xQ3zvU93S+zV59n3ebe37nzxZZk5+v4ocm/zuhwDj39Sna/tDk/9Dkz+VeH+eDPkXbH+LpcvH08ouTRU15wE3ojja3UuPFl9cgaqeCZP2rmPvt6jReWqHS6vnJfLtnc4bJ86uw0Dz7NA87hNTrThfpys9LI9+h9BRlDKhpgpmRhYgciF0GadhhMc9zi6gSDpDURSLdjyRqTRnC6ypnSmXTCIXIlGf3Joh6wSUa21yR9FdKbJPwOvzSLE4LwyrIVTXDQSdFWbRXgzdU03l7Hs1CH5kCWczKXUm9gR1W5hbiiAchW7nlvTrCiIoF6CkmW/PqFAg1fAKUmc7Be2PxuQwd6ItKKHdpxY15o7k+4+weglZngiTF5ag4CcAG5MqiBooIR73MeqjyjCPoGKyCuCi6dU46ievGNjBIj2Az7UZDYWKTJy1FWk2CWxb1KRupgIu9JAwwEgNNfpt95aexnFqDi2WROWjkUNJgvWgQ3pek2LZeAEasouyryFN08lKdXMWrOYbZYXAronj5mOvP+KRZJ8gCLTaE/vp+AXhFa6Euqaq4RBbTuPJ3csPLlG6oaOQo54oLZp2IED9IIqnA05R2gnW6imYs7y1kKFvfLE9Rtl4hnFtfgmx3krKQsQTwhkO6FEscVRbdiFjHFmt5boCZHChUdyZaNL+VmsfRVT5ugcKKk9X1x/wJEvWQ9EJqQvkYqm9sM+Sa5fxZrQH91E3juHw20GVetRBea68XBloFYTiUhP0YEOW/CAqU7Z7Fw0AjqXtT7Zs9APdo6NX+q1aXWTm9Wv1s7aLJC4p80IxBZq1S8Lc2sbXe4sc+74QqH3cRW5yFlYL9R4w5M0uOpbAwT5z8k2HJMd/5eSZzTqnqbmOzD3RBAO7BsKdLQ7jMoEY6k/t9NIj+PQo1g5EriRORMOrQKFPol/Exkfr5Ch/1fKXO+RXxlM+h8BRmA89MQxNN74yTsy8w8Ig0zEXlMp94k6fUoSmJCuIOwssfm4Y3yml4Y5lTt/tRCqz3IB7AXuz5UUenYFfZzIImT3LP+B2W3kHQnwnd2svx+O7OZRWXcdwzSHWvG7Y/4+YWhg+9OP4s3GowtKXoih3uM484aB75Mk76QWaav4qtXNumlNGiNyRsr/ZcfwQkWzuH/2nP6nMrzjeDyb5cwL0v+UNSwuAXNHa/s/TpNNMzM4CgvV9YDImOgQry7e8StDuivZJVI14S8TpJFpgy1KukB/LViDpNS46Gp4MctCBpynW6UPN8ZXv7fEXGPTPr49AUVVFI8aFUsIG8FbxpZAYFE9zjvT2ks0T1VugsDasmbqrhc9Ga9xFftxqq3hS2Tkq1XqH7Fr2oxnOrxl7fWHg0uByhOohENFnsi+1gsLQVVWaHC08tgCtZlMQH4GulPppQwjLs1h1pOb3/gt2hvR9wdCg94vBwSbIfHT6yWAJFSrwqBWHHYgM3RC/bznGBar/e59yumLFG6qlF6xiVtRQJi4bTdKgX1IhZNBhp9idihk3gxTs8OY/HJXxwY5ZcrTkCzhXZZZinXF6huzOoADdagFjPZIdF+fwCwdqiA4GAZ58LTH0hIgXSsLV9YyvOLMvX91LzVa5QJJMXD0UePDzwGkZBEseZfFzumY+8t0vmJl02Aun6QTw2YEegQUkEmwuTOeQDNsulaZ70wBCC+KB/GV2P4pEUPjm4FmOJyKQbD5pAZknGFYPnK4BedTeX0EAfkVTZTeM0UZ+HCKTNvJ6XStkXLQj/lk1RVkCFJOAzJnOhMVFNzvaYH0jzJlG9SJgyl6UYoaZghObWsmBz8U0L/PzF0zYw2A5H2ZMlL5rtNcRaSeEKDv913jyIWHQEEJeOTpxlJETPuvZ1o9bUbtFFiuTPpQS5Wcv5fKPC7Pd8q/L23Zr09r258Px2lPpp1ulFlz4qZr7k71WXP7lrzE6M/H3EUMVV6ZTQMI/OUq12QV4l9NGW1ArBPUhSPDQvQ8aHpkOsGyWdVbxV3qnj8tcQ9kuaRW15Yq6yY430ohRJ6uR0/+jwF//dh/1PRwcnst4pHw0ZZHh/KaulURZC9+3PsC/SmlWtG6RwtGpnOG5zWNggY95lkIQ6sTsO5meaY5EhiCNNc8D40d6Wb4JzCSmDjR4m+ttVaFEiHDRtfCQa6eIPtzBBoIs4QmvbNUOSMLcR2jdeLQvzXlBHFQoqmfOXWwvEnXMllKb2NUxk+PPibd7FpbugRtQj+UDei6qZ38vllVw0Gq9P/xin2apwQBRaMGTsOx3dVATJYJRq/Lwq6cXXUVvBlOLqJTFtS/zjoCWnLutL4NWrcWx8rgEj84ROSzZvCCWAbF6X/eWe3duISNiMLFzQFrh3J6fHBK6wQrfUoAdADZW1zp0WBeojP7b5zFY5a7JVIQJYf7UUpr6wNeOrIpI4iiqxZH1rQQx6tUU9TKUtLHijHhq+ckImYxPsD12XE+An0LyuPeLmMvbtnMUD3PU81kM3TEJF1cp2Dg3rz1d4zIQVg+Y5GFBxAQOwKq982g3TkCFjgUoMbTwSO7Zhk8E1P6YwNuiZsMrnTnuuOY4KJ7V6IzeDcsEEf39wm+mJHmkOqwmQ700wyGRkBvu1ywTW5sSK6n9Duqm0+TX1hmt1cl5oczZkDu1l1hbesBeJjB7nm8JPR/1+kNzZAFNRbTnApmSBJcCTcxn5X0DkFy4cOqGeov/hljVFXoJdctoXVjWl9IgjKS1GDkQwm69an/CT0OO+OBGxpO3y2QsFxniDHQ0HnbTbYLXR4PMgvjUidOr4qDXLH2O7fpSmsEIzZ5yMJkFDSrMesRzLsoc/PVPVzUW5q5zhFOYTZizeZVFhRkjsNQLrRMH1IKa7vQ02YysvB+RULrMEeLiywiTbUtWnjT/C5F4jQ23AKhUFIQpcCrJ46OcXC7qkudQUvDrSnR5PCsN+9odZ2DmnXaQXORglu4q8gxRL8glVdCx0RHBjpEtjsaZSu+hF95rygy9q24LMiRFTZ3JgNRJ6zlfq7G/IK/Jv8+jBrabSoW4tGKuD7yj1rzGEbCBB6ASfvZWPdMQplsyHd2SlpqO4RBNwtl48ZsiZVqVvXGtS37gFiw87fls5o8xUVHkyrVl1WJkHbaaxcWUoLJl09TLOAPxfDe7fATp91bbtIioWswDIDjKoAjXDLOqHTeAlvXozSmNuz+rVG47G8Lp6USdM/Jsw4U73rAYU21yruWr34SDAGrg7k7CLzrs3oR8AYdylkdQQyP/dWz3UBBeJyyiUdWCN8PY6Pr1ZZxXl9AKlZxeF0jChdQ7aIbXOi+8fP37UlNE01hcqcswExCy3om9uEGpZQeDjmlUQ/cMiIn6rZd5UZF+1OhFEQ1KQ7/CQtW7Pu4O7YthV8SpDZgxBt2WuCxTadjGMdCu1I5aSGYyP4IEKMMQQ/Mezsj7sAWRQNo1ez+XJil7AucOtFQgegzzGo3Z3GEec39VL8T2mHE3+J8QIzGt2GcrjjM61GlmcBT0fnXKdBe1ukFgFMpxVmvvhmA5y/DVRAHn7AxVc1DR4wga8Hq9WwJ94hoHmX5UHml+ieIiTMBKKzhwCuUnqzo8B8HTchb0mK9Kz7XZPVEFktY33soaTxKhIIVA57oghNcSxsQWvbr665u7hH2HiDc8oxlvtwuHbqonBpB6uLXYeIYfwcc3Lag22Vnd0pEFMMrzsFbvIn07QhZDS8bUgTuYL4719EmI87EqX5LXj60EEwKZa9sJB7shcJw2k1rWz6bCNDT2js0f3wK9wwK8Q9i+WO8GDAMZkVifCmWKTSrjZWBy0MVc2DnTU2e+wcKj4n8kajAOs8f1pzILoTOMSxBPFHmwjdzC+T2EHAd+AWKhtdtWLg0nAU77BCvR8xj6KFRLeKH7EwlfF4O0YNyDCM9m+JHwArUDoJ8zw9FI9IXDtseGmVQ43FQbEL14vHdxIdXvoa3fbKrApbTAfpsbT4YxzUQJldO5Fp2WdipEU/RTOywEaPY0hyT05GNMGk/YPjmw4eufsP9maOyGDS2jDsQtGEc1r23w17LnRqUsIQys1m/Jbz/im+GLgJAgTqz2/HI1vH9xwbKPWOF9oa7yD52IVIugavRRyuzR0B5pEiHKL+QiDNfQ8WmuuIdjtwtVybu22118uHdSkd4O234EPSdH44KC9wkB2XWVKXIU6k7SdE5/r6RBo3AKrWJ7J8+WcwChsf8M//nB00GD7m/4vHz693989/hePH7Lf8o92/3VwzGh0tAjv3WlzQAoeXFOqQI1NMLMJ7h0fnh7u7R6xN4f/3Gb/wGCKIorRndTDIhd317+Me16dJaMBml1GWRT0encN3iHZX8UwhYG+EsEZoJNRGstFsEvABHRw0sqb7AjoNWkU5g/jiRVoHE1XMDsez6qaxdDV/ukHCmZyOcpY/k3YLWboqWVsNETxd6fJTrvABclcr9EXYSZmvA/1Sul9HPaBf7sJGe00ZMlCtAObz7sVkcZyQVAa3IRSuFaBNna1SrOGB7mRBG5NY+DWNO7FfeANOrNDGX1hAlBgGwxxr0TJNvkY1gvocQKNVIhAII8+/BEN0cGRmopAJgXGJe+42f8M/6IQAmN37ZwmI8xh/AVo0o8/009L9ksj/nby4X3+8I80HhAvABeHvGfgBGpiZk2soemGyKgyHoYDTzWF28Vtrc6ClF1ZLBRWaXZG/aGnK8mA9UNjArTM3mkh6CQZJr1JS6fcHcHnWk3CoIOhY+milRpyb/hizjVQUTP7kjkXkDcsXwHN278FQgx9moYvpyFuzFcw4VmKiFuVniStST1JLAHOq2UQEZd/hSoOp7rVzLIZfGcEqtqi+XWrCEL/wGYuAnNLMig+BA3lna/snK/8BEw/+xn7ArJdqZdUPB91Xm104N9Oq832PhwdHe7Dwb0Kf777eHzw68H7k8PfD9ju+92jf50cnrDjg5NPR6cnlV3aY4u6BnRwqfa4ObXbATv59O4dMGvs5HT39PAE+KzqwVfPV9hPbMu9cilM3zEMA86U/vzC2enV+copyrCUpChlb5DsMJ6tMN+scSGX4lT9K6xQu7ivmCt0+4ZucrtK+Ab92XjFQfO7X802lo4vElSZf7J2ejMeqwrVZ2f+OR8oZSxwAnjKdcbAJu2d/F5EpbDXUfEYlMgTn+B/VdRn/IHCFvyvoXiqmfsMn/BNhn/JvcRbi91GjXTFUy28Ed1pBE7LxXwXsM4m3iFpPYnHeY582jv5nwaI8faclruAzmZ+J1swbOJNrtG+KIkJK2dMHeFrNTNCyVJboqwWStlOz7a31i5g1GEvaIdeDbAIn7NaIQPj7ZxquhYLdGAawzgNecoUgpwjom0NVNSD2cHGJEqqStmNPW0TKzYf1XhzRo4JC5YvsLhRPvIn7+OOoYewHs+MIV7oPTMjG8Fl2TNv8IFj06jn38tBZXE20HSeCGsLfjjp+6TpsOwqK5+7JIMP2EtKKKgZcpEmoeNSWubeSigxF8MIV2WLzaVFFa2wBk0u9aYQjIoPRK+ftAmvbBSmRhJRuRJHP/jWo7avJjFZh8UsiSbjd77CL67UAXoboeVU3qVt2H7OPx7V/NrjA26zNs2m14A/YEL6m2gCb9yHGd0X+hHroJ7w3Xvm0pv9OEU3p34/HsAWqhcnchPFIr+EMe38ccncfW3k2StCtyrPpq0p7ddfLvbhtE8qH9PRqay80t1p7S94WBWuUi/Lr1Iv/xqHldwvTg+nsRXnxM9pikOr2suJAFt3CdUuD9w1dFGS3y7H5uSKbl5r7Aa1K1fyWK8Xg8fS12R744jNitFcGjJYDIV20UL46S+qwryDv0ORFBO3VxbKpozaWh46XKDedPFIVhAb8quxZiwj2tBP3vNoQNmq/KLlaEkknJR5sQgR1iDW6aoX36qRnNxb0Q+egoRpb0hE9+v1gBe6CXspvYwReriXvjmZBov/F+ahuwwZ2poMU9Ovb4t0fjqyiEg+nDtVLLIHL+YR0KbgovPCgBvTR+dFhTJjYylPwzZ9Hb5Txx+Jdu25sZqf5mTUF1OBNUUlhmtHu/CioNbA3G4NEaV/wMLBqE8m5545bL0g3v81GHR6IbuMgWrw4kM2aPHlH/BVCp5v3SANsiwRmaxrUadWdySqlaH9RebuqOOowoNlUzkPlm3X+BwNVA/4tyMfbtxTfeDfxRqottFr+Lkex8JEM1tIyUJIoQFrJlVG1Zrm026+9XIpQYZnxOhGsNuTdvduPM44GjxpoqxZQ421ngehDc//wY3CVttd/GGkySw6pxwOrsKEqdE4NnF1qreHNqZNYYo5xJA2ycBSQQqSyoFKExcJ2YzD4ZZHB1do4SBVvgTfxhUV1LdpBvU1IfANYg3voVhMilOc8XDiKWtTH6qpYMA+bZbb5U5G1ERUJfQZuiD0cWITz8pwfn05GRrOwtJ/45SsE4TwbgL2prLtnJjNT8XqlC6sIBcQLA5vwELgUK4xiLhqyXRpMqcAJiTBBSc5EYp4kPP8hF9JOJgB4hAJyv6s3ET5HN4GcMlL+LhMiXGLbAiWq5diRULQp8or5kmRxs1ATFZvpkleygHGnJBMKJI3PZM9XlhSfpvreQL8+YsaargxBF04rgc+13mMh5xC9fnwDpwGZIyllODKLtVhyJdE+ApG8IW49kfL2CsGd12fHAAhNViFW9OnNHTAFhBjcBNEPTSMbXBnOE5AlvOtqC4YlQJwMjEZi/os9ZGNWWoSYgUfPx1//HBy4J9+4M4vJRccoRDccTc6E71eTHRhesZOkzu0u4uIS1S8oWQGU/etye/FtzSFnG+jJ8J+bX65nFfLiTLc/NdHKeAEIGPVXmBORl+KuEZpomAtxOgRiYnx36KfnzCezlkZLkvtCPEz0/XEJgapKWMLk0vIG1kFOktEtnyAHZg2xeMkhY4zX6BJN7pGToVebd02EuAtCsHoqLvmx+ODk4P3aOr+4f12wbWX19n9+PHocE9UWXdW2f/wbvfwPdKWq/Tw/Zvj3ZPT4097p5+OD9BXxVXr0/v/fv/hH9DJ69dayDfXu6iKNVoh9ZpPo1M7YdrCoYzQuxgFOq6Ulc9dRsYHYIqmbzJaeVMqmoycUfHgJhxE3Bp7NKAkBnjoCoAxzIKEWon/+ymF76aRAp3PxvRkFGTX1N1GPBQ2bYcJ6KRsqnXL2B6Kna+CN+acVkN01aRXolsgwdfKvCvd5ksZFOkvpSMOJMzS6DinrMSsHZee0xMz4VOYtd/LZqUUd3NSKe76Yt1skIb9JLyGHZ7cERrswpP98IrczTnhSRwolsyPfbG9DpP017ee1OJmOm51weyL3TvnWDyw943+vNJk69VTMaDfc8cUDYorcrWut/4ie8ZpnlVaYWbq528zy3rANprMLAs7lGZZFDbJhN0LK6AYb5NmFJDf7wdDZ5B/ZKlJ0CqzrtC0dbUF9ZO1fH14lWUl7+S0hanpMInL4X7KvIN/njaPD3b3Tptra+t12TEGvg6srsN2nN6lWdj3payhfBBVlwytRfyPgUNIwSVB4RfUw1CQKehiff0V9rG+/lJLZkmrYj+zQXgL1wnY4TchZZWiMLtQiq2sbvlHytNYUhe6xx6v1YuDjg/vDVM88AgoXn1uczu/XCi7uXFo4fpA5dBRVntO5CHT4Ihzh7plr4c8ehC6JpAuhhK3JdF1BPNhr18AaSQIMWGHk0rTln3ocozzUWtra+3Hv3P0r/Z19ndPd9kbiliFAp8T5u3dBYM6frW19U2C7fXV1tqPD7oYH1T/Tr9EGZy566ubhVMo6HQ8OAXOV6DKm15wjfG/zs5XLoG8EwwpNkwwHGo8OF+5wFr7cD7zkBRS0inair8QA+Avl4aSqmHInYSacjTpB+ln3vLSKPwZTbzgoBvMryLy1cYS3NfzU67IjpSfiO668jw0WLtq3noL3hpmu26tv/zOJ6KDG3Ofh0dQEZlZxWqupsOwHV1FbcErkuwtbXfDfkAzSZ/nfT7/iQJpFcyjVQUKWbVDocI8n+fu8uvCZMj8D3sOE+LDnK/QDxpM/J33mCdfVRYQmTVgk6KFFZWhXKRmhtPZLzDVXCYftLv5KxnLwRd1Epi0LGhn5O5XRA+ZKIw88M5U3YZsttoh2FE/B4AiNyFilqsvGQmE3wl4j/BdeAfwxxf+14RKg2llPVPaera2lgl2hJRW7ZBSzHFVnB0D/jA9wqeMv+gZYY+9NC0UDsWr2Wb8Ss4pYDtPeyizvONZCfScUUW2Q0BFV2ojkXwByYQ7y2030mmXBTQyuwx78eCaYu0oEwsxBVKpSfopMPyy0o76y/L3UAtT1gHqiWEdIC29cWmqqvidV7R0g3IZjRyfpNlEEYZKzMSeSd0EvKODXz693WZ73bD9GWUXX1Un9yy4DiLgUdhXNf17IwCXCLKDTfkrVajLvGOEqW0GYPOoUQOnY202LOHgUkCMkFCNAxit2tPmkvkdXkhHpmKcIayIBUmrB7l9BahgIz+NR0k7FE/IhHkqIFF8EHBHJMxTuNFG+6scMAYFbzOSKlxFSYqpnrN2F0lN9nK430AEQaTj7AuvornVEYmlXOWvLYhgSqlRyVqJW5/SPHgvFF65zGsNk5cqWJTpl0tEks6g8ThnfbUa+1PSz5l6dCFypuK705gV2P/3Bjz2L0n4AiB6vvIVF3nPvvKXMIfIsv56mZAFsxmPgxWrzvylcJ4CWbQ1SZ8UrhQg3DABwx0y/W2YKfruKA0FpoRXOoICXyFoylA3EI2IwevzmUW4tVhJhMeJCYJOp1wuIAoXWDCO4jC+pSOZoUgdiLDNhbZMZ8KB+4ZNdR0nd7ySdeG8wk/Wh28U9EQn0igYNrx40gnTdhINjSfilu0no17o7DiLwiQ/p0/X4KQuWix2OnAIcjIDPh4PWfU+9HPJ4Y3Ouz9dY95oEGFe2aBHb7XeYKfrzDNMsfFZi3lFiYjFDBsrp0l5aYREAx304Yu2Ya2YdV0YTdfx3L8OBmFPPgbyqpcf19TjjqX19Cxr6s4OeYzAJ9nBf7RvuhPMraxxwcyRx2AI0JgvVaml5h7FWgvOjhvrERjzbdDybRhT1pkLehhnqGHFw1g8seCnJS4KQDJuFEIFeu9OqdCFurASlfbNuim+xgCNEqFRCd6w0SCLeuyGfzw9IgVy/pdJjMFzmYhzzEmn+c2AotsSWK9V4cy8Rha0XMdfbS0+R35550tiquTKrXpzF2twSsZcW5ZkzsVPB3duWQg5+XQHk757csp9qrDbpuPaLIdUN2bDzsh5V85NmM4KLc7kj4uLwn0A79hzG25qc6mYf9xehUQb5TWW5q6b58+oSgSaqVNMy5xRIA4gT3moW/Z4UKId5MVCPHGLT7WTvlgo5GCobFuRNjvnfBucr+RHMT26t0XpRPeRTphlTpPams6wYlP+Qg2FVqhu66oCZWr+ma0X+tPeBO9SeyB61Z7kHWsPS/vGF8k7xb9Eb/hn3g3+Eu1nLFXYqDy3N6Y8txcdWcIvqCniFmml4GJX0vHl5Pe9p/IiOgmTm6g9M5tefVUqC6FQ+hVv9AdUm4egUzaqCneAMca8XgXQQatal8od7/Vk27MNP1rNNRQvs2fsd/6YXY76Q+4/Hd4yOFH70QDe6PVdIbBv1A+BCPpDCrELxIAPmoP41qs3ozTmGcy8YpRcnsFrZZtDTI60xZrCtMFpGwAr96JO3VkmbAcI4YiwCxx6XouiVcl6JBsoq6nuaqq6elLaRiKeaqIgcFzkhfi7G/+2NhcrRvAYsCHlru8IQ15da2ZuA9/V2MBYVomJ00esA1d2mcMqvrIu6Ra8ENVKnZZGxobqizTqlLGL/cRertWLRbunH96x44O3hyenx//CvGAK4E6DL/Eg7t+xGwKp+gO6LTocyhRbu9xf4StNVqbVIqDBZForroZ47zmlFKrvMLRKJ2+tAACvK1BS2sUHaTrtvX5BCtJ63oni2GoXZzXJr5X2lItHSnrIGTx3H/VHVRBOZ960sViSTrL8CAdJ1O6GPPUX5lk7EA90bLGfV7qyvXgyHYm9ABNBWk/r/bheJR1fnpw81ZvG6ctWWmFOfNkesI2cvmwNlsRxllu7kVC5iexoOKAUltdRts0u4xjvxZQftiJMs+axoqY0RtuljX4Mf7JOlJAXuXb20S07TizmV5/eP7ohRQ0DLvyaxw+Dx5i/OiD+20vJZq1CgcUzt8mpSDNg9aCOWd3i3k1Y8CXLZ4ExltUP29YfHvkqipE8r/02Ws9gWdFF7Zq8hKCC2+Pu8YXa0/Gr64sV5X0cHqgPVI4IRpUnjXlarSebBhfy/agkbkj4xWCDZFgZXRGVRWken4vsvpBg8WmkwKBT4FuBly3IokXUi3R0OeRxCJvJyNb54P/OajAszxl5szoMkpQSIa6uwtNVQI+ay/K8fSuURYqkXZWCYTZKQp9HpeDpvIu1svBLeRncvqH1zpZZVHeK3UVwDv6L7PR2dtia7prQhh3NDug/qDx09vIm6KXh/Ebzai0RU9nkJeQbUgoIVp1KRHj9Xa6uUyCDtiinibwSzvNzandwd1HBJRx8gW+G4aF6vfyMJrk3S2FZvZAnUB7DOGgzwMMaz34y9faCSziqMRYq9MgDL9+EWIqkX3dYwFr94jJQRcc5kHx+GM0mLV/UM+iOWASSIRoquThtkoV9lMLUPDVvW5YPJ3XPYD/ymhooFIME6u0sPuZ5/pYcrkiqYbUXEu/00VNWvygHmIosD5uLZTA/juFAEc6we5eSb7jce+XMR2n1+QhKOg0P4lySIZ1H2pgEcFAvSIiQ4n2EHGdEvwwYjGGYZFGYTsCZ4LaGXXkVUyJmoBZ84LnPdIcgvIbD+5d3WZjWtvPOoBcfSxplLT5fQvUE96RXaASEDV9qs8FadVf7KPXD/jC7c41HTIbV6P6hTMdXc1GwobQ54y9tBsgq3c8vg7K2TAwKUU8WovPXxPjhrL7Y+FFY0tT4ofRr3PMOvsysAKMfd3hGKS6/18m0j6Pa2dtVGGBYILuMEuR4oBrzKCsORSuEn9YgxbnRPYfS4bhGpn756IaohYPCbpYl0SVwVgdJEicP6rhNc8W0EMD0XQZwe4SVtF3rHFCcVkuVqT6D/Rbhg/id4I5cHgeZ580tzixYophJcAYoZ8St0CdEmpIGTyZIfRSscSxqarTpRQOMgI65cRtAIJ/DAYNtH/Vhu6YNAqB8d7FuhCl0x6ORcNuVWAQkCgQafsm8EIUO8Kp2aqPsavVVrcFCpOt0pxZdD+CV2PmYcHap5gcsssCcnw9qdZuKsS7P8gsNMG8vNbY6vOzBHvVlt+mo763zJMP4GjDJMJWIywr+aKKL0pBCldrgeCDek3htfGgP2Kdr+Ab/3yZrd4MkZUOSEWMFSg0Rd2zAxGrGvMVibVyFPp4AaqZT5G0ulcyFfw3KEk3O6LgnKqSx7spz4hY1lUy2uCKBL/S34bMAVJ2LY1z+AJRpnInOBH0pV2HTUb6ALHIKQww69iV0BBKpwZKA4a89qzXsgj/wmlB7/hwltc3M/PFF+/VH/qvQRXATaDXb+t/DofbrOtZ+JGlZf8mlmCv8nXbzv+F9aL/ugn5P+6V+OIOl81dDEGm+KzJvhFfbwLYGekms0eS+AAn9UQ8FePMZO31jfelYGWER9gCpS1mLBUaasmVNzc4oLKEEuHA6s9z4GJkZSmiCPkYihHnTEZxJXaFGV0BJxSAlRqoTqmmmOtEFtG/MSRg211CgW4eTyPPNh+N3u6f+3u7pwdsPx4cHJxoZx6hlrlkDnKAzVNCDEYycVZhtrxO3P4cJfgKedk9N2xbmFqZSo1yENV0EjB32g8/h7LobBHOKNct3bULN/mQYY9dccGzRlzM1pqDGuQscD27m3L4Dz9sIL03BKOvCFabuCGGQ60iyxBNXIa4c8rPYMxUn5g0D6EM1l14ZmoFGuc4kr3QmO7jQO1YLKLJS1JKvqlZMEUPFYq1QfHbhKu+hZSSvhExLzVWHAr+IgUiQYg1muKYU75bPGH4T3pyzMmVK/bl18N5artsSSd0nwJdivcUV+ZprmVpBzdXBjHoz9dL9KEXFNPWZlkVHsSmYDuftfB4NRzllra1t2+pelw/EAzUudmtN3Cwa5MJa8UDKUl14k8tzRGWSovhSOuVqorg/x/pMbq7wZkymBcFrNPg8iG8HBQz7kaz3KQ1fxEyiCgmMs+Yc+m9MbwSTL01HmvypkMiQrSbBTv6zyiaGOmcBz1sVX4lIkKpXEbNZoNJEtjH2lLBXuZcoP5volCMV+xzejTeOEd+5U5iZacszxlYmlL2YefcoUIScYDQorKLE/ge9SEUruqDx9dSZ1lv+nFqgLMeWbkubGHVsFNRbj+2O2ip3R21NnJV38QxgNNuyEoApr7HYwGJZ1unIUoEpDzfYd4LQJMnv+ORsKFLgYwHPhKCjMU6a6b8y8qenOlRMauUvZ1UELgdoFd+B/GTw0vQDLfcB2MlNh7VZ7eR/mtnwwtIT0f64j5B6Zq0SW9YmtubfWChsuUwCfAnAJ2JIeQKX63CAeQ3gdRtlOrpUVHnauFdvAvJ7caJKYWmWv6mdJrNkUR6ZfFJeyTQSyZwIHgBHDFx4K9qzo6N3q/EQuHw042fUG5O98Xj72CWTXRqXI/6v1O/Kk57/+4ztzOp/ssOTgz1MnsLWt9nh/sH708PTfzHvH92AXBSybpT+vf5IY2dBglY50mxXf8dnNcQn9AnllWoX/HbHG3JdP0aQNdvw57ULWesGPsZ16KrHS2oXhTc+p/LcF+uL5dBehSm4/QvOAO7SmTEq3w1I1HI8uf30CPncGtxgSijzrhtUymBE7WxK1SG8ADRAoZtGPAwH5hzqLEjZlXbgy1KYBXbU5NBX12mET2GnFChlF0YjtOXXFpoPmE9MK4dLxm2tMDfilJq3sLlDj8Z0OZifj1ov17bYL+Z7SoMbwOAs3mZftWFy/3LLN4D3po9hMChUMEs/9FkxHQsW8kIFafVVAmREiU/y8UceQFwmTdaxoqpOZQivzSdT9jhXZ2IGQfrTpV3dKHdM3VgaR/UHbiqn5/pElSsPphdP5sX+0G02WVrWDHaMD9dKWD1cya/RrBCvxGF4Qs/UCzqgMt2s4BnvYBgkWYTfv90L0hQF6DxFFH+6px56dWzyvz/tHu8C3/n+YN+aCMUI8cVZQ/nUT/DJW/nAMTRsmnDQgSv5nS/ywGOzffV0VzwcNzR64yaZMfYxPXIOzuPIxB2+YF9LAP827tB65S46wgOs/vjkvllO7pvl5P5iodzQH0rtYkP4eWiEieje3awCAVrNtYccNNHgKgmkPbQBBo4SAQt7MbzJuNcLk5niQnGpMtgFPNAZ158U79qJRFTlP7k/6Z8874lgZCfQHwqKZLA3okSPW0GCbbWSPCWyJRXXuL/Oq40O/NtptRnvFbWPeYfAAKp1cPbPsELKwiFegj+iazwJ5klvyZlURL9VDonFUE5q4Ha7Rc2V0pM3ztfA0bTZbBrBjRRXzvX+KjBVEYfVXlThPjy1Iq1DoiUZMou4dYCSLPFKeqXYmnoTK2nLo0Zdell+IX5ZAVSvlxqp0O7n36Oo/bkYvfYhbeYuQvS0uGStzYxsO8b0idppAW5ZAF88Y+qMbgdDHlgd5ds2tkhGhiKlSbp0sDf09gPyC9dbGDzCaIj8Q9jxe8HgegS7pYrQHbV1uCoxnpCL8kWcTLQB+H291VwvWAA4+ofKqEX1HEUqjm7B6GAw6l/CrOMrsx+40ju6KbQ235avmogusHhuI2WvL1iobEwl0A+GfojfMpAQtCd3v8ELmU9nBiOTSOEqr9WuNZjwQXZpT3ernm7rLNit2r1zjvlTfdtoj37smR97pnTPHMiHjs1jlFXGnFx7Mmne3G2hl+Vb6OVfbAs5ZXiVlZ7OH6BaePfAXVUahpL34gzBLszzqYYKn0iJ48VDT29en9ecP4sVHXHSfat/h+rNa9d8MunzLFFR7V9j/9n5A/BSJ16AU1EoNISJW0MovEKK2stcjafdnsQ4niMDFnZ0ViMzc9tJRMtLJqppTwq1Me1giLcbUVf9LtRMQripJmFnh2cT8ilEow+3U69d5373aNzJe9HvrGgkIdvWLuxeY5E46eG9cuNP2b7WYGcXdbt36OAy6nTCwdjuH9uuYrNcjLS5NHEWJ0UW9RWqYcWoNh/hRKbFlHzfcUDBDa3ZaeX32e0CCuRljwoEUnwtqsqfhXp92ObteHAVobqKj88p0SwAelxrbmnoVn9sCpsuqsaLZSQwURxWkpdeaQ4NrqekNLkq213MjKhBj0UMmFQPxY3FD9ANacbIYlyeSCjuhBh/gwXXQTRIeXYhsaCmZVmtTQ6Nqp1RTslSmyriaYWdDZP4j7Cd2Z3lS5IJCck4Gzv+ihU4HyNq3TMPT8BOGA5Z2g4GDTYajDBoCD69Wa9XBUVdb+YrPhaHe45Uke4mf8Vl2MrFVr4HyRPYUda0EOrtHPrgT/1rWrqxFk1n9qLYGTlzWNmGXyzJMW5/pOrT3FV7PpxTpz3UC5uUYw48+P/Z+xautpFs3b9Sh6yzsDPgGMiTe5h7aULSnCGQC6Rn+gBXR9gC1NiWR5KT0Dn897sfVaWqUkkYYojtSa/VwVa95dpf7drPdePUrgShOAs0f6o9Oyjut3lF7oc5jJN5fKrkEY2EBUO21Ild8uU+pIzgmGwo+grkhRy+csNyghpz/Z2B+AzrRdNqkV0mo15XtaImW/t7R9t7R6IRtS5asAqMyYg++qRsIqYkKwVRxZE34G8LCQSNTeVkUXHf2nm/t3+wvbV5uN0sce9Ceecb77AcoJA8+WGMFs+z4QvD7LzPFiYVGnQbjmbaig4gqzodTa9v6vO5vCxoU142eaoHGU/lKQmvcV+QcVY0jmrZOBi3wl5n1ONTOuyiA4FxMnOCLjiHZVA87/HctOJaGLWPO8UF2tsSSahDNnKjDMMTnyx8PNg+BOg4WThtmtccOTHebNB7Qw30zJjiU/g92k3ss3j2V9Em62gsshkCtDrA7IqR+ADD435H07wLIwBqZ5SmGMsry9kF42ThcxsITsZHNrkdXCXVIrd+hKx/ZqVF9+Uw3F/WivOoX468Dj+IyrGBBjzUE3bPWEszCeEVwPqh3dTG1lhbnVOgweAEw4B37G0449adbVbGXk/ByNCWLySfhT+Z5uyryf8v9nMlqVsvOWh3yHUKIUKPWD67pTREAUpJTHKy8Gnvb3v7f987WZjaE3q2Dmi4YxLXhYJq6dS9CdxVjCY8ozT6yMVWuk9/8ZT4PJTWYxPG8xc//R1+zBZqxWiSXtjF9zCATPeWjVXd6HHde+vTdd1lzykw9i5MQjLnIg1ohtLUmR1QjUdjJPgKRTEC++nJxPZ5orxeqT/KAsYTKMVHks+V2lZ+LaYey/io5pRJSVOCbnMFeJwYv+UEBcYT0vXavvOv54QC8f1rYQTw1mHmpI2/Q5tauL8T/U3KrPc+VOhb3V2JUAlhSeDjT0RBmTCxb/Hl8tqmyzgr9JdLRLWDcqZo5MHSUS/SbFgxZ5MSy0wXNmLFjcxv3EQGzFwaZ/3T1aSjO1WzllvJqxVteYkYn+edmp44uybls9pVQv5Ii2V8QGn8dPq9v5gtE9s7gEH0dQgPyTj62s67PH6L+QECe23asqkXeWhdS3iroidzV0J21ZQp8rC3EnVj6nN01tEZ4HqSNgNZQuSFj5uO5JLbAYQg8fhjmWKJ1SrOUFkVDjpRQ3awRBb3FfnjZJ0SuR7LgtPpPMBfzTzNvo37HILRcwXzlf28f/28f1VuHsLuoZRdRv1wgD5IdTuqssH8wL27OmUFyI/J12js8LOI+bojifXckaCOquLOsicXVSSQNwcn78fpRNfVuUNX2u/GDMemkYo280MmngXqHDaq5PuJRfc1Br3oukQyziwegmomdI+YQ6qJs6A/ymkX+iR649afA2GeuyyXRsYV2ql+DKHcmCRSkJS8SFRRr35mXyeK/uHuv7jTx5mcYRj06tT1JfrEkKWP4Ct7v1PrxcwL9SQZ7dITk9BKBbXnz6t/0dvAi+pt82Lc28CrWd82Xle16hqPpvGud1O7Dyo7PmpZ5xIgkEPFaDkORos5dQIeSjws6ldIWNAA5TzEHCl5Ims/K8x5UcmCBh8k7swE7CXCdY8drDGQjEIacEzpoIlRHjBdp/VHPBOL3MbKBJVF62N1Xjyx7GvZJBeFtTI1jsnGlaWB+NK+3bjNu3G/3NrlArjptLo4v54pN79bqZ383EwRfDAsy5Pu0GRyYqYfebGpXKISAsg+427Bt3mIoMTG4RsU4cCr80BdyM7bEtsGSFOMVqSoMgixJkdVUeu46MRKU6Ueq/xZDiYAlMga2SJ+MSeOD84XvxUd33BGTWvumHfBHKMFFJXlZaO4NIyziKKz7yX5O6QMSkSOIbM2fS+L8jlgtXXxzezfDZllOGUater8Mq/Dh04GsVbtP1AjdVxdmy/+lHGkq8B/TNzx1p8j0CmtrwZx3IOzAm6E7lPfAe+HOcXpXQM5utKEEEdPPnssvNGv9VHApt9rZeF5FEwp6KzOG+jEmDjRc7JnNcBT22bq4tfdC3sql1j4Gmiddhln0G8x/BzGPZQI+bmbnbfl7HrEnvDV406MR4niVUeV1C6V0qdlPfWwleVRn92MyO5MdXXRS84ai08ZY5qnUxvi7cU8UmjpGLyNPP0N5oc2y+u7B2F2SyebjyrxBB+PKI2zuUSSspcJUKTq6SdBPhZBkvrbemxnQfGVzrZGUyv9rTYNIi8LbZykJ2y8ibGUe1EOdGXVFcqSyiIx3MZhT8ghdPIR+d0jS1QlG3bvDTsnmfFTTFRs9tNI0iCKLgt0vYdSVflsX04VYbgrY9LIR0N97SxIQta1+UC0Iy6dP/bho/e5jxK5Cnmgb8ia1ZLIxiJHPe6woWTUVQbFMAOnefnCvZgkQwyi8RmDvVNYKZvScMAl7OkRTqD7GajNGLFFX6G3Th4k6fAyHGScOdR+ZqUMLReZNHb426OFrjmM0s9xx6+RKi/KyRb63M0WajfQHFOemvGgnggS6vzn4f6e9NnJu7EhgigFl8uusxbVafqdw1H40LtGkhNyZGI4iyrq6YYowjxFX6POiMwZznvJl0UyqpGh2Lj2ouPkY46oU4V9CNMrTIClYtEUldy8gvqZitiw+ISTJ2AiME55si72aWgMQZN0I7EFgINmHMCqNis6OV88ORk8fXqEruTQaDTI158+Fd/Qr10uo3kDNSrbLx7B2X+eoBWGTqbwbACDZ+ILgI7AIFg5ZWZHCdBokEZh55IYcfrlwsG1oMznmFViCpN1rb6eLc12cpYBPcqAK3yxjIcR/mLk9X9AeSusa6S/WIHJ9j+OWu8+ttrtl7ewsi9eLYk1eFmrK68maBvhLseGj7WXD2ka8byW6Xs+LtM3Y4bSY22gVp4EGE7rlo1kVqvfUO3x99NOZRKencokPEfwTjK4S/crsvDcYZspgYRc2hhRSPwZIE4WikgaJ9CxSqOlgmt4aqOzv1ETvpZqYYAT9JXtU80U9wsHMykK4MBvltr1o34C+6ob9fIwuDrTwzjPS+1kaiGdjUY2sx+XWkWoZdCV+ZuucjO1QQtez5ZMw0PJUYpEgLfxD+EAmtr2cd7S2sDuq49lI/cjz4HSfeR19X3k9dyYyI2ze/xmcvXVJnYOfJ+t3D0Q3zGV+xylZ0kWVcerKxBdRbvzHJGnDoNPjWTXUCQ/uSZk0GuaBxKcr87WBWxyqN126w2j8GqcanJe3O+6gPtMSBVb7Wm1QHsxUxZoYxET/6jqt7iFpMqVH49jnzhl2YspWCpHBsxiMrwws8AZW2FAV9VQ6Bu5x+6/vM9hg+dxP2oN4e0GlJA+KqcKdUlN52ZA8Zx+Wm5mU55u5fQ2rYLq53N4VoXdrkzbeAtp2RXryWptfKq6m1RtKwHWedCdFIUVa9JpQvHLuvAcSdWkt9lFSyqOzscdkEQbRXZXAne84J3tJz8ZD1DKjbi9E734yO2pHKWQn99OhhhNzW7yV/+h6Au6XKJeuyt70r/J05ovPbZ5vHGa+wfCxKQcKVH9PvLFTBwaXtQKxF6MHcF5Zf5uQc42uo2bLVWejoiH92FpbfLRBy9sNq9HqiQDSZxilCESxAPxt19EY9gLc3xVy+GXMI2aJQywRfj4HzfHaMgcbAeF5yk9bOhHB58ON99vB4fbu++armdJP+zsHwqOBktxSM+u8yhbAl57MPrK0yoF+0FNgJoph2KFDfglHpwsVEfvwdzBNK1WOgr64dc0y8Qz/PGeO1Py+JfUd2O0j75iwFWx/VXGXfWbirQnLxx5XcuQvx475nJ7pkI6jgcLZXi+DRv8LWZPml7kaymfUN/BQXzE3oCHoPeWU/AfZNwpz4I8RvtJ1+O3S+LOIO4kA3SMOlnY/xvKDzGj9+qr9gtMg32y8G5zZ7d4+rzDT/++ebCnn74M2yej86h9zmWHf9v5qMvWoq4qu+FoQizElqJW2e2LtVI+8ne0GLxMWEGAKBY79VAIX8VfNzBEc9uhbryHBJiafUPA6N/KzZ5xq9bq+U1mvhcP4tzW13qrfX7Tp148i5DITgJf31IcgTAGnvZEVIsmqclbq73TrM1prOaxAAqP7wz93zNJorfAk7f+1NmH3gOmSgsreBntxmoraMp2ogcyBieKFrgredU5uxaSfHxOImjnaYr6xogwprrfABbma8NovCSuouuNXtg/68I9a11kBt02PRqlBa094h5NBVKVNkjWtBVCN4+QMaZdTbbtuTHjGYtsfdrT2loTy0o1TuiPdyEmpr9+fEWpumdIyxjKHxUOkgGAR08Mixckb9pCq3rLdw1KjCC3OMoKRv2GSUucyUA7dTHxGQSWXLFAUDZd8dan64SV1QGZEqOX8zDu3asfZmSMnuBGNbhXT8z8NN03o7rSuS70GxhDbV3oer+V7zonCzwCd4iV+PsjmAmuVisS6gx82nMoz5BMO/9St8BMqe4PknjWpcC7B+xYy7pFpVC+lch2ImdLNaC15WXm7/33kzH5ANsFFAUC0Ak8XBB/4evFi3YbvjwVr1ab5Zofdz5u7+7sbYuP2wfv9g8+bO5tbYvDTx8+bB78bhG57trpcFoA0rx38LtHo0DmtpyAzixltvu9oyTVeukuDvFR8sNRaO3FjF9O6PZ/FPdtkxL76ZTEW5oqW5JJhFuaQZvCYmN4bUgqiqckztL32470+exdF+XzeMnIsMVRDlyTEtmYbo/0yadnCziRkNGZX7GN0iLL4KNO/11pQGLb+607LL43ChIfC7RCoY4Gtw5ZBq7byQNkHKpptUt5NeN2KRblRfhSayjTKJ+S3IL3Ik25jIJJPDGWaSmGXMq5uwmJUlz3vcrERtMbzfXhN/skMsC8mvHN/rX2FCqK6+9Hz++gzPn+QKz32+9fjaMo+toJ8uthxJ9gFfLRmS8OazTojrXvsd64+93wKyquHxuiocdaLpFdk3Ngts2EnIVaAhob4y97iNAcND7XrwDdjvEW5wljaJ5ZohDR+CrRoSWVL6pn2D+4qYLgZl18k+/5xtbAyJvOhk+f1nDG0Wf6Rr3XAM93w5j8tGYTWF2ZHyjJYIcX10oPmNgVfpD6ZcIGZsWaJK48fXr1JUwvgMMDFrBa9HKILpdSnCtlLv0oT+NOVmHDabOardEQ3RsbPFZz0rf7CTmOrM66iNHZvOW8sJUV5md3WwlhjdsLnJfV15Q6M+bBKOz1rrFv2Z1o7P9tSaDIfkmgZcKSwFOmWUEI+jBy08DaxxD9fXg74/sRxtqsEwY/icrK91JBPdf4cnIWQBNS3+G2txbRuI/Qgrfu2whGRx6WZLpfUpmTi7Xr56NBBwkn48iBLGVvKdboExrMGcTzf7xzWlJXNrGyLn4Js0g7xltycWJ/09FAiolXGhiZcEkkwzyrCM0UYjd/RrLi06dUVc0NPd+7emnhCH5hAKIOUrXsbVl8iMJsBHu68E0gzlkVk8Fz5rG6WRZb4TCXLaVJYIYe9AgJFskv61gCmbAPR/awlyuhfAjmjyJjgcAr0Wto4G+xDiP3KFQWgddWOHnVXck3/3m1b/7zavR4OetOQNZebumfoRJH7CqTu4f+UEXdLbuPv5gIQIAB99KshUiSUTOHyAli4Er6FLnCghd1iXx8QU5RW19rx7nRFpewykujQ7K2qJTu0niAS4M+NiNy7P1KdtXWdRLfTuk9lOsbs2RJbLnKE7EJELd8oewzHLZdgg0OW25r51TkWhg+qJNPb/ygmXfY1ZTVkvRgAou3cA4g5ScEzBwEND2Tly0WKZLQIhoASHtzf1XrNU4eUp7XQsrzcSHl+csZS5NTMPrBMI3wt0o4DiBe9Y+uh9aVx3w2uUCY48jI69MrVSzCiff3/CHV/u1afUt7TkMJVW8f4wa5BwReYaGmiiYmQ5qLvTQhRfU87iVPFmh/6eTg6fsyv03jdrqfKniOt1Or3o7WU2v6Iq7ffaNp0bdrQYuNy2ocqhX/GVl2+jKYbEWe2pJlORulEseHhuPaOJ2elGOWcfUoA64dtnsXePYsd6Ke+arAZaXcV/gZGFoUYMJQvo5K5d5eOrC3Uf5HGU8CmP9FfmmtxKpwW3vPNMoVvPO4THIgvZxvMdYEZInvbaLb4Nk1qavJtv9KjfwZHYTE+dSGml9ZnReu2kIVWVCJOkb5dMRom8rTbBKx2l7O1466LWqbv+K05Di9/0lm2eCWrGrpkDEtV52LyF0Tcj42CM5WRs67bVhZ5db9atSr2a6rrfbDJRyok2R+x96V1aX1QSiVm4HctBirfIk0jBSKfENbHpTZ1BLnVnyX79HHwalY3TLYOEvaWr7I5pto8mPzFu5s9yg4OPU4GlBk8EBVccSeakGFbYXYVmrUd/Cc1MmdyzAeiHIP7vKeiEJDPIp7XWudzHQ6JhRnWI1n3bAXYbzsivjuPNbqutiiHAzn1yRcFshdlcbpyCokhiYGLGs43T5CTNxX1RYcr2pEmrbB+8s5OymNLXD7aelUnhqn7e85M00auAP4lGCGSc45UzMvrriES11zRoGNYhw+sNl8Vz6iaCiW8sR2JoyXiM5RmRANRn1SYTiE3SylL/81HHQxR2iSX9LVlyLeJWd/RJ28FPfkMszCPE8b2NWSWMTdsuhTbtAtMu7CcvBTC9OLnuuPtAj6Ynvt6Mbs2FNTA/cEJ5AxZ4NPF+HvpwHlW1j0aICApI12E07GuVrrKbk6p56SdwUcz1lwO/BUNJqOsHTfgz6+k9Hl3hkuyscskTz5FSMBuKCChQoMCv6/RVZS5UR9T8S7OM1yVLQSdS2fhVnUFXJ6kg0swQGRKBEjDHKwv7sdHO0HRzsf4O/vH7crcKGllwqkWGp0rPs8HSv0XKlHpaRrbe1/+PjpaBvX9pZTVTkSIecF7H+O0jSGF8ZLTwYMREP0l08HDudGzg4YaCY1kapFT1ydujvQ1mXUucLfZ2rzAMw5BClxKckXx0Cfcv3ZBx57TRWYsy0rCaw0SbhBEqORFfVQxqUgQbuUrnPg94FyY7iKEqlt7R8eBR8+7R7tfNzd2T44PLbp/7Se8t7hbQq2/CiXF6IlcU5sJc66oAU/zhkgU0YZDzJZ88YwWCvMnbWKgWqBguqaL0p/9tSzNQBmZfHUmMnUIs7KynwzPWGvM0Lvv0DpJ8bgebxt5oDlKa2riuNRFYWsKOgXnSzb86vsekNcxheXGOn7HNgdcTJqt7uv+FkFySkdFE9K3XQUaQDZeQhzaunv+VyT33k8gPdvqhZvJz9/m9knv/K6tJ+0EvihYPUIc74e65zjSxxBoxzM7l2M8fExkJ3sEhnmS9HoJYMLjAB5dk3006yIJ1WINohujQctEntmVQnFl+xQHsWnM4yQSXOw887Qc3k4VjQthK0oQKmfCD1U/WGEKI+5qYaf40HcPXXP6HIDwi6UlQy4+xYtw2toKqsVQ9i1miUWRs13ejmA1/8iHEAXaCqNz0jGfyc2oNRwnngBa3GFLQ7DEOosl0Tx72kNr0DiEbM3jm4LK+VUHmT94QTTlJYhXGtDZbYmfRTBXrNcV0ob6qqScUpFXSC7ZhUEjc++WBPnqxB9PBV/2fCxH/7WOD3nHsUDjteNtczqflbc5f68izw0EslvgVHDxJuK4olpdX6oXtnQKZsLbNxboWyCxhaljY8jVKwq716RJ2pAU/Eqdch+X19SDnkXJ+I+Jv3wLcEHG9oTxnTnNQP1IoeFCJRH0Jmd11tlAZACEfkt6trxMHEC0IPvldrtHZUxR+rE6sp+tNFslt9osfAN4TsHlUxV8n9D1yKiUdJaP3ikjPtpd1bWZkqdHDOSbMNucL1hzGdT5A0Tl4Fhbe2n68sDbYwtWAxA58AyXbIeTo9vy6PvjH9NRxYDMly4+Lkf/nX3w/s0HFpiN/2gdke8fKxr7I8/N+4XI2SGdwMlIu34TpCK4imMtXXbtjHzk+q1SImr/r4u9JFZMtvWlbJj/bEVd9Fa23o303mVnq3wV6XNGTmHWLlkxrckLkPJ/+HjusBjurQH6TKo8tril+bUZlOa5R2XJ8EfGf/O9oYzCiYm890ZnKehTjBkbjlPidx1R7DYDO/mUfpdO0+upxDzwmhl45OvJAG5wDeAwpX/PNzfw4oUPM3VJrG0BDt1pCvdMA/Jig1NablWmKHEwG/V/mvUG0YpDnfJZrHbg1EfiCCN4Tf/07GC4+BOJNQNVJUobSRnfzTLKQON0CBQYYk6blbnUoU6LSOimRszO+dhPOmM8B20uqP+MGvwQvktL6mZbpRn3JwVUexskXP5RZcp21/n0RQ7H3RgpHvR8nQQwdS6rDnBP2dj79JZHyB2BupFBvwMZebmDr695hSqEm7b1rid6xfWsJ+tCzKSILUknWX0Fdmo0yrNAZxBaDHx33ZH/21HmXobIbeF4eI3WaZPpxL2K3YOLK3C0WWcYWR37DO8gB17EXLe4QwuFsffThawP04CHMLiOTFwnvCTM/1E+9Kvwe5otVqn5dkr64uCHHE+bvB2ymu+ER2rgU8dV/w8TC+inCrgLNxifBmkPNxQEubWzoeP+wdHTr0vUXxxCd1QJmM9fXTldyrCBokukvR640RDA9RzlZiD8xjfdrSBCFsUGqqMCbuLtGsVCu2xFQovZ0qhkEVwb8njDlyG0zz6KoXIAwwAu/0VBnIjAvjKau9czx/O9bVWflRemI0yLx5XtHi/kJAzFhFynM3UivgT1KGCrG53eSub2+3wt61H226HUfo57kTfv9sUm+YuTl78pUrcOcZuSWJrOETz8cRmK/hiMzyo0MxQdJN+PIB5CjWi4VENuN0Si5+AZdzsEHbDb5HD0ntRuojjUxG688nixeoZAO30VUBL9BEoh7b0G9jwwsuOPcqYFw8W9nGEabjuhE+E3DVkbBQP4MOXJO06hnj0SKWICfLkKhoAe9zATp3+KHA41MaJUSsPW4zPtdcRfvE7HElmG2PiYKWm+KtYFeHgod0d16qveHWJUV7MIeboX7oWbKxa02HMdy9cKfY1AwoyUjnGPUg5VL7mitGSuBxZC8AvF1vwknpbGNgerfSyQXgVBR342vJEOaAGZ9dApIPlsDe8DMnXOe6IRtFuSVyFZ8nZMn+OcjOA9jBMcyTKNGpl2FcjXTz+f+Hyn5vL/9VefnO6aK7AyiwNq8wcs2IkW+wPyZb6Xfd4D+VU5CFowEWADvd+q5ZYvJMGoaUBlvhK8SugMz9olv050doRBXYxh9anWwWDB+DzCC/+DuM+Ogv0GuHdIISHvR6+HXgzp//7GF7R6V/+h778pfG/N+jD9IqOZsuHcTxYuRjBSwwKPXc1tLg1J5e+8Lv17vfDGHNBEmfyZKh5Gcm/sL0wsS2wE09PK6XLhzHuGnEVXdOh2w/zziWm7ADSoJEEj1SCH9mAYCA/bp+qE5iAgFDAnNVpuWGA6XCQIcgb6pGXUaG9hsOUogi+Q56qEz2Dv0dR55Lz1C/0k0GkbvJhdsmfzmBP8qewoy/IcO1GWAjJbJEfDMPrfqRKgTx6/CkefE6AA5WNwq/8AaNKyIFGaYoSCv72BcAikn100CxPfu5GZ+pjDy/3qZpbj8wZF25Kofq2l1G/FaWdSC5umCbdUUf1DVjKn+Dlqd46l1HnEbBopRqLamy7Vt/MFBap6OfBZRT28ssgjVBvQpCki/iZiUGeIjPa/sGnw6NWu71SLwKcULj9umAxlauzUWj1lSMVdNanjfHt2PRPxG4SdllZRSdulndjU2cUUv5G0tL0oGYju8YM8lCnIs6SumXIpHEGQMBGRnzAHvmqQk+Ae/l2Y/R1NYztWvjArUTYYFfjR6XegJlxusMnbjXYyMMki6yK8lkAXFWv6zYo/MDMJrahstsmSZH1s2PmUDNZAPWPTyve6tsIL43xIMI4VlZyMR0Q53Oc9EJmnRrwMkrgkkxQv7BaLa2pE/21X8/W3akbwymT4e+pAotErHT4RQ7u2hi7z6fIzrhiLQ6IrPy0PH60TYSUXLJStx7+3D4Pvn1ezeru0VFZP16GmbWFyiU/99FPGKrcSG9VwZZ+bu6miuLaLfXq0RI2TMF2KjFHL6qZoxf/ktvJG9/6tnpTEt767hvs1ujWT8h6GoP4ptFF9FVHbGPZrM9xkrQxpP4IqAnJWY5TDs0EHTWG6AfZ2nm/t3+wvbV5uM3inaH2yt7ZDz5uHh1tH+wdHi9SR4unp07/MlvXBAbgnsojEFVVDeD2eHi0ebStO3W76qRRTV+3THZ359321u9bu9vGnLnD8py7UZanyfVYI02rA87LmQpFfidk0fEo9Xu/BWK8DSYnbJ6c4df9gae0RENvvu7oyUnebN5aaxTnRUTPy0jsPNsXqn+O7pmci5D10GOGIef5YNhhjuNL2aYXcTUB22ShGjuLLwYh2nUvklasVRWB7oBMvdwhzJVRiGHhmGe6a8TRLXW6M53FppAK+aK4eL5oKP31xK3uzOV4GgEBn8WDCAMRn58sfNO1b05OBt9wrBtzssUnYPQDgnVyqb9+8EjB9xQrP58p06/7ARG/4XFRSNeuNdpZ+TFGOxOAIFrfbfijZR7jgM+XywjwJ5VYI/DymWO8K5IvTxZ7ruJB916woxf0yJiDE7Z6kitYVEE/TKOgsSyHLK5VuqWEKVojwW8A5Na7FoqhsWKljQlAY/JB/5pqrfvhT8+8zoyFQVaLOWWF9BpvwyJbeDYuN6S7F0NsNileSFLk3QHIXsVYKHR3OKCw4Hxv8kQdxysX32/Vtcu+s5XtjqiglUVh2rlki8NqTxt7ga2tg224LXrnOaWs0Nq/ACsU9npjg5CsWws/z2cWftAs7RbgKR55rQ49wAOdijWhZ8fyoxrY8UPFW5P94Z1E9y4kCvygN92idGZlIKnJ6+TPJlr0vi7hoHRNxZk32YHOMbGR03FbMndZ06yYvNu0OBD8zW8ewTjnfgbIjo/pzEKHSRxBsYtNxKipMoWuenfHCRcjjDU2XC+HAi4YL2A/+vz1bHDox/ANSLYEEuhsh1wKh+vkth+SLs45EzKR02B52AudiIAO62JMUvVG/Evm4k8Ze/ZG/TO4xqk56NQtUbe8quJ9AofiOUaUQwGbGm+ItjnlOg8KeC8o0u34DySGBj/3s9ntou3lwEr/gN+OC6DDmCc4gvnIrczAhjUfwS34fmY7a+2ZAhwURiKTiSF1r9kuORwkA4z17RpblAqmJ9iXuwrH5PjNz7hfD79vcFccyAfmtnGf12Z7fv1YqvAfuWPKJhU1zsErq/8ie8ar966sMDGO5vsU3nfYRl5N9xKnVKWUBkWa2OOP8BVPOTcZJdz7i/oYFQAruGHDiwobAjtqBAFOKQiarWGIYkj5Rzwj3wApiligrx2F8ZytrkUxd7xKFLoEJcNo0CgGxDSNKIEZdIA5GlxsLI7y8+XXi00RAiflTJN9JksG0+d+dwl2sMSBzOugdSJxhmu3DezeMAv64XDduTNSbeRNqAbyiHrtIu6WcunKMOxmL9rpzT8y1Q84jgHPerJi3kmZGa/OlL77NgzhhK/pLeeQr97U5Lu9D6bYyylCbzn4YCaz7SXJ1WgodCgw6UNIvg1kpO9KKmiBhbuzNuQ/4aVn6KpjmfDb4k2mB/w1luRnIn64Z3DzVpxH/XIWBJv+joteTh1fzXKONXLawpeJr0iNY86b01kvkCeBR3pKbSnPrerl+AT248nCabkuoQhZvOTopNZQLeRIsliO5fHo9niP4t3MQjhPFho6FLobPNMHViPdLyT66mxlfrkFX+DXDFSQq0pwcStNzDjvByCLuZZGp5cRqiyay10s4cv7KEddq1R2oMYHxSq9KE8w9xL31fKkjILuW3qwCu7GroPCCCvZvJSmWrUmzr8/SFa2NzPOvQ/QDrPnBEWorjExmpicRPIe1KGXZDDzdDgVoRF87smGXE91IEK2CyPFYp6IOM8MhhSNXL1aiu2vIe4tV01xsrD9mTx+cQYnC28JJeQjt+Zh5zLqh7rq0b6nCpu9qDrGu9Ul1UuUdxZ6LVq7KXl5b+Q/Xfu2Pgre3h9B0K50rHs4LeFF0TlcCFj6CneWZYy8di5GnHH+ASSOL+pFRy/GjoawNuMyRwsn4iwAIIi7lUBiVnjUs/U3HDWUccomgR9qJdXwcZYkvXI+NDImiM8t0GigqgI3exOPTgxVgHkbNYRkUd6q0D1WkadQ/HMF2U1tdJDV2YorOwbPmTuy+MoKtTL5h9P0/d9RNFmeE5tVU4UWlNkSIC8napMB0QsMgjI46IIyYiW9z6j2k3e0EpXoQ76r7r7Fsa/nVuZBDUKiS2DRTXPCVjZrtTe1tbE1V3PFj+Im4s1cRza6xuScPn8w4dA8xqAcr92MoheZUZOp5SzCdL8Y969EGp1ckYSm2RqK6OScwJLuermIellEV7ypjewypxQhhdK3E4ZRcb7oQy5MkomU7CsSoUyvlaSBvx+eFtyDMhDBHqrYK486gA4EerKEbOqkD4SV2u2/MrbZ5Vxtf7QYotO4ct9bNabRtPseW16vqdAJHEZ5NfqjJZTDLe28zaq3NtOQ4nOuouus0WxOb6iuebons94V3lI9m1OuNidb216YH8urA5Oqza62ON5vQ5ENo058HnfGQXSlkzLB/Ph0JrD85exDOSsNa7G8qDIf0uZiTQWY377BmeWm0N1V+5kSXzib+sGgfEL2cnO1oZExTYdnvVqWXFWYG1YcF1R9Uy0MbTDWq3d7H3z8ZVeFUmVGHPv5/lsqTsy8pH67eQQyuB+uz/wVlTaCx1zHfT7Tu17veGWgQzvcpHDLO0HdNYk3UW0KJXrLk7Wn0gCh8QAQ/rx27z7/l7lfapFuST5fLplCF5w7bmB7TY1aXTfv0ErttqvZLu9nm1q8EvfJ7+sJJW2addZEaSVLu7pU8Kg2kxPTvpqa18q9bChe/UrXcZSs/s2stb4zt5dfzyZ/4RX9lQpmWXWqGIxC3OcT9d1JzOffu8YAM7JnZ5QnLgn1xldXzsheZbHdmDrKu+sn/fvXM/DPjTyhjXwZwTwyyv1iO6/TbwBbqPqi5xZOzLV0Uvu7Ym1OrtmVihTKpTU2mutqgz6MBnzlTb2Y7c39/FJndw/+qgr8gZsriicXuHmCyUjvvhdnI4zzqznaW15v1tvqTU4x931erfcDu9owzhweOIZf53OURt1A+Z2uO3Jef4ZPai3tsOnMVrE+pCfnsRuI2AJbqOAB4IeniYlIdOeKJvSVw/ETGavy4ya5q5c2fAeFmMuS2g8cs95jZHuQYXBcrIiCB92Hz42qTAA1/hFWPeKOdd8NLCvrR+gFTauBx/P5PVCKCGDXCj1vI6GKJlMoir4/PXnWqILHWZdKI3ckGfjVBY1T+cNoRmGvd61HgTunig77rB/ll0mXZdpn1yqoY6sUQk7QVXMJ08GeY+rZTtRs1cSDg7fFdbWntWeJgaK4hl+JKbX5FtYQOXPXj2GhdT934ZczJTu/4+lX8zvefhre0ng6Mkx/z7lYt8vvR9FqqjpkGYOS6CUXccd3dGIyZxrEe2A2Fj8xC7q4BHuzXRHrTBsKXyZpLl2zYHjOEi3Cc0xj303MlM5cc4PqypzVi63F5vHyyilOCj5TNDbsicwRbN9Iaq3zxtO3cuJ4YGF7xDjrijRYqZ65kHZLHG0fHomt/b2j7X8cibfbR9tbRzv7e6JxGV9cRrikNE6QENWygOKi1Mx4qwLfogPnJWpMpJ1djq0xP3b0NRdn4dR6kq2tvZlfjgK5PUVp5Yyv47eYmvgG90ef8sIKEzu8oHrMjzhfrODaGJmxuN3qAM+e/PabsK2v/8R2uDL0JJD3WjbR4wCM0RdPjGjK3h6cp9E//Zdkaml6atoXZidKlD8VPCWBX2SkbXqiqWArToONzT0xU4DQexgTCsub4q9idd0ftKRYzDF9PBV/2RArPiCqCJCbJ3nYK37nLsasHfUbVXIGDlmLFo1L5Y6mN8396zmRvoZwJbgOdLGliPWV1cpd38yE/J8sdp2lNZAHiDs9K1btaWHIS189gWpxutdC9+PyM3kidMdwCJN/0jAeRr14ELnhaouKQMYUshabj4ZdBDPJ37Bpfas8D0VYKFLznA8KjeoFb1yHR+xy/Nki9qyaHs1OvyyLSVOPOfA+TnWxKTY2hObO3GwBHKvfbuaL10+Voy+Be12jwLRy4b47tbqDlWL0U2cP7Q/wslrK+LJGtfhqpvgaPmUDmaU9YVAJhkkWfzWhpHgyHdchz7QdxbiLGLyCBseDxOiNjkhQnoZY3gozWXt6rfRX5mCXZeE5wpd1RbcePlos0knvNbWIBrYFmE5y3nNwocaAobwJy2JpW6I8VGFGdZtmi4MqRArro68d+DHENv2BA2u9xN3pttCUDqUGHDn4HyzhZOHZyYLsCeEf7efCMxhglEdWuMBKSbciKui8Byfm5yjIk2LNZjg+OdPfkFncTtMkre+waRHl7YuY2qjlK+15INQ8POthxEabUs2nM3ss6FU0niIjk/noEgP+XobZZS8+a2WX4YoiP8VXKZ7K5KcuW8yIEWfaosi9uG0pcC/u2wiJINs4WYgvBjB12MNNT+Mz3OhtTaWSHi5bl9HXbnwRZXmjeby+snrq7n/OffvDT6kXc7D5L9JkNAyuIsu2yn46s5tfrwJAu0fBrH3bf0jSDC6vRGBb5AnHCTxmIROUIoGcw4Nvwxv8hmSDaZiBYjDaNfSlazbLR5gqVXcl7hs2bSfMIm/nXBzUlYfFPbVUxTcFOZw9h3hwnoY6zu9Y/dhN7O6GQBywo/2TkvNG0S7shl6UZtVLi8eaijmcmsh5nGYoMR9KcTn9trBRm8fTywnPAyvcj1LY4l33iLUfzyzMFMtoEOL4QAZZZth4KBJp/ZHEg0bnkjxFL4ErDXuDUb/RZCXNyUIAuxuPXqwxENRjATuoaaK+oAL+PW6fQg9wWMJutuymeDwgkYvgG365ceyb8dnUbvrns7/nt2BlyQAGOki+WNlwnOfTkwznbjv/Zz6ch9s7B/TwvXpmbh9PUe0OevljTI2nbS89r95Lz8c2M56HvdSSpVHNprLq1JzKq63VB9tdderau22uQlXLi2rYJr+GWu/pkslGaskWWooUBSHqYbM4C2AnjHp4ocYoKMddO3mg0QD3VhpdYja9z1HRym5g1Oe7bdCNUylU4yLiJ7pV6UtxpkqeVgioXHma3X2rfwX/NjipT7ZxlI4iuLd/hdUEyRV9tXQTsCEzVF7wNaqYibNyJ6cNJSgm2w33vTlaYrqFyawXWiCmJQOOrc350KMexrtDPDCzL/MP2YOeg4cOnfq6OnTq6xqrtbU5RJjgC8wVrqeK0cmCTva5Dm4qGzyeX8MEDzNtmOZblTRIK9Q0aMT9RYGIyRue+vLwUPIskhRTBq2ThS94fR1EX1Bju4GXCyOLlpbGefNo0ezQoAtm1UL98d/pgSdXzPmS51kc9bpkH7Jx7DfUOFnQKw8w981SVTXUmtYUZ9f9s6QXXMWDuk7ItK26WIl3aqrgG6wpLrS6NZWiz9VVpjRD+hxIF0pwwkmt5K28FnhKNSeXGf1HII61HOUjgtyANoBdEgUe+UBnCY/5IBv1+/BLukyKx8uEcgETWyAlH13XK8tlBjrIDBiTsAnlAs/qQmzbaSnKdfgAZ9zjCxzKeUjMxMWSaDfFX9BEzNDWdS+i0qTzwiwYmavKBWBjXIPxoiTboq4tAfWPuAvVj0/dxGRpB+1t87SB1RTHkyZ92QBR3Fltl4SWTpM8cRs8NMTcL5P62hxDTJhedWWKl9swxqg622yNvZ7q25RrG2DfiGog6P5XJ5vXMlCvqCLB0XzsgTVJ14QpnilICpS1JBmaOIF3pVsaQ5VogNxCrKECezCsEoAvQjO3444PN0l4TDF6xb+hWFnasFk5BpWB8Bh9bLh9mKYN0hlig5bVuphOTubFbCljybFC3YlZSSIv60FxQ7eUJf7i6VCauKuxcWT1pasxKa+lkYcpEIa6FJlCECusCxEr1rGsXQ+4PyeqFncCcJFGJEyyrOph7xuDlPSHJEkpKhQKGJ4n2hLhrD36XK5AWZFb8PJ7cCVIHd2L7MNIp2zUnFqlzMtZJzD0Vwh6IfoQBZd53zbM8xVOjLiOoFeTuPT3hyAudyUNV6JoB0uinOEONdEuHURf0NtKtr4c9cPBchqFXTIoetrCrvE8KXpfoih3A5vObOM6IM4uusdTxtsM2I+o60gcDPnkRS85g5OybgJwcjpXbbg2bPTC/lk3FMDZkx1G3mjCn6Cfx/1oyZUOfo7SLGLhZ1Fk2x++g5e9l+TvcNe6xn1GMB6LxIuFHrfJG89Y+QMmsJmU0UF71mkd5WN0cbSI3Ho6RSkA70rieh2uwXcp+uQ+1ETnc6hLgkMWIeI5uX+I/HwILKm4hL3Zc9IW2HSL4SGuYWYAKxh5lflF+Fm/oN2Se8EdnQ3TpAM7tpWOBo1joGCYBIom8QZLhr5wu+6gf+fGuxBowbSj7eG5nLXY9wIHwdSjzgBQTtZV9AJ0n030kkNmdl2wzeFxmOfpMuVsi7qn5hhZdOuUv3Yvlseb9u1GylTbjroMcPPT4ujBiB8OilHYYyqBRcJXx+7IX/6DgsdtFTP4bmDwrKzaJ8Q67UPBbQW2FbItO28iUz1KiVfdP3SZ6LFgQRm6L1LnJwvfcE43JwuLBS9eQ/O6NVG9QLNM/J8+yJ5OdF+6sqJgc7gZ4a2nPlxumeZYKkSKW2A/I8u7ylemaG37H0etg0+HR632SvsWMdgLQKK110tideXVZN2/70hk7nIag6RrO2YusYTZfsSXvsI5RloDOjkrUKLlceT8BceU5/gy/ZgxCnNgdPQgx5fJHuCX12dpjLFlPscXBDQtJco5wjAKWAgTI5LGRroruIqG3fiiLxpb8iK6mAl8OTBIhqnnmsQ4KNYA6vLtgSd0FmaROSj0H8K9G3jrHlBgChzv1yFcwfVcZIAbg8S/uanDDROAdbeUa9CisfQYP+FPEcMB3mq1TpeqqrNHO7VhleEKG3jjx1W4hFe1Rd1gABRzEVFbgiFUtHZPl75HGNaBy0z+UOHgVpzk3rONKXICsR2Ku7LC1ESWuD+0FAsiB7mMsWbdgQrbBdwww6nEELoJqN9TwJUkJOD4HGcjDPdkg4aKRBWSnB6hRrdMzv4Aks6Y1OFyK84iMUIYyBPRTcMv3AF3K7IIAQbeEkBQlH+JInZ605Hw8fcSF2k4vPQ4jxdvQkZsLLyTNEos8Upi2S+/rFacR/3MktEBp4EVjyUekMbwZOEU2Y72uqtiVOZExfNiKq1wiPL7hhe4ECWKqXmhjQ0W1ksekPicW3wnrzImuNwzidbrWceWoBP2OiOUkgWwAYF8A15qHg3k29S3hVtrTok+7653hdp1lZma8RiVLdWp4E6F2anoR8htZPpaoWYrpX6K+DnyRBRi7MpMfEGEATYC9wT8xsTw8E3qDKDsMA9x+3QxUkXUg8t91EfdFvcRpqgPGKIvUldjjXpD5cmrSF609HIkmUWM5ICJDGinLtKuWyRHR/i8uJdww8UbcxUUbgZwC4PbUHHTLH0i3q4Ef/9180g0CAIxRMTFABcgq3VXAlx+wAWcSX7UN0SmKxy+hwJ9Yfd2WDKOWdGN+6iCBOJcBNq4afJTGnk6k06+nHXxI65rBISFWvLkM/yBbW9diSorTGOO1TsCi3dtY12S3LBZFrBwr+ID9Yp3ENgNdNngAQSa0AiMumkxEh8bm+JktLryZlX80kSVPFTIuO4msiq/iGeSRs0SdeZv9rIE+HzArEuU29PdiQSocm1GMm+XgXLn/0Td4bp/hLD/OtfSXIlLkWj4O6nZSSyLZg4NVmWsW8+AE1De1NiOpu+2iwlCCk5JWS3xOzcsHZJRSpFqtGXRIj9yg9xItaZZkR+5FVEmxJ1OJ7i8eD5ToULL4NKF07STB1dwVFmMivu8LGJpr92ShqBSxPLDwMRc1HdjyFvqTGjTm2tB/YoG/bRZU6DIE/iJC+NqYoLJsti65iBcBaioD1vqw6aqe8QdrYtfASTEWcx2CCw2AVqHNze40NehftId9dTxXYsb/Jim5dB8FuU6kAKpNSvLfywu8Fsmcw/H+hMXdcy1TlthtyutQhxzyIfGlfvlpHj5Zo5whWI7BjrTgw9inCq1jMurF9OqTlVmjcViCGWksTQLa3XGCFfFqu8MXaKhZIDhVjpXriCBf1/SXWyw90YhN2566spax0bD9dOSHxTeKKgGhstc8flDEVYpQQVX9UYlQm2kd0HA08R51PXHMjK0mnbgTdmK6NdZonpDvjIOTcaTdYqcWKXIdJ0l5FVGGcgZohF6sN0SZlNsNJsYOaZ9uo4Iuhv3Y+bS4Bp57jiexQ9tz/ii2p6xBk5W3sy6iEXdA1DgFpz3bDd4b+EcXX70ur6baVGBf1lUCz3qEL8i7KRJxtocjL+EahjvzeMoBZrjtmfXZCMhGQB4gm4QbALsvXd8W4wHUtIBWxY/3fxAHsIMiPwOQFQO8Ux2QOFH3fHV6goTrWJIf5ktUVkve6DyFOMuxw/lYaxq03nzeb4y4xyK8lWIgjAOpGLSltVWVfDchVbqoy1Oi7bZu6QGdcJCU1YJLZX9xkVC9kgyVZZt9FkOGKwDk2/uKJ1vJkaYO178FqV59BUL3keY3cTWKbPchDGI4vIv92F1FySGZWHrnxEsU+TAN7HwZHm5zwwGj9KydU3Y0zBMUZX0n4f7e8VkgCqRToGJEOdh3BulPrCL+xRWvTDosh7nUX9ICpqBgkZCES0W5plmnTQe5qKhoj5SnOQ0QX2X0LGtJCrJ54HpgB+wBi9oSgtv7x8cPJOya3ofveXkfBlhnCzcD/b/c3vrKOBAoRaUJD886OOrWbcET0eDwHpqYoi3sB4/Xnt0ypX4QTqcc7jLmxBiP9SGYSoY2iSApLSuhmuRYmMIm6ggxTlIUuh/ZLmfezkYDbTyp1D0EACgkJbUQxHlSRLnKbz7L0l6VSQ+KAzDeGjMAOI4w6uSwkWTzN7Y8h2eynLpb2WUmVFhzSa+IcwOjRtPMTHZ/SAJlLkoG4fe1osMC4aXuwAN06EE/7TwHxWvQ/NFBCvGz1WK7CG/dg2PGvSk9fjZPCiePH9VE2fnVY1M9vWrmcpeSDdOYh5hpedRik7/85KxuGJtTsaC9vRkLH6IuGFTnzGjcgfuqG8HI1t2Vyqo3XmPZ7Zw9/028XBh7dr7VXvc+9WMhZ4bbwu1AgxannuyEt9SbUqsYu4HZ5yT2FiRPzEx3n2ilHrPVNpF6xlG6URppK9d5GkXOe2mNdnw6kzdACp3On0LUOcf6IuducWryqdRUHn3jY6b3LdCqQHRUgM3YaIVfc68fBMikBSO7Siwn0XYzF8G+t4M3D5cmYdRmsc6U9DfkfMX0edoIL5cRih20zL+TFyGcAEvZxeqzJG6BBcdaV/ZVCIDj5xAJvfBGbqJfZxUinbkb2ZllNywaG48l71YzdD8tZ9ZLfgRVD4+VcZeSQdeE0pczHr6qa9fDItl1cYHmIdNPzDiZ3EHarAIdg3s4+kUVb5uz5SoshJg3mPBETzXh6UJL/7SWr7s1b8SXzYhzfy88GXl7QJcV5kvu6Xa4/Flu/rnnTRjVseTIfwj0u7svds+2N7b2g4OPu1uHzq19JBBL7kwVXHSx8Du0rzQ+pPTTSujtjYfchXPnmZfGW5Rcjkct/7EUnB9r1bo/tRQWpdKen0PvXPBJbHRGXsYasaQDfej8/O4E6MKg43QYAOgtVnYK2WtNdW1e6jZ6CXJ1WiISuidt0UhzhTV0DGyMt8K7eqS0rQWvFlzXQwc/eyNf7wtuoY941uVYFUObPvLeJiZ4Ugo1YjHTg67oHnBpNBpOiLvJ66vCtyOojt2FHk68scadDXrWrv90LYrq9W2KzUKotUZs125C+wg9qvbCV/Wb8Edf4MfFLR/0mJfJfK1F2ggUKBi7RVXunVxGLE9XUUg3RIsGHdR1dSTWDsnPS5N4BmuN0NCU6PirYrgQsDtNu2jpT77KupwYc0SfBXimbyUL1utNya/omJtblZYaaq2YayGLdWKDjwhzmWhx6gPF4a9yRry8gkPF5ech+oqqrLbNpverNvUIVrk0od/q06Ha0K5fIEPHnH0eTX81KRtcDyf38wT/LC8BuveAjt2xcnFNf6RAiuFOMXaDKRRdjAGJzSuDMsVDrmyLCDgUKApTI+PbMEBD5KB5ICk4UuraK3FUzRVTChfJ6dqVU9DsQ6mjCe2JTwGd+RnhRAarYn6GCDjtR0vyseLp9qqFuagDGt9XE+5dXRra6Z8t7HGA7d5WzadzijHz1/Pq8BKIgn8pmMhjqxXCzgvZxJvYGV3vVox6pj1TMO7etjhyxaayqg4vjSsB2Q4mWpX8jd4luv1CQ7yXAMwyr+IAYKIsCg0KFOpqcrXTRpWvgEvAmkMJA9H6KjtlJEcphvlYdzLHPmLw3ZJxwSfYa4MURUoDqkQzUvuSD+4jTOyvz0R+9PJ5qzNCeSgM/+13lEeMXllhbkAGQQY7wobE4IZy5kAB2KyllGbiMMp8AJuRECpI/gkUUcBzs6g0xshvrD56jKRWTy4jGBzhdiSr0UZAtH5aNBh47jC7zJFy+EsjztiGRV8u7sfYKB/jmIYzaOeiwYX8QDJuHzOqKuYhB0GOPQdoCbFKeTDJWX1uzGp/1SHh0cHn7aOPh1s7hZyZ1hoOgJ4BjZxc3dXzZdC5SRJlote8mVZ8oMPrYS7X/q7l7OlhKOIPsDbdyNO2oAfg+uw3wsoVJiJKJ6iWoHM2g8QyNjLsQFk5bkDIM6CGvTRCfxY4IMFDLvQVEWQQ6V9KH7f/LBL8YtanuAouucWpYrLfCHQiyBNZO5Luap0Ozh400UjTdUiZalaLCWpIn+nDRqvhclq6V00znVUAzkWVuNjndbA+vSHpqf72c3PWNAkLz39kSWDCnqyiyZnXfjjCKpYUYM+OgRVMnkvkRJ+bGFTHyXpLmsoqUgJUlCSbndHSqJ5VBPRlBqCzDbNMDcyvARWKzgP+3Hvumxe5pZOLHjh5LjaO5FOeVUNjtDZLRKjU7Iti3b44kut6ArLLQs6EjtvleNry/ZufQeMJx1ZTHm9+CoSWyvBziDfxYyGYU9TnZwGRw/PkKIai1Bz0UN4jcW3m0ebeEuUnWRAV9CF+rpIOU25Pw7o31iEH2xnC5tsfx3CJuWIW8360VcrRtd9HSLRUUiz27paq+gKEHhzb+e/No929ve4R6XOXWwajnDwFsnfzniL8Apav/x+1NqsHRhqOQNPrZH/6upMc7QsexkN4vMYJcrh12SQ9K/LEVF9NR43PkedqcOdwMS/oIZygS/cXWt90cwAqLIvofqSENPrMcywN3dWCoGqjSDIqQ3QE4MPsjcbRRLtYYg+6Jh+KW76zZS6EbJlnmjGJwuINJVhjgkHY2/LopLCqJpKbtDkbycLmJZ1XVDc4yIOsvHo5tTf1U35sfPI+HqzZL4FPf43GAG2PADPeS/MpWGIWbMfDoewvZzKm4dHgksmH3h5QoE73sw4yxKE3S4xvZZjvflwOnKO3QlG9PwbiuyVupDoUpooMM8hv2BtqUC0sGSzyzw+iso0hmh0cBl9ZmiQ3cd4YrL6cQEHpi7AV3xMnygPqYMFNzeGl6zklmrGkR0dm72MObjd5pjHklMqAOVUz+fOXR3rfk5VBCD83pxaPuL1TLm/uBSOBjt1TERV+eQshx+VhfAtp+HnE1BTDnzwmZ9RaHTCzmXUbfou87C7Md1QwzcY8NwBNbXYZF/NFtcD0qrgeywvlLouJk86E3KSfD5btjku7Qxhw+Yq77NJNKWCafQRuxPdWCtq2IfgRyzTaXITlpdFUvhl5xFT1FO3p1UsFei0cbKwcbIgnoqX7ab9+NPezrud7bdi82j/gzja/Mf+3v6H33UsB09jOwJ3uwhYlQObjvm9zxPntMQCVMAleBKVswco/TXWgNoqe4BxiNJYf5GpyI3YdjS5c5ia+IZj3MD5TVVuTHHhN+pXxciC83Sh9GqWfa+G+j3aP9rchW5pCrJb5+WUevvld/Hx183D7XVdkWLk4UktGaNApVVwznQXXjjAxA8Hl9XZOpgH0Zc+LCsbwVYjdPmYJmfRAeWJNrHFeTyxkBHjHMO1PLizAEfL/fwhfcOe13Jyz+8X9mHqfcNKO2aPHhzid3PHOI+nxKXwB26Xdu3lvj2nroR12wUzXbpWfRXFE7OzmVjsq/F3krLhk8thn0GtDjeQ9dQSYeMT1xZNPlVXVDKHG2IHyNOwC1TAEZKT1LJ0rW54kXRZdIiuhNHXcVtJQ6EcNjNslTFbwdsM+2HQSQYDjEP+udySLhWyg0e4e9/TKmWmPBprKbBq81SRZF39iXkyYpgypEyDQs1Hkj43swyjQk6KOivJSJOrQakl89kjit4GNI40VITHhbtR51IHWRTD6/wyGQgitygrefuoAN2lKGzlbMjEKVO6EVhtqzxrFW7ykyr5yFN6K8vrzU23SDqNCVkTjNqL+drIbt+8UKgEZRHdR+AqgosSn+A3OYiGSRaj5KTxCzDwxVe4yKjIDzLcOdCofMHr8NKyzHwbvon9HZMpDRZzEYUZShvjwefkihI9CQwsKPTyUS0CdCzzVS6VOsoS8SVaxCCA+MPlDyGtmJQn48uZUhiOgTbOiVMPNZ7K84Az7ql7J5B5n3TFFpGb3u8wGUzt0VM5fTDP2WXSVfFzP3zaPdrZ3dnbZoCaHPIU61BTCWArRQp+YKY0UQU7qCWso3C9ng1v08YtZvL0ghQokWZ0Vb2IauDiN8HwhR3QqOsFUHEHQTKIStEeCLIcRwGjSf4lqWgyvWjzau7QxuZUb0GbcuXJWS38SLhx2PU7wc3OgfLd4xyrrLvuko1U9BXpnP2Y0XZncsgSax6GDPCXKP0aEOEgXxLb3YuI/z3SmQT8mKCSFFEfjRN64QEa7LO5wbO8P9SSxwIc+kNoosdroJ2CzNNMAKEK+BEhB3/E3uFnwS/4c26cLBxG6ee4E5XG4IQhqBLu6GHwUy3AkdklcjXSYbGVJ2Qg6sKia20pbUcfAXQmkmhkDkDHc9GtB56KBhMTe/xA7PFd+sfHH9UMU7onAvZL2BP71COG5Se/n8lhjppqj2LLSPjh0bbo2ZL6hk4zF3W0Sm416FpsNnAJVQ60YY3R4Ka1SACozG1bcRaEn8O4h5loLU2RwRWl13APgmsgMIeXUTjEW2l0kaQyU6SvCdyzviR4zwo7+SjsIVuJ5mnSxAwzKYgMoyLiy30mE86I7ohiXMAQPeC8HgFt7hmbwdHQTLsENfoadUb4Q1EyHwKcd/DhyAnAYD6bnOfDd+tnSrN3cgSs/Yyq/EgbBsNfuRtGPZsefd4P3S8PEsh9FvfLVjjKaICtS/njqV1TLvm5d37uHXPv7NAtk1iLbcxMbwdsL5f93D8Pt39ez9722VaP3jn5GksFE/OX/i6LgunaNPdzC5590LE2R8tjHFlZYeqy39xlQ6mbtjKR1Pfqri+i6iHVwqh5egxKwOnen2lJQRfjCsdnXM2OKgr71kypmw4vYZedXQfU0E3jCd00b4umQzYCHFwIXv0oykpX2fKcjimcDj0/RYPHlXIQQ6wAF2SeoOdu7Mzc7NHMA9yiEGm+NSgfadefikwgA1oQeibQ8oxnS259pI/rYJjAi6UGmFmZGpkFzVKzNAo7l3jzx26n1+WxPfMXbhs9SNmG2dQC1DEFMO1hkkXVaFNdfwodre8DP/4FylBl8ltwHke9bjU4bak+HHBiPZ7sRFAn5QBiW2QWTdU/x4kMtIxBnhmRhmGcuvBm1KsDNxuvOnjp0YBF3zzZeel56zLMikE84IP9xdgX7NaLqEHJ1KkhzS8LKLNyhG9MrDQrIqHiwmD65ycL33xtj+PTG3EyWl15syoqKvxlBa28/b27L+oYh3OxVn2aWvhZma0gZbehz1uPhVZlhRrmZpU9X/4FeeSVtZo4IGv/Mlyy2ifeDB6313w0F9z6HB73Oa7qs3fImHdFnlklKD018rzq2jIcXlFbhQc/rYjEL1PSYwQSyqaauZk+IjTYi4I7dyxTtWKEfw4gMLWIPFsZQcamIzZeolq3k5JTuYaaVltrz9+Y/72cGb7QWKRkBlUW5kBSGd4OdUxJ/lLB6UguUrbDnW/G27Beck1wW37/LovJ8TdUgmj2JGv5eMDN9MLl99wV7VEIXOpR+RmqKnZDuWi0YhmrvvMG9in5c9gTHyVr/A5ZYxmB91yZBPYcFW+ZdT7MYe+LlXUZm4TeB19cbVwK2HeSihr2opfsuSnu+RE0wG+qNcBv5iZS9vgHufETjXGYO7UnF6D/e33r73Wmm9uzDmtqgKQiBZE6/zMvTrgUZfUPPdvfgS6/3VTdLuMlLRCLBqN+lAJpOKTmXgSfiF/DQbcXibMEbsm0GDTLS87+gB+5dDFVIQKwqyXBYft9V0sn5D9mGDnXHynUmBaLeRobeS39NcyUkfi5MscI8DPmfGUY7SJqdvXdcyoC8r+cKVfgu8IMnV9jw4yuPTX5zr4DZWgxEmUM3qUKQCiHFllsumBxW4YtILs4U3ZujYjMXrtGPKBSNi6kGqwmM6+yH/+S8QghrJSqo4jAQ1cIswt+ZHWRJ94Oop5vtg1GXYq22GwSOKGkCwub4q8bYrVyJUv2dI7bMvj48cqpO3AWeXpBG/94MIpusaOTrw0nxuP5JsQ3vSlNdbYypzADZ56h/hgDacoNJiakGAdsfoOX1A2l5G0ycGOvSOX+gLcgI4SpFMqpQiC8C50lSa+ERCoAfkQxNCWfgak6BA0gaIBS6h8YKaBsz3hcwxc79XMp4eFl1Lky5mTjHDxHmDOm7Pr+dDABOGb5gCMfvjXLo+kAIezNqCXx23tHB78HHzePjrYP9g6PTxaMSVgxxgzCV6Fc5SBybjiFCmG7VPYdpSamlNdP/I/yAHWgnn5LqlA5cyw1Jv0Il6h2Ney05ybQyfiwI4UWpuZ1DOypaDUdgQrvhT2eFTmhC7z5y94hc4/G4gauZC6wYFkcqegGZZsASrflMQ4oB0Riytv+ivKsOLcHrbIHMJbkIXU5N9MAoJwi8Yn4kHQpzXOYkrdjeXjRyC+j68VUOUNGtKScU5Z1fcyTvhCJjQ2x2KcBFu8/wx05q3W4g57BpyIpyjPpgc661UGikrAVPUwt7JD1+jzCDvnDa4OOMRCn3GByEpzHRxt7NepuZWDPeoE59WlYNQCxxEX3ydIbm0J/eXfYdLGpaFDKu/rPUTTCx8hqNSzTHB9D8OUSAydQG3+iMOiJSlvDZNhol5OwqmpoI6AmNfZFR7dAL8OG7KrWqYji0vGVS6Eu3Unp1ic7oNwmfn5KNpUBYOsmrF+lQrB8OgU4c4s18mhn87c7cDdGg9lnbORiJNQU+1UjyziMDndS5HXODfhAkQI+MSGnhDZyFhPjhA6v4qHoS95kWSgWREWHDnsEF3BzheOe+RG5hA5MF6+vUQXfNAZf4geiJ2J/gGk0euGFYkQGyWCZ3soyvRVX32QMi1JoF1Hki2VeTvao3vUtLN70sjVrcwo10jlUHe20FkodNA7s1Deepjgw9wKi6uVJUJLgYLA+lTxRld689J8pr1YRqNnARPdVlx12Szr7Zpd4pclylHRcelirPBG4KrkEQ5n+Ce8dHI+CVFt/RmlLdUaLJwGVcmku55pdF9+k2TZm8znGFgEOHwwiuIpl8sJ6elO9BBkv+/3B5sdfg829zd3f/2v7INj8bXNnd/OX3W1ByJsLa1LrLnOlc2OVeSn6BR1bIY//+dTGgFlbmWu9FVvtjq24KqpPLBjDD9Rc8Wrqr1dLoh9+DeiXWBcxXVNW2wUzZHuAnlbovDqqFltDZ2WIcMlS1qtLvszN44E18+P1F+3TdeQzduN+nLN8OErhTx/1UDbhfo6zGMPVlK52inCd8bUZdOYpsL+xlQzs7E7Er5lviEuCE+VxL0tqBsZLvi3Sgwd/8D/LvlzlxoaRo85V4FhuN6Y2GMPcKq+MfTAG1Di1Z1mQYxJAkatepd5jalC2OEwT9YZ/imDQiypHjZeCpbK2/QCmm2bx5wiuGzQNEbo45OEFqEfxHxuiLYo7F4KMGth39PsQStYneUtZJktpNisltg53oudgWCT7QMmKsUvVjmXjU/b0qPRkKQQ9JMxypD365nl82mwCwJr4egYk1LmE/eSDvwkLctZqBTlrYwty5vZ25UP7cS5WVe0eN8HOA2jM/ecfA5GCG1uQ7FWXsyoXaJEdyLLonyNKTg+HruFh5jPncVy6eEyvE5cUqQZJ2iUFO1HQ7ubvcBnZP3i7fUCUyO2PY+DK3rxxOIVB9HXM1uIvYsXXgyup+U37qwlW+/PyG/HgPA2bpCaiEE/xxWVRiJlGYR3UrlKILef5V3PSKLSxi/9tA+bIwpyiGj30MECOPv6hZcgr1QxOTeyglfZ8y5DjIqJHEGFIjzuIk/1tJ8f80K7VefFMKPKUPLS4ubxYR5vuxkY59drwdPDM1hUF91RSr9PTyqvUE0Gya6RmEtSQOBYTgEdlWSxCmm2PlznaIb8k2uYxZMtxFEeVHI+9OMX5uG+tUS0Gy6+HGJKzH2cYEzlIo/MoRVA/WViqbsRr35CvoKZzWsQG/1mqFTlPg2prdeZVW8o8xSoxsaeywsTkxj/GucpwrLKbNap9qiwf/I1arykTS7aSwedoEBPno4xHEDC6Pi8qKarlfz9l8GsaBMzSH2u6Kr6mdy3+YBsYJhRQTcqNMQWzKTyhTjcq3g03bkl/JfmN3lGzlCTNiBCj05OYr8V18VCCXpTVmC+aGBnlc2GVoPMFNra8L6o8R6hFy8BlGWh80hnQJiQ+XpmthAUZ/My4W1BggMwJhb9TMZm3wrRrRb9zC6YneFl5HTaGvHjQ5FYTUoPOmIu9b+8c4rNt9cjcPOWS2vAMD5efc4r3UTlia7smZOvYO+nV7O8kb5iGmipTEp/hTtvJG6ABT+thwlpYFCGXAjboYjgzP8Kfhn7QdH2YcVzOTrzuVXz7IjwEzKfc2mxaI0LOVrSFMQhBFsIPYh/Ot1Qzwfbwt+9J5HE3tJUpICZHHebCJIVU3EuRZ+QdW3VzZUMMeVdQIQWOaWdjM9ra+rpgcT81NiLyNxCh3YJkAqHAy3dPehCPGWOB14E+2OziTLcJToGBmS2kGTtsgyVK9xVIjWs8QKEF3PrhNpR3Wp4MHO7K6bqEyaQjjsqAYRTQlFjmP8GsQV/z6oXrwZV3M8pgTxb0Y84SYiUDMb2luTb5TJcr4mqCwaivKj+0XOF+qTzW3szfuRsN0rgjjYxYDlR3BPtrT0zm8F0K3fsdxuUVSdRBAFq3adwgwHU6jAk4EEE82tqwq7xvKcUg5xNi6OggrUt6K+X3KKfweCK28HS2UhWWDUrRr1BPr2kJHE3OwG/Yyvb6ujlwHWE3wOk1ogHMFn6OjcVRfr78Gn2lSUS5sRhfDOC1LzYrPIqNQY/tuSHsykFbGZwqOVJ/1vB05Mve8TFMM+V1lIkEpTfDKKW5V83E5HGKucxKUsRXc4YyYZaPCzGy6pRYjHw/wIRZXocujBd8D6hEFsV/bB4eAYGTIRjrNAuv4CVxFgKNSD+4JdFNOhhZeHAxBtjksHNRCom5vpDSGjypW1SrpHLBRKXKmB9mV1aZqELs/EvYu2rgYBUON0asBQ6Qgo1kzsTzqoihypyf+Y4Nesv0hXEG+A94A83j5ZXT9WplxxPN4plvsbo+DYJVA+V4uCGOHy5w6IR0JC9W5w5kgMMk9/M6dDHrTM4c5AfAilqIYYZGmGF7+DO9v0cFJJIEXS0QOIgSG5cUXSkTe3S52Mw5+jh8PBydZZ00HubNlsemzEua2EfTb0guYysZGtxeVS96DhVdYSxgPtP1+ql3iqvevGl9o2+okrDi/lYPWKzUP2D1YKU46ZmM5dScPM0/rzXXeD6uucbruSR5fe6NRfzl2jMPA/aSxgUE3coDDZOgeiDV//NNkv6YxLgV9np1vfmIETW3zZtGq9VqjjfIGBDjHal5Y/tRU2WoO+J4bScLj3DU389Ka/7IXgkJ5S2w9jpRrjrTBO+sR1K7e3OoduxVvK20T6D92EeBAiMAd1Smf3ndto2u7nt7mMhdYIemVHUTIGlsLw7JnkvfCbIatl8uUZleAQzIV/SN+qH2N6VUx/VYw3N8By+2ap7sb6zEnvIbzN1+/cZ/U4syTp7jeYAZuF5HKZtb10GMU206ggfcD12MpUhkMSSeClx8HMUONhRh2rmM0UCJfPHZgppghUSXJFksRWFDAUYv/pPc1goBpIxbhurPXgg0BU3wP85rblGhbc1JYy7pCGVaBMq24yoSWYVZJ/rmDq4bQ8YMPS/yucNnqtdmtb02jV+TTOlk4TH5hfvZqcwfv4Cp6FklJqXudeTsrTzTPENpRXVCSKk0LLSk1aLIzW7Xo0EUjS+XibK/voyzJYHfu0nEX6mk6cEBFZWZhXb8taRK1BK9Si/amoCz5SCyJwv8zKOS9IeMPVngZxUNymE+VDhEHtr2wZNcm0clg6sEOr1I0JabXqWOJkTDewOsyaHkpO2h8il1IJk7VYfizyXMZ2PYcJhVa+041mbPjEOtrd6UozBZ6IZ5WG/UweYCfYz8p0064Oi0bDnYld/EtdMxLDqsBpm8QvSEDMguwyDhlUVaZ4xp32EubDcJu8BRFNYdjt+rvS7+LhIYe9Q/A14qOSdo4AAkPOvqZXXUcvDaVkxCwlhRilD27cZAFDYP8bShAqx+fOplwNSPLa+JE4acCaWDdZ1DZtGIg7V+ZCMVwOeg1+ubOFNRPIX5GO+ELYgrnqU1PGyMc0+RMc2obclwK8zg0RBuKUMOr7G7+4GVfvG5XI3FrBRiQnKl5YrXkrVhww7Z+zqGPNvbf7stdt6ui28mX3NzMni3s7utnup7Dzzf2/ygn7PMYfC3nT3dAUYqg0e7O3vbh+oZkBG8RbSiuFnmJ8Ap8HecwuHO+73No08H2zCh//7v/z4ZyFbxxSBED8Eb+fhk8HZ/6/DoYGfvvV1T649ZMtEYJIVKuXmyYLTf3to/2DzaP8CpYRz91h/AwTS4E62ebupuAK6p+S+bh9tia3fz8HDb09LUrZbb7nz4OPmbVLv2JtUe2zr1zUwlLNd33kBmiUKsISl41rmM+qGJMc7j6RB6eBZg48naCwdPjGVocQBT9m745/VyD85rlblK4BoF13XCeBnwcNFLzuDkDg63ft3+sKldp+R3jEqPllnOdUpiitXIFq6ycDbtYLrdqKVzaeVotSZnxNJKXI8q5hLuJPragQ0hWCJJzqTrdYJcO2XX+MPcOhT+p14Gc2xeLUzNqyhalyehjMjkFLbpj52h1jd4Oq0uQyuvZup+5AWQ4mE/yi0MKZdMU4SOu4OJvZ5GcZdhl4rNwfWpE5UQH1mosz3I4EQW2L7FF/lnedyPYOv1h88wdyb5xaM7O1mUYnz2YTIcYWrproVD2AP6ixbcOz7RAgsZJtDQWmBxOf+O7ObbjQrf+kR8BGhI8kj0oouwcy3SBPq5iq7xagTXEmrQuIqiIZdwsr4+MDdyxzblvQkLoBleqBypil4wf5WrhqmvWwpp2RhXSO8Cv0urV5yEgzn46BiqnMqXQp/VouTboLduS3ncd3FcFJ3ar5cfS0t4YlO6D30BWqlJ9Tu+oubFLIJKnKEs8zzuovt2AL+liSvewinKlnN3ZCmtCCjsutDIGFF+VEIbKLczzGC4H/yOd4MMfUpgzwZp+MXe4/L4fRf2sshuh/aUKDZQszhZKDcrsscodYg94tb+3rudt9t7W9vB4ad373b+sX34ANZSL2rP3hfjnr22aPL1i9k+e43tQy73mf8g9lar9QNfeTjnsv87iiqChH7P2VxaYiM5+8N7ThtcOh+te6oTUXSy3Iuv0DcDe0K5XLvVAvClsFHpZ7wzA40JMhnMrAO6fALDNMoHsIrIZx2aS9yhDnAHLZVK0zkkeQgPeJTidZXCm5cvBZS2M+6gohYuRnnDNYSUXHfj6HoYEd+/JH7DKvS5ekBrwoDF4j/0SP+xAXuo3Wq7plrhF1wHTuRk4Rt8umEks2vhW8miXKYTb1CjR0gbfs9T+eXsc/rwDtL4c8T3xfOwH/esY7mieDq8x+4hOigvp0GfZTRQghCtojCMsSRZqrqlU7S4lwKKnMdf0aCK65puDPACmsft09ZoOLQOedkGfTCO9j8E7zY/7OzubB+Wh+GK/Fhe7jdseYjukx8YXdB88CVsyDJiguUsmxZBq6ou+QOJXSTptcyIp2q11POmvTBn7nyHD7Y2j7bf7x/8Hhzt80J/53Quqg+LF8HXOp0qiZXV+aH9PLaNpdzns07tuI4ymReqhtuI2zAAejTSY1GBojBcgd/02ary3QhE94Wt/YNt303hZOGobXBCZpPNg61fK5qsVDTZ/sdRRYtVR21Ta381FVjwYg6woHiah1+TQdK3+QB/8ZR4ed4DGsrraRTBKarvFJKk7AAJ+FBL6RhzupK7QIyo5jmamuJVGvuCjyhK1p3o4Gb/nrgUxzwhWUHKvKxGpstFKVM1rctgwZ3elthiQ90AEHUCvthYr4TQyBBcGlemosmSGz3H6q34UmYrMEhnUZfFkQhOSxJxliSONP3vh2d3qgZ5aFRZq0aVuoiY88BhwA035fiBFprYj6fEUPMeKFKso1pzsAN1UOV4bJepm4UKrmiIpTmyommzY3hlZh7vimxJpk8iDDk+nU7DwbnZz2RTVd7P+vGM72dax733s7JEq7VBk/uZ69r7mZ793M+PtJ91ksUANX/2pvaUzexN0FmLNMl2nO8+jtIIQwQ5Qh9Zt3RVUW51pDPdEKp1A2Uj0uS7WdQgC0v8cKqUsjs60niM5mw4/SUR9rJEUFIpaDEMMRVBS88Gm7ey0TlcoszpYO/K1pyqcDtlV2HzeLfUfiLeRt0Ri/YjmTHYEIxTAgQ5oSyKBnbeqi42Ja8g9W4oAUUe9SkHBY5sM7OqCLu6VbiNlSiXDbYymEE5qlqTUSp/KKwweSHyWu3lcW3sy+Prubo8UvpDYssrro92hZm1QfMtqFF8XMczcUlueQddbhMyF72ozI8u5ZSEzrbeR4UeNQGp6LRp21vdrvkpjYZETaDnIeqyBsoItSHjlGFGFxTLJYQ/zbI2qphHLSjUCoknTt7tavJuz7ecuHiojZ4rVNF2ea0O+vms6aCLtam8BlWcsEpM4o0KxvrkD+GVjDhahOhUhCGkSZY0JoNDGM7ZYZLBjnEMVxVfUcHe2HZjfhAxtdTKv99NdnJ7FNFmSYFd+CDfdqzDsnEJXkA1gqfS9O1xoKVfvmPMDIU8UG86RTxzCA5yHnFUhxB2pckJkSfn5PLdQFEssVF8lFzBeOigflFCiHuAQ9lYpZiIvF970GBisKJARS0DgcV4Ex6LF3ee12XLGj+CmPik31qBURY8TRJt1FjHahwAmykFmrWZSoEyBtBk8Aa60ddqkDEqzCPAyOU1jM/jokthESdNwImA8AN0gvhyNhm4MaZWbSM3UbwpAoC4kksjjwKCkkHpOoW3MV1PrJF74gZbvGFjc1SfTbwRvERZxv/bhs1GTTq/0qTA5dXsgwvsvGQAJEzPY9vS1lc2ORH/j4QUd2UNQyVVc70xBP21tRzHGUPSYeV0MyYhryBslVvs/fV/jqCYfMYoMrBM6TZEqMg4fAjH5XgmYUqnUsxE2IGXg9HQe9et8uBxN+iHw3Vnlpb3TN3NCO1TXWuAuOu7D8maUqBjoCQXlFThNea2Jwvr6ycLnNX3i20fYHBDab5E4UXoI2IQ1dW2QNgFGgMVbafT8+V5e544lwKxy0xLUVYDLg+Zheuh2BVucS/XOpzpNUX04E6WVa+cbDbLoyHyLcsUcOwWdgTHr+JDSFupyEz6z3k8A5u2yp7s+F0bAC1elXpQo1KhWG1qA5pq+RJBQsPn36aCDTab3j6Mq6ehhHWKoPV9B1Csp9N5fZcTRpdX9WnZXo2dlm0erGw+s+cauclQVA4TYLyFtezLA6aemrSPXWlx1ShzNIKf/1gHWTWzpVmQI6cYScQRquf/JaEiEw3OprIkvoTpANab2ZHRuHS96N9Qh6oW5dJ6D2CK9uMYShh4xnYS5gXnu7x0Lb9aj9+RnfD6nCfZIp8eIZNZI4JE/WF+TbzQHWBTBluhLLYDk6NiPkwzYa4V1NLEXXcnlIDq5eoc+CSW6KzVuYw6V/Ueindq9KMuVJNEJBVIrWKZPp/FJdELz6JeZf6YsvOg4TdYDoU6tuugX5DqV+CO40Z4Z1dCL458o5dxIxhKcDFy3HXxjUb0B3P2L0S+jjY6J25Y3okl38QxJgO/P4ZyA9q6iMzZTK9zYnu2cAcPAbiLD6AKxja3YQch3wstqmBihmnfHymgvBAbMlbbVUwMLqbaC+HODEzIYgvkEFri4OGZlycwyD9HcYrhlwnwrJuYlpAsxl0ry7xNeCiehkkrNiJVPWIr7lZDgGPYVkSjVVldjpl1OLWlMTtvg63Nvf29na3NXRVdutUP885lQ3bhYtUwzDInTQV0srv9fnPr9/F6UK/OgJddDsUSd2V8vHUxnc5Nay/nCEfwBu7FEVUwFziCiyE76jK3odjrdXEYMQnfE1vYePvxwEWiiA7qvMgC31ok2cYZKiRRDQz4iDmt7rEqOlWxiPRbqur7XHYuQ0TLZhR8FZgDu9Pj9Rft05tWq2VchUqr4VvaHVYjG+jVPBFHLPrm2H5TH8N1JnFkC/YFRrY8pBdp4EipoMb0ba314uGuM7VmrndClIfPHr/yqoaxfVW9k9ozJbG7dR+1AngBcR4ElRvKqvFoFtO7+vf87r2ksxrIdcjI4kb4tXVX/0UZQIwK6KtpRGuz60mFZXHYObpIQ/uv27g5E+zqZsokqo4iLp9sEbt28gksdNIIY/sFYX4Cq8fzEgVvMMsvjWYrzhJm+BrNJbehktWtm2st1aJfMAvCTh5/xnGwvjnfG1Nf+ERsbGyInb232//Yfit29/f/9unjoWjsN1aaqBqFM6CJNZzV0lUk6CXJ1Wh4x/canF2TlsBsxrzGwyNKuxpQxg/Y+WbmAQUj4BKlxWGPk4hUQ4u/7uQspsbhg99RIPHryeFMeVFGhkVF9MwQmzBAV+2apAOYCYAyJsuuMffiswMYj3OpUPxdeKvApq0srxqpBjY7KBjLiFnOUDKenP0R4cfGW1idipJtNPhlFGNkMlKzRZzVgAiWCTJrVU/xidjqRWHK4UbhhfuAshINfbhnIkEduVOQAYoYgKuE123mO9E1KSD5WDUxZvqYfSbu6CWgSSYXE/h+mZtfrcwZ89uSKdJdwVxtpSlMZnAveDGWZeCKCi60xAnFyFJJPnj6NFQZTLM6gNmmjkUosmHUwVQGLMHDOJyw32GaOTyi4LmENSGPNG5SEz3JI4Cwnbcoztbp3zE5CQ3ecrKbGEvBZion0jknT6C5NOAO20J9ImzeYZLJxEznvQTjlDr9mW9iXfwtul5mxcYwjNOMjU1TSgYFH9XkauBOJo9HsZ+8gxv8oJvw/u8wffhhB3nvWmRX8VCuGH93aeQ1WCbcxAeMlDCL8HMCvXfSMLtE8KJOpzYNnGPN8HLmYYbS+dZijFlj+oKe3gtf1JI84GL7jvojMBSEYjAN4uwaaL6Uws1MmU5bnsRRSoo9nSaB9h5/82IuNrlko+r3uVGpdquvzdJOl4uqzl3qu6LXbnXGbtjw1SlM2cLE4mBp5xum/BTXoFmO+lDQyvEg7p7y0cEZ+7BXPJJkqkBd8XRKVTtzSki0h28jJFVprggJB5WEhB8nQUN0ZWsAy74k3m4eLQl4T0ti+x/b+M9R8zbCwtZEWPjhJ03NLk3hffxWmlKV5oqmcFGSpvDjJGiKhBsNEvzAiTcadHAlS2hzeZlgOt+807qVsrAPNtCEDz8pa4ZPq2QMtk9Vmq/TKtFsH36cyGmFwsBGB17fcjzIItgb6MV6+zGVSP6PPsgcLD+JakaJioTZAYrI6unKrjdHwoNiYVUihDtTGCsIkjS+iAchahaUCJIldC55DbpxJypIrJiQKV9wkhJb1EUtjmOmrZgoS/aJhv/iP0QvGjSKms3T6ZRVzDF95ck41MW15o628mTClDVM4gGRFYqc70JUefKTpGZcXQ87hh0ra9T0Vp1acmrPCjUVa6JdV1CPESjAyO1L+TN7Pcxw+89RVMj2siqhNvmZ2SI+DHgCHN0jOG3czxRldd7UxPQb47a6bW/rOnO0t2lNd9rb1ILj7Q5InYk6ULIuGW+Tk7jt5yb/IZs8uR3AdZ152uTJPQGcGo65rZOf2P3421r5k1RvarPGNEZEuteuVosaZ08X37dgU6TRJUqcPkeqD4xRMiJ/DR1pCZ1VP8NcoMi041MeNCHtfLSvIfcP0Yc9DLPHqkXlwygS3aSTPTva399t9bviI4b4+W1nZ4dTd+uxyDzHP6A7f9dzR90ytFMRGiEFqtTJxaOdd2yTG8tw+vhkoXgruiMO0Kq/uTDAs5o8yb+pvYq8uaeP7cu5IXn7174dAMr1f1TMxQn61LmA4JCAhofbnecKgmM69zjKkZEfOpn3RznL12hDt/x06vehq/ejc8wAM5m6wTD9kSes7T6w0hLkkVsQrx2dQIVGM/rhzMkNX/KtQC2cvhhgU3aCbnqDjkRfc3SHM/pqVrjamjX1a7bXttoS5FVnwHVDho4j+24Emkew9bufTbGTOGIOGI406iefo6AbDi568GuV8yyNWf0HKcmABYDldScHPN4FFrgDO9GDL9hEyhTJbtiyatX+qkimmunowK+fy9G6JcQZAy9UVaKjwOdLIDuHp+0TB0DIj1gBCLtjlAJ5lN1+K9x0PTNRHrT4xcWUcvpDc7J/2RArTuxFVfRX0fYxO2rpxvCuFfJBdIbeHWrZ5OHh6Ul7pI8hgL2vu9RPR17ppvB1mKR5jRuDLjeR5fC3R/NgOMTsS50JOmLyigoo8YZg9HooUEMSS8Gu610DQcD9ogOjdZlhESFeYuCKj9FayeMJTZXTaxMKwu41Uf7nOBsVwRzhwX8e7u+J7qg/rLmoyJtByelSJk1cN0QHNjdSdreUeenWDdot1VHXF11NPyj8LafWHeCN7Sk97ZRKgs4AtnLv+s8oJUJF1hOJ0GIDrIcTE6WN46lY615fmr5DiG8e0rt+QjumPfM75j0+2sQnWZwdRNmoZyF7RfHPXTRJUagjFpnBXUQexCXXafvp9KW3usve0X7S7B+tXS7E/whMGkdsAZyqX1tvY6IZOADNSEDkC82aqT+yZMAee6HYi/IvSXr1DyFblWIyf8Vkl06QwzSMs0js9JG1oGCBGAVMdcR+fbCJe8BjwJ1lNFgXw3ionokBV/yqI+HwvyoHHua/w8+ykK5ECdwHGuzkcbKQortiNOgkGCN+42RhlJ8vv8Z4o8DInBuTJFnqhsDFktN849wa7z1GjNYvq2GVPRGb3a60USSrKSQbeAWDXHL+xXc7+KtRj0PA2hHpyd4jHpwneBkq6nrCQ77HvJksWvH6hEq2ZxzH6XFZmOe1Uo7n40o51t7M1m3DgyXncMsLzpI870WDqHNlsTK+sonFIMsjigFgQor5SMLJZpZFKZwbE0EUdz2N9+sOiiyJPBkGQMSAGLDb8XqShfjTB1n8Z6Qev2i3CYGQmT/W/J4vfcQ7tKUvRpRkxlqXM8CGKBoMYMuK4ndumbT5a3xxadXbEHCZuhbZJYARvCw2MREX6I6cJiOoTI7Phl/y0WUE6BWmEcpRhiioEZdJDjsUqPmZeJ90xTtp4Z9ZI3/KYJ60dLKmBJruYdAXBtVMNP660m63eTkc/HgYpRQ5ZtCJfJksqsDVTlasEOmQ3nlpWC6+wrcQDxrGD7NE1mHv+U7VpFjU5gPxV0HTpUDUDx2IebWata0zdV6dDyQZQhvq2YURs2Dq/ATuBSRqRWOgyJhocQC9Fd4CH6F/etKIiflA0hIo9+kKYmlgJyFtAoFe6fgsBmzo5hIzVCcqegD86NGAuiLMALpsGaQ/RC8DzICdsvyDvX9EY5CIrBMPr3Xs0+b3Ursd0vmJOEqveYhlXut5nALQNc7DDCZTggRDZjpMmcspfhdMWD68DDeQnuy8wgY7Zw3+Dpi2sxCAGvhF9xXotesxpxRKXswHlMDy+iOMZRRlQS/CiOElUPFXmQ94Ka/NBzTwwya9EU5lnYOfCwohToCD8s1jgCDOp+kJmMqf30Z51MFUEno8yaCgHHWXRgY6ukhgs1z2RWNIOkiT8ulfWRGIPhwg1qTJZxL5Cvibit1k9Dkki0GY4cUohB2TRxEqd4Cv6eRA5sbw3CHmmcuvh2gq0rumV5KJSwA26I0SbuXXApNHxWXexYkuA29N39e6AFk0HP0kJjIVr/FXHoQls4ie8BOKrI9XvLQ8TYncUlmFr3xdV7rG0C8S+dFqhrTRO2+zCsiEu+Svm4fB7vbO2+299QfPp3c/Bcvz1TlEF96d9fBS1Jk6+8jvxxdeXBlgJoIjivgNEDmX56yNIZOgoqKVXJSHD3kiPvXyuI8KITWRdZhrZMORJQTB/2CzKvjYEO9beRIUT0ybM/MN2EHpyLdlqegcRSMRJX9Akz548XoCQTGBRjFKs5yETw+FvjMyfY1uW3a20Q2mN0rU/LEvdcAylwyLj1PR1M+C3A2oEI7yZEIYg7zKGUpEQqD5Hqb8LAb8XubAmPnJArNiHEVOIgx+oZx0vB7RkNEelxBTMs0ZnRdza04a9Qpo3dgwJonTajhlcpLIXhXchifpYCUT6k9wYbd6BHS53+XIyTU+uxLbNHbtz9zn88GmyAX5EKUX9+O8kMkWQpacbF51wtxqwSz1rezRLpMsYhOqsCe+JKMeWohk8kQ2fZ0M2jXEq7BdpAm9lLOS02wmluFDLk024epE0YQJsSiIdvb9wtJf+A2JZAD3JHhv8SCitC0mv2LKT8dhY+RbVwwFvHf1O5jMiEyQztOSFY7X6Wc5nVpPmJXZv8Ao8T/FgjMhoFQwOUP3o4hjpCvq198fQlFjrcNH+mxoKQPYMiUVTu49xyOmRPeW+kTpVwRwAdL21OIXZHjsCE5QlD+Oej0KT5uKP2AL6fhIlM1aNL7EUJxFYdq5bH4/ZR+gVOJzxHIOgA8cg5OP8ywkQbM1LlVtYBU3YSbODC4a772RZ+XQWKlsOh9woBh/S+j6/GThf75h05v/4ZzfqlHRvhUNuhkqthtFZTunpzsTbqfLJyxkXavV/K6Nrfldmamw/LeBSEvun0owMStMzpnu0UBl/slEak5oFTqKtXeqhVWGnDCluN04SkeRJ2kn1pUGH7T4BczIQcPcYW7yOaLepHUmz2ud5Vaf39NbbhYJenRxgeRqMJlBZ2Qbp9bVmRxZ/wDTjqqF3aqcXTHuDXgD9zENh9y5vCjA+cuOFqzN4JsCyR66ETH/UcVlgRSr5FlhmHSsq16xL3QGCVPUyXrMPFpKXABjS5EH3D14eE7qw6qKGCAuJBlmb4Q602yi9hiGnYdtjrHabt9uhvFCWWHguFKOcMZqW3wNgfFigoJiUJN7tXGFfnky43GX4cqcZSa9ICYILu1abGmPHRL8zUw54nqgRX4JkO804cR9Xgshb+6AIGSEDJRs5QCzH2q/Nlh8grq5ieCIuaIGN3aNT/3WHR7TbQtJDkYDZttDWQepPPSET0FbTcP0tZiDtdtTGgEv8OVxG457HHnQbZiUaDiSENmZNTi8lqxhW63CD5Ejf3Iy6r5e68K/nU4oaOw/EZBUhkmeW6sY+4bvVUu6qBj0Rkg/F89IxkDddpeubmQ3VxjwiYbfiK6pEloWr6plNtvwmALKn3WD/q2fTafzWmw9uH72ZbV442UN2DyfdT7mAn4R1IfBWe56vnmKflDanrqsYHfFHGdVDd6w6z7SXhK8zUqgBFsaj1SCInhqQc972T8wFelVN/kyEDyQDJKp8IiHtYPe9OIBe8uaLm9PREGXqx2eplDzBP4E+wY+y/aSM74Cgjx9ukdXpadPvXDxP+Lp021ytjUqmKCBFbYK3QRVQ/iSVQ21RfOmbionC8vLy/UVnhjLjcLX4pfCmlebzooGmdz9YoDRVgFG9f2zCJlt8mr5v5PRanvl+aRhp10rVW2PK1V9tTZbvlmSjCTpJYw8AZ27X6Kzi15RYuJPZYVHy3ta653lWZQNPWuvHejxLkg7Z3yO/wxMV5WA4hQGQbM1DFNy5zX/iGeYJDRJenCa02flQRsxK8PDwJwcmyc1SosCAdiuIex88w5G3Uvyd7gv2AUHIOTv0dn7XaEnTV2dYw0BF6lvqtMbI6815i2DpbAhbC8+a43yuNfCpxT8lxcH25nAvlExf7xAqs4ll9BPuiPK8uf0zM+5bxylgf809drxGznroJXpWG5Hnwak2IYLKDYT7hvg8TTfY/QPrxYWyeUN/lMob6ZXUzNbuZT9kJL1Rhfx+bWFIsazmQUOuYYGmUkWupeC98jCc6SJNGplo7NGerJw/P82l/8rXP6zvfzm9C9sQLFM1IQ9tKBhPGw0VXj7ptUJ/pE1qJGteaRKZIAxGlwNgL85WZjaPb02B1taCtEDmQaatrW5vSvKJydffOy97llQw5du26EADMZgu0ziE+ksSbL1jPxEBx3ubolMgJosIFNmgzwmytgi3Y3KxN3EXW90b+YgryqUQnx9CknlaUkESAc+rKXBFZrNVqH7kFVq6W0agnG/mANik7ZkxJyQ/tciNW/p7BJaaTkNY9cqbX8Mz/OwP1wvUk3KQHL6BnxkGwDJ3U0OzLq5JI8IH8Dl8wucPVD3HL8Ctfz77//e//du8O+//vuHfz8sWCo49KAPffgZs7OPpIZ125VvotfrLydpDLsm6gbfsI+b4Fue3ZCPuntDlm0uR3ATXMaoNMj6Wa0u835Pt3qMyLP3I8KXs0+EX2BqEf58QXHbViToK5uYj/Tkgs3enRjdhckt7Tv35B6UY3TjdF18GsDkuAaeJKqKIuz/z963sLdtI+3+FTbtt6JamdHFt7jr9nFsJfG3vuTYTrs9to+WlmibG0nUklRiNZv/fjADgMSNFKXIjsSmz24skYPBRcCLwWAuqQ2wYW3I6yG589mxbsjhkhSCqx/yElc6MN9Rq+fn1fRJVSVxBu/JvzY9uUZ4m1Sjeek7wXt+uSQcU1kb0GzWvG3r0RiSUnwE4XnCVlDkEVqh8c+TUVKjQghFQHr+aAgEgREgIEgVa9ptDcO4DeNdMr8YvO5SYCQHyw4EyROv0hh8sYoWGXFhQe5HjY2ywAnAt0HFbXz5tYK55AWNnBdRhK4JkNIJQqbTpsihAIylIcmXgI28qcob6dLDDR8pM+zwt1nww9/PAUOg/QLhx6wyFIic5EKDUsH4QuXLG6x2owTK62TQ6dvIeG8mvMsVUrY2VkRKUXu2ECkFNtFOih6mYwajRDArRCkdZPLo8o83HIjSrmHDdxLsWIxwwlTz0kBYTMku91nxof5AjjaJykLoMxTO1KNUZfklYV6T6wLwkU6IT3Dm2ciWUjZyAGVrpaQUMmP8u/s46njDO3/oIZwc0mcXk5Gk3FMeLy513heHJtQ7oUBH8zFjEy7IVGzFYhOaJs7b0A9CBvB81ojPvk2Zb1PGjDUGnFmu6Kdfd75s5d5AbZU0/KlpvoBgNGCRuc+7997AFaeO+e1X8oZdJfyZz/JnxYIy5+BP1MZHBhgS3uTMo6bzZHcrX3fmaMfuRk6oj0b9r7B3sRnidMgQ+HGnkz2JJJInM/84Sn7SL55O3JeO94MmahAOgpiJgLNkqZ7YGKjpnpA0QpCGy7nz/Tft473zZY0c3lwp0+oCs5XZKOdMVoEiZ642neaC5bA8++q5ZivriJAYPaLZOGrUA4F+ES+RpXmbk3WEOkB41n7Q7/tgzEcVKqi75eopi7dZzB2Scgi17ISsgUcs+ku370YRzVoiROrmNSp5g2h3eFHqXmYHTJlUNTWAhaBR2sA5uDRNCpge8m7kpGpkcSPo3yDUlzvnoUCB6Mm6T3M+QQ5WQb9EvlL7byiKJF4oxt0SE76ZPHEXm7BI2wS3s/fA7RyDsFbZQKVD4Lz7vjPwI4jMhFc9kQ8umbLtymylFnal/nRiV7JPZveMoZEws3f4xK5qiMNiXzE+VsIH4mDG0Gh1KX5vtR+6/TFZEAcXpxCIJr73JhisBnXAEZl1XbLuPUx4GINnZwSZ2HoWhWMLgtakgS5xcbMnYNeZtpnmPmvDu0mlZtWr1k/66707skzuyPI6C4IYqUTNMemKiedZ0kelhOS5n7TqF2sDUZfy+3v64keysloKGvBx3E3J1mhJQ8KzBL5ZujY2eW3dBT6ejLxdriVdzgDB5dFOZ4AH+MzMgDUJ+TLlNlgE1GDHcjAGXB5jt99hwgYRszNRB92QuhDL14XY2+4oUtEGKzMtYgjqoSzffnDngyuGrRGzZHIcRvT1pfNnRgqzFBGUNXKFRQq/i7x9N6IljJCEQVMwaDjcgeGwPGddBo94/PCLxRzhyTEvA9Y4YaNOYyGnXP9OVu2GluFxOcGmWS8p2ER04nToop8KNhr5wsDGNSsk3cdWSCqgI3XwSwQbxshCRirKdBN3fyPWpNEAFMRhTI2FFMwpihYZy1ZsIRdIktr/Lr3+0biO5xc3yGfnrP1qb//i9Ozw5HVNJx+xi7hdfiPnHLcPDt8dG0iJTNT3dsE/lYiCrN/WEf1NBPIlFXE2Soo63f+EUScYgfUcRomdDjymEqt/mlJ7NQ/g7P+fs3NL4KFizX/GXphx2MEgpwoKdKkckoFLqYySgRu8tl/IlomgkfCDJ2o4MiZd8ELPU2oWA52V5FKGFteLHIgIGnF5orWDkUTdPhgO9QgUP/CISpE+TBpUzIhZRtzaO9t/c3jR3r94d9aumcuMvh2nnhRr7oJeBxWPndCP3k9HGp1+9XFG7pOuPc4ElzToLyRZQxZepGtoqKaTZleKQAVDSQVUwco5wVx6T2Y7h1nhEI3gQYV2w6FhD2+tezeCsIE2PKxZlIS5IlYqVQ0+Kk4FqzPHAaSN5vWSP04YERmKVO2QehvVy/p1ViHW08uUxTVLdW9SFGM4Vza41FECA2cwJill8jPSaCbdfoSjRv5CNoYxzcSQNmBJj1KtkgINaTBE3KLBVGaTbnKLrj78ZHZvFiQiPNI4xd4D+Y3px5Sdr0NTKvxcDinCJPCC1sEUSWAAyIomnyl4EORgjwhoYKRQJioJ632MBuAL4c1sySvGayQcuy6Rg3xw88RY5t7QZv2Cgx58TRpTlYQxtewvVqu+4IPa2/bZq9Oz472TfUXeWVIpZ7Ok4IOLvPPBh6CZEMtpOuaYSqw+1Ki9mnJTngk3yMdK+dCrahblTxV/UJ9gBSFcm9ssu9suaZUHkhCkjAq79z6wJetRWKFnp0ftzsVp52jvj/YZ5FiS15uoBtqxKiMyUcnswuZUlLNF5Tff+ziNSCli0AcRBoK+TauEq4ynkBXjphRi926kDL2203sI8VVOb/5NRtFEtZxws9UsG9yAx4vu7plLtLhADl/F5CbtDDURk6OjGOITyn6ZLEqhChrMNUk2MjMGa4eInc2t+oZ1EliEbujfkhUFon4UjTEBbox5TByRu3BHlYQ+fPa9tZeawPBfjAc6vBpePcswY3kdBuMRpPKFzT99cTPpwANTbjjKG5Avr3/vvQlEG6MvHeDlYBAl7ZQGhDBYhB+r1HBYY28uCbFqnqe+5mIOq9qoyoJ+QIEO9eCipI8NMo0c+9PitjeraH+aOEDyl0a/T/Hl4nLCPCmqSN6evKRdxJCPRoORzPmkuDAiwhDJ4YM39D3ItZ2cmeIg05CPR3Ynv5qwtFDkUXrHogPqfTAtoiS8MzdbFMIN4tpmZWs8lOuuYWyEwKpImERRlbNmQ3BjyqWqjwdr+64lb1Rc/STY8nmSwajNahWrS5rqqZudLYefUHu36Jini3IbX18t14cuaRjhR35vEUB+45L6hS/fY2svlshzz9QVGTsaL7757j3xBDJOnsVOnC86HX/tSbMgqaVckwbyD0KIAuPkEV8uzFXmcHgbuonxq5xgQnvD5tUFGYMI8p5kWOvNOLX4CYl1Lz0eyREr9KiMqqIjhADDfo+c6/G8wL6qGoDYR0UIksBnelpQqVjWJk7Is0WpNXpuFAyTCvGbSkNG4xZyxaIqA+nSJyotRnWn6fw4sfDISE3DR0jU9JFKTU54rt+POCX7KlB9Xtos2Ers4+3VXOX7ydOzcV9yM9LfLI+b99feJxbkrVaKfSKdJ7pzruldrntu8y8racznm1TKGWR00c0lerK7nXwn3TlljMRNV3bDE3ZBuGTpjMIAGAlRp/aEu5e39K0Sqwqr8AeGsgf+wCOzJBhmFwRZJWIx/5JyGMxKphUvmr63jiDxAasvkpTCYi94PgWM8Zs20JBmgY0SxpQCDkmQTCKYDVCrEicxp3i1dtVwEyxVvyu3Bloh1GEoLTZyV2qyUJY8Flyx+pG3k9eOx9+W5ovg2dxYKYfHoqCCURFxTufjiky3OF3sU+5XCbSkneH2t8KihrWs3xLjAk7royWowvSPveMjJ+O6J2VsShMjZaf73Q2HZBB2rDPKGlZRkhwG0tMlrD4ngb3lYxaPgidH303LaVF3hbh6E3fQdyAjBQ6OfVsVmX1PBiWMPAs0atYe7ZR8c4InOGTlD9Po/XiC67iVmnV5XTWteuTEb2dk2dpgi+L3dpN6LivkyHdtsLiFKSySoUWgSrjICMEL0squb6/UzXFRfGFm78Gw56u6tkLET3uX/BsZoB5PjrUwuFG6JVioaLE+rYTKmKQDQvvmhHTYh4pQqKCGtQM3JnVH5CssiJS3Iy7uff7UwgS5sbJOkym2Yx0OBuMYLpNV8BGn6Y51uY9ZfWvWu1EP/x6QtRR712KlLHIDBimGBu8dHaXNi2jDLXvv5IC6E1ad7E4D/Lz3JhCXeIQX42gTm3SViIIDHXVdIh66EBYYYaiDYT1BcYQaJmZMTJhKKMgFNlrULJMJOq9XLhF1aPknUNfMeZP8opSgI/+c+Zij0y5JHpJ50UaZy3lgQ2Z4mgKLPDKYuMQEPJARy7pp0bVx7w57ffB6HHoYegEC8ju6ndyBH4JtHXkrSUZg38EsZ80mMPAGLTdkKeQN1OpZZ29fHsFhgx7VIo01mNjK07iSXQ0z2h3d9CuY4IhFcKhULeaeQB+k1YlkB60O2PRVqsY20FUzc91vC9a93nn77uzw4g+h9gXbq7RyUaY1p71KSVDmA5UVPFxsuRijUeYizOYqyDRSl3IwJo1IlVyO5cWkYm31CM6AT3WfJpi13DsXooNbbr+PD9bIrz/y6DnEMYkVfRYCSjDntb3BKJ7A8sS250kUQinZrozdLUlOSX6PuySJPkoVlmKsUpVECH5USizlsAs7mowBjx3aye926RVXxeSvFAxjfzj2VCnle+v8vT/i+qY1sgY8TKbCTq3gKMDUNL3Ai4aVmApc5mYw0k7KhaXWeEzDuPVscWY9B2g2ynX7pOIH3BkWQxpO+bRGc48LNdCnbG0wvXjtGAUdIcYJC+GfTwU1ZbyeG9CGyDWBMviSCWN4jouYSwJfd92JCEw3bkTErkB2NeDLeh5sY+OH6CaMpQBy2lMT1ikDjeyEQRfYaU8z2D021MynrlFOTmWBGmpc3hEnFZpR56JOXqElzCk3Jw5l9TIbkoRgmEpiKBVs8qnyTWzUFc78mTCeQs8DnCBiR78ffGSAQmBD7INRfqJ9BZ0Qs+hFdXJqDWPhTBVg5sjAGZ0X3L4o3qxZxwEBP7yOImfIDx4X8yjUQbDQuyE57MRikaPgozUefXTDnoiFGAIiRysEp9Uu+FJ1KdoxM2Z2KQXmS/LZ8hwbazV2MG0788pmrfsQWQN62bSEHkey3nizZCIPprAvJvMkpLmY82KlZB7s07IhTCrUsPNYhIFfaOhc8H60sNlGZHF53yi44JrEpSbKNhMLzf2yW0AqFlw+d1SBjIk2kiaKoqKET+jNdOuHUawYFaTwt5uY4JmxX3EXEGt8Ofb7NOyx1Q+C9+ORco68mVDpSHWmYiExHluVs5mtytnMRpsXpThhZaPLjGCytdQnqEwkmQ4b0yFDtr6hmSorNN53t8MEDe6tKxnbMNIgGMGV2AeINgM2NBU9RZwAQ0V8nT6kyiPsLNvCR16XRiDndjAJLnFM0hDJ0SuFW3F08sZM9UwlQh9yuxoYEYjWgA8dtDGQAIOVssWRqyYDpJRMdL5JMWEQE6RJ3JzUXVGqZHfx90/13IRz9cIJ5zZXC07QSyz2u5IrY3TvDofkh4KqgpEU/MXwamH+AIs7EBl6paBKS0EVpV82zVuJaAEOiriOb8k8jk3L1+13x31Yp+eUi9WmXPgNE1fekk54d0FIOtOnV1Cy8+IbMu3Xrsb1ltuyRvZD1foR7oqvxs36dtOGB1WRWslVkDZYqGnCqrFsz7lzaFQ+srnjiJO/bILJQVckJBEq4H2id2d2nTR2PPThhr1mJQEjBmT04VRFZ2ns9TTGeEM4Cj0a4EE6Sb0hXCz2A4Cy6oMHJjo90qXQvxkjmtkYVarn3956kMA3GVGpB/SAlTB6EwwC8MkMxpHC7Nb7KHCAaOv+8Emy487nitBcX6mDkRFa2K/SSbKe9kR0Mb9dQo3L7ACjd20mjDlJinFOZAmuNayIYIlXlWBEX7qwVumcInN2wpetZYNhLkcKYf00YCG7D/5gPCALBlYhGQbLhrORsFq8/4zJk0m6pJLFLrabWQ1iVzUnqjoPuc2EuI7AngaJijyWD7eashOp/r5rNabyJX3huI49i++JRHLXtEVOXOJBUxiB2rQvSDDMqgxhQdlK8edi1TVrvUra/wSpcuczB25srz66QFPICYQ87gi9FAAmk2BxJjLzeDWiMWq4IKQx9tEGCubLl1rIkMmXK8/sJ6yIPM5ZUamGskKNrIQ++/vgNTAe3EA4KdAxd30Q+q1R4EO+oJ94AEn674H8eocskBroDGrWx3vSw5oVh5Pn3kOXzI8aqGSewyu82n3edSMvRx6S+vt2Et+TSoQ2wxCQn2W62CMMQTqaVFts2YCUEJ7GDXUZCGmLiz+NtfUdlFuEWuy7IBAlqI21rR3rmLQeA2CkhCnF9lqjTiQef2nt89ZfrJTTgRFl7t1+FHvkSDvwyCTqSn4GpnelkF/UjpkBJVV1oCBznYsubxhLi7HMB5ZXRGQh5cS1OWygjw7kc+nG4BsQgqJJMJ8bNjWCoRiN9gQYYOoVU+mTpvxWLgow1yB4RqjsURjche4ARJY7KTwM6FuHQEVaYn8Iuu4N6YIkbP0GfKST3rAKpP3xQAy0dwBJWoaN5004FdonzedD8smGg5BPRjMWObYJ6QGh+o2c+m5v02gy8N8Fedcmcklj27Jjf+CBlok1vmZFHhgZiyepl4T8N0LeqtfrpDav/xTAMmdYzPqL1QoCYxZgSOfGzAjNBC9Z7xdnFfM1McbUOzvTCK+AWhXZ4aVOAjFBKJviOTkyBK36BMQFuF6l6teKAHwV69b3+r3pUsRBUjyVzvCK6V7BQL0XUJ1knyfWjyF4ZdtaeJ0+r1QMhxUheEUlbU9lJ0d0rAq3bxXeaFLCuC1w4s8LvvKp51q61AuHi9ooEVJwkwiTsjaPplyIofbQVi+Ermt0qSa3NRjBurDMwpCEH+xh1oJUkQAK8rbcbhhEUXqJPA1bhOSwQw4yohsibfAr5E02ahbRzUoiclfwN4APfBqSz17cdaqzIFKin0hVU6nOQlSY6uPCtMsQPhzBB1ssGrxlBhVHyur1FHBizYC4MYoehtZMgWbBKNPIRZlGYZTZKoE+hS0vsE7IkUaU1wtzBlgGZBH6poPK7HJIghyuKpNwCJsLNOhKFiSDGQBAuoNJbk1eThioYWpIdmeUXBlNatgTeM5nrHQBk66JHStJOCvKPlA6EktwQUKkT4QjgVoc2O+TS6mbSZKZm04MUTDjqnd8hGiVC6AV7Bl8eGxgWc8GlhyfgI3NFYt2Kf0wz8dDvFJw+50kl3qIYJNsP5p9rv5mCe+ci3VTQZ1txVSOm8vJPbbj6g7fHuMnuEBYSJirksxKtI6hab3TjOETObZzFsXCIqnNNksx0cvjz1Fzv+10qoI3+eJnayt3trbmm60vNko0XTHpIdlCQXTXZqr2svyTVOryo8/PR0HT0szPd/zFfvJcnKEZr3ODCT5d/IIvnZhPEMg4x7KoUaIQlfPPNmPUwWl0TxcdbErkwUVAoxSLEAMe78juGI64q3MDYcNGr5SSYJYVU6BX9Cb4rbVjHULKO5RzrT0yxGe8MJyIL5qW1w2iCTkBDlL3LaVO+GHEOkUudhXj8Ih8MYsmwL7UkKbUkMgnK4TaV0NZa+COLPveDXtwQO9h06KR5/UwXyU5H4NxMzP0JOSR8+8oGFZNzQRGWoasq2c0zSj5ca5SeLsiPyF4eKBnV3ogVotyW3FaOpmcculXnCgnU/iiAxLOqTFrrVZAwi8AIUYyYSlt2eqaBknZpZZQ5bYwrDL3moXoAOsb1OnTj53heLADZk01dMlkARC5dYIQFbUb6/5gbKSZKmmt77/3LFabljEPKwPV+Gjk9ZgVkIPfbcVrqk3zfGIYP0GTR751aFCwXSKPOpEH/g12WLGx8v/imrx1u95/QQFQvbqKfrKvrj7+VK3U5LqrWoTGlLU5Tg/FPzWxsZAjmBZ27iBplt2s6m5n4QB8NEZuGPtk4VGvs5sJQUKme7NJ44LhHXOXBe1/6Ln9tY9BSPASdxBpJ2gPI3T1d8G5JSZcmTrzOU0N/ARHyPXsI2SOIm5zvZQaj1zkSVLgzgpZpoJ/CdRSOz4jcIHmfXg3hrRWM+MYr/pxoQxq4fBBgw+y1MZp1+GtLdWTdksHsIRhMfzKxCQhtxZ7zNP9pTESkyZiprybCW1q0gJpAMjiDvofvB7nInMl7fiH541ouOulxaxW46+HWWw6kh8umgxugn5hzDIVFFUR57/tz6+KmA2zWEbaJ8IstePZ/vo/1mSZhmKWQI7lO+/9YU99peCcAkgJHgpe/x9orA5uwwEwVpMWOZl8GS/ROAT7l9zggs+NIYw+OXRSQ9Bcsu+tk/bvYLAdRbCCra47Qg98escotHnY61Cohxjbu2S+Z5ioZ3XJHehey9CkpE3QlstPVzij6UHwAQ6AV88QAvEBqZo+YrFC6NP61bPP16rvDM1NCjUs+PJzK19VtVVYVdXc3i7n/adRCUV1L8I+w/eoqeqr3JILuz/9ugpVKUSssbM8kiOHJll+EnKPpuLT4fDWC5XTDep3UMaJxre3/sPzUeiRP1qA2H7w0QvFs5SDT2xZyEmpHIIPERx2bLB1gtiq6fUETyg+vSgaQwU0sbhQXsw3Pp1JqtkTeZylT6eziFjadKE8z6Q+vXA3TRUvlBcSyBtZLO39YrOxWiFivxSkjIJ0IZDKLFlGkDKfN+YFqTRYiAxSGegE5ytYdFTJQpcdNIqZkKuvbonQlvnOi7v3HXGl4oVuJb+yLsbRz+I5xuj6WW97GHM/623kfvA6MnAMBu6wN6VBSTCZDLY00YECqjSezRTO5CemPJcWoVQz+DIjVJc7nXXSkH9TwSmrUNlwydRPFZJq8ulLi1UgaJ8S/z41uqJlp3drVQ2c2ALbqjt1DDZGDmxwcBK5gDr43iPTEU3vl3fr/+usKxZGjuxj773JxyDsRVNXlblI2daU3ktV71tgk2ch/vj9CucEFyrxvUcVtXqKinNYZEQG6Ltd7z7o97xQW2SPY/m0oDA3rb/O8jEqyqeuoMxSZVtE5nsE/f4k+4LEuKz4NUYiPaPMjNJzzyONDOktpnF5wdGTVUczomBkCTWVgelil/RIu8U1Jr2zxOvXBhqxUH5G65W9Xs8KYog8wdsVQVK8oeeBtQpmkvJGFsS/Cv0uqeHOe0iLGy+g+bD8Fz7893ZYzWu2oclNU5OXFm22/kqbdUiepoEYi+zVhhILu7WNPQjMcCcCjfiIYc1eFHlhnBEdZ5EbttJVhjNcD1jcBd0cwhy44669TRYlwYw7wCch5xPzAuPVSaGGz8kxdOCukWl0N2SpqSw7oYzwLbU7k3y5Dhqd39/sXexQOzaUIkCQjnFYJMJm52jvj/bZjrXf99yhJSYcZoHM7UNukPJcuKF6DhvDczmu0fML8hs+f0c9QCWnMJZbiozkwYEVEwRGLzj4nSWq9c7L03cnB3tnf4BdHk3hhx5d/eAjawcZOlLraBw/Px3H8Odw7VSuaqNzfrF3Qeo6B0whaDQkqwrisFv2ObNsew4fiuTNLGgFt6Ab2mZrfaUgaYSxq57TjZBv2QGFIRp3ae/8os0fi5Bjfptr6739aBesuSJNdh9laFlvPKa1t2Zm2ciJ9NZoFrX2XvoLtNlmmNHAewrZkwnO+ebdc00zo0l3zUo3QM28O30FcSElR4vHna/zecI0VsoqeMbJyo84fDePOmQnnTJzM8vk2KY8akyPPOOUL5rTxp7yCR6Q+cnsPXSjOX/Y7Y97mOMtvucO/DuYbphMesxkixLcxZhMuUsxTIgSHD7z9Ji0yRpDOCEWY7ASWeS3sgZBD5Li2bekvaT3GBLQ7XbHGLgPJD1KrWtBU65yMiupH0qOhTicKOfPmKw3QkQqd3D8bTZYynlTS49nHjU9TZ/aGmpPN/BcMOSF34hysKEduXXCaTLC6LTYPici8yvGh/YTqHdb2QJajptCs+Tbp/YzTttIjQWWQxf1ZTuqPqEp9MC03sHVRQZCOQiSaapjxjFlhNCAjNDAncw0K/QIKEQs34P7IfAx2EX3PVkZAz/WMxBDQGHKYdeqK/lXumQyxfJzyotACS5FMrpVAVMwxColUdY4TYnM60EKZxSM7KpOxmr9aZcHdhXghDL4JW20AUrEDuFfmQQ9AO4h7wyk4SEjTs6lYQefYJg4GpSlamBMW+2OIL+WbWMJ3qWfyDjoOiywoUs6BCZyS6uzajRLfEJM9dtsbXzwpgGQsUAOADWph+sKIJDWMxMCGVwGYAdVQ8unQo6GT2ecPSIUqZJq0QRJhRnyRtkCizm3jiLGUF8jCjmSea1IhNb3U2hEFfg+s72FoaGA0Q8QbscRqOkJcPzmow2b0g5+BFIORYLxLv+1GJGok0PxlF2Jd0ilaOVLfRyGAVr74qCTpqvJkHsPNL6+XcfdgpcBXX2DlCH/sAJPEcQ5L4pzThjnF60yI5D2u047kJnolzBE0dxY9EQTXjiIkDK/0BQQiGWmDZ5t2zIcCS9oyUvC6hqqAroq92ta/NJaz93a14tu7avlUpi3rhjmiktHeJQbdWbzr6zlXVDm+BIdUtm0cT7A3w7eTx54t4aJZaDIVYltrpZGTERiuafcWg/jVYNUyF+YcFPy976DTBRxaNMTH/ciqlG05LCp8+AQrjOAN8MAWNSxfF0vTB21uO6ZSnqXa41rzPCcPqLGA3YqDXKa9AklwbaKspnJ6YtUlw41mmKnb3Ew2EnSpOziHmE6j/QdL23sLpWQ+WFUJ5FF0mwHRPsJwlXNF5Sy2Sor3vD4KbmQoxDlOonWN1YddoTeasgjvDOBj+gs/jWwh/tjmhnwt5QJo0NW7LPOUH8io9iOebUTYaDPx+H26tknBQo/O5+SkfpsGoQ8HDVTgwsuepgOPDIDeiamXl9CV6XpT6CQ38pWyG/lyMwbZcWevWgy7BYCIBNlrozdeDwUYq43j41Capc1KFIJjFpi0P3oqIabOeiWqDu0fzckjb90w7s1eHD9BNtwI8e0o+hdeemupkxi2zTlcFaZMlxQGcXYzLNAogTOtYoGfnRHQbvoiCcxZnpg+obUDtYmZLVoCmEor95eg1IW+bJEEA4S7ehqn8gfkmUD/kdAUcP2n0Aclh2zdJ/I1Bg53+8p4jtuaEamezFLWlqMM0gJhXmfj2+ibuiPYhNvvZCD7tv5fdVbtbxuhaVWDSunviLgI1OXBXaEk68IOHvDSUGcSRjIMENzcimYIh3BVWBJGRF0USX65GUHkrCDVH95XdWsZSZTF2rCZ/o6TRvLF2vyREcoE5IodeVCFVcwqAMj/kfv+b+ggqQS6NDSqs6bL0oPPIkjFC7JAtijFSgL/EgdUxEo4wJcvprK8AXDdHtiomCAmD4P8wT+U0OPOohpKKXjCAYEmKaoWFMtZzw8qOfrJijnn0x3Z/TVL7tWHTMMAre/F75KuxpePXP+HfiM+BKZ7RAe11XxXhwSMltt/COnMaZQEUWadQ0M1dLKLH8h5KAhxWbCjrRI6dCDdi1bglFirk2HD2QI4ShZDFtQF0S4DlnsNaMFDWmDsn/rWOKGd5EBFuAxAAI4WepYAOE0XTmHmLIuae15Nrq84WBQTFg5yXcCjKrIMRwPOgI9gA7/WtUpWZeACjnDP7nmwoDFfg2aAbKeR3hgKnSh9I7x/sUdYOR1pmFeWhhqbZb/6BR0wQSDunhOPTmJxKU5OPFOGVFHllF0FGCrFsR2mRnVWGqXJlO26lXYnNdLvyiE0JtFloVCXpaFIXRrrqVBtrt7N5I2R8oygutE2IJRtxBqmTANa2s8pH4zYokyC8ArufGw2MJK6INzfPoPn15A8bUkP13czVgvGLi+dCkmPJlh3Zj6oiyc1tP6Fs91/7RieaRyJ1ISCKN3roUNN71b3KRaBBB/m1BLP6GcOOhA9ua8iSXSLGyjlwN2iDPN8IbNuQsyMBEE48iIxDLftOMCAOslTUcGmz182zG4aCkZsHjQc7zGhy81lQLMXhIK+MKu21Q6DEPC6TDltZaoKwlEmNCljzTqxCUnIU6eaLSgakvI4ItGwZV/CRV/oFFSo6CEjn7V+X1QesIfaJTpbUZCmz7SqEWLy4RefKjz5yeYlD08Wdq8nA35OLK9sfqykjkVp+ld7ha39Vfb4urqjNoQZ1RdmlEbf40tTp00iSlz3sySiHI3ua2Nr+k3NefexnuXnUTFlDiFZkxJjy1FE6eoSVMK5jMpnB8lJwkLbtyqAJOdncplPqVYd88KyMm737fcD67fd2/6XlJTvjWA8EXRRyvW/9JXhVT0Jr0IJ5YcVg50zUHY80IruBXCEQvSCYgLYqBiHhFDnNiP7Mm5ke0llIM9681V9DcriD3J8EMYXn9475E+uErg75kKLZWmbU40yuofU7ll4IAQK4eG24HQ3zmZ524mGORPsCUUqrLse//u3otiYcnokXBEm0GpVbIE+b31xh32CFyART3NIYnZ7mgEHofmUIHW00/K/TyGSuZ2+GiMhxFo7IpTqeqm9HC5LpQgDSOd7LzcO2939o/2zs87x3tv3x6evD7PVi7aGSUuBcbXNevFCz0+hX31jEVVpIYD30Kqfm1MMdsBzlKmdIiimQUa5Y854CS18uN5LI2IQchgXQq15sGFxPQ+DxsIpQINemanDIho75+e7V2cnhVCB41YBYZ67gX599Y+ZCyhPodun0Zh9iL9Fp0NYg1lF3MzIdTOILIzjJgpg+UNkdP6q4CQGjK+GHXpgMeUR6mmnaLmAB7CDcL7EVHlA8RODgzAg0mzEQ4ys75F90EYS4nhZDSBJUU+o4MEEKFjs5xnl7Lg1aQM9cqk4DiIBz0yhUkx6voXSeHsRbakdjy4HLw7OWhnAhYDKxPlpcDtOq9BNENVmpNYAnH6smbZ6cGqmrTt7Vn71eE/O0uLPM3Nvwry8AN6cfQRS5QOgXjnGArp+ZJmwx00PuZMLBvtkvlyqRpTuwVxWqk5Io5ygjAt0CTEDweaRA2TCzMHbuziaU1f0aRp7nBiP6DJnswdFjs+v6yQQYM8lTWr4g8h4D98ognhLPhIs7+hk0hFc+BIu5emq4Qebm1ktPbNxcXbuVsaev8Zk8MrtCpc3rwWjRflgaFklen5uw2vcoGltUIKZCklt5SIW1UYq+m1jRpiVTv844/vP6L18DBPccuACaUfn2ZhS5JOBknzEmWuBEzQrA5Y6RIYSWUw+z0KYrLPEzyrUaRE0QevbYfC4u4Y4qPYeOObViMEQqQuILWkk4+gLdGuf5rZ1z/Nor4HqxXxi34TbBt1Sxn1+XJZyaj9UFZj80kDfeXFYizb9WH+BDJZxmS9XwWrmBmm2VewiFkCe5THtjJhXi5CK8hX3QYotUBOTYHSZ0VtV+CJQPt5eW1Zmitpy5KFHXvnF2/xmdGIPn2VswW1nObGI0PGsm9LuuHmRo7lZmG7lhclmVv56YUMNEuZW2iWnUhKLKQlE2JxwdnljrhJqyG7k90kUsN6Ly1ANss5hfFV3vxNCBYWptc1n6Vd81n6/4y9cLLgaUwdevTcQamzrzR5Nd0cDk0SBYkyoA72zAcYrJeyouSLSyVzWZjz4BhVWHOl/GFeS+eTYew+tMMwCM16tCzLKJ7FhCbRgNP/fRCQMUnzBZDhJIv0bqLkLdIyBBmzA0l6OFru77Tc8d4/O2ft/Xdn54e/tTsH7bcXb9RAC8hez5YgVrHwnXJBCR8xH2kZN0rp187dLjXKZfRpnGnPlGd6VtogMgXnyRVUNCuQmv2nXjWu7C/OAyRWD3H+k++s7FSf/sfO8GPIV/2QTrZvOX6eEhWKZffJpV5YBuqvhQ4F0/pQZYloaV3NSd3DmGKqZIiqBomT+2tssyaMdalEyYfD0+TYGOGMLDr2XV172qGg86FGxauQtxkNE7LirXY+UBEFOkU/5NHREMcC2ymxSkyh8aGBxYLjM5P0Xbmh6TzEgWL+5VIbq1P6yqU/x30CyJkvZUSrXg7I+YLMI4/oYLLsep9WrkdBaz5vpq2NFZ9ERnWP6d1Kq3mWBNm/6YGeZk6XMpHOPHN92UUFerShX6tFck98T2U4buhJY9BR4c6N2FIzJOUQj2A0PjcZsIxgsLLdBjt12Urqj5o5AH9egFna5M60UeXWJ7xmbC5iUjZrZLW0qXMaZdsyHyVvzqNmrHgKlFEzVchAMyVNBTPvlGBkB5b76bA/seJgtNb3Pnj9xDYrMi+GwouLB9DCxFqZS2oKYC1tloxWKRdc2ZPFzL/0jJli5PVXJFeMcRF+W2h/gYWWqZYEXTWZ0gWVmBL1wsyUv7YSM+mV8ZpDU1gecnJVYdnzvBFVVBJx8kPg96L0xsPq+wM/Nvg9qFccuJLmuuVIDqSZ1xx56Wooj5mODOaTQu4R4YtOBnu9HpXySQXzHAxCD255vR4NinnzBGrMZrYas1k2B6wZQAd/tkKAk1CW5saELpWsFFfSlQnesIo2HZnR2122EgwuDMKdochKyeEKP8RuchJV7ETBxHb3inqqJLFyxJA9tCTN7VDTUkGgWe2uHPa9kiaDqLAjMP1WramRaGE4do1Wt6mB7S6FI1NCW6WMaGQrlBIfG8sldrFiVXLsaqHEU6RnX8/OMZN3Vm+UHFu4YFoIXkTiXIR5sUIIk4jmKcjMDSuc13Oq3HpcgOF5XWl0BhRmWHps3oxVRx9qti/Qs/QdJlrBbl8oIMYYV0otHnM2VczZFDFnU8KczZIm1MvDnAKp9LJJc/Fmmf3IpmfRmy+B3sxJ8xJlv5wjLzcrJyHNT4BnTH43PTFnwjc3F53OHFJnp6vb5YVpNBBCXv2sKVYyq953+/1qkUSADuDpnHkAsSwZjyfIBNDIvr9v/EXRRp4gUxFHJ1/YLX/sRTFLbMNxR3zEoGcvglAIC/ctNC0WLXl2shCzUue99mIaRSvhREPXYPg90irSHWfghu8dlhMr9P/0TMmvaO5KRCLgJABVdxwynQy+xcDdqkJHvIuk5FOAJElkCSuSFTHl900r50RK/cpFqFi5CRaM9UrAyMTAilOhGfgShQsWrVa/pc/7CpAhHm2nAoZKXA4hRTrdLzi7eOnTh2dKJ0BV1Vc/Fn4C3ep8wQa2S7zSczJjmslW3klFOEKbTh9fLfklywtJRQKMUGMMJOf2u+M+BIhKM1Le3kZeLB6B6IsOfaHlmrTW0geGPJUyAs2UeFJLOrkDhYH0c378zgsyZmTIhkGMV+UaxiGX5HVWusvLq2c0isE18wnkCc3k4ssbQ7hV5mPItHx/ObSlwBxzpr+pObrZDhnLK8QcCi8z0Z/uOVsk9Z+YXJAQQWw6SlapciWr2ITU2zY32fazJ0oS+FeO611UD5mblzaTshTL0ZSRdupiTAphTMZUBgCLARDvsy45pmSuXdozbrPMZ1wyKzpRMA670/cjhbYUC0Do0yxLAEOy0mIYrTUrKKsQ+CQz+3KxIA9k4oeJOozeuRERtqHd2ml54uUrO8oGfKSN7alcXQ2ZCipt+iUW2iF8rrWQEk+ZVHpR7tUl8XXEjx36XFy76vNc897WSgRySYK4sG7ZxaO45AcxHRkiu0hrOfFpUxCRGwiyCT8Sguck4VeWNu6ofMDaXo0F4A9GEF9eTqt+iA/F2Z8++Vpm7UW2K0NnlOlff0yH3+1cleD2fPFHV8XGO2ciOZ3OKIhig99v1vulEoJmm1Wp16/QJy3SG6SJAEkAM8JYfoRJAU0hmCjBbDHd5o1LuAhX3q2Vn61t/kyfqNKrb0D4DQjnnVoOe5szxUSSXC/O+td04pwPGxl5buxAOhzZdyS05ogqS5Izoy5qUnEzip7AArqebQFdHD9XeZZTaT4HRjMJFnaaKh2WNnIPJ42ih5N6yWeZCVGnEi6xd/xTAiuH0t3MQKXnsQs/eY+T7rAP1kMt+QRubxP5gheTJVJPN+fWH/bAsdEOK/+PFrm6in6yr67Of6rav+7AFzdKH1V/rSQdqEH543dHF4dHhydt9WKYNYmbh9Du2fotEc1fu4ttcu7CYDyyG6qNO96V9303ksiaiTJdpq5mJEN6BVtSMlK4QT3wYZrUrD+LDRKUS8cDPgnD5vz0Kxu1H3/4L/z7fZWPl45Ao3H89R2XW+UBoP91P7jn3dAfxTlbXS7Rt+3ukXVx9b/AbDNteYWIv217Bbe99vmmvuNRQK9MKgVgXLnGqQgI/usOAfaPfO/7sQb/VH+t/orfP9mX/+/zNaD+5+qv8IZtBj9eXl1Vrp5dk9f0w09V9qSi7GRsEAQXUD3mKFhndVi3di15Y9S95XqddMDk3VGJXYz7rELUyvf8T5RcmnWWVLPJl4QXhQ/LG7ajWS48mrLvfdvxvu14i51hWXvdt13uS3e5guc0mNF+Fz6SLerSXftzb+3/1tdedJxrtoU5V1dk//q58Kkt6lCWpGE3QdC35e2nyJ6ibjyzHgTxT+YB8OoZ6/Iz6gjBm5thnJgbHJ+1bGm3JzUIwyqDx+sgZ3Myvvy2NX3bmuaeXaaNKZfo27ZUVOdI+gPuqEiYHL+unt0OYhF8i+1fV8/gyATnpatnX6ZYNKoRszSBr+G9p6tNbctxHKtaqBdJJ368urJt58dfyamwqvTh4PRi7+hI7cANWX7vp5zsoGIwR4R6kZ5myrLRZNHki4fEu/jHAXvjkb202xpmniwJ8JyRXuRsbBmvv21t37a2L5hhps1tCtm37e1LT11ksuKJSzhk7XwCZaBwtlr4VrUiB5XN8iy3/fN7NxzlQHomwTdQ/wbqXzTLTLA+lfAbsH+xOm0cQWZ7evmTp08DWf/nJzulfIP+p5e0bia5srzx9TfY/wb7XzDDzLJ8Ltk3yP9CyL8iE+g/Yz/08Oq+cnVFr+7ph5+q7MnVs8eT6wu0rRN6fUwf8ASNrMFFCq9v9yIceyu9J70okVHtm7d5dtvGt992pG870vzzy2ixnUv1bT96BN0SQfera90E+yOYYM+scfp6Vtd5Gx3pmz/s9sc9779sz4PudoJh16PWdV9laxb3uOW1DCiR4RoEJlFfiOCT9f4rbXNTIz3MhjmAN6Ye2n13eDcmQ5rijgLBUsgHiFEc33sWmfZhMAp9iBbILjUTlrgYXYszltzxEiIa/5SA2OHx29Ozi077nxdne/sXp2fnEM0oaZXTDz5CXAi2hPxblcOOtqIUAiWmhNEpyK7Cbe0BNYm1bt1+/8btvn9sT4r5PLnkS80Xq7wik4RnqZzPF6PhVe7231qd3V/Y+Xn3pMgrNUtfkgZRID8Ei2dykzX5x6ardjcfH+Rl5KkC2iPGZ1nQwlkxD6QP/p/PR/eTyO9GHW94B/YWKEjTR218IsnO6ouF7VtfFETD2A15dTTq6yvnQbtZhunjdAwxWbIpni74+lHyky5kSqUxWTLCsbBEmuSlT36BPz0UcVgVFqtCS5QJ4VnIDAj6HzwOnvyrXX38WTynTZQsPZRhEsdB599Rh2w/t/5d9kRWqRY3mXvBwPUlSUJ4wib0K9wrJ4udzmKX6JQGUSENMr43nOjxM9Lvr70hxty2UqfBNZg1RAK66afTn/Ifhyw2sBBA+8wYDxjqJ5RkZtCY5ZxP5MWQjSXC0wH5f9dbuwvd0b3V929CQp3dUCZyfFJcyJ4hkwgigX8yJGwlc8wN77yM15TEG7qkqz2gAWV0LYuODCf5ZeJ7IJTWPR7/3RCTGVw9Y111aMMc2gAnLVyz1hrNejWzmp5P8yIcuw8z1rS0+Q3W5W1zexW2zXSkRdDZS57qspfpXY74tf50+Ruz+iPjy+bGYwpgehrizZw8xJulEsGKzSWjIJZLtEyy2Izza6o0li9ZKXQdqKWDne103e49OTTjDuiD4Qyk2YCcEZ/VQsH7fve+Q7Y6mNqEIvQcmHOEFSiM/x++RnN7sMap/gDQTUgOX5+cnrX3987bSyvftVZOviu4QiAe7qRDRB6IvxzlrhOdNHe1bD3ezdG7mA76gleO3EFbntyCdIGvd9TcMyAWXgtUuIDYr+0XoKdrbYAJqwgBWT1Xz2LfC7nIZsp3gzxyZFEYv4mVDgeRbd97wwg0WW6/TzsiyZ574Z0qeLLenrkf8aPVc2OX6r1csjCJvBQpri9qv19B+js+7VlxkFXJ4zXIItWjXQcjPiXWQjogfCis/5KPSEo/AhPo8DTp+QQ6QQVnt9cjVX7wo7Hbt0Db7oWEd2TZWF/NWrB6WtulN7I36Y0cAJJ9STdLiEBe764oAiWkuQi0vroIhB1kF9j42QwfxTFhChJgHYbMvDSYCY4hASS6yQ+DcIDqHPrcNoTXNZ+ukNyBqngSKxAArp5938L/pAy4Vb0VwcjtkjHn7TDWoRxl0xrXBoh1jIeWYDyn1awIcoH21p2m3E75thzIMPcW/mpKxgPyDLMJkT7gMMCVHDku88d0OEh/HxuDWtkY1Mq5td4qKwZ1YHeh0zn/qCDT5aJPa4nPoslZIe0PAxvoUsfvpVdkWRl1KSbQ/TsYYjkLuFn2Rf35ReP5RfP5RaualWqEV2NMyFEEZgpBDdTijIfvh8HHIYOaTfxPS7YtLWPIXkfb52AykQjkBsJ0n5xSSIeqT9HquL4GPy5t9X3Ut5t1Mt236/9TszY2/qdq6oCUDdTYgb2z/TcZHXgCTVczRzuRo1nfXKlA6LOADv5Gt+7AJ3t+Aewxki9OAPpqGKT1S4Qi+pxd4IvghOcjMpdnxCjG0LLJgD0/2Lt4fnr2+nn7n23y/wsdrRjxrmWLZZn9XNUZkx5LqhOGbowOEoqagS7hmyxTjA5w9QxW52X9OuWstoWOUIQZOxVhh/QoUW9rOFQIddZoHQ5yQris129bt7ekUap2/eoZGbwFVYecoLqVEHvKhECw1otAj0yXizmbqwA5aX+kPOHyIWoWaEHNCGYZtOkt5XMh0dRzL+7q2ILULEUaPQdQvUZVJum89/DIE4c2fE1AB7AGWbDIWe9O/nFy+vuJrAxJ+2lEjIPT473Dk+xVPIfwAjU6nC9CyO3tzXa9rgssGqDsvX17dLi/d3F4+ghNkpgL0PbYkLOeDTnrOdqe9dJCTnqvkA85Mt3T3cs8GuakHWKYgw/83sOOhZcqcRC7faSK8Mks8AOlSJme92ChN7R1F/R7HpF4INaT6QzG67b+btWzsiImZyXlbJSU9YdZd0U5BySV9pKzuxarwYbnanpwvNeYMAHUsKwbrS1nQ7zKcmNmYVGYV1oEGG7VBW59/+4+HnpoXl2MWVICeG3Ul9acoFHeQxb0eByTNpI9JB9xVMrV1+6IPZom6Nz2AzfWsGafcqDyDbBJMYdaNKMu2SaTjMwxXcYB4vzFAjypxgNocQ074pqLum6/MAsk1nW0A/cBh6AomwHYCcHvKLVkQNbdTFz8IW3KhnKMg6GSBT+2RoFceJqua+QjujuxduDw/sSH3/qRjpZUnVm3s1gZZz7Fzopltp0Bc6hhBdmNQ4P5ZDHqxWXB84e3oUuW+rhL9jUJhgxvpvpIfQEaaf0sbFtJBZ6QHLCwOMg3I9KAgUdgMzN/u3bY6fkDj8wtMr+mGAHSWhyRvma19PMKLNUz4DCm0kIRplBmLRQK1axtnbM7jP098NwsxhTI11xKX0OLSwEqPi+t0LG5Wh5XMwIAeLqBp+qwVxQEjCUW5m2yVDigdXUmLEhLo4r1ph9QJyzRnrogKODoLVTbkDYu0TPAfwX0H3BVk212LdhU54kfwMNJaBka1Ix23KSNcSF2jJJMqo163cwsGoWeW6xxnLRmrZNxqS7txVPjRanx6Z4cTfF4WhSeTAXKiU5qT2cCJ0LrUXdRwKb7AGxtE4ZUb1NcZqHMhFW/CIRKWuOk7JmmttsthFTYq0dqE+PNoLPbxdunaQ0iv9Nw4QO1vMjULDUy3faDj2j2WRSZTAXKiUxqT2dCJigMgWM8yz52w/fBB6t77/rDKrOF9f+kilLuUFYYpJK1u79AYQoaizZ7KTSsMWGNYdV2MawCVcnxuB/7o74vgNa0WqHY2kAoB4opw1ENbPd+93vx/TnVPRVkjyaJH6HcWqK0ajp1nT856MY+WbSSYLi8yLReamRyh/4AF0lRZDIVKKlqR+3qTNCUFJaPcWhQy/yNn78lK2FiHcPqKYxMYy/zPBWNvKmnqaRZDuHksBKg0iUHl23zQajnDkZ4jT8D46QMsH7x4sWGmXUYxG4BTZPMOy0EzLcVuPysS1L3YTBwM0etQPcWD06tXH1Tq7CPfqv8YhM5W5P9O5pJctLLlFh4kjs7u/zEyhtwSpSpZJHK5N2PXhebNA9rwtT2BjceaULQ9dxhzRr13Wjg1iAAX+g/kO/jfuTVLHccBqErrGR0a4rvPT9kdgFw8kw05IJAl+knxhuwa10SkQYaQcUsbAj9SBtDP9MGsefQKPqRNgzi+wlObTBMzFdUdpSgdYIRAatdsRogT2/9B1L0lglOjMz5RD98ViMY0rou6dtr3d4pkVaXVnxqlRuhkiYVVYjr9CUVnpSezgZLknul4OE1n0acsOt3EjepnSKeUbzyNSjLBCTDUekjRMWekzOUpZxbpjNSrzdd5sKbec7QScrAua6p84Tbfu8Bc33PwlYsVrM2db7/GcNtXcZJcWmv6rZLjUvof4f+gUWRyViinFKT1tWZwAm9IWX9Emqg8rEJ7Fo6qB3JN7bR3DuxTGJJdBIMPdk5Q2DsR/heze1YsGZc9ejCicQII5rdjQleQ8lgwCih8FU/j3dFRgQkbaDSZjhpdahYW+/11kHnLrJaWoFpY6v8wMRsZWcAJrVESYUmra+zIxP6YtMz03zSUuLHvvNlju+6HoacD6PibBm5tIKN12QxOZ3OwjcpwX0mbl/0TKzJGp+BLaWW3UM0lizGbmGuSys9lduQYEivo2YAKWOJkoKU1teZQGpIZSUNn1CBgt72oOpBi8gBaeRM13Yxuw4zyiDg6l5o4RV0VjcqtMEdfYZKGmtu2L1PKwHv5q0NqKOeXUf7nxczVNFc87qB0I3tOriATKni4PB8//S39ln7IL+m4dICVNk144LLUUG9uKlESRFK6+vs2qcvkaAIezLh76ZphEQPraQErFPq6bbGXMBMttR30+/lM13Jcu7HivHj9Ow0qpsnCO5mO/O6qGlcBb+zneKuat/UT0/vnqYc7fM91AzEJXCMNWk3ahbpw9jbAeBBKCJ/Dc5pQzKjYyt4f7T/hplWQkCz6Oz1S2v//By8Z5PQ2NRXwgOYorG4ceJkxSfyI3LoQec2GxuCMU8zAv8ggaj7oQmzdk0xUR18R3kCkPkju6rHD0GigpVhrpReUht+pXXaSrosrRpatGA9ZBO4q1k3Ncvtj+5dUh8tLRB0biYxeKUR2LDRAJ404MEma2XgD22yusNq1frRam5siE2569w8QmaTen7U13phwai0PmriRMkHHYUwVwqaJfiHaw646M6atutLoEdcLRnZAk9HGHa/f3kxJjPkEt1ka5bhjyHo4ltgn8ATMqYHNuYQDzjVvXeHQ68fWaP+OKKLKwuUeNuMCxbEC8VR/+rZ86tncMFuLgimhRFbzzAS4JTKUxnxeETPuWZbTipIESAtyaFMDEIWeab60jrMPNVusDCVGEqaNoocWi+t2vVP0DJkacbRvje0aeGq9XerlTdoTyD3zBkGpFFy+Bl5IbShQ84ewzGYnRSBImOhXDmovgpiUEbn6CQ24BEFnR1lqZCVgn/5ouCJ/jQwoWxzVoVATzkSAYoHEvwfPYhgHE52dO0I44htpT253FlrXFet52Tk605diY/60CWzzvoNZI92GAZhNke5jXrlKL+A8VBas4hOUyoyViJKRrz9MDr0wS8wz2gwJnzwBKBSzwaVeo6NdqvkoFIcScoHH98w4wswQ694PshY3qXfLPnSR+1dkZWfEJZl4WOHvvq6l9mG3qjvop6RzFuqrZUctgqtQOt/rNamtOrLsBK3S7sQqborDjoRWTD5S1EjLYEyU+qTfbTDVQT7yac37BOu0EylwvUUbSfKmKm2066vNfTwW/ed0AXV4MCN7x3y0XeHkf1GWIFw4t63fqQE3SCysYRAcCMSRP4wIRCi4nUIzZH1E9jmvthstbbIf+ukiIuPmo2N7Xpra2OrRR7dCDpSWmqNkDTqGxubjdb6xjaWgkf1zdb2xnpjq7ktl4rSUvXtF+vbhGRrg5VqOM0XjfXtjY317TotJbSRFCPt/PFHqyU0AUZGfYix/fhDUbnZ9wHY1p361ubWemNzs9kglfRJvS2nVd/aajQ2XjRa1vJe8ZY3wh/5ZciTYpCj066+ACD3yWYKRRFl1Nh+ZFtnVNbfd9GdsdVo1bfN+2ij6bxokrnOSmjnYTJKG7AGecWwduwGEdabznq1StfqxsbS7sSrdxoG/SmZVFLq3n32TM+hqb/J0eC3nMZTzni9J2p+3taTZjBvrOckB1wvVQLN6ZPImDwzh2SZUmfONrG+MHPmsuasbKxczsoCkxKGfuTChZnBlqsI7TJbcc03bbVuzmTAhSXBRYfNCuo8HES+Ho6hsE3XwItDv5sdyw5rM1ll8QGAVNzYI4excpIieSHteLNnYZyWAf1EHIzWQjCeyjL2vPW9fi+apQJeomZdZuZLB8ccOSoo9QBYw4Gn30PPJRIW/ZG0/HWiR4K7vIeQFQwPUxCTbsZxTLpRDJR04nKiktzP2WJ8YlGD1Tvkjx24owhxijqzFXbWYUUzcWnv6Cjj3ZQYnMLqZ312eGUOYer8QM2pcsArcb6OqVW+rFfNiteSJH463F98w5HtHE1nmahUwsWj0nouKq0Xti5tlhaVor7f88KCqKQTlxOV5H7OFtwTi5pQCUKFx5MafOl6YFUFwYkThc4M/oTIJxOh+u6N189dxqx3DuPksBIgQRy0L/YOj7IkG8xXMANjlt+gkcENcijMwo3nXMiILxx7o5n40QI0/YI5UBc4Yi6vxftWaTEJx9jFELkFgSmjRDnRydDZmSBKKG/dePfuB39u15wkzK85gN598PFoKhyJ3aGxfR0ouJbAUvZpDujewllqrgpGtGReBUlk0VkrEArm8e95ZIa9Ibh0HM1aw/JminpRXmGJ/FI3blhQWNKISyosSf2cTViiRVXdUuT/Cf7K80FSEc0Rq3eaygg9f/vkoDPlXMTZCdRZDFksmALMkqgxzfX6t2QtX3XZ8/NusXVvoF7iuE/zr3uln+nCP/Kj+FJe/eblzzhYsJ+RLgJnuF6BTQ6PTEqITAUAEjXPbvZiSvU5NevyuprnxMdJa1aftD/Dke9SSkGZuCX2doydhmCZ13JISz/2BuBvw2tTqtGbBQVqVo8wrhrMVqGr/nCs6IG4dyGUQgYsXRw+h4TopCGfPqsuO0n6ct+LqEVQ994ZBSMIGCy+Y57KS5oyrrwoRNVnBUFIJy6n8CH3cybhg8VZsigLg8aGSye8dTPFTcmX51mzHUaJ4KTJCuiZXIgNozSzSddtAU7iIjcxg3uoYpwYpYnN99aJ99EKurF77/XIYrKSRHrsx4jyM/MZD5tLKxe1ynmlJTjl4/LPMQHRKZfIjHdOQxC5T+aIBIlxPQGia9m4jnqEmSNMml3L4ES0C3b7NDRANTHJH49GRpN8KFGEM6aFxC1fA7KL9vkFva+BT4cn0p3NZw0IGSeUNqD2GrahumBJYUG2Ly9KaNUnLjWQYostSk65PHauX7wmoUvimoxwUdZSiT3cxWA7yXFFX6GmGB/TDweZRwOoIOc8wFqpnQboeyNMZMv/2HreUUMpeInppTkNHhKU84DBPV8oCziEhbJhSBhHKFS49enQYSSiYc+GJ1UNbVK65fWmWy8jyEQuHNLJKqPCWocJ0lEO2uQVyT2YrM8iC+yZ44XszRMvZD4IyuqnLVuKCvIwE3h3lBOLQOF+cP0+GGegpEEoE7EiAZZrFhbDWIqL9AULwnruxjvWTRCAT8wrF5J34Nv8g5UOmaxrZu0F9+Pj8r4s6USd0P0IvvnsMEH1F+IxRxhB1j9jEeU8o9aT/EBJdCRlD0kaU9Peo2wjNUPDoWCBCNTKRqBWNgJtybfEWyU5fMRB598FNCEqWY6E03Saj6wCuSAjE5E9f0DjCSwQdcRuZiPNiuCIqmRpP0CMZ4vO79hLtDE8cRBIUf9LWnneJXIIRkCKxoORllTp4p5IUfC/4b8xDSzcggeQEsl6c3F8ZBFRZtQnyzMnAxIDFo4UBu1TNZO4wL4glFLUJcoPt6t8rz1GeCLtkLWdfcjaLuxTuF0idSwzmEyuQaYoZE3kC7sW+vqCj6mLyo2QcsRKFbGw0VrBrcXKJ9dCzMAXBlXXvTJbVHE1KrbE+olBsa4Hxggf8KHG8YQcxridKxUhxDukT5+rDhx7IsNBh5ZnhRJzWnYRnFJfP7Y6pJm9Upt/xdtbPi3RErzgKk1oS7pEsX/zrk9Mz/O1F+fl1TPsxNWz628rcllWJMZjSfwecUFewKMz9kRcfdqLXKfj9UdbalOVkVqn1MW28bQeyJs56u7Noh7IW2WYTkb/42yKXP32+tO6H880qYzexzUW+LTT80PhSPbWje/5aayac6w6hAMJKjLwEETDMiXtEU9Oe+GdqpgWa4YKIcgMC8NKnpHzVRBOHOuA61YgBE333hu4adej5zknLR4bDmvI0H5/b73yhz1s+ygM4ExnhUEQWzcT6y6Au7LxyLoNgwGhIAxgZJVUsOMwhGC7u9gBu0OTHHSq/E5b3U5YJR2sZJcXd0Zu5p+sIYPA2CKz52DIjMNz9Qy/kEFin2ghGJqUWcHNal54aWWjS46aqbl6nuTTwaUfuL0O/QlyAEahWqKb7fkwRugPwxkoAp1Po8aBQlfDliNSkKMArjzX+t/z0xMs7hiUKd7ITXMoCsvjeVKhhAi8hENmXxQTca9QpEhMfB2MvKHNy6OjNBjBuaSZO2ZfRSaS/jsKhg6Mh31bNYaUtJECenngdYk0irHmatbhKX6oZseZ/KRfnn/6/NgWdYtITbZVipXN3kHKhfucpa2SLc8F+XxLW+yPJEPs4IqGYOnxfbrKTQk1xCz1yIys8l4Qrw2DmBrO4aImx7REqIiQtyRRvHGHPTKLrZuA0FKBgUerA/N/6k9sfQzh+rfH3hQTSXYs/AmxSpCHwgkKHx6mBVNCzUNXD7Sm9/33nmXOxyi24AwXrdqIC9JpNsis3WBqC9ILvx67hTWQPag8AD4CHY+w70ghMVPBhUkHQ9miAMP0+0PKymRevHhl8Wbubflm0dvy5lb5oCZ18M3GGZlmcQLEbOfgdzEd44VCjpBKiuJNgjA1bn+Lljn8wDIddkAh5Q7FJPb06ELz5UwBibkWvcggaTM723A7vlvKR1jhRaBCaLmFHuK0zsy+k8GHOvlVtQbnTkcIEEjRgY64rm1jrEjD+acIW49YhSHqWWsewbYmP/VOs3DqHSVW9WYZ8IKrdrPRQqQoFVYkNuSLRIr0unhxMJEVd2q1oCK5RFhaoGhMsfRt/JWBgsjXgxyZInldKojAXi0WH5DlwmWImzsnGoe3bnflYAHHY4kxYUGBL0uICGShBuM4GxLS96XCBNqtxYIC5blAVIhGbpeMjdNaNTigI7G8eLCgAG9lxIPObR8yyg6nX2HohCt/iyF3yazsDL1b/wHRgqwATDyT2MLQpBuII2jemoMYr2hN1tCLwKw0TvSPoHnkpjN2N4rWPrjhGrVmoR58Vgy1yJrN8/f+KLLee5OIVOyGMdxk4h3GD5ZNDhwuGKNVhatTlvIjAiUsXrT23Ojeo+ETIL8xqdMHuxduqDOfElW9CqUDt880kYhU9OF0mDriI2IYiQJApfpPkZGqccwcsvZTe6DFY00rF2tahf2BW+VTc955Qy8kQ9kh87zD51wO5GTTLw55esHA9SWxRHjC0OeVi7YKiwUfc+cYBvnDbn/c8/KM6BGGyINcMYVWgWu8S6ZSMACjghGBAojeQQ0f6GKYsuST9vCFSQEs8iicsNcOa24EvsB4RKDxIql4QD+nuke4sjDeq0omIZdGTteW/e5w7TYgneJoGlWd6biSJnOneLlDrUHIknuPOiDyw2NMKXWsJNbtBxeWrEVaMhqryZApRy32wNoaTsi1m7u1GzciA0lzRW8vbTyC9TJagoGJqbjc8qBHp8y18q1/JSvfObFH7p0o+XTiychjpyP5pnca2MR4navJE7gDuwwx8MqyiHzBmlEIR0yHrIukujydSxG8SDpDZBePiDJdj3Mkb2xhYTO+VbFB6ijBqOOgsNvbNLWhQ/u1RgRM4WlHeKplVeTekbwlnzj3z9XHiHTSyL3AbcyZPPRFaZCFKsVQhM4HFoWwXLgidK6I64AMIPwklDivMc2rfi7JPzcIpZhwAts6wBOP54QUOdal+B6MLC6pioOVo927BsvSA5GTdeuHUSyfOnCd+0NLVJkimAzjyIHDm2adxgMhkIIOHux4zuMf0BRt2KM8v+OqGKlRBjsy2okkQAIpq6MHpXmCc1A9+xyUhxaNkqKF9Nvl44VGWi7EkLqXYkYxcUNaz3TlFNOC6gUtewyRJPsTTPERvoc9N0/ZgMvHsBCXdufdKuFSSnV4wpVUES2mQl4eXabQsafUaAo3pDPqNTnH0yFZet5DDCHMwXEfxOrQA3/7xGI8vnfh8iOcWDde/NHz+PZVWGWJrWSbsNDa1VVgpjLE8qoyGyVWZdLl1o2KqDEl2jKpMJOOccBJzgDFtQf5qkpUIUQjr+vf+t1EeM9f80IjTmB7p+cChlQ23+NRscBzMNBcDmto9eRGMZpUz6pTRP5rSVtNusQ8l7ak1dZuETFfPYeMIUgj6iAZZNpuP/Tc3iT5tXpVY4wl2pKstmDQJvNRZucxIossKqpqs5RaTLbsiKxKf4uoIADpBRbn7fr1UUju3ePdpCAY9ftcRZDqF0Czn6gLqZdKLAockR5riDdeBJWGI91LIKjw04oNoFUV2d5IEkXTsS7h9ncNKXYTaLsWmeEzxgOi6od+T+TRUnkomCjxkt6J3J7wPukJ4Ge+uGqtsl6i/Dvie74WXK0Q8RKnuphbjaF0s3CUeU2nMfAMYeZpRDL4hiHJ0lhmJnUHuNvBGSy90hRqXUu1qzsmhalIqRmepXQiGf5aZJXuB4NBAKe4oef1yKmNPqfB184tG3xm2LOa1XWHH9zIurmrWV7cdQoIWjCOgohlGKT/Pc8Rrr632vRsCVHijM2kgQCSc6wwEoxiF11yJZasS08AQfOlutgsR4AYWGChIT6M+nxx+Su+mmqU4wkntxFEJFhlC0Oc4VwfGpF29j0IuiQH67B4wNUEL/RFJtWRFNDruusHN24/8RQOOzKpf2t4ZQjQYSDaldvALzvZEUUvsPBAOouyFK2v3qpzIxC/nhOByvl3tLMTB2R/8byhuNrEZwtzc1+sdbjUC3mZIRTyVXY7HtLtlPfJfqhZk6pouWNO3PKwY9kP1k9k/xr8k2x9mIDNem41q9aP1p8B2UF+Sp8pITonpOiEFv2DFL33UA6Xy6YPhRwKP9PPn5c2hPnGyhlGK7OdxlR9HbojKdSD8jh3d9n8SpvLzDNe6BTmM6tZA3/4m9uv8Zia515c41FmkxXx/Lm1d3RkHexd7Fmvzk6PrYNjModZZKUumW5wAh75I6/v87whEGU3hqPyCcTgI+BOivxK/oFTAT4iW9uOhW341RkizX//CwG4f1bKH/nD90p5fCSW7yNNUl7kAPmTXtH8TUnk719pViUoMPQ+WqTLtlwt/CZ6IYylm1OI/GKGQkHfyykEYrFeCDMjZRfCOMsTvViSm00p+QROFevZW+V63gX/CuroFPS49x4ugrO7GxE6xGdl2St5n2zyQdoqCTgwHwOgocclUOScvX5puWHoTqzL+hqRl/g/15Ke2QZbP3IIhaK7u7tWZTge3HhhparuveYgoPCfDU2yfvnFamxWrb9ZzY2NKuyhGxu1HNrt6aRAKdLIJNc/GxMdmbpEbwj0LiEB/JsY/VW+r9SsSqX6s2YbBK1x+t7wDiJiEaatqinJWcLxsn6NAoXwoaF9aKYflAqFDllLax7UbK665AFJxs/JsOEKOw56dFA5ipjfLk5r/5UBRe+encxpus8NmehAtnxK6PWY6PBzctq0v0MqtjSkRQEVXARuFNuVk4AxixgfaYlRaOGCtiw/8Myzu1Yv6I4HELyRNKfd9+Djy8lhz65EvBNrA+jFGitSkTft2I/73ixssIDCBJZZtE81e7j3F+aGJRVu8JPMwgPoK6mAhaPPx4eIHN/B+2o6monsuO/2u2Ow5bDcu7vwKWyk5otR2VByw26tHqKMR0Qi9pJl9RvmR5auB7MpcnOfzAIsaOUE5vAirMgPGaiwAOv9nIQnM+OKuYMptuC0xRMQTlr85NzBvwfgOimjgQxECq1dFU8uUol7N0paQAqet4/a+xftg87J6UG7c3hw7kQQV/cXq56sEwpjt0HYdrv3Nnyzdn8R4Ywy9iMOhUa2pF4s6/i9dKGyZXjufgCnb//OJ4uNymnPsRmgPofzHe3Mx3u8jeONp7bIsoAj9e5vf7O+41z3UVf+KggP/IHUFk1aMZYgvzQvUTOJN9jmHWyng59rOVFvvyC1UkM3QZCtLhUjhBwhZXtj5U84yoJ6GTzk4Al7u7BTz1JhCemcDbEoZSyhq/Dw9KTz8vSfCn5I75wonvQ9p+dHIypSVPAyvZJD2/duwSbwXz98gnrx6+fRw79ySsTBSChAvk2hpwrLtAR+n1KGKSrTQvQBK/V5RYygV3Etki/jUTIfcR24+FHa4/Opctfmi5VZm9mdVM8R5Ldzw5fxsJisi9QV8YjBy0ubGH/oBMMuOS+9J8xJvWTLxhdJu5KzinKuuAuD8WhKm25i0prQI+tkDcmlRnEGUqP4Q71RyOY1vH4VBoOc5knrvdiI3QQPUtM06Sr0hj0vJAcWeJQFl9IvRg0EuMTFyxOBqxcMvhBe6FBMRZicJBo5OTQ266uv0MTYy3DQfhMoN+6GV7lgsrlC6k25ayiG0ksRBUyA0VuI75i3NoBoDaNAJgvjzelv7TMmqmNqZSLgg55+3O+LZ+W9/kd3EjHBw7qHtljIyLIjb+SiISIaq0AV9A27KKdFsPXYPuxCVeT9euyGvR0rbZw1IGIImPdixHww8h34Q39ATgc826GwqJOOa2sWX/92eN55dXh00T47d3gcGgdUMK/Scp/k8P741On2yY8FtkhkmQ9I6+0Ki5dZQEeTKIBUjfRxQKQIC6UnHOk1697vsfGy3Fu4OOl5ZO5hoSeQV9az0STnfmSjteoazpux3+8d8IwvFzAYAp6Y35blxkTvHaaYeEl/Cd+LFGSJCQWYmVnUb6HyvMKjMFQqEK1uBB9J/7v3hC/ZEnesT59p7o1ox7q8Bl+v2KX3rYQOLQcoe7nWRMeAralZfu+halQ10CWKhwPM0IGIQyAr+ULdA8iTSuVntTCPU8+ZsFj1pFNVh15Y2iOodSQu8r4Xi9HryXhIOgzkmTYfvtbw4aHeBVFjAgiEQReQEq9PKCt2n7JmNQwXLrSc8ZqF5/bBsXdG4+jeTqmeRjyZ7wDUfLHqgNIL3Y9MAQ7b7fnongiG0uEnm6Issoq5h3bHIK1E5BfxEjkav8m3J/jIqPRENafBeuM3ujsLRhzI/FdRL6qZdKR3AXA6ovIGGTX6mIgN7c7+6cnF3uHJcfvkgmAF9ihZ6pGyuKHlEF47uq/SHnLRgT38WSX9SFD4NoQYCCp9+kYrdNcPPmr0+JCLIfxDVgfQm1Ps/enJ0R/Wwdne79bhqx0redxwLMSoYxBV/IiQJa+ajvW7Z7mhZ52cXjzFXex69l1sjqTyYuUllSgORsKi2gM5mK/kRK+SQ/NkqX+mpw6cXZWS0a9UkaLNcD9iVMM72OUhd7sAKxq5y1m+oqtQFDbAmLe/JxFMZZAeBJZX27j6mv84uLtDozav/UCOTj3ZHlh/tzDN4le3C5b7ZrMCst7/BC2VHJATh37sJUTqbuqOwAsJuMGe+TaIfKal/FnVKxwObwN5s4VSae0g8f9sNMdUOR25N6ih4Fx/lQV2+TE8+RdqBX74xOr6/C9hNbf/+Xbv5KB9AOf7Nr1jTPsqrGSFjhywPWFYfjZZZvxrP+j33RFEcqR1Y8M//ytZ4DQ6dHYlqG21ReYKgdvrTWkC/Y29ngokNMbjAu2rN7Ptq3NUio2VN7CmurX9Qe8VEZ50faLwojTGkmLHYBflkEK+gpBHJuxjWPTXczeuetGNq77qEw7w+JXb79+43ffNA3HG6W9yrV5erJA9ndw1u8utxGpWcjCrWbfjfv9APSYGcNEc3NmVy+aBxVlcpwmgMSwuvZHhNzGJblYwsvvdu3l9ZI2HaQC/NWuMrgGE7S1jW1EN9CF7ar4pG6WQbpjooyorrN+rD4OhVxEPXu+oPv3NuwNqQ2d5HzwYMrFp1oCsTEmXPu6dA7GdjJrYdjq6jj8k/765OD6Ceis/q69p00Zs0wcaDGvkf/CyaEGBf0twAmjv/V7PG1aybsfokH1JVtiC2qZGjkFdI8+ibv1FKTTY+/f+CC9PNe219KYcPkJyv1IgOezVLIw7VcM15KGrUDCkS0u9ci9goyowllRSyXNdLZW15pJ1fvWMSMZXz0BHPlIciaBHYmvo1GcNsis34zgOhgnKsAL0duqERu2tAFcLjAzS1cvpYu8hhiM0VV1XSCtUCiKItgnoxHDVBZE/7Ape0Vdq7IpevsC6QHkBY40Ew+fB7a2qYCdv9rAlpLo9cLNw4FrQxh+IRRitOgTlwon9HtjznwzF9/dVVd0F7L5IAC6IJPNdhK23Vv4sTZrr/yndfqVPltNzfWbgoB2ypTMhNy9LFy+Z9WSwf8fn5OD50R/2go90SeNDYWImdmZq6Tf0hVKcPv1ZUi2RjTIxcaN/f7R6o1AnSupiHzSy+AHsUy/IxIhug3BggzcT/o99qKrEXZec3QmTGnCqPp4f74Iynq2+cRxIwJobr/QwR9jfWDlhP/XiFR11d7/0v4QT6peO9072XrfPdqxzr3+7Fntk5/kJbk9Jb8gm63XfR4uu+eAYzGO8jxZI3MfukMyBVMFzcOxA12mv2TMGAVju4DglhCA8F6TBSeFwPDwYvMW22wfHzLpHlB4WN3Zw0Di/2Ls437HeBiPq/HLv4UkHQoPRMwi1RsGoNnhEwwblNmbxor6mMmi1snUGrRxRf31re9VFfXrqI8uqB3sMhPfRDd3Vt6Vxx9O7Z4M3f80C5/oa2YGDsBepZlbsWA2EFj/jRpopSBARAZUsTiAjh4AA8iJPHDeOQ59I3WBBwYo66C8s7KO0KPiw7rIW0Nj4zgPs/XWdsqFRTjIomxrlnxmULYHSG/Yy615X6LJq3lDotHqnjxMEr4rY4IOhzNhTnX3YSxa8CqIT9shBIrGuQaM4Y+yqL1J5L8gRr7m56lBCtppztv1IIr/8eGEGKdPujPdI68J4kdb3Qk9sg90JjWaNUdOEvBr+gJC7g9EO39/JYcGJg8Pz03N0kberNdHai7Sph5ZtgtmoS9qFD5k4rYb7AAFll4feJs96uGCqBgMS4aUWagAb79AWUPuuoWIiol9MiSVpMzNKqi2H0z40uwFB9ELPendoJbELLbs3Bu9dv+fduCFLO1sVSh6TYxHPRpuckhgEw2DYFSp2rKHJTVSpWd99l6lppaSVRDlAGYAVLW8BY7O0FrMNRQrZ3lhRjeObyU3o97TTjOld7g1Ga/2F+N/mipnPCl3VTjoZIYmImEsZdO9duKBH91YoC+eVAZm9PNg/KhvR0OT12d7bNxIMpI8JmmBL4CZeaEdqgCL603MbW/0SP7W/FQMX4aW8UMwQAmn4JfGT+l8YPAkMiqH1wCNtJrOb/Vn2sSJLzgv3MS4nqFmR9+h+Evnd6FeHvYZqPn2WCva82O3enxGxcwy1PMFlxotsZHmRox5ZX/k4Z0E4cON9UjnqoKVYZ/qrJ7Nne4V1L1Q4Ubpjs1uLvj/wQTpYT5Y6CypEleYRgTXPrjO6qjNwR7Z9iek3usDqGqWIf/3wiTz6bP3wCR9+/lfV+XfgD+2KdTWu12+2rEoVTeLX1ipL7QurZOJbvelMM5slnoxnsmmJ+W1J3NL1zonX/X0woUryzshiOV4rZ12B9fwPyf0XoZTvvlJ3T/KqIu8yUGG7n8M5Grnp1Rojl9njw4pCIV+q4VOpYuxi8YoZucKWptZJlyzvPR3kfXC2sVmDqhmvGeOqdlEpEoXUcHx5EUFJt1eCUBXoYJgTrCJ5nytCN1c1XAV1A1UgYDTNdzVd6LID66wxo5JoUXPFwJKjX6GoTlueGWhqITHDRjO4pEIrzOY/2Q6rKn+wTtWYYwxB6H+VjpgCWP9KPOgt+4dP2JUnCA68nW28up0T/ubFymPKKBilhzcRTLQXZfEvkzpm93iWhV2rVa/XJRt4zU0jPSS+Dcje11OCakcxaZSBd7FofKmdouCscg0XbCNMwZMeUB2nkumbpTYxVaBLcfbC+MJH0QTUlOSE/VGx18/zrDM40GWEDhOVgIm9pWexczOqLjxyPEZYYwH4E655wcISlEO8VD0VMICW5qjwKJ7w9Vy9Xr2wJ/zKn76jybCb7Mx7tzwKN72nkZzMphHmWgs94pUjZHhhjj4LcjvL6+kXBexjO+phL2K2BBAK284N30fP+0NYR0OMWCcx9HvRRXCGwgB36qTprRLDOy0WXzVZn37PtDrTNqJJnilInlArvUvwe6abBFFuEIsw9/ZfrLp2bxt5LNAPl3CqiDU0UyEYQo/7kG40JqsW54FsmwjZy+LQv7uDKOrmeIvkJ3BRHXsfBO/T0lDp8sb/3C6DsILGJjQ4PNidqiKL6XUuomytjP2hoXcKihwcJ3CR4UaXegyQJXJwbHXJAiYyAgauvcMORJZ9ajfA9yB4Px5FVTXbAKodqdIdzjcXySNDkgGF9ix5ZEgToNCChcbFZOQJ9LSEYr6NRsvRGmY8qNSEFtYsMWQPvq9Z4AzvRfeIlLwJZoaYDYEwTLshM8T3szDEpAeEYdpXmSG+1xk+hRvVRrbMslFqfcrIDSMPQ7RKKCI9XaBONSuf32FmPr+30JQFalDSrtndqrpls7j+3UKJCirfVyDdjxMHzLahsVl1Ri54FIWxTSqv1CtVcw4BxqELgslvh/+XnF6OTskCAGGFe2etWFagF6torw+ebrK9Pn/ylQ7601LozmGwDz2SDfbBdJ2U65+DMxrZbYQJSC3lX979rFOfEeHPpubwaGVfY2b0WhDqg9D9iBAfKdbycRi893ilFTJuLhm4eo3/v+60qhWlYrCT+53Z9tedDeEtyLJ2egUOWS7xmrtqDhFFRhG0AHR5A6ETBeMQctLBQg9uIP1mxfpVekXDUB+7I9iMbeGNmryDSQZ3sVIFwQFS0lgFe2Wogr4x5Qf5DjoB5yNSUxWvIPxhotWQ2rJgm79m7gm/WfSE31p9/wMeZNVsP2x+uzj74Wn37PtQf7DAvVLvEM5R9awJ2SnZmsGs2HRu48lbtRQm7TlBXdasa1Ge5dkBqcDiZthLT/nIVFy7VS2QHVlOhjYVWLxf3ia22DUMhREV89ZSLYZNfa25hS/NwwQuzVXDMKOI8wazBfFB/9WKA3xMtYU2MzTCRy8nGLUgWrx1zqKybW+uvrzBzzXJcqK5EWQRJIcoF0oaK+SKkNlLWxPJv3t9tndw2D656LQPXrfPO+2TvZdH7YNUUajruGEFvQoANkIPT6IgHYCfLZUUcDFjJvqxaEIvZOpGLSIQX9yTKXuKBRD5xEDbKig+ov/fRq7/30ZR/7/1UnjqH7PQw+x6PdKMZ00EX0uj/hiO+2r/ZP99Hpl5Gdz1uY0pOLpjqMR0jX2y/N6OVYHWrqHtDSiG8AN5erT3sn10Th689ybkK0QgOaI01ueamYcQjzvlAzeD1tu9k/aRxCuJV53NLvRGQRgLrM7ab0/PLiQ2Z0gzhRHXeXE+CGISmzZScO1AGkySDRvcMTxKwNl67r5cL6xSX/37fwgcnp2kz/x2cVvx1zUo0nunmhMtID8eoAh7VuX8ppjgLK8X/eoHqmByP82MzqMVilM+k6As0duMHbSlNAPGO+kuGaDQxQeUmClyWY6HzMCRzBwj21RjUjXx4sGgsFJuYUK/KtdHHzAEPbsKv3hz1m47v+GjFqu7RnOqTdhf6pGamM0iqTMKA5R0aQ1yBXCOtBndg/UjaOOsn+BfyG6fFeGDFgXosNdY2UleWSm8BxuOTxZp+wSd6ZbXsHblY2BRBEejo0M1/5vpXS4QtFYow5TcNcz9VrPcHviNfuCe10+bWDJKsz8mbwqmjhwFzDA2C9yUkFDfkQKG4zO8Im/IOv9l10qy0kEaSPr07+xpiGF0/vY3WQ8GNJOkJCSrYwUnScGbICbzRzeGIfXydJLJMDAX2zTjZZ5tTFLIlCyY2wuzzeWRgaSZDSTNwqFgV1G6gNwFsj+kmrtBf7uwxLRLkLdB8QUt7NMKF3Wg3h35Iw/uvZijjBcjVzDOrf9s8EWdKA6Z4JDihhBx/VduCDsxOGXCld7pyO1ClJ/ddJHwG/C9t2/be2d7J/vtDgS5aSesSO/68u24vIZ/zS8qE+9YttwLvGnsBKxdIKI49W1ZEIF0DvM0/HdSbs6GQ9G8hj9BzgY5O22rcHLa5vZmGUL9JsB9Hiu2tOa3orrv/Lf9JzN3O/fCD37XW2wUMLl7MqAAkpy3Lzr/aP/B3dhBvCC1/MObSH7sr89O3709JzP79GzvdZsV+BcZhr5PgKeDeSWjzg+fBI5JiHgIwouWXKnVGsUrfIgOuPy52UFJeomFXmIwTtqjRZz3C3qGb2TvyhuFA+et4L016dcYzSY9DCnKNr3k4tr8uiynfUP3TBFtBm74PvjANlKHfdN3znsi9bbhKDKCgy0lc+Bhx6NPO1mSfQyRJWkErbSk+NC4TSdthlA7aUwZ7EFGeInCCeDgF6Ym9JjyDb52/J7cdi6FuGkzxFBWjEVSJf1uyNWGaeXTsXOiYODZ90B479ATDdmcaelqNa3tJ7D8aRktbsjahaA4uxa9oaMxcZPxXF4v3JXXFtBUPd7bQIqWLT9dmIbgK4NH2ivFio6abbPUJqITGZHoE+8yPWtiGJDJE8GSO4akiQN/CHFmOZ/nlslhTvNwGwWjtykjzlOrzHNp2xqkSVjbiLQPvvASNaul2Z68cslahHXFUpzlNGNaFjc5k9uvDgxk6Lt9crrHJ8kDh4v8uxa2DxteRVWhKXGjkNRNZpo8LsK5uWFkfccylTyy0W0z2womRz/Q3CpHCE6akYcKgZHuv6+9zhXoZ7xum90GHW56yZ6yUMtcQ0fVmzd/CHqAAinkPeSyRukVj3wafak4E0ovXd0l7aimTRKu7+hFtV1hYfNrFCdokqbOMSbDhmO30jpgnLStmjZzdsZCi5f31nCjJFnjIeMRhAszJ3nib0pjqCZ3TV2gN/mrqjvooV1KpCxJP0ryOgCHX+FfYdozs5oomfgQyk3MvxjRgHNgsEkP0N9xjk/lLtXINhUps/1Zz4OegeD01p2AUkTSbJtePlmMtWPQ+y7wZkzrjT2if0VdNgtBDHNpHCnRFciTdn960qc1SiptC7x0NeFDr4cvvAdMvXLQ3j89fnvWPj8/PHkNkSDEGAsNxzogbScy7Esi6m2uSzfp924I6jELD5o3SZdkvbo/ZDRwl/6OrJ5tdAK3eWl+ucRKoScKHJB9PBmTP3+3FFLy8KefpNMDq+TSx0jRnBo+7JOm78W2X1XjY9BUwURIwVDz1BR8ALFh4/vQc3sViDb/PoA8L/B1QjNn9aj9+P7BSbXY+C5tyrpGObJXsBALL91Q1WLLb3IE3tluxJZF3pW7aIswwh5bEP+YJmmSwIRso0QuVCJN4+b6wfc+VnasCv6tKS9v0UccXrNPKgEmY4P39IP22otj9IAGCv5ZjezMNE8wdeCyjzVVUMBdkr0dzHLRNPWwd23Ww+ULEshCvbu/ifWw1iBHTEtCRYVqqpdnjapmXasnv9A56z/txo51SmYiKDDvCPxEeIEAwjwsqy6BnDUIX9ifQDChQWS5t0+j2m/kaOMaueq41Q8KQb6MR/QK1WQWn/E699a9PgvI+Jkg42eCzHnMRJhFmfJofZRA5o3XJwLSjvXSh+wsdM5iYhYaHZKlllQEgd45JdyFsCss4Cas5mC4T04Gd14N5CR/ANFQdq2GeW1HnEXW8pbNWjLjXiqlWFs0kx5ancGqh74w4AO6eJmS1EnNAT0juM6/InJFbDNmNAKpQY3G42VmRORMR40c4OvkBETIUj96OO/QB6/8B69nc2q1ouBpgGUrG1e28kLNNEoDK5mAUgRKViowntQxzXZHiN8GNjvvhv6tT/a7d4cWy2JFKd8dsq9yJqsUisa9I8znIJHBvcFZ+/j0t/bBjnUSfGS6ByIWTayjvT9O311wOrLpguBPupSmlyDNoURJaKcIRS7a3B4Ga0q/HyMNAGQcWO6HwO8RnBnf9L01oDFHrONSGpHe0M0XgQAOIShLsKaoUl5G9LvEPoCc1WLX71voeZCyUD0SMtigV+vfLPCgsZgZFP/tLPvt2eFx2zqncTTPq4nqRN8lKPdHAZMFuc43myt/ZQgSIfxQGABCieOtvCmN9lDumo3nDIMxsdFwOL230uzSwKfsVLSRW5cNiEce3vpp5cj+HftkPpwjAbWua8iuBhCVKa8ohm3i2azYkiJSVPfeUnpH825GHjk7BURWqCjO8qmL7ZE/9A5cMPEd9/vqDp+Ssf7abFiyCQ/8kEKH23/LGg0ekqTZapkbsmLf/6w2t0fa4hVp7yVZr+vX5oYsr/NSGdLspuHBzJ7zU5PmtJzmSjrLj+61aHcGP/hpce+YnEAW9svDo8OLP3asc/eDl4SVSLL8WTfeLWSrcocTlr2S3lmyZU/KwP7LHQzEAHXQNkytI9zSsYsQzb0/Iz3PtBQ9FC14HL8IDKn5IutPMmJuYWxiuc1pFdQfQ1zOqsuG0FLR/gkwHtrFAhhM5wiPfyNSDXfjoM4NcMQiv2UDbBMo/D4CiOiBBGSDSCWUQI5J5It6KYIJ7CXW8vSkr0cTMFKUJJuAuYNyPAF60qcic7Q8QQXIZAv6H7xUP4NZfG5Z8DyzJqbLPSVsqVPgnyQ9gIxA11XrV8NTaye10BSdFGXgYs7+tD4Hv8Ha5q2jT2pymYE/3MGIZlCEfLG+I6hJFoZ3SwajB60R3u2kvMhXlZP7IHByHxROTxNMYDv7kicnmUCr2SrFLU92NAHz24WpT74unpiO7gsPJsCz0QXRNNMolROWUfgkNBfzZC5J8Yy3Rz4AsYc5lzJ6/AXt4leKniBw54EUcm58vGqGRaYnxjdLmJuCQYhXQ6Y76X2oy3oaTex8GUPXmyXJenRKf6fzrts35C1X35YlQoneOzlQA7usgcM7t6l2H2wUSXXJ2tY0G0N0lSZcKU0GOlCKXVrNj3AFT88eLw9fv26fWfduP7DWrI9uRMb2hZwiJBiPlNINZ/vnxNyaSDB393F/Yt1gtH1aABmmqx+70ekkrXlD3kpQYCJwIqjVIaNty92oWfnflcynQgOwbVmVJy+FitPe1yzzZ6Gy5TXebNRXHkG8YTSmh1+2kqSTjvnt4hDk6bOX6z0yhHfJi+HCZjXbG9FnMSXV3ynHE7qKxXAsNBK+mn83WXnHzF9BKnPsRfcv3cjv8re2dKYhY08mwEO9fkv+qyWI8vLs8PWbC2v/j70Tgknj4cCPIvem730n5GkHJ6mRC/qeHQxxIRwhmIaV59ZOHUOO3+2/YcwJ5FG0qzutjbQoTtXfyRLwmMGqEqJB6TOAhdZfO8l91nmzd3Taed0+PW5fnP1R08eqmtjDpgyfwHOjkX2FU1zz+mJlvb4MLl8l9PeyMzSVovuTH+0hMWmhlqtQzBiiJBlD56N6vUH+6h5V/eDjcQANoaHgNcOQmVKOzZfEjfuBkRVpvd07uzjcP2pbqMhds16Gwceh7w6tATaSWtCgE3nkJ2Z7kmr0PLiN9xMCO21/Te/9Xej39r1+/9z/kwgJdWdddk4rnhzNnCSNwTZLvSbrnRYcMr2V6+7VKurutdUqiavoGVW+G7BDeLMwCJkmbizY9EzuydK6iYqOn5muoombaOoi2pRXYfEVaFx9t2Q9vA0i8VEQ+nc+3Ncao1ElRwwIQSczIY9+SiW1lAt5vqaRAu5iL028JzrvSQbvCfJeXg/RlU/7nvhctXpGL7NWr0zBKYRuAXIw++wDAgrDiF2rWp+X1itj5W8B6fBjGgRQZOoTTnq1uFweSzHrkr4hzpHtBdTI2Udk6RQnxEjEYnCLhh+c6N6/hfBDwmGaE0tbI53pib5Zi1CopgnWQgRmBPezLxnFtUGTlWGXANuR+uZ+ckPk0UoVekY5RnDPfyKqEdJ+wCvqzU0byH6BJ9ZvzZkWc+XFTJSkhJzR7GAmhzXOJXoy4fMo+U0XZ7Wc1TE7P5e3+QBrFCUF0jSdNnOA/HZ0/jpH58dO8zWfALpdL4GJoZLGXrYzNLxc1aOr1hmbHyzJGmnW63VZGiiwGpTFDEuPNN3pB3d25VLAqGuLnpcBUFIu4M2taIv5GVkCgp9lZfsMC7vY8VU+umaEczccVpVD7i6EL9+xeAj2yU4Shf3PHTEQu8VtigS3y8dVLyxtBGQlS+AKnV+p4030HH7XNbfbJeMWhBECyjAIB+iyArmiRTDRXiz3sTazizLWbG+YsEbqqw3pqHVBgT7lCXbfnfzj5PT3k4o2f8cQ7IJMd+YwiKWcOHgHj/fdyLP1c4R1cdg+6+wdHe6dt88vkcE1rD389Hipu1q55+xW0XP2yoZOyVkULHW6knik0EL4+k5AX7QSWDflG2nu3naLGwP477kEwXF/tMHS86Mb9jCUqRvvWF23D66BKEOymJk1yx/eklWBAT9GoXfrPxiTWyexNiuUeyUjZS4P5IkFTOloWb15qzU5//9/9t6EvW0cWRf+K+iZdIvqSIq8JrE7ncex5cR3vB3LnZ6M259DS7TFCUXqkJSX+Pr+9g9VAElspGVFViR25jynY2EHCBQKtbyFRRt4IUV/0kFblc2Doxa967Pqx80Ra24cbX6Qay6MWLP172O54qJasWAu99JnOqQLTBe7Y/uBT3eRRy5cx+vKC44XvEDnJk9dlgt108uj6qYXm+UkL9t23/VuFQKTJZb4rk3naaQxI29eBAS+wIY0KsGPCr+CteK51/G9gjbK7NjXROoF7YCN6mWjRv7KPs9f/yD131nCX/+omrGMM6YgHRHc8pWKjrHQDWK6hCQBHW64fte5ObiwKo2KiqrAi/5OmnnLkFCb4TmjqhAqndUaaSVy6M79FEhGM59kFKGmLJaQZKQc6hGcYBObnmT8Hdh0mCsD8tD4dIaZAkwEWM3BActSBJ8V3bJOcOBhkkR+WFk3Dfqjb+UfGGQ7QkFmaG6ajt6OHAUwCv533Gofr9Frn/6zs/++IpxE/bnAGzmB7vChAH883bGcELb4q3Je5Op5FJJK/k44Sq4yg9iHHyG86PBvukvxB04Jrz0DH5vasIrHnB0qQ4372TWoLOdW38XtKO/1NK3cHCtOU9/suql25Q//ix9c+8ZtLe5//NVNbSneNrYWz3Y3PrWO2FaXW5nGVm/mb/Xm326rty7oEGNlr2eJ5d7sbJ6T2O0OtmTe7qtnre3t1ubxj/0+1f3eYX5w9XM7ZPGX0L/xjx0p6JKQNjX14SZ0GoSjbm55HvLOfrlgjLXEZ6UbAZxpHv8kSzIo/7tB58vmCAADFWGQ9bRB6Ql/5kZbtDXUkP30k9Sw1PGZEdCATYl3aVW67pXcuIBYAB2I46mYyyHW+76NOs1sbG+lqjh/p1sha1qLkgCl3QkGAKiGy69hT0Imh1D4LL+FfqPzIDiQN3/9I+kg4qhsWC/59dc/ftct639DDIPf25sHh63fXsCP6bgAjxlWdbU571pFlaREveD6OLAj6f6UEufkZfR4GpPO0upHlxqd4WoOHlc8Lcut/XgbutJDLY9ti8I64niRY1KVJOYNn0/AMuLoYPfs3cbRKXl2R1u4/2zCVp4Ksk8RsE/+SVmd11CHeecEMA0kq17+u7SnAyZYfPsqe1i9mDAIid3Fm9VjliUVFebu7MqlOwKd2sXIJE+7yScUhmSlbNwlGCWpGDOz75I5/g7nMLiiPCzlOoWNyIAj0MYd4B8tVQMkmKWJdDvDl822/f10wGHHM7hcLtt+tmMI6JXA2UjGl4aswl3+cmWiltus26fb2cr0LFVxe4yuBiShy5q9NGY/gIrUOa+zcpqWM62uXRFpTgHYECujsDuGp0oHkfONLxXmwvHA4LGkNnahvjZ6Ic80fhxPLlpSckMCmBo2BA4vHD2J4d+v6xWKSI+EiJAt0xRUSuMFvy7f0yl0+sEVC0MuG3ZLyWIEno3376fGIP7P0Amf8PIUZsngeXZkFwYeCR4kE+yvBgufY13C4bgEGQfgCSZVtfuWxYkXruLZZQTnF2swb2fLn0DHCBNzCvd3c163t7oJlQuUR6zrhsGAvvY1eVkwiBPknqIriB2MelJau4ySDO0mSjIkbNPknPXtAR4y/Tr5/ButCLPD++bNX//AGmvP7uA43v/1j9/hL/jS98TCP+nFAzHZWfS5++pvL1j93xUZYLXx38D1Ldk4Sr21+ZJ1ei6lClKYHEFWy5JHWzZeWDeyYunaovH0wjUjn2dWmbG4UDoyA/bLyAChH41qwC3nlPURKs/U5JXT7YOnJJNGIhQ73JuV1DyqQt6y5LU8KyYv8Wnq9t82kp5orW6/IfS7loo8BT8ovSshc42cnFY1T0eFyYUG6BAquQaPfHh5lCOnyRSrK8/snBVwupR+0ZlfJn7dTnefETWNl1bGk7ArPlAFoTFKPjreEJbMB+fx6sjjlizIL8PZBApaXCydEAA8YCGqrWL6paZP7vk/YwRGnKiJvPicOKiEaF234044ARZuTX8fpzqPyn7A240DQu/WBo/UxBODkL/e2ZO6UTGfxbyjxQ94MAw7zr8c4BbSg4ZpGglkr2y5KEtb1+UHtudsg+Cjvbmx22qfZGeYZqABJ8uAIC6OHeb0teNfACThx532Hxu7Z8cbR+9bx+2TdBynqvb1vcNj9ZHQJNXArIjb6DFuBekS/1ofIdvya9maVKuNmRUErLwuG40RP4PCxUjp5XwqyZsQAWC+OLfqi4nFUwLgsIETxrc6cWFxEX4yW34n+eq52Xciei1DJLvMXMngf5JlpiAsWZKxYzOzYqpZ8OTZ7DmdL+Br1w+EAQJBBGIc6a+fPqXTurl5BXy/IHzw1sIZeJ9WlEANFXS/g/zFsyMwSFfzcd/wAmi2qJVgtl9YJDH1Usza1TcWDPXky8wasCuMTAkU0DRzwxv0bCV+Zpo2H2aOY1hp8DlaOP52HNYoj05/qwSm7cJGYHmUIPxXtWTC6Aq8CYkXp8thgzen+cinVUJn4Nkdx3px8tdf3cbp87/+qj57USOfn91hl/fVzzk+WUUdP6JfLF4jfLhZcpUmfq6RB4ehtDvzLiil4xLo8J3Y8BJR0wu5hKeTdPBwq0+pMcjmqQlUNz3KTJMLiNOcRY4b46niy4gsBkVcl27k2CF+4+JmPS/nNjfna17O2Rl90tAx5ef3bQkvVckdDL2IRdRUI6VI63Tk9BybPlPc/tCzdQLHJTgIXqMJbyjrwyP83ZmCTXaXWOPttG0rV7ohPPWO4LMyNIAs5B8E9u3Qs4sQApTjm1mYmIVXJVXepEpjXXsjZZVUPalpznXBx7kN8Z6LVQ3olYFRXzU1w09YvwB1bgRqhU0oMe1FQcvMO8+tlu700MwP7V16GdJJOPLpMWSVmOkWpyrw3p0krUZ0n27AhLDDyCF0p0SI8UhbQXFf4F/RZ39Wkt57pMew4WoETslL+i9ELVlpGo5SL/L2bIgO/Sbji/uQYL2gWX/9ZVmUJ39erf31V/Qr+/Pnt9IPyqy/UA9w0qh2HUI3A5jGDp15UupkQYvRHBnLLWrlPGO5pdP825WHwk7XWtdxYIzpHn2ww2CZ+ZAWiFqInU0LRqMU9GhBGO7MvgoWXpXtWQCslOp7UXq3i283LGf2RyPalnOc2Tk1LS+B8MrudtvxrScr+aXEst6k6ST1LT+SJ2KElSvVAkYTixR4GmK+dDwwRXczTDrTSsocqmL98+JX8m6j3SLt40+7rTb59YWc3RCdEQ1GsRc0u87AntZIpb1N9gI/AEHXJtrW2xH9u0+TooHdUV/X92pYHzqW7d2DDYBlYXjJRaNZ84PYajD/yKppaMl7do0JJgwGuudBTPctOAYOVGnCDN+hL1+Xjm1HLfdxAE8sTcufJZfViEiYJtfApapmE5ue8JdpoRz+EmOaul+dypq+89OQqAlXaTgcnM00sq5DY6s8KPMwhJCCm/AxEmAa/DIIP0A5aAufDS+bP9foe+HnamU9Z3wd3oL2nBE6qAEfnazSI2cR2TGHuc5dorwhPDypGvDtxQObWbHa6kLZ2HTmliLSliyltKw6m+K3M+u8ndGY9Z+MTfC0KK+Rp+PpF4vRUReX/7YOo4zPRCP57TDop5FzdHgSc5nJhUGaEbwSfZomwfOjTFPRKU0wPx3VAk8yuLtwQ3Tr48MkNtEdDh62u2PG8ihPd8Lnzw2BUdCXB14I+Gf92Z1U5f6zViW5Hd8fHfxxeLZ5sHtw1D6xpFqkDiHXf5aK8FU4NTyGEr8LNYZgdy0Zn2L7Aht1jXzGT0e0Edf0IH/0K6yRk0ajgZ9lOh69S/nS+aWRXQZel8LSTjksir2dIXdyt/MOfNsL+gwVSY2cmCrTcdzeUzr5mghHDogJi4VtUgiznIbSVpSL0mwublUzm1Q0i8+3hJFG1No626ev9LOdrbY6uLwRbIShfdsAeGdLa6PY8uXkdObVafOvjKZnhc6SwUlEbbfr0P18MHAklkDLmJjsb2Ix07TpKGh8S0Y8CXFexoufZgNIV5HSGcrUQSalK5yT6qlZrAqZkkY6ioGP5khE7Z2t1ruNo7P28cZxS4f+s1hxSgrYXw2PoYjRRyn7HdDJVAHTVWE1+GCMLDpro/LIWg6GPSyuh1o/SnAqa73gSoBnm12E81KdaVhz+vjaoFyLeKKV5PmQ5T/qbAsztEJKwcNFHW0zXMAoX5DFD1dTO5w3B6yhNCC3fQMQ/2lw7nChEbqXvRh6YH9BBK60KM32nAuWC39U9XAEtw/3wKTW2Aj7U+0jDgaYS/+tGkIgpZP4Ne1t5rFA5/7xLZxCHtvZOR9esuW/1eVSau7ERN9PyQQ/6kjq85TvXLpjaFbLt889htgpJeh+q2Ju1RiDnhXhnRk1RlKJR4B/GutzBR1blDrm1Bkduq08WJcp7jpRdOzcGJR2eSouuqoDuifXCVCXNYmAySiH3bhHd06z+fM66TlAp/ivvG6QENQxsnMEMQt9Z518rWOsFKzZXDBU/WxIm1mZ9+JSmW56ShpcBoFhD3p/wucWaYw5dz7Ua48iMvpETYw9HBbO+xfx9lCsHrFyhkBCeN2P0AyWK2jnynWuB0EYM+HiR/7LqhqkZTAinBUtK07iLbEgaAQgiwvJ1bcNPPgYaxQQA5rmOSQtShMSmhTTR2jzMl17UDby6fBadWEKdaF3jbwLjfxGNg/2t3feN/Z29s9YtPY/d7aOP6QfdnZJzEKJuBj0Xzq0fccTKYucWkhRVueSomQTtAbw35ZXgwhqXSQzUY0Enc5w4DpdOCmR/sjgddTIRdo5ZAB4vDSQEIzNTKe96bn0K+M51EkHlk+PLwDdpYdzudk0F/+A139SnjEDUGFppTkeaQLb4HMnilnk42xtTpqis21SKnvu7PgXAOl5KzV2EYRgSIujpe0FF0KDOdAhHc/uD5wu7x5+HAfpUGkjNWGZauIa1NL5qbxdh+2vJ34ZLee/jJZHjpQ830SF+X3kPY3MufOhIHgUkdEnqusG1OeMwb4QrfTjPhj5VComZCGkY3BMQB+2vfPv1tbZ4cZ+a7ddIzRh69P+xt7OZppUiUE3CYYtYiQC+lNijMDHVeJwZDVf2mvq5QfPpN/NR9nxChgpt4uhqtLs/wWXJKbXCEII30ieE1mXodHXhKNxvKoptG2IMKKGhc0a+kKfQLQhce0yiCEY4VtSwadZhayZ31b4P7bUM6vYWHxdprdR6FwC7Gsoe/FmafPhwfsogpJMz6LbshO6A3pCDO+gO3peaty+ASzr+OauoD6D3MNZTKur2g23m8/TAB1y2MnNsNCSbqQg1OStfEhyjayT2pkj/T+B8lSqRTQhqUQLKYcxyZHjwLBVC28bdOEtWJo7IIvZGtTSWd3noYp/Ptnd+HTwx/EpOeKfwOmukWd3bhdBGmGFFZ//JChO2vkldl6gKfkm5LFm4dOmObIj7kKZKITA3CoGCmLyxPQkA/Ct92ONUGjp0+E+JNZepBJ8aypXNRM1Jm/yjaP3O/s1FTd8UFwgZBJIrvJEhM9EJlBULTHfF+vx50xxRS7/NPW3SH4trJpIS419apX12LJPoGJZKVSxrIyH2DHnJ1h590kmjXpWWU/ymK/fUc98qnNMpXpMu5kqK2l/PCktEfKjko2iWjWRC71t1GpKTWNKms+oQdI0m1S1OpUTOCHPnpWS3aGpGS2++DZTwY3R6M9crHx6z4IJWzlH08CqXw0MMji5SN8OL10fnfTXTaZM3NKJFlAsn/JKJ4JFsfJbstRscrG/RjTkgifyKb/jRORqYKAJ9Acbfo1RA1rIdLzTYuS+9m2t03/J84cak9bh+SNGOLv4OS/LSnI2oePA7ebRGjF/Ytf/TBKZZKYmzSdDmkqNDfHnerHDQ2KXqFrvqgIB1jRYVDF8KtTgbdmxjWlim2CrKLhIRO5XJ3GQKNaSJBA9SgdWtcFyaMMnp7nTSWDV/UK88J5tgAoXvTr2DcjKRYKQaNj/N+0VcFOG/U/pX/+Bv0TPban5IkQ0bPA5nUdjduE8S/W24O66dhQfXFzQQgaPZSmvhAoKdZom2hJgDioWo8C7crD4Jh2TG6ngdBgthRX/yegZlQQ2wwiu+aYVTEGh2x/L/8ut3ht267wJgzoAc4xmY5jDTbboNvQjelwh6sNn/OHR8/Zvqw5OwSRN+GQ9u2Mzvh/cVD/rwAhTCBZbHCt2VN3A65JxEAeiAl/hHrS8EppMqdM0HW1QjKHaUEP0TsyFYvsLvVwHoRvAVyfXPfoEAFeEnKfFUaqPa2cJuiNllldlY2gMhlFPSlcHtM0wSVHlmGVI+rpCRST0CxmopMicO3Rfy1nRWobq6oR8WfJRSY+DQZ2+cH7YTU3Hr2rHh41kEk2a8soqm1Tnivu0WAiJFkrwFCe/C5aEmPDLL6q7YQclhlJJ+G0syEQEv71RxZTGwvyZL5ZmST/ki9M3FdoL6HIdcit43VZIyy6hb5NhptZNjcgeDmd9yIeHpwh0xVLhEXo785t3qUx3wDih2pdX5nJ76mHaKcfxJwqR4GXofhXCJXHZkh6dmRWE6MwYnDl0LjxAodQ5mdDufCG4q1PfmBGaxwoASJkb/9l0yJxGB41x/10jyZ+fJEYLDEYGdO3cK2cNQSwNvFfCMDM/XhZXK5qs53HmeHyX45absyIOnH3joo/QypMgazQLkTWaIyNrlMlmVn40qfJuOWdOoK4eLesWH41P5riPgmtFV6bKevWOE61ZCiFNewYcuWHsMGjR7HzCoA55hC0Wj6tSRzPaOhqscOO2xdXm+mj6+aZJsd40294srNKHZzbe52SxObK1jdm65uEW821ppqK1n5Bx7MJiuYiJgYqMRD6a80o9EmGKZmHveHnHW4DCAWmPYMGqXbKF0iDoIV8aJAt47kcenYwrzE+XRnbk1pFRQAl2GsUbZgWevhWGJgJ5CPOHH4Nl99xu1/ErxQMBb0hnFCcmFF9xlyXUpAGuSZj4JBl1ayoZ5JQv5GZHSPFCDojAiE1I3/YzizaysFAuWrJNT1+x8U9OiXIK1g2T/WHz861WOU9rQDS2zQ82Oi+GP3NPaD4AskYxpckrUkIn5ZzZWkwIWGMCkk+5psDj0Z5U37+wqhm92H6nF4QgfmRDWDdlf0qyP5liCMF8mDlMxtN8OPjYOuI2SJMxWxK7ocyH2Ib8Ew2DhNJoIpTjkMwNsES0WMkuy6DFS+oY7Q3U1SS/0iO8RJ5Pgdos51ObIh/l1RJRG6M5ixIR1FzgOzkWPipW3yPdCo2WPTr5mIDlzihWO+NU70OMQN3qJwE4Rh3oOxnRRdXZi+7QVQ265Cc2eRAeZc1JGHPG1TqSlf3M+mhdj4IYKgWFPnKGghVgOIItRe5YghSfQUEJnAdLgbl3VAaJu0xakpQCrmWxsbT8WvzffDIxib5BpyZ+cE334xbAm/pQQrnDIbtOzjzc6tBGBhl01NrePfjz7PjD0cHx8W7rbK+dAxUX2heHDsoqzEBxWb4enyx7EVFCEcUbvtvHhdsO6Ve0LJN6ydyuChArN85Wx5B9X803J8yDiU8HIKwamEZfm0iCaB7GKI9iMaYquQ7BRZuxcIzP5JD2Vo+ym5DG7cRSb63JE5hVlcC8FgnMqkRgXhfAwZZMQKO8kUqsI7IUZjrPzx5uRkG4OGl/+6Xmq0K1A8sfDZVj3rdiuvTfjMrxhNvykbAcwpzkjfl6oRCYA+Al3Njp10gwYEHY35C7e9VuYhMi9S2spWAScE/YhA+R7HTpJ3MvXEpRn5MPNMWjf23zrqR2nMZlgxy13u+0j48+NdJBVDr9bh2GHKVafwbTCoJLStfBoAHgL9ZIpdFoVOhNY1SJwDyYfiCZZ8UUaAgHHQngGj025DVlIRSjCT6FjWEc1K/d0IGetw72UiwODF4c0Qd/3CNxz43IzpbpVX4e+8VmuoZXOa1jZAdoeiPwO3T7gI7ZbEGSthM7M2vLvzz/AcElmtKzI+H4JlRFTi2kK805JSvZFPOuvfT4gRyrEF5m4kF1m/k2O81Rb7tX8741mTpW3ZpyajmvvGyOD+7NKUMfjRftuXwbc34fBY/finl7EFiQSHwTPMwpTPypUPxQ+Hs+E5wbpzOMpUieQlI5tymfIHLJCMFvkIlRzp2ynnmkM1Ur0VK//JJA8NFfDc5zP8Su82Mh1LDYSMxipAQC79oOfevzyRGf72n6VPGDmFzAduJgeCYIvDSa2GzT/5elOl+UHeTUTWGZhdT5MAN8PMucxPcovBLmk1+e923puVHCNUp2HWp6KbemOEkjIqMQVTG7Ab44t1HmrfFjo05vo3I6om1UMb20GzWZ5IMblZHTH7t0Srs0GtDNYHu4SSMb5ghCXYQXEvepIWtq8T036IjDeHR/82xKyuZcMW1OZWYW4j7VSN++OYTwVnqwDl9EdvrtjVgyMUKHEgbDeycN39dxXE9u6IXQjs7zSmBU1lmNuN0blCbTf8nPvGk0hJ95h91lWZY83yemw1wnTKhyhqw5eYY+7vwo87QG+qlh+//4w1GrlZlc4k/dsiozivSda1an8REtqpYkqwbWTQrSMoDDkFQGl1PLGOMyLdF1r9yu0+7Ynh1aKags3cS8XXYqq9M8TuPpZlbKdAFdOvE+mBqfB+Gm43mqqbaWNx/c0uPOkzpPq0P/++8agX8+sX/+YzhdbrS0lR2unfbZ0pZ2uHzergGjCQMqgc01vU/ekPrCOvxBLzf84/lzTfCTlb9Nyt8m5W8N5eU6X9HThA74La2KLiOQRqtbPBUTq5Ca0xb8L50OAzT6/OwOl4o8p0O+r7Ffn+DXbfLrP/DrqyxVyrGGkrHW9As56Xvm79uFpTJRiPOh63U/DD1vcUskDkpyKS9aYY6mSxZYU+nyIr+RpXzM0RcvyBFiW5DukM1Fx5cY+u7/Dh1+Fe/ZgwcvYKOfA33KAejhs7tB46YRB4i8Zi1X4UwOGrdiymdTtCU2CJSv0ZaqVT4qtA+hCfTGLkYxa0NguvNbclMjMcDN3Wrh7tBaUXiC8g6uwNUeHqGNCDxbLLtGzqs5UHB24wb57/PGTbrkduOW1GnK7bpRZg5VIPsmf/T4SeF7PgloxqSMQ1ZKR1/aLOF9KHP0prz5cEgdg9AI80yexHCDtt2vzpjcx2WYsvUJLcmK+DKeMbpzGU/aT5gHbgr7w/65EzbcaBuwhBysRI9fIQYjYxD4I/zCC4KQV6Pv73R6uTU/GWrejlTzPxnDIzTAWvjKg+QK7RA9RrdCS3EiKZOT8jdIQg2LBmsvkFD8mRLQk1Mc+Leo0UakMH9XnEeRwiBGcju4yDyjIg0pWs+eEwiwxxEaw1xVWlOjp3kw9CCvHYccTZ1ughWTrjvwY9v1eTw5Tou2d3ZbZ5sH+8cbO/t7rf3j9dFIl+IgJTadeGzx341OMviWb597TtcYGlIigQ8SWN2B3/W3XHSVe7WOXM0epXn9YZ90aartdxxy7sTXDmVvBnYYu3TbRzlNtP8X/EN5c78mf02VFk9YX79YCP61OCr410pz3qnMZRgMBxFTNwV29z3+lJRNUurkHkkPCfDpdT8YXXyfTkMmIS9fG1VL6ZRkxVISueLo4I/DdiLuSAGvwlvzUyWK6ZjghNItYXtt+ot+AbCZ2YmdviW1edY+PjjaeN86+1frk8kmnDVllF0kUbbDCPv6P+2D/Qb+SioZpBPQJHuiuBH+a7H61VzpiLoCrPzjBB+EXgidHlqu32mW9uIa0UeZfWW7HhBAo+WPOhrpd6LYwC8PtIb98csv7I+Gi9ZJ0vRnVh5bgtA5Ah2hWx9PF5g0KsJYKf07Wcs/yoX9UXRFnCDblztG6x91H/tdZRc3OEp82sbT+pE9iVp7/jfxvnPDvucm7kNVraBmfi8L+yfdz/I0TQ7UPRT2yfdcIkz8lSwsvQS2+2eyZEKa5JV6kceap23VyCpdqpWV2VeiLZVsux+Gbp+OAb/2dhCCYYOy53NKlJGOG6aK7xOFoHNAI0Ay9BzGUj7Ep8gsESP3vAEMWISO+hrrwqpjLLIztxtVMz4nSWq4fscbJsYodJxZRxoKrTTgRG1dAE/JJ7SxebzzsXWG8zrb2cqBKLLpIl4BTZB7Kbjmcpo3MMis7Uxajj/NZuO8iDSIk+bpE12hk9K7NctEVCL7ytEflHJq6YhHNj35tjS8H6UHY/TQg7HGHn0MG9a9uJVLSoYrE3qDTQMnuZkvdyk4J6tlOiah43edEPcMwN3LoAVaVuGBeT2HB0aZo5UvpHXCItgv7LQOZsM67HragEG4mOZx0PDjvV3aTaWiC3RNPG7OJej0B4BrnI2WKTsSr5BK173SAgNiHR7674IOqo3BS0nl9eCmUlAUvzeUo9/bthZXVmrJ/zcby1VzzZiy9RCTiUm9K/sBu5AjcuvEFV2JxNcHJHJ+d7Pnel0L26muP4wGlCPOoTOcPHXRvBxX870cVwukuqUSx7BwI0wwMYxj0InYstNjfgmR2LQ/Ts8mpu2EVy6LQjpxemOerYnsFMN6VGh2nR3rOg5AJzuI8WEiOPButqMUvrMAU5SFMP5dUu0CREjHo2sA9LLBUFWApESoSqrUyE9i41WlZlKOdiqVe7oH94Scj1fn3QhcOJRs37DnZRj0048gGYMXlCnUw7ycpB5mE0YRPI0iJm+GlmakVnw8JDj/dVNobwbcK9hr5TVYNZigoBAWTCjwz7NndxlcID19bWTIraVV2RZNqLxPPyhUx4mSZ3dGWdlzspBXf5Pf8AZ53Hre9YrWrar6tbuWzEZBKIctt5YNtqZyALSvNWEsam0uglhLllrJ529wFrfKaDTyFOGcVvKF2CsFL/BXEpV5PX9UxuleOvXoNqKPyQT5k86gByIscFjaodz2jYIDasyfE+sReboK1VnNAQPVJixTnDNfzKN3rWOHBpRytHkA4TfHQHgf2oMeCvEqKd5ABSR1mPG2cQn/UNphW9W3KLeLULMjqZlHtqPwOay4zwHDjdCi8jzAeIsXr7F6fKnIW7CpL4D6vK9OMXTSeKYYr+bdEkM9t8Bu0iSE1FcE8VL6nNitP/6cihO1PNeHoIOJWLe19b4FDLmQuT4Vj9/xcD2aJd2cJs2olF72zcnYsJzNKWSuz7Ais3SbEwe2p+gvpcTSbst0lkYx6jAM6cdAZgCs0uHJc3C01TpquJB0cGGdQQQDA6NDXx1JLUtqhb5aQLsvNMWeM0ITdEY4oKzMSdre6eyr+ZdLeTqAdhlPiJhR7lOSzBROCiPZwuH5wUx85xfqPxd/vFENb1S2Uc256zP8OisjA0xf9V2IPZrHCBvzy8wQaxNG3hdCxHWd78Ae/yC3OQyAZ/cHzQXp6s+S5gMeY4w7n03RQg9tk1V2CuhCJ8n+dn0Ad2EVpikAG88mZrGEJHaXEodt/mFl4qrkzIXx9VhEVZgoJ6cQRtbwunP8LsIrgCcSLfe2cQIFTxWddFoqg+7NKoLkOjj/r9OJc1F7k8Ky6Dg/tHhSPq89RUQNUMNZlYK2efU0+8kNOsd7Pb6ed521eiiR3A0Cjy7lh/aueCj1nPnAOXj8qZRnavUij+4A+l86dHmfw1lM7h0J3vrFCx5TB90nsvagdSvqBWHsoLdf3COIlgb63+ue43hVOdhtb4H2AP03enQEi+zHYqOnxMTtgv8zza7TCgo9wJvOPo+sbq9KficLr5rGKHa0hd9BxU47fP5GceZAszIwWqc9aJn3mt0LyJCgGfpfNqIq+RXWTfUR4d6VyQQjrAGzi6AWJmFNrYqXVPHSKl5SxVOrcDqSuaBQ+loj3jTlUmNG3V4q4X1vUnb9LRRdkpJLohPb9Oj3A/DFZ/7+KaC9exGEfXKNweQBJe3KjYa2h2cAInD5nVv5pKNsl2mnrzE0N6qmhVRa84JyDH7Hyb393220W2d/7mwdf8gz8qQj/hNbf5E1x4a+RqLheUxJ3pUduozUQVwt1ycxRrrHXRjJhCtmuA3rppm8EWaSY4XLciGqJuN0YH0bSSJU9xGCoELeSll0PynkLcYAlmGfnoevzp4Th27HYoVrEGfTv3QiXlk2w0eyqAw5WZcpPCQW8h8So3sjl4CyRCBsoKt+KfmhiIlTwyUGvwvn6UhJOikLt5kccfaMpUE0QNJoNPjPGvzNc+7nLXTX/O9NxLMxqWO0jNLef9JMMyk3Jj+RWHvhgffd31d5jquu7cMHw4Q3533/yQpz5iRwhDe7JWNCG1Uvgok94DRB1oeho0PWCZFNmbXgG8VaEICRMMeICIU5DeBVMuF5LoZmJzMbFkXtRsaOjykOsCRDZlLiOJG3uoGhVN7CDmukebOI/wNEOkzKB6vM5nMwsDv0IxfPCIJ+h5R34oUF08uNw8PWxtHG/mbrrH28cdwyWGEaRn87BR7sZT4P9rLA6uB1CXkw9YYTksoqKkqMX7gKTPEPkixwuPc+ljT4MvAXBL6lDChx5+jK9JC7Ek4AWtB8lVh97R3FkhV/QRz27sa71m77BId1CmSrApd2Je9dmFzmylvxD6Sz9K136fhdSk6AvoITCIGR4lwZCYmMJJS5jm543i7Wjx6OPCeXt6oFz9h2L7hmI4gDGwRXlDgYRxHRgvCRj7FYNoQpOFIt5jtSFWFjlo5pYdc1sJDsyta9G+W80rLS6mQzblrhaH4o3Ke3OxWWUIOHlrMK9+bq/G5NjTFOdqbOMX/z5jS7iGm82XI+b7b8N9qfifJDitIppJXVJETGHYtsynHhIGrEA1GuT3eWyVDkM61nPbujleh6P7vL6t3/DL/Tuvc/Vz8/nTxtuVCetvy3tRpRxPTinjZklZYRULUVaMVUI6irUFVMOxcsnbgR6QJn7ITAlFu250GkO4eZQEXVVPl0bgMKLUhOzqPAG8a8hPK6YW3SlwH+AaZVEK2H/3D93LjQkqFWofVHUpSVJXWx8RfEyvoVc6ZpyTWeAmb+0Y0e4IBk4+6/Nw8kvPAv0gyDyzE9p8fhLdnaON4gbADkwg2jmEeo2dojl15wbnuqYKDbz/SfWFmVjL1lyWtGROjkjUubN9TbI2sIF6gBn9BOQZDZ7YMUAub7ju1D14kKkO5h/mDvYapmcL++DLyu42/4lx7IRRBptMmR7t9jFrExD5Tjl0HQRdz70D0fwqcQophBr6nHtQU/s1CZRjEkhzyFMJq/iqPQbVjYZx2d0FwMvenysuWzIhHfuboYYEQRQHPeJQDZ61+zjnL9L2ODFmBlHbQATDXo1fpnYm6x419ASIdbjIibptaTZL0m6KzVejxNrCXUg4Gkh7ZQaTAxI5AUiy4xa5GbFDMMzQrZetPi4qW252lijei2JVgrWdzZtUlfLrHfT5HPz2hv59elcPcxuPpoVpxhZ5+pL8QTEwXDMDkt3Ow8OS08S2FKimnW23yclbcMftgHIuEnsMNCR1UDI8NGHl/GhpHHdkgXwDhynvX0I2cdiSOXmbDM4uySf6h67FKClGMrRz/RsYsImxxICtCmQKtBEz/C8+qpDexX881gC7AaX5fRDNZEWUajKC/n2wxWgtOQ3j4JsWG2pAZ70AbdfWEc/enGPSvb8ZVqnpghh4BpCAj3+jsFpvYvDKrHsd/wPELqGRxzYI/YCeU/6FH/4gfXfgXg4naDayfctCPHYBkiWIlC3VwzXE5MNg92D450YqI/5LAg+tZUYJTH0HYtmQZQkMo/V/F/uerbJzW7nTBlWSpEglsaFQluaaWEJhgmQ0MlubQiUWGeiT0GU0BJRho/NKNPuCMvPMpY8Etum/59SMdvvu4Mud8pVMBm0O/bfnfUfcmnqGzIVzkXnjJNa4B/IwYnGYTBwAnhNXxhe9653fli4qw7PafPUAg533b8obWH0Su3d97DO96QzDDDo+LcBm8an/t39+vmnmnHvNxJNnb5mjvVGuDXGKt4kswTyyVTnXlD9OW5F9KbD2PK6xsPY5o7D3E7xj2KOMnHH0VWQZStJYFtMuNUfiwN4rbcsgV5JxWYYp13XDnNO6qsAMRzZCUfcVR5hCPUryX1sxOrn2muioMJpvODKWTJ+FqlrB9LWZufE78y777c6YFnkPHiIc9S5uR5+YizzQHyDScWGtlj0h1+xJIU1U5154LYXujY3Vvi+lgPH6I1BiUGhquAacfPh/xsSprUH0sMSI/RHBVeT0zlIHuHR61267itI+wZDjove6K3dmqoSD9Bwwsurc8nQARPySadFP1aMC3W4hp5dsf+asCOuf+siqLRvPcjeqC6X22G4a4U4SssWctan7d3D/58sPWR4ooIHxNwxmnpKfhur+QLrYqelq9Kw8jrH17zHdJyCx2JFueQwph2v05tuMNPCtQPP7WbdmsvK7G1p5Kh90M77K6Rlh8NQ4c36EYECZOigmeZoIXf2jPKaeDQX9uhb1X4qWc1ghDG4Acxa7XyuLMIY3RSpNGEHtH/j+m3iXL5ktHIFY9Jb4dfgitaaWsPRFp77Odb6acFQi0DH9NzL3stejaCAUjvWEsNSDxzWOoZw3RPFJyyr0LkJCNmBlGUtj+1UPxVPn15VaDVXyyPpICHqxGpipA0JwCQj6AlfHJ6CJSflHvO4COk34QYTVQ8Biaeo2nyJ4r9raDz5SGHIuhK9yVidatJI0KwotDpB1eOVWGROytVc8+b/W5Rx51+FzteNPVM61Z5G4/rl/sgFfSLjy1WTOuZJVd5K4aeeRAUtWuw82I3xxTePUv5754C7M6F1dIQE2G5DdyKObdQ0vGED6Knkzvq83wEu/JN/EiB8R+qvvd5RBXmFyxow5kyXLvPg9C9dOkZgXqbTKaZDtiQR69137kmuls2ncqREwE0R9okBkjhzoeEfgcCkaYEDiYb7yjRWvTBNHp2lERjqRqjt2Bm4sRtaOAyC+dSELpFnN5TcyvjvYaW5z+SOqSz5xCdoXsh4ydkSfNhc8gno1CSRePDh80t8S64tCnJUjX3wDYz02TdS58ejTT8cI0Ecc8Jr11avutc2EMvBgHEgkYoANIAOlKEjG95ao7lzYMIAW+1Ig02PbCKoR9IvfEvUZe9kAYjxzWQDbY3wT8BJkHz3C7zQdBEq6nJ30PQs7zRQxDXEs++XiNX/5+18IIveh0AAn22Br/TulEf3De67sVFRM4devQcWie8dELl44CchzdCooDEPZs9k2gfER00WgT1gTDyxfg2Y+aphU5fnX8iAg73oS0HhDZklZWoJHNMiEsUh3rE5SegL8BCJH1pJCbNmBaViR6gMmMSkXadvgSvHDLE8x/bPsMQjPoBXSQM+QxLT5ybgU0PUKBxa3AanBCDyFpXlPY0GyuArLnI3C9O6rTfhVO1UjLRbjJa6NeCpiZOVCak8lGIyjyyJgMnvKj3A9+l3C1H8HVjGbfXjefI7keZj0xQXr0y4/W6sUGewvHvGo6P8ZCNbxO4xNH/hnz4Y4s4TBoguGzhnmz0hl0uKHhEyHetLlr3kgpOkKZWCsvy2O9RdAx6pzfks0yPBkHkwtzXyIV743TXKaUbwHYe3KyTEAzxkh9f6xj7aY28hv8pzwhQy0LUV5++8TC6fLOG/9d4tVJdT8LC/rN50VwnELC+fmH3Xe92jfILfhAN7I6jtIeF4B0FCGvQ+8DudunuoB9ucEMWFiHpPAgp01EH08xhRB8HNE0ZFBagLdAqUQB81T+XlpbWwYeijmioNGu5OXgSBIEJoYIvzL1bhEZVvOCSPjFduqB+RxLWahnzwa+MQWakmVr0S3MwgS6HB9AoUJIBuNurxTqazyeHraNtctRq71CmgfIOp4A0wLu4BwVq0lgjDrbhyFsL1ft+RKzfn93hXXvhBUGYdfmCdtlYfVm9JxehDVZenw2u1j+sr6Z4gs7QgH2PpcBeFg6RKW9y9/VDmLU7wld/orOjTlC/rvkV2E+LmDDS1DKZLYCmRWRlgH+t5sjsfirq0mR94QfXYCNFZw/gC5QIsBjxWmlgKmyvM4QAAuz4kdjtO/oI+AA8yopvQ7FjWorh8JuCPbPCF2nBNzigOjG1sv5w/YjFkFeTq4aqwliF6jyw/e8J7jA8TrYZscnGP7NxHxUbjZcloDARZQIlw3/+e2rg17vpp3s6SgKTUnAVDFRB1YsKO1hg5gEfX+O8BzZoUPdNFl1FhbkicLPnel29qxycE9P7AuwnZz4Y1WoJ72fmWU/fgdLNLKVO7SRN40pOZ2Z6O2sbOF+zZ19dbguXUsFF0ZSP01vTrRI63SFlry27Rs7x5rbJc3Jeg0vxRW7bVYErlvtYI5Vmo1nRHv2oduuAQm/7sC3jFVwMok2ulavA47fCMUfoeQEAVoAaMRIWWo/8RpboQKUWLtIWPjmehywEsPz0wxe0srCittJMWjlC+dq53VWmtOG7fZuTSGA86oQef7Kxv7OX4MmgtHQKF/J4Av7FldJdyGiFI8e55Qnz4es0BlXBGRrvZ9jYzBapgKMtyobqEiwJL9ANg8HA6TLWs6CN6LjnRm2HEq2uUGp238AlvGPHdkyYZ7mRyT/ByI+OwG8ysXDXjQZ0uuRN7isvvwr6Zwe+A6qqyjndaV8qcEli0jxJiFZKJ2IF/2WmqlC9t7PU+cDRH+dZl07TSvU1emijRJdD6Tf/S0WmM1WG/7Fnozl4l0kQpMqLUMX0fc7HYv75KACBn/sgXxDd9tzmb7Nz1+/Sqxu2ygfH7jqhhP2Wkz27EtRsbvLZeL1sfKnp05Nvk1Ql+b/gPtt2IMJCAHEQrEojYvXqPax4Qp98dp2nnVaqqW0jyzZISllGw+52W1e0i12MPeiEVqVDCcWXSs0sXxXMLVhfO3BmeVswBnAG41nreVU7aUSKPJPtz8nsnt2l/ejuZSlx4A3minmzrl14enn2IHKEcWdG3/xKr3SSQpWqeRYxKooL6tXEroRGZlZuiqGz5vqZJhIWFjGk3bfDuM2S5eeaKfd7GVJs23Cqb5+GxuhThQiDse3Ss65aZLUdO+z0CC2j2VZhzmZS8RHWEkpNzf6hwk0J6udBTNcfLQrWwcPr0vXlNG5gkKRlZgRXdE71OsuurlfWzYPfAZvpgoGjTbVh6FiPQUIBvBMddSWnDOXDO04PYGVRtLPtevRoE+ayEzUajbx62pIk1hDN5s/r+bYci9V1g03FlT2zFGbl5dw/fEUSg94YKMhrIx6K5pGi5BWKhlZnRTT0OOqiztMyGXl+3Glzo0owVYQAyGBKyISZdGj0C8jGWUKIpqyqYo+pMfJpSUCFOrQ9J44dS4WGHMkPdpvjWhgHZIZu++UXDtWGDsVsKbQRaiW04UkjicNbtQWwG/EgEC1dMq6W2omdPmM7wOT7jCHzVOT3EN0TlKpbiJv14lfiXvpgFv7rC7m/Ql4Tm62fx37GWU6BzCznk5kCaOzFhVKRGXwkHPZuI7cToWl14OlvJEP+xCQKM/BGUqanUZnNHnhIECt0BkMPzJ4FZRF7ZOHxsCoD1lC9gxXgkUNXJM+OZCSgbaNJB3OD6y5tB2EHXgWst2ojsULHXtfz6x059GVC+bU+mJqYMDnucyNz0tXYBVTtLrdne2AhAMdxWsuAfVUbyciKF2EK5GUxn7wUyF+Wl8v0ThoEAzRnYszqZs8dSMQlJ7uQlXnCl9KjUMQeR2cMM7VAnqGr0CGVRcmgfzD/1jwTdMBg1sAzAMwZVV70SQBerW0ntrKmGn17kKBGQ0l63+KIrHcBXQTbr1ZPG1EQykLLs2T0MO739LEwsCqsGkJHR/SE4781+oDB37oXrQnmA77GaCNF2eo3jhR7oyPFf+lI2W9tpAAFigC1kQneFyByjUPGwANvcczo6+vgk646u+KY5XJxMdp3l3gYY+7kMEK+Mwuj7/lUBLPTrRGX8vB0w7NjgMDOmk9/xyR5UWSmQptaXB9B5GM29+HSGden//1wvLcLYghRXoFjTIXK8Cs/fDmd5SMERFiRVmHSVIA2hL4hpWIqJUc0hoGYSo0t1XajDUQaoW1ng5JEvAISidpEhMGPgATSbzkFyrKUT1lGhwWZcwYmXXNFt5ollpBZyTZa16WnKkJ3Fe5uy/FqNL5FkKhs7+wet47azGZAlKlospFEgApnTah5knZ7qlKayDGrYSDTNDR+bhpdegxiJwkeyOzhQMBBLsKgz2kjOPj2gmtN12tojhKAtC1uRtfFOOVpSz264g+rfelpmizUxpjcQLNU3ACs/Qf6ccND23c8KXytljMn7q2PO8DyNE0oPgPIKAK16kH1OhbTQK0wtcraeADSalrGDuMB5y+VydiB2WW36TIaAtylyfNhLve47S5MEZGPIhbEBP5h8I2GAwDlWoUnADZkHZur6PGfoP0RquMwTNXZuEZpgZWs6FFh2AyqfCYK58qDRAGKd8f2HB6QBoHAK82Kcp7ZZKp8UkpLOIWRW0rmVc2mqLbH0t+mpveLrK16vTLzprWvyif6ZxJb3SoqTZ5Z35VxjKGYeNqlr+JOQeyMBN8o72TKwGqcnmDsIs0KQDU8enbndu/rtPBnTfL0wfa7HmDQDEKHElCny6HwI3rPwuFyAXeF3rOALxuEqLi/tsMugb1qx1UDNn8baj44GFrws05dfmKrkCd6ZCtJ6r+TfZy4YHqAOYYnMrOAyHkip2MGT1k7jJxtL7BjizemxfxOaWC26lXxEzSSyAQz6wm3VCo5/1ngA8bBV8lKQUosCxlJ5mQ5Bu+3ELPaaBXMBDkoyZfSucFhgWMcfavGNtyUlLeGOHSfwFlbagKc4j/pJMi5/iBHi7VvrFUR9mm5SX/pTfFaz1nPVZkYmAbPbYpo+2mHWefPSWVw84R3+YT8xl6W6fyBnTm39NXPoTHze8HXPqHYSpunpsgHIQ3bzqSHt20EMhvH7vQSe+PHGUdzS13BHjq1Pc654USz5sTO1+0abraf0pK5Zsd0Qnv2Fye1d8aZgRuD1rFiTgzSq0paumJGomDwVtJqGYPeM67lcQJ5VkkWySdrynqssyIVc0XJEnw6iE5jRvRYLNWLYQyMuMXGq/kUKpjR4c7wK5gwZjDDBCwDYYJoWy6gajtG+8SQXLhhNDkTRZPXkWqoo7iFrCv5aHTJbYv13F37lm793GzNnkotQL+nY4dgpVNQBgf4bhjH9LBI2Ujn0WRw375yL+nmC7X8j67DwwkxJ0q1unxNrHPdPzqBkSvnSUiKLrMs8NBaKDARWlwtnY+WuN00WYSaWSr/LPmgKfwK0A2CzhWEe1eMo7mvZOwK7avySO094lXT08qEDwCTAxvf7ZBzdjQRHsK/JZZz06Gbgzs9VU0DpQPacq8458MsAiTmysRZKYPNmjEB4/Es1c6AqfvOh67XZfq+qBOC0bJquW10ZeG9TcWH84evlYFAoEl7jiOEKW9OYv88jlaoE7UifgEqngDf3SdCGNe4nhE4ZkStz8YCgce8gFKWLrl14qf3nTBP41EeFBBJyeg+USM5rZtcKWbXzudVmbgQnWdU3zl67sRcIDB6nB9rhEZLT32ukGn2mILmaZ4+KgOtq0mYxVoR33FF26hDPNQ6K6uzHiy9QBaaMBlveHcmaUzWDXoQCX3w2ql0huYbJDM0dXyLvj4LqAZtJFKJPgsUa3Qlx+L/9//yapRWnfHQa8l6FzqZQxBqXs6CFjS/DYmc6J4blICSyL6iRJRurQuH9tsBwC+6TCTwvVsyHVHKeI4RS+Xyu8LLZgs+Quh0k4+qsTamAoVkZ3WOyY5xxgYRTFcpwgwNofWokguXDXGMKyftna3Wu42jUwI83C08ZpLGCNZn5xLwcTHgDfpiuBHnPDQxpmEkDIZTeDWxWMlXTD5btzPW0SBzxUGJA7GSAcCI0ogl1Vwnqu2d3dbZx53/PMi6wf+Swg18GG3TXtE1yjKZHifB3o42Dj+c7R1stUi64usFLWMwNL4wOcVn1s9z4XWp6M1ldnWIVEZJnpiWdtZoizBPmaLw+DnqNTzzpkjlUixwCz5k6+jn0ux28/IndheipO/C7kjiQDlxSjvVNFUrwp9Od5+5Az7enDdK2jOY9CZ+g3ExN581gUUNTXiUeR6tBShpaADxHt7F/miNYGmDYeRPbDXA8gL6yfUX+ElaVSgvJST4w8Bd6ND6oxo/jyb9oMOZAqVZzqc0BRfh0mq5rB5pDrNe+wg2YnI4DS2rLGZL8szQApIZ1X1P88eJGiwm9oqiySBtSw2MN5LVoKkSH141Gadi1ixWmV2jp1elMjoE/ZkurFOSS6Ut5NK4BwyYH5TMud3HSOK45O2RIjLN4ZU3M7LLazJBK2lDE27NthauXGcNVBaQfORc0Gn05GtTzysLPJAyNUUODgwoQMzTvWCdhawI/A4laxYxA3xMnTipYz0AinPU2j5qtT+MJM7hZRtxLwziGACRNelwBl3M2+cjY9g7TIrGZ27uQyxfCBpUg8h1qHf/fwsslNX0Tut44uXXpTqtjt812ONLqWU5oemkrJEM8nMdWmx6SfXQgl0RNxuN9zXEfVo9tamDRoz1GnBxj2JQXy1Qk4Nc2R8OHmepLFnVNrqhfXlJP5cI5GzCcDa8b7OqpttYGg58qwR9dBhGLCJNJde5gObeEfaR1lggrlpiLr2GYnWI9Q2OD3g6opmlJAsr5br4YWezhD8BOFa2zzPmlubRrE5OJjEGAxAuB3Mu4ElIme5NukWGsdNtwymw0pOR/JEE8AD+/DAMBk4Y37IHeqVe54NlwYt17phDaDHvm2/sCpthksGc7oyWLVybdvbnztbxh7N/tT7VyP9pH+wDDiH9YO7FrXWHa1Hj47yv5pq7FMS4FbR2m8HQ66ItEHwawleI4JCjNfoScb6Tnd6P13gCiS7bZRtQ0fUCExPizx4uumKlboZGzzXCHQFA6wfA+lMDrLNvOBLA+szqsl+XDLhAfIeiUazMlJizS4P3p0/PyoPjEl72gk0saMY4rK75MfTeiQlXiDMkEWY2v2XH9h73WKLcPDahHtatPQhUycxFtvbWTbArYM1Hi72l/wFuBJVtdAZrxGLYvGg1An3RIkqKVWXgoLTwyamOMup0GBNE8EtGZBiBiU8yEzCpMa4SHy7aH8Fo2KIqAhGwJPZFvaAp4La5JQZKU/SmO6YMEqzqn875+10wFGL3R1aGrsMUoAyW8qEMlka3lCmBK3U+F5OTXUqnA6Oj3XjooakPEjN9j4yOPTprJPjl5LJSBceqTanbgPCoSaCW595J6GHAR8I0+fqc0jrcR1KcnEHQ4voXAX9BJWGfsiYUUwe16aePphUDQnxsCqbFcsTX3nSMgMdzOlgqFWIbzWCetAq4aJZYSrKSztDy8B/VgekQbdP1ENTc/NV4hWNhg+8PpLPreFfvC/6nFuBjqqEfd07gR96nUIs5cD6kQtEq5Hcm0yODATNrBmQefBGnqA8d7+yWyl/ojEnSmU3NJv1xKatazNmlsUXQp5eYFKmHec8ekJ0tMIOnG9jtCC/oaxelf64edJVWA+aZbGLwVtUqgB7CSufiEqEZ66A9qKyZnW0S0nB42No42tjfbOX5Naol8I3RBrRDZtizXtj+Q5FL2BMGmvxoeyyigeWDqRG8wxaq5FeSE6nknN6kX9YLpx8M7A7d8U+zAgescb4Gsxv3bbF0Rk0S9oVm26TllsrEScH9UMjJEd6z4PGnRROBnAdsh89j1IQ6Oq5AUtvw+mAZ4/De3xbeKAtW1KFfP7QPg8jFaE135AZ32S3+9yvdpc0mmFxo6Zi60Gw2TdTlvsh1UH1HUabe8aNeEGuy2TRnhKXPCsvrP7OkZblUGhoAtzfDous5pYRFl6eJUrlJQ6MLvgd+njdvGvVg23U8eJKL5th5hpSFQ5LtOVMwZkBh9kx2ygrgMh55aYjJ4JLJwkahlA6m1PAV2AK17BdKxJOy8Dd0hj9QBwM9D/0vfnDtV4pagQ2YtAJ/F5W9sPuud5uUZr+gI4vVnln4+cWFclmKgHWOwexMSS8NtyLMyzI6UghYjw4XtBUEsR81eH0GDGkCcsqLU69aWimSCW52BXKImhruhJtg8dbVbG6SlYLVmvKZUVvaRCO4uKBr8EGxtpNJULpiCm6l0QCt2ObMj7j9m0jwnAb3y95yLuyhlwHmzTCuUwkty0SbSd2yTM0tD+3Q7EXTY13jZqij2ZqxsqCdQNMrxE63JGuty8Raq7V5vHOwf/ahtfP+wzGYa7HAC3f3Oj4ra/QkHdMpKg4gcSS7MK0nzTCM9zBpgzCHx79h9OY7GoT9cBnh/AC3n8xjC7TscnEH0vQsMGh2jW+OThR9tNE5xE3wTMBwskLeEs0SlKwRo8mmzkowuwc0XU3CKtBJW99iLMoGWkXKsfiqKbMYkTjbMTgNWn0N/2viIf6d8Rj/NuXjNNekSU+BtXCuFdZibiK+zr+HSz5pMWWWyN9FpioGtxf9II7i/cLMqMXzrNu/r3+TMwqnY7PqjGKmX5pPCpIpwSHl38whRSBCTSQ4s+3wtrBUKnpAx073WYGnSl6B0jAcpgmO6LDCTv4obwjV4yP3CQGEiDXbAE7GqOHI4zv4OY0y5kP3h6kRsfX1PMMnyP2ghahQJbpQSgk8Uc1R+mYNVoXG+Yi5489nunId69mdMMJ7UidLg5vq53ynWWXVQu0NqC/b7DIbZQsCbcJOix6BnfZ6jrHTNNRRleFArELUbcIaRKjXzNISYEY9ZIaCuUZPDodOlfGsERCLY7kyDOsoHya2iP+YBFBsLnxFTcOAxXecCtOqo7Ii75XhsX4LwDRM8Ax6pKPROjahS4cO+fWFpu5lOJS0sSnQl9V8+rJaYPPRLF8kTimoimb0oeVOzGtuBmw+lHgy32hizgwiHxvnIicmBaMc9GifwNHmbZ8Kb5UnwJRmnSio0ixx3QgKLZvTGqGjM0LKAxPisTWOoHAZxJnDJM4Nz7IE0Mdo1IY0dHZRX5dLxrjwWEzsbCnci5ZXGBTwCa0+NoN+n/LRT8a+SBO1kI+KTZYf9MgdfvjU3tlsnx0etdqt4/YJK3yqmXnkSVL4IWModJIwRUbgqwzYmOqdHsgiKVEYNNifEnZQXi3P9b9gHfhjpBqw85yQ9YN/jlSra/cHIGCBavxvjYFh7EIckEvZIXB88zdm9tZd2g7CDh0MX6Iq6I/Q984yrZVacWYfR4vlQrKPQJ1AqYLheSSll9WXJZ2k/jj6btF4cEzvbo1BIp46Ds/D1uaqC45qfN5JVjR7ERaXZ+/IxAlHraMi7SYDjZjv8WbWW7H7jlR+Zr1xl1ZKFx1QDxep28Qbi5TpjWSKmamGNx7GQR3KEnqCExaERbLogZDBptQm7vTAJ96nT6jQ7RBEzZBd0XtuRPmhK6gqudnUiOp2UiNO3GlohvjgDvSAKAa7PYFz+Oavf2CFv/5xKr3YWCvpWwN/5oAlYl7D4EeURTvFpUgL1hDNN+8Nxtdhy40GKDChjE00cDqUaHd4/GG6Muf0TdYl9NvsbOW2wFYS3WEjuvbJwflKK/J2SJd3YmpjZt9IKwul1ByJ1lhm1ZFWonS6I2mG1ne0QDs4/y8dSwN2gutEqblYSg+sE81e7rRYqDKmYa0h+Ci8WwwmeqaY6wqsY54V3YP+ON9iGce/rWIcF63NrvJosXR4InmWKsbMQinM0+Gh/Q/c0k8IJJJvtDJBVa0Ai/hwW8yGTm9Mfi2IGl9VHZMpgHVhbz+gR6QLfi41PLiUOOUYBTJbv2oOAACyONmEdA/FLO/bRoENacOQgaG84Nz2CDZK0Ho+MtjaJKOYDpLIj/BewMUEfr45nCGvLBCtytQs55ut4RgFuWN2qNzAS7TuopfxG5OpmEaEuo4X20aTXis1ZCV13gPCn7E/aVqar5O2vutP1KC3Uq/TJlWwWWbf22zq3ds3E+/evjF2v2zo3ndmFsx1/p35mPqw3nO8AYBSoWzXvnJA5pX4nkvvImPmnDgOa3OVqc2rRaOwV52wiY3hkItpyEz4qZvm0zeMkxXaP9hqnR0etHfwebS5sfmhpSqcWLPgV4x1C0hXArGYB51I2zgR9VkM1DB5WPkoCDXKWdCb9gbFuak0N0FFbNzK6caXEY4cxNOsKRDE5LyfbtZYqzeIZsA6QEgD/PMrzKFZM1e9Supe3bBi5Cpp4uo2SUlauips6gKbmoKkdyFf0ju6O+BqKSjOBV2Rr44Oi6amT4yBmT0yI05VpjCcXOxufDr44/hs++jgP619iKwUDnX24wE6lBGVWSElRpLBPPpvILAyVlnPK3KbFLnNLfI1KfK1IHKNyHFx9JUg8OABdex2vkRWs8qiO7fjYEBZu/7Qs9kTt993ui4Qgdsns/xfLORUFkflVBQbl3LQDS7lymVW8vKnJ8IFaajzpITDNEeOPWwwqXsMC8KqXITBV8fP6kh0SLO2y2VTRqISwiABP4GxDpcZ62DyN2Cl8+nITdJQN5+Q3GZlcinJ16zM17wyV0JnV7m9XQndXeX2dyV0eGXqUSc1A3ZLfl87F1mO+7oUdGbo53Eoek6JeRR5siNxKeg+Nz9sSsZ5pBzKuqnE7YMlvuaUmGoMy/GEGgsL5WQVTMDLSnKhFmZ5Zmxhx2UUUqPxJxVhaL7CIRlwzoQ1oIDAM56BXfYYXVP3OP6DUx5CFwk5HjuMBUY8K6uSKE2xU2R7KjP9i82E7d/wvOBa5PvjgIRD32yFeuT0HDtup4Wt6ghWaXw9AasOjNKOAzt6EFjaVMeqsImzj03qhJn0TgEMbSkfDK0oisT8x6gx0BrKse66/peW3x0EdKl3uiLFMWZOjGl4ejfCsWiPNmkLTNhzkVEcXo5SGij3tnECBVV7/LTUL78Qfo6yinB2ArQnqRjgXYGnSAvThwVwC8lPs0JWqTPzl/hqSQ/WNt1pxwjkohwqOaPEXLg0V4uXrtE7KbY9yIhqJLS77pD++7UNNpv+pR4pKi1MfntjCGnEd7sJXDg/YEFMb2cWgj4ZFXkhDAtAz/fsuNc43KF/LWq8hRstbWWsxU77bGlrXTt/yjjp8LDJThBZ2Dl0wmcvl7zlJSPXf6AknSYO5W02jbowDTqnRaibrC2hqyJjDv3g7p+WMMSUTYvdQZRaWh3zBNXISkyfD4IgTE2xhHiZZ2KVTNLE00cczoafqeODg93jnUPmQKFcplhU935AwwmHafKLrKriYBDU+egrTwC/N6JZ0HhHYqVUJwIeBMf0c/CNoUJ+K1kTQ8iapXOhzJM+MWPnMghva+SLQ/8DCuZvOy0/8eNikE5l2cm5qSrndL24cK7EK+45dA7ZANt7m2fHH1oHR58KAIVZJcpBJ2twSv+mq3D6GBxhfJUfu30H3tRsuD3KkPMU7bV+GAzg8esQ/tmS4Wg3Pv2n5RWTFWygDiUNJp+xG3uO1MIUXrqL+S/dAuSt5bkHx5GIDH5+M5ExZM2JfdAjqYwyUSvVBidy70nQGLT+eZhCQIW0/+Jr3IDdcOXqEQuzejzXIM3n4dGMvQkEAuwhnTihH7k4GOOOcpSR4mjpflppTgcbeELBAhaWSseapLJKlTGRMkrLlmSi2j7dSnQtddtlThs+7Owft89a+xvvdltbxkPvOfQKZKLi/CsUoa+wlA6Og8katdCafCBafFoHBGlviNijsRSe7H365YsLyyie9mDg+N3Nnut1LTbsPLE660QOgMLXel0tpWABixRGXqozLJ8wPDJDJOeJABtpxuQJzOtCtuT1yICgr0rFljDG30Bcyk9Y8okK55UfIhS9YfcBOmEgQRM/bNLJYvXOYvpTQq4R00dgLtTuixgKuusWF7Pgafcz+6BYmHvXgxhCcSdoMsfwQ0GSSdPm5NDy+SgndjUHQgZnZ8UswnnfMQPgXbiXwmvhQ2uvdbZ5sL+9897wfIey6CuAfzbS2MkN1+94w64TCZ0VuxR/PsHBnZI/WNAughXXyLO7tIX7BtlIOoAM1unbrNe3jf8Grm9VaqTCHL79wHcq958fjUzDwbUSukXsOA7d8yFNAqiazXabXNmhC13y8LL0oxr8EzW4YSfeSFqiPA3g/OHk6ICzZcoB+rpkHpEKmh5fdw5Mw2QvrJ2smdHJycXQG8s8eDHfPLhIPDH35sEZNUFpm0pOpMR5kUc8gqCk87MmQkgeghzg9EFsCHEH0uNfefQ53+w5HH4KXK66RnRcePFgLvYPpv1DT4zUbMCrkIobESpSKF1OAEYEYaBD3mFouhFrkDhhGIjwfxolixxtbrDodOe5XUUdk436l19IPkWHck+iWplUtMOl8tCVSwOXcjkql9KcR6KSzO4baArX2/PSb9VLco3Qqzf8Upkiu93M38gFOsJy7eOUdcPPGyk72pBbyr2tzHPyuzwl2HSfn7CNfvpjp09vp+OQNJotp5aQF8wmOClmMFcnnT12ZMK+blBe99FfQz0aeRHsdvyuc5M8oiLK8dCfBxcWz60aUCJu0jqW1MZzslAlPycNeQgmLAeWFp7i0Una0Ok0hUDjsVev5/2s4tmq00/i+lwUNDyPOvRVLsuCxMSpodi0k15Hto1WZiOf1dXXRkFQ0onV4Qi86ZE9S/PCqDEYRr2sCN+Y/NrRhJ5iTQSuERqiA6Kb1+ogkD/9L7hjq+2CFePsXlAr8+5hqG36szj44NxI8E1pysyCNo2x2dmsrOCL18l8cBLspV6NdGrEQ6glLJFeNyAcCPwrJ4zJwb92Nz+A/409GITBjdsHcdzR+3diU70jG/SQPcHe+AVZeJUAC3FTZbiKkhJgPgy1qlKRc7EI2A0nRdJRtV26QRmwNx2YfQ4D8+hy2CGMiVjCIKtiy7sgipD68s5o0i69qpqNpderS0sv6f+Wad82Ji0urLxqLr1ceblEk86lin1WsU5LLTRXVlYXlpZXXmFFSGquLr1aWV54ufhKqxhlFZuvXi+/oqVervCKC43F1wvLr1ZWll81eUVpsEsw/jOaw/8jjwhy+5DB/4O5k6cmy4XUZHlkdvflvOtRNHJCnzZH9rXyqOMp8/GQG4O2sClaXbfv0E8X+DWSWDymlIZflwPbc+LYOUmLnormkaCroMQIP0QHdgTM3oM/lpszfjEulo8bpI90zzumHUUXQdiPFAWhlje5x9yOfxHaEV3NDt0z0r1pyOGbPB3L03KMyrytOP0z3ekcSZl25l76WYEaEcpyon3mB7F7cZsxu5FVSUtBoBofA9XIFWf3RbRUOuaQErZ2B56mGINCoepKznwoysej7sJUraiTqFbpzlQ4SZYHZiH4xyHl3qKTrEIigGMmtpicyDcS/jSf/FcVTuiKdoPsYd++sWgN9jdlFRdgXBKv+L613zraOD44InsHWy3mjeZQzpAup0fSeVqMwb10gr4T06srGysbauMSEH7pZw4Fr1ctq8BznI0b+et0ibKa1lVVl2qe2RDrKSU4nH1PnooiO3x8cNjm09tyKTlxKHOO7rIRuXbjHkEqMQhEp/3ELDoYRNl48CfrYAqAWuNpzJfKJ3sBdU/ylVUll5g+MR5ydi9ZccqWykDekUajkV6Ic8UUluFCRHLEbgNxlyrJcyLXH2NvChMVLsJ0k6aAJWAb8SIDbY0DZlwJgvA0HihW1y5EzR7tjJVvd8xmFyYekrWUMZB3vLM1rFwjOCwEhWEpMgpjYm7iBZdW5WTzYPcAwlvA8OlMpMHXyDACN2zanj30YnbH0O8cVfSrTL2zxmcY7vShcssYPtbEco5Pmi6AsLQPDkxdb1538kRmqZDrXhrZT+VVGS9Dtvz0KgqMXHeSUWaRSjZTE6n5Zob7jsCqrhGRn48oV+xTtniNVPghqqSwCsZqDV+pl3CRPOGpLugJeZ8vl+7odJ3z4aV4ZNKE0h4VnKElHQzt+koZSmY4vCZKVUTNg1bxkAksSSqwjKAul/F8cW4ji4s0q4XN7PCbkfQpB0EXTGslvTqL22E0QastnP4q17LXSEU3CDW2uSFe6dCydANWZ5rDnn+oJdPll+wW5eoTk+cELXG8my+ZaHoq2O10BRFMlAuwSArEykuSoDeT+l8meNkEGx5y8LF1dLQD0pedC2L7Mp9M3IhekRCO0+kCz0wTYrS23tjdzZjmtEmMY9m3vzgRvheWlvDK7fLGImJduaHbdaMaGXh21LfRayLs2x6LD1ol10H45ammjB6ZEov8yy8S9yFlnkrsOmchFIHimT0F/mApnz8owEhcbpaSvuza545KXNK0MrPUOMlv11O+bXjQEKgrk7SZZnPLp5z03IjTEEkvqSSXdisL89QkpHl84Q/1+feRYRjlF38P2YVJbsF3aY68AkgqF3D+2KxT3azKNi27RruQCeA2iHbkYNjFIlZAFLBBhcfos4E73+bmv+QytG+lE6KqfrH1pzkXy4Vq2eWRHZlLdy6UbyBZCetZsxudfhx7YaPlgXxC0NE+KSE+s+Fk3wp2SywDPIjB8oG11eiR5yRu9IZOu+dexPTH0moTnEXoP+tZhU7eA5+eohozpmiApXDc6PTCoG+3O/S8pkI0aMErEBGw+h6OxINwzD49Mmw8L+hnacrSAzYtmxseh6jWw07xMQ9Ii6A4zyhC3MjKgq3/gqy8SsY1CK6tDu0PZ7QAwM1ZPYA7pumqkkojMokB9xNRiJVCXdXKyLqq5TIa/G4IAg/VnVPJKjPPJ85Ve5VIUqEf3N1UtygGJDEb8hqy/g52vMq0s92aXlnZvfSGJNdRlilcNTSfnlythHKZmBrJ7gaxicfaBM+2SfBqeU2C30MEA9r/ZrttfOIr+eU3DxYmLBkJd93QYUXfkAqEb4KjUZmcIUOFuX3VL3n/VtJHjfxzaYku7T9XV1erFcV8GGfaNti+UjZxYMFfimOnUA38OhX2GCrojtEDJ+wwF21k9ELYw1i0gbopytstNJsGs9/PAOpFO7onz+54G/c/f06YwIwnTYqrK/DsLl10us95YzhZARnsvvp5SrRjIih7pXhPasRdelIac0vlhKpfbs4V/QyUSNixbfa+TsJGJl7TUo1pCUTG829cLN1rJ/MiUBDepOTS3nXCPC2sTkkU/rso+sK8eEH+dAjtbQiqfwgNTHrOjRORju2Tc0f0n+4SFP7RG4s5n9C7JUZMsC6tT6Kj9+/qv2NO2vI2gLSh73OHzpU2T2IwF2DTINc9t9Mj/SCKvVvCXUtoxxeUXWU91Mi1U/E8Prq01WjgdCgv2mGF6l0ndBErjck+IzL04egQOu4rt0szQvsa5tRIG9i5oA3T+8j2aMe+A0WC82GEM6//jmIW6Jpl2XA9gk+5E2YtvPvjuIZyFKd76ZDkKotghnTB6AfC+sFF7PikZ185OIYP7V1YM754qPmKsiZ3nbhCV3E4GAQhvYzBJc+/5AqyiNz1ap2adw/16SAJfY6AYRaxfBssN9innnCg5wndjEsLZdRAbDKZuqthYskZZRahZDPN9BNF+l1dN4Eu1Pc/lL1T95U2Kgmix3hvlcdHOnsWYcwn2W4PnnA0GW+uVIghPrTSVIyVRN9OWP8BlxeDiOSOZL0Lsb+f5GRMyJdj7uF1hm69b/u0TpjCAatIwA+eg5cz4yAmzUZBf3udhwRsSU8Z3K+QAvD/9B9xG9O+hoM25afOedxtOWcr6HwxJEMUEzmS2dmAB/3aRnwpJXOIuNltupuHSg76gNHt8NXpoiIvPWRTihi4km/MtpJ/Rube3Uk5I9I2kMQBakbhqVn+nvrlRx8UZe8bgnWxrKKgGbyIITbdeezzo1BUn5aqM0S2yNzGphegBchDI6h3oKAaTINH/rjkYXlNwTF4fSE8BitvVYKB42sw3vwos6m9s+kzSQ5wr0XOydahKqxJI/A7lDh+gVE5pmExQehhGAzsSyShlh5yCIep9q70jetXTVcS+51ZU28FLftlSegK3hY6VUmTC2nK6vyRFH476gQFgl0BOTipODcDOiXgECvQZoR/eME14gNrdMiJoUk4K9CC6bik5OF/h05420Y/jyDc8Dyr0sAQW/QAVKqpHBPFmOeGkDhMQ16pqoeNg+Zh7rvYLyBIn7G7Z3fwjx7tA05l2ko1a1ANDpSMQ1qNkSaKFjCBV78Mg+FAmPIlTPmSUpVbz2l03WhAdw0ogzAsiXm62ETRVHGWU6Amy/nUZLlAQtMsGzVReEyJpBjyCunK67miKxp3rUUNPGMsvwGp+cUL8sHxBk64RjaRKSasFbLZcweRplzEIpiFSMr0ONn04R3udEHMPPTjqMaPbduJTaQoi0CM9QrOj9C2iU78lOZX9eghvCeW33B9+t8Px3sArFmpaESDjTslBdYJPsox9TQvGimfBl2HR4ZCFOIbR9yt9U22Yo2eHYHowViLdiZFR1RJCz3y3yT61aCPVvOhj1YLXj+rpWRT4K2rcylJ6uwa1o7JpbCnvbj1KaE4AqMksmvf0k1geI2w7AfeM2jYVPewDS2WYNJINW1OfAqYDiMasTKgs/ehPeihFWslxbWpgO8nZlRNxxhzGl+DoH8cbLsx/S6ysYMQBlh/v9AF2Up97skxe0dZi1svlrZInUTx8LxqWCRa5aElyjz5TQtEG6jyhh5aHNGZ/q9/pINN3nyhQ9mkKHa6f/0D+5kCr7KQz6sUxQlaKRtJ4XhEm4EHLOom3kASdckrMDHF9fenM6YpWm7s9JGH6NAtFoTGCBVQEGCmnGuyZw+kNz5WT69y+JXLg4CE/03aEZbVGX3kDOg8mZrA4gmXLAEjFzarGEJClDMYzKU2wtC+bYCSO2kDthxo0arVBu0+tiy7Rs7xEJ+fLJxSAmLTfwpiTMyClvdlWZ8QW5Rb7tsD8xtCzJycmmB2XhHJ/HLCwzzIuFeYyLLe5e3oEYOLWPeR2PZsMHR5MIgFdNZIE1DFrAlM6eYMvKtkfpsYagYqc/6BR7zJKSWBpspk4m1hVbnsGr+pT07XzaF3YEDGdqxkdrokeGPzeOdj62xr43hjb+OwnUXvUTPAd5VSTfrSSKjmFO788ZQoSwtlIy6abFyiLsbcMj0rDKoBnb583Gmfbe/sHreOhF0sJiL+PppBrWVbuUZi1wnlFJiYmKIw7+B2Fwex7QmOD0xvAGnP34gjaWB/jcj96jxUEscxUkkcX1JSeyfA+oxAYrGcQTXUd3333WPaqEMNRaCK7w3IrLLxMIJ87NygUyXMSaHraa/ih51ZS4bFkhIYpkc30JYsY2YNtselKontgCr3ZHYNv/zC+QMfNCxV83PAT7kILKVHgsuKOmlRz/W/FBaNcGD7XLOTr6bFYnXsOUfdwIq06OkapSWwUI0MChLEis/GVBUHKJ1vfz2vIg6hKo5HqujIQZyfKELehGCHFsqmBAmdCzqBnkEFoucUAvQ9IQb2/4Bu7skogjxPmSTkmiHNrnvi4tzDuyk7tJALLmSCy7VPH2CHCyxpfmzWp9usV25Ux5VjxqFRgvMJFhaSmaiWU7hLm7OCdirOT96lC80Fo72oNFFuYaIDZu7s00fNx43dM4jv0kY1JhZ9ui27WMgBLI7pAFeCLZt4aHRMu9aQOR/eKmNsXGWuuXt3c+O49f7gaGdzmtv3h6OKafeeOT6ggW97wbW6dw1ZM/uMffRmVSanP2RlEfUFL2dSdv+klKkWaMx5UaYOTjovig+W/M9Y0SrSnM/6S3DujVaUg9R1o9yTZMgr0VFSZvctZ+nxR0np/BFnSRv2j8M0K4cpuvU7f+xsh0G/HSuwAoYs8SHQ/jg1aIE2ZdLdjvNk50qZqWYb9tdwcaXZFP9LPrrONTlEgy9yPoxjMJPSi2WtFFlvD5jd2Hnsn4Dktc5+n4pW62B4nmPrwUr/Cy0+aLkGNAHGZSx9Pb8KAaVN68+zw6NWu3XcPkkbOjVWEmw6eX1KRdhfDfzs726RJLCV5ylKS+eSvXvibsNN3mtpF5rFyUNfA0MZEKRKycew2LTONg/2t3fek8vQ7VbH/kLMETf7QDMbm3OlbHc9Aj2BJF676bWc2VUoP/6ilyanv+70y7m19b519v5oY2untX+MTz310tcuaHqUWiLYB3PS0bkASG7Q4Ydx9Kcb96xKUqFeqRbd+oYhvcE+GqEz8OyOI7ZUI5VKMVtQNHtpuR5iTEx1ZGe66fEg49mMLiyU8ZTzYF/6IRcySnfG+dw0luPAB6xjRDzm4Hw4MUDQodvf9dPARXii5LPBhsHRSY7pQWEnIqmB7L9UZgTmH6OVFbwjML8hBGgtogxaYXnIRXSAOF7kGCjZjp8AyWNYcViUGo/6aoj4+r3mOQW+YSGfbyiiKIsloyhcVYpOEBJFUTNm163/8RRFnJvBwQW+/TB2CJhiMHKi+cBt7WWmaVt7mu0Vc0NJS+BPrZDPLUJoW2/pf8CMY5/7Ba8RC+u8bVzCP2AESsswT5U0xaoyMxVa+uRUN9sy3PzQPD4BVFtWOLiiyQv5HWzaC/iBrCWLGdSs5/AgECgudC8vnZD86Zy/3yWhUw8dSjFC2h7tCGzzRL29QzM7DkDN0Tcd/YOpQOWZmX152Or4ycAsfAn67EnChje7Xv3L5aIq7MbGJ68Wfz1L/l46/adWlwrTtFJZgcHO9RHSBbSYZznVPAcvHl0c7EvbxxvHrSzCOKsIMVOz4Sisg2aCLx1idjOjyEfrHMUXa4qAo6YiiHx1hELsp1IGrNWEMuyn2g7gP9pe1hD7LYy6Rj7z2T67SyebgQzMrtnEwlLZlNDjgGotr8yvrhlAtRSEuFuzJDKyr5xuO4ESp9/f9tpxENLVBh5gJ3b6VoUugufSW/KMseN5BqHQEl53HP7jgcZwac+A6c+zC82GVpXfPoA/nmWu51RNx1KV5ZtJ7TRf693wGFMNT6QWq5QhEp5qa6QivGsqIiWDB0+nhyhCd+TFr8S99OlHl5aKOGEIXNGvLzTuhUXT4SBkbJTAnVx6wbntRdOBIBuPq1hYLZlhAF5D6Q7S5R9SVom0mfLkdCkn3aV/IJuc7EoEKAbIZsoTdAlsD0oO2TfPanF2fv9gq3WGD3BR9PjAa2Lj8LC1cbSxv9livMaDMtSceuwwc9rF+x2p2jCk74T4MOGglKr3mos+6lUJKHGxLEwpou+PTg8ERfa1fcvAp6GA4s+SqoURfAkeStPRHc+stdzCSsk0u068ya4UBRNXSJ2cOHW2mJZsljpVEZn+jM/H8wBsdpKi4njNrjagZHZyNKuFjyRl22aJJd61bJIPbNrkSZnuWZ4whS37JMb0ZdiybXz7K1s2S5wLP49xNiyb4gMbNpGTpBuWJ8zrhp1/KQaEDVPtvcS0QkOv5twaeiVTtEy28nek0Wiwh/D9nBnHl0Oyru1IObVgTy42lpZfi/9bndstKhBO37lh27UGoX0iFsJvyITfFbPg/Wozk0vl2OFlZQ8zCZgopFLt7fac8NJBhRYWk9+R6RhTiRi8F9Pnoi4u0yqs5zXILglzezxPbI4l5bbGeCRzazxPbI0l5baWCA+NzWWSRa2CBrKHoZ7IFEJGv84PGf26wJ5wqYyWRsC0mEVtYk7pbI2SyY1iTzgxSVjEO31AmlWg2W+nLYxu1yfWk9zdBCMivUuUGX5o7R4CGs+IExbrNAzLPFd2hc2SicDsK+cwNb6QICMMWVOTrINy5gmdGeSZPai7k1RrUZ6erkYKTfQeaETQz9VkjqA6gkaLaa9mmx9fKdkDkWYZ7HHl1BLL4RKz3CwGdr50gx+JNZIVZgYbPP3ZXZbxpLKOCdmCzr1wrhdcSYAsH+D3oe07no7HIufNR+jcZH7yZn7VzIdiyWaJZo2Gt2MvLVGEwIWl6gMoZkDmQ6eOXuB1iyFUeSNZYR1ENRuNMa4DlvFNmsesoiHES89mMGQVU8wFYTxVcSZ63JTKo2zMjCPCSC/G4TxuKBjCxRzyYgrYhIv52IQFLmrLK+WhLz3b73oOGg0DVr1IXgxZc2Ii9hjyoswSqUuNYIx4PVALO7EmVGSIsNTtuty9FKuDnQH+0Yh67gWYOyqnJKmQ9zBj3qXMjxOiqPnKayzv6EoCH/BWA8dRcxeg/0jbP+GFT6vm9rgF/dHG4YfEIiUxo0/TlClaYml8/GLELACKVXN6t+ehC69UbvHecKNtl32Z4gWCUq0bStK7bLb8i0/n3dostAhrjmwRtlxGkoKXtpmkpFkTCyA3gxQFJ8kpihbVlZ0maOxBpgUKGXgWfgo+HHxsHbW2zvbZkUTfGIASH3qeerFueNf2bcRZKnaxE2w3K2Vmt9SG3g/tsLtGsoGRPr3P/SAmdG9HsUI200kaeaHRsKVVBktEa+47sY2Ir1EvuN7OOlOoRjoMA2dFn1juuaczVsWskcbGTYHALOcTmOWRxeBzSGB4wAIkMX4Q9jHwsATCL1Ka/BKTe/O7uTHU3dwY6o+SnGVTlunOy2UT3TFP2Qrta52RoYlAI7jwGH6hsDg4/y/lBSrJMU1oiAKjAdGe2zHMFRqnDAM0BX9B0Bb+p2efU6JAf1Qq1QYt27e0JxJwJUX9pPOBgwpBlHgceHOYqZ9YEBc3wn952bSDk1PjuWbB3Rt0sdJoNHxiGHCGMhh/DOhLZNOOHKuaF61WGe2x64TTG/G8RIV6Nd8Eh2bwU6UIE4XUiYWsfFJO5nE0JZshOMxduDcGFmbU+Cb6kQHdMlqJJ3EglBpVg6OdOgb4H2+ogd7yVo6iLCkE8JG8ndyGuvS0xE5SbP0h7/2kGghFDHU0jiF1T87VQWpLyrtQaAJj1jJ6jxForMfxMNxfaXjODPYTy3jXm9EIlosvy8TJGIMJycjwOQUmZ5A5Dh/zKLPMx9Gc4vhK7LfpJRVCnMgvjg+e+/LVKtdtJKGvwFEtJws99/PveOCAsv7k04Z3s5kXqyolWYwX611AF9X2VWqX9cZ9/zN2Kc0xPKQubM8DDyM6RGVyHFjsbTZLNRIXb/8A2cA0CF7SYhWnZp0gb1fjEbFOq0W4bpQUsnFA/2y6wttUqDG7FgUv514vqjAyKUKEakBkypsPfdKjmRppnro10UMeePk2PwxBY8Pzdp1L+mc0osmPWs3KEcGmxUWYlAcGlBRFnDJwzzACjeSPLKf+lADHJgQr+LpMTAP/ew9sTWSjID1najZBG3S8YcyEupM/s/LEuEy1k8cL9NEKJ7142E9z2ElYnx1BooEqBEjkwgtjhW2773q3GbfMAYI20ixNV8PqQgA6rRYIDHLKI1qaWv4oGaahPP0WylQwCabyR2J2LUs1NLW0zDrh0uF6nF3AzFyILvXLL8SQnnIpJlmHqbzrd7whwCplS5rJPy5sb2YdbZeapeIJ0BbIIN5Q0+fEWupxhEWcpEnGoUtAfvgmTnNzGkUcuhWUocDkoj/P0HbNkfjoV+ADOHhjC+14xtkfO0L7aVpucQZi3dbr8Iz1sc0MRlYfKkI4kL7lWHLwT9LCsB/AG6i2CrC1osq6Hhg2ciQRGiUIjEeHB28tBdX84+gIAIW3WvvtneNPNTEwrjBk4XqfcID5xcIg0IsjB4Gee0mch68tKQLeWOhYs3P5aTNSLBaWcxGyEC2yRjBoqhzsjqNubtJvFEdyOV12tNt639rfmtAdOSIK03iSnaUS7l76RGASBLghFNdoOWM+BDtjbWdprlbX7Tv0mwa+4ZLs4JaGgMHsr5O08Gn6XMyTjn5xbkEqDdVy5Lp09iAb5U3TX6eI3qoUjoIwtiy7Rs5RksqbPDnHETSrpJ4m2TypahA4874sA5Sz210Dt5SanoOC3DXCQJ5h1eB3tmA1qFY11MOtIdQbqQqdwpq0FjAXQ8m0rbXsTwVNu1rAg0/2YhxP2LRQRtIiXwOS46mWMzHiMmm/07HoSdEFqFyUnJwohOPFCwKCm2w/CyqjkwoIhSB6BMpFbuEvmC38i8sAfzgXF2CXc5qG06Et5apdnBu6OTqgy836A8J2+rbBswzOAz/xLKOFnjA5bCiZoZjPlgUO9clpFvYHjRH1gQoU2Maw5Kxzo4Wz2jkjHm+IpScygvmcLKjw+8XheDCGiPnbTEEttZjPvBSQmMXX8+7oauZedOoiJX6nOL6P0naPy7Nw8mLmVzjvUcCnzBXay0p59ivsN3W78rQyvxmTeSq8H+D83hrj+OYwi6zCE/FzP/AJi/buVnrlKRtYzpiPENTjbuJsrkZILfGxl7EIP0JPf+8tu+do8g0tr8zMgjTZYp5BfgUIbINghfWDcZjqTgZr207onsvmV2Li9KBckl7DJ92y6eSsTmJNKD2d0/wwagyGUS8rpouYLZPJodgCCPTEBhN53DmK487R18XU/uyz0bJTxetyCJb8IHYvbrONKAuXjLkzG0NgPAGTNkcLHccNXqPyvuZSlmRjS7WmCfs9XiDyxRKKMJghZ5t51Mt2/ErGd3J83rYhKPTT8ifSXNH63nZ9J9zp1ojw+MMt13bofg18FiXDqKHhlQv8o4UONI+hNC/P9ZjlNlyf/vfD8d5ugo+iDsRLNUq0RJ6GSe1dqET5rexXEswPjAmaxpG9eEHeDV2vyysRcPYTJJNCUwkRSBwYzTJhyb+cqVX5ElqVrnul+T0nTtKIBUWXJA4GQZ1vBuipQp7zMK1tFkf9pyietMPQQqHr88LIrs+lZCFTi3GdyPDE7yV9mh6FgdD2jLeLcogIRg3FmJaoiWB9RSJHKVIqtstBHxOB1oUrZngPbxuYIXS0XtxOYucq6XbSxpLc0duDZY8E9VDaFGaM3g5+1kjUL6UtsazRm2J6qUhQUQmN8Uy5NdOnAaTiET7NjwiBUyUw7ILbYykikdEyCuUsj0KF6gZ9eh2LNEZImQJHjlcekSaYUBO8R8ERMggVQNKeGzUyGQu9LJkJlJC2rpSW9cRSlvKMTZ0QU5fdYlst3rVeKHcIvAb7rb+1obA6hFH14ZMZTNrtKGY9khFa4wE2TWxZ1WWMTmwuht4UgaKWVuee1sBWqPcQ4i9K5LqpP967W9Ur0Zw7J0h0ylwV0rOaI9xV5puHeIlFMntj/KnZJOs+jGbnxvUHDcilq7vNAvySjh05DAeKWYWBw5LvON2I2XTgC4v+Jb+LtDElyHCVqvn5wteMo1slCG/k7VtSXzAYsyT5v2WPK7ZYqH9MDW7+2P/X/sGf+zkRXKGRd+yEuGo0+G0pD8PCa3gt3OMriG0PikMLcpP8EbieAxz1TU+n5UJqszxy+PO5VyOZiM0RPcubXPOsUBo1a2pyRgRUe1qqIs4tj6QAOVH8BtFhcDe4FhwGxbMWZm58lYhFlqGnGFCghAzOfFUy977KQQiOnPTro/dxQaOhMwj0FiPA0RLb49DtRS1xOAQPBqK2x0D7pBHu+PTsRFFRi0N6Gxjawi8jNsVvjYrOX6VumTOvenhZSsYDZO63Uez01ThiYvp8WECMRxXSieokIUU3xAv3bGALECTqvpXwZtPiwqF4YQ/cFyMcr/wGuucv2FnLLQKkInJB+CR2dEjXw6Uz9DvO6J3hIj/QHXubil1tsZSRexm6D/VxEQID5XelCUFwZT82Us7chjopAOJMUpdXZWQ0gO87vh2ozxkxucykJZlnHrMxEPl53K/pUWCYkhXdxZK+JWitQSOi06KsfINyJ4NgYOXzKPzQQD1ocTgv1+1yGQ/EYc+O1NOQppX5KOAk887BF/rITvlu/DEC3w3lxLvIjm12lSgZ9DsD52nKwqAutnR/bRxvVIo7EgCD9Ba94NLtiA3Sb7mz+UCLbGWN7Q3szhdg6sV3w9H7jf2d/2wc7xzsP9AwyFEHsbFh9eJu/bu1+YfapHES88Kgl4FipIHwGOKUhk0iZ5VXJKhMlgnTH4/58C0SLezyIbeuhAEdJYSD/MDAL2Ms83hRWk51XGT/ItAqn4gyxVMNJsrcErrK8qagVawPdaWEM9iuEn9Pu8hpO1sH/IhTiH6zlB/9pihUxavy0hlTWFVj5jyYln8LockPtMrRWQDVRABmgZ+q8RMm5mKsRB3bE8BS1Kirbxsw/DYWoudHlPJH1y7GWOybyAroI4DLdymp6lfW9KOGo8LGP9qexUyJF8ivbDwm39Pz0LG/rJt6YQfp4U586GMPnuN9+8ZaqBHL8hvpyUy9Vmlidjy5pz8dWLOxUh1vfPQ40wZHGN/MAq0tNkur7QTUv4+A5W/QdUp5JSU16lQLxI8pm77wDYCKiIyKpUHZeNzMglw080stVIx9K6UWs1KL+vNhYebtsF/Oux123hnbwtb185Wml1nkkE7UfLISPp2jBSP3ecs2tD/sn6OO7M4YgQRvMvucPUMat1Xygqw0m2a84uSINVZm/hSslFHg1nb6th+7nbbbdz075JtO1HMZC8wsaPCYOi5tkhbtZB8xhOPLeN948/ASwIj9lBbS9jMzxgd2FuJ8v9EuE95KA44Zni7eFCZUebXntF5jOadmavsiVE5CHIr1l5T6hjuRN1nFtgz5yTSldhdzxsWwiYVBQYJUc0G/DDF35knBqxJynWEwHMBn+v/Z+xa2to2s4b+ipt1aboxjm0sINM1DgTS8m9sLpPt2CZ8r7AFrI0uuJANON//9O2dmJM1N8gXj2ArdZ4M1c+YmzTlz5lyjX0f4rSUyYKgrK9epLDVXlEYBqYmuddpAWVjNOm3yvy32l5uP4YOUD0wRleX65BTwruo9z2bTOcMmVELFnut8ClXmMutrYY4U7GOtHixN7h39oiSnLsU9mpZKRLi0oBDL7jFE8X7QhxNxYnszcTkylj1bN2EZz8Ml+a263ciQn6vN4hmzTKPFiSwYZJqt+Hc3GjrepFkszI3t8am9+ASNDbRl/Ib49SvNsnOCeGPPywe3i5ZywUiT6DYLA/muNyeN5PusZBjndLuSCJc9rkhA8GmxDbPOAXZJWx8L1Fh8mLfTqLLBRJwUP1lPuafIA7LOejBuNwoRdbsxKaI2m6t+S5URtR188jq90+AVuZWCPsjFSxvtYVpUFdZlv65Z+zXrlYH37B07aA/yyvqJyVreH1lPrOZ2Q09FA1D7CVQniGxsqWeFuRDBItdPwTQf9zb6YOFgjYb1GO+Uz7bW15/CfxvQ3KFFrebmdmP96ebTdSi60Mbqi12s4SWwsbm51Vzf2NymXWBRY2t9e3Oj+bS1bewiUrtobD/b2Ab4p5u8i2a99ay5sb25ubHd4F1oS4E+YDk/Jf/oE8VsXljH/9GnAQAR1vF/pEHwyh++doG5tx5v1BtPt55uNLe2WqhI8mCC6/X1xtOnzebmsya+pv7yhuDYXnXZr0JPum5fC8koFZaHliSrsnvklv6oWZfU9d6i4qB1E2Uh6EOVwNdDMvCcDrEr36M7lCHXFXZFqUaIH9ceOGFEYF04Yh0dVePQhlfWqsLr2UIlpd2Ezc8mUdV7uxrfW2vy3i7G97YxSW+Jldf3GNLiDF7iVc26OKdB1W8lxS2slP0GCtrahN19W0UTPZ5sCwapD5wusBJhjMuoNCpQ/Z8AgLM3u7wir62S0QGJE5SIgVZTQBFa9cbmKpEEhf9VZdqcR+fGG8iLw6cil65PuhUq56Y1L+pX+OeAhp4yB82huXC71BCLmRKkLexqXQgEriFtz4lSvh6jtOGtI3I/E0yMoAGfHL4+3EejzPbJ0b8P228+vD5FTubd8WHdUCXNcSJzNTaKy2dEE/3QCWGGcG6FXtXioKPvq3NNrCB0r1z4lhYMgimL0f0s1lIV4FuX1oyRctpJW2bO9zIID9y+NKrREs7cDDbMnH1HN1WK8lSkKJsSRXlaQFFKRlKIHw1D8u6ahIDvEknRa+YXemfeCrRpSYq8tkmMNJTczqlTUrsdsF7oxVvIZa3Vqb7mr53PIxr3wroiQZ/E4UgZv52u6pXjBb9xoKoeItIEhk4o5MY6fXV8CHRl0CMhSarQVquJX6WlCuTbVJR+p26+6DSVdip1RN+HbbqrpWsBnoSE6IovtntDot6vTuR2klpbo300hUvjttG4hP+UPCyAWEubkHujseoxMI2sCpWqGRiVtHxxNGVBbAqXI+YwKYoQkAKPkx+a2iwoTfVm4ebenHhzl+vM7DujC7KPWp/0o4hbPKd6fjud7mS480nbXS5MNWJJbID72vWGxeLm51xuPauGHbuQi+Js5LdRMlURY3BQ9Z7P2qm1ZWPvxPUlLF7Cn/HtaeIDd5c4B3LZmARuHnIygEum42l+tHn15ZF2GhaY50+bxom6pV4UmlxhlNSPzPWfk/rPSb2WINiFPe13SCKCjP4KY/vW+gmGfgzd/wT/fwzd/GR91uWW7w/fHnx4/eFNIspInnM9ZBKAeugOYKtbLyxbKapHiZ9Mq9FA171WQ18VA6UvDp2N0yU84a4l1j+oqbqmY/KvvHSdDjRp2SMUfe4aAIeeE767vIQPnb4Y17dZDz9Z68ybpWnKqWmLs3ss9LW0AtNmyVi1NrWT5SW6CsVYW6IribY+e4B7Md3NDQOdmRiTBy0RjTu9MOg7OtC6COS5V73Yhy1tQMlXiL9Zd8MwhL3yaoiII076J2tjE7F6fUsnBvsJglLFRh19OgetOu45EkI3Ke5CIUNftetEMf2T1UK0Rrg+huQYyl43bDQMqj5YN3W/Xh9wlM/rfoN2v551byIfJr36AlUus3HSzUa5KEgkoJCU10YpL+f1TlwlWl/V0C7Ljd1rIlzyAEipuxceeqNwg258q1e9Tq4govONyCA6ueKHzj1KHlqF27H1rW7HkPSDayKnb0hKvlJymHu2VGXrm91YlWpnuzBoTB7sVHVMvWu+lY31woQrG+uTZlwpm5VqFAeDPd/tOxpro1YsTN7yOv2W98XPiEuTtTTSZaceDn2fugJal7CZ79G5b14xJUp2jERocZazO9WaxV3YF7A/xcXZs13PqfWAupM1cm/Y6rCByG4OVG9I6tcENhtsAWqK2Wgld17YCt2gbzNBWKOZ1wOTECidNDen7MVzovjU7ateyeza/NeQRNnrexnClrHbDn0msiAkWowCdU5MYtk8mRgPwPUuNBySiOHm2kIsX1/Rq4u+1DzxvxpKCtFVZPpo+lfR8vFFXhAqawcuSGkcKnh7kp8vN0Nm8nRBmAbsDrN4gldOY1dR6+NxAa4MFs7pKzrhmgA61k9WS4o+IJgOKXDN+rYkLBNMsSRLKI3gmYCYjoFKMOR51azi5xzuVphMakulTWQBsrtWvuyuVcDhlo6LIPEbJ4RTgex1UDClCPC0utWInDODEE9aqe10uARPuJb1RQjANgajchWGlrQ1nsp8jEO/e0rDcML+BWpwsyBTpXtJRb1VHgSgLhzm/Z9WleieJy/OHgSRcbvTWtTjBMsfQKJsxDkOrq48YpRcG6rKKbpWFpqaKXH5Nau+R7ukByF2rmgs/Si5MjIzREkVgcb1iroWRbT2YO25uO2amnmQLo0CpUXDU+rKuUXVlc7RU9Dk9Detq6DgGRTVWTrp1IVPDi/fxZ+az949mn7cj5n/Znns/M3m/WNjXTVXNtaVaLevy6LgVpd3wUM0k++ShljpTEpyY60ZLo4/W63Nhim+uhRla3nPls1Scuk6c17i0FMi1230CqVnRUKXzdtbJ99Fan/BL3uMjj0JaGVq8WArcFdbgeLIcxMHnmtulE6KpEiOxmL/sxUWlsrGjIkJgE4KBFNIA5bqYSG/fK1Idk+eWB8AB53BAF5CJbJycB7Gcq4d13MuPEIDPHDX7Z7jBRZNglaV+nwX90h440LP8II868LpfALaaSVHsYLkS06E7oGhaGgWq1sSOWnINqtbBQRlq2QB8vhOJT7UDvumUDZSXXkcvpTF2d34Ti4YTdG7oidZbxQ6aUh4nMzGau5Yb3BhMMPIgt6sMGD5eK1oQEhX843qdIiHM1izB028AV+jWccTmBXPXFYVw/NBKXW6EPESylJzkMfPkw5/srpxDtBPz/Gx6/QH8AFlGO7R8VyGZ11Jy0VJhOsPg6G8Rk1PjUuG1wHra0reHck6WBYjYRIm5xXu07K8ofLK5vBltvaRCEw+yPwuNF+d0JgXacdun8A+6w/malqWG0+rG0vuX4nt1oss5lw6IWtNB6xZm9Tzs7llQjPBFCztRZqDidpqtiNStC4hdwyTEqpWNVCvCwmNEbgmlQ/qRipjQ3wVXDIXoCLazFcRFdyJWpuljMWn3k0NnIwJpHRhb/Q7emEEHBV8shg4uYKAhyg4X9W2it+Dc6yrhNrS21fxtdpG0UAqF88kCwncihmfbJVNY/p960FnmuhMlRg5OsjuEhPZRhn9YMaZouSClNUWxbhg2RhF9qN5sEb5ms4dMnV9cO8QNmoexGI27GxuAqu/YeGdO2t9x4dWIbvNXQxdr3vYvSJHcNe/lU2ojJVz82Wf9wVOWZu8TZ+a73DqApXbGxbWCVRHv45OgmHYIQbtlgR16oTANxRC/Tr6JxkJEBkMxh63ecIT1/9kwa0xdG7q+DvKEbbACzmikc6J3x0EgClHXRvha1YlohOuqLGOebbCqzivXUyXUNFjpfN0oUfdap5c5jvTG0M5DWtmbJf3oqlrEjarobJwV2/4xTAHQz9XST88rSKucs4h1puFjvbNSf3sWyufuTuHvCQJe3NJjAGgMI1DaxXJjLJIE6nxs1SmuSSEw7x0+q43Ggd1DIseB/Ma39Q4oMNL2Gbx2EnBixhH2ahol1M2PV2rEoS+w1RWxJS3Ad8SG74gHevbdweHSALS7LAqJRHIlvj2kWhhF2aapcMjtUJ4hVjdN6HZzic02wWmepslJTS4/yh66SRGqpobz700xCVdnomsYBe/jmi1AYMpbmIGNJeGFoA/P1PkpK3Y53VJxDXbUP34sY6x2jDUmqhm6OfMPV+M8HpOPH8JUcX1Yau7eP3adzo9WXNjqFtaG5RZkEVZn4wt7y7+g4fcJzKK7A5WZzZqUGZKOYRAZ1B3jjGG5UwpX5Y/S9hG6fY2nvTB4I0Tfgqu8VqnegTplfOTFN6ramaGva4tl/I/eJ/6BLt102AHQS9OUMfIeZ+2lO5RrINqnosPbV+PYLkE0+t9KsCA+bJBs8kf11ddtWPa/r+7MH2PvEaZgbL51apCF577U0r+75CE97zvxZXqCnnmg0a6TLDCGRs0gtH4Gr6v5QZmw+Yk8vnURjTyiC8sW7ebocNyq2kZfCfDw+U9Zp6W8Zhh9+99mFCs4pla9bVc5RaAaOJSdUT7jvJH9UsBqGpkoSQQnvnsjTOw1cu6IEY4Y01qzHDsHCUKBvmI8fauD0mvK1KHiSGvMoEvRbiv97v0Tnvb5dNowK5kwiojbqpVJcZNcam5uEkEoBzcFEEmxE3WJBc32cwKcFMckuKm1OHsuCn2+4Cbi8fNiHiXpyRSnOqysoXJ5aZNxDUDBibrMvmRkzAMQkQmQ3iFGydE2/Kc2ogQ/6ib4OEJoMY8BO0vqD+vAR3ZRJnirIJWUFbfjSIMmup2KyalnCCwL9DVUU0iW8n4RMniHP48GDJyStjy3O6O9cPfvPmXP2efUTKbfBfjqdS0C7BGb+VboxeIMzdkmc92SU581MEYz3u5osSnfbbQ3LM+TkFyTvoMYMJznmm8ck55nFHBGZ8NJijP7ni+Z33uLntk45Jy3t0rcuz4uuBVrlgNc/gZ2e50pflMdwqi4Qfq4fqu/y9AwCP/ErOkw42079xiwVpSsmtss6+22S9oM5WpkcCcQJcIU78hmNHMevHCau7mAXcSYHi8dLsE0xPmNMCXc2P9TJdeTV7ATS7gL/SVVJMXkwfYYT3uV5PX08kFpD3uV5PX1inmFtTPuLxpDbdLJ+PG3SwSl+R5bneHZaMpuEC7q/pbPnlincQwCKKthbXCkZgw/LCR98LQGdXdiP6lvbxILgMvaDMOuaModBJakNMFpxO8CwZp6EJW/ef0hUDtixQq7VUpN/XPVFTQL+uJP/73v9bfXxTITwM3SuHogwmqT2In6w0fTFCD3ihyO1l3ybMJlpK+qxSUPyaQhs8JW8MbxW5ncpJyOfQ0itIJCXe4vIc7xPpG6YgKM6JhutIcAyKlsnxm0MICTUZEijo4x45oMdbL/ZQPYbNqc3ZEyf8sGS2j8q1/Y1TzKXaAykontl9W2s1uwGzQvKsWzJNdjpCqBGFsEeBX4H1hfouRxankDVlOK2gl5E9J1IWm8LSTuViu+HVI865MuZN78fR5Wsg3P52Ub26U0TTEZBPyDRiDpFYg4g5klhwLydbbyM/WO/EOLAkV/Ccw3soGTIrKTANxjeoGxDvI7hIb7ZSSAu7xy5W6CaXyMu/EdKFo0CzsyOTWGVFj5t0ljsdRyn35VrRZMnGJYl2pLZal1XKTLOnaxTesyRfuKjXiki2Ul9T8uFXGnUwNzV+GsEN1/U9aXuodnK40tZbP2726n7LJvv5h9y54954Gpr3LSsu/c0+DSfctD3XwsG+XY9/+SuIbQnzD3hVqSr9/+VoTwSsNc1G8k1k4DtzFf/7wN2325b8//E0bfvmTbmnBse9hUy9Kyxu9cq96hxinaDBCplBS+ZoqS3tt01ZrItBML9LLAK3ngob0RR1r2oRVtQvzdAl91KOgT+weOr726iwk7/PnFh996d2OSuneh37+qruR65HS03ZcpO12b/NpuRh94IrmMrm9b+o9J1PAVknV6UircpTpUlX5onGky8sL8gMbtVusQp/Mer/QeF8ZLuKMOoAzQ9vxOuTlDctRwlBZmQ2EhC9y8dy4nAG8L1ikRuS18gXijmYFErmmTHTU/iEh/pWKsIvREhZeBk0/glBn2MG5ksaBAWT5DngDdNUOaACQSjXthP4FhNHZJDtrljp443GTFePBg8ZslYq1Y53E+IJZo2odHvr3mdJxvZCDWp+Ug9osow6SmTkpPFRWWGbtD1ulqolkV4TFZFlv5DNI35rO5z2zGlU2olBa5p3Il6luRW5J+6B/XPBe3KdmycpWzArnthNd/zJ0Inh9HfjkEqtuqOH7kZpF3+9uZCtVNyOz1V6dvbhdHglH5jNgkHXIlWWmkvJq1f0pO1fcyz59VrhPn33zNhsGU41vwkLDdrvFRhlU4MCkcA8qlK941yGxo950eFF57X1xhdodB8pWx9qyLN7gb7NAAGajtqTmWzBpoxHIYzUmgsmcjQYUv+IxER6MKr62UaaucVNqvgmDTNS/cfDx9piYBoBaYyYNHvbwV9jD4dA/6L93Qr5Hkg2sFJf2AiWs0+72a5bkQk8VCd2+kMFZiFvRI51PUvwtVg6MxNvp3OqT2LI7qVtq2tMhj7U8oXd9Xk/dfjKlbr+e6gqTYP0yZDIkhxT7TX3R2dqZn+nfFm6ZHYsF/upgXJ0KvMb+TjJqzQq87k76XmrWAL7aTjan58+zd5aGQzeOgFNTRqCzzUbgj8kIfC1sBPZAR1jeSBzPymp4eDoaEHOsTa2y8NKxvtLBNqW1Fkb+ycDyAm5KQJOF4pomiA/qPRP/eRyrTQvgiKYlyUNl6H/ygxu/spsbpVOaJ4viBY81yzbWX/F6yg00qtZjqzlLCE+p00UZ9swWKONZWfMF7nlebi4vua6Qu3i2irY92fpkLNcsf3bVOi0BmAYhZSLUaoUcP1qdFLxDrNUSnizQbnMr/6Tc+sbCxb/N8rGZL5NJzbdwmcS12jifsTdJmr8ODw4G/XCN/Kq7l2YKNG/ftOpb2L90sTad6NgdzLIr4hbm8Pe5hxuFe7jxsIeT2PPmTZzVfQu7mK2Wh9Yfu495AtArkrV42MlfJYQ+mgXQdERyFH2puKTaPWGV1JQ9qln6ZTfN1pTEwDS7O8lJnfh9OBq3qZfSt6ks+kKetssUK02tKrPZj7jWguxlkoR5kuxlLOrawrOXCei30OxlW4WotjVb9rKSMEN4rzLKbOWKEudLyBaaK6wNU5AcQW0GMGG+BGyQmy/hWL0Q5w1GJa1CV7PnS8j6fMiX8HVCMiJ+GBFRqSkxJgorzUVFL4PJwUUBYkJkpC1ysfG1drvPHY/io9jb7Agp9PqQn+yraTQLcnuaqsut1ZwoxSdRAAs0my+nTvU5jW6TxX9LtJv8CbWZB2RAfMxBMipWaL7MSwtq58AoUefupNh8OVHu0PmKuWfzvy6hahOvK2/Ys4j0SnEBsm/VW9McxN2g77gSogsl967V7HjQ1BIWl+AUxSP0wwpCGd3jnhuh4RAg18He6R7+3FVq0zCiACOlwqC19HxNWtMHFYJiQgJBH1SI5DKbACXPKpxHrgDdreei50E2DH4hqNt/9/rdcYJniQWUOd0Kn3NStTvVa/kqC6dQ7En3XkfQ3ekSFZrSjEwiuF3fzJfcrm8W3LubK09iBo5PvIjZTeDeeQd04o0TXrn+ied2ZTKTCzA3Sde8LSjS1clUZvup0XbCtDxTatQAYFgtWioGnWEfPhMesocewZ/oWWRXEAroHHa1FlFoKVNI1tXvPJDDRD3R6AxSRxhQAiEOCG6hDjl1+3RinKrIvFA2dY1Byaoww+jhNQz/2o1i4sNLqNATvQIcBqliqK2c5CTpaqrZwuoxuUXvVegohlnBM4vJyIJQPLYq/1CZnS9yutjsZTnAZI6yDwS92XmzoXFr8E0AEtva25FYn6UVoLdaq25lIhAXxK33+KjmRUsLC4nIxtLoM6ciKekCbQxoFAywkDEeBrJCey6gA9xPMa3+Cy9XJ7ArKR9UqVcAm+SUwPT2Q7sVjMjVYdP0XwoaEW+HTammxHTq7sD/lcJu6FxdORce2UlWWU+LqJD+0vEiUlOF/5H7WW6UFlG7adj8ahvMu+h2417WJCnBd9NsNFR451aF5yUIv6XDu/4rmqhJGuBVmrtp0zCA1uCOJMWcGU2jKuv5VGW9QC238ukWRZYFXmIYH8BOk/gUqXRpQ7dNx5yka7JJjeGlEl7zyRPrIPArMcVFRP0OULtPmAedEiKYmwNdXRNAbEpTIplOpAdzxwsizAnPzvyadTGM48CvYbJ4oDQ1C68mnjOg+r+1DjvYoZQG5YrXLmIARRkhbET+EMFVoU/woVLNUQDmpTFXKFSbvzKUZySvQCV3DNhI7whOEvmaA3LpDL3Y1vmxEJaIuVVpJ3Xi4VA0gAFqITwX2h6jQYrMobTxjZ8gOutUlE9TIRr0Y/7fjoU56rDT/zPV/8Hql1O40mqWiDkJBsTXmBOpcH7GVuOoyOv0+90HGUkXZWckxHq/9/bw9Ukd6zK0WlZzqUaZrtwzJQreWllW2FYPrCModOFlfyYZB/kk4wHZAJYNu8mCw2voeMnhZR0dRFUxamnCZ1cwnOIa8Mif4Lb6t8iXUmZS5DlZQcZQNoG3E/jFjUYj8whUBukRB+7Ja3R+Y8ehrG9uV4hD0Vx66pM4dDuT9qWtflta/fpmQ72Iw/c6BsYAMwBHzjXpWoMgcinHK8ruKMB7WnMvbHCjMIVnY+IUnuslYoOltw5LkFypDXULY4mnCow2FTlRl6XoAcJRTjZfunGfW7AJHA9nB+8cebyjmPTtk9N3x3u/Hbb/efhH1ZCi9zva2MhZCpf4ZEIwyP+cvHtbHzhhRGzWVOn0HQ3lWsedgrGz0qbV+mUQHjqdnm2fodwAKs5zBV35HLLbNWX0Hccki3AwcN0jl3FVYIijeOQRWgrDJQC7+e3jYKA3h0LeGn4VNL5BYiQ2X1JmWJbUPVvtO3XgvwngXb0JrqWgImr54lji+71YC8uy9UjO2d0uJz+4EfWyVnXDPXVSNORBEW6p2JxfFK014bpZZ/dIY/7x7kho9oeh2R/aeKhJ8MnNa4bbKjwtfgzT2TW2OqUorTbCUmgz0sYCZuKfhAysGzfuub517ZKbQRDGMlA2mTdO3EPJnQ1bm/12ffvG9bvBTd31fRIykd4ayueSZlX1naezxB6W0zVvY71E12o89Iw8iVaxGqbyU9EVaY0mLaLIKUiGCAkhSZkARiZqKNw3cAFTC64MXBEeylJrWqLAphMGpuRcl3QxWnAZ71gCi/Df/9KZsYfHVmVwW6npzYAJSFohZ5A0iinxyGlzw+4prNVNItBHpacBuMcl9Ay6l0rzEVxRPoqiSMmGQmcpJSYy4kzk8kZ3eVomwT8/tT8MTCwKK52fQnEpGJQPA7u9WP4kYU/M1w5OKaiRFhoK1EPSRx6qQntco7IHeF8V0yVEIY75loiaeF2xlfqiGji0qYiDTP9GhHb39k7oGJO/k/tmUWZTIDa3S2aWsB/0+47f/dUJVVGsXCOaVZ78fgeh7FFuiPmj3BDzx4Qev0F4f9LZbLUmdqXT7/4aM2ZF3rsVqFlD/r2yY1Xo35oBgNkCIgj/ZQKixzPCsB9GEBLH8LIiCpX8FuiBdNFQBCx8CaJ45SL2MQcnR/jzfP4KAAtMM2g3JnIBFUZaAeUGKyuqsUUrKzqPOLi68kiqkSmy19YEtSf81bCV7VhoNWUxEzKLGaOl4IsxVtjIpzUbk9OakhhYHpCL4dUp/bxG+0qlviySFsPyTJSG7fsUsMgykoGuUQPJLgJXVHsApTMNGZX6sUj5t+n2IneRnf4cgyvM8MJ46mdmoNpiVfuunFWqBpjmdYpWnmya7C7UdaMBbA8YN38ZaOThuMCUpAvBlGEXHirZLKDDfuATk8fKl4XEupxN0NIsk/0C+3SaBYNSvCIBY6aiKcISDRYNygm6u8Seio3SWeUd0wuVbpeXlZfJMo+tKs82b4F2bCh4Dwbvw2DgXFFUVIzV7mLnJtyR78PSjWoqTPXcJoEKBamozwSUWOFSKCbiy7sXmG7qcPDnXtOX1MGxVDdxtD5Tze8WSiTu3/DOzicN42z/+c5EE38DwZjkikpvz0p76cq4j3a/luOPLMeDO113tIZzZuCKjI2xge9ZRxhzRylBg3/TWplnDgyjdFEtkuhx/wUTtVHR95pFJdLYY/hsiS8Q5+J5e8YDA6nswCaHl1dpVoBJwM1TNQchSu/0eIFXRjdw+bDMOZOOrUYh7dhqTGyzsFGmqzXdVSL5SAvKYrnL8GZ5KcjkqJrIxE3YOh7VktYGbDPQpuciJVLrdBdJwcRx6ANoCBTxpgdU0PG8xBqVfoiuwq0p9Ex9Bekrxc9qWMzQXRPWI7e945WlC+sJg9HYtInN/LSJzcl9FDdLcI/Wr9Bz5UOW7fJ8bzQlpQjIIahEIJMppWQgh1Uw9PzFImgIrTowS/4LGk2ZNxO/XngQr096DpdJKw/bY4+SMSUiUVZYQkOfdH22KUCxfDDcX8CsOaVrbpVoN1LyoQlF5dJScYd5YlCFji5k+z04dym2Bd+3HqwLMuuCZGuqNXffnPeqjy7V/qQO23k+Q0rNVwrWzrfGfXkQCYsc6z8kGXuye9s4pyFsgp0DuBc4XVtmYaGu07Nss5VagEatTujblTOKKe0DGOTc2g+GXtfyg5jNPjPJ3anULDIZ07sknMbT1Y/O58JFKMLvW467o7geJSrfZsH1UTNJ5W4ZB0dvDt+eHL172z493oMfp/Czqsd7KIC2WAQYg/qKhapYRxnOd7yDo5P2+oEu0aLBK4qusBexv5auPFLkL47v9jEtWc/xr4idjJpjCyJOBKfOoXeNUDnrpR6+Jjsyuo4qX48SU0sa+IVVaR1Qs4z1g4rJ7eaYrNFAWhh0n1iwD6w+5k6FUdhVRR+c94/wbwB0ASSllU9SWqXOXyqRFGn3iZRFq1iR2FnTUpg89OsGPjGIq1hKiBQf6KNGEU5O945fHh2+PsgA06J84Pa793v7R6d/GBolVVrjX1+/e/em/X7v5CRrlZXlgJ+cHh++/e30ldokKdeaAaJdeOSEULdm3iQrywH/twr7bwORTXLTsHwZaWoNPXEGmoPl5dTYkTPapJMIqUYOnYBJeBmEwOV1CDS5sasLMNGZ0fB9o1Uu+gJVw4GSoWk4WKHUNVOSE7o8k8XpTFyCpP9JzufcKHvDAeY3fe1cUIG6kX+Y/mw3Oa0JA0kXDt574FN71tTec04SyQljdcx2VVj5Yz0k6Nuc4dwxfdYwLyteDfxLlyUj37NWLvKxFeqhqydUN7EBeYAbXX3dSbFmXA8cUuoDWOPfhk7Y3UkD5Fl9Z0Qv27AloXvXx3A5wJF4Flz8Bx5seN1mD7s13HISqzscHfEf3wCeqPi3fhE6iDXBjY9iAjxNDcWI9RW5RxxLIRd8BMwm8DZInpxrx/XwlK9X7hXdW4Xo3vpmslmp6L53dASTv+rJmToMVStioT093mfLzMN9EnWcAXkV973s0BPKYEPbdkRPzZMYVwMPdZiH53SI/eTsx59/+fiocv7kqmZ1EMb+u/JjZafyo9Mf7FZqlZ/xtxfjz1/w5xX9CS3g91/DAJ/g4eOjnY+Pfvx+/dnux0dfzjrn1arJcnYskXL5Su9CptI+TIRqIlsdZFiSXiqmdSSVGjVy3HZSl5IioQzokDGy+HdZo+TjLobIzJarq9lslI3MvGHx3zQaI5SvhiByevrCl5hHXD4NXH2fY2G6wSnEDovDod1WSXwKhyx2gNG4rlmA+zxH0XEhvE1xgKT43HIMbuV8p4PvFti1Y5j86O2wf0FzANgAnz9Vf9gHGAZMIXeNyTkZQN2NXqK2jtjQDN8btt7R/PEN86HX+/g9CTtsDZNMKllDwbT84WLoSyufvhSZ9ay+fmMIWJtYUsBB2mjKZhRp0WpcVpLVyDQFA8YbzSno6myO67pZjzEeVTMhDtWlT8688pIsZXPSVCPa/kxLVyHX+PQblC6P7VEayZXGby3crRQo3a9Qsqo79ukq71gfD0RPcY6UCktIUtP14YYds1MZLRVpLIaveEIbVR9sKL/CTmUMtnG/ZlUrIr6YbduyZSbUNkSNpJ5plBbT+HX4Azev9fPz5MH1c7JfKOzGbmEiTg7KYK01sfMnlp2NK9YsEmdmM/zcLBG3/NfQ8WNXtgUSy0pI3JPlsV0Z1ay/dNxgVUne6WQ/N3TlMNz9qTKbN4hgMcSu1rHctp2adUEvjw7s8AtdLDYI6E2fdcIHA8hm1frJ+ksXojkRSaLLXnpBEGLUaVNWmIhHu8ZBHclCB9fGRjujvT22mufUARZ2Ibl0fdLNw3qh1Tk0o4P8ZOhsTYIsJg8i5NKzdKsvgsuQvudEvdPgg5LPQy4tIeJnCzTclRNjD5REcak9O7VQPaXlsMSuAFAkCDTBNta5tAL+/IzdcbSG58ePNeTi3dg2/fHzz9ZmFTAIHzDrNbbu9JxwP+iSvdh2VdkSbfRfeRY6lrG+f/nlF0yl/cRq3F7y/5Ye5bbLg3GZkZMk8ZZKS4hx2QJttLCqWZHjxQa0c7sZ1iFgHQow4jH+xJelI2Ginepf4KkFrf/84W+3++W/P/yNQ3z5czZ8TfqbEWkBZ9MeJMStWv8dh6USmv4DXyhFV/x7f4i6Xoio698sov5bx9J/l/XSyJdH8c6AmumdEpFMw+fKZwkrk80sNFqDHbGJDO1WY4EHzmxxzdbLto/fXV5Cvb6Zs/Ly7mi2RuHcQUFI1x1Ghk3u+Fc0p4C2v//k58kOhfgT9zG9f70/gl8t/To4wGBEeJ7U1ykDl9cdmwntr1F/qvXz+X/cOGZK0fw+Pv9ZzbCLdUi729K667r0SpjCsGnqeKscdLc7bLGdILLp+nEg7EuJaDbicJHrF8J93kkWpluDLi9RKNPFLzNSEmmCXFpCNjRboI0WCrq4h5VyLFAtFykCXYuGEkwZz20l7ArUSqcgPCuWEPikoxvC0XxAr07fvF7629hmedAAJh5414RHpFS9idWq0uljlTXaXf6jlhnf6iiyF4bOqO5G9G/apIo3s+QhkWBiHKtGniAxHcJ8HeLncQJ0QhB9fHKDQeLtbHq7uoVgjAGw2AKfZ1NiAfy5KAclsULPdbhy2bJKWZio2GOyshfyODvaah5cmBeBvxdD1+ui5xbU/5OMRPw1VJXwQFNWmWdK2Cexo5kSYmFqSkghduSUXqLXMrRGkDp/AmSnj4MwwGQVVCzTZdPQD02MSMewkbZJHqkoZ9fkv7cP+wpHVEgN9P8i892j06ZPCVLuGPQypHtV2J3n+p/EnMz4H++bVvG+ZYAdyzb1hWNlU6NPwtQMChrnhsmr2EtFmVW6enxI544P/K19+XMxkUYedCM0tvQtBpRW4oIJpSWkKNkCberwWrOIb4qy54kpLuG+R4HrtxS8fqtv9jjNYSmAjxj4SAdnufF4A+ciSvqHi27OADw/ntZkxJuMqmPvubimmpppY1BTQyHoobzZ2EphyCJ78ySCpmYXQQwbaMdiKQNN0b+XXBVaIjkZzXj97pPX6TH1g4j0prq5of4ska/e44TCe8F/da0GDSnNUDMakOCSWTtQw4FKRMEr1czSXbKx54wIDR/ErSTq0KJvV+u00H7y/wIc9eNH++PH6Cf77OPHbv38cfUf8PQ4fZIe7Bc7CPrx4xOpRfUFK63+8MTVXJ7pWHlzNFOF1zvspbz0Aie2aQdnzfOqgsv7BqiWBvXKALWuQe3tsBd1tqEYZQBvoTXfOK8Ce9FcCN2Yk5pIYRNWMPN4xw07QzdeuwBu6hMJmTBh6J+SSOIWhKLFxWzcg6mG8eTkQV+LTCi2tgU64UQjv2NlEgS2QDuGfw7IpYFPgA8L92898Qa+Ijj5WDuq21VPXqAwGQA+1dQI3bCO7g6LPqTUkTAMwh1TYl3uJv0S9w1vm+cIZIin9uSJ9dL1u0kvua5UybQ53FFXzzP1ItffSmtc1Vvv5GXcShpHvEAPzZ06bxmSbbGvVaevDzML8GlRf/JLfGX0wjZ/wjIn/0gl1sn2Zjkoi+dGMaKZJKCUClfjIjIVpUlpTLpQY6ji08OT0xNgIQZ2zHyoE8rCaEpCRigBsb48GOJ/tbNxz/OUo5GXFO7drZXcu/opCWvVYw62ocKHWY4Lprl/dLz/4ej03NpjOW4s3q5idjI1C9STwbL4hGKGLCojhw1Ew9mq3rA4FS+4siv/6GRzOcHbNfaH3v7wUpGnd7ssdGi9XqlZFfrddqzvN7rdjcvLXThA/Hjthie8ugi8rtHFvzDMlmLNxVgAxZ4LKy4d+DBJhWLqxeURaLgMNxhKP3Jybqe8i3PjuLHE7KhvPn2HaGqAAPUFEJiNfAJTEA54Y6uUFEaLThSuWGCi2U5Htkrj0cgTSV+GQf+QJ5NOtunDMfhVNmms3A/jSS6H6yt6N8TF2bhSU7ZkdksB0sr4t0u4VDEGjvFtVHVM2+5qFhr6TVM8p+jVxf4zO6c++J/g6GDT2bF++Bt7/fJnbngGOTBE7m1WPxFwUqZDldqeUVaUlRjE0KzintI2zik0xLOVv1mF5BJm3FuLe2EQx7BVKEbyB8kcXypcmfBW2uqUQDRGcW+6VPkEwfSwsHfjIHa8fcfzosePxb09ICznKionaY0UkO40dDqfrA42Qw7OigggT5cyX13XufKDKHY7ka74vRnD8XFT/2EYwl45YZ1KbnDYBbOUV8mG3AhlqnyFnhPxUo2iaBDH7BXT8LK8Uuo3rd81dmSGVZhX48CY81ZsbAqQ/S8HTVUurTgIrD7mwwyTEXTpT5udOnPWKRU71TYbMwpxtkpCaWjuA8xCrCetSEtXI2HFjKQmW6qJ1ugS4oz44DdQ6hKylVPvdOKh46VIpgMYsFoHMmNsUWdQtxBFzL3EqH1alkMdTpCO5MieFpT7MKfLlJELUyTjYerRHMn83M7QJzklVLmUc2lKgkw72qPh7WG4lyG83QRWE4dgaZas1CSPSiaj549odwOObXZ16d0Ctkt5WmWfQMQjuXRuYpVxt9Yj4VvfI/qI2046oJC+85oxLKrEGSusHWfrlKNJZqyLOEWd0cbDD3CZWFdecOF4PJ1BmK4Bs6MkdslG8w2WI4Gab6Q2BpU0Z0KWPIF3qVEEZcA7ZXK6HHozXWdnC9esmCA8LQnaMhIthZRLS1YlPPtMuMuWaVKxfOWjLIcgrIp/wComU+2NIrfDrPpozqj3rOAk5obPaUIiU2VhRsv7w5ITEl67ncnTrKZrVJIGPjNmJFIXas+ah+j9qz9OjvZP2iene6eHGbBUrEpsaU+GUMEG8xp2nnTXX1JGtoKhE65IpfqiHsUhNaS3pZHqDEDFWKUXtOPHPtARFdFe6QOrD3jVmJ5w75KwaD4U4IRX5vX2OwFMAwQ4IB1n9KKu9HEt1uZ1cUx6xIlP3P7Qo1vJkKVxAUY6Mx6966t+9IoUhnrgcNzaZ5rwSPNDMtSvSPKz6QiNabGob48d4CzDI5MfwZQURW70/vjw5PD0RG/GK4xZDOhcCsKdi/PdNeRKoXXGpEnAkr9nKU5Z3iJNxj2gtcdU0j2pE3Hapt6Be0j0lmrHrAr/MGusOqoYW0TxCDioThTxUPDQeTSAjbNzCXi5e+UMdjYGt7t9IKKuv8a9EbahBKvXboDW7OA/u2LnXKlMuEIZXvhikjCt5zMzBdnPnm2ViZthWbKSg9xzuySUaE1e/Rx9FeDTXjodxU1BLExFyhT7vclVzdNRGtNS7XmRl4j1p4ukU6zjnMmOZeJHajmNkNNYS7gQra3Ih+T1wBkQbViJ7chr3HX6AzQaU1tLDIc5PZtgN3WWZpM4R/MphRzwN1fNMaiiquypMk2kcUuQbC2vI9TG6qdYz7k1sQMt79qU1Raqru6Rn5k22frMFye2VJsdrm/NZi2LZWbYVABeATzL5niuMjCsynAb44gMr8u98uUrSU1DZkrmdvgEzFRPJGcpZAGNk2lY1ncRaZMoV9okj56JpMVwIxZqlziZ68rTGSeRuTE1A70xnAygxPF+C13JDMdYuTBTuWmVDuLCFCO5p0Ztg7o6GtYrqgEmeN6J+9lEX65CGiATw6C8cQaKpTaLhQBH9aHT6dk8SJjbvc3PWnSLfWFozVsMxtAwHr2jBGaUD/M5gfmcwJigcF3/Jxvs3FpPsuXu5jX6Q240mqjRv+VGn8c2+kRGLBoDneeXGvvxR/Lj3zSUqMGTCr8JDSADHVSNTlUUAs8OgKhZZ8tp39daeYWIQllCeINORN7dwG096rlSymhj5dKqM6emLOrq7OCGiixU3Qgtpqa2OkAKlI5uUKPkq1LEVrt6I7FeV60o6hXagM/VqviBTyp30jROilkbhZeDjdmC4q4+YsGd7S068VwEYfQyDPrasZ0HsDgX6HvHMNMSbaTzNYudu8lZUxBrNP/0HXfyjj91pz5xpz5tJz5pNTvf5L1Bs7NzY4/HLD4p77ZDXM/mIUvzukZjiB7pfEp7p45pABoZ4nx38c2vZQPtYsnPzy25xBDw+zK477N7Nrfn9ZKd3eyJ0KNEkjwo5YUE5enS6FCmpS7iMm3zocxOQ2q4A2uADVIxKiTEqATOgLlKHkDXzG4Jc7QkzpZaM/U2AVcJ00VCDtxGfUJp1EWYVXTmnu8WQR+mc0pmt5b1ok0oWbvY8mdTfMl0BfXLWxbKOYzfBzib+u1uLuhIAR3lg35WQD8bQL/AmiKiTfiX5zQTz8EwpBtCmfsCArZs5gds2Syzy6hMYKI4GMjB0IPFXgFep9/tnmgIrshgDVXEzE/NyBcz8aJ9lJF5X14TqK2SSdmY38XVFQnfOxh13VeyreuVK2InPzVWqGu1B+yvhiknp3u//XZ43H6/d3p6ePz25IwDnutuYom1rtQx2gmzX4bU6dz6NuoFN2/gcDgNHAzLj4d5MtOK8VSTGth//su5Jsko6NnKf9bj4MNgQMJ9OGjsqu7q+mURd+c5ZVh8Wq5zh6odXlOGLUevplYWqtXWl0WrNjWHqy6Vq9X+iQJSzv6mGLD39uhNXWhhgoUtvggPkVa+1qY1cRLolT9O6LTyD5Sc6rkpbpbqRDEs1mSGwkkzyjS4ovUTGUXaKZPr7XxEZRZJL3XX75Lbd5e2+eyRHFLGnE7RmS0M8RhTjv4jG4dFr1aVyLMcX2OOLvM0i04yPXOauY/7YzbnpHjZLtcR16Y3Y0ap3wQJNqayYWPt3CKAfXW5sLa87LAyUYXEgOP13h/vPpwq9hvQJsd8A+W9/CdaUL0PIpdJEwwioLbT+WvohoIyqNIPGI6ahLMo9YEJUTvzF/Ur/IPpBewqj7yPQxukttRXm8ujE7KhA7kk/C0MhgMaQOEKf71F+F9Hp1DD1N9VQyotQmVEfL1hgDh6QgthLrw0CC/cOC1s1BuNlhz4S5GtjRerJS8pT6zWZnI3Gqjs8fMFKJ828pVPBcG+1tfLJRqmCPYS1vYpc35Q0toZ6xene1qAaEdfItxjQ6efaZmePLFeAf+OHt7JVvRG1sWIMtM5bHXlEvus3BMvPacL4XrJeGlR1v9960HZMRdlxyAMYJNFkZhwAvaUbVZ9YHbdbiKQN5oGoTEFO4J4vz+JP+116K0llFXvokwxaS2AL7dZjpi0ZE2GwESLdJa7xh415YbW40jpcTSmR00HovX4Wenxc9bj0uo5WpvlYsYpRT+JiaTskAoL3V3vkapM6e86LVVJ1ziepPBTL4+iwEn6KxpqAh9KLTWZDSbaEryzgeNO7A0sLwg+DQcm6sGNNnPtPfffvX159Fs9ymryjRST4VILiYjgyU/X/JO1Pobw+Dk0B9b4G8HOnRBYhMxAAyOHyuu239nNKg3qRrNE52p3BRuPQluZvNXXlJVWjepgNOaAF4AmLoApjCrc8x1/M/+OX0BXtrfLZret3t5kAzBDZZmMv8w3V5O5Nr/s/m2dNnbg3lyzTpv8b4v9/fD2n2/f/estPkgeV+MRN7tTwwBv3x0coiiATUelHTabyBkCn+MFmT3X+eDV+mAY9eRmXwxhSlmrBQrUZrOGeloye0tVgCOhmqmyPIbMmuxKt1OWA5zBbohoUPp0qOUygKB/dcwSAvIvb9amstkx85snVxfIEYCNlfO7gX99xFKWl/CiyYWtZqV3uRqXsdYE+W1SZhZrixZusOc5hyeW7hqSPuBETgaY3yJrIxXvFmWKyK72ql3wK7dLaBrYCG/5Em2gbLwQzi1rx+KsoLviu4GDzoR2o2qIvtZB8Rth5o60MwKnNT27cxSAMFPNssSst6LntApbx0+gJ6Wn1pap9B1z4WQiBj4wFCxAP76Zrx8v4I63miWlLC4u10hW0pryqL6kpU1ET4poSDejH83NRmMW3H8QMS5AxLgAorKRT1SKFF+tUvpEGDQE5TWuuSdlLVMp393jYRBEmV5a0MPTpjWmE6+JY4ssVHU3FzGhX6OnAhfkY/UoXyqP1apHwhdzFkhuyHN8+PL48OSVGgfWaILKYetC3gh1rMzzgUf+M3STHziW35w++gu4B7Xy70EFBjvNZ2W02CnQqbdnUKq36o3NlTPcGaNUn8VMRg4Ol101rKuhE3Zl4YRoPGP9ktyBqH7ijXP7VhMyapkC/zxDpf65RdeBQZMw8HOXJj0Suv7Cp09uO0AGI6g1jfTF8ty+G2vW4/OzX69gyhL43jvKfKH/JIcJE6xWqsW+4aash4UGUJmhwwLYl6f57MvTAiKjhnopodGwbO/wYDYsGbwbIe7HNGdeEUTKdSwWabiKFFxGT417dJn6X0z/fV/7dIyq605qrmIV14TqrSlVW6laS1VprYoLVAks3jKTwxzvp7Gs5frGM/G/rZW93xY6NfFEzXO0GzcbiHPxM5tHeqGFXnYLmahETrasVuSyEoAaw7IESRabOUoBOi7axcrvKl0+52ixic7OTmZYwy/06Z06XcwCLrfP8i+3zwqoTXPVT3FEujUo56J4RLHf3WjoeO/DYEBChs2ZQN5cv7zWKsLyZBLzNEcsry+QhwYc8Ecezlfa4tGNG3d6iAwMxqArjwi683cJmmtVdgx7H0MTXVN8pv0bJFY0q/CuqePe0NgnYPIxoXZ0Fn3/FkyzR8MhQoM8MV3kIFVrw8Ole1WHp0S18OKF9bSRG6HEwzz1QkP67KM8HtptmtrRFbN5Pbd6kbePP226+BrOosb6rE71JrL55ryQfwVDeB0+ur7EgTVwQmhFljZbmmJh+3TF6UvHc/qD3/ELS1dZqfQrJfWc6l4wJVXJFphs777rwz/OrSkPPVOQObc2BUrVZVCSkJ5FZvmbLcJ3q1Tbtu2jGNIDyq3tXUPV0tqTTXsWyktTty7Q6I7jES0UCFRRVhDgEgYatsCmxGKiJXLau6ghTQ5SveuMxHvBlYm282MouHrj+omaGZ6aDTtFqCadfbW6W9Qap5/bGjC2sPXv9ADPaS0jr3wUJu8CWtu8nzW+GNSG23xmadl0h+JfYZz/yrBWeGfLS1OapSIqVyR+JdOSrGRF4glNSVDY+mwOxjW+L+EpqllYmJMlIIKvEpOrkciVJkVwMa5cBV6X+GuOf+VJkW6RGGVt8XIakb+G8JHhFlvJybgBHQX91EiFoW02TRXrOHVLVoRWK9geTT/Wtxpm21Z9Vj0n6uXNJ2LO3MnboUZuMX7EZMycKWGfp8EH341t7KJwRmwk+vqEV8yegXdvrj+l1Dtv0T+xphgIIxtiec3dm61S3diBDtBYibg/JZ5aKS8nRRFXmWKElIuY3A4cv0u6FH/rXdhtMTHhTptK3VDbijggt4rgYLZ+sRrWC0DW0UXodivWjlXBXqKKOdgLN9XgSSIVVa9YmZ+xG3bynYLlzukGulEuARecQa9d/9Oh3x0ELkbxUUNx67Vz4+epqNSPNdTRyhfE32urtdGCG/h6t2s6hwmHAwRBuBf1MwTUZOcJWMr8K34eApZkPSKGBDTSU2qVltbW3a5+/CSVS38TLpcAh4pHNT3UWA3U9oqeL3R1elzY79rEp7Y3eWkt9z3ihKgZunaDYWTRfSegE9b+yr4mZoFT02a2+3gMUfPCHuBOpDOHbSw/Jt3QudmLY9IfxJGQLFuz6eEOy/SIY6oYzX4cmV6OlQd7p3takvsXrHjHGOU5weeDN6Z2b+CwRBqgxyqiE3rLtV/d/gvUWf/uAmYAt0tLX8jDdfsqBHwbZUrJXNjRq09njJLNQp17dREhF5oF5pTNAruRrc1SncgUxZDP2g96JFJMKY2Vc/MBWTpKI67U7sLm1CNSXwoge9D0mhhp0BQ5ygE/U4iDN1r13vv3h3vHe2/3D9U0fWqN1vTopL1+kMHTR334w5d7H16ftl8fvf1n++AIeoIOhRkZqwFVN40ZPOjdFYkJvLwXdZ698EVdfGvY+O8vBg8ZljMPBXCchKgLlPs5SRsgjfGH/QvMdS4ToxdaH3IX950fYyP/ilzgC7L5rFQUBmoQsX53P+P1TonlrdSU85osr9NG9iKlLC+PXh+2fz/6N2Zcy2qX2sSrZBIc5Abx82QcoawcNVZ/LfPJKSNdT60o1RZr6zvVxD+vym5dRYNEnV/b92A9JHyJxl4av6ZWrkgkvlkYNnGpMsOWbtYcuPvZsvOK61YuAusMgD+mMmK8MyZuhzKVLYAp3L8bKys6z1mxid7mgi7IwWI9n41d/1Z2MVNJqGoeuXQ1nH+m3KjZEifR8Djd7lj1TqLEuTfVzdKk0iiX8uaKXWNOadwFxXBCriit/US2TLMZBcv7WbM+sxhABi1OoucXjBYEAwfrJ2b68P4IfrV0tYsih77d4TlHg8jmVgA/JXOQIUccMnL9MZCfdyxmNQWbqRv0aWSQRn0T4fmqBCn3ikXXW3UMhLnHwRhWqghmcX4CJzEvuAc8zFuhIbCl4vdCz59fTOE5qDG8GyV9Wj/+aFFZrzRAveewQerJEVcdF27D0AkSD6mTPNv8wuAaLNNyQXgNlmo5J8CGIXLml+VMFizLQp+VQdhUIGj6ZoRMJgGTwggKHKCgQcRcMjxQixZIgWsS4JuSxJ2vTp80Fe93tNjsYJjskzfAaArEow+PSDxoy3pI+sE1oYWSRbHSWkwavgh5Q7NAp1lmn12zRNek0jRWllyam+o0DZYU96DQnEGjKI3FELe7zsR1FXGGlZpmyoDLMA+JxgcUWj2klQHQmqpSrXddwD0fCoy95SRzM7w/tBd2vEj0IEwGPCY94sRCyJ7qqtnrloM45MnPjZUlJg6SXNxAHDpC/V2Jg4J0vGsDQhtGXRKUmpNJb8mOW6jZp3Yfimo/K5ybBa/rX4ZOBO+ugwJxEYcMNQu4iaartJnliywZTa1h/rbq9Tp/rOFvXvNl6VPLy8R/uxyWKCiGPomV6KSmusJsQ82lyTY0mzVKulI7NaY1mKQcsroUZkEap9l4lVbJnPXhhN7zvORj6dICtbLEnIq41DyTFIDh9QvKrz5jTIlyHf80vgl+G8qRiXtUr1nJMFlTbld51bJVCkvD4EUW67sSKdDWGtvSvx3vvX+F+ibYssBPe16aeaVHUPw99GIFAZRREyaY1mM4uvbRwQlwIil8IpY+6kZyiDkJgvHwPJANre66IenE3oglW2PLuDuydULCj1wR37YKY0RtTRojqrT2+oAbUY61flJVTkWsslA782PJs//S4FbohFh5++9Oj2Dxq9RnSuK7jbWFnMz6ijIy+lJtmgvnjWHbFsAuyHRxtmjzJWNurvCCDzvtZRC+AUqCu0e2ezHUltIKTF8q1WEbDFz6rBqYjd+PTj7svW6/2Xv//ujtbydnbYcK83h7zXE5afjf/yZ91JN4fokzpiGyJbAmHyLMaXXpAFdksWAk3MqGvmjoxxiiI1mRpIvHrwBbJi1q46eu5vl1sgUDbtIATTwS6JhlZtDPhUibVK2ZrLrrRsAQxXr8pXnPvEcnnQxLwyNFZ8kEzzH4yAIEU618wVRRVoutUp2RWbwYkb7IpXOToi4TXRED5cRyqkwMUobVimc15q2zsc6lFfDnZ3QeTOLvWu7jxxri8G5sm/74+WdrE63a8KFqPaatOz0n3Afc2YttVzXI4a3pnx/pH7MuUIwf6FxEbLB/IF42MIYY/l36cAlPy2axSiml6dAur2tBej4URvri4V0xROy7axKGLrXN1vTlaVDaLMPdBLFphZi0Pks7Z+ujpfp51WlXA5UBdiw7J8qtHuKAHXETRT5Tg0jgtxvxwL3xDXE+RXiAO9eO66EsXAv0zUDSMA77716/O26f/utw758nhjgIUvUO84g2mkElS+30wqDvSN7OaKXIoYL5U5SNQjeQjUndQJrlIimyoE3OCfMg8ETRoyE75leJbnKRmhhm0U1k31Zoz0KaaC6vO6Z4/74cKYWHSOFdpOFQTC3Rwkho+Zo+Ji3pU9ZSCxvDEx5YuJfQmpeZETMBLJMaI0tE0SBwu1aH5/mVkonz8Aysp9/EsC/F8VqAwDBjS4VE38VW+F6Fvc31cpGbOLiCmyzuz0P0s1KtGXOqSymCMKzV6JFG47TIXmlot59rsm8MYihy+CxDpNLK4Ban3wq+LO39eeubcDFWUrY9OBlrTsapDavso0L16ZrV/NSG+YWZdiZJtDOV/w6eVgY/nreUWaaFvhuzXN+YHzqvamT26jG8pUjx5KmZ2nE/PTZqzVw/4vWjnPrPO+apfq4CF8E9fQB1eOOl9QhvbpQtsJEhotEEoYxa9dbqRjLSQxilEvw37w4OT+qu3/GGyAxTIIObDouv+BytB4jK8H4YdDGX2MUwjnE43KRCsMRu0Bn24SPX/8JsISewfztxgHY/doXi4Bp2uXYR+5VqSjTgCWkG/AGqBqt/7UZx4r5TYaL6SlW/PWBPv2LTbFDg1Q89gj9/HR117Qp0uUZHrViPrSRsk5SKgfVRTToTJoB+8uno6ks4pZwOZzFwPsDZe5F17SZ4ooWGpZD7CWDBnOl8Gfha0nFFnbfcXXUR6b+287WN2/kEZb2Eth2iTb7MvzxE99FFC8sZYlG7eLOV7OeER+TVOZER+9RQV4uOKPVZRyDoKQKMRd2rGBIRWAQDbAK6o8aH5gJfz+2S8GSSoIy8c3M8RlMIRrUBm8LSRmPabJYxiodJLyKVlzqGx2z6kZT+qLaSM2tcFmXMM5tfcKuMG19P+iOUlnrTT578x7C/J9KfPcQsXWgcmHExYMod/6Uo9ku6c8fEilmhPfusDJcbltnXYEppri2lHkNfqs1N8Gg69UTMGE1lW5n1kGdXacxwBguu3zihb/95lqDMufXB/+QHN34y2o71w99Z91/+NKc8y7M0lK0hM3NDlrBdU3bizciCjXhFs5+niRmN6kxmsJikZ6OXGuicZTf3xTdSReEQILV9jVXXVMuZmV7++CMvMkWWYGNw4zJ6tWlM/iLfBmw9uJL+0qqCNsp1v0kyWUuGlEJZOc0ok/TdPZ68mxtmCVcOU6rjP6Gd/cPf0Aje9A9/Z+2+/AOf07Zf/lH9c4FRjBr5t5XGt8LiCX5LugxwMv+ujdWW/uX6dgnHBfYkGvpQoxhqS8SGtoDyHryxrrzgwvFKapaUXcagw6z3xCBaPGSzlzlxTMQkTOkvppMvmwQF8y8DaQpnYg/nmnhT7mFyunI59GYiK+v5ZGV94rTHpfEf/S2JyGx0IZVqy53xKV1qXng0btWg7P0cj2tDumGhF8SBO1hR5N5msxHq6cVWjpSUGVsIaxKgRJpr6k0ivSzokhWlUZcYs+52iBUpIYIL4zQZzUuiXnBzGjhRrEX/Vr5ACmj/iW/EunbJDV5W1OlzSviFEqmovgBGfCOfEd/4ZnyadBdWWZ354Pk7eoNHdrPVaOgGjFmGyVO3T0L90okWWlgF20qHzglWqIDB4LCqpBMgf2Y+4Ds7ybdJwyIz6w0hO6bZXGpsisxc+YEmQxBCZ1jklmGrhT0rfJPZPUMhL4Z2Y+iMwDFCW2oSovVhq8zePVlizclNu/mshFEdk/g/pjhJk8VIerrqMZKU+Eh52W6VwzxKblKdJEfjJdpcUHyi0jvjOa2Flx2HR4Z4tAUZc9m0EtOIySakxY00+DMYoH78UZ7oZC4RY6LK5ge4VKadH7xWGVYHXICl52a+pWeRzUSjdDEueSQ8xdpTKP0WfL0MEQHlZECcT3hu8V859p0fjriJp5YJu9PvjjG7BAhqdqnbLbK2Vd6HYG3JXEdSg8taOlFdPAPDfprQ7lOfAG9cTXqZdAqmVzRwfOJprwfHfY81Y408afuK2bB1YktRak/bmT+Z2Sz09tqc1NtrfbuEzl66f1d5LVM4VkhERKAx36l4uiqxR0sjJTRkbTbVlTzOXJK5OSe8nP1gxvcVA/grTn4PIfy1wLgyzENw3K+UMlHeqA9JE8clTTRYoU7b1QqFK98qW9YlA13+5vMuyXRZk4WtTGj9zfJEUTZtVq26/FrwdB9KjnYyn6vDLWjPbuTv2Y0S09ehu0atDEgYMRIbeOjxvA+ziWUth1pRmLlkfVkSl8jrk7frs20jaRUXarsx6cNh/4mMXvoGa+kOhcKgduTGeuMM5HgW2Da1gsIng/aT9QP9Qyd0FApokuV/B9VVsyqTTYMGi/iEBt42L7hiBVW0+WhgHMqmpA6p6tmf98LQGdXRxi3pA7cgVepU61EQxrbt1KwLqse9OGueW2uWA38WluG1lY+mBbrI7VXP2qKiaWIZBGTwtzAYDkwh4sS6Qi7o/g6W/8UYCveHqupKMUVW7Lg+CY+6NYujLt1vJySuWYHP5N5GPOYNC8TVQudarte0zpwyltXVXR/+fXX65jWMUqkYnLgdzztCzcafP/wtjPZlDcr/3JXD1kLRfo90Pl0EtzymptSfXE1fVPJ8HNxka6mxMWtWZe/1a65IhPtOiDbedgdboP5FJ1vJWzWE8UlVJUlrg62DTBrtM+oDcU4HSnvG+BW0vKr0rtIYQP+7hoabk3nV+vrK87BGSoNGfX1ncKopD8y1q+FTNSO9kVYrIpILWOQ5FwTwh2/9GjuYkfLs99DhyEB5bkLge2W6w7YoJz12hfYpadl4G6b6Q8dYpCddNq81pu+oGMBh9XsxHOYXw5jYFH7N7VZw4lUDLaInd8G0aL2snsSSOpoc4Hw6nNxUNAj+dgCI/9IgAr9D3xcGhaBEIXmBttSDadoxuS2adTRwfGnSCF/Hf1BhiTEwn7OPKHZ9L6mH5uRa1Vov2xVEPaw0eqPUzU+oeYTf9dLpSG7HcmEq3aHabY+E90xtcg5tkdYwEpOSnAJaEwY3BajRda8lzABomcIwD8c1PLsrCyUYLtIKt7tUhESnypSSyDQWGJyUvk5OcO6F3MxL0bdVTg7n8BaN6dxr8m6ghTrIBVjSWAczkhp1hfJtKmCFNW4dSfO3ILFhEfKW90pF8RwlNJJbG19NdgNhBYCrfpfcVnPlNK7pdvbD37TVlz93jU04WdTIudECnBN4w42payhks66zk0Cvppe53FbXjrcYxmbG0BSrn8M8i6ZICc2QSh9+dTqfrkKc0K9h4vwsUptiqEKpa2MqXicvz/lRbp7zY0JjwweTy3SkNyBTIjotnRTlL9+eNTbfHYLvnb46PhTg6aPmVPZd6nf3nRaI7iJbiBMRMylDj12opJ5xXJRMB6ozf/txfeqdhUJSlKLWoZjapKn143T/g0YdSPLS+QFHGPjErtb7Qy92B97opON4TmhnY+p+gdmIbEF/fv/D30nfNO7T0qYqajbKRoOETNfwjvPyfSdVq+EpNz2RUZZqoiy/H520Xx69Pj08PsnwXyiUqIBQXo9d5Lt0sagIg+sfB3Pp9GFNZGxXgTcWhjmlFsOQ7tVYGPo5x3Z0Cbs/nmS4l/oKTVbqHrkiftf6cDRZkOY4GARrrA29qvLAPKSLAZsXQGla+ZSmSIxTOkoDdcPBPkt84V545IR0tJtVEcyK2KpNT3zyFm2r0UdOYge/Y9eK3C65cEJoySA1UYUbs9AcRXiBnaxRyHonG1yWYNB+0ksRfTRchVgngd+B1/cplazkerTG1JiO6rVYS5Q8w0uos4rcaB2dVD6Sd31Meq7m9uF2aDo5Nq70UuCNJFlZ1hCqYuqEqrHYNKp5iRf4QBH/okwcxdpkvjnLfNFab6y6BFmhPNSQ6A2JHdxov6d1mvWVGeRrGQxOpSufnurkrPjOrA+XLMPNMIzHeo0xsFy/MVb9K0vMMMY7jsEaOpnFfU0O+jQEmrtjEQYfWX1nZPkBZkBwqTjH6ru+23c8C0MOeICXym1QfBc//mh9J67KGHKFthKZoz7/THUMP3KcdVc1hU4IxXrhoR7FI295jfBX39qzN+xmjM5LR8vSkhWuhj6crUcmJtvNXA4GF2eiHm7XIwcYeQTwr9VqNBS7lZhHBdEsVrjMAaXLyPXnsBUpRuOkDNlWYBFrfw1dEleM7vDGOCdarJNYDXCiBDlhTNBk0U2KJk0ztOTP+Este5mS3Z703s4q/QDwFJdfqVnsAQi2jw+fyCj5GQfDTg8wHWjmeSb2JtexadKc5sP8Dq9h3jhZ4pPQJsusCVcCjmytLkVhMlBg/2ODZDgtXo0oo5NTFWF5eioWekayUsMJyi5LcFbTI33HeotZomrW4cFv9M/b0+N37/8wZYqjVr5Ia+hxKySIq2axDZU8SN0rpRXLvKq20rKdwPyShKi5bAkCrdFZGBgbrDxEKc3YHqgsJ68HNFwYjMb3weAqegy1dCXVbFGKQjt9tfU4eB10HA+zy2AUalXLBx0sIFZaI5+eNCbO/LSKLAqlAGs94g0SZTd869NgEJhSs0jlKyJ9UReo+KM0ctwF06XaMANyFYQjauJv4GYE9cn+u7cvj34zKo9YlarB1tsqKiJWWqeLSOia9bflseA2HfrFe/CvcuJTNir4RPx/Jl4DCo/F5USoEsfvuEZFyaPKLtLJA3LpDL1YoZ5vnAHKWZ3O6MmHI+wxghGsUxyEPilBUPhLY9GYqMDbEDpRnkTFwI5Rrwfs4rQB7YUlVeLGGn5ytRHNkiu3bKotm2tO2OnpLZc2B8P6ylvwGclMWRLhzEhipsuGkxEc6g63/+71u2ON4OhV5mxuEXxuQFBEB61JPa2EtpWrwOsSf83xFYthdjQnvSCeReSvIewj1/EqVbNpDHQUYLTrN07cq/edW7sprtmc0cFKXo/1hLWvWj9Z61uN/EC38qx6TtTLm09EqCg2edW4Xs6EGJJpC1PiLxu7Pg0++G5sY0+FE+NX16UVtjRLSGG6bl9jYsSy1bgdzUJcklXaPXJLfwA9cVClgcFP6+vrBqICkFCZwNdDMvAcDCD4PUoGTILYBI+p1YY9cMKIHPkxjliPhheAhDZMrVWF17WFmGE3rTU+CUOe26vxvbUm7+1ifG8bk/TG0R3egfXYOoOXeFWzLs5pepdbFImkdAxWyn67vt3ahP1+W63CvYYTExikPnC6JyhZwWVUgJWp1v8TAHD2Zr8srYXLVvkoQ5LQhxksHSUOqAmRyKleDS+CWeiFYcF2J6EbnofWWcg401W1tmFB/J9qRZPAdJiJGk9khEdqVpIGEtXOY45pyWD5h3sSZJX2SaOTRhTJKnldUsiiM5lSh27GQtHnd5+8To+jL7t7KawPa5U3KO8qwF4YIWbw9dc1Pl59P/31Kv21lxMx27CU5Y2d1GyVUCYSM1nAW5pPWA6NqFSU+MoirdVEH75/Sv+rqFYqx3T/Rtb+yQnlMxjKAhIFnhv1COaA7w9gRRceXHdcQEridC3A8v9h4LC1C4iAnOjZjI/sBKfwOcfyFjuW50h4imlZIl/mdLdLJaI5RFilPXwqYuOi+XQSo+EUPn+V7BVRHVD0LzfuIf83f0rzrJDSPJtYQdwsrVTkbnmx10sgGJktkzXXGt+P0ISBnP7rcO+fgtWLVJojbUkz2pnlLVn1ixfwVrT2nmCsb+trTrNGynj/Qn89MsCOZeuT8USD/82GfrnqDfEtTyy+MtMuedylTUrZ3FgpChOSKxdOgdETOEzxDbbD1BunPhhR4tJGTG4ngAqF0SsLLd0aX8HQrXiJMn3ZEB0ZU0MLcmlpS7WrO8mx/TbwydJexWUzzGebK74fjwO0w6NV4k5Uiue2B7tB33Gl7SeU8J13JHzq+W2+uWcVnJP+esU8CsbtJ75pZB/EZFcZKwv21sZUbJSb6yvp5vpKrshe091XivxXWhNTr7JttnobXogbt9uFu06Cml/i3Fn23+v0w8/9pMVTNlmoHRHvsrojplbwLuvtQUgu3ds27z3asQ7cTnwGI9as0yFsH/bz0guc+PwcOM6/v6g9RMPLO/YATXt3ad9FiWZ4px4IvGzYBuZO4B9zM9fvEcASx++QSRtmv763TsMRGm/AvLosWXHH8QMfGDGPZeC6dMNIlrns77199/Zof+91+/3e6enh8dsT/PGqTi3eIzv7vPdPftbzqc/6xKx8CalP+g3dz2QMCVJB5ye0nITH+h3G7eKevye6I66OEp+ahUPvIFZUrTWMHxgK5OjjI/zfoR8BeaSAlhtlCFFn1RIyUByULhA7RhGgDoeGlNn8bKyranJ++p7mfgXZKhS6bU0qdNtYqTipM6AREsU2EsXsO43BppwWhUj1dHMlmcsUxwxr1s55hjmv8ZBJzijltHmCLhU+6SbzQBlh4Gsod+PGPSsYEN/OOYaqlgNdK0iIltdwBtIecbr2ZdV8GrIZUnYknWhWjzmleSnG/rkM0L+LWnVj6OSPjxQ+5iO8vb+/VOs0fKldVQkDkpfntBveHEuwzcdHH/xPfnDjf3xU1WyVLt0ugaNebpmVY/unm1XVuNLAZZ3xH8gcUOpTE7ovej2M11Jez31Hcp4t6+NG45sgUQrvOQmNMjSZmw3UstIoZc1FROr9KO6h8RRtYfUJPGWUSyNKxhsA8twyGlaSa1Blx7Ir6ZWrUrOebVZrGqxPbjjoS2qPNMoD7BJv0j7hLXJQrr5BwIYBEN7whJDkLw53MiAd95KLcPOg0VBysn494nNAKgLOAwPimkz0CH4iL6mCzv0e0ioUubUmjhe0/W1QJ+1eOxGBMrYqP43Sll1EplLosbRJ69ZAnhAF3A4jdoBQGYIqcNQlNQNLqZMCNgiBTwuhPcBwFFYgHLS/hNZZXwoNUXscxSSK68B94KehY/OfKuQEIMA5YXVmVacPF0RjQYbjIIA4k5iMAQqD4dISqc1vgkiZpGiTkKm8dqUnVKaFF5Gqg4MDS2gzjmCZujeQrEM/dhmF4b9UzMKYh2OBaHjadxf/IR2KzeKjCrp3Bdh0BVh4HAQUWC5QwbP9grDCk2meEwPziHeMqLCfKggjuLmUF4c7IXGMkeU4bbp0r7jpiQj9ZWnpUusbYZ6oA+aUrJPeZm5GYsvLOMmLLqJFjudZHD4TR9mp+aqL5qbv3tIwPpe4N6oakfreei8LiaB5akEPnyeqjtFx6bTse+uURLFB6kQRFhkfdstBKPNlCGFEkG24AWK//+NcOzsW1n6ISPg6uHJ9lfPrBUOva2r768HBjsWqmekudqFyUu418aXG+txuemNB4rEg6gtD2jah4GlW4jRbBrH1rWbJqRMqLySVaTFhMoLPzZpnFpp0T3ZliU2ZtFhGi1DdVKQU1mjVbyxxF5KEXj6/JCqY5GHrnWAwsqsLSAPfyM8O0Zg0HeazzXIiiUz3J0ATvUGpEUVe7l1RRT6VxyCLPPQDuiwBuiiGPOPRxdCgzOiiLPeO6KKo8orRRRn6AV2WAF14DphoCoQxNikzymgLviPSJP1NiDba8PeGOHPyLPgmEGcqlXlOgzIjjVFXPjPKTKhHl/BGmcED1iwD1kypys1vU2rcydHhyuiDdtn5CDNesSsjizbkA74sAb5Mr1UsalVmnMlXJ06BNRPpFyW8MQ37gDlLgDnwOalf7gToIoHOLQfZEuJIutAMMU4IxYt8lKB2xMzWmOqldHQIWDKgiMR2VTZ1btcSw+A2xmLJkZrlWzdHNGS94tiQ37EqX5hbx/oNbG5dq0zqbB0zT5P8s3xp85ApxkElpEXU1s29HLUvRnznFxMkM/z8nKpmIUtFkVruTJj0BXM/K3xHmZ+VdlnUKNY+78hyaFPrYqRL8w1OCR8igi5afeLtOxF5EvnOJ9LuwE8r2VAwzZgkYass5zpwuxiRCSDoSt1rIvZ8WL+q16wK4EyF672tvhN3erTokGYrrFgXw9h6++7UqqA2/ISE126HVOrqigQTgF4Qxm26rOd0dfVoAJ/ErtQr1bO15jmaHMBvpAEUiEauxl9qF15ww/KIpB3WaZGd47BxAmCZjQK8UpZxwLK9wL8iNP9RGMUYE5uvsh9gkBpuhSmMDv2Qrmi9gCXzp0utQs+01sSeaU9LFaylmMywc3NyspTBfyNkiS14fmRpnNbkK2E7MhNsajXRoWtqDgu9WrMBid+N0OnOZo2rFo6SzU6tTyaodipG8eZcmeiaS/kiPl/T2pKmFe4ZV6lZjerSkp9n3xD1SZjryemP2OIboUDJku9KgyjxueAxMzPTw9c0F4f1isCGimK3U10WknSBVouMsXiuIG8eBUv9a80kbNK7HKyHQ9C22dx3jHlbcRTrF2G+Z83zHXMGV3lNZlq2KhF5y02a2OV8csKUwX8jZIkt+O6MkaTeuw/aI4fcyPrLk8MY5C+MklBBl6HBWdbpuTn1yPIyLXMiDdvfEGUYOKHTb2MA0imkOVKbb0Wiky6aU4msINqxMNMnFT/PwMek7hK0RwIztWivlv1bYF1i0U0QfrIcvwOYGVWNsp/DWwe38o515fp1mk/wNrY+DlvNZy0r87a07Geb/8iJbaEH9EGnj54TwbtLCGNFeAspwahUzXF+JmVykg6RhInvVHVxeJtE6saopJi11fKI00X27yfWU0AJiOIuIgUTz7qve8g6DuzKT5Vqnf2sGj0slvZm1fqW+Be3P+BCtskoVAYvasFOfl+w9ymXh94/cWLr5VjKHu5IlHgnlv0/J09OTyzPvQhRgDwZEaqExEHhMOskoUMfjvZhKwc+pjq9MyFiXc+BCM1wMYOxkVgl71klVIe31JUfqE3nE2AEY+VoiCf+PtA1RW6UgD5HkIQpfCIwhU8qfESeyrE/oB0sr2b+acmD6CoMEYw3BfvEoMtqxKKuleMstqLPs8p7aBBOyQPMsoe+ew1nvuNZXTckNPrGpDSKLThhjaIngAxh/SqoGNmmxoTUSmI30hVnieM+wn+YOw5we7HSItkdbpykKJkbvYmmS5pCYLQAtmlGZ/lyhWrkDpZKlZrBwAxRSH/u/eJ2DwRI8DhV2tmU3GhkmW/ozE4o7hErcjGra0zvY0xsKowv4vuVF1wA4TEMx+oBNwx1GEcV0ykIyGSCeq7PNiEVnLXJ+ar3G1F/tkzNq2obI0epTZIzqFkZljQdgzp5BXGePWRiWPC+OTbkl1HLC/ZRqz4NSd4PZEKcPq/MHtKFuQVXkeY3t4uMiRVyAeYnpB23sSbMnzDFzpowdQI1LW1jDGIx5n8XfpmzBdBYOcyIeHlVEa3VjM8/butm7z5/98ow80sKsnDKKEdnEszWzSGZmBk6lRcxa2mM1Y3MpHPtuJ5z4RFT9P3jd68PT9oYrCknBQX7T4/KL4cSV7rBCNzhx0fGSOITRRTXY29naAqNhIjhtJzHCS9qnwU7p3Pl9vpq3/VPZASrV3oitx3Y1NYh/YMaF1gWMSxrAHsjti8/PvqXE/qwTXasl/Dq4U6fpAfJPsyO9Tf5Am9IoyDB/CIvreffdNcnNb16WhLS4UbmDASFQHMLQTnHRB4zEBBxWcYUHhdB4OkitB5hkdwcPY+HZZNbFFVTuU01z0FMdspQEHBFol5sl4Xtu2bbi+RufhFgKVPYzLDzkzVNvuv3PBfPLNTWCFhT6AIpoRe1aFkRtnCrJFtbSgOUu781qOVNxzrDTpdTIU2apyl7TqSYGYmn1BsRwbFoeEqeaF7QjiSZ6CsJ61thWlc4FgYDNLBgzKRlR84lSVO4V+tjlbZ04ka97MeUzcZmop/OnhcSpzvKFiD1WngUmYeiuWR8NdGbxwyFkxVK52DBiK8Pf9vb/6P9Zu/9+6O3vxUkuFIgz7Cbc30a6J615voR8Zn/FZ3BAnLLN/JzyxcdqdulEuSmJCVVceUSHQlifqfq/PLM34XmpIubmN5kp6tEr6y1rC/L8UcMeeDSNNkBbEgD93ACLxQRQgIEsc1oYy4uqEBlQwdxfXfFiIf9vtT73YM/1NQ9Xw4pg5SK18yWloXRSG0G84P+yZxlTiwNvs2ps7Rt5NaqD5KDxW72Dswlzt3naW2ptjhdVba7YYsZ93UcxLCf/WH/goRWcKnscbz5sPgHF8RaX8+Vk3nEX9hWp3ZMBYaaG7Nt9tJoR/FspSCoDSiUJUhQ87OJWhZhQro8IyvzjupBHO+M6kmNuHE59Dipp0obRTFVHFRMUMiglieHxblTftT7UbSuMBqkHz002JsYK8ux6aUNnzRhhn8izo+x+aMbPR3QZO6XVGZGfkmJybQvrXsuzUK15RM/x4MF3/zQI+r04DanWs2e0NJ9eItXirWsXjM/5JifaZ9pVTJmbDYWat4326ZaVcMs86Y6vLxUfNSykodNtKBNtLXimwj5sb77mR6VjBaJG8pc+7WO79XYZnPiD8tFq/SNVI+DNt4BirebCDU3o5qjXO+Ro1zvkVN4PRFQ1z4J57r9kpsTX2cmOcCnHe2WoyQu/Aif4SN0w8wJumrOPvpi03p80CA6nPNIoZICNOsY6vBdEnVCl17i0iZCmQaPyQfbsDgHUDobRCrV2hB6jKXA7DFnPlFMBlEKSp80mAvik0s3zsCSAg0ydKNPGRh90mGI52BARvahBWi5fLZErgv2mm2uquSxiM0+NrqlmeoKnR9aS5GZdelOs+38jbY96Wn2rFzbzOgZUQj0dUPYTOgxMeNJNsZrgpNH0WVCP/YLHCiSZMO8nwdXiq+1501foxgB8lp8XWy4FzpsTpCd7NkJ82MHAl5YvK0m/hYNvI4P3787OTp9d/wHOlOcHh6/zcG+s4+PDLCPEO10ZLQVp/3uc3NrhVPCfYCQmYsxdzDWIBOW87ksDKvvHe+/Ojo93D/9cHyoNBFYThhjD+NyojkdVRg4nQ4gunVBeq7ftURHaPzSl06Hun3I/UkMKfR46Mdu7JKIeqoApluwGxj20gBQaaeuoS/Grz5nwpj6m8ODo3tOlD1bPKf11opGJpiQQF2RuJAc8foViCY3I+25IkmAJt6B2zXo4QyHr9kSg/eCgVGODsakK+W0is4gGXveerh5hTVbTTujyZEAc9eMQ4QEZtkjBM2OCbhCxeho4p2P2XpzTt/EEAP6s+W9T8UV6BH4kMzq6219jP+dq3Qrhi0xKggr5QdE8rhjySzY9MjCtz+eEqkkMQdpzpj5aiQkSVBwh4YcTiWS1vPnaZ/nD1j1VbGKaLrH8ZDlxii2To5P7GHHYneAO2ER68ryyDXx7opJvC/AI/brAYu+EhZRQ2i3WywvEYFKijvJEicxB8cagReDS8g07BgPz7AiG75sihjdFDwfoqRbfUbD8HEXj9QCnAOuyg5fdYMGPPW1GtXw1Qiw9FEwp9zgCQ+kNWOmsCqijzGH5cR9TARMbazMNlarMhnJ6kDPtYmqFrPGj/lgOntnROOhNoAjfoKUrD0Ig+CS+VcQp9Nz2JwPXOfKDzDDluw5lw+yPBEy81YoI9XW+kL1+LMR8RUzfszfW+/x1zGJhp6c5UEufthDD3sofw+dwCPdMFIcopTDNdYW7KiNe3R2XPq91dIOv5Ycb10+/loT76/tMu0vs6VRMVihgnN9YYFYZ9hkRouimhU7IQ+63ttBm4JeDW5THW/YJe2YRJiHBgN0AUf3EjONaxZIQnMW9LxnC0XVOuyVwLsmYp4EZl4rjoGJU8RnBRbfudtp+0GXSJZOB3nBYUn3Ks3qlQCdnatAsO9GNOsUgJ4QJifh8Siroh3IexKu0eQVWTKvDkvRpdqD0IwRvC5npvd/jLTyj5FWPpo/XSnzqqmwHCqvyRgUT2EK8Hu6CN7zC4ZyB1yny0qk6P5lEHZIu09ih4VZ5oh9Gg4JS7CQsWsFIcqOh0wsvkbnYWWzq4vxsfbCKzW1kj6Bo0s6eA1uhX8N3ZBYSZV16RKvy+TwdBixax7vTOldmDwLiAt9hXB5sRy/a3Wzy0z+wkLW+LnYFVICkRacxJjnqYmaPcenGWKiURSTPovQRumU1UnSZAljXUbtrDjN3RlBJ+2sE5HssMnUs0q5PUqqpD6N82zt3EcCvDGR3VuTh3bffLpS5iLT8RbKxx3HYxjAF8ZrzJufTVkNdYOnAlvlaNTIjQm93o/iXsBLKVYTnqlNxTsrcq98B2V1uqRXwiJkHJQ0TCM63VT1J/Ay9RDlZfbHRz/B4j8+MmRf+vio3R6MOk6nR9rtj49oJ3Fo8z6rhkjVyCu4/lAKcMiw30tYKt6aOcS418AhBbY6tara3hwnPAqGQH+lPp1uG5kVm/idAG0xn398NIwv17ZhfXr7GNAdWjtRXB84YQQHC+2Q5QajBqricquLS8HZyrdVK2B5NpsrZbE5HfXpEmiEP2mEqHHER4deXMaJeyM+8qI4FwSFO3QHk9tBfji4JAdk2oWQBXLv5NTCq4gpjL8buT5sZb9DbGhaowO9hZY56S0Bpu52syri5fSxFwMvczGMtY4ADyklOztX8+Z2EVWhA9Uym1K3bAgEHDNGOk7dGQyI36Vt6pjO00Aj+MAUhJpLaFTSOLjpJZnHdbvVnJC08EHq/4H7nB0STCq4gPhkzfz4ZAUaheZmienOxdD1um1+YzeFsJmq0WIDoL90Ookmaq6EyLi8JK2myMRrIgNKoBR1GyM7v2KfaaQb1G1zLohKSSzAFcpcwAoJzaWp0CpNroLckIxXn3asa8oTfarBD+BlpKkmOSg19L7mCUEwTTemHnHRzfpRkiQdM4R8fARXs17QZb9putGPj74UOvgugYPHZqmZhZh04rYgERvPMJhaLEmWn7sxDerCskuLEREPaAMra5BgIMfHwPdGNcvHI6kQI7+3XrphFNcsSi1YttxElGjZST7vx1ZyeEaqRJWTGUkGKYsvEJlxcm23W2MHdXLNESlBfnZZNowbCW+Hnsmmg1sVsdadLjvAzb4rc78SzJZ052npT2Zpe0x2LmtNCtF8a6UOZRlbijGdHbmDRBvAW+1YjGSQbpJRnsomMl1BirAayi+nwEHooVjosNRSBzllmH0yAsp7exiGAbBWH3wXxiULoEIb+VRoI58KbW2UmAyxqOmeN5FcQgOeW9Sir8ZgSEvilwA8FyeQSiT2fVQWgRy/tY8W3NgGNqhriObKE7kYr9zYtpqX3kUiU8C7J1d6/J0n8cC6sSIPBCqUeWS9TC306AzDEIrlORqlHgg5rdQD2+RJPfjIFGSM1GMBVKeRT3WKohdtlZjqSEzrOKqjAS+U4SlOw3YX0iNz7iLpQWHDBCkI2Z0BGRzxvjNEe+OM4VlzbpyQcK7IRJQo+eL0hMkKWGC1Gh2uWveCGxJKBiM9YKvaSTP4U48GsI9sKvKrnq01z/H69ArYLsDyfZQn1LmEwc8iXHBBbiSPnJXj+GfnwqiUNeQ8kdAiLU4nLGteacxtgT8UVE/xbar5lfhO2nPaL0+hKvbZrFvsG3TdEC+b9FUMWPyPSCLHwqtKOMrDt6fHf7Tf7r3JMmzdd+yA2diezTKLWCjrmqkkxpEgA/jcrGcds2WKM22U77uQImV9onImiakRDweefgl7jw0FvQzLhocOQIFlXzgRMjd4RrPmGu1JWAfUvIhEREIiNK6ggFXrl+dWy8zIUICzxnmN/wIqpDA1QjfPn1vNfFarlnameSSxavx3afmGp+VmG9AgkZLrCbgGCXaJshbfkWlIl5XoLJKjatLUxUzCAXyDhV3RRwNmxr02PfqRhU9G0JkBjhi2eiVIWtcBBwCZ0AQMtRA4dVRDBOHkDaInphYfHz3hveHRKkw3BxB7GQMpTAJuGMkU6PtmIp8MvLq0+P+sxPjPLYzYhZ1aFY+jAuYWJVCM6AsbIy5NbCg6VEaBDawLEt8Q4kuqSoMihAlaKRP7cdhqPmtZbtfyguDTcEBlptSmfEjVidKlAkPOuV1Ji5o6wJ/TQ59GAqSRodGpvTon1Ygw9lnereZcNGJoUyOGFbU8u+/Lw2yam/UysyEU5/iGmERsaoJffcmpuqo02pLn7WQSTSkcnzH0RUKYWFeCZReXpxqNu7gQFAdbDiGo2BXeeDQOCYnyw6Xha2ArLBk+WDsUvKnHYmxOmxIwDqalZaxD4nilXx5YM4s3w1Sl1K6CYqpgWGBdu47168sTQ0yPpKHm0/XXkAyxOItsI3SoyN4YM+J0/+PApuqMaJusHspFdiNZjcptwPgKs4EMUXrWM3817VTHYs5LCCzPIypO4EXXpNtOkPrjI8M5DxM8w37OPj5ietOPj87PqTEGL2VUEEqldTONCX1PO7qSBW3sn7Pa+iAY2A3dDCwBgyXSD7GcXEOr8U3QIWYk2HY68FWU1OBTNyyBYXju+ia3ybz0AicuoFncLDPpeMcKrknoOYP0CpSB+F3B0SVPgytPycgJNOoNEYPTxcGthFNA/T7D43hJfmoZvGzwmcIKk8MvFDE1D7SRhvyR95VBD30D2H9TMGM0JnGEqvWEltF+aAw+1iPxIoKrXwCzM5vpaLP5DVAZuFD67DvBT9jsOMCEdCanaYl4H8MKMxaomJZkTa2k6Q4qW1lRcMnZIurymrAETNySR0t0n/pJ6AmfB3SusVOL5GfSaYg8TMrZVCdsYGZ6BLqTtkqIjvbSqsvJ0XwTtEa8SrS75lhWs7YvpDpPV/bGJS7Tli3Ha9lVKQuEUYPD1VDMWrKszOZgYQWRAxKSJkwFjdc8x/VRh3vTG3FihvYjwvB12fvfiQLJ+38NWrWlaB6CcQqQKtQ8kf4gHolNXCA2mGBux0qR8HmDMmMZEkIB6m9omIOr0Bn0xA66bpQSiTZeSukUXIw7Ao0cqL+8JPQKlPklxz1uOYOJTuT5uz6AwVtgXQlvvuMBLpPQ6jkRwFkXoYuUlqVxT2+4sErs775J0mY+SdrMJ0kbZbbroO5L7uWoLexX/HwRs6IopEbFTVff+79ggSoJEhQ5TD9CVcs1gzRHIFFZLe7SPFFMTbyvjIPKtb3d52uhVMrhITZTgziJWGn6LMF+TpJcAaqIsiSRPRPJWY7diEz0cERpoQxpeagQtnDKe6VaLsrEiXe/DNV5K/5Wc5qJKzxKqSkuker6HAwvfd8EaTbH//XWt3AfY+dGG6rjiRkjrVGZ7mDi2vLpj5HtmZgQjacwE5KrLHy7OUBK9vwS87IlXAJd3I64CM5SAeuBnMjQ61oXBF6JIFgXpL40bhJwY33Hsy7dW3RjhBtbvWbB3QlZNNnwl1/7qnLgJ2ku3FpYnQ9miAuJxMMdxQmLk7BCnJBQVieIoYG+rJr17ljupIJWRnCZhLE/PrKCJVVWb5WaAA19eEPBjQ/7mTh98fQfT4eK25aCHOUvUbuYUdM0xgrlEKZCWiKQElOE/H2cioFWZM8U9+gkqJqNXYXMwqVrN3KN0qFE2XZG+zm/Ly0TH7/Q1CWnNXWRkojUxL3wUalsiXenuUWieIzbGsAoSyo2WhkrPpapNHqS2KMlbhCUHrH8sBcimRGK5mZBP11sR6MFfcEyZCrSpBI9MT0AX1FqhsZvBP+Ba1Ud6yL74FfMI/tK8LRd4lwtzZUJMDx+6yUl2gYUK8q0DRP4gs3IMxqfPGzJRW/JyLkmxi2pVcwvi8p0e3I/6PcdvzvHXSktzU5+JLuTXnCCAfHlXVmzKjeVqgXXj0vh5Kd7uDvsD9JuatYlRsfuwud73tK3bzDHjdvM37jNMuS9Kty4HS/wSRs2Bvzf8UafpXuDsXJ+VinTbeCc6CR32MDa8mzMkUMNXqtStp99BKSpfajaIhz61n7gwcUELsq0aeRGtYQe66b2FBVi0h9QG+9TgrFL4HMfUA9Tlm8I8CHuD7quKA2lk4GiNNg7BUAtaTpNoPEDz+nAbebRE2b/3pZcWWAXD3Crmzr5+IjVijeLDL7e/wT/ipcLScyKL8QQzjkaXsDFBbPY1+El/X/2vsXNaRzb81/Jdu98qeqBUEkl9eC7zH41UHRzbzfwAd2zu8D1umwl8eDXWHYVaYb/fXUk+SXbeTqO5YiegUSyZeuXo6Oj8xQChz5++mFmhXEqMhiAfnz8mJIz+zKEf6affpiHoY+fPnlCbphHdwOyBp98S2b9fcDHAcf7GKXTz0I1e0P3IS+txub0jGa/FpKoWA4ivc+Go7P9ROvWxWqupalAtpTXiI3MAEfXS5brrLgsu4G+/2MHY81m7Oc9Cu4tA9XIfpbM84Sr3KjZAkyV6bboWC5TbDyb5JlU7Gs/t2bzx1NI806daAmqoOCLB2B6Btt7eExO2VPCwVwDlbAs9nf6+AAxHSVTORRei7uasMuSVlii376f5l3fkntxNF1nTHbZ8jHZ3z9SpgxB+2XTY9eQHvAQmiaZGOPEJjQqCZQGopsOXA1pCWJvGo9lE+Bjw+vEXfnWs9N8pDMd52+F2GRo3jfX2a5MxdW4G1wnjt+N2Uv8fWn5ibNN5BiqwJzqRk7LmW9MhHAyZSDSoEY+AhNKDoU02h92ez2Y0c+Dm2AWOQRqGs4fnBDqpo8i7O1ZyjTy7OGOEPHc0YMvrJxhIlKwwUEDp+l81BPYwEMLBUDzkIj0GdWLco988gQfItrcyIH+ObJ90vSBXN4LvR6XulYP7/nJ6OTgmo4+SYZ8ndQdpW+8yeiQjGEB4zM/PzIYJkIZ0gjpo8xLw7awSHEiD0h+Iji9JI8hYwNf4U9jyReg7STHq8w7MPzG2qX4BfnYz8QDf57LQdqTmMPx6dJfDX6FOg9KhcJWl9VVHS+X8JEzWerdxGuQiK5asgQkVXaKcxCZyIXSdLad6Kh+JU90maaW6pE2pTs+oxPzrqg44hS3SmVk3illUVM8UFqt+1b8sGUq97OlvPHs6HijzPr2rfikfMr2miqDd4F/Rr5JgEtK8mWJtqSrI2QrzCyzzTNt0++0v6fPCHnM4BNQFwY9THxLTi0F6Zqo48vHgKWngSvNu48Q0kQPqp9B1RJAnBIZJ6INNOKJ3Ui+xsevj7Q0Bn0Caf0YX6El4zC/XNaaO4CRB7DWzJIqGU+/nyUBaGw8HDkn8GrZVjKHs3Qm/Gk8Dir37KVPSfVO2ecU+9Z+WnzU5D8PJGKH0yX7dfhPQb5r7NdKy8JS/xu4kAz/4dXtu/cZjOgN7Lj6rK2K9rMO8Blm1QKgi6a8uLW2DDW1mvA2ZS7pnFLDXVJlGUxCJUY8nZnxQi/2EzNjK1yO0UQBlGtd0xAVy4arjGBrG8DI05lxKzOXrHlruWmrYNY6zQmvvNwp+2bQGmLPemetPclfSaeFLi5JaDG4wTi7KMX22pZlnRrpTVdldlJsXbJUy6ltOb8u35VZ03uey5dqblmutcZ8Wrz0PF5nFs3kBp8TjXDGckzLa7BVGJvDWW/mdTdYeuToV7UcL86WLEdJlp+Uylumg2c4586KhY76hO4aEj9vu/5yszqpWnUsuXOy7thlsC3GlX55Te/c8otXJ0uf+CzrXgL+JJFrTS3EvWnIZdwwkojN4PydG2JAjb75LI+ZlGo5gwmUKn+W1bzkR8pqXtgdsYWXHiJ4mkhqCM5mn2dxL7mLaFPuIi7weqFuJ3ZjEJlZcoL0VJC9gGypqyeVSudZU3SljXorS3U7Je2xIGnLyFdoimJRzs411lbMAkYFFpJhJdkmzkZuMEZBWN9OnsyFbZU0HO1Rjxxe7zyM6DaX5ykfION0ErBLj3pWQbJOhGeanige9mOcw/Vzspz4c4QTZO6uuP4lNz9/+uF/QVGLyPfzeaz9AIpwEGH+0yf3U2RenZvkb/PM7H38Brd+/9z7wMB82svI9olFt5tOfCzU6BkVTwbw18lpIT66/IDFprRXK8u4mqksq2pxLr+wYkAAu2Z6Zu7wnm1stlBvZbb7rQ/t8Vyo3Q7Wn3BMjyP4dbbeHYRC3HuBppZrxXmYXhCyzDEVMhxs4kX9mOmlSr+cAmq5AjHHWGjSJPou1Pl3pXIxJ++kD31axZBGl2ODiAaxcpO9IdTyhXtjbvadvcECUikVU/S/1G2MBF843TYiyBQQS3JchMuoJdfTSSYTSDSFaUt2zMTdbgMNZHbsFpptx52w2yI9cJlvaewhlFhui131cZfDyCzClBIm86inR6Gn6ab5jC6WPNO5YZoB0XE07xUnrk+6PHPWifYxmPXYSglLyT6pID8hkJ/QWe/X25t3r1+9/rn38t2b38SBQf+fOt/RIT798OzTD72fepOzCsdd9pJU1CI/BTCWzBlJOB2VAZ35BQg8BR7UQhZzns/YdCGlMX5OfhNGsjlTfL75UHFDv4dJiu9aDPHprBLm8gwO9nmO8p5clkS9p0kMeuzOHNsAiaVEekmPSzjujVlIcXHmzzaGoff+uPn11YubD6/evO6Rf27+fvP+tvf+w82H399XLMqLs4KZk0ztaTbsh04K+8iwppbBOEe5eS+7JpPlWMH0PmfVpyXm3fyaXs0d6cyQS5OobDgSvy03FIJCxnijkdooyQxlSzpQZDNbOfKPJLGa7OLE/w/9Hj2GgnxmxnM/5TkrPeBj2l3lAs+WP794xZgP5J3yIQHG3LMMhJ9Rv4BkTLD+5DnKqpFp8FN5PACw4WTkXy3HCtNwAOASq8eGw+djemhc/erspPrCe5G4Pawcn0qnK8feqwPWVbUD1tXaBUMlUK1wY5821S07Iu9KWYjrBQ55Sj7KOdfYUimlZDYCRzkTOUoyrRMc3QG9CU6s7978eqv9dvOW7sr8kke9+Np2mg2GsgnLpVQYN4q2A7G9trSkdW5sW1Bidl6xSwt8jgnSwPdxITRIJpfYE0EQfpLsaE9mAfxmsCmFc+1+OCC3xSI0T3/K7AM3BLbnSUM+eio9ymbtAC8Q8nsvrHv0lBxi0/f7LkjK5LZvfag11X/6H+Oz771/9771QR9Pvk741xuXnMkhPSdpG074JQGCyjRkdz6BV2NV/ALnlFxyfva9II0/ptL4cJwXx2O4yfzOMvbI9KvoCByD+qjXD4o+wGAupWCRywaQzuwdbTiZCrnmA7Ljs7oyZu4sEJ8QUrDi1F7kjo99oIb+5+rUXnuVkLcLdz2XzniQlImc6wGZPliwgbs890wEwuBvTO2bZTAlXbXFaqxjTKjK9Ld0RqLkfJbhLuu7zUwju0GvmTNpQ6cFYoqbnSIxlXTVlzOyVuFpY7LKZmfg08s40jylRthHtJohTxhp6+4souVC4irNwlIrzdQAFRD58HFVxPfkKEQ2YNKaOuWUe6jGqtNfPd3sYeTohLEavVcvuJ0HWyaON1XBTSe+GGoB5Vx0MKtH9DG1wSejlHnqpHtNcllhnylz3cltMpnnZnxwoEpR0QOHTzZTH4B+rJgm7cvNL06qwX1+yC9+lsw0Hak41X3LwufVPGZJHsnr664wmST6o4zNlHYuzQGzx1PamklgNmI0hQme8H81qH/4lGWmFtgJq4wGclvejJWE0cRsRTcCD+OeE9mhRYioZ/BxyrK9MP818qNbocXSskTOiTNIGkAedHhoTvJ+p2XOcexGXkRy5V3xeuSPY5moV95FC7kld7Fvy+6KWUiKkT8HILjwDZ81OjIMStP1pmeH0nGfCkWlYYRHPaqdopcO7hYabawoZZ0+sp1n7Ym0eWoF9rKF3ngz77x95H/ZiIXklMewvLPOYhpdKpp2OuBlv05OIS0JFBr8OPycXxzUzSbDJbJ5VLjHatxD5ISUnk+Sh6YuaU/0kMgZ5OG0vhi4td18+O3mNfv4Ggo//xPUyI/WGoVb0rTR2WgyHA2vMwP2Tp7H2aCXDE2h+PTDk9Dxn/gegpqIXCMM97ylLez+tzR8YMntOCOjaTQpeWakrACXHe+v//k+HTKHepanFJx9E+te1rTH5UcwcOXExxLhEQ8GA6ph2KtOeVytU17irjeWLrYAKoyGTI/F074iPTDmGgsOy9m+xY5DxfMuDS0Q5iPq8a5F03d2Uidf0OLBC3j1IAgR1cjT0YycU6AsF5Dy8FywidP7ez9b4S/RHTOaeH7W54MPmRVN/gXvz0LxkkMWC/ChHqz46d+GZ2dnvW/81u/k0U+pm2rGRJYXcwjv0x0atPrph399InOjj4CVir0ghAZqzQ0wW75kUFjJ0ApDskaYrU/d5Z7mZv49+yBOzMzRmTyEHCro8ebnVx9++f3v2s3bV4/4yzxj/5zm7xsEukX4IcEp9jc4zQ9P1fgfv8Wu00+pIXoa2bbGfanhVaPAjruYOy9toF18lk9jA3Yw0/9EAda4he3z914xuz436fM3hNPVySm5u6XmAvnieQssJtuQ8wkW2ltquNqQxWQvP1nOU9ilphB9Hl//KGYmQK/Pbz7c/vzm3avb9yWyeNEkYKCL3rdkScc7aKZeBjz3Y3wBDbkv44x5plgWj0CWckSEmVHvGy2EKg58+l3Iv8eXPL9QXHNsxz94ro4L2Wx0REI1tVyNScczI5sb62ivF5DTWj7RjNi+dIO/OMz+vmxm4pliJKzE7PxOUu1Y4qJSNKRN9U/RFJ1Ne73fdN8H6fSGLAqy4AyImGUi6rd0pNzCEq1XmQeKKsWl6sT4IPP3yLLBrgceXTQN7s+p0vBHWgSeaQ1puR5eDpRqHvjm54ql/biLCRjyoFJ6rBiIlRBpHZ74GcNB7x2tvg5uvbbNLs3wKbJ4qGtwrPTsp/Xf+yzFLSEeIjTkeBXE98F17A5qZctH7Yi6V/pUWjJHVLrG7zkaMG1Hpvo1jvv+gXouIiyWnAJtz/vSa+EhYiJfNivumQWZ56mxGBBPM6xlGgtJ1oS+Vp4pKmYnspvrsnxrmVsS+zWztpTX6GMHBWoUSG/tPX//hxC1nIyaOV+XWcoR5MMgc3/Wj8Lp46v9mM1/7L1x7QWwHTsyEVzKTz+O7ka6nX3dgr2dGtf12MdAgx+k/3lADmCWX9AvClMfEJ5MmOEJGSIvTQhE1T4p/ro7KzwukFli5yjpOlCWnhUS/ZYLXJjfSebup5mVXW7YiMuZ6wbIvmQ7L8tOEDvEgCydGV3Yl99AoBvZj+Oh+FpgwfIBWFq5UWFIV7JOS4xnOEhxkSWrU//Y92Nfn3ht2t4D2BHAv1wvWbq8W3jHtyh4DBfkQ/foO8YZt7LyiK07d6b+tPetH/p9Sp/9afLBhQ/fT8UMAuK8cgei2F/p2bIppTfoRMCjyC+ZIb26tVlOxvLZUit5zAy5KDlEB2GWx5R0tbSaz5ZMRphgbEllFTuTFESCWAFe4zlu8zMfpQduh1A+tMeGKxb1ofJDZtTyhJvTwQOhGojv/7H3m+Vaj/9I44HesTwtEL3zyc3pGXKBN5FD3mVROmTaWxwjvoyc0x73fvrpA+WQWIc1gH/6iXAMDtDHPmWe/c/fV4zwnLNIzhTgZ8mPw3no6pFuOP/N3x5z5f7np4PhX76vgOUPFMBb5E5AhaHaGI1z1R12s5V1dXyo8hpb8pWcgdWC1B9hEpsj2BbWD9zpczaASiT//pJAkv7jx1Qw7/MwEuaNViWXJMEx1ITZpz7VUHdcSwOENM4RwKO6f/qociQa95K6OMNBq5fVQVS8LOOPubdd82V5EqvC+3J27Jir3/YN86Fjd0BA97yfk4XWKNexdz3rebXm43zt5AQymE+TdDJY8kyl+ZmIRo2rFXlKLXfqPUr8NMqzlGaSKOXEjmzmJBjnYx9aiJwdJxHqPyErra9pMZnzNKfPehnnCmoeFGJ96WVLErKRbfv9f716SzZrmh2pxwp2kdNV3ocsWGRuXV4OsD+zgCv0KTzwgSdChY/D/qPsHKOAyCbZlKhrVfsrKfCXpl/MT+3Nf8UTi+eDvhrkZXq39B+Q1IhQh0pheXnz6tcUlm+IHLZ+aG/y/4l0oofINraSOIaHkjg2YxWrBY2VIsaKEFQqOoAXQ1qiS4izousOvJG0+1G+tlXVmGzRPSbMJT9wumWnw2M6PiZjrxzW0b8+fvCCL4j5YpTU/9qo5lZ6YoO+AQWiPDqq0sTEH2fbaaaDz2W25yTZCjXvFG3OyQiE4YZUK5tJp1SuKmlBEYYL2QQOnr9HI/I1uTDgKtjIDUtLhxR7lhpYLg9kYClOSjy9TAqq1+zETgSBgxr/QCMqlAi17pkjaE78oF3wmxF5A4ybwWIQv0+a7zFmXBAaWOwVBwKQtUwAJ785H8WZd3zyPbLyykePl/zaEaF4gQc07MNyIRPVCShNOdSxCMWyPwWENWvkEouc1Pg7xiHU+ZyuBE/mXpbqLIqVUZ9SNTUV7+hE8v0np9mDTUkRVOF2oV+8HeYHnXWfZMYiY5lkGcs4x1gmnapvXMZZEt2CobueS5a1neUu5b0tS+a4OW8pTkvgL4mSI7kAPA0ImcEqmev3yO2HvTuE3N695UG+QjPHcJLlJDKxXJ3iJEePmCGN3Q6+j/HTNYCcJur5H896z29ev3n96vnNr9rNhze/ZauVrLj3b0tu5XEmtkX95IlUg8xHLPc1nyK4pOZDQQhrymQcsnNZb9MJxiZc6nVDs0YCY8Pk7MFftS+8af8zPaf51Pen9014ZTinlHmU5hgX/X1jfsNegxqzznIMhnXAZfCp/sPPaKkEM1rbH/RSOlNyGaMBQZm35yLl8s1LhZfzQxWQ2pzDZKYVFyzT4CgQO56zJv4N3oJ/TBMHUt9RIeGjaZLl6KKH+H6aepFVq+qFc0TI3ZwJ6R1/7IG3R3KDKNEk5STiwBvIqhqgJ7Gg9KQorNDKFKdJLvgQURfXZKBsUnsxToeM5ECozsMcBQgctJj4kjC+LFI8uRkVMcgaTRcunMeogPTph76jf0Fa/2nvpM91X/1HveuzU3BS/bH3ig7e06fgzRbOrQy3IhiSw6KLmI9+lmn1v/GX+E6H/Qa/zXfwbUt/me+nj2hYL+SRvH3xtHcThd5jyjETNYwdT6YB4/GWmSPOOsFVeKk2Rvgl1enSjgPV96yds+QmViNvobs0rMk4P6r26+2Ln2/fDZxcaAt7rsAyTM/AT8ruy9eisBxESN3xWdg8okncXe/h5BScwaY0nXv/L//n8V+cx38xe3/55elffosPMzRxPlus/4aUrXwgSFXz/5IF+/8gcU0WkEFohTaCtK7/7v30E1vKP/3EvmSW819oG13F5Ldk2Rz/TS24QtkLzuoyEBSZ3Y+9lxbgSLhxqN/ZiLJoJgLFF5y8Jycxm1Yd6T3uPXiRbTKPVT/wfGBV9D5QCIE7suVCuxlRu3XMdttbwnrYCbZSozvKec3HoRVGns0Ziuh+clruVmK55NRDFSUlfiUrDjyZVLLPSg9foqaEFnmYxk/4EfgMFV9eJS/xjl71yY3fzyQHirWZyneyuN0ff+ylYQDDUe95ctR7nhz1Tl6++t+3L8jr/TtpJKziNj6cEK7BvMj+3XtPg90I33D//fTx48f/Jv9/yv6iX2EEeu4BHiUeaaBtyWEI0nHB0els0s+c8IpX9v5WOBvSY1mvzw5e/e/09XrvPPD/z70H6IToexAcHOBWMDdy14V+xsIjWivHjK46oYaRKtx/cx6zfaLYfnHp/8YeG8sGYK+l92WsKXD8StthwPAZxKqAKNYvpHFngSS0UxxywA5y9LX6dOX1eSrVflEHLY4M5zV2gHnCdJ35p6RD89qAJY8kn5MHsuMff1j8rPRiwYUFBKB+mqmVusSSVwA7NXsZ+ERdSz6vGip+ZPwi8U8CLvzubMWb7N0RZbsQnHPp4vi54A+yNpdRwiTDRIlrfkV3GyP+8jMTeclVQV4pTKwgs4TMEpRLNLHELLSBNac2W9LaFp+1LEf7MQuV6Va5NpnpVtPXpxhi7W6hxcl4c7pWoAN61+jyESv0I+rVtzA81c1aaqroNcorbK8n8vEW/h1Otw4qUaukHe1Uq2zGUXKTit3v8yyF15R/d3vz4rfbgWMyv4y4VEZZYA8bTVCUJPcnqhFeECdzdbU7W7k6Intrpe6Vv3+sBmYJv2B7TiP2siMOyCLOeL4F/ZNPn8y/nn76hH9KhJ3M+oYcw3mn/GTtwgEmXcePcoU/4XG56sLC2wJt7fKq7FxU9Z7J+YpztNy77Z21bKdeGZ1Lp16pYC20qAAEsC9R3Rau6BCzEWZXznW4UhYTIqNleFjIzJ6UtJwTZbWbG3KipYrR5LgVl0oMPVNf9HFsv9JtuGXRY89MXilZrkTSCDV2rdn/DGpR/uDyrCij4fk1z+xQnHPyMD4edYT7VvGo7ysKjcXz/2tGY/XJffz4MaiYfqR6ZYc+hHG1p+UPaivDmUjPcBL9JstHpYGDZKlCV+ivzYm/Bq3upiek4ozKGUwmaNCYWy56DMuCmh/YrTRSJifW8CEF1gK+uOTwESKHPzPvgpu5iWdx5EV+eUpH7vlOl77mfWFVmnMHG/Y2gn9aogGFA8I3IVNIelARd/xH4pXJ4SS5krbkrvyeO85Q7g04lT655PiSjCz0lbxNidtccrfQV3J37DUn3CuHPHMpIXthpYEJeDZrLJZAzvc1ylZW+s5txljE+ZQzFbbDw5ZKr+yRK6kmkMpVIjMhI8X5iPJ+cHA/uRM2+hdvnmsvX/16m/VXyzIgclmxDHiVAJMp6IHKAnRTcaZcjhHDedPZEmpn0kTulJXxOvFsU0ssZeTkAtmqdNs+KT9exW8iZGlJcjWnoxVLnIAYRPtOwWGw8mhGjdOZa/9GqKwkIUvmZ6LefG1lJiPpZZWtzECXh4oS2ox57GAD4vqAHCPp+ZaPwIdrRSAv5Vn9pEpgPy0SmFpyigwL9zzXXvQ3CtUpSXs8Bt71+2+3rz+woqa/v31x8+G29/bV29tfX72+Xa/ScKzFflau+q4odxznXeZ5pntJTY9Ceahe4pFb1I1wa3G2j8tG38sG4pYhXEjSkNMHgdmcpTng1+3dRjSpthEtc/EfymYjSiR/X6dpPCEfOxdTyEZG2kP9q+d6zoJ15WSVqgtammylaqoiGzoXZZiyeZ6U1EEeXlwy1WDPC2a6a/0JlUoXrAIC3TinumPZZfVteCRe5lzQh2rG/cJRof93K8R9akzo/30Rovjz2wDKgFr3tAHyAff/0AMLzhvQcFV+KumTH+jV85KH3H4lhw6qQaLDkV+sD94qyKFpG/kDOLeHr/AGLyOXJUrpw75a8cA3736+ef3q/1LWVvLcpGgFfcgFPJZVIqHfCYH0f2OJPfs0XVr/pbV8frf/+/b57xXP+oX8IGSniof6BwvA7NPyoP1XLgGTVpXkTTvxG0ZAewpXvBxKZztayXMyOTCquE7ZJd3kO+JMyzhPxl2Ol8I5X1oDJ1ffos/LQnxyT1gRh97zX1+dgrNHrspD0v3X/3xPe1mdC9LMS1Gc9j8nvrdxbZ2Pw9EV4Q6j8cWE/HN9Ppp8jt8AEtTNEL3m7Ax+A/ZX/khnzR71TvSvhMb1r6NTkKjsEOw3vu2RUxppJr8euQiTlfrsBPjQREwy9yuahk97t/BKi9z5itICA+DH8/H1lXkHk/pxhAzjckg/osuxcW7Es7rT6dXkZQbk4/wkwfBRMuFHbNBnbGhWgou19B8gQzCVH63ZPHx2Nrgocf2hqXB7tn6H7DSHbntZz/i8e6yHlSsywU/DuovilS4wn/KLusl+inMtY0Dw/2TZJxejmBuxGlQljIh10EVIhRFgJ5eTwfAvlMNkxQXoGZ0PRqwn2dmhmRxo/5IwH5ZOGkYcXYwviQxxNbwkU7sYjj8X1/10ejk9Q2zdG/rZyKAfzYvR5egq4WZfCbMxKaM6G8DPlfw9KfIq/avIoxLuROSKqzxzeqCpuB/1QFlE/tEjcvCBj5TLDHwLnbDJPOIs4RlDi3MZHLOZytRQhTS55AG+ET5jiTR75OPT3rT/Dc5i5PMTwnx/goyg7KGnp08ffW8v7zkfd4/3sGzwZUlzK/q7yXFy0yykcXDAAsTqWIrl/zaVeEQRJxFq4qUfF/r7eD4eE1ocX49B2h5eXUzipR8X9ft4eXVBKODymlxDhJLri6vrHHMAtuD6A50Q0QydUEe4+IVinvBgmVRBfTY4n2zCV+AwdpFnLCCqDBkXIR9PvkLQEIz+ZPQorg5Kv3PG8qwPEhxTIFNhJZWHChLMafqEUfYJf02fwLla/gm30Jh5ApetxCe0l+FMzrrHcEyLnOjpMV8LdPJCJTyn7JJush1xpmViDgTpXaVliNNbynQ6SSdlOf/45eYDFVYuLmmKJ0zlmF8BCWie9Gx0T/Z42goaVGgcp1eWbfL9v3M6Eq5lyhoqMGUab6eEFMP8paWj3hihdc/SN5CLz7NvS6gZ4qNy7UJtxT+Y/BUgUCGBGvnTD5DcLnDY8ZTw67lLFu+nH3retId0Y54CJQpwBKpHsDTG9H8j+jf58c5zkp7mwtg2VbaRe+6fAMCgmb8Hkxe75jO82Ov4OvCGOns8LBmkxeJOB49asIYcquSv1PKUXdJN7iPOtIz7pNf0TBSyIjY9njy2TORhedq4Iqb/s2f2EiUtrOC/Tc7INTbnOW91jB9/mAdeNJuT3n8EYLcNcBXrec95ILn0RcTwovs74T1BBJWQdDvfxRcte3G2VuHHGoHWh/4846vPO4o92ZNdIl+QQ975tTEc0Y/Xd5Pruwv6kYs4onKHijMpco+SF15Dt0MlnoJqB3gRGfQRsBpgSX9a/gk8Lh0afur2sh4xH54ErMexZiw+2YvLm2VbcuZyof1QtYZWOAyLExKZyli0nGeuPwG3jySpAy0FQP4VTlXuPSQ+MWHTNqhHCq3LQTbKNJ0V+ldExAIbXPHyUQs04ocFA736+R1V1tDCXfFzH/XiT6c1V96pi8LlS1OPAmu6AL8qeBp49Zgora0Vez0UCmtlOw7kGb+8qFb5tARqH52VFdWK53bCyl7EpB6SHQh9NGldDNJWUlILZPr4Zmql5bXJIfDNDdl+K6QuiP29qC8Zrd6X8foqVNfKy8e8qnXv/9z89mv2EUmwXdygkX+MOfP7oh9Pgv5/g5M42boHf/1fp5+oy3jq9QXpWAcv3ny4+fXXvH9+Ycyscz7U3mUy+y0kNzuBwuKFdyN7GCFrITlLtv9Zb6E79gDrU6SxTLLiMwczIln4J8N4x4bfj2Z/oO/+sXg9ZIA7ffq5JLgwc+0jOk57c5vI519WyVmYJydUeLYCZGqY11AsOq+WXtKyBJBbMpqKCWap/WmP8Rq4LeVCkGb6Y4H9MC8yyAcQD9mLh+yBkpOfoHPMp5ADMrn1WY5h0cqZhTcl3OLj54J0yntZKT92Rz5FZHwBcBNyEZ3bisyNv1mYJiMSZ/a01//GP37vlydmZGOpIn2NLOg0JwyzjRfXc9kVjeYv2u9qFqe322LOZn+lbtuwjiFgHSrkMi/srLyxfGk/sIC/bFPiDF5Y6+I8WHVdMZ/iFFIYJhmwiXzPSnpTNkCVcZm6wMllecc039Zd6nX1MeOF/lfe+igbTvvXt7/evL59Txs//HILLYW+bDxKn6lAxaF5a37oX2//uP21YmjeJwztYlQyNG3lQ++b5WyZd7FzQoTv4TCCHMgl3Cbf1yWxIZ3Z7vJCOhZlMJQszeXMBOrn+TRvx50HBSJss9cnrIiQgYP79NwDaWL76cj93hfEM49kHlfCeTK3PCr2Js+gokdB9khupmkLk5Hy8kd60RYSSHIziB7JFxmFj+FZ1ziBGeuHtTmtIV3CEEovaVdI3E5soTC/k/VZAY14i+9PpHQ+znJ2wC8Sw8r++8e/0r108NfT/9lnXInqFX77/dcPryAApTQVmmewGBODMIgTa+Z6ACaRhXAck8ueloay0dtQcDKPi3onBYRhSnNY4vwFCwyDtT9Ko9pyY5cUoYkTIEKsGuVzfQ5UP+YmbIT4FUpS3JOeHvYclIANMLPQOseBwKI4elaMqmMjx8/52GcKm34//jHbq7kYd43V6BgSXGksF3gJnyn218ZkyH4WAnfJcJlsE2czN/QF0H64TH52G7CYcK6HvZv372/ffeB51HO6CbqgqPf5cnaTS3UMEkx+SB40R1+ywJP+43+A0hP/xG55Ch9PPv733z6z8NfHj//GGdWpUBSD1qJgQ2bWdF5OoOpOYXpU2UmrWvFTWiIpCCUrMmFsL+k932hNdvbI0+/iHDeQN1oSH9s9/SUkmdCot6AWoCmie1aRF1Rd1SG1R9kUi+eSZewB7mWxsiVajxmZDA57//n+zeseCwNfiz18CBbp8SQ+k4CBhXMIav+kWUHo3TyZCCZv4ehPptZXZD5hJlKeTORRUqIifsOyqzK17dIHUG1o+ri8QJF2VCUMyFcITcwt9L5C3T1arS8d8/S0eCf9veASJugAj0zGogetT6ywGygx7GS0TC9PWUK1QuwBe60YvqWuY9IdhrNFZP5oMDpUwfDteEm+jueUUh6kFNWD2f1p7z96o8Ju+emH3zEB9GnPZ6FmFQ/u/QdNSxN62vsPN69f3Lx7oT1/8wLyIP4tl1wLHgZkdDLMB9azXB/xq3wcfi7GvH/rP+v/dHFWEpUeP7IHj+z9cfvu1ctXz1kQSuHa6lFecOnhKS0xMRevOK2uJ1wwcEKmtIKN+7Q8i9nl8Lz3MmOahRuR2TthTLJ3/62goWE9GvklwAkTzieR+8X1Htz+aaZ21qpCwfwd9lrQ86raveOqmqlcSZe4me1WfyKN+fFAEhwqwnC3NNJBmUhWbil2Haik+O8hw7SqTnDZ1MRywZeiyJKf3QnM+lEPUuHRvME5uYR9hpdbUFPL6PEHyJX8gUfv996H4Bk1W/ROfkHkByfHMAOfDthd76hMjnsnz2m6H+pU8RJ+cZpDxI4vKylUDv/ECoT4MBPyqlTJx/wFscwzHPSycW69k58JsbupC4fuLk6+gjSSjAiCylemUGCpmGHNOjQynqVoN74Q+oKPpkf7dCjSBx8gl3P/c0nZ808/vGEpC5jfN/lBPv3AY+3jma56FZrZmT4UTeEfnk6+b8U7EnyhXrKWkX8HMjK9KTcyGbg/5e6qrKe1ypJx3ip8IS2DkaqmxFacJJ9SSEy/g67OoCxLAKoZnnCcLYje28ALPTLL3sk92V/Joeh+OD4dDAbCoZ6u5r+T9Rf5PF/ZPCL8cGB4/uKEFk/R3t58+OVR7+83z//r97f0SyEdT5KLB13wsbiTOFSsydz4vfDw0aBHXdpeELE/9gF3aQmd5KyBM6+RTVXGR+I7P87f8vvr/3r95h+VN1VOIJNMiKL5lGlI6EslKYNOk3zKp8sG+p29GQxk0mpAmI8Wv/JpEY/zAfxwBuEG8e38HOmS19cs8Jnh7wJsg7wLE4h4L+FXw8nZ6V4lmu1KUVxfyibRYB0mopHtgixX18oktUjdVnXCyxfYwgW31WzHoRy0l/qtLp2d6Kt9Wea9Gk/xJP6gMTdWUF9QJcwLywiLvquRS4vCJbdTjQar2KBnKnfmlC80Dz3VOOSedQoC/bQoGaRaimlL3bfly3C+YjVwB2SNAEkzLmUXRFlfdk28/6O5iCienGkvq0KcZ0KsT+lSoGviV1BMwre8ZjL2sAZVQi++n5E9ORBYAdguQLlZiNtMri3LLApx01QMjZca2yp44PTHnED7Y++NS44fDABw/yL7N5QGz73QCf5i+T0mtuNHvKgKFtOSmog96IsFdaiYpJ2IxSD2o3DuwVbF5e/PolsEe1zehyvxiiKb3NPMQ+ie1++flsSF9oEAcxfThsrL6fs+FSdQeTmQQu7yaUtDRYbSxYqsYDa8u4zXlHTVZgHh8liWy2Sb1rSJ7sRihOmdMKObZloB23cf9VyNXYNp+VuyhiaQpAojkMRZw3hEOdFrz0X5eE229N10udNNmaatoJt0PoaKyLSeM4CBT+Cv0xKjaXora2ZZMmB+5DXSV+89IYfs5NJ+iUk0vbHMdpFTJY4NMrPMk1PT6Lf0iflqBxmbaO9d5Pb6XM9r2BaodfXItMLeoN+bWgEOV9RJSMYCWQeOZN/Sd/9edviiMhFLDXJi68EMUdvTqSj3pKPkhZ69Svqjan4zWubyJQSntZTfkN/OZ+wEPuWYSNyQlVJ+e/Ni8GZrKWU93lGmiOSvKWoJMoxhRyXTfiNxs9YxpsNtIS2wlf70Kfk3p6FmX5dQwflg2AQRsPfLk0CNFLCW7LHk2D9ccu6fXF7IQAGh59n4yb2FI5pvgyd0ekB3M5tSRmlPllYqL1hCPaPBRSM8ZPnkBM4yHjVMWMsYyxLOcpHLL9JywoqPhqZnaPT8lTs0J61lp+Zc59IN6bJBYiqbkEhIDXOoLdOfjy8l4k/M80B3LSc9DYmNOa5U0reUhi4a5EfFyYgUNGyWgrYssizHBocwGKA8dwqfmLTDv+REnkzbUkK53oBQPvABYypJvi8hEfF1Rbee62ZJ46KaNC6WqV6u5aEN+FtjKj2NvKRnRwmLKe/K0k31FbWxm62pqHJiAk2dj2VgN5cjyUiKvIjvYSithGwzJadcc4GUCr0tISNxMiIJXchAQsPLC9nYEnmz2TzEGnJnlosyTCnfUWRJxf62MKTClERamshBS5eS0RL1SA/QDDK+L1JKyjUX6KjQu5SKzhujInEyIg1dNUtDW2qMLyeS0RALfdEw8nXmx6XNIj0wA92ycUpSy64qUNiqi5fqkUY1B/IsJ7oVsxdpsGGF0nYe16PJWDIahDxkVAfD7Fop2QkdBUor6a/P0LEbOyvOSSSmhlUC21k9hsOhZMR0b/2phd4X5GbYV9pWIKF8V0v2wtwcRLq5lmEjHF9JRjYw3sL3CIAa+urrNCV6SkBlvQVSqrqoJWJ6xQxF8jqXQVYfXci2xwUINoNwpCXJwzMCe6GvKLWXXrJUkmpuryudm0hXlw1vd2dL9ruzZbn+JaIs7COD/wZQXiqu2gsFw2iJv8yhsLy/QGfVly3lYuNGiG2d6Ypk17Dp7rya6s6XSFnXUliAeag/LT3CKAs+5WgobmiBeVd4W4EwZLDoji/O5CAL5g8aW9LjfLc5z4CylMVlfa0gnMr55IloLIVbwOhaJiJKKrlAAI0G9Y4IaI7PiKmqM0tUy66pzQ68M20tmWaexiYyWIeH5xOZaIwnW9AMVs8w9j3JtgmuJ2LXUsH7rFEuVZxMnoAaVhdcVhPQ5bLUM+cyERANQ/oTaTRbKhFGoWYbGZoSUkVflqCWXHJIBdTq2eUp61wGRdToUibC4oEdZCHH5JRryRJRoaNFkpM4jTzdXEghNg1HMhEOTfS80OgxmFzFTmf5ttw5rdh1eGfK6rnk6edSCg2lHM6UQgoy37MXM9sLs+64cVuJN262q0XspziZPAFdycCAruXgP4HxRCMzs0JNYyFogZELQGNflxLHWSO0kX9RMTy1WYpYops+W69SXqsJgnnFB8iEp7jGgtsFvIBSSEl7lmIqupeeuM7H19k/F00R1LKJim7eDTOd62oSu15yDru+lIvIYh2dMddTR8Sc4jHXU6Z9LFzQhsP9ygmK5HUhwzF/IolCO0E/t7XRppwUHTe0Y3srvLJIIyMZdrmhXBRi0Oq9mDkPOrRsdxySJLYL0Ull3bW5RtZASOUzE2lqLINL5GQk2bZmEpHCR/kNTWjLUlNJV22uITVQUnE2IhVNJHEOkSMKLkXeD7x7pgyin7I0kzQcPilE8X1F+riUJEXEeCLb7uX4UYg003IQdQjUvCCcezPPpQ/hO9nSa/K72spLW2CC3WD2Ih2ey2CNPZ9Is9vBoOTH8MlvPluAHyH2oOgqF7fF5rzsXdZbn5Pacy/I5UlOvi8nrOoJCWb9Syn80oZnUlFSUsjC8Uxka8gNLGPOBfKKvpyysvqS2tjWljFLa0xRIDApHEfOR+dysSoyWQ1b4HaaC+AtNOdYVWnvEoqabKZl2olVlU1IoKT9ai6LxYsul1QvWqJcuhrLte15tq07umbYFtQip7b+bEvO1i927EsbvgspifMRnEUuZdB/j8YXUtHQzDM1mno4sTxoZGzGlCr6cr6S1ZfUponahaSqp5cnrqaNK9tpocYXE6mIq5DfHqhKbMySU1nfUu3CuCE6KpmJ4JLUdA7KJeLScIm8dHE5koqEkDlDGjdhcfNvvilnkCv0tHGbK0xJYEUjGfa54fh6ItvJLsQa95r3khNdtk04yYldrdjQitMQZO0LGTay86srqYinmLerMmXX/rJ17UI2y3N1jaVI1XV+IRfRwA+fT66Ua8n584sd9flC7kI14gwEZfZEBi/Iy2u5DmSAb17vmGvJUk2hoz6/o12oRpyBIN5MmlUGLdEFLVEFjYdySTd3AWShMr0HF2p9UbLJN2XpptjTDnZTmITAb6QI+xifXch2RqdOOnbex7bYLJzTS3pbISCXzkc4qw9lkJFZxSN5CCkga9bRfQ2RXzxKjliF1pyndllnO3hR2WyEk9ZIBnbE8pfIQ0U5f1nDy8dRx99r85bdhUKWuMnulTBGS71kR52LBWHn18CjYiUIBlwszjcJjmlCTzvO4OIchEO4HDmOr8dy6Y959IMX+HNdyCgTt2m0mJymlcV2lF3TDh+h4syEg9ZYBgehc7l0Ot4dRsG9zl6NmdyzLTmTu9hRmwfQTjZ2YQKCjf1CCp+foVw+Pz4Kpl7g6K6BNF68mEvHpT25razqglYQU9XEhI1tLAVRXcql8bEYBVk5crHaI+1YRUKQIzPslVwCDkZk/YWWoZFvIfrKq7jm2vL1XAtd7RBnivMQjtvnUvg7nw3lcv+Ks8jNkW6Hc5pMLgjzqfJyXaWJ8gpXtEOHUzk5QVC+lEKRI0/kGAU/DYmh/nfgPsV2rLKOXChiRX872FTFtASKGsrAq0aSWUYhD69QrCjbImYRXt+e3pRIJE5A2OCupdD/SCYezRF5D0zlijwbKuvIklBVfzu2toppCfK2FDmqL0ZysSEmRQiehGJjPh9Rsa8dnholUxF40lCGpDCS1KtKHWQi2877xOdaci4+YsfSoK/GPHyECQjSz0WzHj7nZ9UuPufL8sSwotoSHdYC3Z9rVIqw3CkKkGvwQJ2SjtxBraK/Jce08mkJe9mZFM4/F2P5XFQzNtXM94J7asusqflXFyzwUlSvHkl2onfRg0PmhaM4PjDbkCUXsX2psHPRFJsRXl9gLw1TzHBZMcVl1RTPJQvf+ooMWmJem9reA7e+Z5vyNnexpxVWrsIcBHFHipQuE8nyJGBHD0Ih8E9oy5k1il3tOGIV5yGcsMYynLDOL+TyInTBKm1bf6JsQeBCY5nfz9KLWsGOSuYm7GX7dSQbL2VI47Xt7VdyqX1MPdQ1IkCQS5w43YbQlrNiFLtqS6i4k/2iMA1hN2s6jn3bRIqTcwnP7rwwTpA5tcdNxfN6tqeNceyFKQmUdN2sGui6Wgu0JI59fCnXiZ0Xxslrn8XGkio/7YtkL5mJsI9dNetHf1XtR78sTOdMrlN8nEM3m31MaMt5lBW72uFeVpiGQDwjGVRAk7FccrVBXiyEKM0wSz6FViFPebGzFQyobDKCHvFahkDByUQuDkQlhtAycixIbCxUOxT62qGDLs5ErB4uRWKNK7lcn2OXB4NWFnhimiatLkB+QJ7nPtOQO5MJ7a0II1w+GYGcGvZU3K7+xvhcZmpK48cFh6GyjvKY+LUdhkaD68lhyKxilgK5NZwUcbjEj3G4xJHxcixZNik9wCh44i/CuecKOm6xMRcMVNJXW7nfneKAKickRAI17E60ZcFfyVRLHH28cO68AtcqtOasJmWd7fCzXjIpgaakiAs5l5NF5bIxsLYcQ0paWkU0lZkZzq9loJWLC4l3M/Ytu5WVkI3Y0SrqEScisJuRFOxmOJKRhiyH+iPnJSKxMaedLOlrR66PygkJ5HQmhafapVwS0b315xN/vsCCjinflONIhZ5WyNWl8xDOaGdjGWRqyfxHAPic7EMactXr2ddWsBrhXYVUd+NmjbDjaiPsEv5yLR1xQDFTPaCJL7JKbLE1p8Uu62yHB37VjARaajhz66SalibLKkSPpaMmwyNDejYWjGrZNsGkJna1ZrsqTkXcr85l2K/GkyvpqCj0viBXI2/p2ff8CJZvylc/FHvacQgrnYhIQhMZzmBjyewgcWB6XvApi65fO7B+3Fwga/HdhYPWZcNBiUtiEpdsXkM5ScbXof6fSzOsYIscdBdcYyg257WHZb21+Vhb7jTQydtFRhjlKaukZxMaK52sQG1XMsSEXE4k5VDwc+UzgeRa8imm7RZmAqmciUBGUqQEka3kYQI+NubI0UWmVWjNWczKOuvbA/fGs8qmKgQinUkhVE3kojVCBZbJXC7y+qSkPadWyrW2wj2pfAKCYmAkg1vSUFbCwciean7geVOe3DH+ms/rmG1tRaBa1RQE4pEifPZiLI2LJDYCyw9xkh+ci6v51OdxY1nK82xffUG0v7tfXO8hV7c+27ScnpbMSdANDOXIWDQeyUZOQeRqd8g15o4efGEyd7YlJ3OLHfuKXquFpsSJiQTVcEr07cqxnl+dy0ZQPHBQm+qWTURanIYBZBoLYQBCX332k1poqWROou5SiiJmV9LudsYc8i1AlHNuv0uby3a8fG9twlOtW15uYiKPOpNBhhrJ4wMZg3+PAmu60EL9q+d6DtMPCG2581uxqzbDXC3EVJyPWLpKDg/ta9kIyYhoInKqf2Hm3WxDWSKSygtqU2DWQlHCxMTdTgoF5kQ6cpparqmZFnmI6yIjRKbmeGZkcyGqsjdfPHjJRfVpNGshsmXTFbdCKfxz5Uk6kewcTJmDNN11vZBqdXBWk5nrKNFpFvpbJrlXzE+krmsZpPfh5VC6/dH23Nz2mH7PbYr55pbRUH4S4lZ4JQPpTKQ7+MXWeJbTKsj5HfC2MqeDTFdtyShqIaLifEQeNJEhKcXwWjqFVOTTDcD0DMaDMt9zcd755lbrNvNTEgnpSgbNpkQFR2LUk7pTvu6jgGlucL6mVrantKSWeEG7lFJVMxQpTArb3vm5dMYYx5qxY7cXn/lyLVmKKnTU5lZQCyWJMxEpaCyDa4E8TimCIpCABU8zNcMzUVa7mesoUXEW+tvFnyqmJyo75VCbT+Q7zemu50KGYra6yVmaHeoKzbmzXWlvy7SdZRMTD3qXMug8hxfS8Sysw0y0qRcQ+F1LS/2LmF9UZXfOT2rpVe3iYksnLG6UlzLwsmGbVe2f6aPcL5h8+/jtB+xFgcG1ThZXSlmAS6gHMxTmXN1yvp0G95HL0QrEk7H/U0LxfN3gLzmgmiFkzhCtgZSmNaA/zAOCNKcJWOCj4t1rSevZYMS0Oe7UMmlZpwysnk3LVrCQHRpMZWoJKdBFpuZ4fHNco/pcMzMeqhmrGdc1480rfjQDwFlTAKxVYKBjc1ZbUjfmuHZRA6noN/Q8Gz+5t3DEeBBbjg/obmbznDIlPRUIVSWkaQiQ6/x/wzrxYaoa3bWc9CwnNi5BZYNMLFKtmhBhcgSEv7ViuGuxuQKh1UH9zYBSOyY0zwj4xWa2+7IOqcSFWP9eJ+0gwCIckZN7iIxkgVX0VaAVkjO/hi0wTGcXWbFZdpa0iQBdJnYDtSA3sIw5F8FyLQ2icy78N24DPG3b5vcM0uY8pl3i3/BC+FMvPGsW1JPorFczD1p7ucgE0agZ2TpxUKBN2jx0BMl6iwEGZMO0IfR0XsALAhIgAu/ibA28QELRLXfds8jo4nw4uby6Hl+eX1yNRxLDl9IftYkoELcD0VT47YrfVHcse6EQ3AbBdBVTKC1TwbgbjBQO5Jq+ZzGRR24w6dkTxoFPzDfNM75o2cOiy52GMgiuedfAmFu2qd0tiOSCyAdq1m8KsnqP58snmxZH2AykuGwB/NNJYP4VIVHbtfZtA0P3wzh1gITIUK2NHwW+hxFbAHSyH0jzW9b6EhpfUHWOV0o9Gw4xMDNjNcWXLi+uR+fp3+dyI5hqJT3bJpQIlYxmLnlTn7wzOeRSBbfGPIcUyLuATBjfvWWgFGHd921e8U4BXAPAhFoJOim+pucQPBS0NUCbZmZM4c3nfFQw18GHoZCc9mCFcyYRaLoL3uGOA/9aWEjsqYCuA2jPtRcaHQoQZpw6skKkEN4JYSaZYZFLGLptW+4sJ10opHdC2vW0e8uzmRwB3tiGFwSkX5va3oPCtgYqzt9GuDAhZRezbwrg3YTiiGxuZKOb61hDX32WPuULWmCF626ysOMTURh0UjihV9amqHZ3dOdEHrMJsmEEETCATafolbwIPCxX8AkAecXbbxNvmlI017t9UOGTsz/chsIfOWHLSVeORU5jRJxKDgZWo5TYQUSJzKRxndg9CiD4SsG5A5wzz2SHLQXjLjD6cHaaRi51g9Q8P7Qc68+mD08dwjUxeSY3xUIS3dIVqNuAWiZzksNpPIQCdRtQ50i3w/mC5oi40zGisdaObitYd4KVX0vPnbptM8m/S1gWozIAinek9V1pTMZGtzIMbU83sXZ+rrG8EwYhyiSNT1NHIcEH+FJCGJPcngrGWmAkIGahjJV1uo2RgnQjSFMnsBRPIoPOdXeGTIXllljm6dPRfRxr7Jv1+ewUqBFLXwPL3L7TwbvK07J5ZRSoW4DKBHqwPRNqVcxze+aJ6UETEZkztO4z3FRBWhekOaaqYN0IVtAg2ygkCPLszgq/jfCD82NMmswKz4YjJ8tALfbtF7twICLvJcDctJ24A6jaFkCrOxkVHfaCUInzG+Jo4Qx1EorUFSFuBiC58zgRfJ1lYb/pvs+DJTdEs2wYhqzDvuRdaiDxZLO24XPhT4cQJlsTLRnNkVao1oKqERBRnqtEKKyEesn9HQKXByRg5OssPbM2i/TADHTLxglIr72XFsBkIvzKfQtFyX+GeM1KqHcZlAFPK59zux1IrJBm2DKoY7TMkWhrAfOcCO/4NbpHwTs29IcUqd0gXzYyJ3i4QuNTAoUVA75JdjI5OtBZaT4mcNBfANLwL7AWufE0uw8/q1NIep9zH6fbr4YdEYies5dHwa4/wxpPyPIeBxHpxCA/Ak64D0GE/OvqTQZ3HooJvWIpal54r73wZjolyFEW/T5OqLT9D7Fs5OwPQJOUk/nc64GluyHVnqd5czoN/gt60fvkmlcxCLshXznsIDMG229NC/+z0eQKe4AazhcLmiICzhy6i+NUfpQd2Jbx5Ta5opq5bDRKHMlFWpMYOeYv1ygP37fQeGBk58iGGlqQjHGu3zXqGtdxZDmktK6ERt23rfujgfcDeeNgZ3jFURi8gEZwSJYw6RiUh6bUZvF8qePw5u2rnREtjsMwnZJ23be0wIvI96PbshqFN1Dw7gveY969Xto63l04EEfhAEPrAZnDpGtIHtXm9XYB1+wMaGEYrixYsFuZMocmujPRVI/sUAG6C6CWywGlGUkI3c46i2cGgpsA3VBl3xtuadgc1qrRUsec9PascaOzqpZ3GW73wtJnrodDblLYHN2KweKUUDr2wH0kcjT0r0i3sRZ6YaNuTqNJR7GFbT+AQC9oy5QKUbjuiGvaoJme5nqER1CteFYNroCuF2iaYIvvcLF1x41NfdICXVG5hqpSAoTe07yut19psZ9C6Zrtx+GRtuw7D13kYeFYmwaeo4X4a5f8UVoBM81ggBTAdQMcJzzWoDS0xt/vKLAF7hl+GIHEekMTahYLyuwwEEc3wqRVm3veF426o7NhaBVxBXJNIMfcV7fB4uB7LulRaO+NpGneTgW0Ef5CVvVbFq6DtwY5O8gA+ASGDP1EarO75SrcOJb0joiIDCFEpHfQBnEgSNOVTzVljGSPC97XnkvBeU6OUM/juPFX5LQVMAQ2RXrZeFxJaYO7U5J9Ck7NdDyZlWhLAIF95wU4rlt3dOg/WGKJLYXf6tF4fh9KwlPrK02PDJsY+IMll8usB24NxkxqiDGGuBhRjgDccUexTo9fL3lyhN0OcfEosT04TbiALQfyobLU9Ti0bFt78IIvuKOMAran31CoQ1nQW1pEd1uJt3yk4ikOSJd+cPjFXVWhNQRtmTQBGCt464fXi+LNzvUUwLUADEkv2K2pDpiA2wkOgX1kcHT0iOwtPDUFCEc0My+LKrwhXfyE8CLuKEN5+9EGVFSwpgtwdmg6P0a9+9l6IFCBqlZYq0YcmNmxm4r8Hk/y/110GeEk1N4PEJF/k5wPSZlChfq+UMdF1LlLusJ9n7gbZEcMkQj9VDeaLpt1fNAnKTgF8Hl7s2U6jw9+C4vAw6jWlNeYVODvl92z6p44muZ+AdassN8n9pnqlAL8hymYeISbblpAWPgF0h71C+zzF2AlqQrwo3vQv/BO9Qvsdft1rTDB3bamyFgYtuL8+911wyCBnMwIfFEV4Hsl8hCliMMXJdbvG3KepiUn2EObQn2/3FzL5otSwDcF/D/1e13R/GF207kX2abCvWncTYSNwLpTXKZBm4ineMxBgOdFAnUnpXZeu0Xhvk/c/cC6B9W8g8K5l9awP0SNnOMDH8KjralF3p4SfhJXRjbcgKXjlx9/bMyRoz+BV2JZEN/ySILbryFyTdE5ufLyAhLDEXnBCwLH8GINKCx3jgIrbNK7AgfGk9DzbPyE/7CaMdfTcpR0ds9JC49+E+vQb3z7QGO6Jq1JornO/zeUEzlfDzDSMPOxwgq/jSmPJ4qluWF1t1nDVjcgjK+LMArIdX4UKjrcGkQTGRZWS3kXCL+ghTa1XLPhQhYdQ5FFtYNG3FEobo0iFDnXWH1ZheLGKIKfJwScWklWF4XfZvi5YM8CHx6HTHKhENx2Hd8tYFt58AKzQxiSsciJHrOM/1CjCAUMgkz7S9t7uCGjLP5ElWBuOk4Xj3sHw5IdANHX7m0yB4OUxSxpoec3mFex+3g6RBZScO4Op6HbRmTDtm7oPlN4Q9HohcJ2d2wxmkE0opa9UeFaw47Pg1g4vgrSOiBN+EAntZcHAxZ0R9rcC7HvhUqeqgHQ5Bg6Ja1whwK1RlB1bFiWFloOsi23SwzARGbko/zp/BX78gK6bAgDqz7ir3n7IQ6jw/HoanKZ+VtO5GxPN7Wp1WxqvY5gl27e4FVhN8oTOwKhmXxBCrxNwYtV62rpbgwd+grStvZP3OjRsFvgwfzMZl0k9w2gHxBOTucdRC4rv1AFVsmlA6xPEaUpzYwcv9FlOby8GF+eTa6uRueT0fW4fhHZ8SNIGktEVFpxQSMUMPdmkGKaTIHioDOxNt9TLStvOSDleoF/12hJF+FPbeCC3xIBxCfTmC148RrLnTHnTd78nKV6ssrOHZvdn2SNki6n5AGwou4nabY4LC9mRERwTT0wqfIeak9BvjZ+NH3P+36DrlveU4HdxuMc5Fgm/OkMlPSgZuguIVpy7qDgYIVrTbg2nWm3q2jydxToVAG7M7Cx0MNcnRWp1oQo2f8VlLVA2XChk65CyS5J6p0oROtCVLftzoAZBghpmKa9JwjMLJfpIZgXGU0aDpYkLwqrDkHr3j/gN0tewmTVxNMqAr+7FrXUEfKZcUPc+vhVDnMQX8mL/J/LjiAZel+Qa/2JNJhImBz1Faq7oBor2sAOqNDcmUZjh/Okapm20B1bAbsHYDNjKHxrw5fWaiCndxsrUOviraYFRcwazvl6LHxAYbozpklFEVaFrOmiIkcAbFKrUGFbO7acI5CXxQvnzlPCVn1MNvQiY+57VrM20K6jGugP3OVfobo7qkm9RyptYUthWqOQtQjndNOKz1x6s9kI9wuvZ9u6o5ONxIICdgDJG9rynDZUgLn8pkOo+0YSoGLMEVmh/Cr9Xrds/a5RfZMMIIEtzdAJVJCrQGGTxeYA3msSoGLhLqylmWfygycLNPcCzbZCtkf97JnUL+8F7/nVCqt2uU2H6Z6H2qGAjNVcB6lt1E1ImQcqe6HmQ7S6CSlPY2Hr7izSZ0gBuiugBzIddhxNepeCc1c4k/jqALFSqxqOZjOEm86z2314oYgwck1dIVsHskJegHsLQ6r2P5vOZLNfcCOXJZ+PVXYUjt9Z4w1vexOFfqUb2/oDDEJPMy0jlDeGp0mwsH6P5EWKvghKc6uTaf7n+99ovax3bJAq39I17uyAam+/+BxIHJQKI8LOrVCBUw5OHEHkIOcOBdQJSUFVDtUh0j/sH6Bb0sRz95Lh3ocgB80W68NUfn+SBBjuaA6wOou5VE34LbXPwbTrAqu5YjdN7P674FO890CE1IiYpN/rUPLPDxUx7Quj8vs7TFQfyGu9rx0wOctxVc3xZ08tuLqxyd/X4QX2LsKKX+8BHfHODpPQCzTVI1tR0X4AKrm5y/t94lAoKzkNBYfDi9ZjVn7/QXxbuoIdc8Ozbc2F4l+NJ1vqCoxJiSYCJUJN1xTuHIxNbxedAbBplXvzwDFNVTr9uqBrcufdb/KPvYBWNcIhNt8uwXfY/bdxJEHLxbRkcq/g4WgiCVbLRjmI5NwN5A4sN3cDxFjcO4wNvGMgGkloaDBTtLgTjAc4wXULxMbPb92Ar/HT26hJu6jcEp88UC0Z5SBunZ0A7rDyXjcwPOwWO6q/2kSI49AQL8nMG+Kf46bq1L4rbuxkPYm9gZUEkUANkwDNoczOPWq+YJi0AKbxTThyyMQWCrWNUDMRma8NKbkUya0LXlpS0kfB1AuchgtCSwwdXrhGWk4Ma/oUch3NURRYOLQMRYDroAixXxp5lchWK3Y9snsgRyWkzSOyUqGomAl5WBTH2xS/NLuYge87A5wfBb6HIRoO2SYzeLGWl9BQAdrymwZNyyK1O0Avn18cB70VOPHN3aoH3hhqPDnKNCZOhdza9GYQ1k/YGGhBsIJuI+juIss2tblFNoTAmC8UepsRHq+jSwuVYrqVsusUGW4GJOQWnLmarS9QoLDbELs46t/2HroDHZS0IyL9jBwfA1aQ+oa0vOMNFZAtv+kglaCu9urNtBeUKEhpEdGmy7PKCBmtYxuOwPDANSAKsGWAcWEXGR5e4BA5Cq010CL01XChTwmxApuoAmodnqWbpkJoGUIEIM20sOHdo2YLR8m56u4WUJyg6ZrjkoLVtI5aQpjQVyjQwgRRhdQypPyAPPYAdvI9QwVp7PJFpl+SlhU1qpffdJAj4HX+v6EEKLFqIbNGHT8lxImXN2+6cq+EBAV7nj9fYKpRcFCom3qoK8xWYkbOxmQXVJhtghnZEyMjjBRq67N7LyICBEsjHmq25TZb1FVSOjPAg9gLFEvbDDYiVSi41oOLMP9wocDaRBa7I6zM1AOrSxwsiqtDJiUM4gTyrPktK2m8wp644SjdS6JwGBgPWpuri4DCHvKvyCLn06aVaPtFM/B009F9Dd3rdpR4bL5jrbdxYwWI693cQde8RlCj5l1+sYJuI+h8PcCIiMoKt41w491IobYRtTG9JaE2/c6yARcF3ybwZWqKge1FobcheqAT8KlYEnXJizHw6NkLdkF+8roJjLkF8lgUoLesu8qLca2boZCyiXzkwhsvNN22vQdkdka0awJBoL6pF9xZJnlnCIbCjZpNuwEg+uqTRvJG1BO5y/C9iGM1N8ZOvJMC50cBQULDyNHdhuM9ZYfOtqbIWBgQuKjQ2wg9smk4UUgLcx7DlsGn/SttWR+23G0dqKG4L2ToIV/PbAyan1KogqoAVRLtr3CqxMnCYSlJYYVVKVYFmpIYKO8Oo+CeKyLYhC0fgXH9fajPoJJkZFcVDF7r3sYLK9cejV4yzTTxym+6S6YarI9Q4dZOpBLeN0aY3Ejkd05eCqlqpCAeIEhWrUKpYs3BmcZBjhcstC93CqklSHG/beDoirBWwkVd++CQhzlmCqxqsJoWDSSE6FBREw0ARYXED0SWXh+g9JYOqAjqRwTBIxUkOUi+KiLJIoLJ/uRFoR+FCpMsJo2bQ/eOCWtBqRSyFiy5uwYmIpfFRmdJs01nsqQSWRaBwBGXlkp7Vqj5NxiiA9n31pst79gNsrijCzqQQ+DGL1GwbUhuLKNc47n4OoGdYUMitOlCC8nuKX8Br4NgiDABj2Xex6GCb2MSTHKgz70Q+56CcGMIp5ZrakZghTQy0NfDuYJwayo0IcWFdUdfXGpStNh8fw50f16BUvYSam2geUVd5IYSHxK2mTe8/RFNOfS0fzbrrXnoGZtoqkd2qJETsaXb1p9I5mNw7LZHlmsQoq90ms89MrIf3saFqKpy9K9xa1qiinV0xztw38BpofcFuYS6FGLrIjaLEMaa6Tlkwp1BLfUq4gcsS/QofZ60V6C3yRAdMKA0jVhy8OXh+wsF3cbQgZ4dKdw2xi3xv1fYbYxds8XRa0YN3iGfVREqha5Ixbj8pg6mmN8LSkxJHGQGUWBVgQV+T2R6YcPFCCVEygVFkt2svC8hTBbW7glMpkJp1bLrVi7rfaHUdKyszDDF81BoLUELSto3bfyUECYKEXm0WoDrkVTj1cUkZVSBf2d3B6WkBrV4sP0l7lh5Nt5kiA4o/xpHLKk11qzoLjlsqc50AU4G8HYKvPVprohe+pYKxjVhpKlfOHqN5wyrGTv2/kLB9He0cVWp9XVuHcTJ1SS2dO8bIl6PPnF7abogvXR4MT2qgwJHb1SfIytQZCKm9yCzp800IicZmlMaW5jOlVeH/OJyX82y1OlLbxowh8WGTWD7NfnPwM2Ivhi5dooCGJRO/FX87V1UGZSy3s1E0vc9HDYt7tcelFI5W+qqBafDZNqb4lUcoQPHo2bxYoyL3UGWKfqqgFsPOBBNXZjLnRc0rk2UGjl6QdO2jw4gJrUzhIseHN3VcEQEcDrN17ThPXyvQGjZLYMgchUgWUD8wLtDWrHYhUIoj9DMM5nmAbTUMm93e4KHSwIhmgXNJriXAh7PtnVHB1d5l6wu615qiNBXZNDbtKntPdAZ38ZNL0lLBUyrbhs0n/NmIgcw5KoA0bCzByucQ1JrcsJD3cVpRWWmdW8/iNfj5cX16Dz9+1xO5LgeZsqJVoG3EdkdJtdAt9ADHBR6m6NnYUgKFiw037MaDdDtCoCc9WVAVGS4OYpUdx8g3Zjrd81Woe8WGXqBP9ddRYGbAwjW2ojWDKNESBOe0awXCsxt92SCo6VocQv4II4ZMfgUepuvZFo9kfmp31ueTSvrKBy33VKYko6VJ0JB4AUdWtHYgaoBKEkcQPN+QtvKNAQrbzxIxkJ50EmygeiBqRAqpR/kBpYx16aB52j82QqoVUDpOFQolaJEPQl0RxFRNTxJNmMF1JLVxjm35YBzIlYolaLEfCmaDmmTCSHIkMfMwDBFcq3CaZmgFLlfXO/BlXi9JXkNeH0BOlsaws/y3Lp0olVG87VuHrCzX/rS2tRCttmdXHNktrrm0NIvDnJDnv7MRHc6hpp6lT4HK+87iPFzcnU1Op+MrsfD4eXF+PJsIgtYtHIo4GXpNmNiCrY1YOOCOlg6FV5r4EVFdgXW+mDdLbSGS/hKj1dguTOF1/p4fbFcU+G1AX15aj2ujRf1YqGKLAXZRpCFngJsHbkVqpM3XZBccrhgg1RwrQ+Xp6hrPbhi7YUCawOwmEv7gx64almuCV2AHO8eaabuzmwCWvOusvLqK742nAtm31AxfTtNofAnz4eD51BIAYdJhafKINLq2wb8DeQNMSGPhaHBGXpmuXGaBNZ2S5uq6sGsvLEDjiD7RIdTlQKnlHSYPcOxMAbODUlisBV6gYWwAmwNwIBDKaSWIQXFnC0DyW6pbgAp418B1jwfJILIbTYgVz6wMuHvFv6ioFoClR8FSJtGrkE9bBWBrYea4N6tmHwpWDQPctMJLWvGhwyFw4A8PcxO9I+sY38JOCvugmKVjdZFrz3fWfkEnyetS0lnvZsPcnKpO9NgIzhRf5AgsuUudN4IVImHlmk1HJcjJ16xDwgUu4mQgms5XImauGG3GbnBarhQtZRg8Wg4PTDmFnwCqb3h5IJyE1nTbpL1o8UTxhtUgnyS5sATMsz/HnesTFK/w4gd0Cq3C8+kkgJTWzRfiuI40E0UHQrg/QDM40XIDPDCufNsBXBN/JYVCQlCy7AZPuDdKHecYAsRTviDQngPCBu6bUQ2j5iK56jArQdcfkIAH3G0ePACEytoa4I2DoJMuIPiCrUSbmCBg5jlIBfLbUwhGzRGwRN/Ec4hXU0usPYtbbx5/2FVVO5mgxwkcnK/xSYPgWK8xGMRCzecyqODkGoO0jHoqQiSZJH74VzhuROeMY0GyIgCbN0jhedOS/4+DtL3As3mmkYF51qD/GFRR8DjQCwz2e1gGtzDvxoVel6gqcSF85qA6SWXshVSq5C6wQvX6D5ce9tQaYywjhFXusOpDqtNYGdIkzxmCszdwUx0DneeuVB41ocnuVl3FIXWsNw9A4dN5/HoKJYBCqPAbdqzoxk0mUFQVAkmmkDzfWIwrAZzvTHkd69dOl02yZVK2Y3GSCy48hZ6ax4zLTF73y3I+81RYIV6szatbmF4EMmxWxA2bJrqFnixSlB6ALnQwb5lJI519tjl93Zmb62aJhHK3tK27VBKbj+IYe4i/+dSTuRol4JtY4KLDW6NG9s6gt9BDWxyYngAQ9CBgNpEaV+87RC7wUgOZA5nHJMJnwOZeWSC6JDmMMl3PIu8kB6qHW8XDOlBUuG3NX6xZUZBuDGEh7O6dghAPQwD6w6K8DasQ+sSiKk7BVJ0uB2EzRumOwTegQyoXdpHDmHO7xIH9MxF8wVTm0GQFV0UfBleOXGGr2rsltw40DTfw2HT6pF9mRWWzHRNh5F1RojjVboJF1tXtYNWAGs4uiBIEcSGF2ugxQ38B0kQ3QRapeM0TmiNQvef+r3+3ggsP1TE1jxilWN1n+gUuTWJVcko3Saxnz1FYM0hVRij28T1LsJqu2wUq5JRuk1iz9/P9cBXRNYsWqXjdJ2X3S0UmTWJVcko3Saxt7+8VRTWIFTFQeSnr3vrzyf+fIEtI1du4S1rWpond51bD+GcJhlCoaf9E7O0dTO5UdJ9H+kBhCllZ3uTtK7Ear0BDuL+fn41vhhO0r/H8sJHLrMXGiE7SCWPFYi7gdh40dEOgaiFFgo0BpxCcCsE9dBztKnuWIQaFZA7AAl+CQrBXRCcWjZSCO6CoOE5PngJYqvRurFdwpB5arkm3VcaFqm7huOdbnyZBV7kmgrLXbGck5nZMDsF5a5QTm3vQXOgcpiCckcodddyaGJtBWUtVOmT90MhVmjuvPXArqMHC4XkrkhSJIBbKqqsB0uKncJyVyxdtoErLOvYe5KTt8JypwO46wWObpPTt9Jj7AIjNaJq3hfbmCsId4HQR+Ql3FAjC9uNnDukKHInOBWGu2OouzNbKSe3hJCyRLAaYgKaAnE7EKGgih50FEV4ocCzsVB6mratRHD1zQfxnbgcjkdXk/Rv+VBjwfMusg9xiO4GfHdRGHquwm9b/LBNXjhQ+G2LH30RnaYBUiBuTYTkfe/0QOG3JX6mHuqO7isC3BbAqWWHigtuKfql2q2mk7B0CjzbarZ+q/zgYZ2cOQA6tnw1E031yA6xQnETFA8UKNCRnQO5+p1NXijeghWC2yLoNB02sH/4Qu8LcjV+Dwv2+gBN73jLEvBW3XqYYg2jiWQg2Z5uavQyrIBaBhTv03y94UIMsiGVqpMVTEtgipm/AmkJSOEcOYqMliFk6wsvChVEy1j31NbDkFyjtrmVWM2QC2UDkGZgrN3rgQWip4JsOWRhDi0F1gqwKFNvvjS7lFhxjY2mNsL1uTwlL8Xr1+f1DDEDK7jWgku3bQYZVpitwcL+iWMCa1yDWjteAZpZOAwWT3zgNQHM3fdowaoFyzDDmt8lrRXgbTzOQbRZ40n+v4vOgGnorudaBrUrKUTrQJTqEaeB56TYKmBrA9aMaGQ9vwsrZOtDNq6xpcCtH1yelZC6Fit490C77HCooK0RWuZyHM4VqrWjGqCp9VXhWjeuOJoqXPeAawyFQrZuZJU4uydclTC7L2iVKLtHcEGjGngNGxo7iyit1WtNF9rdgstcCtaaYWUil4K1ZlizkChgawSWCVwK1rq5K9T1brwy9VFAayUliBWstVJss97LTYEK0qMWf2NViUjLO96wCsrldx/C9jqUEieqlW5akJcSKgsfxE4qJVb3um2ZeogUTstxojpLRVTrgZWEFSuglgMVIEf3NRvNdGOhsFqOFUSoN+7YLCVShhe5oQJpNUOnl0DsdAfAwsacMBPxwPLGDy3H+pOmw39Pr1gF27rjQOS+aTVYJZK1Ngcdm+b6R8b1RjnIeWdvnrrNIpfzy2E3YQXjpjDC/Qq0zUEDQ5oCbhvgwPhAjpgzPqoCcAsA0XTarMq2I/DRU4Nlqn1iY+QaP0XUHn/FVFvkvicY2VPNDzxvyuZKvr6Fb3+wSyoLp28yxEGiiCSHjHTeI4XX+iSGDd2llVHwAofIUdCtD13qvwdKJIXc+sjdRZZt0qLMlpFoVBSAm5BeiAzINUdw8z3yflihtyn58XJQ5O2+Kvg2gY9Zrmxbsb0NgbNwZsUq4NYHjtXUSfZbBd1GNBcizIrfKdzWx41sClAHgTE6wEFtERugR1Fjo6hdYlPsPMePQrA06sZcv7NsAEbhtwV+7Fyh6YYRBc36Q3QGRDIHFxm89vk9CvSZWss7rmXNtPSZ6+HQMtSesgmWsWN05HI4qTuGjsmbKxg3X9l2hKHKBOlWx9/NAIzcUDO9B5fsLkh3svQoH46GbdGZOuTBFfCkNV28KCS0Q68XGwszJ+9yffmoNzy7XmfmRF5cc9pX5/k/Igpng+vJXmCYRkSm1cm9C2xhenEQuVqutdMgYCOw/BA/oZOFKjW6ZUdkTHpL3Ag2wO6TQpJcco50O5zTWQdsXSRdrO0IsAh0f67x3z/IEQOsje4DQIvyYozI0nA8M7IRfsLSvA/+iYEejoAG2Bagcdr3GBU8BBaskNCxj2YtlO6UcUAMtTWATukoeQKeEwoARWRpTOMxMAVWGZkyBc9HbvcxYKte4ArvaOPPSVu8Xx7loqD+x7Rd8umHnmdjQvQ4YuyPzfUB3c3svFREm+imsHuJe1rp1PYeIG0KrLSqlNX7gnJ0cT6cXF5djy/PL67Go2EboVyv4p2Ca3PKm5OZ2TA7RXZ7SjWvCHF9FgjVJhWORRz9+QJbRo79vWVN65SLPTLkthggjcymRnKCs1nu3bIvKCcClhJDSfil3ezxqKXgLTtFYWQzeyQ9SOEGtSsd2zYoDLRIseJ+OwEZIJoeV4HYUq1oh8iNXGYvNCKyuKXFxRWCay3YOy9yTT1YqCW7E4y6azk69wxSOG6Po8uObgQ4BeRmZoQBfxd1btvisEHJLrDcmTptrHva0E1Trc0dpJZyN3qlJ62hjKnieGtyvKnuWPZC8bwtRWfd+DILQH5WskoNKlNKkZapqHFLyweL4FWS8w5AKsiWb8dMw5fW1lZYbalqVuu03W5inRCXU6JUgslWEnIsmSjFwIaOBMdHb3l7devVdyXZfhuEqriy2mszOzRSpgwgnQ0m7QNJIqZ/cPRSRZBaieurKRRWm3rBHQ1iccYc0zOYfwJFK4nad/UwCtBeClHIi07cSlu0aeA5SaKmVp8WR5OWYLMh6R0VNu0TmaQgmxee8Zp86RImUgQqnu8xMq0OWA6zZNqAypbLTXZ47lEAu0fi58aiuYXGjEZbCjvMRFqEDup0WBdsCBOOQjVgrGSylg5AJ61BTplsOpkSyCLXmlrkIblcNFzNJptsvAqPbFc8SGwAwJK4De6JR9UI3eZkqXA7KnFhE8x0586aRV6ENShGarmYJkhjTzgWne5+8GrnMj0EZvFyBK9S6gXk8hOb2g5qgk9tCTWQ3vFsC34U+B5GBBFkm8wxgzS/Za0vofEFLVniBQOTf6jArDhS2SjyyrkbIEWv5xlcbBRooM6cueQxNOGNG7KDEKEotBuY/CdhVx0PshgF9xY5cyawQqCCZShUd0KV0CUkuU5ANT0QahSe2+KZVlVMMbXcaaDjMIgMMGwobLfmrWAh0h6scK79K0KAMA1scBz418IZ7BW6O6HruRABBkMlBWlwZIVIwbo5rGzWWGQCMAXLneVkAwXv5vC6nnZveTaTAqbUZT0IKA6296AA3ZZe87cRzkqI1sUpFmuhWjbUEcmrEdmYyCY117GGvvqkhzznC1rgrahywIeTV010WPwOuKrbACZyfCLlM6tvvJhZ22ZLWjHKBNI5kTptUCxFvo3SYPljh9FyMYyeC70AIF/xdm4dRokZvQSwsjHy93cen5zs6FjkKEmExeSAY6EjszZvARrkWeUqubQSmkJsCWIzz2SnQIXUCqR8OMJNI5eV2vP80HKsP5ed4RR0iR9+clMsh9ANdIOdoDDScQBYJsKR028WBEV4Jbixok+QPtBEdzoRwxwLvNJshdwq5Pi19AQGCY2oZHpccBUDXACsXJALvQ5Kg2Dt/FwzdNdzLQN8kMhFVWDNURRYUFI0LpNpZfNXZJ8p7xF1T9C1MPbokOil5aoU4e0XOnKprjmEo82Qg9yQ12Zhe8r7kIwziAc8IuhccO1O4YvVxLqNkaLAfcKoqDGFMQ3nTTEkZ7O57s4qfVhhfsLYpCUZNxmyMy5f+wRz3T3ZtuABuoOwgnUNWNvHKlsIZ551OrqPYxNwZbqItq39iZwwqp28DMjI/eJ6Dy5s3jbkXwXH4+RBih73CKOixzIgmdoQPOTI4kaKAusFTtFcuYiDqXYeudgKrfuMzKPob38gKlpcC8acpKPocb9AKppMoQQXDhuFBDVfD2FUSTA7pF0FzE4xCTIfXwYY1vRAccTmkFTqxixLFCwGZHAB2iVuqoom60JS0WTGiJpoVhPrAYagefk0tvJgqFZyip2FMyuZrDp9V/N9dsCj026vjaayEOyOYfu2kdZgCFS0HojKnLozhGot1wDiuttLbsTO4MmTN2Dk6wETn2eRHpiBbtk4zQIkemoeS9rzTXCC3cNzQ3IVCiRIGXQwkPTQcyxDiqRKk5YhtDs9dhU1ypw9x/dcIo8p9lSB0LKI06MGxw88byoDPIdZXZXwbE+BHYUKhNHX3kvLRlBhAL9y3wJ0P0OCSiaXMihZSBZo0Tmvh/Q5R59i8CDosoM6edgTjOwpG4E+7D35Ssf/g13iBQrohoAekM4OpWtdC+7n8L6v0T0KeK3TDyn+PNsWXBFnJwXnNgb6Liy56mzXSFmUI8K5KNQrhFci3MLqRkdEssUTlUK4foQblYdbCy5b1UxLS5HWcKgv1kqT32I9yHHCrUSKGhBXW187iFltgs1ifRTboee6iGaBes6zjN1+NeyIgPw83qZw9pDtoDAggoYW4eSYTV6Y/Ovq1TUWlFrjsPArnV2rSf4YFUyvaHUb/MJ77YU30yn5PSgm7wG8LPgYGshT7/XA0t2QRlGyWyXiNZMjxrhZ4j4Q0i/oRe+Ta17FWA4yYzDdtGnhf3oWy+wk3RnyKOA96JnxWAj4EAroo8D2QIfE+rGlhcig1DcRVP0oTAvjpRGdrCe5smK3Eq+nI4mNRwzUiqE0rDuQIP7ocWqhGky2VZdmLMzc3HmkyDMJPw6RKwWHaiNSrWRRhwSKVoKFasL0KEAEVFmoa+/ah1oxbCXdyQXhEWohyUy10PuCXC6SQ4Jo3rA+Nr7uIiLTAzaej1x5/Z0FNLJFhrEGsYs0Vx8hq5nrLFuAK1DtIuVshtUyasLIZipvSlC4u4utPsiOgzmx1Cq+j/RAJ0/QAijTBDnjprpj2QvC3G0UhscYiFALUO3iX/WDRFZUsPBBZQUlDnUiAhAWkxjabMv4cptcEfuuQWtS9ZgVJKr2ODkKa06bUJTdXrM1lnNk+yjQAqQbc/2usqCTosimUTxaiuQgWjaZl0YLJ1r3iixbBWWnaRMyoAQFQOG1A7V/txXFo6VIxS1bD2WnafOljsObt68KkE5Ju+5bWkBOxQgrhtlCIBVdBoouWwjkcdOl2s9lgLPbNGrruHiknEKr2s/bCeLx0qPil22HstO0+XYB1xQQ9RfsVhZiZWp3C7Lap3pkh4o22wTlEdOm5XJAH6xwDixgpkizRUh2mjIzSN4E6IZGxbxx7UzNm/T2bHKzo/djaRTVY4xfbyvAHYuWXgrzu4wg+sLSZ64H+fU5zyVSKvagxkvkaOhfkW5jLfTCygpYavM6GJyd3sGWggoH+8CxXFYXIvWTV/TZFiiPmDbTBs30NNcjGxfNkpBNi6CItdXYKuoFhCHRcXz2ykbWY0W9rcZWduoFPWmohSOuv8+5lwQIvbegSvDtVxpMBp1cfUW/Y3pKmEYu7cLaNPAcLcRfj/5g2yCoIRlPw3RAslpmlovYo5LH/O5a9yjAun3Lemk6lD8RjftTgO8fcIUxxZjWk0OKRzQLp+IOrYX6uNE1dD+MyFO0O89caHxcRcPyoKyAXRNYtaPxo1r4YQRGhhuMeRw3hzLCpFWbe94XSHyG+TBwTFMMQUK0FcAbAqwYxHJE45OZbqdJERWn6BLsCultkVa8YwU3hrObYhudQ1yBvAXIilnEqP5CpLO3OtCViwcgqmHN14PQMuz2Z0mSETzFUFsC7HFiSe+IMPkb8havClTqbtn6zUFLtxjqDc6IUgFYAuBrz6UYPvdM9NwLAtJtL17NXIKIyf3rbUj7Hwv71J+Gjqd4pqSIK5C3AFnJUaQPZPoXFg4D644O/UficMQwZXx2an0FIwMV6aGsSHK54hgyw66Q3hZpxTvWgJbpBmJo5zouaAsAbnXMPRjEik1LBf9xOTq8JO97pxtf4sQz7BuUk8QWrZPxrwgFCw2Hlm1rD17wRVG5vJgrmLeCWe2RpA90Rb+hUIfyDLduYBnzch8IYM/0g8MvVvxCTsAVxptjrDjFKlDL9MuAruIW8oOucN4OZ8U1NgKWAMOxdT3FNzoBu0J6W6QV71gBreu5/NY04pPAqo4o3cFdQb011EfBPrCPDI6wHoUeFL+Fy8ECZXiEkBapJpp0c4eYF0lncllZmcD1xi4bV0qvmB2hpDcS/DQ/QFPrK6HaMAoItVJNXL3wDqiNwJouIOUqv+1oIcdFyHkZIwX63kA3CE8OkYj7lPBpTxH7HnHn2XwKyN9n0yMp7PeCvYVF1GFUa2oZetHPQyFfK4sP7i2DyM3RNAc/a1bA7w34ANFqAx6YEvPYpz0K/v3tsqxuvE3OigL8aY+Cf2/wz4kMWYI9ugdlFu9U8O9vv3WtMAHdtqbIWBi24vZ73GbDIMGbPB9SUSq090feIUrhhi9KfN8r3izAIy/AQ5uCfI8cnKHO1K8K9WZQ/6d+rytqP8D2Ofci21SgNwq6ibARWHeKuTRl4PAUa2kedeT44UJzdSel88j94noPSuu4P9D9wLoHVbuDwrlnpqJ6/GCF/L6Qh2pH1tQiz6Ikn2QvJjtsENI2Bb4APjbmyNGfwPMxnWecbQViQkyrEMIuXn4XWUR2CfVIunkHlk9+fE4jGma+JQkGGCVNIgJLbnzPvkhWCWN7LFrnMtMEIraFw22Io4hkV9aL0KgwITNLLO7weBQoQoGZOYgAoMgki4hubQJEgfc0wVRHk/YBUaCkYwWijM8cKxYl+5CMUMyQC1YdRJ0ltNByIGmf41dCEkths0D35xp3uA/o1fTkQw+lejgf8Dc4NlxKpFNfd5GNqXTq+ehoKGWd27g6Gn+x/EaDNmTABty0ARPy8KknKzAQJgJZ6iDASg9YHInt6SbjHNjCLV9GtQtmZYDEW4mDwsAy8JGk+VyGCP+8OSIY2TxwB0DB0ioDagWlE+qRMkT8AArVAvMMQrVqnhqOqd3pZAnwmLxWiyeTg+Kx5K4ggu82OemgoGNg8O/rYwE3mdZ0euw4dJgm4p93PSBKRJVGxNI2YjG13FSO1f6JG1QCtBGOEvHkaLEQBZOjBaJw1usQEkV/og32nQ7tIJvjkBXKOgJEtZKnLSCMWolCk9JlOxGIl8/xItAwW6wbhDjrkK0zvy4jtO7Je8piKahdNeFFoR+BFSiIUYhPDSAja1ML2SZuvX5iPwlx9oTRwdSeUqHUpcxKqyGah45NjiCuiYJNSoflSUk3TYWTYks1UVOHGVO11LM2E1OwVJDasQMTa9ZYT0doJZwjSNlCgxv0GT8M6LYRgRitCb3HZs3aEzidMASXYVO9mjZGUk5bMMQF+Z69mNleyFw1WRuwDhuFSXySmL0hoRbq9Rw8sRxQWadX07Fe0cbbpI33dg8t+oKrkMpflNu5YE50EOncxsnkQs+z8ROy5UauqbvGgifB5VOkinyMHN0NLUOzzONx3FoJDbUDJtCYkW9Dtr2yEuLLx3kR3/lz4EV+U9x5eCH8aR9srTuqSoDZ8nFihkVDV6eB55AVrcBbEzzXCxzdtv5ESZSvgq2dSgCJMTuMqH5gwMIgMsIo0G3JdtGmhQ04rvDKDERwdWebYvSG3H+b3v7emvFcEZ2CKhNdkVywqa/wgVhXgyjF1su0f1NqWr52ZXL4aQqssvWrcFp7B1VQrT6aHx1GVVGpFB3aLi0siXpprkO+SgxPYjGCz0lLqpdblT5lndEkzSpzEKzS0TQM5Kcx7anuGqjz+MXXRZhsZZYb26V2AVHuxBtbI2giw8LbEeEr9uVoiG0HqA5Pai3A7wtaaCBYEZFTUdue0VIEZzBfWM+FzPGOIrg9o3XUBAfJMnCohxYOS0PjlSSyFDyuKMORQ15rIYMFbjRpL1rbrX7DMxFc7M6a03J0EEbhQKJQ3JGPKgBr2cuPHsb2GYe7R3S587HCsJZTX+dgLA9J3B38RoAS/siF2kElvU4gdwjhTmrgDiTPdYLYDiLCdQK55uUQmWFTIG1CW3cLENEevMBUuLVert0zcmQwyCmiUz7t6L7PfT6eZ9pf2t7DTeIQQhW76GtG+Gq5onPSFcwkzMW7PWYYzRwowJ69sWoh1/GDSJU2p6WwMo8zLfR8y1CY1oop4QhIQVoPpJoRIKp5YQ85IlhLZl4Lomk4uKH7rHYmEafChYJ2G2jfK7qsbaUnhNm8Y6kMuFLBM0AzC4fB4kng2eAhzr7Rkd+Rlndxg+FFR0aVFdQjB4Z7cIfZGEIagzL3Qux71d7NtUkHx4FpYjmakla4owO47i1VUhthLiwKhW85vseSEq8GEHVsWBatf1ZeukZxhPaDrfjCRigfRY7alTguM3Bsir204Z1NgHNQXignYkuWsgKtbbYJuSksK0RKCZeJzMhHeTM0eUAIHGeu43kVZGX3pem1+AjSHo7LZoctx7Jpal8tAIo4RnPqdri0jmIaQoZHQb5AcRIULxjQpBZQHBrL6SC4b3lzZxx5rtgYxTgUkBV3O0hoZesha6vbW1uAS/XxkP7JrlbJSeAUPWk9iGqfALjM5AvaBKiyzbgL/oK1wNa+WGgZUFv/nKAgUyEyrUGzizEgB4Szc4EhDe4oTYZGy72j/O5a/4pQw9mDOrxquxg6si6c6CstiAOl2jYhwbKhYlUL7pRCcwlo8Eam9+C22/rZEE7LLAdbEmMj63A8uppcZv6WBCuFz+ZrVOHVHu4tMVKCBKKwWlubrqDaVPXbCcT8gMyIzjuIXI1886ZVVRqjwPcwYkWD6R08wi7X0RQwZ5Orq9H5ZHQ9Hg4vL8aXZwdEJnItMneT5f7HFs7WDThGPEw91Mnm7uozBH5f3BHFRHc6Ru/JNoYY67FcK7R0u9kCCXLhhNzAMuaa22AMa5sAQl+RQZ9AvZSyPCffc4zY+CiYgk2RPJdch0wrqVjCv2mZK9TqKlldxwhKa7y+WwJK5aUDrE8R1XZoZuT4DeoeGRoJOoejlZKCRnhOzu0IE96ih/MBf+oxrqP4xMArqeVr/sWdiuuWyjRf4zKIR7dlF05Qb1nLS9rQcD7Tlm9LB6ncLsG58nfWeMPb3kShT3bv0NNA5jtGlAJylnR0X0P3uh3psRD8jrXeJo28u0O7leE55KdH5Id3IGkMkVQIX517M4/cRWaQViD09SC0DJtciab46Axia8NEXjGBSsFUBpPlTlGgkQmTv6eB9//Ze7fmtnFgUfev7FpP5yWOJUuWPG+Jk8xkrclMju2ZXXVO7WJBJCRxmbcFkk6U8+cPAF4kSqTEm0AAbKfKsUEREj93NxqNRsNNPjeQqiLFS5oAqHOgste4cRQjh3bKQxbnq5bV75V6oMQPdgoXfxya4H/79FOOimOeqW8Zrg1CODC8cqnWlmN22nThioJCeP3qywOwPHF/WBQMiCqt5eMQ1Mz9BKItiZZ2yPOySLByhNVOOPrSSFhPp0ogqx2N6okvBkQlXhCVFlzBykH84gjZ+aI8HWRV1VLB10cWEBaSIFjkMqKapMrD2sCr2WqJary4VY78gH7szY7qCQp9z/Y2/Alf0uZHh5pstpBIbszkR+kHSGkJ1e+I72Q0mCT6HvaULJnSwxNLXtLiejV7BmKnRZlnYex0K4LLnzOMkGchYvHTkBwjSStPc/qe02vf2KXP2RWDp+cbRgW4Fh3ywdVEHv27US6cUQh4+8WLIt8FqBVQ02GcbemiH4ZlV/HSqI5h7u1GmmGVXNjbk/EirdJaqZP45qpz08PD7mzFQMj6pzVW0cqimEbIOgBgPQFr3m/6mY+M48i40qkLSGBHUiB6bYCy4WJEKzktSaUbr7NYcAWwLY4JL15+PIXgknt4nqGwVcTpXBF2qmmvzmQPDS2wLEQc6bMVDyV9oS35oaR5igWQ60kKiw4nIO0pgHVjWJjQ1v3yJ/CVOBdIcy3PfNCRsaSfuTeMJX8e3TzztOph2fW+MOqILZWMH3a0PcLXt/Cl8qzb3LlXgBeEWMnsD4KxEdoRfdlh+ZPkaCpOjZ1XSYfNIi5WN4YfVLhmPyX5Wr75ahx2x/tIT3LUJWehHa1L939n97/s7xwTqZsUkwLi1b/pr6CUrDf6jmMzR39DJ6YYcq2uwWqg1UYFSWmbhVbO6oU2P/PWfP79Obmqfl7KVHKE8uip7KSSIfB9sIu2vmfg/LwV7lPwxg/PL8LPyZSdmmylEBXUx2EiaYODyvZ3sTr7zTz8M/DX9PlXiDq3WWU49TcpXo2uPEODgvCai2Z2ble+48zYIdcBxFdAHPmxuQ1YfSbQ/2vwJeiHYbtslynwva6JOOgDSFeSbua635xiRmEEeK8pyEBXgbV1ydid8ZjKih2nmUfvC9mFacVjZ5+YZPqxF2m2wNQXwy5pNNlW8Owd6eOEO3flO2NmfTR8N1uTYWcb3Zhb27GM1S4pjW94yFU4o+6qSOU8s1sfhrokfIkB2P5dtr7/auSAgHEHRRe4XqsYwzrjz//EmPlLKIhipZOOxQij0r6TZla2PIVobCCLA4n8ui8sI+jydN2yCWahol0zuQu3fkyd9CQdRGgNbNkSOzqCrMiuAZKNSdYPTY0y/6g0UHmt0Z3/wMwCe4wRh0WuyXgde9z/Hx/majHTSJ4l8BGMs7Kml1xLhbtscqTXREwG3BU5FGMqitFbYoT8W3zm8qM7XuVPXnS0yp/1IjgrRSLnKsl9OElpUDpbon/VplNK5CI6FNjZEdx/85bHpOFC8m7l3ewTblQVuisxSe82t5jaufRV6A3ZDlo5WFNWF+qhX2LFtsSaiBIzXvFOHxXbTxiyqtNJbDZ5ZTtWh6SVPIagJ0wh/ajHg+Fjdv8jItbYAVkoQoaLPLTBbtbRo2/hFQrxc4QifPOGHNsSeP65rKTOa5yydDa+lUYqLBzxEKrh2FHiWP3uW3z29ym98ie7kAVG2Tk61BerDrk27tkYIuY6uT/6UoavVOv7ylJsLqUb7GFCDSLtm9oPajUtHkoJgXVniRWZejYiieVnmiSfkdtWENUrQE5eZzjI28TUmxot4jIQYwqPdnd7xlxP5Cr02nfK7wK0CmzPkRZeLkJ9O59rHtIwwnizwaFQD1Rb1t9wRGwTOJ7jCBrfWjelnhL17wnFHksbsPJiI1leAWv8kLb9HUcBFZ0QveHRHdzUD58GvUS+YdlmpBUvk2Cmctk1nz9pZ1TKhnM7M+IPUlwwYetuaVrB/mNRSUIbz2eHmITjpSXbMQ/yEZKnopcQNKkH1XcWeiG9XQSt26Oo0mJ4eEFMAj/EyVZv/vo00lS4MGJAYYSiMPNC/bwOexT+njflLipb+SR4y470eMMGv3PE5JIyjdyY294aE/ZBktuCwNkZyeX8yohBlXgH2ela7NKYZajZSAmQ9rcY2LUjHmTkRT1CMOFnTPiI4UjjSqphmLPMZPZco7fOSuz/lNYzkqeAtQaiNe7hreXpSeAv1Q0Ra0uqzE0ceVpkF06yWXaZWY0pcbELJ+lOPZaYVYnHnt9j2GCipCqzeGVIJbLwn8/f+CM/JZ2QM7WSR3pA4vWhDV1iVmqAjbp5synSEWHLn1cFXnM5AKmgkUOgyhZYXOyuKAKz+jRwbXPqK5JS/js0kuc00q5Ie5XTCI2R+9mJi5VVWpR+EiiEzt7JzgxHPYExXPQq3DsXP5S1xZMqIrvJWBPf1am+Z59SVKGbulNKVAY0rTscEKCouXLqSYdXxMkKT1UTkiaMMpcGiSxWRwQRViiapUke6tLYN/d05TR6w9yZVomeakqKV19IqORPDBP4tJbiZ3rhOWIpyZtdXksxT1YCWboasyqpBHAwHPL4GHpDoUnsIAIVHZDbuNS0A7wRq+rvPqjoALzGpZotoI1YJZ/iEMbNYYiNSy1bYRuxYu6z8kupsY+Oy9Z05E9OEDJpv4Cvoa5W9JbUeXecJKzEOIgrWHn0pRrRocYL5bkNOWqoAE/WHFOlBE+qrSmKa2yzgRyIyryjRXFRHDZ7V3WxG2hHhyzUzmWKyzReSDNVa5haL984oSrJsW3qSNYM9+xybheOfKuD7rALTUIDbO3mma/dALI+kGUWqnLbB4Sk6kNkn3iFKBxKLwSMXTDipinvbaRcl71cnaDChrj6EJWPPN8uB8m26BvsUAFoXfANGYdWiKGs4WgVxVCmKIOW/ASGUjUxg7K6jJrgrd47DxAVCYdpYigHqt+rqQRWVAoBpP0OPCfBpDECbrh4MFhi0nSuGKhBM5GkpiVV+oxqciWrS60eyGGzPVTT0IHSO5SXqgF9OT1t2yBemxCUrMYyrLz3h6zTaqd8+UZz2XHCOmcelQtTaMbaJw1r7u7/BoeCp28+ZUdcVdldAKzWBmDA1MIUArSK2z/hNYodMFz1DRegqjkvCGFI7GMaBdBqbsDXF1T5eZLyF0e8XUxm0+V8/11yVIOmgKnFir7xsKkMionWUMmZyknVACeaq8VoA3onfZaLYsZpiPrbqjGqrLoMsJqfZQbM6k+GwKqfWPUAedgJuVX3A+wBpdJ72dz4c9JCP0p1fh6gk+tIpQFZWZi+AtFWFfwsIcvVFrbiwLFNqjtQ2LF3RIPt1lGYktaVZ7JfEw8bjk8ssFnFLAmDT0Aiv83JL6VwNaGThY5sN6BikEVxKacziwpyCZGQVJc2mKrimVkIyve1OsfMDulEzHLslcH8oJ9pD2pI0AAWuwmuivtN5PkeHRodvY+j6kpqIJ0TT+pkGaAmoOoBUgSnqbxgKiVvRFxkM9XyistFH2FEeKSZ10/F5OMEdGRZQ/TngAhv3vdphLFLP8sO6HA6qY044GPZaOP5YWSbo5OgMEJRSN00D/MgKof0zNp+z5vSi9gwfTcgeIu90KYmiN9ZgatGr0be7YF0qrnL6joM9d7ALIHcWThC1Duw9j0CymYow51nUuPpsu58LzTQmu2+2uKY2LkxBaaSnqOgLjNddokPp7j0qc3YYf0GmKxZtjV7IABZ6DW3Y4bpUAm013Y6B0dB4OzGYuZK/TTwkGv7FJIPA3MVaQ0zAAyBqo6HBcpYYBaiNx78iJ1I/vy8Ky9U9IOrjqD+IDZV6G1MPQnaG7LQysFiJ1aaocx23oSGGb6Nh2HV04/JyAUxCfwQJ4VLkm3cScsX1vAJR5jHMy3+Q/KqCkQ1e+JOcZw6x37I/wDJ68T5tvdHX8ozZVOGjWdQkcQEMLbGmCyQb+ncCxFzuwOQrXWcDstRsg8IxLG9Vmfbghz/B1BsRnFkvE40bkyT2x4ZVXb1F71Jez5nPTOpg0uDOcYnRnrck4fUbhcudBoF9dG53tGcDJIqcqITcdcgeGOHEdnxR/1AW56yhgtFYi/d7fjIMqIpz+lMoprAqexufvM+zZy9XFtSVc/aApuwrJj+TXc7zZE6vj1XCJEejvcFQun4hE0/3IURdsfmHtXDQyWIvRDgFODwlHogc2bUqT1efcJrNuaxz6EnEQrEsOzQ9N9wZcrISNEkZXOkT3gQzgX/5Hn53A0Ex6YxmyZSpyGhgNAeLuSoAaKLiLT1i/kWW+wR29ymaZxfaMvnrOHCZF33sgvd6Fy6m343X42NravwJFfO1aO4RIi71phtTEOO4eIIWShCuqyXXZ0eBRftAFsboaNKCeDagGNVsTY+4fFKANgCIHVJYjOKweC15Bdsd+EYpe+c8LTxTfyYOsWm77qY/u/YHg51deKagcvmEe+Jz4u2H8wqnnxWKDlt4AB1RVYhHWOK2nQZDIHTeW9rZPk79cbFFdU5CxF7fElzPfFp5n7oAergofoCVOwGMB1hUhXKiiDbMyz/h8eSBdKqQOmG1OK1sY1g58jwkvJnZiz6rsx0odJM1lSkE3v2GyYh9fusLAWSPeU/WfN3xA6G9Pa5uecjyQTzda7iFsEn3pjvERRWvk5yVpd3UwKpdPXGt5IaHnl3dCoX4fSkauuRXcr6+pNeAG5JdxHB2Aj50a7UD9jQ2W9yanV+4Gve8Wd+dTTcsg0GzFxRPn7lcmoPlWmEhPSKp7csleHbVELzni2b8LfaAeILiGVb+lYWZIsKEsDzDM86vmJuXYHmBZr9dAyIzyCWp5ThlQkSOqF1UWDgN+TEe9VMWj/njZfmgjV74Xs+0herGnpp+6wdsAWIhNTpFMXsCl57j9DkCV8pRmmgkwXmiuqf9oAKVmVMa3d9ASrv5xEFaGU77MH15pNexh0HtyTj2ARqjajloahkaqW7KpY8bid4LA8m4IG7OFS2fAjx+bIvG+jSaM8HYm5tNteJCf6eXL6xWSidekXsXXcG/bT+Dzy69dKarJhgrH2ysi36vqw4athkf9voUOGfAW2knfLKiQDqt09Z+edDSkFM6Mc3Quwib4yFoOtycuw1NncmK0YMqKpRUXvuxnTgYqdhnbfmHcFrAjB90j+TFj4rRAf2zEhvqc+wxBpqUvS5d3qjqd4ugtwwk28pwOXHKoC8XQNbjYECuIGSHlJLT3M9aK4vWwXiGnkajImF1yh2cjZhfSrlRPWVnvak6mossOvklWiALz1R2PBJsEVemOyrKLaNLkm+VyZ6LAj5qxCTt3T9IVGT/VmL35CHNlRXQkqEapwdYCfNny1BVKsnHn92seuTnfG6UnUArPWorLZckiSnGrCBpKwnYGn9qAht8EF32lKreN4xhQ5rcYp86imZnUSLVyZgUccw5a21YDUGlg4Pz4zMExfEwz605VSnXh1YrmuC01gvuTK90Bkey0PF7P7KRNRR+19FTj/P5OtK7HVdeUZ4dWpFBw6IXR4gteWUtOC9OVZLE6dzdQiJ1zp56QynYaKZ3FiYvizbPg/jnGhyIxjrOlMb0XiX07n5QVAQYNBKwcxGoI8deGmricFeEoyAYBZsSlPfD2Tk+/5C8lPVmmGzzoy17VmGSeyIV5RkVQZ02Ro7KFaKwYwdtuPBYrVb7RV/gBDY9sA2Oade7OnqOvPEYWS7SVmcMAKk/ar/1o/CwAesXbAKTWnRWy5Z/TV7vTOoxidwxiqYx6NIW7h/0Q6UPaW7d2TaphhVo0p/Mw5e0YuyAqk2NlJFYnZaMJp+mjCpc5vdYiRtDp1CjE3hukBJ7/1sqbuKnu3koz45ifDPpDKFT7sOos9JsierRZCmfZrJhSqjXKsvYxNjVrXVd5Gtyy6bPiGOZa+IeMGL/Ffs2b/wmACeaNvIjifJ64FsMXKibVoWpFi1/WypEH3z+6+BRg+XYL9JKJ3G2sebHR/37flMNz17Yze2hOJ2tFhJHQyo6qDKyy4Arjq46MetANVdrzVwG+SAWpBpoNoT1dyo6kz0kN5+P2/YA0jt/JXroTqRYRW5sU9QPAX1hbbkp6BeqGWt78ygG5dLdyfB/ewFujI6fcpaqB6R53ssQ4b1Nmo22s4uL9Bh6YxR+scHLHWxXLjbY0s5jsDY3wB0ztXWbABXxYliXTrZZxjZPPoCHuYc5hkaI4sPX0DDsdBexlm4toZakWDlgM3Z5QWXGjt8J0xsj87i04wFPbjkgy8M4D1gOZYyPWDYofFGYVjAoi2LgrpkXegDhf2pLzkqTfycMVPRU22az4GAw6WppIpEtjgm9FFYYkwxjP1HduEgjH0hllnZFxcd38GC5ad/d60ZLTMLT6aeWOkRrgmQ9wU86QE7TlHO8u5GQW+/orxj+x9Z103FrtYfRXulvRrI0373n1w3sCgInJ2RXw77IMhLU6fgxJ43Nrk/+lIF40ADicLESgQPmPVnRYGjfMEo2XnJcwr6lUElg1p2ymS6VcwI0ZqJS1UgfENQsDXSI+WTW8Ity9kP+Wi5vUnfX9mzOdtAKb8p8EP7p1Ycnnjj73lbllrfBMtxH2kChYupGRIX45tMZQQmm3LJSamRWNFnsvwfHhArMWoRWlFffexKV0+cfhCb13pxA9/DXhQaZvgG3M6PlMCm0MdjJjxP/o9x45HHxR4GT6U1kTgzu/94c0v3sLYpSu8ROMBdeRfJtYFtiB8HxiveAa+R1jFo61qPKZFwHTtOMkcL7eQguYQHP3TQ9iz8E4gclPKLtphVM2ZjnYMjKkRhCHwYjZjCSd/bRRGxQWx+szA7kdN49fyodf42sixdArTXARTqE8G+DiCCXf8NA6MxrIG0onP+ppukOLhG9QAaPa/kNnuqGhuB5lo5NmIttQJ4hjHSsoGRzj5PhU0oLBQhY+0kAeaRz0Hzwm/IZhvR2FuP7+D73rnosUH/FAuJPaPQWlVlOSaBH2JjbWPHOjQuhQuiuNxOJ9PF/fxhvpjN7pe3S3k4xR7LvLKKN6epDUCnRC2ZlTFEntkgL5061WCBEop8t5jY+YG25ImdJ4dsg8ZVhu3Tsoi2uO2U8oKK/IA+/2ZHRQuFvmd7myRpOG0uSboGZtL4SRJbK3aZpV0b2NvYHi5MW9i2XxdHJM3KBkt1PiY5bj6yZcnKS+p0rvI9afnCG8A3SO9cEWR7BktmcHxkFavGF68BK1bQh7pKlkEHOuxQY06N9jZVw+QX44cdbY3i64AbodLjosDAb8iJ97k1SevnrBE4lVh3HrBd+VHkUKU0X2EIrClMN+llGAnL4i3p2xrUS6c+qGHZoHxlmFzkxchJolPUXae/wiBIv3lhxByD6HA285i3fk4aedkq5kRwowbYeKyl4DF8oS2f0wbg0yaREhTxsiICp8bni44bV+oTFPPg8ylhchW0T6rkJQ0C6oDKX4WYvKGV7dDn5Hc+R2iDX2yX+gtUmFLVA1ANthSMGxRPiKKjGpUiF3tR6h5YeIVC/MxOmMqddGB13j2/SaN7sFbaKrsKQB2B4lE9NrMJI2MbuRAirgx9BtR4EeS9AqE2h8ONm5id8PmdidYNsiyDPSFgaX1gO5jxy3ufx80I/8Qmf0Oeh3+Yv1G8AqSqxju2zBB7dgQu5oUpMdA5pfN9H8f8xqd9QKkWpZuQ3hgZgR1gB0LmdWJR7IDqGCxU3d1o44YkX810xbYO/ZM0fkjb/uaB4JvIN9jqlS7MEo+IV+y2vTUmrFf+9F+z355iB98YrLZw1PhEb20OuqzExH8z1sR3qXUmsRnFBI9tJ2wlHB4DYLXfc2G6dGJQZVfanBjUBFYy1U3uaFjna7ByF3M1eemxybgJLKZRHvsoK580PcB4oKoPquIarr6KEsRkOy9EEzkTWeNoSGKJC3bmtNex1FK9NrTBzJhK3Lrr+iiJ0k/eA9DiX2cklq8aHbgi7UGN0MXtUxNLp2J6EUxOd8seMb3SFF1V/AhQNZZYQFYD2bhB6WvneWkmVi8gXeRhPxo75DoGuzK6anu94dCkKGMpj/8OfU8JHv1H4Y95JO5KtgwYoZ++57u7c2XQzsNUscZrr0ySkTnYIlYMBrm2swMs5XZodEy0rSLdq6QYLHWaNepCgwW7WrKoBqnD2HNSNnN0RDz8w0UeRWBHiU//F2945r+zHJ7qmMTZWwPir7DhOw5yEcup91jo640RUNXNvy6pjW8lyWJsNU7hkM11KVGte8MkRI6RZNmLq6Glmjilc/IIb4i2SndOJupg+87uf8Jh7Cg72e6Tz+kLs1zMpPk7itin+SRY8wZAVmKMQZ6awdm/KhMmw8n6/N23eB2MTJL+tMVtyB8C2KktllSaprLBMbfYRTxJKdwH1UdL42ibb37EPAA53Pcc+TwgCFCON4ObI5CXigmnrPZ2LjOh7JWOndXS+Zu3PCYNdmigN2Q7aOVgAHYWGPvAG2B0WaiUZVRSB+Bz1vSFtmSu7k1aHeDMqX21uzKSSKTnW+KSFydHX+piBGLtBY8XbiAYmVuRxl9HklmxEC8iOyPw6YcEVe5sEalY2h5w7MAx29Of6jivisCP2wGq3ZXdJ8EWgXz2QDKZAiN+CybEJwC1s/FkQEaH8diV7sTRDg/Hc022FV0ZJeviL3oL0BrtFsrWhmpkVRmuzEmPJPQuc1nJ5UkaNeyHXDhCA9aW3Mjt/vlZab2aozwLXOgJXXOleRUO2x3LkLkPIHWaCLCC0jjpTP+FjX7RmVtsvhrU3mFivNm+w+f4ALGis0cUh4hp9yPI2igKMLS2QarZM2l8j8scYY7QF7axu7lVY9+YCpv2tBYAM1JhEEeutU0JlvT8dX/vZ3arvgwrz0jp4p8crYVpMlG9BipV8YQuO7UC52c28XMaWFvJMU6IWFXHQV3uJT0YMS0OlXwQRZOmxTFjOeZJBIl+/oi+FpAd95Jv2XhM7xsvHm1LUYhTuKTQC58oaAyrwhb3YNhRGGk8EvbMLRVZmxowIi5JdWhuqYi0hMaLDCNXl6yWzvDYQlL4nn0k9hO/3/XNVyMiGBuhzbaXGwEiIVt7Yv8Bt5ZCZ2H6csQ2XY9M/A41Tgml7T9y1l5GAFiT4U92szYMqNJJ4JgC1w3c/9h79fwflSuYLSYSmgd1LgDTNpsxP4bH8JOTEBmjfaOLIzQ2NbuAZP9WxtrGjlUlMqXd2OHh/a94pxUkOvAT+w3zApcH9WHrwuHDfVKYRSt1qo9lXGYm4xLZmACQekDGpTj71gu1ZZvonQbz1WvSyoQPMI0lE6Eck83mlgrsHhPl23AeCux4EsXDRJ5lW4htAvD9aIzb5a7KJdR2Trm2HXx2r8io7W4DTpeGN3av8YacGAOwZgo7ElYrP/YsRGwMmtgDLFDH/qiNVifD/bmaIGJXIwbi1c4pNR2MtA4OUMHwPdtM2m0LpnpFEUoam6haGVAh5Z9kB1Plto4NjjQupmISE4o9gFt6OkfxSmByedEaGF2arwCh6gUTYFOaKQNYThdLtGFCp9bJtJFlILK8MQVyfyia+6Mv6VGd3HyTVC4YbBgbYi7aieAQ7pDMYibPNEM5ZRzCmEsB6ZzRGV3CJyWDDBd5aIPd7HydnJiX1leWfiicS0JF27zGs0DYZwQxaUBlVGLySNVlhUL8HFEqN7yaqu3ZkY2cfVXVcRdH65Fa7Nl0MLOSiqyhHWbnMbPGD2nb34kmRr5h2WYEDMeaHXEZGd+nKf1oJ8YpOiWz2vHYItj4XuBokyZZmw+xvQ0ITy9wxic8r7ZngfD0AmeElseHYasnOCMTHh4u5DVnwCes5hP5QOeYThYXqSBTvwPjhx1tjR+IeNRFCPUHdvq8NfGdBCxHMWftD1sWwANsIy6Ifpkcwa7/hg0LeRuHMut2yqDWDkRHUnr4oRdPGKsHI0AedkIOww+wLqertIFjJ6/7nb3khhUT08hu9yQsWoavS9jwUxJXfhQ52MPma4ND69hJwsxIhRqZlZo0xmRpOZKAjlAEea8gHZdQjE40TN91Y7ZESCfxDmbvdkSGF2N6zx4g3I86o6PQqAM/fhN4/NsAjADOleDkoqcJm5OTcVscqHuTfoKRYZHn7A9F5ERbHocKMKYIexmXeLNhWAhe86rHLKZixlEIaH5LfzHWseM0HIIOfWIdkuL7pbMitk47BnqDwycCWYblEw5jJwJGNQISAOiC8wyAKoOfOqBJtkUYG6oR/GiVZGtWer+RUDl33Iq2g3o5GIu6OtS08txSRqXK1ym/O3Tijb3eaYXkB7EjbDiO27gey0BLSHOJqNTeIa8ZmG3kOtTIsJOJjg4m8n0npMISxgmBxAb/wKuNw29PO8NJE+9Hk+WkNrQumBs+WiWg8itASzKtGwJUrkXJ1UaDWClkFQ9yvRKZos0HMJVe09jQSGV15JeZiimIinBsL2R9hwb2NraH+fN9Tds+J03pLLMqxehyB0ZSVMK1w5CFYZlpDm0WkxU4i+89Fi8QXIjJm21isWeTK00siAkLn3g8edTwA+YLsLjRDujVoGf+DwkBWkNoXDmNN9t3EPucYNmaDAn8zN8RE5OnVJfK0rTxLcN0KEeD2OGr1sguuFRjyle8Cq0znY6HU26VQZzaYhq1HJ3MW0CO2mIatRyVzUdAlDqQGrU0nXqJQKgFIdC281EmEKpusEC+SkNKIFatGI1ZmtgS1dmcA23z5Mrg5At/2cX2YaciWA0SMq7M6yDOB7AuwNIEEu0rjAiirzt81Me8NTPmvPiwYVTgqtsLTyojzICpas774RUQn5/sxXjgLN8hylNd0svaQyqKw5hrx/RG7FJHT7GDgdk4i87UBZYfMWPZ/E262fysDrvIM8D791TbP+2Y/PmalOqcRtNBWJXcOt4jOn3rDVxdvv7N4hSASG4LLwG5M2cklfj3H4i5tSNsRjHB35PLPD6x9snKtugjGASj0B+ZQ6vUgVPqIJPEuMkBzMJM7Qx0oIDJs8h/dtdcVWJ6xO6bauS5yqZtx2Ud6gQMyVFkQV2VOMpUzVt9+cuHVtEnEyoucnqedz2AvTs3ZOuLtBbBkslYOgH7M2nhAWLLdrEXstSX9PWqbhjtQKqerAGY+go9Mk4V65rFZuBSYYIKxltxK8RTSSLbLGRQYC8ifrAz8sIFVQcdlt4dbpHnUfuc9qLqpLIbGZ0P4SklY+5Mx3epb22y4oKBg3+epKTy/T1MPdfsJ36X65uvRkQwNkI7om9rBIiETPPYf6qurpXy2SInjDC1Hi6OCL2mAhpBonMezYhViupRnIaYmrPRMvbelVNt+QNWDc287sDM9JS5Q7dGco9IVVzlThYQA0ufsaIfspXxOoNayVSIq0Aa0sIrQWgof0E2OBrnr7FNu/baNvla0fvYs98wCZFjZBfS4NA/2YXHffulLRg1u+bxOMQmft6+zoouroMkfInvYAp3Y4cRoL2MFkW+m+NKkuVoyxPwy9rTl+zSTf+p+nYU1NI/FMVlxg7ivkz+7GO0tuKQpyu3q53xinc/fGKFAPyqwJMRkFD/xEmoMfZCSwQryz0z0u8LIxzv+4m2ZCabJzabyPM9+pGccWPNK2qA1daMOv4ZEUQtd/5eYENEYOebJrL3AfPdED1Y8MZkUz2n7xfu3JXvXCJ7OrtOEj6S5qd9a/4OVIBFHns7GTFlglyxeZEKs1bbyx6vlIfxem3/BM5XtyYEA+danOXJ/B+zOR7Uax4teQsT2rrfXxAC8f6I749AA6eu4ZAn4wRQJrDliit1kTK51qs78IPl/vr4zq+eZhsDsemHuzDCLsDsDjOaGuyFyqJMMv7fB7toy7JHk4EjPTvzO2/88PzyOW/OAt3ZdD40UBipsc/gyov6/YNs23W+GkGwGZOQCjsg7huxi1HItubRHqlBCcQFbOVCXC5qDfn+a/OAiiiCtw/FfxMNEJb1m1QRpreys5BDoNs/3TyIsvKtHQDubAFu3tj/xpcU6ye8Bqj9Sy3BUUw8oUGSURoFvsAIdrdfxPgteSBWK9NwBFYgGZMI831LSQ4gWxYAGb7A+GoxW4Deszvsm2FEbG8DcM/D5Y9b7O4/n7/xiOxT8uFSZ20MIIveKdfd1DVVdpYmNIx4TX6D+QPyElR6NNJGMAd1pAakeDR5V9ZCTmbT5Xxx8F0zooPErnSHOkBoZTRyKjacojHWwVwmlZgq7UTpbhOET+PlAfoh3HlmN6oDL7b0XwszfdhEx44V9Jm3lmjneXI1OzMO9wDY3hYTO0Iid9wqizLvxnoWO8HUVPiyUR04duModPewpgwHiGeKJJk/6tnk+vZ/DBWLC4sB9l+2ZylOKHXJsgTYQy/3+1FS7EW/rk4nGoQbr81quHxZXcDZ9GPRiTKAqwsuSx8Wmjo8HLSWi/p1eszigwDxco+CE60VQCVdnoOWOsp9Of0Idlg+Hrdl6wecttasEZ4RW7Ar698orFbTpQT5DNfV1hMuoWu1FDNqfvXmj0oOnnMNGQo1gMMDzB+3Ezwt83nF4ttnTWIAWKu3Z51ydAXrquhcEgnoHQ6OChq7a58vPzDQIZJI9SYqOHVUb5gsX9xIPxYQVWC41lwexSeDSsPzdPjtTBNFlOWKn94rLBFqyAhE2XwDIJ5/Zv6jkbQrlacyV5CQ4mxsN/BJVJrX/5VfOinXdp5XaX9JT4rrWemT/Sd6Q88msYMIaNWjBZwuP9nvPlC6/GRPcQhaV+PJHp+3iARAqo5ErXbAqYZ/8Md3wHT5ydhU4/iC7HXV53Lyaeyt6sgrX0nmF8PWulaqtQCrrniqSIrZl2C7C20zNLC3sT2cqE7S9DlpuXD0O+sj8l8xO3krTVzLMGUNqlrxWngi3/jvMDm1d9MM0QtryrP9UBBgRMTtQr4Orv1THBL7kLeCTNWHRF/m7AwqX55v4bNHr9SEzsLtRgJN0Q2eV6EnxcE1GolZZGMCYtaW3tp2MNBrS8/03YCt4IT2Lzwmfuyjhyq5H1c/EuUaFKUYKlTkVlN792dBCjWA8hA9GjvVUea57MwkF8Eh+fET89bItakyK45RIk1uQhVG597kE0boM1P+jkpd+odQMvl+MIQD2UX5AUpoAhWQOi3PXG4fLYHYe5sYCcwyeqSm5XJ9A07JGo1n8SkZrIk1JLdC5uuG+LFnKUhvcLlrQg/iAedIbukHcdiHATG8KjyQwnMg147/w6AjKQYpvCo8kMJzIJFnu/w4EXBoWkphQLunTjFo8bX5gSKfdQ+ZZ4jIDvS4OTv+qdloAlp8ZXqgwxdJ8ucELW5Oz0vcQaDXbizOY81Ar7ux6mj+kr36/qtjbscA8Ohxe4Hnxe4Kj2MJ8hr4kLdxMNBr3Bvvh2UNhpQX8GvZW4DpJ/Iigw5GI9LjE9npyJKdo4uIWGG8zkBC+4uI7xQ2qj2mbbDpqh6gpOigh50+JrnZ+42A2SqOIt8DaI2ghQ59UwLQGkHjfSFehRDINRM3+p4rRABaE2gWipCLgjpRO13TfnonJZl8DUptbTsRjAFNXNh9ICmrHSuvQg5GKUTUz2eMEvkyLLxGsROd26HXjL1jhzptprgO0rFsRRFCL8QO5m4fBxiODWDNIjPtB2shFbincx3onQ7aAK+zFQCEHaItAK99eA/YdQ2+AMEOQRiA1yFgqjU8nu3koZVD+8wcNghA9YFK6nFWAoSuCgXzFOA0Ojm7GKWssQI9lqhJV1YbgoKtgejb7H6l94dbn0Q4ZE5utL1JuwZkDftwfGQZ/GXhqNgdPXc99UymU1w9/QB7KsfVG2bstpav9BpXUq15HS5JAa1LTxptsQuCVetJE58AWNV60rWDooi+5qJlb9OVttg22MMERdgww9B4Q8RmHj/Qa/yszKj1KnpHHeovgMkTUzEEfq340Y+ZPHXYFSKbqyf82PGwo5ocXIVmmYAD0O5AT4as8UCN2HpDKlCdU+oGcBIHCsv1DG4gQykI3fF+mJaUlN60mgSBUBDwyE+SzvE7C0jWjxyxdZp3LvLQhtJJw7t/ZQF1dfexXYnMn7b3CmSKSYCmgxEBaUnWO3kH6c/fUGRuh1WkZc9owq3/4zn763/zLXp3S6mhNyQdYUuoubnsIMnELI3dvlshkvf14iOZsr7lFTFkWfpiigNqZXAO6l87jJGjQiL39PoGHNhcj81Ate3vj74AlDagOJZ3W+wEmCRL2JbtPoqspXZ7xGwhv/kG6QJQ/YDK7sdeGBPMfPG/3zCh2EJQvwv3p6Ce6aNigFWpguwogCDMVPA7selT7X5njV98wgQO2CnhisrNRmgYqoYkST6poTdFeWcfstLqoIm1+fkB4Ovk5Uc+d/L/Elo1bwBy9Jd4LytfDzbvdTJ1eY/C0C3FxwJ7QHccQjUJpoKcuB/EdwFjE4837+Sj/1PYzr/LcykZ5Y5+Eid3eimuJ9qZVktBbRhJV3RKxBHBwA2MGBgxfYwYMAKDBdykNvTJfIknlnwVaeYHcO63yLMcHrf/wz+fCnlkt7bs5QfDIr/9O9tIqlGMsTWd4oybYNcXt4d7BlwU5yIw9UhmJTpYfCWYHaGoUSKNRdAPVkUE2Z6Lveg52GLSpFxLWXrxv3ZorxLSilfj6xnWkFbnbgGAANDIAIlcaRYwh+0XjsjRHSQHJEdayYn8zcbBX2wHf/4ZUCexPhZ2huc72p4syaEgignvh7k+3/3Qzuf7Qlyg2XQ5Xxx8v75YtSdX5jeyfiSCJY+YDb5/5ojVQmbJGjCfSimhGsykg+rppnrZnQSv6Ttv8z2nmo56rCzkF/oBV8h8nX5SSJZu58vl9G4+fZhNJov72eJWYliDueN1ID1IAmmYbSEZl5wTAFIO0N7YP5sEY2F5g8dk7uSzQIAG0LRHw89TF7vvU4FRfe8hepa4NPkadngpi2vI9hWklf1Th+eFIC9c+8QFz6dMkEL7F5ZKxUDDyjVM0tkX6wc0qyJx7VFwfp5KM1OCA59Ee1ZP/HcgdZnUh69fvZA9CchVDVrfcERsU2tUq9h2rMetHfCNbGrE+EWsSPbDRWx6yFQZeRG41qGMrAzLZAn6A/oD+qO8/hzPsZKlxEGH5r7R7AMPykR2hJTtZl5vw2LDg87Ip0ebnKZSIjpJk6JWZ/2CQ+B0gROJvU/ud0QYA4lQLYdHlZ4anixW+EHsoIgle9D3ZgY/BMGqpEW7cXaf8BoTgq1/bfzjm8iqb3Lzqqg6D3onQULL7Khsw0xKTRsmVUMROJLUHZvM5gVVm0mpaR41ywVW6WEwHNjHnVCrLX4nPUgXSJcUwPJ91/jni/+0WQEVoAKWCCwRSBdIF1h0oDJmKln5XmTZ2Is+00eVacILplotUw2wQPX6A5TU0RsEkBqRXFC3BrDYw70Ld2GE3cyLZCIldoeM3HIlwdlVagAqqeAHdEroPDq2+Qp0ziy/uWi3opgGOYAElit1mKDIu1wpgSli5cZYAZGPfuxZiNgYRrIy6Sn4kCF6G6ZumLrI1gTjX/hPfgFoXdiEBHAKt+Tj/nNEZ7sAqMHhBQCqxnmCY4Yk3fEfMiZPbtg1A9Fed79SSOHWJxEOIyNA0fYmfXdIMJVge7oaLtLAO9PVhDTApnQ1QYnej64GpeP4Nt8kwCLcsm0OkMBbIrH3LOH+pescMn28gKbU2tKd8CSKLtAkSlVSCxxIG0jb9cENlQoGdOSiczT81zRRNjFjO3q3Ihi9ppt7I4EOxMPkVnD9dcAEmAATYAJMgAkwASbABJgAE2ACTIAJMAEmwASYABNgAkyACTABJsAEmAATYAJMgAkwASbAdF1MBzt/AweZ+DvysCMsn3WyKB53f3/9XRogTIAJMAEmbTDxDF5kmjgM/TSH1/OJixz7F36xBRaWuSuY8sUExArECsQKxAowNce0ZSXBDrLweYkwsb456B0IFAgUCBRgAkyACTABJsAEmAATYAJMgAkwASaZMa1i27H+2K2IbTWsAbW2HfyOtu+7YcWPxR6CfD+dy4zo5IB2es9AFaJLST1ITYqVlwFAZwD9aXuvAGjQ0vQqMDku28Qs0Ety/4CUlkBJKUrDHY0BhgcMDxie0VKi7++kh4VEaOXgv9frwa2P7DLEPMPPnhX49MN8tYSdzQeotEIFY9o4mByd55Fne7RxDOkNSUfYkmD+vpSYFMGuL/CgC+X4IMsCOPu76f/Ys/K7n/wfwmrmToAO0AE6QAfonExO7Xfco8wmFJQL6+jRjz1xR+tMlgsABaBGAiq7e812GSVc/rTFLdEDGkCjAZogJoEfYmNtY8fi5zB+T1q+8IYwdulD7AaegMlklw/CPwSvHXFukJj1r8APilkpNQ83w2FEL4lPaCnsEGLfr69dLREhz6YWB3/3A2ExwyKZxdU1qyEZGeJhx+Ijn4oBJaA0ClskB5qQvixiRywj23OxF33gqNgH0ndEC3eemftDH9a0A74m9g93lNTQvcsHuj3IBa3CG/3XDmMk7mxv8efg9SRrG+LHQVg4d5A2fIyjyPeeo7QrPQlSwxY79Am/2A69+XFrB2G3/GFWnkVwXOmyjXuQndqT7W2AWlNq7FjQF/rkQO5idgq7h1s1ifzXpUyUCF7TN98K3WpUxzsDQVJMkEZDiWDPSkqxSZ3rdnGu+ABcpOKSvT7yn02CsQcqBEgASQMkASIh9YkZC33DTE2h7F+vp2dHlYAHLpBlY4/PjBpUKGBECnsYIp/Lz1+xuxIHTXz0ows0XqP2aN8Hy07n4D7uvtEfARxIG0jbMOCye7f454v/tFkBnXHS2cd1cjxcZxrM6MsBXx9X0ipiP983HCEWYGVLlcR3wvaZpWn0A5uvK/+nyLxu4YLVEdybHdor26HPnmXEO7ust3/za4BPonCteEhb2ne+vknHeKTExkAhdit5PL4d9Kv30f9ZX3RSzykJG3z3Q1tkQsZcRjKV5Vhy2dMIj0XQj9N6acrVXpvNi/8EnF7WNzk+zDlY7JZuxbgNur1bNVYBimzkJMYLuYHDFvDkEy+ZDNq+Ds7/xMijvwgTrumi+A84ASfgBJyAE3AS4yKYvhvEEX7ELPZgi6sL81D8N5GbWKEidzrdEbq2rJpLBSLWbY4jsA6jYrYLMDXVv6QwX+w4009grkCqABNgAkyqYhJZu/GyA/UAnAbhZHv2flkq35zZdJbMHYNPKEL0+n9hYcvs0+vrWxc+B/tgHR9ZfANLCGyO2SSpxJyOyHJPkgK6VAkJZEee/eUCOBWrgUhbQeT6CflNQMiw2rsQsI8ZmACT+lX1Pv8MkGclZjJssr+AJxO+W6H0rE1/s3F0Sn0DOmdzJikVBz+6/OTQtgsdYbLQwbZVCByghfBhjsyj77pMeFCDbcoBc+jCA5kR6uHdzo++5AU1pIYNkaTclhN7wHfhLoywu0+BZ7srRG5mmhx9yYdryIx30DrttG7QhFJ1xGm4kKo6jFhOt4uyTQf77agi7bdCuGC8O48r8l+xZ6TvRXj5+BfW9JS1JIVyZJIsOQSL4I0dRmSXWnT2i8BKF/dHX2KWgNpwkmCGBy6Vhi4V6B/IE8gTyBPYcUmqguMoDh7Ze2ya12UYbOI3RKn+/kCJDSSoxmpYDZwe4VqAZGmqhWCu6hdQ4+EXXgjE/iU2BAPkNCcnx3Est4sjXpLTyuOhz9FO3OCoCiWposiqeRQADaCBpw+0pKHVvMrmYe0sFggaMlP6YVgq1fGwwVLH5QFyWi5y5FAqDJQuVE695hIs2YrCe/r02MjXF9gS+xNtecoaTHaQ2pC5rteq/ZykzDU5j6cw4w3RG68jl1ULFTeHm94tbx/m++9LkRWzm1ArLK7z7ZVseV1stqIysEpELD30fhApm0webmeL+/13JYSMW768HJHAEo+HpOj3e1lpSZJwpohsHWYzJoG7T0mLaK9BemK1T18GWudtPu0G/8J/Ck1rVEa6ktpNuxWxLfAiwIsALwK8CPAiwIsALwK8iAbSteZHeIt1IMSvKLeTpePVl3Dr/3jxkbiKRuoMgsU0K9PB4tYb6vijD6Brkusa+OrtuFUnnwn211URNHDXu08F/7V/Cd3DrMwwCLMbmN3A7AY8eAVN19F5u9yF/+A4X7jPCuv54MyDMw/OPDjzEHsH7xS8U/BOwdyDX6GMoMEwCTEv8CrAqwCvQilePMPvQxBgRBB9j2eHvhdRbYPqRHx9o7bchqwkPb1cVkw28TqKGCa2/yMyX9lxPp71kbCH83Aozo89QriQn6EcvoZ63DiWd9jb2B7OdjG+0K7CtU/cAU+LegBTpqIpA3ECcQJxAnGS0x8tP/oWnHeA1b/7+ejErJryF5+9O/ifMLXuwM1fhZi8oXSOyIppWJheQJFPbn5Qmx+Iq9pdR8SueB5uXmumng3b0o81TJ2a4wKSc+DUmtNcHlAs722gwkdFTnLqXfkuFnpD0hG22PJiqHEVV21law7GShljlWlhcuBzvpdsZzrsBKLNBpPvKGIfRWNFTILof79h4qDdM/2ouK31ope0O9IZuBxzwV4YJ9kvKRv5S+OXcnkALkK4JLa1ifIE1BQjZz/JffbX0aPvOHYoMtVKRKHIumhKbhgKwVUIPCUpdY1BHNw3bh4sBMmSn5DtudiLnoMtJlgnVdkiz3K4dX10bPO1rWlNqlnnbqK+B271xCvEEcCqvjERJxb7//wzoJ1ofIAbBRIdWJgP2YxJuXFdKXYDDfw1FiwBkeg13XTfQXGVUWZ3SbgUdSA0rAMl3ibpKEw9ISrslUKmicPQT7PAKZ0XG5OG+62KfXg+cZFj/8JZT4rHhc7jerK9TT+4sp40wXVcJ8IkmCrVP1/bV5pAlsUPnNBh2ndFSlGEzO2f7ABvT2CViQFYFSqPKFG85KrxyKpnZItkakZqry1A2ZlW7WTnUFU11bBugJIFpmTvtbAzfgbhVGJzlTiM7moTlquDGki2pgrLFg9JfaPfhfmZSksY/VQ4AlzNRsPfiR8HX4jvCg+qi0dHsOu/JU/c1Y7xTkJRrsQgvhaLLHBCed5f/VIIhYNID7sYyJ14kJRVST+H2ZZfLZ1ng8fDW2tkR+iFZMVNlQUmvPzn3UJl4WJi9S9yYqzDebAgWSBZKtLivbz4f4ncV6YOrXQH8btoS/wocpLd1tkv1qDAHsBwSWO4jufHKvlbyuISLloDkCoJ7akjW4PMrZlUtF3hSaIYGsM5Guxb6h2O/nj+89F3A9/D4sLNgzmkwAt4Sc7rgxNskc5znf1aoPxriQNmFJUvOagWMJ3OdeA3Bve0f2pDrAGBxKkjceVWSZ3yG0Ky3pKS1gcD3ye8ijfpTuWmlbEPC68fdaOJjPWEa7i5pJCF2QNKb8ixEzONgu3/tq1o20qo6Kv/tfGPwCeRfnsvrortiQqavnsxAFkXZIGDTPwdedhRRSmnc5UAmQ5ygxcfIJ273eeDZ/CB+rgAqOx2O/zqhfSTai5G5X6j3PZbSPzm4OEI3rCUUyJ9xSnRbmZzMEWR0ZPK5qBKB7c/j8izuJMUqjLgi7VBfQOzw2f6wVeI/B1gT09k6boECqO/1+vUvjTmlH4Y3k1e+UNPE07B/G2acWBji41TrRUxFSyRc5VBZ8R9cRvN5A6ANQTWbNdmwXqtnSSTRAgjNaAk7vw3Pw7z03A12m0IYgNQxEEpX2rQT5VO3RoVPO4BPEhWWRAmdGJZjWAuR4H8wcKxiorWVGlaeeDhEbM8BtsCbHLqpOJiJj5uIBhYZTAJZr9ATVpqAyyDDhrP20/0JJ8j3j4U/01UwVQWAARg7UZa4FY7v0GIR7Eo/lNIws6tL4KUgZT1I2UVQQ8QMBCwHkiVrfmDaDXOTQZkUm4jGRbZpmUKzQbrVIw7yecjO7WyHgGNRGgoi0ffddPTt+rWcCp2oDEbgHL8aPgnNuMmB5JqDObwTDbTdwPK5XBZaryn15YBWsW2Y/0RO870E9jhUjjPScPvpL346LV1oR9C2u5hqHEkZPOzJcs467nMchV8rCAce6iVTx5x+uyAT0L9vAysb3Xd8Bos/DkdH1lJSZYipgiHES/RsWY/3QS7335zffPViAjGRmhH9E2NAJEQkxv+n0aj4QEdrkM/Iw7okT9dbVliz/cu3NHJnpscTxU6eQ/6gSLYszDhnNghG6qcDCSkXHEfmA76CFF6GkcIlI5ONE1ikPmK3b92GCNn0NpmD3LLUkkfuiSYASmRpE7mfsIPRprIrn5gpCopZYG599QTwEYepmNO5xNtecoaTJFn4JWPelcjdVAd8WMcRb73HKEIyqKWsupeX/GSj6/JXq1rMRPvgyoMayjXQRFikoyLQodFDQrECgB2HEJJT+xhJV1ZvtxXqlY/27qopoMR0TfCd010oc6h0WNwlM5n2tSwPmVJLwKzyIQE/ypAdYyS8iQQvaKkx49o7qjt+dboWIjjLtgRS8IOdRPi3JdCYvLUDVSBtaby1M201+1tNNb+d4IsG3tgzOo+4p+298pFxfoJibAngHgfge9Qd/+P5z87WDJWmvh2olEdi2uRErvQOgiqQ3eyHSTPJy5y7F/4G46IbWrsSQCr+k/Kk2e6e128G41tev587fAkga4n5G2wXkv4PXMa0hVVkRfPl2Sk/ojxNxQAKlk8czUYcQ7vttgJMAnTJUQO6a/YXWFA1WgWpEtuCIAaDJTQbceDaN1BGFN6R3OQeV5jQJHvO5GdLdJv/R/sdt3OjSz3p9m0Ze9Tq+KZDzJ/KXEUlfI4ReSw1QgCKBDIGySKAKiur4kDJjMMoX2tOVF7jt65yEMbTA5rLX30Y89CxMYhYJMp4WMISgeLfg0X/DzqXRVmzCyXlHlcNib/IicWto/pdnn/ML+fTyeLu4fJ3e3sDiiOjeLl5TQhS/gJuNliOb2/XS4GWe4BgABQC4CiV7IZsEMLqBK7YbbuH4oaJ6fyiAHiBuIGyEBD9dBQ8EYAIGivqtpbFRP4hAOBtZh1jKoAQTCAABBGkDGOIM/YRV5km8+2azuIMESiDGFxEjKd3IMlBEsIAMEStklZbp1TeEJfSAhGBVhJ9jP2NraHhReAHWQs6ChNg+yKElLV5jrC9JV9kjfkaFyfpbtQCTfrKtpx0DzQPNA8cAoAkGhAYVLjSPXiPX1jYmcGHtUcrYcmv5Fv5Ekq/tm/kMiywdOjr+ubpda0ht/ccxmWfKIl9kAB8YefACEgNBwh28HvaPt+F8oHx2EbDphpElfc4uhLYrNU3FhBsOu/YXkwLcExAMdAMcegXELa7w77xh9OorOrpSQ34P5DPZAJO12V2v1l8d9USWACNyGqCmyYDGvQR9BHAFYeHSVJVBS5gWOvdxLxWgIvHXhJUbGtxgAgFT45DpwZcti07BCtVAlb3AsUJwADYK4MJr+TT5qHCW3JzEeCYJZAS1wuBDJP91ShI4lzJFLXuuAasqCYIhJ1sVo+wBrRaY7UrKzfub5nRz5J93TYDQ7MPrndCOmN0bekxfY2GlU9rPWsbbElgvbHP590BsYSzzzmR1kdUIWRH2hUBvg6kDIt1gRSSPvOjog1VrZnPSf2+A+MLOoXwfHiQKoTqeRs62f6OaLnpLmBy3nQT5imHmt2rOXhI3Jvij/ks7nFboMp8ZsdvqMjZoQzVN+Rg6MI61SUtR9SJ/no3Eff9wK0ZInRTeeqaF9hYEjPpPqdoGDLewt1BcbHwO/bXWib4WMypIUtofHR1KEtwkIKS2AFrIAVsGrpi6b9fKefbtDI+jWBBX4QswIkX2yHdvS4tYO2spX1xPr4nfhxoKkHD8SA2NXNWOmDyh95GGLbUl/cjox/IqyArVE/IZ1VseanZII0DnoFYZE661jIPvBDNFv68x/+GybfkYcdFWISwk09W2pIg8xPOLR/YQVy16fqICpYJ7beuO9hKFLygzq8HShVUcKeBZjqBEvDiL4uX0hjjxNqbKnaruiIXHO+XV70mB6kwVRjTVYSZkt5mfFliiSSBcRqEfuTJ9YCsm6BV4B2CdqHIMCIIPpJgVsjbnwQ+BhHke8BslreHF/z/gu92RsUiSvyqDSzf22c7j0RGUVVW8yOJw1A7BKx5HcgVjf5beeZ/3z9Qnz3mbWNZNZU6sc3F7jyZE0NI6s860/JVMu7QeWsPTcZEi9VZSdJguHd4IPCqcfVav0260bTbRxdSA2bITAfYBT4hNeYEGwdCkWL2qar2HYsVtiUK6auqeR9EhNa5lx5VAcb14DWRbPFykKILQkh2HQd7Z5WJofi9mamLih90yj6pKRbaYircsq7AsEat53iERyVvHXxic8lGaT1MKVT5nfRlvhR5CTxh+wXa8DJzYNUuLLKLIcRBl0rHRQStNrkC6K3YtoSgJLCas8HqW5wunjaXKTK9h8PNnORlljZeXJJZ1+9ta/r7Phq0MSe6KgWtUuxey339JevLrQ/LOUvkcc8Dbu+04mdRzkValFyiWP0ZFvjkQ7hqdvKT7BndRfHxK4ii6t1EsAwCWHTAdbKOoyrI1osA1LCNVF8zTPxCkgvJNn09REhz3bRPijPBsp9F/ob+jrEIv8Ve0b6luQm2P322wtrespaHMmALdWQMLH1Xgbe+b9FnuXgpCbQI/1lg5UqhS0+QA3AWqx5nOzVgKWPUxO29X90r5UwbC2J6y4NFbfvA53LixV7RhEOI65Qa/YTdxZc33w1IoKxEdoRfXcjQCRkjgT7T9OCJIkQney3AFk6Xg9qi+hEJJOG/21b0TbUeP2sF5HSehktLwRxLBFgpM5nr6sQfZkcfQmPL6iZ2X30pYCYDZndfVnIpMclOsNbcQGTVS2lMWZDpnMphAnUEQRLqPclfG/KsA5YecGkVothYld5BjlPoy4oyRZ4BCcRdpKpEZ1p0x8nkVufxK9An5zm0CaihaNk5edf5MTaLkQAK2AFrIZmVcgKalm3hvfxcTeanJkWzFhCs4uCrIc8G1dkYGvw8wsacINM3EulO5U4l0uC+WJv9MpTcoBi1GFvsgh690dfQA/oAT2gB/SAnnb0pPGbh11Frz4OBtKA6lSGbnvs1SAlpmcD7MkCYOKB+d4gtAY4D6sHWGXJokCradKoJmXUkhXcQlEAljXNopDffTrU2Y32yxSX84RtYhMyMpaQSmWjJaykw6yGhfakmm+QHLDio/jYbl/QSvqJPerx419Ytv3LS0kRRr7vRHYQ5olUSY1zgclU4sXv5Jlf/MB/SRpbkmMjcNqDThtv+iE1WOKLaELsBO4eCGl3BDdAaqNrBUsMmtY/H+12AJaYaxCfq7DRT3RYdaVsJvvS9CQqzWtR9QlH+GYFATVC93y4H9wMUDlcXQZ1IHPx4cyd6WBAc6a6ML36wXFeCPLCtU/csEOhYsPzI3u9e45XoUnsFRa1FDoMuNOyzG2xRf4f+KdGQ9oVUfFCW7mwAjMQLxCvVsyODnQFiw/MrqWbX1k/b8hR7ggE8SsvV8IndgjQB9sww4Ec/MDjuB6f8bgZJY+qgFANM1TyNXaYiLd3DrJU7MfnZ9DO65MLMFm/c33Pjvw0/Bz5wZC4rkyLdxL4DooauP/0szjJuhDPcP/71TG3zxGxvY2+2yyA3LDkwJE9jG734nzoPKDGduEcOLaY1EBLizezoh5xkCZ5a5Te3T+jT775CoDOAPom8jBC1QgFfhCzQeGL7USYAKYKTOmB9hGKYo0ZnRhdFVJr7lXBVC5TieJ9RNYGg2CBYLXBNGhtS5AlmWUp932gSup1GGlWIbUPQMdn2gk+E0IVTMMapCEolcw1ZFe5u9vF/cP++/L6acq9QRtWvorc7h/uFBI3aRz1yfxuObvff1dBZ4c8JkJxoeNn22QbpSkvZvQe/diLxFVQLYjb7H4Gg0QvgwRIHUgdSB1IHQAEgNoALO3oU1I8PwSXD+YZrZey5Z/gDpFPYVh4jWKHHc1QtFVSl4ITsre7X1JD1IEbBFOZ0W5+Rkr6kdJOHtkjbHReJG9A7eJ5feZBtWg9Sn5eR8bohbQDECxYAe4LlMjpunhKpe4kuFZlrNJgdW+zIKHZdEMA6yBbksx6hFA7On5v55n/fP1CfJclEipTu2o5X0xm0/13wAbYABtgA2yATTVsQ06UCsTY9+sHfIrUkt177HypZgfiHif0nXSjyTEJZbS+IwdHnfZMHhX70dKzBVYNWB1nRtWPhhUmTpvkaGqNT1fuhZtHGRVOoOAylh/qDfjgUO+z3BLLxkuq1Be6ki5yR0VLo9Zsd+XRvWFWYkvkNgHxNQX6I5YMt1wPAVlLD2UMwOglLiQfd2C6zkFioxowOs/o2f4FjOo/ojoD4eXTn2XnNtBwqAs4ptnArVsgDbhJ64RpgA17aOXgL05ynBiAqw3OskMg14ZcyQILgGsVZhsDtlM/omtsVqxPMsDqEr3UeLlkBFOqrf9WyDD7g/3+HXnYgUMQr4ZIrzM093y2yLMczJd6HLvJzqIiniS14jlr03fho3dyLGwE2GqssiUi9sV28OefAe1kXLC4BasvY+cNoCbJ/D1wGnIcnAEhDQnptV+mBzwHO0XpvM/xfwyIp29Lfbj9zvOJixw6Jyts8mw40UOmicPQT6d6eZcvNiYaTfOqdy220TjTweLK30+mc9X4CLRIStA5vD/xjvYaK3Sj8d1CwFSvLa3M7V7zTWdiQ3UqSNHx5oJw6/948VEYASXQNaAlwDINsoogWukqC4c0l6hqB3WowDhgk2E94UgP87T/eutUQ2qj+AGwM5yBdggIJsXX3ToNf6KL2QjXtMrxXV63/OIK+oN8vIatVzY9+lIK2bDbp2dHX0poJ6DrjO6wq/Tnbygyt+I2cYrPFAI7JwwZwRs7jMjuPX0NNrLfeNXBJ9rylDWYrB6mRBIHpg5GCdXROXiDPavDiaMlHRim7wZxhEVWJRcyVyh5VkroT97KJK5DBQnWD1qJSwURMPm8Li29QZ2qUAmpAJEQk/e2G/gkMvDPiCAz8pNyvV954+e8Lb0q7NzIo69BdBMgioJYsyvPj+z17jlehSaxV1imYhxihgoeYFTB7glJOSlhRGgDJs/71NvWwnYy1GiS/dUSmpRzrOtXde9PxAbL35lJK1OSU3pQhJJ2Ze8rQX1wnE42/QS3vvNKAAbAABgAA2AADIBVPWoyw/uWtHSClgW99Q0pAqshWA0ThtCAWh4q0wXYSdGQzUHq4sddswokmq+I9MqqrAI527L+0Y89CxFbXBaLcmK2ppje0fZDbKCYoJhnq9KrppXii0n0R3FwBVUZXk3F13OBsmK/tvSbvQXkMfaIJj0lUrcqL60IZdskEiR5gaV/7TBGg54kLb/8DM9oKT2j34kfBx/jKPI9obU/hcNKV1XVK4TzICuWUVjpWnxGaqO7y47uFro7odHY51OJaFmDUthWl2Xxn3D1A2KiiA20FW1R/Ae0dKR11Itlu0IjUbcPxX8TVew+SFkHm09vij54totE1mpWVtSO4fkBsFOhwKUeDhowq8MsrUv0LtoSP4qcZBUx+8WSSE2viw97YUzw32+Y0PExlD7gJWTDFBDqFtdrFfsSGBUUkkZZROSi3Qo/MsNcOPGijSTtu9Jc5dgacVe1O1VePTVwc3CUSsPdr0c9+a+OuX3x/8A/tVXG43NnpI6CDSBNZi92ytTaRO13EyqzEjYXrWd1GUmyGjZXUoYkoLSUn9Jgq2LCcZ2G6lphQ7wHXHQqQn0qZhcfNxGS1E18pp8TK7A6Jr5uDUDrDK3ktMj2h05q612xkHnOqLMxGyAAPwCzYlxARY9dhOZBSl/fZEaR1VcX0UgT+3qRIN1z+3qBNJr0vtQnlH8B9LJH+SArKJHHIyqMaYgRbjL0RKUWLzmGOw1kSz5iS8mJDTUQDo7uTGiui3HDHr0au/q6X31zS3cxPwcospHzfYtCDOy6LFcDuepKF4fb5yOf9/FX7K4wgFNhQUNECebag2Q9eht2Z3jg3A0z3g4QJ8xtE7aYfW8tcWX9aBqsRyTqM1ovfq/BANT6Wz0r70nPqjQn5YyMVWw7FjtV9qtn4Z9Yjaz5OzGHdQEpICUrqdO+6Aw08OnH+mpp5NQCMon0UWCeiWLaONDmWBAmECYQprEI0zOmbZFtquRVTe9vl/cP8/v5dLK4e5gAPIAH8AAewAN4usLj9ZqRaeIw9PcVm19scYtNt7O72WJ5QPJ+sMhiTyIo0L9TXwAHmj9oqrhfkGs7O1BdUF1QXcVU98n2NqC4oLiguIop7p9oB94yaC5ornKa+3m9poIIqguqC6oLIgcipxk3dnAfZ6ZELHmuLqdw0PM4r06JBcT94Bv/LGz5X3INFJJGX3rUKA8+PvqxF4VqlloUQSlxOoHSGUr0YdcvOFRhq7sEWfHNacmQWyp+Zy2A63NAtDEBG3aGke3ZnQSLe2YfHOfA6dfVv+qIKrtdk+PgK0QhcT/Vmc5Mh5vPtEIlxX4LxZgNF5pRDNRAgZiBJst8B/TH3T4XBebKp7NAFkf4QnwX+FTzefGBTiWdjzj6gbEHhMpjUXaTPfbjQZMMYsxCQ2RcACf9I+MMESjaOT8oS6YHQpWeIhjrcyP9C/2wisTaBjNDbTkNMzMbbkQrRhQ7BScLg6Om1TivT7EkuQNY9rM3Hzj2kRACFPuJFALH5l3Z3htybFbx7hGZWzwmjHvvONsYBN5xFaF8BwYgqkK0T3UHRieMmIZBMsN5RlzHANLlWahSWZCDztfbkRrPjP0TbfiW/K5IesztdDlfTGb77wOky/RDLRs5gVybscL2XoFc22XLj9QgWojYIHytECbTbkDXAt1/BTbIXCuZwxECcB1WjwFct7Vl4Nc1RxEIdotOAr9uuQ/Ar0sGLdBrn18L7Lpl3wK/lrm5AK5zFQJA2CgUGv5Bn+qzFxE/2MHUow3CkKsv/TjYAngtVPhfO7RXDobYckeAEGJuPYgUdu4Dvo5FbgBgp2QLwNctDwP4dSy/BAA777QAhD0kvwDEFhCfkAcT4VazuH3lKyAn9/FIeqGDBTdVjgjRC53YQxr0Yie4TL54eAHysBPm2bLf2a8qHO4rvPZoN1AHdxshvSX6RNBGHlhLuWE94dD+hUeBqygdim0LeJCLy2CVkedCRcYPsNdew9jdA25NurKZboWkYLKEyEth0J/MhBtowASYAJMKmOgHiOirvvuhzT6TuGIfs6O5iRq4DN/75sch/ua/YUBVC9U/wThAlWnSHlpEr4bv2adhP90Eu99+c33z1YgIxga9g761ESASYnLD/9PT6z7PaPRzkiPjolh5CSAzIJnEysqsS4OG2NpgKk73CXYFjvnDxoxawDq4PURv4v1J5YCBEoISghL2PFF59F0XedZHRFpBi/zNRtx+mulcNT4G6+PvN+R8o3fa3rNDPzkBXBdxfcKrePOis3BVParUKiikttnJs7VfWhmczdXX4/YLsxAV6EZmRGuVrXTJdPxQV2PcDMpgkrIAKkBFTiq5dZB9kirahQEwAKaN0yv/GD1XhYq4BCvRUPjfu/30SKC4DJF61jEYcdrFUJ5v7/n6tou9MLOlTTWreDfybJcdkbFlu+F0KojdidHadvA72p4gCgKHl1r71/71TWDhF+GSdCIL9WDRj5LF4CO0cvAzFlffRXwA/irI/h/gVdoJVb3D2ySi1C8kggOfRNkeoDj48PUrZUY/TthGpnBoogD/EbmORh42IAJEgAgQASJABIgAESACRIAIEAEiQASIdEb0DUfENkM1UqjnyvHRK1VqrxueT1zk2L9wwqeNepkOcoPbiUa6BXiax+VlXwUZhMzf63VarQrwAB7A0wmPaRMztqN3K4LRa1qDj8ReVmW1hBEr2WckJftc7CXb6x99C69QiJ8jFOGbN2rcLWFrZkLyQyowfXBaF9wzHaxXakgfiC5Ioy7549dCFQ3NSXalE1jlciiVi6ott5wKN5C+NeM0mBgJkCKC1/T+7btoS/wocnCCJ/3Fqs+otB/D8p+Sdq3CREAMiA1AbO2zO4HWafL1dhfaZjJPW8W2Y31PGh59dmqi0yBCedgTT79Ne/pOP584sz+5P/rSASGfHYoiCAABIAAEgCIA+qsQkze0sh362DwgZmF6AUU+uflBKD9xlVvqDBzXY1Y+YCokcgNUVboCvjhg4deMH68cFALBS/1Evu9EdpAG+7f+D7bj6sVHocYV45LdLVlcw+A27zmgLcj5ndgWBEh6haRtCZ0jQvTh/mLvv/JJ+IX4rvyUhCwiFSmlG8u+EOR2ndIXAilCgttHX2qwO9+HHNyW8mFjz/ou3IURdvdjLDvGVOSO5MnR1/Xdiv4lLqku9ic3b998/iHlkTv56RHqYqAQ//3Do+7s1g7GAo9eonOgzQaT74idXeCp49IKif0eiRqzTomONZ0AVHakrafWHyyxu+TnggdOc2c6WFUlFLLEXmeka2X1kfk/sU0GsPoqQ9sQPw7+omIWftyJPPVbLWiSzKXEz897EzTBZn8q2u5zUF8c33x9tt3YQZ1YifYnIKYBMQ2IacDEHCbmV4K35gNDhIPW5MqWEjRNL+obXdUaA+Ar78Cjs4F3yDRxGFJi2erKF+Tazm4s65uATRQ2OVy6Gnr6ILeZK3SgZ/5QjdBFF1UVF/4YYL5lpP5bGprsnEkvftKlEDEJplqilbE9LCkWjYXPCHqTrgFnpOoyG2weOhgy2w0cDAHva/GSwOLPhzL5nVANaL7mqiijLMZrPlDMUTWzNR9oQQBSMs6YmNZrc8MnZUyGWizvaT1zsMwM5cENFvVXHdygMX/l4MkQuh4quQWgiYQmSbRfOW5Dx/qnSuXR1upKy5kArIm0z7NTyrW9fSj+mwy4e0K55GMt4A0VBlIT3vCz+Omi+E9FmatyYkDuQO6uOsqWLPyBzLVddQBy7UopSsLtQY1hYog1PRgjVBkjCofXGxzbv3YYI+c78QNMol19fIWutqHzyIHps2u98HyUxx8xbgsHhdsX/x/PjnTFQ5/JQUGIv9hOg5PbU7P/O0HBVlcyXMVayg0/geKjH3sWIjYWViDu9l7ESkoXSuyEk3fJCSckU09qxuyVg3lYY1hSD7LKE7+Xqeijv8WhSP9Aeok6vZcPZ6FOST7ARxCf0Nxi1vxH7DhP2CLoBygaCFJrPk4c0s/wReh0WFo5Gs53VEG7zKQM9rsVIvmsVr+cObA/19Mrnvr2ySbYjHyyeyEYbE7OxvTdII74JPeDGdlvdrQDOBkc5uawKvzI9tipk8/BFhOYs+758ODsAaAPWQATEI199DqekqsVBJkOEQFph2yY8u4zANQYkKxKN9xppYKFiF5hhP61f2X7wdsEQnAkbje5kEzG0/g8o1SM0asS6RcPrDSeoVJcRLQWmiiIYsJnHGxM/+6HNnuT1mJ2pjs96yQVHh//DJBn1VujLDf4yNJpN2trOEMG4UR76LSnyO+kgtoel3NpCGujYQS7/pu2HkPqVTGnKD81r51f9dlDK2FbtwaSpg+Ok9Hq5FjRfr6JmxGLh8VjtoxUbohbkDrtREhQara4nzwcfL8fbrKcLQOosJAwgOkqXdRWanVcfLHJ4xxCLiJ0xvKNCoztbVoSzDrS95hf4CYTN7HJvUOcUFspJu2kLE0VBlaX3TPkBv8iB3iBJvbo2JYtjZ3GaUfh3/aJUGxutU7k/rS9VyAn7+La3fL2Yb7/vlQSGI91gJCBkPULbJicgCNYD3cgXiBeIF4gXiBeolYERIfL6rgUS+mpGam7/9mzAp9+pK8Cq6bMi1oK+MaADywc0AJaQAtogeOvoeMf+ZuNw9PvPrMMxWbp+meL1OiYrdgfrWI+qI6suidXDxh/HTiVum92Ag3awOQO9sTInh87xIbIjngEJugrwKZkaAA6+e6FOLBQlIyT1sc4igRuhFFOr4SObRPhVdW6aZbodHz1bE9eCABMz2AbpwYqbtBuu+eoixv0h2yYpLepotuKU2AvyZ36nE19FVjDbeOYis/ZzTcIKbGUKn5zUIqofYlskUnz4vGke4j72MJ/bjuytiUjkhL13TaxVBW7H8FGoP4Yej5xkWP/wmPaswEi2JfX0XCLrTwe7cAx41b0Bs3lkkFlmwLjXN5tsUMVM0xDpryPv2J3hUeFLl+g7hDzGaagwHAVHLvyGtazU5ncaMo4t4Q1eF1V8QHZFsUqDgsZy+plLKHCh8xe7km1IXUOfZrMpsv54uC7quiGON9IMXj7kuR+MGRFckVlbsiEnGNi84HqsnVCJjaZAITsCkIGyORCVkxBkT87bLkAQjoQGlf2JeAB/RqQkNAsugGOC2oDiD3du3AXRtjdM/pMG8UdPKGKth1suCN47fg/tM7n7WirBe+zUHG0B0SAqDsisVXL7pUwRWCppa7wD86RPs7RyM6T3k+yVD12RMwqe7dz7wRO1AY6mqWHDQSl/WicHL/fVqLG1pQBz1Nsfi6nDOvAAyXH9wCstB9NdorF9jueiZjldLIqMHT68ejHXqRCuYq5MoiGKeg0AJ8ss5X29Dvx46A+otKeHrfYfF35P5/EzfPEZ5r1x3DIXALxJ0hdi5vAtSjxmydAYQdjSPDGDiOye098BxvZbzfB7rffnmjLU9ZgssFFIr1dgtrKqbafUIRcFLycC1xIKXTzYYSsDi9/FWLyhla2Qx+UY7IwvYAin9z8IHQ2IG6300CUjky4GjJVHg8TQOvzT9OJQ/sN/x003Lsux/gpJJD4xsrTJBp1dIIx7UuNXNnlpPBvCtAAGkADaAANoAE0gAbQAFqf0ESnxwE2JbHRa3HwmJzewCqAPicswvYVEETuNRhi8gnEgBgQk40YT7P4hiPECpv9m19TYRgAXPLh2sbWXhG/IFXOFJkrREbgcpsALKcF7iiQFz/wG5Y2pp/GSe4PEAnx36+OuX2OSFoYU5NEu1JYjYsc71FtUbh98f/x7EhrSHmFWC5TX70gjkCwmpaZbFuvsgK+JuNdpUY2NF+XNFtna98C114pTQe5gdDKz30nd+aL+gGK2EsNggNWZ9NPV/a/J81P+1aDdmpHhnEpS6CiQ/p6o5BAoEn2jnCQJR06PrKMNfFdw0Se79kUDtDtl66F1yh2IiO9LRwv31zE6OjaMWOI2QTBEtu/Y9OfvtYbhQLk4XQY8gOs7AaVq2Jr27ntbTGxI0SfULimjwKwFXsWJsC2oc4Ps6FoHBKZ5fuOVijLXBuph6K58uD02CDYnBtz+OjH5RPBUM1QtIrEwjHJmOlQFvZ6Z6x2RkDw2v7Z34hxPPcZx3zlkGgYr4For0TNpO58CEz7Y5pMM4Boj5YUEeQmTwFUG4a9Ty/1xVB5ahcChHWDuZe64e567kJpTaz4qFLP40TFtq+BbDAHW2Vow0x7JSH2Rsc5C0Vd10zsUKMlkwvPmmdxwDpT/Ycl2EWB4eANMnfArdnD8pewJFu5bZpQSKWJG+2FSnlC7ExHFx275s+8tUUeQt3uChHn5KZwNCyrHr45WFa3w7V/8dP9kvcZC8Tqkqste9IQGrN1J1f6oaZs3m7ittL72JxnbQTE99fJE9Jfv7Pf/k1e4pNLRm/DaoobiL7d7hcmvJNw65MIhzxIsr1JP5ayFTN7ZKV15dUmnOjFt8p9Bo2Am74bxBHzTZC5Rfs9VEL2DquHkHfyhEM65gKlVoJGH8VLNJb++IYJ2mAg2Ygk/hkRZLJZqOMYDEUIABsBDOn83WAlzpPDT4CeRMPqRLdhNXGIDWSaMUmjT8CxNkcLR1QODexRhoFvpxXnAWBtgLykpkF/dm1T+Dajib4+smHZaOP5YWSb4xDJslFzT5ZNV3nJjjX7iffh+uarERGMDTrZj3iCOwnZDJf9N47Z7FlkrS1ilpvtIXckHE+fWUmMQweiKseCMa3q9OF/dJY+OzzoUpeS/TKATUScmVyeQ0qnyiHgPYt3RGdK9CFJ8rs807nc3KQUPXWgNeo3SVZxHKG+oj4CKDDuNTC0E4eks+hxm7d3s4EjiJ0IsaM98qVzpv8AUcL988OyKl87k9+pk8o1vgRxdOnu18LXLErNukt6EeruScW2Kp0FZr7DMAxHquPdGIKRPL+ALrUkDh2yvpBoBRIokiNYwyuhhMG5OhehkSv5dNDRJ/E5DVMlacoUudZLHEvfJKu5EXvp+/DNdCj0PaDcTEz1KJooo4xmQ5wThyxIRC9HYzGi59VzTNX/BgA3zg1Q1frWgybHXmRY/g+Pzjsxcg//OuP23uughinQVSDCfPyiXsIscliWIchlB5a6KXhoEjugz5ctdmX1oJMN7ugNq1Jau9dw7lkqpuN72ECelVUDGFFq9lkwx41J8XvPt8ZW/fn6lJSfhp1F5CK7ZGbVzFQJ2eg1my7ni4Pv8vK5IHXjoyWXZikkSUk9qxWQqecYgGYNXKlXNdXScBAjsWesaG9b9u774ToxImObU1TAGPM06xRJHLByw4aLIzSykqbVTJKdGoQXtQqBCCXCdxCw2oXVdrYGRtXS6Vvx0Hd3Qc/ikThx2V0jh8FaKALHTk+k0QeHucXmq2H5FhhS5nhiRLwkJBDZmACTpLrrDyOMUBTDYHt5PnPB4AiZyIixHE05FCzNiDmUuPQjplFicUdM4yAcoD0FyQLPkgpEcfAds6EQHG6/BoU0HG6ske3E9E7+YJcOSNLZuyoFkjU2m8Crf455Byj1BUzx5XFzi0jET3cqrOZSZ4o02leg3WmJXUFduP/Rt/AKhfjb/v5x8xprXtwRJ7TZELxJ5zPyk7pqDtgRmjNer2xn6EznMlCRx0wPzqO5dQIsFcZIVTCsekSU+HtpZh9GxNwaGzvaxqsRmtkTIIcN1bJymaOiPNa2RyfEdpgWKaB3pX9y/pT8qk+CLfLGVs/0moA0GpCuLz+h2gvp1wCkT5pBdhQ6dWM9P+K7jw6S9w4ax5jIVQlngz2cj0ckAjYHbM77fJW3ZTtVXd1CE32DKpE9AFXXgulBap/UpUzi+lVsUJpkbLjIQ5s0ApPsi72QfpwfGJ31cHRi9PekuXjQNo/pCM9nn0qELa0cYpvJLuXYs98wCZGTlRSx085SWEdkx0isnaCF8Xpt/xy1qEk1K1HfchGssUDlHoCJPN+j1smp9hbqgddoPERWvgdLfipXWXTulUqa9uewxyOaQbk4qx2tuHQiU26eNKJzfn4mj7BMpeUx0JxeXiDD6Yy8TI7GLFVhpCOo5ZthPlk0Y0KwdylPR6VZu1TgFJm3ayBsQ83cddDTgeaoAtCdt/XHr05/JxhZAk/PlI1C7hIl2yaM/1az7HpfMEp1b5Qs8hk4Ip7tbQRPxaXDkezHpEriJI0Kg8hVPkABJklaYPqQ1BjS9gj99D3f3SWXWq14mY4v6vjEq4T4LjLaV5EFStWUgi1ixwQzN8VeJe8BnEo4JSnuXfblaI/Isl3shSzBwCDIQgQolVFCXmS73LUfsVly7U0S5fOz9MPDlhEmg79hwg4iod6LRzXHMkzfwgdeDcH/E9uE9hUmC78hIDpGlMdHk4LwI61MfTVI2hSmvkAo8MModqglAhU7YcMiD4ZJ/JAO8HiNCX/fEW5ovyom/RXtQhZri5FQ2QIa12FUZuUBUXpbUnfFN2M6WYmAzInwWHHgsPUxbGwxsjAB6TllxEw2iQz2DCMDNIIiV9cRmaJfCXBqeUzKYkpG4F/YSMIabG7ZXKe02nzaCxF9dps2wnHhJjZYb3zCLqDId0cvJVpt+g+RGzjYWPuEMvHsg1Wtw619yNmF9ih3Jl/gk1VWoSLB/P0xBnUuEEovqwHoKoGKawFSLeD1f+iL1jZ91JUfMzfNpr7qb//r//3/eCP/DI5NifxH9jIPuUfNITPdq13Eb5zeTpezrPF1xT7xw81yQlvs0MBuwB91jZwQs8fwLZZ9aRkRu3WyuF8u5/OH+wf2LHzdrOxKfhNLBGGfhL7l/bvbybvJA/s0iOKz0I7flrwrTw45eFeb+ZsmiwP89r8iErMmx/ZwEjahbfPFPW1aOch7NdgF1tV8yfm6TBjyxtk9b7TwvmUxzZr4QMb/DkvetkUkfwf6iafsw0X+K/YMHPK1QfYR57fz5A/JhO8nlYv8lsWs2G6xRVcOczK/ueeC8zNKFmIZk+wvxopmRkbqK+z4341+OHYpiEnAlhNp06PvRcR3HEzeWT5VBuRF/+v/mryfcgGltFhFtyI/LmmbgzbmglChsmwzER8qpJP7yfT/ZJfyJ89gE+RtcPrKW/Yynoub3MxFMvbSSB9t+A/uCvBX+VucPiPVF67emZyGdFbhovdMdcIygT28UBDZyXRxf1cU2ekN/9vWEtnJ/XQxWZaJbH6lWmQnRyL7cFlks7aCzM7ub09kdjkrkdnp/OFYaCeTxanQJl7NodAyTKVCezd5uC0X2umiSmind6m1ay20X1MLdiCyd5P3d4sOQjthij9ZMOu8WLJvFNVkyUSZGbAJ0+PJ8o59m7Fvc/aN3bFkdyzZHUt2B6MxeWB3PLA7HtgdD+wOZpAnD+wOPgI8sDse6B3T21v2bcK+Tdm3O/Ztxr7N2bd79m3Bvi3ZN3bHhN0xYe9BZexEy+4WddTsP/7Eb5hvLPlO5Ybz/RPtklzCj8lgwP8ezxH7O9MfPq/X1MXmr7PpTzszWbRnf4kkqPqULuN/pmPYCxvC0p+/INd2eF8f8jyIP9GPr9xH/9f2HT7uPmMWMIj46z7lWSX87fwkdT/r7/h3/gyIRDb9RN8OTiTI2tjPj7kYHlR/ffRZ3NPbFJoSC3PQdPDjp0+fvhM6rtN+k5hO/ukP3+8zk2oL88d7KmwkeMyHaEaV9/A7yzFiv9lUpZJ3+T1JJ/FJfv0/Tm3iKrYdamxQzBWDH4MVpO9v2FaqBemgvkviLPRJ/yM3VMevzn+NfIOqRNTI3iaPUmJvkwsFe/uw5EZxb24fbuYPSlnbu7tTa3u3KLG2yQsL1vbd3Ym1fXd7w1S5aG4ppXmZtZ3O5nfl1vauytje3d5yr7FobNM/WS1j+09kO7SvA1s7fX/XwdJOJ8zOTZidm8xOzVc7J4ErxEuiD3aYWbDHA8HnWpIpKbU+FyW8WI+cB3Ijg84s7TdKo8zJOP/Sghos5ouCFtzecB+vlhYsZrO722mZFuRXqrVgeaQF03ZuMh/cizpwX6ICk2MFmN6eehuJd3so/gmdE+nnI2wj4afu8a0I7zhFVEv675gPcH83EeseF6vOZivpZVJc8Zoj8eXzmr38Lm7qiu/9Yjl/SHzGI/HdXykT3/m7yfTd9P5YfOctrfh0+nBqxR/KRPjUZ76bnArxpEyIbyukeFohxpUe84TOo+/mnST5/44xKdrwZScbzpzTCXNO2QRiysbe6YQ5p0zD+QSXDsnLExlf1vJNnxPRK/F7ElfnMBHEoZ5ToeFIfllTvqP6YPnWxWSDD1/URI8Ke9YN+qelBJEblOrThdcW9OpuyRge6NXdzeKu7rjwMJs98Ela2bgwZfOU6nFhenukWLftxoUJl9KiWk3LnKPFiVZNH0omoieeUUroRKse5rNypZosq5TqfnrDJlY96tTk/ayLTk2ZXzRlftF0xvXn4UR/Zu3GCLaHjgul7a352Svh1o/pBCJ8tQN+oakC+HEUxGzDNKnwhcpeUBxCJvNi3OX+5qH2RGA+TyONJ6KeX6l2gY7HkFlLF4i5sUeiPiuLFD6cRArvl6eifncSKFwksZnTAWSxqPKDbqtkfTa74R+3vayXzQLmXaSdjXbTOzZusHF3OuNRw7vTqOG8nchnwwBPNKCC4FiF0WEbuQ79+9KJOsHpaqFLhRUbieCGTRUi2mKfzbT9N2rsN7g0Bln6kqJS3HGH5tCvmsyVUoq70/D57LbMrZqeaMWiZG5wd6IU0/uHcq9qsmjqVc2nNyyE17NSdJoaz1gccDblqnDX19zYRI7JE5GMIxFsKuRpTk/gO7uN40dlQl7+kqKTc/uwPHJybms7OcvF7XJR6uQsqQc0X4hYI3o4NfyTsqnDiYtzPyuZ/Z54OLcPpfOGxaJi2jCpnP5OqQJNOgn4MyZvVDh7FHDm3sy4e3PXW/AnFbqEARXz1MgnIdT0Il9a3V+oL/Eh306cjA4VEl/ykuIi02TCAx8Hi0y3iemp59jP57NZadgzv3J1x/6Oe2tFoV/Mywz7w/xY7Jd3JZ79yXx5Mrm9n5YGPRf3Feui95X+zmJ6w+cTfZr22fvJtJN7z6bMbNibshnRdMpcH/Yhp8xtmzJFnTIncMqqZk/v2AoQm0xRPbk90ZNJy1gRP/Ehyx3Ky4qcZBSVHs6UuEcHTQGxveigahs78NT0HTrVTktSuJbBDtxjnzP7Pe0m+5UK7Tr7mSO9pJY4ioMyJTy8UFC9+VFCwu0NHyPq6N1ifju5uy9zqPZXKvXudnY81izaRqpKZtQleney1jAt0bqHk0lGwufUnUrTG05UrlLjbjtGWk/1bfJ+UkPdUmN1spx7PzmNsE5aac0lmSTme4O+tR0ZRploHl0rukIPR8J5W38VYHE7m81Loz3ZleuvApz6QXUWAUr8/NsTL6g8yqOIUFYmGdzfzcVJJc9Sayuay9tj0VzWFs37++lDeSAyuzKAaJbNQqdtRHNRHpVRXzbnC8GyyX0OlvdgYG9D36VyUfX0NUdJXNybOvSvJzcPs/pzyuXDsjzvMLtS379uOae8W54O84vSJdX54iSHa16SeJgsZhVzuHhwuSSHqzLx8L5yajmb3MzmPcvvotOS1IJNMxbMnVkwlgs2v1qwVY8Fy85a8Oys++Wk3ZLUqSsdbtnxOpQjWyBOnjv90chPK08CizvT8SkP2zT2JNmFLX2QCFPX+8jNZidBeeyPWdJupodYH75tdg05Tn5LbQ1kJJj/z6ugnirfyeWC3t0vZ8cx/Pvao8SSjoVJaPw0kpNeuXokhy9ZHocrS32Y2clQcXdfsgp8f6x0KaKSIP6kKm/yoUrnlnTy0ne88q6Tzt0zG3DP5gr3swX7tmTf6APcz2/ZN74MvOhN5/hEdYdch+96CvO5K4/x5022t8YkrXK2zpMPk4y52EulMK2mx64YrLh0to2KrZSVvSiZ7Iax67LEyEbqlZWErVSwoxcUVGx2d89VYa9js+nN/aK2kt3SiVDpmkB+5epKtng4XRNY3pam1J8o2XQ+q7NUNpveLkrTkye386p1gdm0Mtvi/oa/ba/5yfP3ky7LZTMWA5vd37NvC/Ztyb5RTZuxZZMZe3q+/2DG8gVmLKVqxsJzM+ZDzJjHOuNZzffz0wW2Sa0Vtv/4QO/5hNdsxpBmTLCWp1R2S3I1Di/fZFON4/tukvZ9/YpcjYuv4noeTY38b3L6GgtHmO37Mv1wRwdWt+oFtJdM2wuXmepXXTPSPYWFRmY3+OGqbzhJ8D3pbrUzUBglO3rKroc8D7iuNVkRZHuG5f/wGI0yc1L6iqKrvEgCtAeu8v3N4kGlLTqz25ItOqUJuIvZSQLudF6SgHt7MmxTTHel4/ZsuqzIwL2vTjRZ3nad7H3hqxb9LTTOWCRwxncn3M97W4fJU52KcpiMq+mlNaHvw0W7rtgfVfC3qNa5KAhsb1Oab1VyvagBt0e5t5P6y4/397dpAvtJ8mJ+pTp58TgkPG0bEp6drsWUJZ5MTtNvS0bT+anw35bn307vq3KsKmeJN5OFZEGO5VRwkKPeARQnYnzmdcUQMvWyi7m4d/Ob+/pri7OHey7+p2uL2ZWrry0u+BLmkTyXzcJm8xODPp2ULS4uT8LJlFLpqvrDZFrhH06n95UO4u39zaRvB/G+m4O4YFkDCxZcXTDbvmC2fcFiYAs23nMffMF2ni1Y8sWCpdot2c6zJdt5tmSbBpa3fDRY3rV1EP/JJPYxF9gSrzAPjuReUfXJK+wKqw6bz5BYY8nbFLzLsuupCu0SXTo8Sejsq7NPXvuGdOGU1arbuSvfqfy8yTNne64oCOYqctU/d0f+eWrdsU/7OdgbXttq0b9XxEbx6ExstupFxfH2YXF7f7wpfFo7OPtwT924cgOVXbm6gZrPT8NEyzKPczZZHhuosgnsSVZzxujU3XyYVizEPtxWT1/vkwiBVOaJzQ0WbK66YHNVnsy0YHPVBXPSF2yuumBz1QWbqy7YXJVnuS5YoGDBBoMF34FLXem25infrPliJ/kJhd2bj7koP8XZntGs5TOX7RJblvdwk22bLLmvYJxOL/KJLWHVI8qvp/UdfYry9LNmL2LGgYeM35ATl376m3wPhJf+uatfgdNdtSevSCfQiJhbm/0Uk70Vr+6O19EvbMPY5Lta65gitqE3PQyOKVupz1/6kv+fundvbhtH9oa/ylROvVXnqZooBAje5r+M48zknFxctmf2Pc+pLRUt0TY3kqglpSTerfnuD7oB8IaGTEmUMrO1q40JECBBdKOvv+75iPzE6yf6D4amCBjE0FJcSARRGOzkQizocaFgvBCskHYRWSFYzKdcRJHtIvLp4EPfSxxiUugW/kOVvzFifoX3ih8j/UcgKUcgMUZg+oyAc0Rgs49ATcEE4gg8AhFE60Xw8BHkZETgNovgyIrAfBABS45AbIxA0IzAYB9BDFfkK3t3aKf2DVIxJA0p745KuifiHPs0TJBsa4Qe52m3INdBU55UMGoC7fbJVmU+e2zxi3aj4Th0ixRNTFYJ2VjqnFyy8bP8Yu47iz0sB3V5imd0rR39eqYDTFjoxnF6w93MUSA47WbWLad3eBG2+IAKJ+PCil5+SZrOuG09UItkmw+CwBEjwZ2mM3686cw2IQSv2DFcJACxJQCxJQCxBRGDAhBbAhBbAhBbAhBbAhBbAiW2hETYzzCeYFLZDaQGUoP5o4biuAJvVwc7Y6cSRvTqMAuqvVZy7lrwIDs7VgY7ZGevRRtOZGfPdKEq4bb+blWgGcwVupHgZAo01aMbVhoh+kuLEwTBJB6cqiPFfYG5h7ZSY1rcSg0bKVVTJERkaUDZXeIotL3f8RDcILlOUUgHmPJEuBzgzqiTKJmEfGzNhsWvwmNUGx/I3gey94HsfSB7H8jeB1eBDxEpGN3jw47xQW/0ISLFh4gUFLd8sNr4YLXx4dV9WBgfPo4P3NoHycsHq40PVhsBVhsBVhsBvFeA1UZA2KgAvCD0jeAGEhCvJwAvSIDlSwC7ESD/CJB/BMg/AuQfAfKPAPkHlVcB8o8A+UeA0CJA/hEg/wiQfwR8YQHyjwD5RwDjFiD/CJB/BMg/AiRNAc4TATHsAmLYBcRKCBA3BRwNAmKTBKSFCYESk7ATXcNhSt1/3XxA6L1rhW1XGlCgS0W8ACy0AbfDA26Rq6fNY7GC9vbV/0q/pCrfo98CbPaGbPml6F+53lZWrzfZfbpd2MOWWXaTg0Wp36IesGnvP6Z6GLq9eVii3T4C+ivX4f9Wo4E2MVKd1eFLLkmUbNGwg9NltryDCliai1v9Gn+otvz9o5oqXMVp2fq68t/OtibySmU7Q/nrF4qXbjV7V/4n06C4PjAxZP2DT5Bv2QxhFaf3i+IrDaJB9OiZxbykG/3N4kk4/AQJJE9J6Jwg3XJ6sxi3FVLm+ZQ0GVrpCSyk0j0Jy5iX0I5YtB5R50fsPD4CNolHB55j7BU/xhUbwscKYTVC0KVDOOBCCLwMwd0WwpYIQc0PwaYXwrEbgi0tBFtaCLa0EGxpIaxGCEJpCEJpCKduCEJpCKdTCKdTiGh2sqOtng7y9754K7eykTzh3x+N/pduqxRk7ItHjdoMy6TRnC/LUuXhXRqSgFutC2/QtFRQwmqn38SEYPUHmEjKLDM0d3/Noeq9/miuiTr8ju6hzV33u553MlWBZcBEqmd7gWC5qxeQ/mpTQv5srlD1HB1NrEvTedewmPYl+YSkrLtF9vywRbl+TPeRqHW+mL5vF6pQt0vPQif6jnnO9+CHns8d/FC1nD5HMibYIeUlGOKWD33bOCciGoKT7QuLxSfByGnBxyHGBgrwJEjGAsXqbbfBOxn3rDJ80aYiqkN3Fwee19vGYg9/fBzFIfMcuQiq5eS5CKgX9HMRSCORbxuaPUovtENM9CrZmzkKHLtZOHEchD8JRtcK41fsGDAfASeugBNXgD4oQB8UIJkI0AcF6IMC9EEB+qAAqUSAPihAHxSIHxsGhCdeDDuo5Sa91HuUOFDbzZ1jsNugPE8PSqzvNGnLsFEGureha/vxqcJozmULkNXutpH0UJTPdqvkJgVn086OuETT7g4lRzO1M55/PPnqO3ogLTftgznMdrGok61JDkN06IaES/G+m9Qsoj0gq5PQ11gphENdtZweJoxhlkXvrAwozOrIt6PYAiL1gttB4bEfkIZoxr3YaYlm7qCfZBJF42MKHMNlQrDRhPDqIcjwIRyjIdhoQmC5IdhoQrDRhGCjCcFGE8JyhiAPhT7G+4TJgVzG5itGF9cYStN5rrRyFD81KCrgLuFFqI9QcxDw3W4lPeJF2AGpcgEpqVkjl82zb71rraoFMAiBc6MAQeS26WRR6QoK8ouVOY6p5d7Pq0LJ0e2/J/j4ykI9lMjraNfHLF1IZUSBJOxEB6R6dk3OomcvCJQDd6h4zOiUXGgJ2HmIPhmGm2MlOCZEjF9kxfgFeL4S5O5HjlQrtquugheMHLF9pIgcKUeSGEtE7uBSlpvhe7uY6zC6udYb5XfakPFhu7t2xeaYYyRBS2yOJvHguGwpaXFGJRM2Le64bL8flx0fXIiBEJy9gYUYqHxCbifxxpyGBheBCxo8YjsA0Pgp4liP2ec+LI0P5jAfNoQP5jAflGEEXPFhhX1Qp3wwh6EXyg8xtVdEB8LkvPilmKO7sQX1by4Z08j7nAzIoLp1JGqygzGmd4Nd6bHw8FFFjPDMq9xd9aEld9/DVoO70R37xvzdvXCl3N1abOQeWd602j48wMbUOVrP3qaIQ5Vfct9R35BWszyffsmrLVj60xooeBDvgkgX82akfk/26HIqESasr+D7fymURswP7PGpJCYzqCy7PcGlPNtqLzAzmFDvw9Ch3kdu8Gse+xPMxhovkuzYaFYQoCN4pgicnBF8/ggYeAQiWQSGwAicnBE4OSPQdSKI78Fw5QjQ7yKB0F5RdGg0K9jeu1VEXmuV8TqrtovNC0f2dB3rhYzlrthsFpKwZp+r+tpa7i859ef6AmyKLYSKZdV0kUEcOd1UbL9o83+/rZmvzI0FvHqUQgdoBMYX17lgvIbYoPhJzWDy1cN0tt0jb1LRNMbMY244BMK7aZ/sN6KsIiVuFrlM1brl5LK4CMXAlBsvHphDGVCiiucQVRxQlrFTII/FaQLBjhFVQqD9EGg/BNoPgfZDoP0QaD8E2g+B9kOg/RBoP1TIl9GhiH5S3tL70kSpI+mDU65ueUHDf1t5NJ2hpNAC5apbkotCUUBvubG/OSbsCjx2s1LYFXHVWjzRD0NKoajhnRQisICQo6N6NBN47uygAw3S9XrxVE/fXqQhvOMx25ZYm+mZENId/bolEkOVRdnwDh7s4/YXCfqB6XS98CzGO7QtDSk3x6LIDhsLiAxUS5WHVSLxHMLAhQXKAr4DqygUIxfPSI7hGxC4hbmVIQRuhcA6QwjcCsEnEgLHDT3UaUJbPkgG8YlfzXbcGQZK8gXi1g6Fk+01foPc1q5OTQDpUzuhjh7P7tuULXXc1M8jVKikivxr8hwuNeRyqzw8bnZhk9FduvTOox5GEtdK9zAIUhGHLCEhSE3LHhCk4YF2jUDYJc8issCkZ8OQhoTGICy7hlwnn3QIBmHsiBMNnPm5nB1rvaPjfNgxBSYjsM9E4OOIID8ngsfHQlcR8L8IzB4RmD2w0GYEZg+sTBoB60IE5AhWMgIeH4WI5RIRpvtooBiBG9cE81yVeWGKL+om+OentfwKWsW+wYJ/rQ6VMyuu26HDO3pNWs0mWrTzcZlj+bbGUqKVid294ePs6Fap4IXpwtS7pLvN/llW02INfATUmCd3z8bMKXnMZ3e/NeTL1Tm8g4bGZ5x+MXmG1FshE9/PhJuTIkxeuhhYl38Nj8oJReyHpNsBzbJhfB6zbGzrOoyT1g5LXCGkFcEJ3iUcrGvPwJxYoVOPyrfEK+Yd43cAxhQAYwqAMQXAmAJgTAEwJhTHAmBMATAmKbEQ8BreIJ7UrhsL9VqLlS4sa4q8umqh4nUEY5q1b2suZ+0BIFXXAJ+rC3MVpQ18IUcBBpkChuop/ccIHip8bwoVxwaT2ir7ukxX02rrcJEQ7V2vX5BEPa+fiIbbGkNVSpGwNeqWk9saVebpgIpgoU198RCPiFwhTrv9Egf5MafgILgqxno4Ab6W+7ncdMpFiuMgFkGvwQzjEGSHEGSHEGSHEL5fGChJgB9Yae+qLO4ybTGUTR9xN95saW9Hq3UCYP9awW5fXsN40wa7xvj96H6tgzN7UHYBopPW3CGiWJ+VdqdisUiXKazmKtNlV4eTaJ00oOIWSDKl+/SqfCgRtoNCPDwuR2qAIW0WDLwEc2lOT6yYotRPMU9IQZ/ZleTDAfWbzCLZ2aGJ70KX8pyugYQrJJGxI/+O0u4hOCuE9C1E7gyBf4fAikKI34hAQ4pg9SKwAkRgBYjAChCBxoIoIBG8bwRWgAisAAgUG6ly7xGRRpocGKyDkXW1VN9scIhoe9F6V8SNmX7OnrrdWm1NdTX5aUpJ+oih2MJeNZc3uZWn0wFilfRcNpH06s86ZB5sDHOV7V4WxR7m/+IOJP70Dq2/ZK1CokOPsr2+y8/bw+AfB77w6ZpVpuXkid8+s3N1AhI0zi5XGBCVOVlC1e8JHfV7wn01+ESoWiUjRyYchR4RgN8jAONnAAJMAPpIAPJIAIF1AXzHABh4AH7BALhZAPpDAL6BAJheAAJNAL4BNKgE4BvAvP8ATESB8g2E3qHoEVf5Gmvt3GzkdmnO9KusxBWTlPoBEVJKnUYuxe18SdoFiZHaCDf2iB0ln2iWu7XcTNd6WEcnENXLHY+tgnKX2RJC+yQVOjpppGZ49N3DIQNcFF/Bt4jdHf12v3kXGLqzss2qDGZVWoxZ5A6gG6pDt2wHlhBscapYmcL+OhUkRTisrCqzsbZiKqXQEkFihRlo8ynPFUHlhmT3Q5X0Pi4ke3JU/BRETYHSgHhBPigNPigNPnBbH5QGXykNIjzQufAJN+GFehKwE6q/cU8S3KTd3GEU3QZl8NIbPP2S5guTrNbtp2L4ZW8jk3SajePAapBr1xm0gQQ0RgOVN6geYDjFqlBnHZ1Ew0k4+nRhPDFDpFMUU+wB8h4ksQPkXbWcXL5gXkKASVBqvlX2ldDyI8vGptfHItrYGdvr7ch+i/n4VrajapcA04vAsINYqBH4RyIooYDZUFGAob9RPFYdBQU69zW7e1g0uxJl7GqxfdDUU0fzy7MbXfMaa3Jq7GWwx+EiSudfpW4uv+liqRXk5pqutGz8cXUcnym0PJTS1mkpxfSD61kxBNjoZJf64WA7toiTKCLt2KbFbcfmfTt2cqAdO7RPRko3bxBx6/OTyi+1wd982pDmi/gvX9oqDs+M+qx3aw4JbpvdaEOOPl2xLmGiJ9ZFbI/dG4vEsXtVyxl2L4/8YcHxLLI2sE8IdsyKOtWLZAt2nLscMe4EEHZ0zOkJsCJiEOliEOliEOliEOliEOliEOkQ9iMGV00MrpoYXDUxuGpicNXE4KqJgYfEQPsxOKdiMO7hEYpFtWM4d2NY/jhCZTSOD8WKeLc0DF/967JdklnB3BANDcaNo5G4/EtBXAQ0HuLyxY3cL2uy/90T9aC/XvWvEv5u7GFH0PXunGgCdy5Au4NzIfqddjRbC9NuJBao3UwuVPd+a8E6L2gtXN26Jwdd41Lt5qCOPj3sRs/rBuLodM6/jmZM4L/6lCeNSC5qiga2JAACulGtEQHd6DnEbOFWjdkJkouYd1wQTgym9hgsIjGY2mMwtcdgao9Bf4lBaYjhYIkhQCAGSSqGMyWGqPwYHByYII2FPmKmKgqKQ4NwFBN4fXPbYTm/5xjoQlnlrP5ds5vdbFAwDNJ8BdWIHH2nyyytIEAFChbNs7UKyqc6mlHlZt2WVa6C9KnZvxj/AOb9Kbuffj2FFzbVaT73dstb/epk4+vqaTXr9aCeFDFjoQyccjLWyoqr7zyTnAd0oepALqX+2sGiOh16Pgbm2z6GaB8NJeQuDSXk55HxfGY7+wNSR4ks411ExNooYJyul0EtE+FliB1JBYEbTtI7AVA+E6/4MTn9MQi7MbxkDN6EGKTQGATVGLwJMSitMbD9GLwJMXgTYvAmxGD3jcGbgBUnY9D5YsgyisG2EINtIQZFDuX9GGwLMdgWYmVbiO1AYy724GI3dbmLmraucKsPYWnq5o6dvTsIzed0G5IUeZPhaDY3Mz1IVmZ4TXvS07Ot/iOB81PSwZdsX1akKo88k67g6tR3ezKLJUXBPizJC10syQvPxJKI4kIk4jWL40FgRgRGoZSbEponuRKd3IqnFJvE6BiF0XGI1zHgwcYgzcUQ+xmDDhgDf4jBxBuDSzQGl2gMenbMlVx0MOK1Ygf/bVDgzRadNzxG/WtnakP/tjZ36d/ecRpYjZ1chHz1mJX5BhyAz3duiRPP9jXW1d29jEjVcWDoUkOD2UTjw5yuywwWxaFV7ejYA+4LAtEvrcGHG1cD5gs6SBhavDPxiSgYGPoU2AESlHmKwO8LREgD+PmOAAkR7oh88sbmEslxSdEBSBv4igFIGwGwsQCkjQDWJwBpAxM/EagCd0wARqwA1jMABTVQfsmQHZoUDV73Oqeh2b0Gp7R16aosDPpB56re5ZSoYt3chiKlBnEFRTQdNFW5B+hhi9KdakYgN1TWJE7Snc22k0urkyQcg9ZYSo/FploXu/qqdG/JFhFTzeRzPzfuHDLO8rttndegV2Pa4jvDmZr6JDtK2ZM9OmwsUjCh7Wr28XCApZCJgE7qNi2nB1hK7EQHQYo63IYgJSQdZmlfeomIavaBw8LO3bkOXE0wanmgo4xDAYh7AYhyWCwyAHkFi2sGwMwDeNoAOFEAhiCsKx6AISgAQ1AAIlIAIlIAIhJCY7MwiA81Dr1u1dhqMau6Pkabgal/vseNTdXhtoeCaAipFWUrkCawkEbxNVMFronOWHqwKO/yuewOOMI6fcLVN/u2zrAIYp1h1X9slau5hXjuaZVJUt9o3B2yY10h5Jm+8qWW2w0mSrVfqbM+XabcaUGneKe22dqxyKprUzXI3U/yOHLIPQxMar+rIFuSsREdeoA1WI6hC1jjJX+tFFRVb2RA8TPuWd7DhIhf5bb7Wwg6LswPPUdcmAiciSTBRAQn0OKOgqSFU0iA8IV1dAUIXwKELwHClwAOLsBYJ8CDKMCDKMBuKMCDiHghkp+xQyFp3xtWcKVesZbJ1J9vYfP2/96BCd/u1pHDiNu7JE91MEDvux5Cii64/1vSGNlLiWyPUnUDut/xUAaMEuPPKoiU0V9/x+Ag6D2sFF/d1c0AfGnkev1+HU4xmAEZbIDDI288jEBt2I83SeLhgBcictWn1i2nr3PBhsXd8CFhC0FCeN0C2unG9iy3fnTIwviBN4k4c+BNvV3tktLk6enq1U2CjlEsbGdBR5N4eA1jEUecDND0E55w7xybOCK8x4xT8TehDfnECd+MZxk4YJXIEzRi3IHaEjpTu3gYH2nhsNQD9oofox4A8J88BAWEy8hfhr8cf338Ffgb4G+IvxH+xviL92IJFkSEZxjQyhCzliEoPENUeIaw8Axx4RkCwzNEhmcIDc8UNrxI8N4E703waE5seysfpmpcF4vsqsFj0f+8bsApBwLHWDd2D167tQ8aQ3RBQRuTsOvOu3rOt1KjKQ0KTLWzqzHODurdsvsOHF3FyO7uqxFrHod0K7P7/FvTcW922PlcFCekOnTtI/0I2mif+iwiCYQLuEq1nJwFUqkltCsotDlgOCQCMXKE0LLYFUPLnSpEEk5YMCoDDI7TH1TBSPmL/ClB/pQgfwIFi2GIkPxl+Mvx18dfgb8B/ob4i1ARSXioMgEcC4PQCqgfpzmQzaXazR1e1G1QFdgLja3baYNlafOdTqMpvmw1qAwV12117qvVUmbLdD1dZA/p7MlqRFNCHcHSaVKrRz0F0vRe5SlqfqFSg5+RnlyduvJ/5PNurVQWquzOgW7khMUe7UbWLWdwD6Gi3LetMjItjdlqwLD4e71ONl6m77sqPIXu+GUln/5pIHMZWlcZytEM7asMDawMLawMTawMbawMjawMrawMzawM7awMDa0MLa0MTa2ShxwMoKsArS7MGgDOzP29Dlmmga/Uv3bKRfaNHb9zb4AOT7IbO4KEorSK7Ckp3XXdYHSQbXdPzR7Y0Ser18XqgUwpn9OPVbOlBmmgDXk+nCNhesTODDtHnw4bSrgvevG/3mDxhYU8YqQGV7e443/7BZsPzqAIbP+OTwJvxjYPonL4LcheuUYkYq+8HDk4ENtRqxmDg0eP/z0KshcYTwh8JwS2EwLXCYHphLAYIbCcEDhOCJ8UjdshspswjA+F7K2xrK6VMe4a9+ovddodkZ4HNPJN5eOl9yCUq5I5csPcQSUctFFOH8piuzY5sNNlJlc0n+vG3hw1eD7VNlVpenUarFzF6gvZUZk29Uy7eqTl53nxdTgsfyk5HYg+mRSptk4ad3Tq1saKMIqrVRprEsZ/KSJnvo21SZppmI21yQh7o2eB6+o1spUUlriI3OnE9X1v/DiU+LhoNVRKUCdBlQQ1ElRIUB9BdQS1EVRGtC4ShIdGq12ka40coyRw3KStf16a7UoqKN0uPSWl36gVFecMExVeLlecbtaUk9H3atRL6nVavfpVgxyd4LOvsZz3dritwnh35ScoN9k3UuEgu3RZQNILWhWTvxgH8IjaeJSr07ccDgFRKCuwC+OpFSLq4nEHA2DOU57riOBRGYD/6qg4NOD4AdhqAzDVBmipDUO7mmYw8PxezbL1zgzAfpc68WamGiqFadnrNMUPoA0BduvDNoPCWcUSimoMJqFl+ly6Md2lF9CZBEE/oHMwSL2UmOI4IgO/6xa3xt639fns4IgBArSaQqTgzIqGihgRMWDHcyYBKS373HfQUT9KqhUNxSZhcoKAzqOqS4IaEYKbIgQvBQJxh+CjCMFFEYKHIgRRIgT/RAjuCQT7DcG2E6JvIozEoTa+Wmy+SEsUNm9g3+6iwm6HrnLdbarJkxx6MjX1bbH4Bdbeeq6Xzqvrd2njZlBtjRPC1atOB8Fs2orqoqpd1LFW/WaA1VIYmvKDyzNzs2NBtqvPKym473Fkb1KowCllfrkhFzsrZ+/u2uM/Cl+yg6SZ7OFrCBQcDeFr0C2nrwXP/YGZcLGFextFgzLhOIvpGlueCPeV4wWfIPTneOZC8Yodg3Tggxbug8Tlgxbugwrkg83PB58Trq4Pa+KDAwXtpj4ILz5X0FYE2xmGW3Cjd+kH2KQ7amiT/bo8h+6BQnztHWjCtXd1hxfZ0ckA9XRHdfdHz8D6bjGtgIarZzrmq4fdPeDp3D00lzQpyM921AZLVfeb5Bj7MKdNtdtwSHfpuS9YyPvuiyjcA5wr9DwHOJdqOT34Z0zkwJF1SVlg2RQ4oVP4tjAUMUHGfggeu2I/gh11SeMTKBXHWRUgkl7AOwpIrRUQ3imA0QpwXgvw7wqwdwpYWBGgzhF4B+fAwb7cZSPsdugznnZTrbHDUpfZI6yoZBaVKR7YH6nu38W0pPvMs00q6WnuHq5J+GjndRAdITm2iamupuk9wP+2CvfY91TpF4PxSc6tAci2gLAvqW+O5lPnk6reDVYCmEGHsppNsS4WxcOTjo6XPJPiNs5eXQMGRhh1DBjDC33/OSwYzBtW6ZtbfoqIMGGGluyjl4gwYTKH5sWdnlI/OjYPhWA2/JU4SvgByQZ4sY9O0FDYxothWtSt3nE7c2XtTp2MWKJ5aip8apfBcDopM0mB+QaRvZ11tZy9epCZTHQJxfcn/vCgzJAHZFxB03JyLQFhGaygTMrWFzC7shajrBSBjZzJaMT9OHAi7sfurC0p+4wPi+YfB4vmQ1iHD44TjJTwQTzxQdnx4Q19wM3wIVTCh4XwATfDB38o5hZj6rEPh7sPh7sPh7sPh7sPh7sPHwghBHw43P0AnYEiOBQWDVEeIE21UBCZt3Kn3+BG/83UzHDW1WqB5mvxXpn7EbZ204xpX50oCE9oVOpHsVjkgMn/IMfMdPHd7WI+VRfqFE7n03XkjR29jIVzCmnrG8V/dt7RL02+Y2wb3OgpXS72vqnFa4ZzMSgRvCuWkurQ4V1S8A97ZX2GY/1wL1IZXYR9Vbecwb7KiLJagmJdieWmEOEQxhUkCWnfUFGH+x3yQaj8IOPZN6JX/KiyWsBiA1jCAFSdAKwvAWyBAHS1ACyqAVhUA7CoYoWjACyqAQR7B7AuAYRhYnEoRHgOwN+J6mToKX+H7dHk3kCPpjYjmFR6+P8dYZbt5i5j6DSo2IB2wHinHRT+fFXV0Bqdxk7MZKdFrjXGYZLjbYgXUBmlxlhKt0y/ZqYGYqdDumgZbDoteFU+vx55KCPZrhSVprp2O8VLHH26+SmB30vx5GISDReFAh5FjiSrJPLPIgqFkQ0dxsgyfdy3RCGfyrQiiowGnJMIsaHvOUymiRPkmEcqiXRkI8VR2P+gFfngvPJhNX34pj5sAwQ38cFo5WNOSijiA7H/f1O70aRv6j9NiT7952u9VT8pKHCbZZD92qGSdAfQ91/U23RqKKNBHG8VFJXbPlcY5Tpjcw+a7BUvc1Al3atXvc8TvWPeHxyMEIk4iOIDMUfjfuDzgZASjFBQqGocwjIcBkTQszr4O4c8JklR1fvCxKGcOOt8c12adFzd5KhYBEzOwrwJTJtQWRNhEBwYi1DLszpJaEeGtKtr54R2djJyeCted1d3ODn/uc2huC5a14bSmk6hkL0Ozi72eqnFXpe89Kb+s8IaEJE+BHFZ5x0V59enLNJA5v3lkfyT+MwJxa09WmWLe0DwKO7p2LRea1dEE6HH+yKa5/+VAKhDEQwU0Xw7gY6FFL6rdR5woQrW2CIaE84DwXkiRP4kGd22y8LjAF4ZIgQxBREUcMx44ZjxwjHjhWPGCzqysbwcw/pyDAvMMawwx7DEHEP7HcMicwyrzDEsM8ewzhzDQnMMK80xLDXHsNYcw2JzTFebS5JDcV+vs1R+OBUq+iZPH1ZF7aW5AhpoCtDdSLrAS78rSqL9WVanrk/LbpaUpqRB6tZqlq5Q+Kueqk22dHUj4m+IXkpzhUXKZx0Flh4SsTYkNZRP6yJfaV+Tc1hkIToyx9lVBdRK7XPXYwIfqWd1dVLGwfq9h5/U+b8OPqLRidE5pH02nO9FCRlL2LScnO/Zla18yszV53gvLcf5S6ocnVodGzMh2RP8g3l/wsPaO/dhLbdpul5naYmp+m4Xk6tT98z2FWpG68z2J4PD0OKAe1FCl33VLSeP/AhC20gbUSKmb1eNYmQ5RSvyQy6SINGPg8QVBuvGzeLB+OkkjL/ixxRni0EJj+F7xbAiMUTFxhAVG4MNNwbZKwYbbgw23BhsuDHYcGOw4cZgP4rBhhuDDTcGG24MIkkMOmEMOmEMOmEMQk8MNtwEbLgJ2HATkBcTEBETTx3WNvoWH1bm/XW9253epX6XzvFrNUryWTxNN0WDhuXuUldwtqeAgtDgjVKlL+z2Vh3pXd0gRm1Xuz5jne0GiqvSFmarBwbCZYgtMqvLXpK97tLZZ8jMQ/c49tyLdckvtqmAg03+UVE8S1/uBqglnIte4fk42sf8K/8bM9oTrlvc5l82jvlXhKFtaQo9KrvV92LrrE0iwtrEbaT2WEq/dI596AeOE1cIbwfMH7NtwPrTHXjm8uBVEB7BrhKQ/hMQ/hN48ARE/wQk/wQE/wTk/gQYcALGuAQ2TgL+7QSYOCY0JBC8loC7LIHTLwFDHuaDJICBkABYYAKJDAksWAJZFgmABWKRkQTAAhM4dBLQ9xKAaEzgyyagESZg00vASJ3AIZSAkToBIzV+vgSM1CjSYUXFBNhuAmw3AbaL+zABtpsA202A7SbAdhNguwmw3QTYbgKbIwG2mwDbTYDtJgmR/BMeVjtzU9xIMslWmjrlafMLBNfDn4/Zt9vi+uFOO9S/Svk7wzs/FHMFBLJdA/3U13/Pq638ikTLzwXm/0pusF3XF/FsS2c1YPJjupovEEnxV6kKIW9DneJNXqJZ7gkc4Yj/V6ZfL6SKkeYroKSb9WNW7mERb3EmyQe2Uql6la6AcOR9JJ/qNXZlqhAdFG2ZKhheVCIG2SkkcYTqltO7qhI7vC2hPN9hYlnuXiYhoRXYSMtmmWw7SJA4akpETiy1KCJ1g334FJldxI/SDnyEPvMR+sxH6DMfoc98hD7DmGX5C0YMH6HPfIQ+Q4Ql+Yv3IvSZj7BEPsIS+Whg9xGWyEdYIoGwRAKd4gJhiYRncwN+mFryQinxN2v5KdPFL6VOzS8lxaZV9unrKiurx3yt8vWzzUdwK98VZfW2LJamt6KW7G2pVftqU6w17UMp+YesbIGzoVD1Pn0qtpsrScIqpgexke2+sK/Ljer8oYBnVsPLi28XxezzTb6EwFy4fgQnmOXlbJtvXt5JevyclRQ/oLv0Mn6YH/QzfuJgD/R1FiQO9HXVcvqMn5APK8+nOvZMBRHFFeyUHy+I6JQf5gjl485CM1wczRSo2vVHYQSh04+hG5sh/2PoyJa/B2bv2hRbble3mcrWA/Qa+De+sbz+WqWeNJnt+ArH0AaoHC+1fYEiDLu96z5mmGTZ9h97qjrQwDy4UKvgdliHbjl9TQJOpOEyLyTxc0P7uDRdu5Rhg1rIpaJDOxhPXLEdgrvT4U5AGxDlegx2DWMg3jAEJ5S/QCkMKYUhpTCkFCyeLH8F/gb4G+Iv3otYpAyxSNG8wxAqSP7ivXggY1wfw9xC+Yv34oHMqGLA/DAirLZ31azM71Skxqb4Nfumk76u06/68JPUeCtHrWC5K92KGFPZhdHk5ZW6S306qj6dG96t7guFg323fdAtKNB8SRfH0/djtljLc95N4N0O3brefi+EPVay4DBZWGp5nPQJ1i2np+/Q9glyEhcvtCJEXnJGnXqWhTxUdgCbtEMXQrbv1Nh97wSUHbwKj8MVRhxfhNgXIWJshoixifQuCOipA3VXoJdiXbTp563crr9ulZaYL+uWOuASr7xb6fiqjbr343Z5l7VHUPcdRUmrTVksXt6ltARpNfccTFiRt50JwibeHrV7RKKQIaxzkstvEJ7D/pUwO0WzLgvW9TOx2D4lfVKrtHNB9EIR3qbAIUCGzphqSZYnOCTZcXHVzENNz0NND6tZy1/xowbZZxh2L38j/I3xFw5DDwEpsdyl/MV7EZAS5Wr5i/diLpaHgJQeAlJ6CEjpce/AUGubQtUO/O2dMSHdFhpZ4jFXiwc2edxxm006e3wvJVhIYFQSbLYsvmS/ACxcY1HCPys1IJA/JoJ8NEZ7PDA/yF+d5K3bfk8X2+w4ci4dAm9JCroi6CHEionge5iEdGwIYRJSLac/Bn0ikouElvaZTb2cEnGt6GW9SETSowse1m0QOgHl8ldHCbce2m88AtD1QBkzle+tMxj1P8EEWqbHqXQApvxyma7kliFPKqK951IOY6/vUmZ77HUR0q6auuX0lSSYDYWcUIaOiIW2+TMaZv701blLOJWZw00TOiMjQnaK7e6/EkfZOjBojyE6gvwN8TfC3xh/4WjhaPjkaPjkaPjkaPjkaPjkaPjkSDgcDZ8cDZ8cDZ8+Gj59PA59PA59PA4RjVr+otEUj0MEd5W/aDTF49DH49DH4xBrujOMD2CYmMwwM5mp1GTEaWEI1MIQqYUhVAtDrBaGYC0M0VoYwrUwxGthCNjCELFF/tryrRgWDv1GEtsHRWsvXLZZSE14t5pn39SJpw22GkbQagBhFi/ipXxlMN4v5GFrdEopQn9Iy8/Fl0vj2JYXodL33SJ7n68+m0tv0W99Aa9kLl3e32ezTXMJQkaNNQpGzrNSNx7Jopbp2sWdmqZese+470RmkyAarosKT9AwJ6bl9PUdfBtzyffJDCLftsD6gxhTrDQFGyGZC0eROJ44LbDJCfiSeHVUjRuOFMuRYjFZSv4il0GKRYBI+WtTbHTYIV3rmW/UzryooyvkltbXlGyLEEedXpqCUGJFBfSDXh+9yz+kG0m0jZzbGk7Jxs1ooFweR3MGt4Skul5jrzoaIsu06c7bI8YsCVzoQqbl+5BdMJTsgkGKa4wefZLsXIAfTqhFHp/E8eEf5fgQeHQivIBPVFn0Dw1WeHhQifTay3jxiPeb0IJjtjyEdb1U4dXUprebu3Kwh1bo9rZPJhEbnrEqIka7NkzL6csC+skwgNHAt2ODo2CYHOwp76UtB3u+Sw522j7DU9g+OT8yG8JDW6eHtk4PfRse+jY89G146Nvw0LfhoW/DQ9+Gh74ND30bHvo2PPRtYFwt89C34aFvw0Pfhoe+DQ9lbg9lbg9lbg9lbg9lbi8+NBuCcDNm9/LMeoSzqSNTghAoKeNv+VxBbOi/a8Mr+vLNQYZ/QLO5sGPUX8p0nstd1x1tIVVfj+kuIJzibfNvypS0yeSHBWyuX2/eH8MKoM9LeZ3iA722HtKVik9u2X18hdMwjAn4YRLSCD6m5Qz+TU7krQuf9G9y2/FvuvYYgY3ZLZeKOyCvhCOrjwVOGB/IKTrBIei9EvFRnhDUTQXqpgJ1U4G6qUDdVKBuKlA3FaibCtRNsW6z/MV7UTcVqJsK1E0F6qYCdVOBuqlA3VSgpCtQ0hUo6QqUdAVKugIlXYFZWAKzsARmYQnMwhKYhYVQK/IX78UsLAwulb94L2ZhCczCwhBSKDCNv3gvZmEhlCBDLEGGYIIM0QQZwgkyxBNkCCgof22hQMQHBi2hOKyCD6/KYp2VCu0fuYWy/YL2W8vm9SXJQ7SvCBCE0nWFXMhENwF7uVzNMf3o3bwWu+t/KEeRZjBKAoFLv+f/qvndIktLuPYzBFCnZX5ckCKUPyZZUnO9K5OoHda2zXmThO2hAsfC4Y7VLacPQkoIpE8yCCmxvUjBMNsci2NOhiaKyAv+FDqwf5w/1kOrm4dWNw+tbh5a3Ty0unlEpdXD/bFv5V5UkXwdr2x9taa9lijfUK8uNaa8txXAW9Zk1O1wBBVhnSEyuqHT0q21paL527W2hNjLlMScpqSz2Lg5UYODU7gXqmMvrCEeREeRH/qOYqHOA919nh9NRna10KOOci9AkTpAcTxEggqRoEIkKAx58DDkwQttgjrwZAN0O+XxrKVi+cfPT+o4wgjcb+pam9quyhyAbvH626I02DaANtMMptJ/8G/wuvY8rD9vN5tiBYiyLYAaNWBZLOsI/mPo8BFi/CkybDd0C/ZGnt8r2LuHcM3jKKRDak3LGYKLbE+TTwcX2Z4mnwwuSmyUuTByoMw5vKrM6VZl0Z/PssRR8OUo+HI+mmVJ7X3MO7lKV6pAXZOPcrHIZ5+pFJVj9v92Tu7++nI/dNbvIS954q9kVWVePLQOnC3JcW/Q3vcjuhBU4qoD9VcKKBB43IiQjxVQgBbTt6l6cp2vtR/akb2pF5idsSuElOzRjSHFqN4Om0+SPbY69wPHVlctp9/qhNLCKUMqI5QWHgyLIVVeFiKGlH0PYWt0vx1DKwHDugMswGjuAKO5A4zmDjCam6hyeKDfDmQj4OpXgA5m8hHvyyz7V6YSjrTTbiP3vdVvuyJ6ZpvmT9KYoENNVQTb8TTnpjXSNBAnfi9rMVaQtUOFqZCO1K5bTh+24wkiEYOKUYs8QeRh8GEOC5FwktBC7nv71gEJT0FoAAdxlETlofnQQ/Ohh+ZDD82HHpoPPTQfemg+9NB86KH50EPzoYfmQw/Nhx6aDz00H3poPvTQfOih+dBD8yF6eRjGTzBUfeUv3ktUBOAHinJ5dZPPs7u0/LRWac0gqS3S9Wu5VxvLwxvInfiELWjSM5ExmP1cuzPWi3SW1QKhdrP37lQISnX8+O959tUkXKEF8rZoX4IkDqM+4cAXUqTEmY87eLMHqdDtiuQje/RCZngv7Jx5k2R4ZaAk9FxHr245vb2QKEAQkKALIrLthYJiCRakG9jTyPwNHnFHZhZzBp2z8CRn71FFxaVehToWUjhHCudI4RjwwLDuPENZSv5iGA1SOEcK50jhXHiH1hd/j/vUHQZnIsbhUMWuEPaCNnsNe9KJUOv90RhJ3tSVefoXPmRqvG5S16rY5PdPN+Za2TKi3BxvDAHYmZfpTH6AqqDlZrJHV0XELJsuOK/YB4dABC4cAnEeuTkgSoWTQeeBnVjJ+aDAG71IFD5v+Kcwj0RHyc0JmPSxzkACjDuBKNoEtIwEY2g9zxs90u02r4++1j9VsGgn9eq6Scpo/fO9ga6vw0mPpqMd2ifR3j0C/agfvebvkbqR+EHCHR583XJ6U39gZzD61BGoOvaMjGKQ9smUHkYdgbGjloXvLlh1iiMwPK46njzA8NhD4RRDYeUvHnvo2+bo28ZYPfmLxx76tjlqrZzwbTN2sEutjgf9+ck4loGEikV2YVZFy5XycKrhQY16qUtGgFvgMa0ah1s9atW5dCM3fmsWuARU3XaZw7U32bqO9zHB5ze5JPm0hI96BAWvQSYmabfT0qXaADFT2lQb7IFFnICE6kDb0C2nxwsTRPAdRbVCEMF3AwXXgHk03EYUOQ6/wAm3EYhTYPCER2ZLYuUshuUzGNbOYlg8i2E5EYblsxjWz2JYQIthBS2GJbQY1tBimMDOsIoWwzJaDOtoMSykxbCSFsNSWgxVCPkbj5YtiQiFn6Qm+iEtH/LVDRa1MlmStRaqcHDelCkeoYVUcusmIxtrS1XHSjUF3K5tJan7S+0OJDv8tjZDXci9J7XTn9OjHB1QJ/PlslgB7D5J13Z7r7ZUwHpy7fAgFknBoRc7aFu1nJy2uWeH1JFF8bhnB9TxcJg92BO02y9gfw63nzjS/Y6ZYB5KsQwzwRhmgqEdT/6ibRij7Zg3mvvdkNOieLiWO78p5qRI8IPas1qWNThXU+1K/O1NbQnuxrvIC5criG2ZH0VVj09VPqMPyk5TL5AlifuBLH+pnCiWJAN1xCQZqCNasFRRGJGgAsyZq+nMzTg+NeMmK79IKuiAWB8Vn+5jRLmPEeU+RpT7MT+sHCuRpAxy5JXaf3X0CGYi6ot1clJtTjW98bBrhFF9WaPCHUEoOsb85eaxLDabBZnH7+jTM68kXt+8Mtw2GkWc0aRjWk6Onc0SIgZMkKRDxIANUwz1IhHmlciB8sicoZQs+RMCumGyBpYfY1h/jKkCZH4UjwXoZvbgvD4+bkyFb/nS+vyZF9dqy6KXAY6lxXE0ouv+kbTRaesmPDAR9HAuvD1ADuPAke5gWk4umqmUggGVvU3uQceHmAxLdVCLZNOE5/85TI7HRkaiZuShZuShZoSyqPxFkQ0NIx4aRjzCMBIfmo/UON0e00prKrWdv/3XC1yubLZVp5HsfbnI4OMazETdvTJ/6+bqOIoChx9NT62WnvEx8aK+8TGI9wh9iVnoCH1RLac3PhLoiIKK8qKwEYU3yITPOKOhhH1P8D+F/+3Y5FmMd/Ex3sUPxFghjhjvdV2DgeKfr9+9ky/98GjgG+SlD9mmhMJHR2z+yji4qf3fb+ySQMSjnv09HF5JOk54EtNo2nXL6dNomX2kxJSGEtglSl7GfJglTy+TnbLiM4f9XTjlLHG8nKWl+kVWtvUU75V/nBsa6YAjHXCM+0KXhfxF63uA1ncMy+cYlo88Rf6i5R7D8jmG5XMMy+eIRMgxOxeB1eUv3ovZuRyzczlm5+Layl+8FwU+jgIfR4GPo8DHMTuXoy7FUZfiqEtxzM7lsR3O4h8YponZL7g15wqNu/i8mD3eGozRaRvmUNseWjj88oNuy0xHq1StPrXNcJk+3WUXMEkT1l/fCLb+zs3a/q8RwpVL4RhOoSJ1SD7RaeqpYihztHUxPomG4wiHkfb22l66CKGLziB4Io67Zcgg1THVtW/KGGbzN0tFaGRuy2DizrNN/FOY/QF86iijBsIqM3RvMAwgl79oKsTkWobJtVjaUf6iqRCTaxkm1zJMrsXKwPIX78UcA4Y5Bgyj47Amo/zFezE6jmF0HMPoOIbRcQyj4xh6IBh6IBDITv7iveiBYOiBQGx4hiCX8hfvRQ8EQw8E5j/LX7wXPRCYVC1/8V6UsxnK2QzlbIZyNhN2sr8Qh1YBkGuro1p+zdJ5N9plmZYbHWFXZ+chB2qQinEAwuKzLtYA0Q9ptnIPXDzmKhdpaq7DlRrwUeXTGhk/n/eyM9oR62ZK7TE5hiEpxkYypE5TD/QG+X43cm6v/AzfBXysW04vuYuhkrsYKrlHFupNIMjgG85cmvCZUW+OBD72UGDxUGDxUGDxUGDxUGDxgmisRNsKECAxWb2GPjXBb1Ays8ib/EBVoeMiWygKRFvsr9vFgr+p/+yV+1Co48U9hMtJdRgnPYKiNsAUKHpqN3Qdfizupq2H+9AShNo4CuroljMEsoUDLa1BONDSageyeXTSOjNhPd9bCQ6Os7QyFOAx603+4smHAjwLw7EsrXKb3poTC1x9ty2g/fa/X39J8wU47PBiVSPZqD7HkEZRLDY5nYzea+smwqJW0smQYnvQh+Au+lAtp6ePyI7S5qTVNbKjtHkyTPCN6bwNKT+5QB2c5TM4/xPSB6q/DNVfxNSSlIFyY8jGog+kCb0NGwDvdaGvGbGsdwl6QQRZDfXd4H4fQSrb/CWeVY64Tru5J59FgSWfBXuIZ4yOIalbTi+e8WhY6jjn0cDUcRsLFGF6KPGMueyq7urN7CSe76NIRqB4JlA8EyieIS+Qv6MdKYAj1EHENSi8G4210BQ1VGCdt3VYCF69eMxmn++Kb9fF1/ra5bfZYlvlX7JP682xwpikkx0pQlZrr6YZQli1iYjvAfUN8VbOKMvwPFGWGL7XV3ISMj3Ijo0WyTA4Ib1MtnuCea7yLs6Tx+enMLfERwZHo3zOGMIKYbCA/EVpDWGFGMIKMQTzZgjmzRDMG7Od5W8yWnC0ic+aqrqijU1CXfhgdKNp1+5QNV3eFArXQS75fbpdoMrTod/6Vk2vbROqGu3ndK4QSKeNRWJbtdANzaTHkK2UHuhzr9XQI1ZMx+zCX+9TljTR6H6ElKhaTn/kJQQOL2mRSAgcXm9IAcIk4iQaKRe+68Rzkirjpykfw46L9sITzkcDBGq/8heDnVFk9FFk9NFjgmUcGWI4yV8Mc0GFC03l8hfvJWo3MXGoX6PG8uwC9dUJQ50/lFsSLv1zC+kGC+PMf7wtftN8QO4wqaXdZCp2Rv31f5t/frq/18GYWTVL19mvm+VRUTNf8uplBUFuFGX2G7vUGYueA4PFE294ULOIeUgXODctJ6dOQRRKC6mjVBCF0sJkmKc/UCU37KM04cmfI2EhesWSo3ycGMuMqGsMw7+BceMv+h0ROZSjc4Ojc4Ojc4OjcwPjBuUv3ovODY7ODY7ODY7ODY7ODY7ODc4I6k0OTbI3BQdNtlBe6XSkfNZcnGYY6Qz4f/UljezXvlY9rWa/vUNoMRM0qkA922DB6sqV3KYb3UUfsHXBctWhDrlG8eA4+s7vkCM7CLzb2gWx4T3oTUnfe6Dgh8zlD9AtZ7BhxkNtmPGhNkxt6CWSFlwo+MztmTzeMQmxMRVE9D+NF20t8MwVeOYKPHNF6I0Vba0Ezp/T2WeArlzNfy4hlEd+g6p2zL1eLFpCL8q8FwrrNsejclan/6jaadkmhXITv9ebey8C0nUN5R5XNYDXT67Sh70uPdxarPTaxa0Nh8fBRUkUkrKrEEki9ouDOzDWWhDUQ5prfGaZaxizZFdvwm1kGuYIgwuwshIZAxS5CwRPINylRzz68x0Et8m8V+wYZ1oCRx+WOsagyATOvQR4agLLk8Chl8CZlwBLSODES4DBJHDeJbCoWFcSMzZYmNgJDmyQ681ENlWXuFsJOIpuh8kUc/imU3jxXtNDtpmqHFbz9nSfO8TefKZTpdIldndCRPxUPewzwyndeXcnXYfmmaHuFbtxd2qAuKcmd8rdA+Jx92JBOvlpBwcie3QZEO/V8uATPjibOGRJEpF2riCIkmCnnYtFPfYjDmM/RBQuHdTe5z123VXJeS3Oo5bHZjyhQygXbiuxSr86nO0QIvlxJ3YMR08MkX4xBvqFRBGNQcf1Cx3/4uQcnfYO4+i2bIrpP+oH34cU1AfSpaZKihTIHr3U+j7wKBOTeLi3UQSeT0uypuXkeU9YmqAfkBuRMemWJBvHxFFM5NXTyNd+lDgw4mKnGSnxJxjCOypJBMdpqYhckkC8AYLhJcAMsR57AkFwCcTAIcRqAuE6qJonYH9DiMEELGkJ2CIT+NwJhL4lwGYSDHwLE/9AnfTFLSz3td67BH112jv01WsBlO0pfryKaNXUIY9uhXjRbZZSs5SyTV5wt23WinzrtmxMdEH38qJGjOw9w/0ilTrvyvmQD1A0We6K6ayqpl/SMgcFm+y36XQZwk4A72otteJUbqknyQTu03yxlYtC8RNHn+7hiuVQOoerP9QuHYrIS8jayKEIpdjvsksHLxl/yf0eP+Hx8wzFXOtwlDggSuQQDMViJ6Fvs5OIwJz0aMhJz9vzfA3V0h7OSygU46NyW7BAkvwF21Tk8bFyWzo2Y7MLIdNqnx0+S1fFCrblMn/A77MiFVhXr24Mmx+IXgwbH3pqhn4UBSrfsLfLgyhgQSJ27nLe2+W+d+AuJ9HqyfKjlhjZwvBuyZG2/QeBWij7T+zQYH1nPKgfKEDwP9FeD9FuG6LdNmKj5XHp14CdBcOpHI58tddOXxQrRR8kG7ebuzJhGPdgQtW3HcjBVY4MwcFNyxk4OIGRRpa3tzAkbIA0ubFtiTCMSYFQcAcHd2NzC1VF8vBt/TadWSbN41g46kUBJkBFXjzatq433UE7eovyj3tL2+09j1yvch+bxHwPqYSRWg60eE7wzLH3tI2Mwuhq0f1NzQmxxE/sOlkBCTEkQrGv2h+p4f9Mcgnm/wWY/xcRCEIH59ym5exx+pBvHrd3aJRv7cN99rdcKrDkTeGLKEsctcudvbq+qZD3fVPC30c2EVTyXMh8FnB2HtkEQRf7sglp4hIW9nsYEDq9ZeSKQ0YjXFpVKBuPuLuayAQDmcfd78FxcniIcjiycsyDReud3Pv+YbGQLy4KMCFXWTt/vEsMZncudQ/cCw9l9gAU0bq4L+83465BSS5X1S7K6PXp0kXUgz+PJ8FgmT0ApYY8A+qWM5wBCFg6pF5imNhuJ8L2i2TWo4s4oOkickU3OoUbXyeJjed14sdVHQkwuRL5m/JBy1+kDQQxCRDEJBoPQxkNT/M7BTEn/2k2p4Fn7FxQ8lG6mk+1fqtwTbrbenpfysdamcDHfSnpXi4GxGfIlVplM9jFOhaCIqnnOvdcKr0EyT1cKmDboQPwm5Yz0FZE1BuhqvpwCz3LJ7ThgBFuFUG7VRyQDky4IZUnUBl8THfuccWrAoRUiLxwrOJVuPmKcv2YrvaSo2pL6TpdZ6USlMjdvatjL9I26olTjO8hT4ko9Bkj5SkeM8HOs7cRJbcPP0zCKsaW9hBFhDxlQ4bzyBUW7wIf3pFdIiY8GVkrDo88OjAOPsA4+ADj4NFQJ3/xSME4+IixsY4OtVumm/RbsSqWT2p/NqU6p7qcjexvNa0BtAMYtxS47rYG70M3PkAsXVsY09fndbkM+aBznfmvmiAad4nnj55qD3JUNlT58oXjkKE69BH7+8aoPdwJIJ3RxihoORPxEdnCtOJuJQszgvRsysOIb4LwfIe73kl2wSQ+zjWpkdZGPFcSZVwdrShie7/ts5G1ADY1+VNU3AnZpes1CHyv5zXw4+EnieDcYYUSGE98js3MiKwNEkeC+YO2s2fZocLAo+F5Q7531GgUKvzjMbf0sToIYkoFiCkVIKYUekPkLx4qINdJQSoZ7SCB2zuKhqmENlWerlm60OhTpleDvjJdZPMHU75Fy0tljTC3r/ZRblfTu2w1e1ym5WeKgqgO/cOgF7kF5VvCwTq852kt1qKgJIlxF51DFouJeJWQDN+ybFuIFGSdCJF9JESc9Lz5wlXVsC6tSBCRPHLHDR71j8x6CrBuaID5vuhJlb8ojGE2VIDZUAFGZgcYmR1gZDZizspfvBezoQLMhoo8NlrWU0vlRw1/qPav6W2p47Mbg4BxmABtQPaxKRmxTssKWqvtQmUywjrWvWeQZzydF/N96FOhzkzlJ53KD5W3ZEyKWJ/t3SvyIPro2oNr/gaBx2NBR1zqFneQWThOxCUjvC9kjQfmW/BJBMl63C7w4PKVe9G+yNqh749NsUemSWAlDvmL0dqY1hSxYKw0CaQuNJpVedW2mmUG6PfHertme2D/GrrQtDkvZqQKYzd3wQyDnvkgmIjhIl/gBQ6RT7ecQ+SLxbBAEWYjnlKmMc4IWPnEASsv9oXQFkKFXP2ZRL4Yj6UYj6UYj6UYjyXMsw8SRQ+jmZ0xCnBblvBpWpq+3qdyJ82XWUfGS8tVvnqghL0Kk92n/6i0EQGPFdxAuN8PkQJr8TNdrYoNHhgkWe3o14vECg+PxBIh96KQNhDolj0ILDmUwCK7coNPWueYFXLImU1gNkZ9qIwBVCSWg8C4O2SFJaoKwJ/J3YlgvgGC+QYI5hsgmG/kRWNBv+hTpt6LLVC+NpWNoCd9ycr8/gm20WqelvMpLCBJIe5+Xb9nEvT9noORIkIolhNTVRxkC8dM5B0U0he+TAX6/f2egU0hgrShMQJLl0hW9awzKMbodsLxyf390+3oMg77kMjviv0VZSfMPznOmIaHDtbYwlhj+cvwl+Ovj78CfzF+l9mxAskxalEx25q6DOokKbN/bvNS7pyqlaiqmmrjhJq61SJXaIOQLa1r8+16kcOKTh8bPFvVBE9VyoMwLT93rsOZNp2VRQV77z6Tp6WK8T+QWo2lfgeh9rr088k7JOpNBtsFeRh4IRVN3LS4KbSfD+uzQynU1o8o9cgbEpsWWTbBmDZnIH7Cdw9NY6+OQluKPDt0+DDApAG7FmAnq1cmWYbarL22zi7t71Gvu0e14kyIWQEcF6SYZVqGB5UdLmbZbpghO5TI1vb6+5PcnQ5Lm+fam8ceGaPvzNCPz70zjURV+yOnUoh6LB4Kqd4DFAeJODDklp5PX226jk/f34PjRiqc2Oa4QeA9IxONxnEV2HHPp096YmIigYMTerkdEszDkK4orJJHqEh3ZwZHEE7QzD3mBg+PMyT7IP/4sBY+SD8+CD8+nCk+xDL4YHnzwXLlg+HKB9ESYzl8ULB8xOIJBR/XdrxOy00+A/06u69q23G6WNQtlcK+kSLLdJE+yV+MCdvoQuBWg8lrVA3g9+zeYMgHgcXV1zCX/lHkchsRDcvtZislMzkkfjcTYqBb62St+XSZtxO2OnT5Yg+esJISVKWiHZaQkVk6kEcc3bqRap7yTLZoP5mEQ31IUSAAAYCg/abFaYz2RD/jOTw0pICAi40TMqbApv2I8iFZYQXc82i4WMnhHApR5IyQFv4k8U+Q9XyMWQ5LAmFFICwIhPWAMEQPqwFhMSCsBYSlgBASAQsBYR0gjHbk4MhD/wNHA1/oE9CXg2x4L97k6aJ42NZYWBetvXyTPRitqX35Q7ruXwLIrdeK1koayoTs2gc1oTsph1P2TW4S+SLVzr7zbCMVuummWCtIv+c6LonX7vSTeuAMdT65TdYVAp+orbXrpkot3LTNGHbeMNURTxW94r2+9SPlS7D0mBxx5x0Y0vhYbKp1sdm9fLUN6V5eBVY2nFfOM6kKy0fSVd8oPkl36eFpx4Hfx9Me7GYPvSCKyHDeusUtHvVZJI8OFY8YoZFGJAi9JfLHfEgKiVklWy2NmCOHxHdXaYsmwdjS0ZFudiyVxcFfwcFdweGA4eCs4BALiShUCM3KIRCSQxwkhzBIDjFbHG1NofAOlI5e/LbK/7nNdPVCeAf9zzeZsfUUFI9rkIUAncEYm9Q/p4Amqvb6Ml+kJXwA9X3p4Tt8kWpH0Qxoq3L1aJhEgVXW1q6O8/qPzNUFcZxMOSSqQ/YN+FDtrNnRBYxh8+LrajhfaWWebXZyl10dexkDQQ+zn/PhGIqSlYQBWXG7aTkDkwkIJCaNKdPDgeMWk2EBxWUiO20A81KovAHfFRngLgUThRM0Z48qiInjoOCwog0WfcSaj1jyESs+YsFHxLvFco9Y7RGLPaJUi6UesdIjAvuoOo9yTQ6GgpM79qYpkNhiPdByqfY1yXQ67V1pqtOiRKi2rbt3ZwXYTn15otPFkNe2kspcvpL6VuXuNM9mur6Ts8vn7GkKgkm+etjRS2HMTfNNttzRC7dyWzzs9DLsK5c7eEa2G5/zdin50x764bqUzJWMyG01dHlPjBCCbd4TKwjGv0xAUkCUOojiYXG4vk84jUMiYSmhK5sHkbOyuRe5Sx0cG5NEV6E9Ki+cgzPMV74wwcbKCodYPbn3insTuId/TKr0PlNup/l2ua6Gb/BSHuGruWQIsJ6gMBWkAcTdrR9E68dWEC3/K21+P4mGpTPxyErWCwiED6LKhx8mgo6g5Q7ZPnZHTATRRLBR4/HEcSU+OBA2h8hpDl5sTLfnkATLQdZAbztWZ8bizKo2c+iHBxb2ePHGiLZ1iRyoOazgDzPACL3JH6RE8cJhEq2yJeQgzab5vBPeB/te2TJVYcNG9keK+FGnsNa31xJ21bTJ3TXbbMt0QbWCzK5hRDMDZdqK76iprQn1aKCpTONzVA4fD02c9/Avh12z3dYLq42Dfljt8FKKHtcngQXeaFpODt7ICS09IJ0YgUXJjIgt9GI7sJZOaNdgFgQhO3X04FgP3Y1kyVm3UE8/okMv0rDiHz+iNo2FADDa6UdcE1hSUDfg/QDPERgWCDccheYfUduBWBeOZx9G5IajFQ6QR90/wKQnT7xNK+52/bR5hHgLUxBAB4/rMh/LYvZ5uikzKfzlmGi40v3IhsnsMV/MJQ3I+zP5D0PtVmf4N9mAgni5o0mJ6mSHfwIndrdIlX+9AWzEYYRfrbNZ9Qpj99PtpjA5ASrv/guMR8G6Ptu9W04yRtmuXU5yMNr6n8TfQWWd0XgwnFvSLqFm27WL9SLZbCIJ944x4ZPjwiNfY8hSV8xNXvHwCFahEmYw5wUjJVW2zI+qQq2qNakyZVRwGDIF+MHIMOXohB/kNIh6p7CTEeH1R2VCZQpcCYEAMK0GM9nwDk7gAgxTyl/LXX6lNvkbs8cR91QuAdlmcySq2wTngKAsyUVaaW+uYSfzIZNPkDARB77M7vNvclNLVrCqGp6x+87KvnOmYtGfv9ckf3dvv1dp8M/fXkdb9wb4YsIQnx9C7sPezcDcJGeY1Z6X514fC0JOq+19ZxR1+fn7y7q+R3+IpmXAQtZaZn+UpmUYb2+GA2m12G7W242TndP9Onzcj3plgf1JODiJKvQgy5FU27wkeUbYGyuJihEhWPEQWMaYUNoiyyGjF8ji4YlwqGzuisAqGmhUFu5bIe57MHBwrIDSC24VFcDL+ViR7VMtjamdV+cSNuqUaqi3qLtHPpcbsTBuF7oPbn0ISsG3rvIKuw8nKLmgab6SXEGKaCrW42GblvMyhUqJLuoacFOH1BKs69MitWQP82AUeUFMRTs2LW5Si/uuiQP1qsDO2QqpcEcW2jlb3pCUEr1EtvPTd+FF+jvqRBydsEi4JZJXLD6c4iDgA+I9INwD/MEQ7AFsCLTJGMtH/IiuHvCKJliyBrDxAfde/g+Q8JXkQ6QWx8Pg7+UTfyzeyq38EeC+3q2uwIhY10KD5ot0sag+ZvLs0gjwt03/uo9C75JLegGHnNxZWG9Y9gBzqiQKHRQPfd+h46F6U3wsNq/v7+VtOOcNeCVMnzdISTc1Ib1bIdi8JuEeYwHb53aldno7QXOqPoCavlb24CqsVD5rLmEum9wyxcokcuIlyFTT9VvhCZu/d6yaOt5Vf0RQm6ZlZiYsVounIcuqZQToUVcOkHqYGqUaPoKCUptKzphWOBxQ+FMlV0uPOt/nA7ZfTecigYfIvJwkNCQK470axmgh7u9prUIAv61TJEsng93RuRdZgtn53cgSn/21tFH0QQ6pjcmEJcmIcIg2apbJ5q6hC9WHhzsCbwM+ukIaveJHyDMMs40w2QhzjRBKHZHUMVMcE8UxTxyrX2LxSzR3ob0LDV5o8UKTF1N1p7FuJpbB/FGZARjHaplYLBNrZaLiyu1sCx4M5sgXi3z2+bLe7DXF3z6twaJtXX+bSl3j6h3VIkemRroCStkQDa1Lr8vsNZL2pxbbus5SuYdUVb83efqwKpSnlaicQryIZmxw1Sid2ovUYkU77nnMFoCjV6qHWGRD7ilbTzxFDS3/krlWVN0IUcul8wF33bNzMvszqVvv5fV0nU9LKbzKA6M/36Dbyv1v2/movX2jb4WrzsfcdQs51/BTQgUrqLNwu9l1RLh6dj3zvi/6OKKDK0MCQhSjAg+bFrfgzXqnw6FZRpGNtMj9IXlGIiGc8pY7Qy+Q7ZOPfZdL3qnkesd6JcfWckEQAHMt6AI+GhzZaPnbKIy2hdD2psy19mBkOqtDurzLH7bFFr4+CMB9Sc3a4XIMEAwVGcDK7UFSOmpuR43DHf26/kEuWA8cwUsGgyOI2FcIuFbWnmk5R9ZeZPv6fTKO17OBeQmS4jY4glokwkMYevtC74h4Eo0ua0W2s38PogK+Ai5VcAGAHAgOALAOgPkfhExQ49H2L+XnQz38qD3q7egsiGh3mqidW+uf3UZlucGzrJou86oCkJLalJs3Ct+u+yCCXhtYlfY05KaHYj7F1xvSWX67bGredFqs5f7J/9UxeVN313EENRUbM/Nmu17sfEqkXK3CmptWRT3Qrlsfs3SxeXxCPyyA+SN01xJTuZ6/WfeBMGpMSEPva7UHY9O7XN3oZGtUry5TS5Kgx9Ri/y/mz4xsTFhBWsK9QYhKNk9LEpqnRa7S627jnDcJ/NHVR/6KHSMoQI4mpGhChiYkaMrvBgBzwMghlA0M/lAZBMKcQOOGlxaKxxEpzcPVvyv1Um9ha77RMXYOTkd1nZi4vFrZozr13VDgqXxYyf24lpKF3BzKgI0pns+PY5xq9SBQB1675IaOIeeELVEPoa3pA+9uueXqEfLVfZma4Kts6Ej4NaZf882j8qhitQSjC+aUm2/QWGD7wz1YTfVmnFbbfJM9P4g5AnqvA/Y8OKva3+v5wSQL/5IXC/VlAFZxVpQlhNJAFtjQZ+lyz8YPDH/twalBK5SKM9ej7lLrnF17Qae8F4TC+CQJBoeqRXHgqDNsWpxc28q4PzBUTSlevVwPEqUrFIPqDNsJZXqRCChv5ghC8d0pt94kGV27Y+FxVj8IPWOg0DPQBxArk4HSx0DrY6D2YaE1BvwdA9cZVhEGFs+AxzNg8lg1gQGbRzhcLAHFsLILFnbBui7I7FVVFwxm4cExVr/bMstuMMhL5yu0CBrMbptbDva418jeTOpo3fhrUXy+amG9Kh/FCtugqtKFovPF07uHVVE2ZhsY8k0Lxv/3GmG1tnfVz/VWspy7dPbZtMCcHzSY7OWqzGePy4z00bheT3N+9beW98yNGkCg+mY/h3MAvaR73GoC6aZ3xfxpWhXbsgkCIRdd37at4Cs/ygUAV1GlGZQppfnM3eYdEXdKu50OGEadLsNGaG+PCTx21YV6oDviNFu5ohsEH+1Z/Bz9mwfCg09N1r9319bUjqYFHP+1yrMq9CmwzwEDOBRl9gDb2x3jSPXqhjaGYdALbRSDQ2ISkfiM9NPXLcMPFe/AkJjITuPhVNWhJLISGfwBxSH0AhFhjcyVwuMuwetPknD0EyV4xY8wbkC8Ilhp4NyEYEWIZoDjF94aAhUhThGMqOCegyBFiFEEAw1EKEKwECw/6GJgZMKKpyG3U5b5cCPItdyx13rD1sRYgOtXhcEY6IY1pBPQ3Lg9hKI3yIKopr7fAsXDeintCbp32Bj/g+9YQZh2c1cdSLioMvfdrbTr+lb5YpgLOB9yW3fWJYA8zAzvGXL/dvV5VXxdwXPiOQi2V2PUHXK/sqmAHiGfYeCLVmi8QfLIv/TKKex9d2cB3COADWyRbWRnE7U6nOd+yf81RUbgjpOyuvQKQ0e8XxjaH5w35vtJQjpn6pbhAYjBYdyWqCpKVuKx5HcyYTKwy0Lj+tgVdJmrwpszANGPj60LTfBaboG47+WxB0EaAUMVXij3xwJwRwan913tTNEGkArL3CJDkJTTSNcqB2K9ztISMqWnkJ+F9HufLvMFBHVLMtkMSMPowBvMCxV7tBPaoN+pC+SJkQ0diSRhg9XckDHuk2quaTl9RpaIhkHthjaigSDCdAO7xKiX0JGDHndVmnaWrOLxsQV+xsaihgDdH39QsStocBQHFtx9U8w+Gsdhv5S6Tl5YpaAhdXIi0SuASladXDUA0FZRgcapTcEl4LL5OPp0zwkLYW3CBtNAyKT8TZ4Tdcvp84uJim1U8KxdaZ0PSaxnjPbhc5cP/2SQof2ExCPLteG5QBT2OLBYW3+vmScYtpnzaqtkLVXz8Gt297Agd/SOjt3YlIjzLm/noWJvw9TNMPESkrnXLW51k42jboa+nUcXUZGLiQUaIQLChhlZjiceJozUOKVs5JCCEr4jQsVLxkeriY/Z4z/Cbgb30o/Ax0F1xE1vC0PxodU7tGMY9+H0cbNcdPLOm8sT+a0XNb4n2aFROKz89W63+ZAeSrRy9Wkrc7Kzysnf3RHCtqfZao5haRRZw6XP6xxW5t8v1Nm2KeSeV0Uz0BgBkd/1RcFRVMFxm0Cz6TorNVEkwQR2mwnd0YHjYC1HGaMJ6qlbuILKBQNofSlRao8K9zFXQ5U3AR2RQFqzhgnCuXdj7ZpnShBbb56lqoZDq8nDWkGqDnKnLIy+1O/5GWxxiCJUR349gR2xMfLpy+mXB/k5V8UWjzuVNq/YX+dwUWDGm2I9fdzedUPK5MViUTw8TavHdI209vPr968/Xly+mX68vP3bp+v/VoAITfHY1mEmb81nTy1/V7uxQjSIhmfByj0WrTq09cEHl9VQDSy3pCMpCkEgOpo0NCP8A7hrtklxI23S8iGDoV+8+k0qSdWrRTZ7fHV1/em/Li9ub8DWbf6o60W9MlU2XgJW5eJlcf/ScBv5VGCFXa67DPvWYz8J9lPAalyICjiO7DxdqtMEFCo44wxjExP5Ci9wJ8iXhMgMCOBtvcD6UY4xU8Qg2Z/iSP9G/osM5t8vshXE3s4b7i/XIls9SA7x0w8vMTz6BRQGBo3pQ/oNIQ0613J4EPaH4lyf6SFNZ4PU0JrCm/hwL2xJ/Eq7H0i+bYDdoaydXoT2HYYFl+k836LW/8cfCr1vq3YN9k8XkhLUg+OGhdWGS2+yWaq3BceT50u2KGYQG103wN7+mpbL7fo2n31ugjKLBYDjmWvc8/7obCz9AfJv/9N6yPsFbM3V/zWX8FEb/RRvkW8+1+vS1FvWYiQwt+uaY+njA7b8a0gRaW0CsG49lJI25urjSyIsEf3n4e4/4YCR/8XjTX6ksqK/QRP4gF+/WkNNKGSCnkH4R6EdzvFinc4MOwhx/kVRLB1fqvVxmeKz5tOpxd48Svb6KJdXOUBxje7gVVI8wFGEW0zbU8Ln/JqXWeciFoBep3NALaunkvQyRTnB8Ix/bmH5UDzyJskf5lhYYnaU+hyt5f73i9pcqBezcTVGSiiG0dsdGKSGoRFZQVC1IkJ1D8wBU3aTQHdBM6VpR0s0/u//vIAH/Joh5Bw8zeMWg7Pqkjb4tyZZlLmkipfWS1SBImhoAistLmAkKbmpkCG9ge/zeWY2Y2uC7viKTew1gUAK+ZrP8dP/+wWElqkdU7+UPJWUqMoNm9YPUzfI/fYHspdl8zlQUFdJ7GrLYJf2XvDi+ssaUpDUld2n2wVy+OLzYvb4nzz4/6Av+4EL9S0xg6tpF6o9lmuhAFl0dlq7i4ddIrB8qW+pRLjuCMkPsTYeqFy6poOvOng/JIo+89WjVG821hDM+yGI1HbAt2/eCtiPFHZR1H2QRJStXqZgDVYHzMNCV8ybBL3Px/vfL7S+Hy4rim3NdJtc86qLT9eXzVNG8BXwQf1QQLan5K/4Qq+vL35tdYukcoDdAs5+iOVfSuq+/P9vm06B0J245EQAsD8RCtH7zbubi0+/X15fvml1DiaJjyMKHoKBNFBk99vH//746W8fWx3ZxPPVYstRYyl7xWo9S8Uv/v3izacPr9+17oi5ediIyYf1zNCvr67ev7t4ffvuU7uzfBemniPhACc/0SA+V9eXN5cfb+3uSYLvKDkBxBRPYgXk8e7j7eX129cXQ9b23ce3169vbq9/u7j9rf0xQn8SCLWAgsnBJ0KNfXH96eZmevHb7e27j7+0Vsaf+LFeb/8HXz66r9b79vKm9VnCQC6desNAfhYfVnLPpW4xumd6Psp9uKjZXiUFLi2nIodEbFAsYKHf7BHCeFvnHQdTChfCUO2qczumymPBbaanU5DaILohEzSTX7SPUTWpj8Bo/8eYAT5IhpKvF4ooGMrzwHX+BkzvpsPbGu/9ztMXyXKdZXMtuQQtFqqORnjWlxhEpmWObHmnadJ+8P+4v49nnvei9QDttjRVbZK9Npd9nzF1GV6l3T0M+0M1iIjm2t/Mw06C1tWb1iuRi+RPvN1L+kmxdyPT+eqpP7WZvjoGZlm6cq2G583F/T29GmJ+76m2zmpI4ZGpvIXuasj3iGczajUEuRqeYzVCessE9GqE9GpgcEB/OVDqXi/Sapm6d4fnudYDPjexHrA3VFpUdz1mcpvR6xEQ6+G71gPPJWs9BL071KpSu4NaD4HqXrop82/u/QErQq9HHEtaisn9QVELrAZNLSGxHsxFLWg2c7AUYn8Ix/4gloPj9tguqsy9O4T8j2t3xDGxGrAW1GrMZpwrKuqvBidWQzipRVCrEbh2B6dXQxCrgVpMui2L0kksvj+b3d3RywGkomDlepvDvHZ3OThP0yQZzjy4YzkimpU6mEfk2BwxSSy4IMbIbpQDdRy3ngC5+TxdrpUUJXUqlYdR6oqoqmrhH23h89+9/trK9KWxL+Fnru0FngInBziafLOdZy0Jvy2udp6LtweI+7czTwl+6/XCeiNkHbVaIrX8P7SahH5n7L1OV5n+p6nxCv/+klf5Hd6mz3SVOKvMOJti/bI00OE6RwYMu/A9XrZ0Tq2FvKxLELTNgy+0QbC2MoFl72VlkDiM8e1FbQqs9OWXj9u76sXfjfrwbnVfPP/Id8VmUyxfLrJ7hdn4WHz9hA1K2uq+Bwz70mAu1vbaltldG8JfKkGnZe/u2Lq1MwHkmy959lU9skZS7T6wsS44F9lITYJ7yqSwla+zqvQGVNED+Mfr9+9pmUy+k9pAq+1iAUO8//TLu4tn+kInlCnfvL59/Vxf2Qf7Sv3n8vrj6+eeA/WkP7Q+rCxFH2rDxc+ffvv45vX1/7jkS8l7fn5S31XbVszlyrJ0SGEovbuPlEa6RnPwi/8I2EyKBLi5FCaUlhLuQmSK6Px58R93mbib3+FbLdK7bKEwuuUsP9w9/fDu1SdsuZH60OWzD4pRrL2nxGsLRfHtR8Lr99uFEWwTMXc8ww2Oip/z3dvLi/+5eP/8kyzy+wxt5r2nUU673qNslZOptYbyE0nu8dReMPrZrh7BRoJfuLFIvX33/vLGYXXNVMFZvf9viwep8P8AtPiDcWAqLgwjXl9efbq+3WcgRXg/IL9TTwVD32zvml138en9p2t6TK1PaWMk3P3rb+/f3+zu/LgFEwx0vnj/242kimfGXmwroA244cPrq92doWaSYufVIsd6wMosZFwb/26+yJvLjzfvbv/nhTIhahuwtoQpc+gmW+twmsauxLRRWD3UTWP3bI2sX+uHt5+upZJPjd+MrqxszfhSdAna1tHmxG5NAIv8w6er1xeO5/eUeGBmwKOyPQUa+uEz/C0vM/cMf3t33X58VfzdzBDunMH/oyuIdEe/fPPL5a7n37H+oWcsVkYWao378dObyx9uLl6/7zx289S+e91Z18T+c9kRO+oZfn598d+/XAMbfva74mr1JgDaek+PDCzgh/fvfvn1thmZN0PHzhUJPPU1s5vH/H7T/4xyPX5997Y15ksWtx7YPazXCHTESl/8ev3pw2trreuB+XMrUYt1xFPjKljP3VoMvuOp/8ADTdJmWvvW/10bj/6NIs57PZHxTMlLV8j/6ktt21TNPhfp06+Sp3xQUHmaDeSzzy37VdP9X0WxvC3aLhI5y5tsA8CDLafOSsrED434jSI1MjIQyV6q4VExUK4DeKTm6r+UQ0aKspAw+kI7ySDBu6RFP3C4SZGozThrw5My5Ss5pKrtwDo6HdW9WzQJ3PK2QfDv2rqqI9eUebVnQO1bSDsmUNvGqa2SYL/EIAmIPch1aBwIXlBF4PoXZVK+NJblv5uIABUnh0b+tjXfmO1bBvq2Kf7vbXlLvX3HPWWdN1/SxVZP1o42V5JUIz4pmenvnS069I6G5+gn+eE/pWyljJmV3ia7n6wRpNrSU/9p3L3qJ2jkqUZKem5yLTdpYaklIfXn39mx4Qlm4o4ApRPdupRddUkbAPh65A2Xr1HwIRou9TZCEkVBvNEk/lfK0HOjAXQeT/0tNemZEgYwIkjBIrf27t//wIA1NQZoBu0x9N+7xoAunTE0JdRj6L93jQFdOmNoMmpOZ/X3rjGgS28Mrd10B2ou7h6t91aK39TjqD+bETqMqXsj697InDey3o28eyN33si7NxpG2L67dY0aouadnc1Qs85mP9SXmlEsXtsZpMd165F616nh2l06Y/ZZdz1ov4EatdOnM2znBKjH7FylBmw69EbrHyGtIftN9LidXp3Buz61jlLXb6GG7nbq7jrwvnX2nb5AjYNt8va//2F8Sa3ouF5cXBMRp6pU/qQypl8gWudUwwtCH9ayI6kAMxU3ZoK98HaVNAp0q0cyR5CWEyAGb1pPBJl5+lqTsRjo0DG42ntgdbH32It09bBNzXmuiojAwvwj/ZIqNRb+ekpVjCQA/emrKpZQIf6YKLn0QVkEVaCYyRjrNKomC6lOM6wNBPniOadi/epYwZZBhbNupIgIvH5oiFqa+uYGJUwBhSn5uQYcq6XZGsAIF1u+6rR1xbwVpsG0ruur67sF1dsRcoiSubyCIbY6XuQPY8drAP1RPHrCxEJlIGjw8X/CuJgXb3X5AW2Yfdcsk8A0XZ17geVv4XPfaKj/nzCPU0WnG/w8k8+EWw8eHktioRYA+/X3ulDBT4hs9eJK1XhRdvb3LXkFYavf5joUCz7XBywWr7v+AsDgWnV5izHGalL4+7aUBAKrom7lWMRZFWjQs/4q/72oB74AmaYwI1838CTKVfYewc/r3jfbO9i9ysWLPhu5up9zHehlLKdYacw3XwOVt0TJQI8FPkaoMYy2KiBE+UrlSApkRX/Ku6dpPx5IKhWoWEc42jzfLjFVAQOwAYHE7EMsPNPUwyAFQJ2cWCm0GWyJ/bY3DOPU9XZqNUOkqbkXSB5k+GW2uEhRJOQB1BGBIr/blQaleQFw+HhxCx9UFdCEpZINkWpQ1Kwq376AbGG8uigeHlTAM1eDSg0IgkJhFvxbPmS6wmplmOj2vy+A+hdKREXs/f811lqotoR/pw8PZfagu6hLtTiPuEP/2zEvMjXRuizk7sNXYWpcldO/fFjijQyvKcAbueJggWVq8DpyWi6CWoNyUf8btD6FNKT+brJrP2dPX4ty/tOVqYKkHm2ONehh3f4O3LPaPki+C3kKq+xr56PgyZPNiupJNi+7WwEF5WwNgY6rWZ5Z9mYMeG+xR/y72swX+Z35q46VhWVA/vcCoprNTsItWM4ecwho3paZtuyp8Obuc+IBIjd9E2dc7ZjETFBHQuer+6ys6UOdT3itxB3rIxWWW9jMzTZXbNXo9/r16iJzd0VRbVp3S3KArAutgKoBkMhqB49SaXZEWPfsuRcmBOaHVbaRn/nzD3Bq/zA3OCKyQZ48a6i8oDxNExhEmZCnbR9XC3UdODCmwEOcMaJboNWzdWjEKnoD/iprU3QdiK690sr6Wl8Vk9DHd82+ZTMVp3+v+My/LQkBw3p7Usv/Hh29/Wq2yCfrp58wQ+7H46PBX7mTSceeg0jD+8mVLjXKrP0yhT/1C72dYAq6dtzpJjIZkyeYwVnh7hxzmTp455irKa13jtnqwlrnmEzLVCecDeyyy3SqGfQ5pqq2d5KQZ9rsd+LJTr+Aj5vN+izLJyUtKbWtTjkFnrY1UuspZ8LcNi2TTaX0NuZecEK///Qs/vZZn+A5gO+zPgyNID7yU/Rxdn9yApyO/foWbvlPBH70yJP2ocR+otCazjIhCQU18uTP1Dv76ZniUud+lOcKWZ39eQYWzTr3cz1XoOvcz+MuBjbyw9jVMX96vkbhd3mAbgnE7/IIdIXFkZ+mgxT20xDEphPPPgQLauSncBQ9+8lVKOpcc1PFqM41N13w6myzE0W1zjU3WbjrXJPvKg52rmdwFSAbW7CiAMd/2gXTfJ7ZnUDQZ5y+DzV9nqmfA7M+z1Pshss+9w5sA3KfZ24H5Pd480M5d/0U6APUvpbGAVR/CaK4+ijPUc0epXL+Cv38MNl7qTIsTjLy1SIdSQe1ntnUuhh95J9b2R6jD35jMjRGH/kSFZnTrHU7mWP00SGcYXWaBwc7wWkWe/6QgXh4ssHf1hhhow//ugaAep9+fTc/yRy/G0/xDVgjdCLe6LO8aWKMT7Lti9l45x71kU8+wWl4uo49MYfkSSa5qHEMP2hn+mlm2a6hxNBp51Cpnaec45Rjv3nz5kqF1uRZdVpmcdLtegmgVvPsNPzuulMy6wR7yMSY3WCc6CnmQKs1DJ+Pp25acygYy+I0ghv6zOuiLxo5c/RZcqikoyTE6awssJzmSSZSmRwnf596fAxHPIUEual+utvmi/ltuj3J4HllRPaLk30POQ1uL8NNRpObIOasiXWqlC46bqiTmaQGkYUs5WmNt3mayTQgJ9ZKSsvsJHNg9OG/oO6h0qbl2gEmxknm0k4B+S6nmmHzmEFxRxNffqqvArFt62Lx9LAoNq1wNwUcLTeH3oqj8ejnJlbgxeNOWs50fF+ZzYEzrGZPU1MzFKZuUULdrjEzzjK/2bhN88jzGn4ye0ybQIFxd1Q916xYAbEr5+YScwCUcgZx0Nvsw1gxF8/OeNG6/CFdn2fSEyyoFFK36+zUn21dSkYDY5fb1XQN/u/RF2wpOWY2rTOBp5K+HosHqAo4Og+Vs4L3/lU70LCJi2l8u5vRjDZmRh2UN1vkULYQ5DZTVqRXJlB1HHfy7UoVOjBx+DD/b+raxzHp7rnJxjM2mMm6xwJMVceDZ7IDKBE6y+3E0yI1Yqnn7DwTPmQbRY/nm64P9F9tl8vRLOBmaitQbkQTvpkDYzYy9Noo9qz+rWI5tNqWj72mdwBnPgWscyjA1ZEvOhWERvyKmhR0rmmbOlowZiPyuDuof6590jCbupBB2s/YhN9KmIS8dlBJ1Ua9lefI7ejsOy/Ht+d3xx4vHLA3sKrZgVusDvxV1xZ5tRl3xuYQr9MNy7azbPzFc82IHrTzTVf7vhRQxrjCCmQfd2Jb5YVRA2ndU51SJLImyytVReQcc8F5BpH4aLc5w1yL8U8xlTeJs9XJk8pTqv+43o59oiCMCBxfWS0UGHFvk34rVsXy6aQTrkuIhTqJ3LHKvsrTRI6db3AVP+LfN/Dn2KdyOwETpnor/398VlXJNdp0hbgbuHQ5uhHFNV1dNKycT+W/p4vF8hQUoM0kOKXOo5bkp+pYIEDDdlOdet6O0bQc+VQlUjh0+sYJhBF7rqsyL8Zzzu+Y6NN6ky91qsYNmtXHnbJVraqZtHYr3uZjM2hyvrr098P4Ah/uSHDLteYz9hWsN7Ic0wNci+KYhPqqelreFYu+GIYXL+pr55u5tq+o1pNMrHOl1V8t32KNnDP6jKYKXpvN/lf6Jb1BA7rKWDkRg3/mCb7X3L8U32vm62313Vb84uYxLdff783vnr7X3Fe/Xp106i/5v14BgDo4DtfryT+qnx4RZehiOQc57dST5at8cwJTgD3Rulj/fCJLFzkZVBHM3iKGz8Vjvj75lBhLYILPLkyZgbNtFQRmO/FsYOJeQsWi6ip9AiXpLGv6uk79utFo3+daVP90L6jAEtB9Bxvl5V1a4tT52N6R5+css2XxJfulLLbrc08NSKwnn3ORPhXbjXpTsJFk5RmnBPZ68ulq2w9u3sqA1p1z2ods8z2mVbaN7NwrfKmGOuu0YDzXS1ydfWL9wqefGID515XeUciTfn56Nz/jtCq8EWd+WxbLG0R8z8fWrohHwAJCCnRPv/6lKQh17rnRsQCzfyjOcBzZL/4LFBaWw13WtbbO/AwVcLPR0NX2mHi7BlMNvPd1unrIqu/w4mf77miNVh8cFJ0rrIR5ns9NTv07wNqfbep5XgGq6hkkrjKD+bBs2v0TKiZpdfqjC/zlsvsKsg/wFCkerrPKFJc/9+z4gc8+6warL519WiBiDdl76ql1IRKjuvwKQcKq2sIZZ1ZMc8QUlGHTnkW0b80nmdXvefb1LLzZXl0jB53964KOeMZ9pVS3l4/ZQpJVVfOO93j55LNDiOomV5IovPhtsS5u1bWzzg3E/L3mVu99jjNq8yjvNaR8C3+cb0pJzeef8fWXNF/AyYBTV+ebGzWK87wvVil8qf2RsJ0M7v7ZZ5YLfp1+Pf8Ly++8WNTFDKrv8d717GefXJ4b24ezzwo2EowgyL7Lcqupv8fMryG5LftO8+PJ/H03unpzY7C4uLk5+0NgjO26WKSb77IBLuS8D8VJfXpm9m3+cpmu0odMq3T38vs/vtW1DM87uRKK1dw/p6NnmRDzf8mrl1g5BL95ZZZ9li7OohB0pod6GE9X59GpOxNr89TPT2ef9ib/19mnBfayOQdZd182/ZLJb6tDek9PWFi1tXG7Qn7Yhal9eu6JUc88+cQaQLWmpDfq79OrttlDtpq32Rh67bbn8OuQc48NlHTw/BC28R0e4XyqiT13CagzpVQUvsPc7/HKB3Xh5PNDIGrbngNqWbHI9An69D3mh1pw6HP5HpNDqND4cdzD5j5BttKQicGbi3DzPz+NH3VNmS+NtRRjFFbVtsTj5ZM8XRbpU3Xe+WXLh7T85zbLlLL2vWaXsky5+W6vPp/nZ3l5ONx7x8xrEyX/PSa/enyqvtPUZ3KhEzNrWj9BJvde84+JfbrHA4A8ea7DdQ1OGWSyUDDpPC6aZs6zuOCa6Wp71xnnnC2KKjv3uqJqfwXQgWcRzusk5zM6zTtzypYzBL9uN7la3jrJ+TtMqTA5zzexLnb1JrtPt4szKJqzvJxt883LuzJLPyt+CMZ5AC7/LpOX29U5lCxq5hNkhpKhomiHfbl5LIvNZtEY5s8TkEFNP4MYozPwSyVa1YkKWtQ6ee6Hmb8pDwssbFOszzwjfuKHB4jMwGoA535hqU68XRSzzzf5cjsmUu/QJzi7WgmIPS/ldb36oMj/nv/rPMGaramhdnoJk58hn8vx6mdSLdqzPujg1LdFOWZZv6HTK7EIVv3SVOY59+vD5L9uz7vXJG/fFMp6cj55tP0AaKH/HQuof4/PjtPDwmOO5llIfZu/xONMG8/w38rTeZ4cMWp+7SK5PY9uQD0BloispO4HoBHn2IRf8irXyGZGQ7kArMa1vLzIbjQi8+m9ZNt5Pf/b9AzbT094zqBeFdbQtVRD9ON5khGo2YHiTzC7Set6ZYo7lXWBAFOX5iSy3DPzIrSk1XKiR7Aq945Xjef5ueBNOxdPNLECie8ts4K4OY3fa/fMl/f3o6uiu2eEhbYaRnuAPj6+3rzjYyKbiQAM+S5bzR6XafkZZoHs+3ra008HQSFnnE7XwlsXp5/qJJ+rhXNebrBg7smmmm1rGDBVnqP19+iT3eeruSoIiBW0s/lUH2KIvgaNY+O81kD9BsUqXa2KTXqCahTtNV0Uq//H3pstt5Er68KvcmLfL7VFa3CvOy/Z7vbe7W4fy6v/ixM7KsAqkESrpgVUSWYr9O4/EkPNJItUYRBFO8KWUEXiQyKRSCRyaJK0+tV0T0ZGo3dWfUNkqh+psQVRFpobS5X2LkdcW5Lrq1mVRieFlE+sd39fFSV1BCAH/wpYoVWdVOsQZK7CqRO/je29utZhAUX8u6wDQFUZQ0MskJCllPCZkrvNhunlrqyGot8M4AVzchelWQq5f+WQVPVbI10xiIfGIktoQlLSWLmVdqXrCVjuW+sOeOqUG+O6V0+n7R2MB+LLJ7tnDWMit2YyTQlkURrkXpj5gAGlEHvA82UscmgOPZiw46qGRBaKvJmt1PlV45Qjlcu6vs6oCx9VbRPWlub64gJ+kvlB5c9Tl85WufvqchHVQaL3ZOqueyUk+q2Tj7afzXaoffL65F2DRr916i6jDDaAgOEcyT0hWJb8AxSBg4FGsO2lqQGJHGaipoWovVZh6LRP3e09+Tsosjuc1qOum6bujL9G13kmMgnr66aq26GHkzMaBkoWM1WfrNl9/9GEnbMchwoCKousMktGutJ9BWP4sZFamBPWDNhS2LHbZq3I46Znpgs/dpps1YDc8MhsWchWg+n6kJ0mSxUbddNkCnMQgH9pEAjNlYZ2ajAONNsqwjj4YOLOmzQVLXbKIQ40m6+O2GkyVShR/GC/SOKOVyYucZPx1Z0toRwqYllK0qVkoG7rxCVGtNVDPG8VcNvwyEbVyH6r4cqRrYaJC5tkkSyjUAm7IFb1cDY8Ml87sttmvICkmUrDmoP5WXCp69srzm02GS6mOP0huF2qqXkWbTUYLuDYajBdt7HdMvkKEDtj3NJC+q0TX97zcfBtOMD3KC41Z/Yap+2zqXpAw8ScTzPBE83aYc0W25U2zwJZXTSwUnJTNVgquTn4wEQpSzK1OObH+rQgIT8a0QL/kCbxVtPE26s+Wa8wiouVKhbWOnO3ntipXTnUbrgiYqth2r5WuKT8a2EGW6Mcap/aA0rYtVu7e7dt4m2wjOOWrtRqsFNtcqjdaA3Ixq9mK0A2fzddArLdYrwyY6dpYjpWNWNri3yvzcx2CK5dyrEmUaelTpPxQpCtlok3e2k0bAmYbpvxIo0mbrS2V0zsNZovmthtm3iUagMKhf3rpyiKhA2MpEtpp2r8brTj+lTR3iqH2k3WT2yJpm6bvYqRvUYjXTePPbLJUmnKZoO1an3dtumjN1TUb2Pxtlum77E5g/x3AwEpVYW1pkjqNk7fr6oG1q4e22qavk9xXx6orARUWpGbLYaCFJpzaDj2YzjGxl18jbN4F3PxH5KbKr+59gqtmo11x3C8CHKaZQtpQdC/WYlv6baZD9FoNUzenb6OXyASl1Q6XHTbLAWI9FtN+fNqP/nG9blushqhMv2xbHyoytBDa3ErQ+324liYjSCTTpPpeJPGr/ac/gcf2HX5Z9Z8/ofaLcUA9FvduMUPPP2v/+VIwCdxBYVVlKf2P//P+bvZOX8gb2M4qcq04K3XvCnCSNIu4CwTYtH+5uwC3ubfQVJWvX35hrdBfn815gBTmlH49qu38E0x5DdsR/v88/88/hdUaOZfi1TD9SV/tUzv0uwBfp1dvxPfuoAycLQMC77B8eZ37y4Am/CjhbfewK+QfUId3qHt6s1TNSQWzNeBACD67H0ffLwD5Lz/jY3v47/+Pzul9yxlmNPdNTKIkL/tpCnqFP2zm3RVCmKV6/Y2RDG2nBFSVcn9F6L20yLdxCVUmP6U0dBBUqb3cQyZI74IGfS/sLiENVqY+GGVwg+wbuH2RDT8u5D3tnIJwxq9uL6CNVmC/Dm/fHsOX/JJmFKab52/q16azd7CO5+hDAlXm+uXri/e1N/05p2QHSo3WlxJDfFl59V7b9+K124h50/jjavGC/D8PacDLZpfMrusO3v7Rrz0f0vcxPz2+m2N+WfRzZ9SiGeN73l3Xb307hLe+Y0ssKhe1YDztu7r8meBF9N7EjZfOf+5QcULQUQCCdfrVy5qNPD4i3RKHHgspqCqctMadIPA55K8sgR3A8dlPR4B9VdR7KDxJW/bHf0CcRONL2g//QTXKkWL8pftcXyV9r6aoO0vuIEoySbBG9x2DS98q0/rQ6S6kHPC11ja4qF6Qp4qtmdZSUOxGf+/x/9SLN/kQNi3QR4DEc7edHiw/oRkxsbLs7PzNj/W735r2Rr0B64a3y5G0ICj6NH6+ndNmvxvNRyS3nUGUzNn4/Nvzi7FBi85VXy+4EeMWIiBALzN4FsuZhdilcCZOrsXlJRvFcBpKtEW/4bZW2AQ8anggRQQ+wbXMeobYEe/X/JzcqrIcfbm+t3V1c8/n6v/+Qsr/r6IGcnydaUe8UHAjzAION737pGrb7y4FiB/gIVjLkb3ZnY+u766/Pny+uLi6t0bsUzrb+skP66RXfa/593l9flF/W/re2AjETm32t/ytvst5xeX7942/ly0vqU6H4iIwWBVJHH7+2Y9VJezq7fnl9fvfr64fnv17mLW+r7NdBIyqf1NV+2/561vGvYirb5u1if71axN6feVgfjjwOevep9/++7iiu8o1b9tSkGC1vdlkan8Qx+aATX1t/bJdXHZ/nvV+lb1be1lefjX3eJ48RUsbfXO0fq+/hxcyvXXWlOPk0fUwneKn6RLPV+2Z2KDmzLMVvSxZmpYsPDpUlzE1C208XOBkxz0k7oFtEII7qlbclSsYjKvGww6+0EfM+hDnffOlJchNtH7Dj8ZITcuJV+EeI7COxMg9nOLqACEsDmGmlcnR7XTg8FAn6P8GNRydRZNDuvrLyaOxRzIz+2/oHBUi2/gWbb5UXuZDryw/JvkGx/OEcNXFxsf95hl4J3WKh943pYLAy9wbQdCOzY9NnvZOtjrk/XQf+AOLcV45xWjzDoEnrXpNVPKo/AxwHKOZk+W8wg0dw4hgrPGzy3wl66utmXvT4YzHrSW+PlV5w8QY63e2/C4Qauh52UK+hzvNMnUljL0VoM9hh7rmeo9e3KYsKFFObmNr7cxUS+GZ/IJHp34QVhk63kdAb77eRPIx+aP2B99/xtM4B+TiKKD/dKiZ4fo78m7TBhtAdSUxeetmVW/lXN+kAkxaza2ZJBoacoT+UpDiomGxlVKw1lBPX9ylJ5jmnPYocr2VAe00QlCWlPfncjJJ2H//CE9JaEvFjtiaDNXGRA3e6UjaR2VDWnNO5TiBrHM6syjY5Q3DqR+dcw7wV/oHskz/KjXRe6UHa83TRXn79p/Z08eJZfp7GhvO38aEnzgUZOjuo+fzKWtAcxc8JVwL6zsDIOnErAyp2Wy5RRTnxJnT9aT4XQOYJWoGjh/DQ2tOZon54l1YDAZ23gECNn9/seDrqlh6IXWJO59wnmynA+orS1ddK4LmrQYetZRngZeaQ124HmbWgMvdPeRoXea2ln38ZPjjEdAYM1rTXpOC2xHLqT20bK2Yu9a5cZW9IiESvseh5tYL58sp2NqaXYN688ATYXfCiy/mOtSjSCO1vNOvowJJ+CQ3Ew7zbYUj9LxenrHSD2xu9kMvkMWi226ZIqLh4ze/dhpeh4GyedkyIZvxGh6cBormKf2/jQgLCk+WFiPkcXdudpXXjcNv4aE+SGJtBqqkTzvd0wMfZNBjxDDhoQeTUVrpSXKX9uTOpuaDiPyerX1hAYbgfMDYvXYu7QYGuIQdTq0aS5IoMcGfpdP2+R5MpqDrH1F/O7d7O3l7OeL8/Prq4vrNy3GGHzauBweeNq+LB54oX9xOfBS5xJ64I1B0/Hgm41U73XKmo1vD9lFhwfaM//qh9XLYtZbAfybXhtOlbLp7W7s+uap6lxcd1958i4dXV/+Dxw/tl7O8KlebT4yddfxAdc32y5mntyk0/undFXTsAasCt2BD9kkwAMcMqEwg7aHZ+Ts230t94yJAxK1ouDPBqPdN/MV165a1wpDb21/4cmVwa8yMrx5q/ZqbZJUvy9SvqjCVaut3iNUA2fJZWXqVG1aqb4auqjQL1Vbkfq9WHHGjrpf1ds23va1luobGkbXuql15dT8YjjMjJz71oeqIPpOZoJWv12z6VW3OZCf3/SpYJn1e94ymrEDuVLU2zKEPtSuUXcAbteQO/AKLTv81aRmLzNA88XeKao1is0ffbKZebMtpzp/Gmpn/0nXGNV/oynC+k97Gmn/lThOevKs/1ZLHe4/bgna/uOSxvwpF4f/KasLxs6fJ9fpSQeuWFtno1qL6F+/jrhbHT4SDZynnuznSW2bQtQir3Ttq1lf/77qS9qrnqC92rZCB4xB6klr5zzregYMSqGmZq52lk6y1OajdVtU9LT2+is2aB3VK7tRDqwu9WQwHVrDX9tm6tqmIWDvxb1dAqF5uPGDnZ1w+yvNXXHHm51Nacfbnf1p4O3e2jUqu0ak/h2QVdXVT3v1nvcX7zNFlliegzkSjQiwHYmJO+ecQYkzOJi2RWpq1DtSHHdRb7h7bF+dbvUefbKZNbl5Czl0g8a51eT12g5L687bt5YuY8waOy4ldO8Sa4dPcI+Nm1dIT24STA84CoyWMRt28fONm7jWzDrZUutHm/U7a0rXyCTZ2y4w3bgmjM6JDdDXKInHXl0OSuUnZ5m1m/buAbtXNSkDzzIbtrAdybpFRHiZhjpobJNtScbRHuQRstXZo7eAnNpE98w23tl7Dx3fGLtxfeE1OD0HWLOfzORKB5p0B33R33xabl615HqynWq9cVwZWKHPM3s/uc3j3vW5aO0PDQeMllrYvtSZeD72Sga/fWYq/tlv1p5sppjve+g439n2SlQ/cLQY0hkbqsYue8tsu6FjYnYblRt/SOMccu3QZ+J9DwEjXT52njSec5J5shvY3LQAvu38vWgEqnZzEwzc4gy9Ut3oDHx1bVYcetq+zhl4oXcPNNB/6/5n4DssHp03EaEVdj84Ax0dcMNrw24QQ29uNXAOTkXfVDr02oCHw/DXbXRxGHx96AC1iZhDF+KbqNBTLja82Du5b8K5xSg89H4VJdAyYw+/Objlbni77Rw49MaQ89/Qe70k91vWYjcDv4UlNz5LwCBRu/cTgwzVdpvpvfLkroLKyA1/yIDg186/pXpLXynbx/jwZK/4y64Asi3pHg71Rd6agWGMk/GOgDTBJINWvy3vbzPCbfwQ2fGl3Ut1k67K46rv+GJLGBDkLu0KI+oICa8+VhzgLr3d23uM2v7M+4WNwUNPTrMA9U9Ek8dx7faYM5wHakPuDKnvwn4hIxlt8PiIAlJd6bCH13h7nlrroe2m3nVLH9T+RahIh3WqBy7zVp0/2U5Rtd0R61meDiN8rVoq+aCjQZJALpj1pheIGNBGVy5MIszHuhFiJbqMOjCM1Mc3XBp2/BqkCx94j/F9N97knHWYg4NT1p9aLx1Rgc1TZ4mRtdxad46j53g4YqkTiiTdTbtXnFUvmx4MOMg82a8411Sl2p6Km+fS4PnoOaXjGtcHb66vfp69rf/t3BEMPR7y226VyNv6wQEP6k2v1rcH/dpM4z44YBra9Jmu59CGVw8Y9rgRHzLYPcc5boi7x/TkrPRgcw121tflk8O6hEMXu3tfmW68tnuyVPZQZAsfcuUfzKPSp8FwVpVWmUNrw9tRbrHJSHtP1K6ZfnJWzLGZhOWy4RXs5D51VDHIjq4kcLbrDRpY3MN5TB//a1PeS2lxb9VdrG2i3fFoavdHYYLAo/N3PoKGktGm00OtwLRvqjtm7qGRPLmodemMV3bWxGwdePdMLWXTKWNXUsbH/9qgfQztAL3qkRte7CsnlgY5utDnRPblXUa9rTG0uxTXbWGtY15/clLNtH+jNHgQtnmxtG9N1N0h3iM0P0u63ZgaqK0rgQGm2pL3bIpFsCsWfNcdzZOTGq47U53tTJ0zIiCjnWfRXI6dLc5UT5aL1e6yFLfJelDgbouoe9ui2+TaP2at5eM9OiT5yUkR32a6uV3Z3YZ8H2o7SudYOHtyVh/42bkrxlwaP9dRf4ub+pODAse9VMgT5x3cu/axPNaKoPaG0rDDfbglOmbTQz+wgPKuo8KWeBlrPvUHFWfuSo8xEqNz0mxP2ZPFcs+9GLHOxjI8oJSzK4VbaXm/xmwNZEQx6X46p6Fbv3Y++1G3e6Ms841Xh/YDHZMoE/FTguLJ73VGFMHuk6i/Px+YTmTNDtUndqgjm0m64d2dMzUUtN+dF9PayZ7lw3fu6Qkq8jgTt9n5Opc5Vne/CZmWtmzgDKN5Rjd3yk94+dpl4uZDK5Q3s1LsGb64dRbqS2QTateTs8LqA8mFV5XTxLAu0s4wML2UO7g2+86lRHnfWXJQJvRnWgK2JyO0UYduqDjpJFVR9u/3jMvtGMwRq+EiqG6ocRbUzje0chnwB1vkLawFSki89gpYPZUCIYk8RSdzKqWRKJBjDuPuW7Zufd+zJS5kDemcnwVwwaCk0oIo9utAPLdxgaZqebOPjRgh4zjG0woKX8fgOWeXUP3bvO/Q8k03ALS/WFCs+HfaRbYnm8E32QXYv87/KlsUtCIDytmlGYOl9pMyr8C1h6o/9ReD4s/ezZwQX/BNzFfeoly4wmHL4SzGaJ2VBUzh0rMp5G/F64DzuS4769fczTMowCFKoXjJW1XRW18BplKmxpnFBdCPp2ArCJJm4gJydaa2Kg8EKooiP1cjSFXmjf6g1Ffeg9QiuKhnHsoKFN4tKQgMb7UcuP6xvBhHI3TGbXKPbni8eafeuJiyttTKUYpjBiIry3HqiWCoqeiHuj6MwlCRdyi5HjTTUKba9myrs7NwReIomK9lYpUgRcIgO22l4a0oGs7n9ro701ZUiwP9T6mrsVrr7SxEub6ENVA8upcf+Ttv/SobP0Hbh2aaVic9n7VzRgyE9riBVVcXhzsdGsC95TLFkTSTpdJ/IOBHPuwlcsgGRfjGV8EGpVMFgPmLmn8rKdY1aFX23lu89bV0jZmkC4pYQctQRC97i11mYHkgxUqKIn6UA5U6SeB/wsZE8vmBPkvhNAXfBLAl95dVPhm/YEthx7pMEvLeSbpsyRYf4adZcE+yWEqRhdCWKeXPG7ncfKR3+1OcsznRU9bMVOeZ8C75KuQrcoW4Fvwjl654d3jNvJTZSc5FtjAsVpSVbd7Sd8W/j5+3gqIED4OGFcZIzHAD50AaBkD6WTV/rCPGrPd61kyw33evso+nJS8TwrdXLiCrTYlszqPiGCrccSnlsarr7SPOKgubp/hy2BhFIntR9jMvSEL+rndGfwBXltPqM1oMCvniGdohcc239XaFYW/Qyvzna+HyN0cMC1ewBMW+4lWvip0bDOliQzKYVqmBshfTCBi/8cZvzbBGqz1KmkBmHBa8fRtIr0Su64pP6nzM7T/XtqkiMVaxAS8BYwoXkTVOrc2imGGf8NbOTzVYLs658rXEkZ9A25RNUM70CUe7vfmGuEzv0uwhhdmP4WoMrhVJCj7zyg3eO8RyAwIjA6eztwzLxHYOCbULct/g4BeCt8XIPmEGLT7GhchpI0I7fAIHO7YmqrRxFIguwScSUW95oLNlcTbojKE2HPgBOSaAGyUNBZSB44hXewJhDbpyWiKvSAh31qPgWVMyf2+y3BeZiM2ewjnUu6SUygnXNqXx7ioDwkDEqmPIfEmLxBetdHb+wQwp32qUmiRwcvqSDcnJpmZDdS/EcI5keFOwLPkHKCIx0+h/zz4RwM8Pup/Tr5BE5BeVHvfRFyySkCLBiTqRwz4DgZIkFNcaZm6FxyC+4d/Nfsf3mCpHkO/1EJyQcBsgxZDwhnZkAT1YEpJVCQH8gywdf6QAF/ghyHHNuFavhhFNmMFgX/QyCQB/eKMMmR9/hHHJsUOABv84R+OGE0YAa66sBHNpH3KismptRTjl/6cq17SjJfZZ5EFkH7Lfs+L9YsGHJCTDrUpo/+gVoCZBGTRwPfMeUYLSQhw55UfdEfODeOe2euWzRueEkhvRnDW+Qkr7iLC/VEyYAdKBprMWMWeg/SBRH6paRzEJ7z5WL0y/mPfpXN/q89bKCUHeBCgZaFgBOhTrCscQ408xCldoHmOfsSqQokRcIO7RyD22oq9tQ/x9zQnoig27nUtyQe5rOsyGlw4p0wS3eS4vbU7eJ8SK918/u5q+fveSRgvejnLCjzUl/90bQTIKLn05cL2UJ59ixJxta93OFcGgdZAZLx0SpoXND3HydQ2vuJq8Xu9K6V3LT8pDhnDFj/AClXFhfQq3IySpQijcIvnELu3PYAPbe4rfi+PWH9KS8egcRG3lrz/dtLnY18G/NdbdB4KWaQYlu+2y/QYM2sMZauQycEkM8H9KFDN+3CtQI22QFzBBqFLwDREVzxtFzDyCWDfwA2CQZpwTxSG7ear2GLNws1YiRttR6nDy2eRSBrYkru3O1IbZ1IspxrciiOajTJ2qc0K56175VsnfleuPcl1jwYJmSVCwH1YM+c+BrbLBeg9YB00F8yxaBywraWhH79wMFpZR8X0Ge817EQlSFXl02L+iVskg9eIqy+4CcZktvwWWsNsJ3oJZLx6oAJYleZbyJy8GvIxN2Q+3ZU79lTPD12aaeEd9nwFXMoj55HtMbOlKdg944gMll4mFSMBq8WC+N8qa34T6Lwm7FbE9nvs9SwXqG/6JG+1Q95mrFlRAe/QAhjpJxWDbr7zOQUkTX2fmZLAZKYiVD3AZT+aiovif7eSXrkEo52zBYgvyQ8Swify+UeN1I6fjw9FKqazRgj9IV07DCJiZI/MYLeeTcuF0osrqzrWFr/YmZUTkYZUxovwowFVbKFPMbC8JkHhfcIGgbMHHlJJwZVnFGgbQ17GAtcQPiXrZzKHuQKBDuwQg9h8sP9UrvGnmJVxwupWfrM9+HOoQL0y4bFiOQwUblXy96pTpoo7DPZbuXO/5E6UufNDtUy6dg0HokrxrMKvWLsHTSpZR6MQe4gOZNgE5ixqQ3py9ubhs/73yhGC1i2pOMd9vKy9fnV/Fe+ysj11dBr8E9CGXQVB8oD2Ahai1+iLIXwU6dYag2nWqGL8HQVgXPnxpVYT7ZSwDmUOGlYvWOGTzSxhBIz9LZxDd7CaeL+k6D1FnHPWTlzAOmXihNwh8DzqeevgiFjeUodXoY7LA4TqMX8SK4OfjCjiU/yDFi1gApMA1bvjlpWwDym22tRFA28vg8qDppf7S4P+F7tGLpj/jR944eqnoIwx1fuYvj2+W2YvmGpXgAyU15VWQ+EtAn1NyD6p/gotVVqfqaoe0+z0E8JKBEncyV2t9uy7So+v8rUOjmKbAligF/hN4CYtwhN+4ciULQPGtvzLJf9SVvS+NdPo1RiqPlcVOf1OZFq12+i9VusB2v7dwIWm704/CX8n6vDb0a6sdf+ZCJ7U+XIi6tT6x0RJDtIGLfj/pomJWe36fFlDTg4vv39DD58h293/qLJq3EB4qD2F2JbTyuPj4o4DCORPdwm/qZUKLPqSKl5XYGnXT6xxdooAYb1AuY1Nltt6317NA2ggCudX/3P577oIQMqN6wJr1Sf0ApgNKRQxpXWjAC2z6tZJ3zF/Ly4J5iC7CIWGezap+7Q5DJtg0qlJZ+AVP+pWCTSnxEV4oKjuJnGk+wYPbPfCJIzpcwR9gKhmnyqHs4ZTO17AmHjIaDYObeJsMs5SrGEyGqkOuFlnk5QNBcbYs8Rdd0EQpHNPv0xsA3DSaP8XZw3tVSWzqDXvP7q3u3Ptik1s4/mFRIOwLUWVcL7JcxFP5ii+RbO8dvBDFYRnLTKS5tHtBTr+1j1gZXsI3B83P+YhTe0QovH5CrObdrhq8L1DQ5IJVVrA8K7yUP5UCIIsNo9xrkIiFhAQFSXBclTYzrA/ww36Z45aeojJZf4AnokjQ9Mfmcb22N9/zi9m7y+vGvy4IcQbpq0VNR+YRqFpcwMVDrLjcD2xR9Qv2CJU+sfg0i/gHiPrgL6ZrGviEip+e7iJ9a9hDNrFQyinnYwBEy1TGQ08tgPo9nDG0wIL4QVQmuc7Sf311cf3m8t272dvL2c8X05a37NWpGapPJHeBGoFCNCmQMpU3lKJ8MyOCF1QpZxvdgyc8Z7AULcUH5F4pKzyIiy0pdGEr4KfUYKnydrqHhYXHvy4CahwP/oHDUtba4tpDg1/aD2xA4RrNAlLBQjHdnOKISJPy+p/ql6Dxgg9TZQPDQAXfGK2zsoAKvny/sYFhryrsZqEMlEnplcbxYxWLDc7KqunK+2ZNsrOWidI6qw4Vm7a/6fxbtr1XTX+IzC1nRRaAULEBivKdhp/YAnyP4hIpofZNNn6s2tTTTetocotpwqkAuUETLJK1BJxfV9kS8iGQYt3YrNsPpjedHoZDKNs0n6ssQZ0/1mmlX4E0OFm+NlYyai9QJF1gKqvDynwrIK79gKZfScqiFKW2xMZutPLa80hXSNcVb6CJbPqeIdOvVEVjoiAhRqGN15GMlEarIBRZnsXZcq1ymUEBA/DhVK03Mv6UTHnxtFe3VQTsdPkS9scgbujreOspsyBUYPRzcfcCKfjgLCV11lv1CC4j44/qwcTzsW/3HVukyUWyPzRxPq4rwAiHK29x1nk1/EKnS0W06eghUK1OSUcp5itCWfLHR2hV2i2/oClzUl57SXqKkHdmY6OmGAdMpKNp2BC+gs/Dd67YZKX0xf74I8S50kan9FbZgkH6XYiMKUUDif1uz2RBOsMJyMIsXcBPgCHJIA1QA54ApVxRjOHYjycMpTbbAaJOnvTvlIh73njKAu6H9t5xYDJRsO5waEV2h1OoWEki3oFWu32DqY0acOvrIxW1J2GVNjFYoyR+GUgbX+EzYJG0SVQU85g/IwIpDKscFp5PvY8gq+xTMheg8Zq0EyCtklO+BLCKCXAUsHUyz7yWUUVWhquq7IS3MCl6aJRb8w5mlTpS3/J4LZvWxUqsJL07IR3jb6SQbgU4i2OUICjLpS4o/xANN+L3idXHrX21lcWZvUFyGbHCnEvUS+gekbiqn2YVh6ylzNFAVIb17lvGX5sdE9Yl+rQsvswitalKn5WMBjEpxML8JYuE6fmDevAbKaY+M+3Zu0Vb777ItK7XSVjmFUZ5eyDrMDRdZb3CqFynYpQuS7TEHiLsHTv9hCc+5CG+ytmIYpnsMmDlcolZHe7sLV7ILopTma3cQ6idcIV7wsqqJrwFu/Bov6GJN5HD/JVc+UwxNGnFvtoJNVpWSYykd9R/334RV/mqqvnUF7W7OzSptY7ovSenrSPgK5AUbrrWl6YJTuZQJFdfDVkH0g7omJlmekhVU9ehui1AHi7Xxll/uNsqlhw+wEzcg/WRfBVnZcDjePAGpOyY0fZobkPS8iMaZFHMi9dC9+ERu6A95MO6tU/7jVNuYYn/kr0WNmuP1AV7fSvZq1nU3bG6oPcHWbL5tZB8YLhOhGhdw9MTwp93LPtXTijQMTj6gUlawuNYxDc2fUr9gFelWeLdYFwn0vUMXr26PAFWHxZ7gOycGWpc1gTARrlj2F1tPAnaEsAXUJtEgFn/umEtWCrffjHP+ezS4cg7u4ZbLBt3C7ewtBju2qc8gRVW7hF0yXwD1tpV/YDV2E3dAmrsojOLtge/xJ/xKdg28I7V3ymUTcLPLapNa3k2fSRfwfT9ZabDRwr2i26ZPnRve392Y/V2YKluSyGckuIVROTe42byKbf4gsEcud6AinCBSAweo94QrM621s1y4xoZW6dhHfXNArQAH8gVLmkjM7NjkHAxHVDMytiT6XyghE/lquTTCIHREbjAecRtEl7tkxqyewtOFr1UNXU5HQOZoXdnx5l4CxmbicfuILWXjc3B6j4t5drcA5Dy0KuT4PkASicPBkWP+YNqXpI4ClaECw0artYekUvlGRG5JJiQZPI9j4gHLtfLVGaQ8QmW9ivSOf3MZd0UsCAqnm+AS64qyLp273nDN/X7xCJpa1+dkNV3Jo2hO4AIHHVCiDp1hVNUIo1GMYOjoNL0nGPSmSjDjK1ZgRNfAHEqVdkeXMIBC4EvWAIURc5BcAx1FU0vpme+hnivOumLazz1EcQlEpX+WchA52ByStKiXcvnndGrKPDpbeVF+cQbDGWk2tqXpTo0Y4DISL0lKZxDUelo6rwMLskCSzZfrZlQFBJcIEg86wcsvh/zRewdLL6ky7Ao/QIWZqWoYZOIWjZQhoP5QS0ooLDMqIfsxUWBR4hkwXNv8CgZNZeFockmbpo8REpGuFcRXSpQSLbqQuVmzE37dW7R8WVPYBtCbX2CCKvvPyXh23GtLJr1zRmVH3tihhqXk9ui/XIkIHFMV+/6g0pmkQs9gtTKpu4FjaSKy2mE5iTW5fa8QNaIEq6qFngCDFSUXAiiktmwV+Y0E1svLDO58b6n4YqAaCwp/iqfTn2VMqZPSKYR4RwKqafhGjrKHnBkfvMYBw4mapHROYk4PJUJ2ids+EeORYqoWN04mt7S+tA+6Bt0W0zU7VAQIi8pFz0BwwlKq8t7y5M0CCwmCxyuQ7gl9wobX3ZJWciqi9sWnWn2UXh+Ew3GeafVm8lQ+F1dy+TejVUd5NXycYKlLn/gEAhhxSBRmCswPaoYiZjP5vyb7pX6JJCQXBQ1vS3QEqL2y3jyzGYjumyk5pjctaPff+0d9kXUn6LGR9zr0WyMwBgA/Dso38zUXDiDAfdNVLOdGwhCR05wktF1cDd3B0PdosCqcE0SYQaGnZopQM6QNHP2uOi/f7U1eWBBD4YQjJA33bhgqnsymmJya7f8KzB10e8PB8NlfGFlOguW7Y4bNgDTaoVswJXweLTW2VmE+VvK3Dl5qMeB+4n7jdU4gkE9cvqgll7Hzel+tNLR2QNFeS6E8/R+yJsK+MIq/i5dYAy6em/qvcFfhmwv43s26gY+CoZqd0IC3W70/LAfFPWGB0iUv3XDCdwtnCrBPtQFMhh8vScsSLaayNA3VvhBqCp0a5UVLM/8QCWrLVJSCOeOuvKrL7SKwPuOzMtGPtqpt1tSJeoxvvnIrn6BSukTS9bGNwu1qCqgaUIz6nYGwcGm++GH5L/0dZHBbiKZrSrg301EcVpqJm5Z3V7weaIF/iErw6dQTe6jjrGeOnJ5d4911LZ8YOFqZQyqqlSXJ3CWJYZ81VmCSGrhkqc2mod1lVwO7F/SrWttXGhtAgDRothZ77/pm8CvK8TcQKhuAY1Vbt6jZ5PGrX1gVPqgcjtc+4IHLEPYFzDVPbYvgKrk2RPXq+TioRVTAfLCUGDf1r5sBvbtACIPcLQmgls8YMkjKXxHiJ2DSeEsEOu93iUSwoJ7jiTyYn4sBYbtBlI7RnmBJHjAZLkqnAOC/Eu16cMlEoGCr2dPZgoI0whud800ULreRuxelfamswX/qtuNaYx79GxSY9wLRhXkruW+Oyy19rpuVTV1SZ0+JD5v8B+KHWMTrqIKUsMpfGIdUn5zO1PRN9FmKsvbiB6r3GomDFJj+lfJmSo7X52dyQUYqdMmmGtvSmVyiALRuyh7SI0Y7hYl39GaJbBUsoe7VBr0H231dSYt99UZ0qhd7J78/RNf9Zi/mojaR/wj/MMip/3ZX+yfOquD2Tzju1DwJx6goDjJ7rEbIFzVysoCUCyxlUTrSzCaC9WX70kLTDE/RAKnfta/fCsnv0cf1SdXbvKMFbWGM7lVcBMMcY8AmmeFx9L4+x2b1PD2QCHFsvwAF1r4h1s4oLWkcG6cZ7SZMNcVHvG8PuI7xmHIEJjiB0hyyUpV3fN38fttOX3B5S09ndEyDcyUCdzWa06zOQ768dVOYNQVV/lJ2chSHIFBiYICL6kOcbWNQdckz9IU9u77CsfEGdV/4FA4L4hceiJFA//f+K1Zv9uPuuWTzOn3aK+3s6Zr+aXNcZ7xlygWjiQPpFjpBJBGKk5tR2Io4cXIXju3H9dXP8/e1v++dUGIKseqTjHpB6qee51XsOoaFJ7AIgxiG+iaK9tE+Rp5gkxnhazReUU4cXqnGIUryPntIeEymq9Q6hXNdEJfRTbhtS5cFj1cqRwg8Yt64L+EJS6vJlXkO5G3efcki0UMvYfrQWqrMsIfU5rRDZM7sZ9gAhGsrbort9BkzEtwV38dp3y7g22UlaGREwCBzvtIsyRgWUl19Q2XOBAr3IAQlpSqTJeL3quAJYc4NFMSyHSpvfptg5DGm/rS3zoA8AOX53p+pC74q04FRJnepdmDjhiY2JSlfZRUlCvAEK5CMtwkFQimNmqN6fNM5Q7L0gWB/E8qzb8FN+4hePxo0EByh20UPR7CERCIvW7ES3l4KWOJCFsKAk/sMY0KFCQiShc+IP3oIzxHDN8qN9xHi911zB+X797N3l7Ofr44P7++urh+c2l17DJBEOAhKJYi0wtYSqOAheIFHqFc+ARmvm6k+/YDDyXp0ic8dySNvKJP5tF8CekrNHbPIBWZH3IRUoTVWcG8gAMLzCc4mS/U0cqnV2DkJc8Doqk30ya9gYIIpcuYg2pa8F3v9z8qh80+FBOuMiqpuTi2sRUEWLJCR5w/2uuNTwnLYuWhdWlf+Z/YMXI3bad3giQpg7ALuPtZklQ5X4km8xH0/a6/UpIpNwKr/aohs4+iZep4/l39mTTE7u5c8ZuTvtWVQUIYA4la1UjQBS4c44Gl5xQI5HQiITZmDBwNJPwPZUGWwzZTplUqezdYGm5PhN25RJJDJt5FmQqHYV/I07l/c8O/IkKrUVtgWgke8mEVFEGqyxrBn3rE34nhEtPbu59499jemclMxIM931SNRvbKUX2azSY2EoIsy1LGhnJkjURRXRNEpLpsdwRFG/kg1rrEDpFUR8jK5OgYR5VTyQ0O5fXQSh9fuag7Jk1tM588F5iOeQyFoGzUxGoHQ1ZVsYzF8R4OxOTB4BmoqjBWqYU1g2v9w1ipZ37DVLfdOArYOplnsV8wZVlSRAsC9VpECMp8bcpP47k4qxn3GGedFbG+WPcMoto24CoIrx8yGjHPAGoHkWq+PZznCFMCNmOdr8mIF4uoxUd/ytfFCjwamz41X0Xb+9vvprwM9+rbZuam/YBpXtIyjlWeeD6hDBKMGKhvUGE+wrmyCXsFUVOS4rCkjNxj/+b6XrtUZTSoqsk4Q/gnESZP/2ZSXLwjqPIp1DyQrsxPlJXrqKf4qh1qnkVrzyHyz6LE13nOQkghrR1lfINHMT9bp1syvD3ZlymP//U7/1BTxkydDnwnirN7+D8QatEHvHAK4pNic9c43rN1GvbBGGEQeaDsZvwVjf8jnbwMlujYAqHSk6NbfeR9dNS1STP67lkwZnnap+vKFGGiouQ+OFpZ0ki64ieoOqGpL7g6GocvsKoTsC+AtK5tIh9DW9jK3+rt2aRM2dqlBVmyoX+ukXwVTVZHXfXaOd13ohKuXRDiTDzxCE91gm+c3v0AtuHc7gRc60jsF3kg+AYVbsmzEZyQvD4C06dLn7ANGQ78QYYKWSsJ13u6R+hqsxD2jnJNA4Y/qHq2AY8WQduq4hGXZdG6GZnfg/ZkeTcaMKbYRGAyB+SurodsOA4A9EwmDjAM226M8KLMQ9A2JH1OlFvlo83+zCdh3QnB8BXmiI71NaHl4Uvh6AsRDATb7Dv2xjxMnvxvC5b/RvfoNqQkL17nXGwcv8P5eL0z4ccc/JK9zhnojdsR/b+V7JVKo4GRO5qDm9sVovnrnIXBsTtbC/P1a10LvZE7moOvv359pYpqb+AmZwDC0/PVmpGwFT4tW4xEZo3osW2fuLQ9YFlXXDpUL00RHeU5RhTuoxsw3leNxkg/qt/ODdzbdxdX55f1vxduqHHG34rXAZ+dRipu77A1snn4gi0oCKacn2N9FeYNMFRkSbBACeG08xEfWLO9BAY5kbwEphNys6pgry/Q5O1JGomlUIl2r+DNUXi3pFAk3VuIK7JcxRCh7y1CyN0dwDd5ixClJJFZw72mYU4x5C3yd7XAQkF07S1AUAUEJzK/IYp9xFuIqVzKPkOsd2MvIQZ1+l8fVQZxGA6yuzhceYksxzTk3xxARvkymWM/6ecxNEh06JkyKNkNzmuMLueeYYNYQkR3gJveJCFyxmcxayfcEE3GzBE7++yWKTu/mL27rP+1TwRV4TzFcXtX9wTZvCyKLPUSGosJP3x5CQ0q+YCJlfhKOgJpWqmP0CCpbIJyL8nG9bLCQ45r6GO1u6RfuCC1tDe4GILKCH9jNZ9BhBeojKvife4B9i4MfFkAOIVSglG1SL0ElzQKa3aQTa/kFNkdTgOV71lcuH2Hlm+qwYCKs6PHbrTT7NL2mFUOQvEWc4hCPapzVDuBUevo7jDo9eMOQbHCiUMCyBTpDnlxEUOWt9T5oljiFOLEcBAyFtwjSkBkOsVTtKC4RSK4tJlQxhUQpZEEjpdNzbaCMN4wr4QTMh+w8B4kHuYaUAFKoyJNQ3W8mjp9B8VLrs3T9U8qc2WdHn8tfF9k67eqcWIdaN/uOwrRxWX775VT2kDGxTRLSSiOSX4iFNqcqAJbYfUYaFSKK3n1IeYz0qqw7AsA20h48jJoKzdQr6FKy2+xegEoKV6QH/7jZOXiReCEAxkiKfMf6UsQp+0q3d5DfTGiVPgWcfW2URLQM4TNlE5SRnkPU4oo72FqCeU9UCmg/OdOyP7RSLPhMVSS1FUbvaaoNuv2QBo674IcDPRvIryJN3xTv5s65W7t1GQhjrEIZMGhaotwAoKwztnUCYpWwVonCIRu6Z4Q1b2vOwgUJygPYrxE4dodClFRubYnO8EQZmVauGVJ8QbcGZuoMlHhYOGKT3pnD7kVjTd8VS61KdJUTuHtQD4uFjo9jhsAf+QFScjfIlBAUsXUljWye5MJSccwhXkL9ajOzVYN3BdLy3omP8N8AKZLW7uHAf34AgUOarVo8wUS1qLOOSCx/5LICw5u7MNT38gpxROqQDEcL4KcZtlCgOC/fYVf/pRvTJ71YI+eO/dwl64ocMaf6TS57kBw2YpSEejD1qzAiXM8tQG1TuzqEM68JHEk4rlJWCmXHhBJ1J7jX0zXeUZS7TPqnFAqYiwt8A8PMMljaBz7wUqENSbMORoZwlStNh+oU2AmYw6dg6kShgPzNDJfOIQkoBSIitBRH9hZZ0SgGIUrNCcxKdYegZKSOkBhWFJte/EBGReOKQ5VlPw9pmjp51TyIzFaphkrSOgB82t7e5kqjMLUg5hOme/DxMYlgygO/tiDrU9o+UGUPUBlcYySJuUUuEl0/zAmACFBJJ1Ypa+DdrKy4BSGbrptFurcLUoud1GK4jUjDDDQkuvLzUazIJhIKMt+Er1BrBAicUmxgKLb4MRngRSVr+kKo7hYiW6pmJfqiWyygYWifBUoAtAmMWBuLAAQcc8MEon8xN8o+fnpJ+ndf/YX+6e2EpmFINdAoIgv0+w9UAITVCSxvbkYWqn6DkocBqosf7Z5gq04BUCrrC9pbTOFDKkGpshynFrAIKe9zRXfRNsvVZNer04mRZh2RbPBKqBFlsWMzwcrJWdKGA94voxbAku0iPUCgVqxZpRHe2x5pnzpJ7x+OGTwvdjdR7vC0u3YI1fDnigP6CQzPlVC0IOnQGZMfFW8V0+CoACJXunoRcIunEbaOPaiaaDNR1EWypyuMP7qDJuigivwbvy09OWPhfHqRtEg43aUbe/RusY1u7Q+uZPXzh61mRgf6IcshBpfU9bj3tKbAbPCOIZ56/zoaALBQau1D2XK3QJTWDVV5lBxdOy01VGkj46SlZtI1v7MtKoTLT1+CGHiX+VtLQN7Sz0VARi7GnauKSegTEWB+ZZtTR2Sptygdoyw+URky+IIdHQzc3YQNLT895xtH8WgdaZAyZwsy6xkAbjyQqwcWNLFREUv97i4NydcWie8XoSQL1K4FaRS7zityONekXlJ84xBUjQcRyK/BG/9Khs/QdsH4fyS0bNI/TB1BZ0ugKHOzWxR48cuXlf5lGJMAzh+LFO+nYrs5mkhFQY+e9gJedTcyJe8oBXv+J5wZasiFFQ2IeGJTh068W+F2/+KTFEGu96JQjWFav/amkokXVDEClqGcPw/Uasho8AyEjyQYhX8p8RAM1EFJEngf8Ia1DzRq0OvLIXSS/BNlXccK0mBT4SC1yUg1l164CcH1Y2a++CJYPB6mgX3JIvljrcQNR0oFRDj7OFEopqn2p/iEoozFj/3aZhG6TSEwA/9qeQim4vvFWIB/pHzJ3zbu8NrZpNzzhQKE6UrD+FYA+fifdW1JOfamrTaakaVbVbY9WUs6xX/vhgsCWUe48qf+xgJQ1IGRcyaGaqBNJ9Vs7IqYxNlLwa6bnfrcsQtjSEhXG3nKkKlehL88o3b+5MBaqEpM0Llh/7aaLDMIqlxv8Kx56AuL8pUBiNkjbj4V0SMyiul+ozeRcVmYV5G9gA4J8mQSsHPDg18r4U5pJ87JCGDMjV8e08I3MXGr5EW6lWh/0MomlBiXjwBet5SMPyWx5R4DVyWWfD2bZ3UqMo0NeXwV7ikBCKudMATkZdSVe6aVgDypdssPpeO5qKOLDjauYAURUHCGX8pPiDrzEgRdFvwobczfDmfiBRcU+rJ0OYSFDN8mhTLk9IoiVrNCFfx+Al4Obm/AmSRbEPiDRuSr701G/JySBY0o5D241TTd+p7M097Sas6eMJaPLl//j5cdOlwjtyv6DK9S7OHFCRrPEfhHXjGaJ+106Q4mhR5WoLLTL5a8GkanO12TByhMT+mFOQet9KPnqbEiylpbSqnabE6LWDwjnHBZ0DluHaombs7x4tcUIoX5D24zKjDAkTNiYzTqWW30Oic5rnc6EyUgavm07zstHtVJ6bqWM/APzpyE73YOcC9RjnezDDPuyKIuZmKXqZ7j0/TDheuJwf7Vj5+I2zjjS3II1Y5uFiCaa5RPt0MQzUYsbsuS/4BikjMqrCT7l3MCw7K32PkhOmSQ5iaiDjyd9gqx62bMU8f13bQTBvY13fikHX4kjxLcVq8klUGYzbhhufpcEWmRlcDdrC0mtPrYEmBDvR79onEGFJVsM+pSI75C8R6SnVIzof0cIGDvxJ9EG/hYn7MxnTulZPfHzCN9Piu1SHgpxv+3ex3fI+pqnT+vWYwFbgDb+ioZbiakVw10YqfQHt7czZzrlZMhGHPpDjOt3RHGGoZPPNzzcg5kwdSmeGc97yePsXC8/XCmSdHsNMCek0LqMoVf6Nc9D/+COOSL58bzaGsqdEkuKB8xwlKVuk0EU75/6nbkjtHnFLrCFSbzyLzCPuQ/Z4V7xcLznAC7i0Mq8ldDBoCkt4jSlBaCO8T+VHHnOVDCScnh5wP4p3b6pXPem7OGl8hjzgRYX9Nl1pzgv300p8N9dIHtfjShz12ci7W2d8bmeE7XiIqiX0jTbyTIhKT039g5AFDCQSgTt6tixyhB2T/d8heJMKc0wucOmMwN/zljuIiZRskURPin8tal8Q3nLtt3Fwcf+o2DoJrhXc4lTuMKPQgf3eQxNeAob89vmYKNibKigs/ec58yzTBBlStreS1z19cO5aHUyA6w6+TyaVbYZ3LF0opCG9wWcuAS8AYF8Vx3Pvs4L/J95q6WiZknEF8E5FZMYVpJCbh3ce6/qlOnsVbq+xiMtB9+jStp+Pp4XOzwnEORfIatehOc+PJ3LTKP4rUKOT+NEGWJwj85mhvgsC9jp4Em8dzc1o8HkzQJ8SK918/96ZowdtRTgLKNSTMTuvH5+mhp+nxdXpOIs6DSYoR6ytwC2g9iTePp+a0dtxP0Nc1vNKboXwtPyl9K6JgvuZLaIHKuDhNkE8TRFI1QSI7Ol9Xy9P82J2fxsy8p/i9uMP+I40b0dX1p5uu1Sev6tfnerSNj741dsMPBC3TDCL2mK6vgVgGkcZlEuD/lCiGElDF5FH5p8X+nEkCHZNCOkwRalndcp4myJsJqhuCKAvSjMtn4dzX9OY7zZinMyZKvyh9p+krdnK1NJF6AYPvRjFTB+emwZdifEsgX85HWR8XnqnDgvhd5cJVSbRV4dyC/Tg6hafglAiYIEUzWXBFn3+n/DxLGYpVzmCVtXdzEWGX6OykZngOV4ncBfjETyd+ehY/hSiHolgsmGfROmBZScPJUxQe/UQenwvTZlYCBaX4PoOT/XtR21DkuJG8VDLeGqyy7C4QKdPkt4BycmKpE0sdwlJab0JxHYlw4q0Tb00irkQdzRNbndjqQLb6lW90X2WuVHYGux4LckT56Tx24817UsdfiDre5x7xgZKf5yBBoLHreSe5j/YmQy2RxS2eXFivhCS/Z6mgCiSMvNHlFD4vU441UjedMQRtVkXZwGorvu60XZ22q41sBerPB8glSeYltP9ZmVVVGTOxxhbkhyiQDdoPhINXr59468RbB/OWVLM1b0FxuK7iDfx2UphOCtMY++UnVdlG+53WdW4YEeG0/ykxXQesIHEcPGT0jp2E10l4bWQs0D6/4AJBbO7HlJJwNWzOBLElfkjUyyeuOnHVYVw1dLoB9jpx1omzJuQsDlkxV5qdeOvEW8/jLSjMJT9Ze7JwvjptiSfmUszFchwqFkMlV8dVETGwI4SQmrKqPfKeP1UGvw/Vs+qtKVOijII0BGdyq9/ziFMVaMkp5ufoqtCSOOp4QbAzVUllDZExdfk474jI+kRUEfMnMu5BxpBvBQXuUnLBt4fsxJB7UbJKg9eh5X3Dp/ZEzbHUJKxLR/hSsiAhms6M/WpEJb0nIddxykWLoLL5RMo9SEmxCOfNwC7Zpmb95ETQffYfmVIv5rp3h6D1kxNB9yDoin/9ADXxPVgT1MMTQffZiVJSVGSMyQKH6zA+Sc29NqCCVhQsCxEQdaLfPixY4JqA8MtJndyTgqqyQUuhhLYTEfeShEGzkM+JjgfS8S90j04cOcnGssrKODqR8ZlkjDALKZmflvThJt3stKCnoCNO8mIdpCipebFM79Ls4WTx2YeMOSX3YIpMcLHKolp1TOHdqZKrvBJaQlIaWUhIsGUVtc33HlqIttdAThaucIJ+gvS3IiG8jo4Bd72ITOaz3ullXhK+vReonHQklOT8sZrIgMmrcz0qhquWqca0ub9b+bOJbBujagYYJ2hMWGGRnr35s8E0nbYjHWV1vZUgese7OdJhJpgu8ZFPJdSKMz+07tKfrBbZHrNno8+BhWGj277Umazmmu52iVMwNWJxtxUUJIGYxiSfmof0lrWkKF8FyveLQidCxRL6LCpWZ6pKtKVSer0SU1NP6jbqKrsGuyN57QRnr3twUBIl3Ui6yExwFvjTQcgj+LkiKvztRIGhRqnOl1pBbMsQ9ZJVlZtfbvzrljGqH+2NcbAw2YvXpQcoy8/0qXRAoMVxsk4SBXPE51M62T5al++XhgcIRYnDLObqAqZ2eAZIqn6dVuHb0FdEFosjJqUa3qPlXYJvv4YHtyBpvfkGfzGtT1rfLMz32RGj5jvsKja8Rxu8Ot3Vw2j5Yn7Zd7YIC8t++rPymGHNLu1JM0u9KX601FuTKSc+u+jgpBhJKz1XPu9JsTZ0KHZxdFFFvTkB1bj0lgQbAz8Y4jhiThS0U9Fjc6FfOyd/VSQx3zdTrnHZyN3Uoj2KIie0fyk8aJYDpt8DR0oYQ9Tel9Mtw9BasXzAzE94scIQ0CDukdFS7qEoDkvY4YLOwxd8MHdozhmg8PSLas9pNGDRAe+DPIvXyzgrxNWIbAKGjnFR+U5M5btczai4RaM/kQQOdXUvAOGzaPtYNamHVsePo6W5sbe/vCnGQlGiiz+e9F6R91tkWcx+4rKx5G+k4VrlH5C9i+MuwwlKoVYQiV60LX/XYIXdpBpsVOYxxCdOmTJ2a/cfdIe/0KzMhdw6v+r8saqfaD3NGIqt5NCML/y0RDEN4hJOmtEExYQfFZWTmOvZ0dqjdRT97bUHweZ6LWgZFiVFsQcr1q6ogt1f5TjhW1O6tDTqP3i3H+teb8lSOqFaG3zjsrt6busmbWAJWhu3tlXVjy3N+NaFNpXN/VCWt9r/sHZgC8KQNjZh3xv8dkSvonnK+45qrJWCu0IQlMbIclUIv5Ub3lCr+kaceceBMOLXu9fgZcnHQB6JOFtMel2yLxj9Wsk75q8pq8ajDzwxvSjekyYRDgmzyqCf5c8OmbM3C8458w6vAxDXfIM4TYTLiZAF7SDIPTlNhAsk4PsJpUtEreeTmK5ODqxMEkTXji6+zmeXTpclfBreTZdKfXUNqK1KuMPTWy7uSdMRoZMC2s/O5JgQTdXKPZqOiiEA2ZJp0zqmPFeA8qF3/ngm23xC1xN0PoAbkno+Ea0vAn1C15FLHkDzj0bzNQjMh4xG/mHrS/LOn4nFepilIgG54OkE5bm0st00mj/F2cP7ygIntGf8o5ZpLlRWNzrHpWPaM7yEbw6an5t6530+P0wZQHkYJmmkDoosJ6FPgODrvMCjM3MrhprUk3lCUE4Zu3ZvClEu09tw4V2sXU3gbWuuXE9VRZzOJcDEp0GKl1AycP0TzURSQPkbYPvGG77p38Os9IeLh0nz6I4q09u39iWKuKxcZQXLs+lvZybaRd1TqTrNLngrfMBTSpnzU5+Gu47aj/753IVYSIhIyjBtMPSJx44iVGcXiUyY+/acDRM+LpPx7czXZe4c2uBR0b8td3qfoghHZY5bxh8oQCGLJrDV1KtpoLvaXVh1bEThGeiYkYTEIvoooED+l56zZS8KT28xGuhY+Rd8wNoHMKNnwkcOkiwxZxczPRu+yTC3UdnvTKsUe1jDDe/cI7mkPqmCH2s8/XnjmbdRr2zRRtUv2MKOMCCYzd2E7OeOYvQ6ZvdefLqjPd2FmnNbsc3c/07Jf0rcdEJ81dedI2Ux/iGifVWyqkcHCLQGxWxp6lvIAMlno8nKJDjJDLht5CYsGgfxGef+i9m7y+vGvy6m3R8kAwzoC7Lm+vQFU1uD9AVV6zDqC6ihs88AtslNqgnX43AQkQQuk7nmxLl7lS2zFMUqQYugVlUAI8ILdgxSd+zAIauEHvxrGThJF1zD51D4vyKxAFQoeVVjF9fYr23o+pWkLEoUi2zoNDHk0jUaDIayyPnahPllDxR/ZZBGtYXF3fxUNqIoSMirn5pBbnUyPzr9QPsBqGU0n8evRIiYuYw9jPaGPNN2guknXb70Q3lxh6SrP07qFycWRJHlWZwtIdMJ4odXki5FsTvVeiPLxRFwo1SV4+wvyKm9xEcPWRi0RGK6LIVvnlhCPhvMa0iu+qqy62oI+rlwNI+5xkBJuJIeELfq0Rd48lE/CPhGToogmJgp9schpFaIUs7J/GQujgEWvKwOxImKLLGATklOMFhwPv6pTInwYYmDsF7d0sAv2+tF7yWrbZjiU8JX63x7IrkFkuuDiMyVxF6++rM3BVRJvc6a92dyJk1ReJqVaWYFZNTLPrsfNnb5RnVwm5gEK1xS4YrX0R3EOmjGEBlJ6TEljzrH1hAd06OBYbbiub7zhiqeq7JEekSJ1g43PajDdeCzIMKUt9a2Emv5agYyEvswV0q0Tpsb5lnSjnfm+uTZl7s29wLlRDD02DFhLBNCTcMDKVYdgnjCIJJVLWpv21ljensixThgpCiqhMa1D72YFQgkAqlWICql2gSzAjXORMzOAn4S9xlZeBc0scjqGzJ0yARPDo9b2ipUCVCy5BsvPhWlOs5g2i1c8J233orGSr+QieZN2U2fafGbuShbP2mfqtZOvi5WWdouPPNVtL2//d6OpDGdbZytMipKMeaoWOmDiR1q99XImVuu17e+4Ms3MefvvQAXvJs54ptFq/itbRf/gQVhFMLeZNJu9tW1dLBGSewx0CIrw1UO/j/MY5QUPajsLuxFTHrjK8zj3UuIn/XBIla8BKI6ETgDpgVT8TITC5xHl1mhvDFKaW8YTSccBWydzLPY3pnuGYLDzpEv5e+dhSsSR5CoU9RrbRQ5e/nppt2ZDQ9miFWW3YmSj25yfk+cqH4ED/6nxCBAUF6UHpq2t0sRO1zTNw2ZsS1Pw7OPbrjGkrlq95EtIlSU7VpbObfxQ3PJhbY0nImTs3lD0j6GPCdQRp+rvTN2Dam+j55JQvEDsBofQOqpzrcoU5kuoQXT8eRupKDvM+xctgbbJvbRf97ziIADesyj/6qWewIOW81euvPURGY5JxeUU+87ypgmR9U2pulRNw2R3lgQpPGva9R79M7MODnzcl0TJYhLFsJfF/WpRcON/N3QxeGmTjnjkqUBrtwxyHCF+SpRL6F7RGI0j434mG4HYij2bMfowXMjRJwGkNzICovVOpIO85IHc/mi1dE3SD55MQCWoK4MvNEDvkGqmM/EfUaoQEHCT2hL8QHZZ4TniOHbAhX47B7xs6VOuDKzuMyMhHUus0gp2rrQdxCTQkj9X7JI6EUf1IPfoL2uAZ9nfJ+Y3sCwL6Cgd5g+v+r8cWO6NIpibypVeY8p5jKDdxKhOk2qW4pVFne/KCbCaFlW0hA3kxn5BVLVGYpRuiy5xBqG+OQbxpd+XnmujHo8Lpe+g8khPvQqArWfTaJHTzaPhdDEAlYul/yAbDzR9li8X3BBjeYdf8m8tGv67Ofnn1wilylY76LKOVBZ96DtvWr6oyxyPk0M3eMjCIkeP+AiCyISGomRHgKhavrpR5kAMTHBRw/exBkNR0vcPpPC+V/Z64S/cCns7hFByzSryyE4jBx04coys8BrapN07Jo8dOX+5uxNRwm/ntZKXFJ+/sbSWQrgKSW71W4Bh0iIqzeYTEdVFeyXqqXafMBURfEKQjPvcSOTrlmA0sFfLBaRehKnoZhOlOfxOpBPqwcW8PSlh459hic2KLKP0HaBJcAJKcRJSTgGMh+42AKGUULVNm9Wuf0h050tBn22N40NiTIuZMgrQtlZSAcF/LqQM1uPBwOAnlxIvsfjs1zvsXxeg116rwwgRpH0xX/FigGJ3EzIgIu8Wet2nwj/fftFgPkmGZMaiIo8xOvEhJXrubEaRi1vI2bmnnCUFixwe0B5dEWBSx8Y4tI63fVpKsHJnKMLp8844+LCadjm9BcLJIJAjZpaZzg7g61T8kvtSAUYPDpRSyyMt9531UoyO6lBgu7a+7xlQa64GAYrq4LYiSAZzWj295OO5nXk8z+a7LbXnf2JF86EVTb/ySffQcLSMfxmXE8QIWFgIG8uLCc5el/p0hrgaweLS/h0yYRmpjKv+qEeSof4j7z9toDbl+W6cojXZtxH9/PtaLqP30VkQHFH94iFlOTFiSlOTKFo8Ut2YoYTMyhafCvZSTac2EHTor5GHGQKMKzhKe0TzzM1WlCpdhDEzirZAEJGoMWxPNnUxZSMZisbuYZtY9i4hk0AOeTmxnYKueFLXruzspc0cUwihgsXJNpyl3PsSQdH84uJWzUvEnM/e8W83qtXaeqoyVWRylDo/QhiNHq2oJjA0f5WHO1PRBgmgl40k18Ke6+0jiJLWKXWpkt2IozBQ860DPxqnDzGkMbL89ebdx7cslgHsfEEZgTJIUcwsyQZq1G6RaGPObbZ4yBBZxvkRvcqB/TarGpbZ6CBiBTX1Bh2+POUrbua1gBMp5upHa/VYTOh8TDdLZbBl53efGphawHWFlvXMeTdf4bc8oQn+pJq8kTvA9o1V5xfvSVjKxFcnEz3tES+jjOprNYpSREsMmoitdM23mhOhYvbik1WVxdY2m4sTq63tqxZF3g+4AUqY0+YxDWKYdc3V0h8YpOuy4+Tq77BHAOPbpyi31yfX8zeXdb/ujOVWUbC1dEtJg/bZBk0Y9qnSDcvi2UES1czMs7yY5spelEj1hFsCiKxD2VXULobZh1SiB3w6kDyPdvUgF1V1SIgWbrxsso+sM2hlj0ktjb+CPMXIMuSkd3fj3icCEdlHkM9GuxqlPadmAevm976cPNmPfBM87rYNI49fD2Yl2CVEbtkkZmKthxJZQvj1ZqiygGq1Hk+cgM2oX3SJ13aUNO1dpplhaVQXsK4ohHFZB7AlvEDipuh2CGZbQep8PGHKM1SvpvErgJlhmbetlDtHtAeHQm1N2czVyw/ddf7sP3MsVSdGsG4rMY27hVyvqQWR6wMwxhFayNbNiuTBE1eTMif8e7KD/7SR/3sRNCPVsHUNRFqxjseP5B9xh/hAnGBGjUycjuAw9ZpyFdEAkyRpSxAC7jiXeGSkjqDvu3pYfiIXFJGTALXJ8MyBqbIMV3AFYnOiT41mGpiOwV5ZVb2/rQ/OVsex7MvPUsoPDpYdg4WnX1GGyH4jp/xIOk2qEZlbIPZbJdHG8EFD5TwVbcqucTldEARVM9tbMh+wKsrKYfs3sKJ/2BgL33B9Iq7fJUNn+B3XdrrTFV80ZVeHq0DEIp8qRR6KAaLdfkZG6UyR2IE7WKZBnzOeL/+wJLGpBVXexANV2t/gKlKMHXlFT9mUd9ux9mDa1Q2stAfNlkvPFHopkH/zt8yoZ1NIeWOoHTiYUvw6PbYDQXUrG+rFhfWVn1i8uXGNbakVejkPW+oCp0Yiu7Y0WmcoSgoZuJKRR7ADJB/BwYx7vpCD95mDui/AYbFyZDW0MlX+iEs8NKrw7owdmyns5IuOMzYmhU4OYItZNSAOWfBe0c/XHE3+0rGqiSVcdH4AS9AKnOZZH+MfIhBRFiY3ePJrd/eDVb6LluxdDtmXfxDXEOLff4I9rnx02p5u8spSQtDl0d7DfrFqxXC4apZSPQTb/iofzd0bHDnZbljuPzf8C5YEgekVgVcDfi07hizUC0w+M/wc0mCCxShAlmwAu6AxREVa4/wAJk4Y3iGCCIelhkVZ0q/kHFpWYZFSb0Dlq/WbAS9nvwgmEVBEGYl31TDLIFvC2KSYhObnN5Zf6JZ3K7M+y2L68q8AoyDDW+YCC9daz1ckryCkXek+hHcOYzSNOac0/mXkGO429pHtTIvURr9maPy/nNslegmCD2niKRBlD2kYFWWrt/Ko6796Ajk1paxirhiA+cEFxaGfaZ0cn4qU3LPv4pveJG+peMA/q1bvyJIIJPWd7RmDsMUC5tRyxHrm2irPLFkbIxlh2UTnS6zSLokVxTnKlaBZZap6AaeaHL/xttNQGjmOMPpkit47SRs1fR/FA8VBKeMp30DgFM48mxyk9ezo0v4+amd3OCd00mrKBYRKki4toBxH6OWWSR7ewSbBjRCxFUcZgHOFMvPNMZxQSxdCNOKKcr33QTlAb5HcVnNm2z8WLWZ2hbHdS78C9S7JvSww2A4IITIvs9P8bmJTXOcaugijmviPrcR24gqcMDsvvCz+uCIb1CO5oTrgmsTiv44Iqun2M36lVdPYYcOLnit0vXktu1uQgaQPLoAAcbRXOi6JTPiLEszYUuBTURqju9puCKgfpQUf5VPzwgcmriojXAarqGj7AEfg6Vj3OhhFhYZnZOIjx+CuJgNDwuPBo9/5LwRRzLW5iiH/kHHaTbHnZeUS8OA4QSlRxKxOXLkMVngcA0pWl/Z4LmkS0oubSGNhxk596wZsEASBeI32SAOF6ghFwL1CeNUGRBGTrIM2o4p9qBk/CimqCLbDXGEB1Oxe6m+UnZQqawarcbFQYsD7UhCGGUkyy3o0TLj4xwkrXU+H7nefcC1YXMynrRQJSTNaL5CKWtmPVZNp2Cjg/rM5vyb7pUlQsx5nbHoC0rRkk88/w7KlwnJcSzvyR4tA5BZMnGS0XVwNzchjsaggEgOeZPiAwmmZr5RIJQ3foGWuCaFE54chvLSj0xjRl5kfHMIXfCg8F2FQxpThLfChkrs3EKH38REN0jghPdMxqQ8axlap8QGjjA8JYIVvnMFCa4k+VdgOvmdpKe7UnvkPwxcxh64FxlVTPfenK3j6csoCzpxD4ZswHIlnlXVQE4ccuIQBaPiibMHivIcn3jj1fJGIzMt1ycw6FOq1mT94GvdLn+a2h6zFwZZ4y+kpBChK1W9JbPuWXtirFP/RhDeROYiRznzD6hMnNdIT+cTOK5PkkQ6obKC+TzLq6xgeeYRxtoi5xfFZHrqdcAnFgfFOt/Edk/+LArboq7Oz/fizYobh6t+6SRGd7apmEgSd+DGOvkcEBmiBtVPZCQRSWW9G1kRJYj5BvXynQxJVSbSSOJx5Q3ANyJa4B/CgTHjE5gXH6vCJFXdZflg8hocIyAEyxJDqE2WIOLrpbn1eQmK7A6n5G8b91OHTNIRhB9XbpsrjOJipbw3W8F9Rhw6X8vtXH0L3C7vUTlG3NTNlYalQoGPodTGQeMH9138WgdfObK9VgLwniYe+nMXoeGt8Nls4iM+vYZN79ubwDXZqVFVxh1nGdjQnrG8Jt/owCDQShH0nTeYzmntQovYMVBpgNDPHVC6B+DRZN83Ok02gDgSnW07gUUOPjnYF37w3j7OFCwdsT58WSexidCZ0RM7uSI0crzBAybL1TH4QW0fMOzJ2oJ8BIfo7YMVA+X739FEg+1mZprP4+Ndu2KElvbX3ihJCt8R2hlptQeY2PH22n6szqj57Y6w4J6PLrJC1/7oLIoDPVIrZIWRmtpbxu9ox8eu1hQyp6zaHOXkNN1U5/lX3d44qxs6LW+CIIjezPBrYm/Za/xV8SUp/x/t5zSWmSQUCtf0qG2Sa3CagjtgS6wxZnamXqT7YemTprolt7mMB8q1u5ofERGpSNFIC2M2mfs+ssUVlgFi+YVmw0I3jXAfRdwsknGZ9Mym/x9KgBgwtAASxUdTXGVwlJAz8YeRHFL7JZW0nLJX28wTzDldnVTOZw4zjs7sp/TUJED0DtI4W8MB94Rzvj0YIvuooT9Qoosap/CtQcjuLRKgFi12erzRA/2mK4i7SAZ5PnMgYzZNte07yelTnx4i5UyLWd2VXtxGnRQGASxpVubBHV6/irwzh8n5F181poxjubEyItKKyBGKRCgkjfCPYxxjI36lWGEIxAOZFuOCTzRjxzhiGF/Jhwucm93z/wpKjnJqVbXkuzQr2JkMmLPjDdi6KZV1fd+czUwLyYH7Wdu9UpxkSvWeOciK7YqdeNeW1ixU6woWsVA3j08UV47yiMDtLDhwnHJZTURcWqZBq3HqULOS5hnDXFvAcdRYLq12MdI3s/PZ9dXlz5fXFxdX795MX+aCdxW1xq6MBRZ67/M08FRdhM1s7yMibyyg2K+ItfUZaSi1nUJxZoEUWZ7F2XKt0niTdCkMxKp1wHRtAdMoyWSYW2Bq4J6nUeJI73bgCpBgrp6GzAWnNDd8C/3vY9g0i6Qny7/Khk/id3trd786eYZlq3oeiOdDlS8fSLEK2q9ZwDWqnoMT7hUq8jwriphPWnjHfCFGs+SJfX1AreKAC1ku46BWmxMYXFEoUSy1E6j7zD9vAUeYpVwJQKAB1NL+pmpUdeyElxsscsFTNsizs6ar7enZZZTyYqJs7ET75c4wDUct2pZduNqS5EPmRm0bNP74odDamJctySE5MdTUuFjJm4ytpoEIQ1EiUrrBB+TyjfAcMcitVtRC1rV43VC027bA3WB6sg9EaE0g+bnavyqS2J3qlkM6QJTe2eDWvUOPTSOSqXR+AcqIjIhYJ9VxbsEZyrHj0oiibwZNY8A/cCgSCAr7d+N83n7gbr2AGl2mpLAjwrZseS567ycS9QNFv2CDa12kqqjoTBdpXiKZBrGfN7P9q4F/y7b3qukPoSi2kur3MD0ZECbCcZikC0wx510A9ln/8o3r92cBeJQW1lI/WMmXtWHg4heZpI/zRSmq6xzBbeem4QoVA9zEqwk3FbS0CYGVoKU9hi91C/kBS25Hgw4bL/8SeA+iAxOkkDJhnlFbCQWM1zUf7STjLhuI5RFXzkjuOE3Kd1d5X2x7rg7ym1EQz130pn1r92aV6bPYHcqtxyKgXMjiZyoA9kSWjD/VvasHlhhwg+7rcjKaa9AhDofL4Gl676i6rKgoJLpGCT+p8wfs5adCG+lgaZ6ofzEopG6HqObDkjojlCJSGzQK9CNLs2TqFEo7qTq1y3WnQyl68hUCVySUkHhtvs/+ejwCV/bOGAO40IA2E67rnb5AxbTLphuXhuk1abIUprMxpvghQSkfFSnEzvy7+P1W/Aou5dMr59t6zGk2x0EWxyhBcP+Vgqp8T4q1CfVgN5BlFkmzNpz2KzXVMgjOBfe8MxQH8j5MefvZJ4bSmAu8pPWMPPlADZPs+RW6/Waq8Gx/OOrSQrZ+lZlNPjQn3jrJ+6vg5dK7HoumdxCrjn/JIuHTpIn9GymwI4L3VppNgk+jmoQrnCBhKWXVgc+A5kPaeRqM9SAdRYpM6MeGewHtLWyPyDYHDu/AVrlw4kt7NaCYKGe5P0TDjfydsADdIxJDfhWbvWfpgiytD9fIzt333vmoWz7xBi1Uz5RPj4EQ17EI+tVAO39s0sU5gJoswseJYhSuqmXgBzDtBpYWdB3kGd8XmUfoJDdxopHUJ1jaF0hNqHBWEmFmzL+ZzWi+QqmHwKQKhsQnMKUZ9Y/xRHnLQVRPLmGZKCs7GgJhTWFh/ka2DwzwVBVujz2Z0oEce3L5sbudu6D38XtjvKT1t1UnMJusVVy71OGeVgPrnS7DjnroZD+EcBIsMZg4bI7nvxUO71T5pnuSxUKxsoPoBpUMAb/fmKLCeFcfR5zY5gIvGNHp9uBqj/J3e9iwPF+6Z/4kp77Hk+Ji/tj0uab8RyC8k9WxKerw0bm1dGq9aSQKE/oTSyBqD1cxrxBGB00DUbD8Wyam/u7OVTS78tTMShqaSHo5AgfcBUn1Nsz44vhR2IFRXajdSOofgY/UCGJLf7S6rtXMNs8Ps51D1kfMxCX8GBBq9ZMEknIzNyJogBSW50IEcKDEnB0RDskMsgEt4CeAkGRcCSwoxgEj4HzCj9CUwaka/jOvFIwkSoT525ChZzN5nlzgUmjcscnk2vOhE/K6SNCXV48uFqeLoQ+pKC/9yDhePS3TuzR7mNy2t7d+fAx3G3UNZZnPq11XOcEFOgLW2j5IWOwkgoAomZx1ar4a6p2wZreyBIyVYfNNg5J7LEIV6gAQ08MVW4X0TzzidaNpW5DJSxE7CDobNY8WiNqo8m4m1mX8MjGsh4/gqeM3nQ8SgYDeZcK/xZfdSI7QkpuGmxGG/DMyBTHNsuJovVEGbxWsKm0ig6AJFwP31xc7NggYdACJyLEjKH0edyEuO6zQygJ74ofXzg/MSAKwY5gJq1tDGGNEHTEEJ0aWklA2k4gd/RG/ylX+aJ+yb87OXW3+U3c9rnSyM3lmo+/2UcTuaIcMVQ64q5NV/tyRCcDuyJUl1B6LNYJMzEvKqjoMXCeAiftMOqYdrWl0oJRDRYNUBpG4GOcxWEa3kVZl/D+R1lABEuHyD4mOCYor1/+jC0I5LOf4sRtOdzKHuK6fXra50PZHjXW+1jVijy/9nw0r41giU5IuT0Q2TOQ7kkYnIpvm5OwkLswSWZxqhHPna9mF5IiL7DWMt1H/7tFFv7Jc8AOiUDiROSVBD8qj3dOrYX13xCHP00h0y/xAcZLdQ3modBlzTnCSiYHZ2mYsFV/ZGOT+aD3ntlEW31gv8diPsqPqnptNngCZZGAFs6NdOd16pCd6TluvMogxGCAnouzG3J6X1oeVlfc6mYB1ohrn0+3DdcZCFkjdyt/C9RaWxffHUySwNdJyuYSBUrwQcR2gl4VlwY5ysOrnACqX2lk9rRrX51edP1YUBUrq21PLAIRk1tcQjeS6bgjR0pgcgejWcLYNopMHq9f9tCtQ3kIGS051EZspbvSVNA0KRA1FrLoQNoNDjbhQ5Twvrl5gnFNL1cFOWVwuyWJta5APlBQ4iOPEjGPZyHJPLvznJtdDNpN3VSQxXzgQ2ztRaG+WxYwTl5VyUFJSPOD5MpZVdQQELFtE9+YP24PcLASWRFE9cOM2O8gBZs/+QxSppkY+tCFShnhw6vQoI0WLjW4HxfbUHY/msJmrHXny/DMkZWS5KiA58pKkqgi9bPooW5SmMjFL7+5XpZ5LCGNw/gEmZwQOQ1pLmzhX42hEvMN7EuJGTiBnUPKSwsEpFZb0IMtBDoAmu3YLK/wPZf6g6SQvdMw9mp9FHg8jUMY5wbsaf6NwFGF3GsuT28noCJcX7l+xefgmFOSDOf9EZRu704nKlna4E6GtbBePFsf84i8BJ1EkTxS3pJWeCD0poeHYPKV5zqkpe2C4ldFJP7N+RG9R2LSv0R6GCtdQLFghQy4yCoqg+HiN4qZq1LJGxFoFwcScMbJzYSamsD4MyJycZiLYt111XlsJ1VMjOYIPGf2ROf7tIMG3Mn4dfoAjWaGKVY6IgfIZI0Ho6Loqy8nke9ShQF763jxu3CbDtw/mQxsVjwaS+F+ap/+fJmtJHcrp01d62pP3DMS39zfi9zRcESgTwg+VX+VToSouMjonUYRTKDanS6YfeT2bEbzpwxalasqgxswF4Mt7KslpZ12aCBA5bFsy7f52mMAyjWpshJID2lTCopUswjo5Bq4QPeCTLXLLuCPlIEKjK7q/1art9TfZII6cEeFfxsCMq1434LEyanJc9duXqlPDGLY9tFutdDsw/a2l0OKAablfWNsKEjatYFBgPcvXdTq0qTNCDHXKVihNoSqj7Px48hUMDTZch3GW8O0gFIWbY/xjsjsaDwrLDI14hWJWYM7YCS4of+RqsMfMVKoEuDiqTkpmjw5iI3nLAYpNa9r0yXAbK4QqR0BDqrqQ49bnYnAHO3479jZW4F9oSCjsyYCTW/H2W4wWOh+UR24MtBMflcCDhyxIKA6ykB/xnn8zigP9QKqz/9btN3WzqSvMcYiEXo9AH0hrJ1ELsmkPeJATjGNbEn4IsiE1oeCQ7k5Ye3nDt23de8NK6o21cihT8+qGsQZZPURxWMYqzbHKDmvk+uIZGJXFBTL+4fVDRiPmG0K5ZimXrbE0BgHYOn5mWqB6JfzUWoaA7Rtv0OtCXH9Uqfd9E7HVuqgcAE9L4xCMuvpmRUZTTPfc1VEBPK2OPVaHml4cBWydzLOpk1VUtOrrG8LUJ1u/1Y0VMD6BkBLFQPb/Z2KiKGlY41/IBuERBVm5WJAf3s0rxWZQOajeYk6SnnuksYkCndW9EHOHr1EnxYxYOHjDOX/yer7s+48egV/Y1qOqvjrGYcbWrMCJMwTFTFTxNaL3yEuMn/J1sQLTarN0/FfR9v72e798vN4cWYBY4e7CxagdYz/KVLo9xWFJGbn3D2GCEYM7Xz5lXITkSh80a4yZgIiPduD8SYQmI2jy5uf233OXNJFRC/yTkPmD+Ymv0nLmWbR2C1HN49k9/B98UsA+4IWflKO4KGlaazv+Tq04rfnHf/hel3fLaBBrryLvyCiuqqRZuU5OZBalIZOGj+IxC7m+JIv4mIYH/qZtVP99+0UorN9kQiYleoahPLkRg2JqpQx89Gonm1idnkJ0+GOK3b4KnZJus0yzeEDZttX7xebnF7N3l9eNf/1T2LyD2NWM/KVhQzPyCeSweDOL0Ji082722zpHD54jIfierdPQiSTcJown9wNWOCR/dHjrVjQOMJYZWozDEDTvR0i6wpTwrw9NhEBsw1Uhim4bioS7qWmRRcsrr0DVF9+eAOoq0PYWVoXCyO32oUt68rQhO3H8jyxkOrnnfVu4amN3Ywf62rZ/Pzrs2/DxYzOADXZ212hIAZmWXKPRFv7auj9zxKOWLfkjgGht3eYENe8UJu5yLzOU69UhpKhVfnRg/jrx4IkHt/CgrUPZfmxo6mS2gxhWj6meUmSULuGPuPJm+brWaDQSJ1Nj+wplB5T6BgA7AHNr6TJk13y0LIHONe7GqvWFRc0mgtkLWe9WwR9ozWsEf1DBBVHAspKG7gnWWPAeUahzE2A2p9Dhy9CZMEAFp85c5I+QxlR3KtbAnvUKySJ+CmSzczuik43boCJJEkh3PnSH+Fk86TlTm5mBIRgSgEFOG+r0v9E9ug0pyYvXO/7XOfJfstc57m8le6W8fnO7QjR/rbM+X7/OkX/99evrHDhocd32l1/na189xrIuVVlJxTNmm8WGeNziDGxgucknAPguX61ZO/3UV9litnYMdF1kdyIJvLpF0omM1O8mlvmYARdZ8BeT6UWWVgb9HVqquzSU5xhR5TVmhAB1Dw0avK8aj3Xexw2bvxWvA84DkAXTSMj1OOqDpYkzYZyZyCA8LgrbFeMVBFOzQx+HQyRZ9gCHzoXIyN9GUjgfsDjAJ4C5Fo5HXzRkDx6pM2rUDGs25vvQBe2YZS59mqFLZ1MiMlIsUEL4ejY1MxOy7uRkevGCxhnntBSTR3+410yqmsNZ2ACaPZn2GDIGH6quvdpTW0dZPL7d1nIBr/Gkl2fYNBK6zis3Hsgb+PBuSbMyjTyhx0n5qydnRZarGEpVn+bGu7lZxNlDAN90mhvv5galJBFB7ycZX7FqzrHyPfnErd5x6xx2X0TXJ2YFaohAJvimE6v6x6picgSWE7NW9cJP9Kh3mup0f6LHwOp1ZIiTPsbZXRyuHJOkjcQpOdIymWPXJkkJBaXLGDtGIuYELg0ZXc69oEqOaci/OeCypDVXT76QyBH7QvYwRBs4jCxoLr4LmsWsXbpZNB2r68nuIcvIMMi+72570yjdUmFeFkWWvnoysJhEvNPXTgaSQpi8iHQ9sQSBWqj0tZMhQgVKUG6QHSy7Yu9JeiMH9XGk54ew4pULpcbZSwUDW+Y+R+NmiKtkMGrJA0GEF6iMCxNOgHtNQkxY8Wp8AdsIGP+w2BkBBLPmJ7R7egx70B+6Tbw5Ozdw8jxQcroCs2Udu6RPT+t3CaZ7EHOJZVgBdomop4Y6BdM9JgkwrvQjnKJ5jKNK9hyHbnrwCnY+D4mpGJ7XPQm7tHSD9ju3StiSonwVoBTF67/lwNkqo1DJUFRePlMk8cOFPYgzFAXiLWZJNdwTku1qpkaOTntdGto+L+tHujC4Ewo0Du2vcvzFCievdvKlhH6tow8WMdRQT83JvP0ROCHEEqeQ7hYHIWPBPaIEFLRXTI8aBggHH9ijjcMtk0gwITtRRFOE9yABMUdkgdOFpEhdBNC5ijvIMD7h6ko7H5RwmMm/mCaZq5uc7vbs4lJtiKetHJc7PieWaW/MU08ev/iBB85c0r78C5yYzR/1wOD2j4QfzJd8vNIa8Luy/diIgx3o/jeS3tnqvnURFMb8uGlx3AkS061+/IKKcGWoRmyfx9gqe7jVg/+SRSg2z2otYvOJlv3jqOY32/eA6nz9jzmimijfM8Q8uJREUWQreUGLL8qcsyOuOONPwkoUM8u8wczlUdoZhW80bfogC8YZ/ccKxznvQ4gDktxUgSVvOmiuDU8/V9hLimFB/sG3O04e5gSG5EIF4TZEyhPbGgw9ORCEnTPFH18pSRBd/wJtnzIKRHKDasOm5RYH/zwtKrnxXgd7eoEsy30B1lvtRSYW+++1M30Pk3FVABdlTaDPjVtzy2JfsHIFRBLjnVuNIKSYCyK55GmWOAI3vDf/K/thodLHAI3KgsRaKHIQ33BYuMrb03LufGt3OiTvCuX1czUZPZ4wvXpX/AOx2LF/zcyciTuzv4JuanYUvX6F+0I7KltLYlCcZOrS+MKJem5RQ6UYUgYYy2LZYqqIogfwkUAkha+4zVeY2nAHGbAGQF3EuWRwc552I3ns7fWlE89UyyOumNu4FaLIlssYfyIx/vgjR6JquGEOg2Dof/B2sbmjvOCnHege2OtrxohWezibXczeXV43/nVgCQNkbsBsNYx0sLg671gnyuAisYZCLRm+DXBRvNLW4QEAphcteKh94t8FWcpmH8wv2a28+Oby3bvZ28vZzxfn59dXF9dv3Eho+zD6pivdc4XEuPC+5ccjLM9C3b5NK98iHL1hJ7NG/2oZQrpCu3RvGxGUN6tkwu8UpWyR0cQVNaoM6/ZXQkc+gHhyQwVhSLlpnkjtE4NiqH1SofmGVdkfD7C8//w5ZZA40RPafMEFJeEmMKZ30XlJ4uhmRXJhXHJhaXN9mnJ0qrEtj+QZx1x8zQZJ/Oh0D7LgJQFy3pKPxMYdZtYx981sHxI5hy++Y+YLHFqmH5KviJJi7QiRCrETKmKWlzEq4HxfYAqilrkHJerAfMALTCmO/iT44Ut1jWgN1qCbkRO6DB6lLjoXGhf2j1L2MYy4GDy/uGzNj3FMkEixCUm5hglc/1rXjGv5GmyFf3zPvqmEaLY71xeCKCL8Gz5GS2yZYVp3gX0c1tcwZB/9B1uzAieKRwBM42RuW6xtcmGxjaN/MecUxE1Mwjsf5HyC1nOOpn/Vb5s2cMkFFvZ/yVTPBLtSD+T+05S0DN0PXEn4gGxBMf4b/6ZD0xxMW8/87AhDxb23BZfEbnBsdd1xgGej96gVLHs5ixjGs0+8uxu2ubFIjf0Mla6xdA2VrvG0DJWuFTxxgAUVz93BlZbp7Xa7x5ML7fvR+QnRdsTCyAPiW4fnQ9vxE23eNM0ShIYlKf4x54fSO2mBK/Si+Pn8jVUnjdqIkscoxLVH4Jvz67Z/wpUVtkRhiBnLJGNWSQ+/E30Se9v2YTF+abvdbbIHx8r106/rOSWRJSN60/NK9A5nr4b18WrmysWqewB0g6T2cHQEoI67tAFgqACq/eOs4oDviC7d+FpWVm8LJK/89vln5zH+Y7Gw2fsg8YHnPqZRnpG0+BzZuiTtHFO1GHYe/mpjGjbdxlvvW9/Hm+xYzTckEkujar6/KTf6txacH0ryD7HZKZbnSjyAuOE7jk4c++7a9PDhTh7JPn/TOZ8n7zYvaZ4xSI6L4wjsHV9lwyfxOysTiJ10sLs0wiagY9OiJc/yljrxaNrbo+BPOgqMbZdkWdkTf81y9+7hzYigDhDj7n8QAduImmmHmlp302brNKzDXhf6qv/fYu+zvNs1Y2icxkw2LdK2rSV1MLk2H/Hf/yXSztZXCLbtFcNOMvbDvOBg3twVPYi++UbSpWeQwNL4fZ1jF7A2+a3aF7TuQ2Aq73/rSZptba5DMR6257kT42E/0qoO8bDNYINuRqcLhtMFQ0P4VawhyGH+sDHIkxYcvcWO8wUXCDbEG3MZsbef3NW+h8O7efajsiBYXg/3EAxPYlKsq6tYTZg/q0culkRvS7a9LFYkwk7z2VVHHAsrYiDziNmlr+Su1AW0U5qdaJqutbztNHj55MJJ8NGLa6qLy/bfKwcHkl52DvuoNhq07SPJUUFQLB04kzyuMku4Ik114fOfEqWFTiYxu27/tUiWMEvyssA3GDZxouz/P7f/Gr+Jb15Eq6XVcFd3y79Vxhd3cyQ9A8o41s61bilSXRN12eTJhY/vo6UFKybhA5e3/PH/4LWdXFO1gRKKDQn7DrPdszx0i76ru6qZm+tgq+PeYhI27s3Yur95tHpV5Oy6+9qSk4HMayWnlFmPVK5izy0cSmSo0U0i/LqYXX8yJrdxMAjpdWMpAv0mSxKYYERtVmWT89pwH7zs/HGX48C2SWSne/p5549tS4j1udl4IHIKpNLjbKNoVFpgDfNxHb5gHNDoQm8OqEPxkqtZdC15BX7WVx62swrvkOcDtHmyFCa1IEt7Zme3SQZ3yRDXiSgbG82sg+Xa9mWU2GqEWZT83dhuLN9Sbgu5vO6AMe9mKffe22KtKzbYgjBaHeixzZPlYEvz11YNE22Vqsi4j21PGbbUZ+/Sx0K/wxuDjYTJvSU2JTdpXeAnPiAcVJoB11e+8YZv+vcQnI/snLA6yvSjL3kY3r578/Nl/e87m7rRUOyUdUB9UilX5IFE2uc/v7m4vqr/tUkssV4qC7++h2mi4f9eeXBGtUyjxqFIKhAfZENLnFlDNdJj2QGdRiRAsU2lgchNmxJgU/I424re9qzg1pf4pppc1iXzxlNKUwLanqxBkfwn+bs2wlifsLYrlZix93Es3eA3bfNWPN3e5znHgtIQ38YkwtTCmWH3/uTancx6WcY2e8g98l8ovIMbO37CoZAeJsWMuSkjt3s9uSlstyUnvaNsbue27yN6U3MTl2BU/ZTR0MbcZHP+TfdI8S4/u0WYtyOum589UAiEdVRlcPCs/mjfJ9RBXOBQqWXHYZKD4efWjbtIR0iKLXjNN+HbAi2XkBil4EvGUeDkYPFZ++WPLZhXBlOl2r/fsDBS5XdiYXi1I52Q/rfZouCad8zVCW0QubQ2Vgv+0aqzb9L6Y8t/qO7OPDk31kK0QN1++l6bq1NetrUd7m2rU9vd/y0fSwbKFdqPdNmWZsC9cLM8I01Z1z0iWii10ku+YV362ToX7xaG1tbB5jR/Ko+A+YWwO8OgSZ1mKwEga4FTAigANggwWKz935+tu9lyNVbcxzInBab4WQmFK/CWx6m2XV4+ObS/u6sH6oDpwMhwdKem7YWvHl2tavtrS9oC5PWJ9HpwsLb6C/zRmdOdB/S3jUGG2fN/5cZmHwDXsHDhEoDO/JCV+SeaJe0z2OzJOjnAHdVS2cxBfpShcUIkOZDCoOWKfLXacvvoMFfxpf3BNw3XnyNH+k5HKDy65QArdVy3ely8vXbACTD8P1Fc2qonO8QD37Pfq1vymYVwDXEx/o9iRbOiiMVVq/7ZfPrkcfuT87XgdiVYJ39fR3I8Aw72RJiCY0z4M0ryWD5v4+LX299usiTPUqxUcuvCnz97H+crZNrtfteJ6AjDufc/Azz6oAE61n/cGCYaBxEXy2BwKhxXUbCxNOq0rHJFfsDzcqlcKGwmhVWu++3ebedka0SHXlqk/D2KiSrClq/+PxIVK8vpeKF4e1Wz0Pa1eAvJNz4Zdm9AdxT9cjYNNgtLhDFK8u+Zs/4zseLz93xftt43YVAhkx++24O3yG+Dou/R/qKzu900MjQ8OshK56AomE2eWjbci4Qou+FfJjYZ5lKoWV3Xt3xVc+3ujxyn1umvTrVcpa5Kkz3aW1kiGYvovXJpsr6++dT/EYZlTnAE8sU226nJr/SJV6/V2LnwHixWdWV7L/2SlQy3cjvPHJ+jbNwtbuH/R1dS17rMAY/W04aXulA46jrAftDecuHXSt9qpYSeOeUA2yTobLpWj1Gb1J5HHzZ6d2dp677MAyqAC6XDei72raqvazwbZLNTWC07m/088WMPy66nblijcYpq4HTrFM+gAd0pog3XGfYy/28yQ1mu8mdD/9+Q9/W4wpyHBstJrNIUmh9up183o30Nw8Q/cFjaCO92M9StFXSOM/JkY0Ga45RQ3eHeyt9/odan+KjvenYGMD+6nGYH0fU1HvDfxGS5mmf0BseOSqT3ecL6SXxDEaQJGIOfQQrhQrWAnyA1U5KFd0FBMQ4YgYQ3gah4TM/Ef5YkTz1ewQE/CjFkXRDNbuK5FYt1x3aH3q865SzCzkIQQT1uyG/cqPN1PnOYrd7muAerjDkuZTo18ffM5m0ncmREwbMjdqmuR+/Om3q7vLda864jfV5XlcGW6HPqum7+kr2zzasgNvDYBjvtZz4XPyyfcuoMza4TWvlQNG3DhDjQvjvAuIiCPMSW3Lv7neuObWwOw0N3o4gLI6k9RbzTu8gE+sVKbFunZ4hjlf26GnYj7fajM6K7YfdfKIoI/7rXyva8999IeickcPTjOK+dOkMmaYFpnsVcMfr19jf7PA8hHG/O7dg7N9s6bFg+N+9tdklepYn7ggtKQjds1y1w4KC8gsOBWx+wPPl8Q+nSXrKSsRqufShV/a5fS/wF5Y5QNLY6S8ljoD5Eoy5NkYn+fy+TOabuiNDecW1YATdLYjsmuI0qrxspaGHnLbIsLoiyOa2yBxivzXwtg+IQtp9KJDqVxw72ob4MfHQugy3b/2sL1MxKCfROBreBUjn2L0Bs+bvv1EFdHTvcHrQtHbK7FelUpihIlF0nb3vz7urny6vL2fn125/P3765eOv6JPrmTAG5uH43u3rz7trl+RAANOlj3w+jSQqBxHYdQ8U1H3CuHZVtc8wAolvMpWpBwluSkJhL0kJ5LLdJNTu/enKn3j+6Fi+ceWxXn6u8h5zvLFYu93qD/wzS7F4XGnMquRycZ5xZduxeH0DUls1kdLo/cXKT19fkb1RHi3f+uD3V2UbTmwz7l7rNypONerZiKeiC3u0/rvKEdXFYWyqDrGs/ffYXRO+yezfhVpsKVTvFIeMKOGO8a/+dOTmRWkfRV7etTwe0i5lI8pgs1m7oMMJIbI0wu7227MclajEWEYbm1suSNgT4la2RCgE1oGs4Vi6enI7/0bY08mHhz1xZZx3fTbt1TDXO6HzCF/z1lECBcmsZt7q9BqKo5hfZYK9+3QgYtgkhmeHXf39wRAI4vqewuUX2B8+KLLdzI7mB662EQMp0Q2Ky5ySNbuWq/xWjyGltMStRtvXYZQTA7f/P3ts2t20s66J/JZVP91adyMIryY+2bCfeO451LCX31Nm1CgWRIIllkOACQNmMK//9ztPzggEwIClFABiJa1U54mCAeevp6el+unvF9psIwNSDNFU2nwv9bI/qIq11Ot2o/Zvpkn2x+6Hfx/lPORx8xOCvwyQqiv7y9lQ1pNz3Vw69d8unJkj30LK23wUKiiK+0PLnfVlg61znernL42l+xZlB3uve42wvYQVcwhv3OHiQPh/6NWVN6knK0nqwSTdbWDnfx0kRZVfLeNPz7MsOoGmZxK9n/mfsw2Aev717IFXIkdPB0B0JcsaNUfqZs6hhvI9aZuaZRlgpB4scxmWwu+ecR0sbNGRuIfx+jvL4z2GyOPeh2NC3GS6Yarg9N65NdM8tM2F/qKYZN2OXvEhds+LFssj7P/b70atUxHx1qb0cD3iwGO+4J9Ankr+5EHgiPfqV9L4n1aXmNeEEOvV6s2HX53A9jU6sX0TkPJjG8F2i45Wu2L+F9/EiLAQgaOg+Ido5t+YoAXzwaapJISfQIxmTfLgeVTVGu/X09w8UKUVEiTH06K+BWfj3YZWXPYvPpEM7GR1i31fXQxrFIa/SLVq+IW/TRsbbq7Zdtj5IslZN2eP1vkffRvMoy6KZNgPf+wMiKk8rIseedN56B0pM7gAtl6bMwRMU96vkr2EKBtUrXV64g4AZny1ipdluNZKh3bskdvsC8rHv15Z3HvecGvqpWGZpUSQk88i/Z92eqQKlpEs1A0AldA1ij8YyhEisqA6fe4Lv5i2noUP4PiROYgi4AhwNqf0P63k6dB801y5v2Otm78AF48Wqf++R35Q/T9+3zLoHLC0KurPnmtnbsVCNHXcad94hmVcb+xzgJqLff/u14esgu775BSvnJpXulz1cx6tQ3T+wK1XLPezIIv0SrQORSjJDhPFblHyWBUmPfTlyYjT01ZA8Iliyt5OIg9GulojIM0wgJs3hoO+7jMl09TKucVDQDAa7GQRoVMOfvIDxGu5vzzaVTGOh62bE57/eTObqe9B1auO/KaZg/oK0BQpoVRv/S9htVfvWcKmLeg4vccjO1HcIkBar05DTUrdB9TQlbTrbvpdkr0Ws9ygkhwB33we5mnaiD3jAlfBZO18Z7YJ9ayHqHkd9SiRRwS+3MtJj/yejrgLqGaFETb/ZDaL5gOJ4FW5ET5SSVp1KZz3tQUzvcC6JvQfqOqSSGrZLFRP/5YVf+9+gpDuoFNHmXPISLj0mnPL3gRUcfUCNKg5VzQ7YA6s7BnKvamg9ugchcRlWt4dC/4KT9jplO6SnjOLD5Ktvjl0sRM/DHyKHlXHs/dn6TiSPZXMWtmt2TkZ/Rr8OZ+7bH7atdymz3p3bdJPe8rLu6URvHGelaHgInbC8+Xq9zji82nud8eHc2vfR/RA+7c/Y5NDc0+dp7mKaAVsSMs1tP/5lA4KW9uqpe5xsOif6mW3TAvfCKmW7lPD2mQ+2juJlD18nyW0WrvN5mq16gdpUexCs0yKe7262d/k0i+94OIYhpqIBaO57Ior0F5GDsncwd0CYL0UGPXGZ/T6zL5gOtWwt3wdH9Q/tSa3ti8G7Ytgmvd8hzamNzsxq8F4MtQRDMClScJ3FBp1jqixnNzcDTIdpT/QeqluFy+59FbRsjd1P/raIE7ruk6Hr05dkurwpRHj2/oyR/6hDSucWL4hZbGPdVa+fkHvVNgG42W7KoEA9WONMHXibTr8M13qZ8Kzv5qvBlYfpgwi9UYTFti9L6H4aHExt5w8y83zt34SzRTRAOA4d3vjXkJvv+wvDdPaf5rTHsEbte6wHMOtBHjtI1GbncuRPyn/Hwy1BtSP+xDkJtmd5ztj1y397jw8zxLSQF4qAQzCpFHRzlW7XIpxudUJc3x1o57zl0ODcPE1/DSgwPmO/39qoZ9E83CZAiFeI5PsA6U69/tObDnZoaKT/vTf8vXCDEW1fpet5vOjqbnDI8Waqh6y2+3VCEBMwsFQ8jHz41wkcyi+GuwpZoDcJ8aCE2v8UDLD+R1BgH/NwIHD4YNqIsTeyXLv8dygGWOkE/u13RYJ6vJnnH+3GMP4ydvn3IUEX/Y++dk07R887R89rIRW+T3ryWW62LM+L3rfIEJmacglB6t09eA+PHMZf+SimPfTeqPiWv5ytgWgmjEW9vFHfxH++tFFXWh+YGfbt+36QGZ5Ah0CSp9QfTaY/if7oh8Ww3YkoANT7JP16IvMzi/PT6pEpvdiwU9SwZvUeZmL/lv8+0FVJ68IQ53Bv1/ZhD+IlgtKWWsThU0M/X4dlNdU87A6pA5K4D2NoZcBcT1lN49N7DruacXKY3gjNCJ8QBJR8923DXh7m0megDtqM3VPHPhYwoPXumWbyKi3k7OBnYlFPNkPNPLtOs1WYsNO1YqXu6aQPp9Moz1N+1que3MZRX3lN2+zUw4RysQYCMfbQrjbRnLGU5FbCEpxR12CxOVklNel64OSMHbbfBo+zekBuHoGB+T48h+ufwdSjcX7vOXPeoFalXsmOZ8Dti5+3HSM9U1gbZ/3eL0/tWYHSRBkOHG1cw364tf/1SAziz49hMV1Gefcrk0WLOC+y3Ss2E1EgfwGI+DlFwlLxewrE6zCarSRaROtZ/556zXaDabrabItIwX97CV/Y6AbbL79SIVjGIEEofg3vxM3SGyaeQh/H0hHr/5Qzz6PzvopXmzQrguhbkYVTeG6znfiByt6pIvFwEH9mw6yY3HcHUL4YN8pA0YJ6jG7aGLVIJKl0cd+H5k9PrZB58JE1DIbcfb6OpG1E9zpJhiC4OsUPs+84zX/kBUNMgxCL+vAQOmbPe4My/F5cXet2z4WmK3iz6yu/V4uA1MelpTb5sL+8YWyXfSmWIR28PvNniT4MSgRNnPD3U1iIvs2De5dlaCy3caMOkdfGZFEYxorRr5Ak3I16MFEKdZcIsyL78Eecb8O+3CpNIx+8Az9n6XbDUziXKCr7rwFE5e/P0UR8pvYztR+aiyGiB1jj6v/tAfT8o+r/+12EWbwq5ZDLSfX//Xp5Uk6q1+t4FSrY1NAdSjen1B8NY9E32Qqj6E/FMkuLIqGrlfx7Zp6afrlJtM63WfTpPsrYDsufb7b2Pefo9z7PUNlo74Nehbu76Ao7QUdYfh+kB0OMnxM6rmsDEXtjp/VP9wsNXtuTSaPagRRhdG97DGm9D138PHP0NU++ocY8HWqrKyPG90EvZ96AtzNv8OuZdzr3M++vYeXxXskwpIajKp8f5LjhSyIOvJtpmEQDXVb7BjccnoWhdcRNx5/+3Y4GkQDYzVSNeqgtWr8eD3gVeCkSgaK4s5L4rCR+CUriXsIntSnZBj1vlVvToL1o7MLeunN4V57EzJxch4y7ttGznhU2rcL8EDfbaM0ebleDcFaBtLjZMKEpTK6XYR4N1I2GAq2HTnBwlgY8KVJq/bft6i4aBHfRSphDmUMN27fjPbJAi3nJaw096F3OVfQZzX4bICOLofkBrnhhVpzAHa+mA+rLGbDiUkGJKeCI+WE9i771Tg6lSOj0PnR2WG3SeF18GOIOJhVPzgCoiIGo7CZiRUU8HZrSbP9y7E8837OtkTOx+oGEViJZsJUQMSwuLy5dxx2NtT75g9Bh35NiIMtTWJb34SpOdgMtjLFHn2U+0RPpz6/hbjDKNXbo3XweCRfFZo8GYnXAoBObG4zJeYNwEe+vAXxBbtPNxzD7kt5DjOnhWKmzriHkNsWqBkwQNdC4+X5/YeNm3ZjfRnkxkH2iby+aQ7J67zo3E9thEtwLo8J+wmGYj9TXSVJeHAZwOix9XgeSKfgZN6xUYXuD39KHEWzsAXIh2oNIU6SVe7NTF6GXIUyR6Ig43y9rxLfpixrvm6j4GkXrl3NFiPtAtJzCYPkRCd51vnb3eFC8mJ0kTkWhtX1RY345TEScEre7TXTOuz3Are770GfGADijY01lJ9O1qq34ZLqla9xPplPVK/spdCte34dJDCzKVThdDoVgaz9shLXrRR2w0qL2ogatrHYvY9Sg65dnqiHKfoEWKnZEDm6deyFiJKJA9hYJs9UmcGmPvZHllv8OxVhPpje/xusvp9MbQ5TCU+gWlw9Ppjv/vYlPaG4iEd71VPbWaW10pYs6qT7p8LnT6VUJoTuhmYqT06Eo3fp1Qj0i69Tp9Ke0Hp3OoXYynWmA8E6gW3H+S7xYvkPunc3udFh4TktXRJkM73YCy/dHnMd3PI9ofmqdOi1RsgL7OhFGUL1rnkanKhqPE7mTVNQRJ3KwVNGsp3PaVaxgp9Otk6R1dOxzuD6Zg09DCw/QmwP+TifRnSEvKgfcfE6iO5qXz0n0R3fyqXeoc53jBiE6cqnw6zgm7H5v0Z5x+OXIA3JXfpuFi5PoyOcoj/8cKExay6R8713ZPkjQHK/H+U030bqn7VZttCfbUZWx9DlInZGxNa3wU8vtb9wZk1JYpes0j0FoAlLi1lh8jzs6XX9Mt3n0Uaa4O4G+/L4x9+SvQZfpCUi1YF+l5Mhz/IW0iqt0+iUosigKWENFlAU8V+kF/ef5GjVb6e8ZgiNa6Lv307NvCaYth+ZwklQe3tcY74CiFA6kq3TFLrGzN30EHS1b1rKx231yd4z4032YfAyzRby+SeJZlA3Xi7fR3XZxO8xUNNa+F9+3g5PQPwX2y395s73L1wONtnZvPN/Wuro49UZI0yTNoyGcguXkjvqcXTna70OIKUMwpmFIyet9v/S7SWmkvfN8Ob+9AHJj9mrec1T3SqMi8unVEiahfqhKz4FMaaEBDvkj/lMlHPb6nff6FHQ8/dsiFneaIrxD1opomLg1tX783147IcJ6i6kf5kKXRZs0K4TJYrt5/eEDI4nFsg8MvJr7KJ+Gm+iXYtVXEr3aoD9GRRZP86HO6ucraqoVXqfZKkyYIM+nukfamibhanNp9URYBnYyCCMdYKyf5vNeElQMN+BpnE23cfHTXRaFXzhuI9uuOwjyBnRIwNEheAF69itW4S7MI4pCfiFdQgcd+OskecZhrfYu9kAdKPprvSWm1l/Djfr7oOv9XMPEHMpl/b3/5oNZ+pkX9yYNNjsxT7Np9ELGv1nucib+om0KgnDNf1+lwOEnPYjFWgfoKiw6cM3mQGyE3uMwtHSpzCLUaYfSO/al+/AuTuJih+N/FrHysEizi68Z60+UDRQH4tBKfR94VXq3zZYdEgmVRI/IOJgP0qciTZMi5lls8mX6FRql2zTMi2EUDKFMmKIFy+EZn37O4tnZ076rmYbnYhQvlndpRp6C/cz2EACVyriFMu19Fq4GOr918YnJzLX/DTkZ/fcmmi2in/JdXkQrxbThe6G03Fbtf/3uEbIw/0ok+zEVSZ0GXrIgY59iF/1PX9esxWW8MXap3z3FnrAjdrGIsusQIL8ejMb7DrH+eQrIlpNJX5JOW/v9nF4mJjLEITbdTZPolEiv77k3T0D/woSJUfa5A4Jw+p9tnNW5otezSIVskPVgHt134gghYziOYPdMikSJ75N0+uUmXm2TcABirLLj3k+jOQ2+iDZ970HD3W0AzcxRt5wB+nXIa7VvNcBhrjHs0ulkPIQq6yBr/z6c03XvPEXlfuaixlCq/9qpNvBdefDLsX0St+FTuP4OtBvi1SY5DS2SN/Be8E6CFL1ToEXvr4GE7cGp8MXoHYJhbhn7NQ9W3+RvvHP33gvzraP3q3/rPaP7nhy6WZyCBqLvBandHvpmyi/8ulDVgAyvCLycVP9vnYBecOA+GWWX3vu0/0SzR9X/n8QZP/jKGa7iJ9MneSEaoEP7UHqDz4/5vtLo1F99epUFxKX/iPNtmFxn6SbKih7Sw+o9WObJVZqkfR1RetPscPxlG/U83DBf3qa/88BQfQ94miZJuMmjbpP/CY81sRd/zsLNcoCxEmH3u7bkelBPSOH3n13bGPm5h34Y3VWv0mWUK2Y3RC+IveQ93YL01vPpMkLpL9sk+RzNsvDrgJOQbPMiyt6Xh2GHvTBzgH5GPuWI9J/uwkwKlL2oR8SYSRPxll0+pkWa7W6zqLfZnqarzbYg3v56WsT3cbHrq2mQNjwBwniNT9xslkwmzftqneQqrfnXUupSHfhraM73ffgDwO4fzewO44A2/DFn90pwPPOEFhfie69ti0Z7l2UhbDUygA0q7Q0i4tYO9u9DyxX2KUi79mlko7N7vs2iC7dhthiCE7YIu/2ywmm4KbYZyUAghieObPsEvRg4QmnpHD9oN9oC3/dKK9G3DXu/W1XI/tAqfV+/+pWDRXTpAfbiEP5l+yWDZxvezyCHQh6Uzrb9SqLv1gj2MhtqxV8niRz/EKIoa1423ffwSemBsUte833AttmV3x351kT71z+R5MSn0C9NJXwK3dHSAPbeHbP6wBlfTrzy3/FAAlr/02GIpl+dionT831GGgaHmI2KlVQQ6rv1bJPG6+KDtLd7VWoZSs8o7BvfhzKs9C5pmO6a3we/6/blKqNp3Q2nzKCXKrlp36fZR9ZNnv7u+0BMo2/XpRZYw4ksSe8LwbEV/asaqpJxuNr8ESYn0JXToQgePhus4x10IP3YqPbgUHqOpF1R/PStFSkNJgOFEbYGSqtg9Qt60PL/dG/052G9aDPN3myLQqW863muy9tDz7NdUb703rqEevWx1A2lqtUzvECoFoY50gdEamLQvaM1lRTT94CF8nxAI9Ye9f0gdm6OUR7kUtECkh72ghGocPnt4u1fw2Etv5+CwnVIcb9yE+27I1O0/NMyShitiuRL1Jnftqu7KDsRWlFK+/5hSwajQb8iyx7u2ndX+sdI74Xo9ixO1U1nA7sL9J6Y2gipq4AZe+uSgvOmm1Y0b+/z03aNrvdjsIte7/nDW+9934e53Y9HL0KhUV5y+/CiOByT1+4xPDa7dCfp10FUKrrmrG9K04zBPbsM1U/F4dyF/hpEafhScEuGpJLf+2dpg6C1hsPNm5ofSKGmwOLfh2t6MMeR/vyzDjXfSya++Ce69QqFAExw7KS5YtePIj8n2OhsnqWmge31nxEBpofch4YOXC2j6Ze79NtnIUWdiBNC78FljYJ8p5ORRYs4L7LdqyxNokD+Qrqmz6zgs/w9xT4cKMitiWDehkW4Cje3XQhED54Sb4i8WcNwiupGHXDWBziS6O9336ZMMorvo0+bnoxeh5ehj7m4hwsjJ8mqP0ERZflgKVTHVuX/9nBX71pHel4PygB+xVFLMSUUnvZEnTVdubqh9k+TdFv7GBUhbG9/qEfP2btpuZ2p1X8fDonaeq7J3xuGSgSsTDdpT/AWlSd8E2Z59OlLMl3eFBkHGPSSNNsw/N6ALmrwvcckawxbYRlo3T+sN9viBS5+3Uj//SRWYch90BMb2L8Ne+C+ihRrePUnZsDqDrDhacLYNWAD5EHKLwIiedjnsjAIYsYVgqCru4i5H2z2g8otpcdr+tEzk6ThLJhn6SqYhut0HU/D5GS7OYvm4TYpAvFWH35CD++pmkbGgIa5+4Lu9MV8cs73VFTWdQbtcB1xdpRuoi4SvDxyHuL1Mspi9u1pVCXlk+jdbLueRVmXHTtKw30acyFVarXp+OtEuWH/G+qfb/t48OyDvbKW6GjPn1vMnf2GroFnnkmVeR7Pd8HdLthk0Tz+1q9Ad/i0H/6o1eco387Pc3RgjqYcopmfZ2nfLHGh4DxHezlSmIWroNhtopc+Tzghm08GnpVO52H/haxr9cOB1klalNLKYHNQ6UX/gupJBoocIBRSP9qS/bRwzxjT7Okj6x3Zepz3pB3Z3w2lpX7uSqL9/ciiVbgJkmgRTncveyaUuhiG6WcQXbR92CbFeP8L3+mYEVprFdZkkhsq7NEucWQvKuok/k5+CrPT0q/+pgrgrVX8J/nt8e6dwLQ8PdL9UR3oeRrAMxoPBp2HTmzKXDJi5AYBch5ssjSdU+Ps1zV+/MFrpFlXzGMBv6UgXIfJ7s8oQ9v5Ms2KKKc73ZId2HmaDALn6UgN+ZA5Z8/unxzS8pA1F9mRGGmG02WooGuXF1Y/c0L9+RzljCP32ey+qZim6zUnEvbnfZSFi2jorkXfiiycQqxMkgA+qPnQPcqZhBvAf4c7w3bRnSN37wlQjOTzQTidbjN+8Ri0Y7OoYBMVsA9nO4rMOzi9EHw8YH+v4mkVv3IS61cyv2AWh4t1mhfxVEzaX6e0y57goMDRSwDqOf5C06t0+iUosigKmCRSkLE+y3FW4z9dHMwPo2VpM1+Hq2joA7vZne8n05Nhpce2Hf6PT2rytxnvYBQS51pPelAYP5xcwNvIZMoknBPIA9Xm+vjXqc3TQMfAQDFy7QGPH67NZWK3On3sYW6p9pCnXp2TDMbSiBbLo2/YBRl0PUiDMpfRuu0BgHODUqTxSjwQWzw9M+yAdyqsR0FBTEqWeULnaYvC6/tzC7BwhhA8sUKn/0gww15l9qtDvz8vDneim+XULydHKNB6kRQ/a+2/renv7GGuLAMuisSQbtdiXQi0EObp+nk43zyOjfHAcgF7XHTidfOEa9Q7c31xdtdWshjQELtdF8Es/bpmgkcUrnTKOEuLJyot7l2y85Xi+RFJPs3iDasitQ/SV5JgLeF9NKTz5FNeF/aNc5qk6yhgr0pQzz/byLNvqPUy7nK+7icnwvOLDbpvqldh/ISiz0P2aYfZEx5PWwOkdGiu/CDzwkG6d8N1wMTfBlgOg8/RcOuxf7s8OYPItuvgLlpPl6sw+6L2LBHFczhVzcN7ZqJDY5A8G2iwEqESn4fU0BglN1BmhGjNn+kYyfQIMPvTH9gH53MoU2fnk8qPHTGrvbSIAsS7j2dR9tQG3fZhIoQwuzTPnuneQIzgNZfliriPcIWDjBK56QL2YrF9rjyum/vIXlb6pFmcjtqA/bTYPPj7abe5FftptxRWe84Hpu5tfQyywgF6WlD9atjBYSXue8E8jJMtEznQZldu9QPxOdMQZdnTSnRDBH07diG7VGpNl2FWkM+9ruVhzC/rwCA+aKiS/SO/YtXuwjz6qEb+oiwD1ckIF4ssWohTsB9C6FNnXh3s04pOD3YitodQzdneUPykv7ZNRNzJpRGYu4KfR1xjzwS56TJYxMVye/c8dk59iPrvp792HJrQLkY4j9dMWItzgR+MZoGYX3SAHqbZZhmuhwp5+g9nE4O6KvTsHSBJSsb5YgfBOi0IplGaKLSyZ6JBbxvuIlpHaj9nxTMfbTeKmLbWJC5s1YPU+vB1Hq4vhi3WgzBd6sTzjgTLoahdBhldMZl2wSVaDifryAr4qKjkEK27DNwvULDxlCPutuv4nn05TCQ8NuYT0xr+dfCo/hREioJi95zfwHzKDz8ZPIp6V9kN9mwexbc6yAfykD3bE69gQqxsdZhxdqC0MzQrLAcJ/DuzjvR2hmY7E7BOb4aN+6anae5Gsjtubm1vEDrqqeGWVe2l7Spr6uQeKNjCLJ3mUj6YbrOMvd6RevWppCfv1MQn70TlJ+9ERZnOabkbnlhrRPzMonAmY5p0vkUFJ+QW4+DfT+6M+CDe0H27SnIJs3W8XugiTNdNc4AHey/hZR0J4WpJN+EmyripgLfP6IoVF+G3dJ2udvxJn9f2aZLmUUey+KFRlw5kL2vcm2WIuDxgs/HdFuN/KSPnpskB7PtDDnoWs0/lUAQGWci+9VLGHa6LeEUSwfPa3qt4wS8qqTDQ6QXPw+LKZGM43MuaASqUx2UW/WcbZ9EsyLleLX8Jg1a3Q+7KfPZp7Gym2c2i2CZsQ70IuoJ0H0yzNGenQzSPmPA9jc7ZZJ96rjsyjD6YTXaC/X0w4+q1FxyInE63+NIwUzDbbhJofqJgya7xrNVhuoH9kLGrdZh96aAPg0LeH8DRB2i/hcd2A4zn++3PKOBiIc7v3szxJwRo6mdasakXaYZyRFMfNvDyk5NSHq42SRTM04yNeh1rChMNZhImuzx+LjCu/SOWUFv5xechH+4fs3g63JB7kAxN0uhff2Giv6xlqLHpbsqqiqQBEbacdckq3MUzJmPRZgzL2MaeJ94NcrQpK4u55J9ihf/zPz3ziV4ZU8B13deY3M5aDjcbtMWbupHN8zb/9b9++J+ez7veOf/LWtGuR7uNf6IcDqwF0uKlCZq/4veWnsnpvLqdjjaLVkjn1+84/4jzbZjkZ850pt0noN2eqejMH3rjD72OdArgw4//+lcpoLIPLoSE+v1HxID4seLBie7dNUuZvCxqs2EAm6Pqid8X9/hvcAXE09torr3wXzcfqWefuWuoqKneb3lcvv+7hFMJeNBbktJZi7q7vMBSyY8+5J2yJZE0jO4FF+QZR9K8+mrb8/IL775FUzK6v0/Sr6rRADfLCIbKeK0+dkTV8rs3qzAr3vEbqkyGREk95NdaK5TfuN4Vy3T9+ub2Wk+bIj9gftpY9voy16hAe+E2/RKt1aIG8wQrsQ4KFOfqvf21/voX7mm0ZiqKPdIfpRueCEIZRctC5+LS8oDsUWEGuAbFH/lIcNkARlyleJWJgjCdj1xW5T1NIb41xnc+rEFABNx03Qkr+L2QuUrcEdx+bqLsPiadn08/C34ptPHjNWll6duWi1vi/95G9Gn7csR+qRjG8lrJJx+fZj9+jecRJzD2FNXfM5Lj32I/PjIuo6r+vGU8Ap9FLQy84I3i920WrvM5K+SvougqXa0YX5Gt/sL+TtSHr2BhT+WXK2mxPepVXsA4L2rfbO+ga7jjzdG9ml3yRbylclnsC+/SNizLyCbXqcay0KzPQz6t6MfrDVez8wr+2KFh0Ey7NiZnk0U5a0/WsHx8NhWqUfsSXY/X8yxkDW2nxZbe9PHiLWNyeMHBG+B48XoBQsJyhZVWrTGWf832/1f8JGr4UP+mbdEk3LF7BWPcu9o8WBeWNfGa8+B5k5FpHuKURkudV3Ro2WOXSjZb9NyeoOfptuA//TF1AAC/+uZg28B2RobNwUsbrdM32GFBDhWc+qlovkU3bH/E11uj02prtucYxmp5k4mptS1HVfguhsNxHnLwM7YsWbrjJIY24R6YRN9kzqDwfkFEZuPVVfiNJglNL+PFMigrczMV0T2+smTncRGFPARakRZhEtynyXbF19F2R5cXtCzs88Esns/j6TYp+DL6+Dp/JZrPOajcmfju2LMuJlgdEBLbh9EsuNsuMIHsY2O+Qb5yLCKdwTiZs4j1kJ33M+XSR8XFMmLbTvQeey7nHHBmBV+XITuYo2wKiqc8MBPngibVCtjHeJbaagXHvwBFL9P0S65CQFWrXFKNL+O259Ylr0HZZ5JE6b9858L9q7aivKvFbiMs7XWu2WCrVc7YYJw1rtxk2zU23GCeDV5bY4IVvm3gmQ1GWOHVJTfGRGRidRlNK25hjSyfTrMiXfFnv376+eL9b1cXH2lqRyDdT59/vnj9889UxKcFJTd/8Eq0Fd79n3cXv7z99eKTYMDv/s/txed3r69uLy4vLa3s/TUr8FGgav1+Iys5lSLrUv8Wr+WIIrT/8dNb3tylR/QLTWhQLm28glNFTjN/SXuTEUxMFOCNOetaRlnMa2AqkZos54yLXFWzzV2CCP8iiR4716N8w0goVlnBPKK7zTbTf2oslhfojMjjynT2Clu2KJjHUaJvcxne2RpdWvLI4qOpnSMjLHW5ivZobDpIxsSQtePGbRwetq93qLEp6JB70k1h/81NQUjl+zhNFFeyLp2xnKygMpDapP34Ns43rNoP4CE/sO/9sCQR4wfG4rMf6CQL6YryY2OafvyUTZfg9ox1ovoP05A1Qt+Ypmk2i9d4IGZan3MmUKMXvGq0Zpt3Gv1wt81j8M0fMlyNfjQtnZB+fmAC+JKgDKyd9RSeBvxL3/iS/MB5Kn2jFBJ+/INswz/cRcuQTVVGr0inH/buhkn1YvoqZPTjNZ+9H9hV4oddVPyAq0W2Yn2d/UhbrEg3wZKJVvyaJvL3/bjgup54HcyiRRYRW3fGJHPLKnmzimVPKlWEAkevMvErNXDlS+K7ei2/WotxAMzC/krlVXtPJbLM1KtcVqqQo0KtiudU+wNBrl7FrlTh1+FaHXf0F45bEQUlSGKSBzvWvszZrQ8X9CJdLJKoc6WAbA6bbcc1EfGfodyCnTaNcmqaiTFsr/Sr/+A6mE9MYGHs6Ibt7u6nujQ4xuu4EAz1DSe7bteYHZ8/sXKl97niOZXegxX23/rrJHnPyj7SSYsNhhrC3prEF+IKL8Wh/2HnmeVb9r+EiETaC3rwo2T17C36ThIjFkW4JpkU712ql6R4T1IGdBSRkqbn27VCyolvorgUXqiWvGUpay+OWXkGVArF+QeuUp67P7HjiJ1Q6+KH/8d6Zf+/P3JWniY5mzG+56SfwtfobpE0JoHJIqzr7Khm0gA7jplIOKJpcQzToiDy9KlgWaxIi2oovgiyKFHaPWMFdUULMsHTW6rNjqkxD1dxsmurU7ZFlePZ4YokcbILEk97TXKJYTqPpY7xIep4uVP7VFtCSrLahnBfjfUNIfE2s3TKpfHGZmDLxGRggCtwhWG7wDXsgrfp9Df29o9ySYHUYyIiZDveTWqEGuARiOmSQVoCzlUa/TiWirwqFameNMnpER17qnUQNwxtGexXXoUvcXBjuIaygsOCaizJprn3DHNffxcpaucxEXD90ZMx7rY2n2rCSA1gZOP1fOS1aWJM22Jc2/L+F+keLTBuRsEWI2GbtWGDtbPRQb1gs3rQTkFbBd2lzerZrJ7Dz0DfMNXsdvxv2B6QHvHH0pizIa09IVK1UkVJ9YTpa1HP+OBiuoyTWXC345dlZV9oVMbfxgc8H/ueR6XNoVHhP3TTbX1yMQ032Du5sQqXQdQjdhSHqzAQWoRGeb69Y9M5hTqt9qT2nWVRbJpf2WaJvK/Q7wQ51mkJEGVXFUNBpohtFm2oMUk+x24HUM/+/XAmjH8+YXTFu8avrInOvMicyxsKKFDv1sjxHcaqHIihjFU5LrGkkYElBQgLryDCohH5edV/ERC4USFc3cWLbboFah4nXk5JO6nurF5XfiMoUiJhRa7mAT3yAG/uraFH+FR0IfWGGmk4SgooKaOiK21SBZsumMhgKYIa0GGsCUpIl1GLy6jFxa2FUYvL6sGC47J67pioZ2ygHljdhBLsPdqTFvAfhUXO9OxidkwlGstUXcngGRMv1tEs0JWUATdSHvxOzhWo5Uc0beWx32BtwvSkPsFVlse+XSIVyi9UlZjHfoloPfgaF0vOOim13pTrJ4I4r+Eojv5Wuk52AZERPsJnbRsX0eGP8OXM68OBeQChOipK5YMfW6eBUlYT3n2aZgBvB1B9HduX6h5gM8I6hIyQZD04TCxbNpdsXpdhHnDdL1urL9EuP4JGVhtGIvw2IFvlZUe2zRXsbP63hOgnRiCZTNUIcqzoUb/ftO7YJuM8b+DzBj5v4L+/gTsUACz7ldUUAZiUEi+WbEWj9YKxiIYQAKOkxz7usUMfKCuPHfoedJWMWXjs0IdR0eOH/qTl0P8gmnhHLch5qZZeRPseVkhvFbM9xWhN0X4c5ce8x2gqEIwGaIbFUY0t0hnfOMdU3mArSL4YpJsiXmkml7a3lbJOLYWkJiKMfa+aSJBtKvmhfa8uozApljt1WSFnsRUjqGNeFnVo1+ByQwSvicNVmjr6/LEM50+NeMwnz5mWnh0tdcgIR68sq8EHASwNZLTCBhf0GBf02ZeBKAWgBdgK4DeACfMZFwSsEFgdn9UbsXojVg9wDACfgFUCpgRwnxGrNyJuaV+2cMvPKZDRvB9y3vQyPmvw1s0Dx9HiMVAAofY3moFJj35jDb1S+ZY8YcMkj9rfLu0N5auMnJdgAbNjXqu2ugo3uZQPkt0x7wvsBfqZ3IVQE6XqCn/M+3xDQNBifThyoDntPMTnKuJ7PQbsY96uTED7F8DAkqhglWXs19aq2F+yQS51FdBYMTYRZkf2tkY+rMO1L+rCk4Fu45zD1Esmk8PrYA9FMAm1bJO1E+75PMWcbK/8m95TAPiE8W3fc/7hFf9RlRMBfI2j/LgvsKnLo2Quv3TkW9OM0YKgf3qNtR5z0EuTbR1tcjEdtG18xzhn5mP4zKbObOrMprphU6fJhrq8rnqv7KaYJhQxebQJediWYAFHmCyMkyacYMSksTFracz4HeCycCEBbHfMpLExk8bGTBoDXHnM6k1YvQmrN2H1JqweEP0TsuzaVpspZLtGpO9ZxWBAdMDh0JqVDaX4Qjwti4gIUjZ5a4rEIYuUIg/46HRe/sYq/ZYCYAXQQf5hfY3nPwMMc+AxX0P+OS7gYx+J/kAXJN+/Akz7t4hdaYSD1m35wWPqCGJBDWngADvjLT3gC9z4xjcGfQ6hmHZ1cwp9i6e4Y4RwJW5i775Nky370pVchPwhdfWpEoFlg22uJmsWrYlANYXmB07+b9Pf0uL1fM4aoIm/IU+JI+roLZJ7BeNV92EWs01AR4HYXeJLb4n+bxT5f5B1D1a40PYPJ4BZnP9boqsObq6jL/Fjg2xxgGyPIrsHLPQxS9I+kS1WwZPZ7E+ym09zpz7t7nuinbVn43SInZu8ssaN049MJACRcde/xoEHt0C4r00ApJvQ4WWC1wYCHCIcCOX2L2U8/kA1114jnjHxMy2i9Z46ZN0GXpL2Sk7OpGX12pCezpJ/AmPs2Zp/H/8p3KibWLVLAM3g+GRdErrPNuGL6bqm+WvrZrmcchHT9YaNfLFe6fMBVzi2bdZTjmel2wiHrbJJYUJ/oZkmy14eu9buwbXust8dLqL9ym0sIoT5HSFzIeCHFOndsJzAHsLlzIKbs3UJ+CEcxqxLKBcvsfU5ihYrTnhOQisSXJHwigRYJMQiQRaBOrMAWrSgG7AAW7SAW7QAXCS/WgvQRUY3bova8iqJp1/eqc6XR0itXNoiY8SSFYZMFYXtiHeWUYLw8FkUsjv6XanS3veOqEy42IAU/fG9evF2x75n6Hi9nH8QPpBZa8f3vbO3E+/DvHh9/cHQjeYT/tE5Kw83Mbvdbgs9kN1DXsse/treQbA9aiKBern4JEpbu7/vlX19uN6hpqETjQdCOtjxXcdFEYI8zqJ5uE2K416M1+JFsquzDip9ovbG6yx6TRLMJ006a3teqkBKVqCLeOrCrk3D2zhcrNO80ES3lscSoBDmSCCRb1dB9B/EqAnISfaol6XjYowy7Xw9/GJZwMSpAPEUQxLZdBntwV8iLINYBl3sLk8CE0s9WlVqwsS08bo2VrJnd7dsmVYyPkRVbVRhVtj+45hzz0z4H8Nqe2WpQ3HOv8kZXxLr61IvO3plN+8eoCC2yWxBdma3Ioib8Hyx4Ppike8LkOcWoOcWsOcWgc+BO6bYPBaQxxagxxawxxQBwQL62AL82HLJAQdvAIFsAYJsAYNsEQgZwCXLI/8a22sRWm+zKLohvwERSEuDV5ieCaQE/y3gCpKpcpeuIv/2gA+Ig+UBr0rfh+Aune2CPN0KR19JN8WtjQ3zmmCH8q7T+lB8c5tjahAnJiArC19MioB++G05AZQRQii4HvEZjk487gu/sJ5ey+SQbQ8ueNybTZixvaIbEBsVqf0tW4eC8mvV+GZL/bKnxL94Y/V3f0vX9PoV25RX0ij4ge3f7Lg6gmEm0MoqLBCYB02M/AKm860WiOcPFfH7cA0B4KHez+NvBOakjVKJ1XTkZ/gays/ARlVfVc4MGlT+Xtg+25/Is7G0keYx6Xc4LJbxQ7YXv6bZF/V1LNlHEdTo3TqLp0t9O5ifNvcDBkF/yPhIR33ARBv40uM/ws4a8Z11+qDPwDrLt1HJqdgnGmNq4eJ/S07ex14PMyvTLj9mQx3eDu2E10I0Zun5mZwQz+AQOHVe/3f5+Glx6afixS+V23YpnPs14TzfRFMhoodbtlIyDTcjHIIuN6GuFpD+FFDVAtbf8sjFHQI24P4W8P4WAf49MjBxB3aSsvEP3vDJg5SwE6QzpoAmBHrFG4DHWsDHWgDIWkDIWoDIWiOOtjD5wr9mXZdxfWXHsRym8gsVe+FuV4catX2n7dnF7KhaCtMjEpdLyJByZN7/Zt58U+g2Dr8rcwBXX5+LKHEHX1fYudoH7lWUuIOfiPP6y6C5eC4DvB0xfO6vJbLRq6+IQHYH39e8rWqfaHpH7ZnI0vus9pXyyeGvcJeexieie3AW8fCIKV3HhXq3DHF4eCaLTL22FYEGDzdWROVb+HHcsgvbemXhZTi2Q6MLdOjAw17+d3gf/o22c8bak9nj3p1FPOzxA19bpH+jv8IpgzHCcmFFSMGD726y+B5bm507y7R0jKtjS9s/AO0Yx7xQB5RMSnHiVUyIPWfL0ZcHv3Z5eCifNgjoT3E0nNn/mf2f2f+Z/Z/Zfwv77/ImM3ll+/wmk0+X0Sp8ReGnm9eVEYXewh2DHOuA+bYA+raA+rYA+7aA+7YA/LaA/LYA/bbGFK0LbwD9bQH+bQH/bQEAbgEBbgECTqH7LeDqLADrrAkF+KIIXwjxBUSVDUSVDUQOBYGmxAM2EDkUwtkGIscGIse2KCgYvyuZwuv8yvgErct1EnJPjl9llIA3MvA1hS0Puaf+O7Ig/ViJ8ixCSnNVGjD9VJHNOqyi8u/3KqLg6zWFrGdT/2v49QMdOH9Ij/wb4D4FD3kbryKym9OV/te0ZO74Xv33jzxWOuliPmq3Z1n2Iw87LSL0f+RAT16I1MrrRaVoGaFhrUj78+3bt9dZumHEIxwgVO/19t4x8lvPuKrmc+VQuEIouRkS+GJW6QuEscWvWOEpfuZetZwvKuQypZYLinCLHxTNSimgRBjGGEo4vnA8X7BwN5OndrW2+slEqVksEIkUcv1IMYoyOuhi1Jmg/jkE1ZRgO6evDtHLjvXKGRm4t8i+qri3DWyiDWyibYz1SXNwy6cgziXRXmljpYmR6/Lh6Fg3ziFM6eNa7iqApyPnkuf4lbFEc26kaZ6KNkCeNkCeNkCeNkCeNgWmpMiUNj+ETFG6biJlpuE0J9v4kSY2LyoFtY5QHFB5p5CJ6REFL0JcPK1SPRSr+ubj4vmqXhuiJXY8iKdadcr7UFnzcXXNVWgHXGsCxmVhw1htDGtPQUcp6iihd317YowlLVDr8XqeUsBILhvnX+JNI2JuW9tPhuA+vjddzbclsdhyvpFNjkebXTEaigzTjC1GAV0poiuFdAWwxQawxQawxXYo/CtWAsAWm4AtvmOK/EC55aRrUSBTH1RzsmukuipPLNE/vYiJ/mt+Mc7o2Ib7EpLfxjN++E9XswBxOhIRJQW/xWfkT+Q+kn/Lu4qkhtrMHO0ZdjDS7z9mErpj9e4ry67SocxfyKQQ0rSx+bpn7zTpkRBTvmPtiaff8q1/Yox9OT3CAYctm3lSsDWBILOBILMJQeY7JqcoSVUgOy2gkSxGDHVGTUjHx+U+SXK8A7m+QSp9ejKPpqfqYA+BxuXiqHxm3OGvuTwA89kutxyaPJKmYTLdglqD2qf06a4/eioR8HDjPYp8Igr6Jk12iyQtDFNJYcbpwHfc9tDtMrec1OfwO4h4yDMDGB7IZp9sbh/RmyeLmcw1y8bJzqaveJB8tocg8a+nu0BGsDRMOSQAwE5twE5twE5twE5twE5t2NFt2NFt2NFtjy+Nybz9dssDVEY/Z+y+ihlA+hoeJCuCY9pNvBAqOzoMc3ahWgOBHFdZAOnpCCnEb3xakBJhrKETVr0+k+3m5TMR0hGBqptPQf8iqFvUSFyhTVl56pbZd+VDOoubs/voIHHHTl6TBp/BXHYlDbsqRFq5JeTMTJGJUkZ2a24KQEVsQEVsQEVsQEVsQEVsQEVsQEVsQEVsQEVsQEVsnxIj4A1ARWxARWyCiviOSU16xdrXbqkiphwpX9iTdzojqRRcBNyyEjSfNC+JtTeF+zjNNNxFm1Xk7CDfXUB5WvP2SrNoGufmpmSVLxHiiK5nMkaLuRYH/sFus9pTC3H5Ah7SyFALd6+8op6qPxdEKWKltrdzt0O3v6bZzHTHr9DN0du9bho+dvWb2/1MDEMTQ6ephiy/zrCm6ZpSwtOsrChda5NdAY5mA45mA45mA45mA45mA45mjyhfC7gSjEs2jEs2jEs2jEs2jEs2jEuUndke8+u9SdvyNg6TdLGl1GhCTay6dhMtJPZZL/4YbupFyBv/mh8C2b5nVeJuq8TpPPqm00JbXRFquUg33M3qUMWVYZyVeqVsPYVrPsgA8cR2e1/K+UwF+sLunwehCc/NU1yrq7pU29ptb9AxvkyLfJMW+6dP7RoEtgYpHlc7zKdxTOo2qaRQifGapH00R61biTqgTQPzPZPqSyTVDjm+98oa1Tn+jEnGm2iPcArTvz2mBFzg5zD92zD92zD92zD92zD92zD92zD92zD92zD922T6912T9vb3dfyfbaTJIlq4xFRZT8WfwKaTATmPV3FCOqKAQg5p8szbSN4YuCBrKK7sHNNzut7wDJwtNUoySild6qat4kz9iNqqSMGhtbHoG+W9kVrdPVVgc5kJjItK+lxd2aOZXc3y0Fwp04Q32ddTrucLWrju9GPOK8ut7/5NxmajuecnlGePFL+uSTkOwwB5YUsrAf24yMN5xHWts+1qI0wKSGz9VCqwI9vtWJ3uNKXmFbuvIMiZQGgErOlluoBzl0nF7gAD5QAD5QAD5QAD5QAD5QAD5QAD5QAD5QAD5QAD5UCH48Ac5FjcX8Skj6ddoDALs2iel8agJKn6esXrObto8Sz13FNOgFMaD2TeVv6AQsNWXpCjR4SBdLPTi/7NI4g0H6y2xZaC3c/BJeRJL58q1jELVrGuxqlMa+sD2p/Z5i4x2bRKcXDvmj2WW7aozM6LcnhRuuN8foXzUW5uJuumTITfieAWiNrbzPCHbQlUiEOhv3zXZG65FR+64jj5WKCVG6UKSN/ymJQVtXiXzU4+Ej1g6qXBQffvd7pD4VVFflNrKPOv030EEU7gWGhQWDi4vznA8zjA8zjA8zg25W8EQwXswwHswwE8wQE8wQE8wbG59GqyDN2IpnEBTN6JhgUwsPmgIr601CCGUAa45ijGA9WV06m5kgxSWv1qe325Q7m2Lj9QUejf22tI92NzDb5aiv0drMh4JVf3k+hlWndSnPLK5NVarUbSZsuLx/J6pw6hMlJBc2OdieJUiaJDY5BTP3G0jLsticMcym8NLJRD6WV5flmwJ2ChHEouStlFKb0o5RcFRMMBRMMBLsABLsBxKSUt3oC11YG11YG11YG11YG11eFBflxTkJ/y3iYJ4xqqpFsmJ6U8dBNXLdF0FvtKL3gKAiXuSChRTB7+GmSNFyiZpnSfZ1dPUqIkWh60toeV/bSnFsU8xfCAOS7KE7v1DSnOSEzdnm9LRb4S6oJduEoe/JJGKke+S97yFJr6uLHM4iwqHd4e0LcD9ZW3II+PoDsMHvGSivPwwPdEL5lkmu9Wd+mxE16k2+lSixV4+I0s/FqJgd3+hgr1oKPwjplonpK8pIVQZK5pcI+jEWj1U6u+ndu32z6ljmQOgzGD834/7/dnut87vEVZziu7LpmwnRiuQsQWRVCWZkpzCBYAZTkAZTkAZTlArDhArDhArDg8m6lrAmp9oo+Tjw+JhuI3tVX/XdnS1QdMlmOTK3oa3odxIoOlVuvxNEGsNizpjcf6dbbyAOkn9I+WdF2NlMM7QIBVfdKO5cWTGiveOzlN7vuPnKsuFdqTGiWrdKEKIxewdwyCNtBVDtBVDtBVDtBVDtBVDtBVDtBVDtBVDtBVDtBVDkdXuSZ01c/pjHQimk+cLJLZi38VmaJN5ZWVNFYoUWy635z5WxxGRyHMSoOIuaqw5iaMZLcComuuWD8R99dS+VrN1TTAHg+6EOTbBVtxBR06+BpCPURrHp+r/Y2anfU+zrcqURddGs208ljXjKOpoLmtz0RxGkTR4bHrlz4qklfVkyM1mRRwVg5wVg5wVg5wVg5wVg5wVg5wVg458fvu2Gxgx/d/E1gN8VO6Boufr0Xjn1RcZuODC82/2lwhD3n0awHJkIMr4z0LQqDETdEqFr5rKup8I1XUI0/Ux4y6uSOHmIQuXYsbB2XVT8BAejjyAN1zAN1zAN1zAN1zAN1zAN1zAN1zAA5xAA5xAA5xAA5xAA5xAA5xAA5xAA5xAA5xAA5xAA5xAA5xAA5xYGl2YWl2YRN1YRN1YRN1YRN1YRN1YRN1YRN1YRN1YRN1YRN1YRN1wYddaGZdmGtcmGtcmGtcKP1dKP1dKP1dKP1dKP1dKP1d3IpdKP1dKP1dKP1dKP1dKP1d6OFc6OFc6OFc6OFc6OFc6OFc6OFc6OFc6OFc6OFc6OFc6OFcCrbtuyZI43/dfKQILiIzGF326mUVxt94WGe6jQqMo8WF8YlU/K6i1R1SAQjdaaNeBdyAH//Oy8AzZb/Z363PtGRPKssTmfl41dJPQD5Q20DzFJAl3JcgWIVfqgUUParqrk9KBZxe+ts8VxydgFwFUVEvgzOU4WBvChwOi137E4XVVWnnrukGh9r6283S5pv/xcRo7qtUf9v8pPkFBJS4MX7h53R/SfNbn7d54yv1suZbb3n+gvqLhmJD78uAvLXXzU9aND6VKvxOQ8lwZ1FpMGmprQDe7I2oJL4DtQ8MoNyDnAjKWk0CaT6rDLK1UsswQTecHsyN7nteZTz7Kj6i8YvSAbnKfY55Z6p0K9kif9Bb2poe9U5la7bWVutbbj/zdO97XiXmfRXbSHrfOy2TwHk7rxPMmZQtzxG9fjkLmrtFSrFXykcaSk7LyFlJ6Cx4svIOQ+8lww94pBbi00VaYdXynOKykOTZrJLsK3F+eeqkaSFbzotZEt8F6OW3MmCX/JzqJI86WMkcKtOK8kOMIkDrzhp4LHqjVZhVE0gZPC+PEF/9egx4k4jQfkaZz572c+Uh54XpPGjh9u2MfB8HPMSs9u6upsx+FqROUJA6Rlw6VjBq1nuoSHOU+HL0Mf9cpJHOJI6zRPGkEsVZYnhGEkOXJr7xK99rQiWLXKpLDQofF8AhF8AhF8AhF8AhF8AhF8AhF8AhF8AhF8Ahl9Id+N6lGRhZ5JVYfdWSOupNf6SUszAkZdESuGy2DuoMrX/J5FjbWmcWFSEjh1n750oPkU2UEQRauIjVK+a79bTEjedBOAcqYxlts9IFuPYONIMgBXbWGNv+msWs3eWWtQmw7wy2tfae8tqlzXia3wt4o77Ijw4PUVtDI57xvKTdL2mnGmE9WAWxCPECD5PUZBAAALgAALgAALgAALgAALgAALgAALgwqrowqrowqrowqrowqroiu4nJk0hFV73mzUvFvfj5Hp2p/77QiEMvl5aetvKqoGOqIIxfc1Or5VeEel/ZLsy1+Hm1jNkKZ9Plbs/nhIMFmc9zIgNeb8/HQ8oCxR1C9lWTt5wk/crPYBpfZal/LIlFFDzWUfAxa/lWj2VT5TIPWfLz0hqXtkMOMmr61BB1ZNECibSaTm8udB0uUBUuUBUuUBUuUBUu7Jwu7Jwu7Jwu7Jwu7Jwu7Jwu7Jwu7JwuBSv3PZPnGyXwiuagAWHeR8ln0Zf67wq1VB9QeSmRKjB9tRYhGAubxMYyJHOljlgPJgfnu7yIVm0V2FckJr7ymETYlmdBOJs1CllZUEm+0fjc3Q7oMoXcbDxXh1PliXBUpTlpPOSOXNrmrNDA0ZykrgU7sJyG1CXn1e18dbsNTFC/sdBFr9Wly4Vt2oVt2oVt2oVt2oVt2oVt2oVt2oVt2oVt2oVt2oVt2oVt2p3w64vJm+89a1V359J/V+iq+oAj7hb8Dl95JHxP5E20+hpdLJe7nIhRz5nXrMZojM38wWpa/LT2irTtAg6YKQLsz9z8NdzVF2l2RPfY0PfU4Dk5Wp+LORJx2UUQeW3iak8qlPFoYaWy0k2Gcl74E1v4DrnPuCnK3GXIO4rADDgMmuwHyBaXMp74nmsMFS7uqNUPVQIWkuJe0ket3lMFTHhYP55qjt/zZFpt4UIl/I0j4tuDhbpADblADblADbmUTcb3PDPYjX9N5uXRroJtzyrburWSGWbZWh174j/bmDEFdd42R/rI+MbtozQi2IYbdJfKzVd1QSFj9LwKN0F0HyZbs3ITSDMXSDMPSDMPSDMPSDMPSDMPSDMPSDMPSDPvklOZyZfhKtyEdypJ2GfesPbnO9kFU1ll5psPSejM2j95EXCfqmnLYzH8yPwuP6empv5rtSo5C7KirRIlzKal3nL9e30FHq15PH6CmxT/Qua723OwoRTMUjqIMVsGMdwDItMDItMDItPDgnpAZHpAZHoQujxc7jwgMj0gMj0gMj0gMj0gMj0gMj0gMj2bn6YmKPPrbLqMwWu2WXTNe0R3lWYxnFNm0QYh3REIOEyS9CsP7W6qTCk00uwunrHqIsjGvrrsskT5y7lyppKTSetWvYxeZTOPIFcy9nHeWlElLzxQlw10tS14NENtmOLxr7RejYKqmqzyhMcO0AYebMohGaqWcXPa6yFrjOmTeUvdxjd185tGh7J0xq33ldq1mo+N8NhCcqb1rk65QTdxemQ6HEk+dwrsLNfOZSV2IwfxCzt5mm2WoSGjlcdzGXmTPak7xLu67V5+LuB3sODJUp3U2+wuO0GZ8kT5uN4hO644jQ0zhUMKTgAenAA8OAF4cALw4ATgwQnAgxOABycAD04AHpwAPDgBeHAC8OAE4MEJwIMTgAcnAA82dQ82dY/nmPBNBvPreEPxP2+KcAHsGKMmos1mse5/cl2aMz8yYX0heH2jtLrdmo+ZUJEx6hWNtVSC7jEre2ZohPAV0QoJP77ctVUS2kQMaP/nSJ8B9pGL6i319s5HUzVNU4m4B1n1V91+XRZHoEZT+TdDdaD4Sk+f2oNSWOaEGJUDqxRcKOAMt+mIHxdfMx6wWNWXcuWxe7MuabeRnZGutJkzmOkeSqlnmjTR5D+JCjt1lLQbd5ByHpESGtNruOR7gCx5gCx5gCx5gCx5gCx5gCx5gCx5wDB4wDB4wDB4wDB4wDB4wDB4PIiBb0IpYApl8lZtWZWBuyzS5cJGacWKrT8Vg2orb9sxZQUxL+0f4Cbr0q5trKQ8+RGzpcQNmivDOXfFoT15se+jCoOjB9M21+XhBJlYSppnCf079N0ZrFXx3Va5/orZqIN+jIT0aBvl36cJvQc1nvpg0jmTyN8nkQ7Z2qRp4IwNPAwIKg8IKg8IKg8IKg8IKg8IKg8ACg8ACs8nHaVvQkLoeaavZEAOPSm0SsZNf9BBOtXrlcWR/gZONhnPmhfIuw87OGLyUcikH0wuskBVJi/ABYtC1h6/5y5re+7IwRlCLAwx1m5zt1zWIb4yrRb7VUTfmsQFwI0HwI0HwI03Iiu4b7KCX6VsO2xqeaFqZVpyHHqQGyup6Fvmp4tthPgbqQzKXBvDY+0kjf4bk2t0PJxO0Zt1ZqI0ycsoTIqlUCg3aWBEeSP9vSbLUhlt/uqT6QPqLXZnfmzqA0pFz7QMZ9ycLvBeQNE8QNE8QNE8QNE8QNE8YFA8YFA8YFC8MZ9bk3lS5kK/LUOtFoqR/SrVa9fLMK9qGatBpQ3FlWPf9Fyd1zLr/cGKuCREB2spneDBmsIvR/+tIa3pgmFYi0ebkJ5gqpuU+ixnvrvAXF7TkARJsR0b6gG65QG65QG65QG65QG65QG65QG65QG65QG65QF84QF84QEg4AEg4AEg4AEg4MHY68HY68PY61/yY85szhVAQEke+K+OGdV/N7yvygdccM7aXiRnoHWuMg5VHioHz8aTOA/u2ZOZ8XuFocdcVy9V/uYnwddIZnGpVABpVPzE1BMqZf1v+TJeLKHKjUZlwH/6W5ugZhxROVxVQNGi9W5Vhlehp6NPpMuGvXkfBRgi5J8J4iQJoiury+iVXRezlU/QPsHBB7rEB7rEB7rEB7rEB7rEB7rEh9Xcv6SAgv7IKIoVPKWHPkO/yIarQoGhuEKZxucKAi3ozFSpPL92enxW8/eaddWNqO0l7kDO62oJezebZFdzvDJN+WPjg5lm0SSZHrcAz2qmu9pEdiP6GO/EHndUHzd/H7KdDzSJDzSJDzSJDzWcDzSJD5O9DzSJDzSJb1NEe98EHwkAYvtGTr+UKSrj2SAgb92VIQ8WyIUtI6EGq4jxI8Z8+EOla/jMnW0+0wAqbq61IuX5aHomvP3KvCnSg7NRkZ8kojP7amhpxOqz++iIlodG3dw3f3+mT2Qau0QwXjZjQc637FxrDQTpw3rnAyTlAyTlw6zvw2Ltw2Ltw2Ltw2Ltw2Ltw2Ltw2Ltw2LtOwSr8k0YABlqRBiMECS8DPEBtWleBMuCxzMP0k20Lh3qV+EaqaKoEHjycE3Tqvnos29E32plVaC3pp4tlhHsdFjJJCrYqvBYoSoxFVuW9J79p8g4dQnvmi9roSrWf/PEneqGpPJ8hUWonOVK5F0YlwkSRU65ymKQw0Gl4MkSg52n/4jp7+6S6jZR/wvoekm+DCivWsQE9OZuBPzDB/zDB/zDB/zDB/zDB/zDB/zDB/zDB/zDB/zD5/CP0eWxot4H2fjnbRI1CpjQwUZVaJIHTwJHemjpB1IqsyGCq/fNpdVgw83HnIb47CjCMtTDYNa4T9ylWSmmGyryDkvBvrWCUGBwSUU2r43EtF6PPu0ak26YvSMlxSdbrn/kwnSqV7JNPsct6GQfkAAfkAAfkAAfkAAfkAAfkACfRzEZWW2JNJHKo3QRpSLKMaqK+FxsoEoM5uEqTnYlw5Wxf4vwW7pOV1zUgaFJunxiSUyVzB61D0Ozjo/KSXkK4+syOcC4Rirr6CticeRbU0YAH9gQH9gQH9gQH9gQH9gQH9gQn2NDRiaD63WW3mkIqt+olZutCPiv/bzA6SZ2jl68wQcCg5eQsV4Ztp5xHL7hDZXEliyiRSa8D5qVZAaLdL1m7cX3oqI+TY8kuH1z0iTGf9gUPRXJvmazlRWV1MJug2ajb9GUB4+C7GSgWnAzAAZ8AAZ8AAZ8AAZ8AAZ8AAZ8AAZ8AAZ8GIB9GIB9GIB9GIB9GAR9mLl8mLl8mLl8mLl8mLl8mLl8mLn8MV2vR0afadYzqT/F3xIBcxVuc0r9erUU5t0PNNsEEH+XZXz53skRvhfCYaVAh71UH7DpYbdLyJCUbERObL2e7ghofFA5Ys01ZOgQUwfrQUEUfGZvLRVHrKVWnFN+3l1A2Yr2VJRxCMrK+z5LonkWhdOlzN2y/7MaOLylohTvxUeJCRMo5/AcTEEV+6rBrB7xavt6QJ5WXJd9H6eJyu+xf2hxSYpBBFrULzLVXcex8ZWSx6Ze63Kr7HEG7WZLnXfOeecc2DldqtGsZiKzfAXkeHtaCx84DR84DR8GZx8GZx8GZx8GZx8GZx8GZx8GZx8GZx8GZx8GZ597+49cI15KaCCvwowUMTfoSAU+VS2pgr2rj8rAmqZvXQQyPgJdHymlz6FaIoVkvQpdCkWYT9OzMoZnWy3ZVS1FXr2Klrje9Bg3Bi6JMRmrYN/bMyHb9Zd1+pUTPs9QT3NEUUmThC4dNQJ4dHCQQwtqCIl4Xt+u17dbeG5dF1gapLl6tslMAD7xAT7xAT7xAT7xAT7xAT4ZAXwyAvhkBFvwCLbgEWzBI9iCR7AFj2ALHsEWPIIteASb18jiSgkTiIzHeWFcmycgLDuI+CrCYj5FKkE4laqcfmU17RlFh+NaYKRgvY/o2q5d8mVxETcCkVdu/DFcU9TJzX+WwX2n4XoWzwjhlwpVsfYhHHYw8W+jaj9VpPPcUF7VYVcf5qUOTDe7yjDB9RVFGSEMOEJ9TVRoLLwQ7vymCWzQyUPdJq3JQUPBeeFPbeG7jcJQt5eT8WRFPmQrU4rWEZTZIxjJRzjKRjCSj2AkH8FIPoKRfAQyG8FIPoI1cQRr4gj3kxGsiSNYE0ewJo5gTRzBmjiCNXEEa+LI4UzJhKFTU7YWVxlVIBH1V+zBXZhHNxLdWCmonJTVJ6SRpBCAbP4W0muhWkccg7Lx6kM6AFuf3O2UPc34MIvXi9aHX+L1rP3NtO2zpcPAvudFapgMeKcrh3TDM3S39VlqfE8uVfsTfhH8GmZr89ezaJXew7i3XjBOtyg5QG2VvknQSY2SH+2+WiWqJst8IFmeqfDlUGGHERoarqtc9BXRtJr30REQGiMgNEYwKo9gVB7BqDyCUXkEo/IIRuURjMojGJVHMCqPYFQewag8goWLcWYTiBC6pRsZg4wseTJbZamYJ+JWRE1Kjru0KJJozY69XJVt4Lwcrr+oAmAOttgTcHWKcDSaH6Xbe6GDqD8r28tiuVz5El4/eaG8+ioFMu8OPeDJYVW2WKz6dMuHqgIjb5Ok4sSi+bVUluXRHqAHZ7jF8PbCJryrDec3fSoFkqYdWDiCNXgEa/AI1uARrMEjWINHsAaPPHLhGRlBhLR0X6O7RaJB6wjclmwXIk+6gvSIHCTyYq3ixIB38m+yUg5fY1dbTS4VWQOKVWLyw+L1uAd/bahPZhs+qYF26kJZN7ZJJFIQrRdsIpvEA/PwCObhEczDI5iHRzAPj2AeHsEWN4ItbgRb3Ai2uBFscSPY4kawxY1gixvBFjfyuUHZBMv7wLuhfMuzOJUWSvEIf37aFPFKZK6+UXdDUSF/RyNollQEndojLTlx/SV+DVrFeY6Nr6JCCrayvzb4yZ5qOQ/eU6qQzNWm/8nyIN2AEsDQdu01NetvnH9pr7dBOChJ+sd9uqYrN42K+zU06FkHudXI7NEhyp6QTppc4Ew2J0U23RpSGpHFpqyXBSIGF628EDiCEXAEI+AIRsARjIAjGAFHMAKOYAQcwQg4ghFwBCPgCEbAEYxghhlxd9mxCRT5h5yqW6GF+kM3T6kferCdK9VjCd8rS0pmWC+r3fvqD3mM0K26ttSfK+3QTOUpaFaS979S49Wo07itttcor6+1GsIAVwl2V6hQCW2fU6Jos6RBA4+Wk/cv5xEr12RPB2jgvLp7V7fT+E0NoZwOCHgYtfISGGNHMMaOYIwdwRg7gjF2BGPsaEyOcmMTTjNfhus17NDrIks3Ox4+nv4s1c2kIQEePV2FPLQEUO7fBMdehkleRCGcQ4pM+JtJ0zytq6F8KtQKerPyGRwUtVfqY38yKf20R94drHPUkNqlT+CU+IEWV36Pf+YItv0RbPsj2PZHsO2PYM8bwZ43gj1vBHveCPa8Eex5Y9jzxrDnjWHPG18SGmBswsM1XVnrDnhlSHUjfFzFWa96ehqKzdHcTa6FXLTRvAv31lbyzbEvCBsucvHtVndp0trfSrJhQu7f7dTtsfUN1Z+j3igdW0rDTWtlwVmhTY12X9OMm4yMVaWhWvVmby+EIa0a6sJEnY8+V0100uQUXZDjme7+SXTX73FPYfOzVxtKJL0HjDUGGmIMNMQYaIgx0BBjoCHGQEOMgYYYAw0xhnFzDOPmGMbNMbbBGMbNMW7EYxg3xxYXEUzYLJ7Q+vXNbQWO1Sw1ZMGuPJaLUKboFLAb06dWUZhDRENCrlm0ETHqDBXlV7Nous2QGrWt9XtpfwYYRtxm/ohp52p/8kTSAZHD22jefPJekJDx4WtkQa3VMHWaDEyQAvjmVmq+troKaLS3lqLuu3S2O6oiW4pwtb/ldIq4f9yE1lYpi5g4vVbcsU64j9bPmClPLpoh6OMzoskzIf5NQuzYAX1kZtr8EN0nOY8BIRnDHj8GhGQMCMkYEJIxICRjQEjGgJCMASEZ25wvm9BsN9TUf0sLtmxxdqPO8XqZftXnJVX5uF6mpATjw0okjXi9ZKemCsizv3KVivbXVcjKvbXkTqpE6yoFmsaqPD6z98FJb0ysIXTiA9bleaxBt2l0rb0CFP/V3IcAZo0BzBoDRDAGiGAMEMEYIIIxQARjgAjGABGMASIYA0QwBohgDBDBGCCCMUAEY4AIxjCMjmEYHcMwOoZhdAzD6BiG0TE3jI5HrQJWSUH670o4dMn1rmlEhiLzcSee0TwYX5IHW/NQkzWMJ5pBetLb7/4gq/cOGMqwqJ+39VpEm3tryN1qrLTnGNSrsOsXhUuO1O4xVisP36j9W4bTUX9cE7/MPTYen5WesLNag8vz3F18C2lCHd9MR6POXKNEVyf1CkkfEu8O7otBNsGZ8p8n5XcpRbqvbNd8cvEW9139AaQYA0gxBpBiDCDFGECKMYAUYwApxgBSjAGkGANIMQaQYgwgxRhAijGAFGMAKcYAUoxhjBzDGDmGMXIMY+QYxsjxiCKvjE2Ang8raW7lfzXjdPDyyu2tViRvYOXiGN4xPtDf/K/wPryZZvGmMLzd+rD+hZZ397z1c2p4p1Gov/F5m5v6aCjW37q6WYbZxvCe8UG1vbudsb1GcWUlfrk2LUOjVH+HYnLW6FZPiqW5QDWqPdYbuE6Bh6nmKGo5ZlH3LGbrarUshmG2DXCS47bYwf101LY5sDP2boED1H6QrA9Q734yfQxB9uxiex//+YpnLm81544B/hgD/DEeUZ6KsQnlds0/UmIzKgVVKajyhHIzcA07HYrV3hy7GRuiXaU7BuntMb3rNA+ya1gZpGdiMgeUcq2Lg/MSUJwxoDhjQHHGgOKMYYQfwwg/hhF+DCP8GEb4MYzwYxjhx7CajmE1HcNqOobVdAyr6RhW0zGspmNYTcewmo5hNZ3AajqB1XQCq+kEVtPJJZ3JE5M9/7Xqf0kX9bLK5Dce8pBUbBWUb1p7FeUn0GwC7m9sFRO+55rPNa+5fdU4Trr9OXm27Xkubeu5iB7bqMHFyPWMeit3hLHWXTj9gsCbhArfW3MZL5YJYGeHKsLFP1gBKnCgYrhGGiAK8H/EFzdZlEdFfnBAIqz+oXpYZeplflRNWo1DNdd80EfULFd4X81Ad9ZspQYu2qdfkulyX4VNxK4Ca8SgCNbb1V2092uHa8CrpmUjUlewk/JscWeuAlYcZnqdBo86Wn6qR5lqcAtD7t0z8zgzjzPzeB7Mo0txyn5ljw0CFTmCp0mrrDsBfmEC/MIE+IUJ8AsT4BcmwC9MYICZAL8wAX5hAvzCBPiFCfALE1iMJ8AvTDh+YWKbc3FRDyogZq2kDnLVH3Ed1DpKdOo11LnbFgXjmPsr5UnMOMWBSrQeIWfABz4XA0qY7a8Ed+FVuDnwKbZNir0903ZI6U/bVkOmqavVyEP40fGAAwh2IBydckPV+g3F0OVojThSMzXAA9VW8jyq0ePRhkC/mSFNpypjfrQzkb1EIusygb1v4LCUUU+6EzZVxRPgDSbAG0yAN5hAiTaBYWYCvMEEeIMJ8AYTSIcT4A0msIxOYBmdwDI6gWV0AsvoBJbRCSyjE4f0EhMTevcW/fksukMpbPSCatKf6hPyJ6Dh5Ian0mFSutpWH5dCcfOZ3PPNJ8UyWhleSMJdyp0sa32YJ4BVrls7qfyOpjmS72QxCMNYr6hUMdeg3pWgnGYF6SvaMoyyu/Shg53m1ab5vjqUPwj18raKBbaV+JTaXFxSLmmiSrSPjfRTozVDuqkz6Z1JTye9DiVgrxl2iDSKOa5TUCxe/DuvsWZASyaAlkwALZkAWjIBtGQCaMkE0JIJoCUTQEsmgJZMAC2ZAFoyAbRkAmjJBNCSCQyCExgEJzAITmAQnMAgOIFBcAKD4AQGwQkMghMYBCcwCE5gEJzAIDiBQXACg+AEBsEJDIITGAQnMAhOYBCcwCA4gUFwAgX1BArqCRTUE6hEJ1CJTqASnUAlOoFKdAKV6AQq0QlUohOoRCdQiU6gEp1AJTqBSnQClegEKtGJ8Ugp0ptpFsmQDTjYVQ7mZfTtNv3M7z/5Mv16EyURMYCP6YwndNpu4Lilyv+I823IN2TtyZv0G0+hW2w3qvCDJipxp5/1LKEc5b+kgpdRTNG3cUZRPne3rKMUqCcLv0JWCOM1AvXcbJZRJoJGFOlGe/JaXs85X1yw+957dm19920jkpLwJq9WMxm1FlzsPdsNUCrYb1UXrpbx5mdkBuI5jKTWArXVdPEhs5+zmDUtkz5n2zUb8Pw24jIVfe2XHeJcqBd5PMErMOJfhegFvreeqZkSOY5qk3oNwZasDOnmTSUCGfANqtrruVzU3zcylg17g5wB3tOKY3S5ss9fyXs6V7+QZJ9FpqFFczYVS72Y3s3VQD9GRQgB70pj1Usm9jYpiXESilhCtHgNrw+xajlVxbP8gyQjrD/WsTpoLIb6sAroJRRNqP5aCyTPFTfRdbopJ5aTxRt+FahSh4wqBIzGCmqc/Drc4WCTDV/xRDdvwkzR+RWxSX3oslgVkMIO83ZT7JLanHLaoGkslQ83/ArSGG5tR35i24eddjfTkH+VHRDbjHaWeJJrc6D9yfg922dRZezOrLo3r5J4+oXvtTAr2jZbxr+krdCx6bL9Q96FZ4515lhnjnXmWL1wrG4chW3vlee3C7SrdAbP/1dQxv8UTqds8RiNNmVcmLcnMG9PYN6ewLw9gXl7AvO2dXl5uc8BWMY7YHSs/fleBVtVFT8LhRF7qv35q4xtwv5+N5+zRT2Ww48OMfiOu9iV7/fo8IKKK+tPd2HWWE22Xhatmk3/OvSvS/969K9P/47o3zH9S6sMXT77l9616F2L3rXoXYvetehdi9616F1S6l/aJgrhrPP3D/IQvU2F4xb4oNzHPPlTEU6XOABwjeQ58ijaoTp35AHDfub8g1hKisr1m9QaE0f5yP4tFw7P/pAhK9gEvk42y1Ds0ajQ6vLv0x4n4uLVf7n5VcVIl4OglmYz4lpls7epTHLBj1r95GB9fp+lK8WwRN/472iGFz/M8sdm925S/XnaHzrt3WxkAMsuD29lrkwy7GKbdqJNO9GmnWjTTrRpJ9q0E23aiTbtRHJDu3RoF1Ms40uH3qXcqJcOvevQuw69S+rhS4fedehdl9516V2X3nVNN/04v+EWh08bLjyndLJuXrOZL9fibXS3XYgzV4/OQuf7/xfPuJZuk4TTSElznB7qb3I3fcWB/4ijrxJSyjbCanOb6kVqjaWYeCXDdOf1x1cU4IPnyhX0xLbKp/mcLZCo+2k63W7iaPaZvcFljxxBrRh9a03ybn9Mt3mky29yn6FJPmH4ijxeyj8hYpl7SpcBwyOhKqPuMrkziXMle8gsNOztx0J2myzlvOL/oBXviJvZZphsjZvJkBoGfkb5YS8plu+lSxzIJQ7kEgdyiQN5xIE8E2pSp4llmF+VCYHZwKu/ylxWQp7P3yU8EjdtiFxWz+Vv8Th/ssBFvXW2qxSk48NLnW9ChAs3rDT5UV56dO54tOoerbpHq+6Z/CvzEFGbsC9+K1EAdH3VtyxkC5Hg9SpKkvK2/cs2STSdxQ3v2s+ZttNv0nm5c45e6YNKpEE63tWqH3GVpLT2uWnRaRt7tI192sY+CRI+EYNPxOATMfheSzJaLmiK+aIfb3Yfyvn7xsuUkoYVXmcxsrxxaS/NpDSYh0KIzUtlDv2WSiZNsOVKj1Jp0iY+PmVW2pMfaBfYiKOYCr71U75jvHNloDGfGIhPxwbFFr70id5GRG8jorcR0duI6I0c4y5HxHxG9C75alyO6N0RvUs5Py/H9C5F67wc07tjendM747p3TG9O6Z3jd4eQoOFxQFD+CDTtUBtwMalRCDxW60v5ZH/KJaUfuCxLNjz1Yb+UUlIl5bUXcTrL/Ta7NuPciU3CCsZsWuWqKM6luNwkjZZpaGTHaECUU2WCfUhq/UZ26JkbGjzl23ELnt0quWJ6p9StnykOHotb/APlx/VRqvvC/V3zueU+vVIz2fTMX5e0FNZ0I4UqHbTwdfAligvcZMfTYh3TIh3TIh3UP7EywnxjonpnIP0zz52TaoQfeBlqVKdlEoNWiluYxJRrkklH+cSHcJILMyqFZ5Kwum3x13lSfePUapmkWmRiflPTFIrZD8R9kX8SSYO6NuO5UGHZv9AEx3tilf24enaRNn8p1W6pngIhmmjc5IMCBYc5Ni/Fv1r078O/evSv6Z9Iq/SSbr4HOVMmpHYrYCMLx95u0KPCNsnPeNM5pff3yptY5UqwVQ4EPTJ5LleOtrNMrtHXfO4IqO5whYZEiwyJFhkSLDIkGCRIcEiQ4JFhgSLDAkWGRIsMiRYZEiwyJBgkSHBIkOCZdO7pPq0SPVpkerTItWnRapPi1SfFqk+LVJ9WqT6tEj1aZHq0yLVp0WqT4tUnxapPi1SfVqk+rRI9WmR6tMi1adFqk+LVJ+WS++S0sIipYVFSguLlBYWKS0s1yQFBncx7NdEIr9E4Uyp1iGcU1ZQoRtSXJCYKqUt4ISDDwiHW91k2mK5DmR5xVKfk5ZJqiBiASyo6d1UXh/eZ7Kw0s8UiD3N0i+GUy1UL1L/+UlQ6uZrg8IL0KDhPL+tnhJvo3mUZdFMPta0flWppGn+D1iTvNvqCKIelS1QSklQ8mcudVEZW4pyKAEuUWJJSHDSl4v6/1t4Hy9UghjdTl0a/WmWmrVzsh4KtGjATcm8w1dL4juyx685WKS0wMPqUV0zzlDqHZeEJlNh8FpK/agqA1TRKBS26sbo8+r0Uw/5OLRlZv8VVHqtOJgUESpvlkZ8nZxV4/oIyrls9JXdXStlx/rAH5Tyzxv2vGHPG7afDdsRrtt2XrnusbbWn5ZRwoRXgxLTIvuD5ZEYQFpsi7TYFmmxLdJiW55v1F/fkwJYWoN4Jrosiv6MSnIS89eot10baup0KK7979azTcqmTKkKccPm5vgnw8ycxEC6EnePQNYUaZoU8cZIHCT5kZ7bIj23RXpuy7da7i+34lslEmOTijLJ5GtFqMUZrsBslACOY2Gvx9xXnrxjXRkkvCMWDCzcsFpkd7DI7mCR3cHyafv6xu0bFbf6wad+LKLK36/vwzjBtYwKc6Xe43WeaomerjcDrgt56f8kPMoNy0ObiZT4FinxLVLiW6TEt0iJb5ES3yIlvkVKfIuU+BYp8S1S4lukxLdIiW+REt8iJb5FSnyLlPgWKfEtUuJbpMS3jLHy8u1dPs3iO356FekvSi37OfyqoEzJLVvdHMBlhS4gKULXjKkqpRFvqq0b//FhPU85sPZuK5FTdLTdK1zwr+EdlyRg9+VvVRvVbMgBxzPoLYNEAPyNysrEj1tGoNSxNzcil30Rz3c3clak2KT0zVJjy/5cqHx3+uePVoId1IKdl6aLpekIKeK8so9QH27jn3iKdJNqibJhWaRet0i9bpF63SL1ukXqdWtCu5q0s9aEdjWpHK3JZI86MeB+GOV9jhd8lLb7oHpny8sqb1OO/ZZelTDJM0GYgIvVV99qnuhC0ce/9iYU7gNBeZvb5ppJSGu0+d4jw6G3ayz/4XPR0VVi3IxVbqDe+zj/KaeE6w3itUnbbZO22yZtt03abpu03TaBsG3SndqkO7VJd2qT7tQm3alNulObdKc26U5t0p3apDu1SXdqk+7UtsZGgKZkVvJWF+eSFUzLQhETAWYcVSQMNHoZPGp+/0AYAYkdCBqmRF5yHSZRUUSNW7fiteW9UxFhqXtQDYor6ZudZgdUP27YVfKNzOOkesQ5ebV/qPlRA0qwxudRhvD36jYs+vtI13YTUPI88w+e+e6SDkwOb+QlNDaGTUzmCJvMEbZtuuAJC05F4WNwFap79h1JagchuX+j+a5MrEfAQ0WQFsN8k7HHJmOPTcYem4w9Nhl7bDL22PZ4nx+SOGpKvANrWZRpCNpKLUmN3ANB2wiinx/DgolfpYpU+5wALquvcS3Zk3suncqgBtTIJNEiWs/ahUWbrH82Wf9ssv7ZZP2zyfpnk/XPJuufTdY/m6x/Nln/bLL+2e7lHpERwj51AfNCPE4CPJW4Q7iVyo/ywvG2khpRL4CLKK1V5XJjFO2Fcrv0ZOEF7MqDH7x7H/kEHX2Y1S5dhq+YxcYTn48uqdWyj/S1bNUw22RitsnEbJOJ2SYTs00mZptMzDaZmG0yMduEi7dJL20bcfELbae/2WnmmM9pEgnZQx3abBYJW6mrXct8mdfLMC/PdPXVvFKkn+2ibfhUKnOOKHsrU3SQ+wXbvEU8vYlXcRJmwg+ZkMQEmn6zu/0b+Z6MiKVnNCXdELN/1DUnlwY8AyWTfcQm+4hN9hGb7CM2ofxtUpbbpCy3SVluk7LcJlC4TcpZm5SzNilnbVLO2gTwtUk3aJNu0CbdoE26QZt0gzbpBm3SDdqkG7RJN2iTbtAm3aBNukGbdIM26QZt0g3apBu0jQmNybAr3Ay5+QqhO2+lqgmpRhUbE3dWLegDdzPXXcxFHSWcrcLdHZPLWCMVl0Szf3oggwJwfwBFhUHFmUmDSla+OW20wv06JQKp4q5O1sdKidmRnjw3s/9sIx5MoFZ2g6+UEKZK42iyDMmgt1Tzx8yr89RAROnTyvj9NtlyNZmInhtVZ0ZfBRMAXhvQbBbLIZm6xA20xhEY5upYCf+g0vNMkWeKfDKKfIpTRNwIkiirhrx07ONufntkeDLU2GSosclQY5OhxiZvC5vUwTapg21SB9ukDrZJHWyTOtgmdbBN6mCb1ME2qYNtQqA6pJNzSCfnkE7OIZ2cQzo5h3RyDunkHNLJOaSTc0gn55BOziGdnEM6OYd0cg7p5BzSyTmkk3NIJ+cQntEhBYJDCgSH8IwOXXEduuI6dMV16Irr0BXXoSuuY7ziBgSnhy6GfAWEdpY7jAk5ovGg4lkQxGvpjHsVssuftIWk7DKYfUnv381KUD4ynN0lEcz0eSVQRkWi52EwyqJcC/QjomxU61ccCkowEoXKoT7obhCKzgVeQP7935tY/vma0emODTzXX3mzK2N6iEZzqM/037ep9utNVHwVEaDi/Jd4sXwHCt/sfiulOUxk2VcKG6CmNarjGPhQlOxIWBt1B9KCHTZD+IghyO+Iq1A5MC1uiRyq6Fi2Xb9dXZcyJB8ZZFhNH8+D6SSJRifllz5XQzewEj3iiSgSgU90pFo0q9KMvmz4ZoUC6JMNmqiTFu6UD7zIujV7euMbdbTfeTOdN9Pz30wdeoc4r9wjACA8XHrzrHdIX+eQvs4hfZ1D+jqH9HUO6esc0tc5pK9zSF/nkL7OIX2dQ2h9h1QpDqlSHFKlOKRKcUiV4pAqxSFViuMaT1VsnE8w1YTZIl6XYFqU1zCcb7OQFjXdRCWWVW48gYarIOECBCbb5tFHKeTCCmKq8PvGHEdN9Y5iY5TwWC5+tkJMUxGgY5qkec0jS0EO1PPKSKrNk7Wo7PCTBSc6T/rDJr0j25h/VGiimdTMGjYx6SUd0ks6Rr2k5grI70IlfpowBE9mCTuqoQFtXllEWSGbU0gKNIcUaI7nmlGJ283nSAadoZ+vPyAajQRec8AGud3mTzahj2h2wOndstdMpwwpIx1SRjqkjHRIGemQMtIhZaRDykiHlJEOKSMdUkY6pIx0SBnpkDLS8cdGlaFyzKY/lcJXme9a3KP/s4WcmciAL8vb9HfB1hhnuYOygksD/Nf/Lf8sIxVF+TTcRL8Uq0S3A2qZNHj8WCYKsxf+O5LSzJv0m4xDRBFPP0GldMNzLx+rf3cPK66e3bx0FiLOOsJtYRpn021c/HSXReEXk/rEIS25Q1pyh7TkDmnJnZFJ081kXHm7AHgRf+dC9hUGxUxt/iJ6Quj5oxruirV4x3BuAtL8VCyztCgSA9bLIQOEQwYIhwwQDhkgnJGJX8jvzNRhr/y55qnIbB7MUs3xaQofnOTJFuBvdWDAhRDZb03zT4RPJh6HTDzO2JRfjEOg+FeUupU4gcFtT+hzRe0y7LD+EQGnelweXoOXf4f9e4p1u4my+3gaHU7NW103ldXQsHIE0HdI7+uQ3tchva9Del+H9L4O6X0d0vs6pPd1SO/rkN7XIb2vQ3pfh/S+Dul9HdL7OqT3dUnv65Le1yW9r3vptGpYa9G3gixKInZMfPqK8KhL7ggTaKG8SB2iYnVx4fN9Fq4i3dWfb7LFAjitArOslkr3z1O+G826/LbBK39MK0aS90k6/XITrwC1FeX1bsypShGJztcNzGSrmP5nG2e1YUoDBu8O5xiqMEbMs1oc7aCtRy3DMnVFm5ajr5zWYffe89qe4Np2dLOdvLKPwDUg5+hPrLzJl1yyCLlkEXLJIuSSRcgli5BLFiGXLEIuWYRcsgi5ZBFyySLkkkXIJYuQSxYhlyxCLlmEXLIIuWQRcski5JJFyCWLkEsWIZcsQi5ZhFyKcOGSzswlnZlLOjOXdGYu6cxc0pm5pDNzSWfmks7MJZ2ZSzozl3RmLunMXNKZuaQzc0ln5pLOzCWdmUs6M5fgRy5d81265rvGa36gBfq5ztJNlHHNaVXwL5MC6qCYX7YiT0GShJs8Uspho5eoClZFf6DuVbqMcpUrgdTAf8R/qrBbMNg2VcMc9JxsEZ3zvZR52JWh2GYqimNFZxRRagTZt6qvaqmHMr5KXag2r3qld57HFKj1qRK6SwwPYysD+OEtJjfLB9VQXVX0N29RmqClhz2CT36OkFJCx+mxHmghuqvXMB3L12yqlmZEDW/P7GqRx4wrI+a7EnaKhxXb54es0aQ+FC1mWYl9zyuTRGNR0HXjPMl5V3OuxepphsAyUWXLIEuiMlJJk+6PlT4PxjA6b+LzJj5v4uE2cUdX68tX7vgoR0yiAiNe2SUltUtKapdQni4pVl1jFIxp3Q9QklchwtJWFHCrcFOaWESuqWj65S79JpI+cUv9tymb6fg++rR5kC3qoDKkt852dQH3jnJTjO+ILkxLS3IeacVd0oq7/mWro9ObcPoFYv169iaDHWAd5XmNgUl3TZHric6DmLS20+qmlrmx/lC9ezJFSm+dfYpFhY0lR3TA3UMVK8vtzLCgZM5wfbvNlPQ+rARnItXfU8Wp3NvAgFEqeRiKVn8Ml8w+Lpl9XDL7uGT2ccns4xrNPhzsk7YcZzoqVwlMVPJhvdkKRCr9/m27uouyxgH5hHFbu+5mX3HoZVaJVxuuYwgytXMaudTZohEvI2OIS8YQl4whLrkMuKSxd0lj75LG3iWNvUsuAy7pk13SJ7ukT3bJZcAlbaVL2kqXtJUuaStd0la6pK10SVvpkrbSJW2lS9pKl7SVLmkr/baYwEGWJmzFxTgx2fBV0VQq4s+SZRgLK+mzDU+n4TpdwxNZ2OAMVSjL9jwDpcnK+2rOtnC8CsTC5HurRmwxEWftqNrxehllMUVTPfLrPNn1/rqYamQIP6ZaFs3jb0dUzLfz4ypOecbA/IiqR00rz/F93KSi7vFTitpI5Q2qbKlCvCee74K7nZiqw/X4TB2uJyfqcE0+T0f0MMzCVVAIx679dTlXO+abyp0raDImbkpulB573tZchA+zA+MB0GQrZ5ZxZhlnlnGiLKOr1CtIRThqk6kqLMIgTpGB1SUDq0sGVpcMrC4ZWD0ysHpkYPXIwOqRY41HZhSPzCgemVE8MqP4E5PeAMxNyjyfazKQ/F3hU9UHtJkV3VWexXmVJ1UeShh/4wHtvNbXKiimypMsWoWbIIkW4bTZf0BexJjrj6Yy+2WjF7Q4s1AB2JsMvVrwSAyXeQWaR8p5QQ4sSHfJkxpAMbWBoeFchXvvRB5ZLz2yXnpkvfTIeumR9dIj66VH1kuPrJceWS89sl56ZL30yHrpkfXSI+ulb0yJQfHqQt3J/t18LngjlGIrkeyD1zOXXhRpMIs5Go+XVK899bIKJTYfVs56Plm5saZQ3JrKcbS1PsPxow24rU6kJqJRg0gxnpm7pYiRJIf6Yksdd7XwWD5Q9516+PI1FqjJNR62wi97NbtiIP4rq6Ev5tyWLQriPMyZSJamcwPvIJSCRygFj1AKHqEUPEIpeIRS8Ail4BFKwSOUgkcoBY9QCh6hFDxCKXiEUvAIpeARSsEjlIJHKAWPUAoeoRQ8Qil4hFLwXK49MYV2/ByF02XIVbNv43CxTnPpynaNEX2OckYqtBZslFT0Bx851341S6sU2HzMJoo7dJhezdk5FQBfUoYVMVUrhfC1QPOYapFRIcCA42nl1Dd/soimRYC0kzuyueb7P4tOktzMaKm1Kj95mVy/r5vsUC9bbatEuOpy3Hu+Bewv9a6tDutwFk5FxyLpb2mqSTUKssntHYEIYcTmuCSmw3X5egThdLrNhISx7wU212tuXmB/3kdZuHhQfxjHrFC38T152diuxasknYQ5Nz/u7R03aDKBJm0nB+JewSz9umYjj9j9SGtHuq5yRvLYLHx/bz83D5/z9j5v7/P2fort3SFq0/IraRgR6m1T5K8kIUjNk0E4IeCiR8BFj4CLHgEXPQIuegRcHF1etiQcDmZ3PHUb+1PXbsFxtFIwTVLGyMI126xwlec3zXrvuAp0XYaNidemak8WJLKfEXQlkNp67Ee54Nl2HdxF6+lyFWZfDKtNmVk8wqR4hEnxCJPiESbFI2c/j2ANHsEaPII1eOTs55F13CNnP4+svqNLaz9d0CQeO8Hc5h2sBFygnHMI98LLKQDmRHo8c4aZ0WmWS5cnVXsKdAnbiQRHAmxhzRenEHBq5N8ALFsEzZbEVpnAp/Po+wdPSlf061Q0MpKAxeYK5mGcbNkwDDRMWAOPsAajS3tfRFuOwucflFNQb+DJvH7bW+0SweG0M3126mQFqdpMk0hbnUAaHgUK9MjqPzJ691ylCHGfR9JjWeN8q7IoXCzYkS/IVRbWmXjZqUfi0Bqdaa7Eg/rW5eJ4zcWBJFRwujDRNoEuPAJdjIxpXXO2aafLYBEXyy3xEP2D9d9MUCchNnhC1/Z9zfdM6POYncazOBdyYzQLBGjJNLE2TanJeEKfSbPNMhTJuto++2RYr0qLndmsdHSXnDJpIGBCzDotSHdlnC0SDQjp4xHSxyOkz+hy1Hbga9/jaPb/v7prYW7bRsJ/BSNPp7bGUkm97ZvOjSwriSZ+na2016luHFqkZCYSqSFFJ74m//2+bwFSpMw4zZ3TS5zWCQEQi31gsQsuFtpozs22uRd4mazojb9UOZSN6snCVP/H4f3V+iFb3Uv5IvpaIq26VnlGhbxxkNI31+mTaYISSE9FqmdQ3tsxnSXTP/3+myZFLCGXWK8SjNaWYLS2BKO1JRitLcFoXeugNA6bblzeEMtEtPAVzXEz+y1nrS2IV/QZmd8a/ZM5NV976E+XC1My93zOoTHjcsNp2XyQSMK2RBK2JZKwLZGEbYkkbEskYde2PhExiKUr8oKCmWCgwWV3l16BLDCV/WBeRh9tLl+/MVsI2sRG4UKPOs/zHDJPxu//AyZ/sQhk41s5Ky/SFmSZMEjIaFtCRtsSMtqWkNG2xF+0Jf6ia5d5rFNQCd2vnfdhEC7vNQShgK7YfOd5ULViGl8aCyD8TZKd6tWVcx6jyTPFlGdpoWIw3zXXIusqpm9ZyqzcgCrF/+n0xTeM/NdbUDplgrb051rjheU2pATvdO0ylzP/qsyTfFdPZjcWoHy9WVhuOXoR902hDniQz8WgXa+MRqJ/JbSpI6FNHQlt6khoU0dCmzoS2tSR0Kau3fzkFlI4TSAq640qijw5i+9ex7kzJroqW9o0MXM1QHMtN6nlytxktfD5jfr6dnNdua4i9eGgcvenUE6leD2Nwji+zu5iKpiwJeT5s3w/+HO7R98PPZ5KNLON9UIgz0GJ1Szo/hsGvcwQJkx5IJodiaLrWHoSl6WLM1EL7Ic1BQv6AYCnM6Q/AfUvdqZjh3krrmdhBBwDP6f3y0jZE1LKLLe1ldX+tGfoLO5jv7Br5C08irLZ8xTAJUUlY3myc27/1dC+nque7oTyEFgJvUvNli/KAvm5LC9fMUfbT7l8IumX4xIcm6XbXdH0O8OQ95/Hj+JZmtks/ILbz74RTCUG6hFE291Szzryvkc8zYdjrpKM93LhPS/1ofoSS7FTmkMt/873SAL5tBQ9xvFe2faqfu17RJinYR/B9qBsYwHvfI+oZrHQj+FbZjN9ceD8t8TfTfzmY2iX6esvt0i+EcS33LnU7X+Id9cqY/fWa98L8tq20pdT6BPs63DFeKOpt9IgUeJFS/YxDOZASH8lMP6Zjfc3DYylmG/R6RZapHlysm8UvUL1UHegY7yyNsUuckcVsxadQov8OZ+sSbPQ5Fgi3rbgWMWxmFvEM8O5Vai+8jmMQoMiiMJX76xNkWASTvdIfZbU6BP16QZYvkmzSAze+vxI9cX9+jYMHmmQHt/JqtuFanoLj1TPtvjdLBIxvQ7xE9VpTFqhSfMjJwHkGK4gdFPqYQtT78ZiYw7C5QqAI5nbi8Xy2gsif3orewQUcc+k4zlUM2cRe/QrQ9dbaK5pCcfajBmx8BifeMsziq6ZU6lnlAaDyDtrSXPloxEh3kQcGkPdhDposaMG5ycno+PhpbocXpxfjifBjrq4PD+9GB+q8YvhpvpkeHY1CSbBb2GinMhT61tP9UfqfOVJ7KMKZ6paHZiwlmp1Xzl43sSyquH7ME78dbWq4COqOJyt37Ebfpv2KfJJ5NWl90jNQ2eh/FitQ8UkFgIqgUGiJmDbelJhgR8p7tewjX6i8gn0x1EOc2dHjfEaKO9PPcWEJqvbMJoENYyKFad+FGEcu0wXsQjn93vV6qEibpL2Ud3cK9eT21dh+skAqneSlknFt87Kq6pd3rW2j47j2301ihdO4MZ7dYyQfSzC8K1a+G+9er0+qWyAjqFyY51JEh2kym0DeuU5bwWYFiKFXueJM/fY7/gWFMF/jnpGPQmkdDTuFoiLME5ztnCMnIMGuSMn9lwFyARgsgvvq3e3zlpVIcMLt4oaALjxpuHS+7tB5da507yG3gpBCq7C5LWjLoAIWLncVzfJWt0bsZhFzpzi7LkyLGGEMPWXEIzgOI8APfKmPsUbjL+VPS/dSew5S0g2OVhTqaBBiNWbJF4rHaDjyyBc728ZyGp16TlxEqU1KXLVqvTzKtYImH1txVBnyKirdl+y6ytitK8uL45O9pW5vWdPObHpBRznBxlxGgw6IwaKJnolnAR2XV2igZaR6hFnmDo2MwzCzrAZkBS6Dq836urqPljfyi0aIOGkcoUpofS9A5BrzoxU2NG8WVezhTMn85nRR12twnWMZrunPphMbJ2VDqT1vRhjDlw2hcyAhmxG/CCUk6BVx9BykAljUvnVD2LV5/bhpEIBOQ6DHw2peZpHzfz3XowRe4uFvDFLZJLizdFMiA+9J8BYCyJLYlSIlK5i4lSgGIOC1GkQlwSLNPAXoaVstOuUBT179XSsq+e+FrelQJTcRaD/zFz6R8ETgUXlveIatRam1Go1/oUZIGHRROZ1uq1bEw1aC2c1ysZrtnpuFieXDRtWo1Oz7FrDHlv2Ycs+bNspn4+HZ+PR+Dc+bmZftWp37Y5iwCjYOzWRTeqdv75FXavRaiqxdIz00a6IGW7Y5BPl617pSHasmQ2bhccUH3YEPV5v/WCgD170L/uDMTTvLmVzj8UfVHZxtPqgJRd/n3oOPw+qD2hQ2/x82Pob/2IPl168guCmOuKDatetn2wL/ziKILKgdrGe71wk0Vbb0RImnKd2Y8wk5cnNTpBAaWzyBhab/3QOVe7cQSdFfvz23jQ98fEipSbfVvIEzpKF2mXIx8J7L42FJv3LwYvReDgYv7ocGoZjnQapD2Wia0sSdO0KsdOYa1pIByyQPTxyvMunvmyTexGZYwmr9CenQ9Vr8HFz8+Oh6rZYYhKSwXaU/rPR0xLUw5E7qtLxnIVQ4HjWOsC5c3yZCQaXl8PfsLieXpyfQcpkZT3FQqmyCCaRsBhEkJtd0ikGfQfSLO73DkXu1WuI+2u122z2FM8FAPieFMdSbDcOisWO66L4oFMs5Qn9hX+Dms5WzfqeWx/bFTL+F8P+yfiFuhr3x69k+JOk0bXaihxR6VkA0NayfsjqHko6yltTJYo4pjjzBYrBrtYs7l7W5kK7DOrOD/UKylllNXupaAzGo/Oz/tHJUI1OYcD8MjxN6XoR+SHkF4rP1YoNWgSeC0+8yB7xoe5iR0GV/z64HI1Hg/7Jv9SrVLsdeyvetB5M79VAVNyWpjnVoWaiWkZxnHgs3awtKUb4X2vIPTZkmmzx64CJyAuA92lU58GNApBRZjtwCKb+itKDhsYboS0SASnxu2bO1BOTyVGBl6B+oVbO9C2YIK+MgjcQKxg1pnOsGCClQ3nTqxmNI00GrFK/nw6PR69O/wWFJZckKF4LgtdFviERWxTo54y4IhnIIeUveBp9gcUsfBcrfaaH6y8eMTtkjsQiXtRit1jqstJPkurSm8lsJcJJ4Lt+pFcIA8WgjPnrJhj98A58VkdJLCtssoLlSTlcLpPA7A7KC7QUCtR/oztNCdPMEeYYVlICfqjnoauYx3OLJK8Z5c2pmn2xeF2kDC8LNPYGrOMBOyP6u8+coBYma2qxzwjKKGU7FJMOlU0RuUJfa4pFqOKlTFvallNfvD4XZpbosTiHtDnBpEx4kdBJPhXWpsl6rS0r2JwRLR6Zb1fjy/54+Hw0UKOz8RA+wvPh2WCYUmqSuL2mi99Tx4ZJKpY5HJpJAJ3oveeXS4yPy83SWQEWFow69S1XE6hLb+bLgvYWi3zexNlXS3g2shRhdZ+zgDaPts9gNorjIHNgnnBdyvkWkAvvLlxIxENqx/0yunrVP4Hf0786PxudPYczAJvjxysa+D/uaYXOO4VBQCWFwtij/kkfmB5fnw3Hv55fvgRXBxud7a3fhdFbbQ1kURbe9qpaT+lkvA8xM01wtDblBzx8RnY5hu9QmA0oEevnpXgc9s/0U/ZMY6yT8A6hysSgadpq1zceiW5wQrmE4jP5W9mqZ9d7P1ATyjKjmx3TtFjfs7pV7zSxZM3V5oBXyvnj89P+6AxrF/j+z7HaxbTS1Dd2iKHciA4wtdOx+DJCuwd+8OscIVTW0cBs8kwCvbGDFcve21dmEweLURdPNKzUbruHf2abM3hmldmIwVMHT+mmCx6beEw3WPBo8V3Yamq31UqXtX+8Gg1eQiaeDS9TgX7NmSuZ/Q+V/NAAxNho5ZkSmn2TwNh6ug0LjLlHW08be+c6gFjawGTQy4l+w4YNQkPPvK8uf4ZFpC7k95H8PuFvMxwJB/Sv/fSCskMVQNfINQSM4XGyy00P1R8f9fUKa59+uLPIAnz0hoM4PPJvCVEpFjbrls2TR5s9I9ltqHe6PFlUKcQR8c2NzcQ4Jn7RNUZVhVbV/uYcnGxbMYjCGG0Vsdr2s6Sv3KCTR6ZJZpwNH1KLTY7vcMtDDDq5g5ExU5sTsTDI2pKXSD5j6E/LmbUmG3ccmS85kfROJ7MtZ02fJ1gfTHDPMyK+1kD5LC483V79KotMNE4K9QX+vcg6HjBOKkx7zqWM0GHQJ6AgvRHT+iq5kU0HDU72QGUh3GJLo962GiVs6TaYdeAhW7KVgmTlOLiAmJWPRQyuBRpCabmCobLiLR7BOm3B1ChmZ0vI3ZbdXvj62nZI5E2eTKnIZVeHvD3OHGRiDmsIkmVyy26gMsVK5VXwNoCzTLgHIh5bfTZsIcKN8Sm26GDXbZuhgtt0aEvc10M6+KFgm9uqFh4yqhglTAEKiIw6rGAF1o+d3sd0/mxPDkyDBrM5PJgcuvQBdOmD2xsiv4JvbHwdwu10Nb9zclqE1pA8EtvQdOTWQ2iJbK/bnVYni9ZLkYcmQ6/3WsQ+mth6OFp6Hv5Rgd4XIWOyi8rSeS9EImjaZtebxpuAfu6tVm6x+K492VfkZv0aqoZL7lLzsdHqWnVhC7q/dv3ZzJ8mi7VmI0+GmVdMjhGIzEGn1WvbdUaEVihIvJnFvb5J5iQgOuvpCcLdAjmIzJTzevjG09KfcHkoUOgKRVkxSNR4RpySJl9DTGYV7oemrac6w7qwwJ1rXuRkprLTtQ4sp1fJfeCQYsfq4Y8E7wbmIj7XtMeftq5IRb6y07bwR0pzY9hpWfjT1jFMi0W8BS/L+qaLHVRIt/pDDYdwAFiVwueZPHyT3i7Oj5d05GdQzblwsfZXtRtSsxLNb5xdKlseOqZ+AxPbezpVrm7Hs/ZZywaTJZlf+ca0Mmpz7vinLW0JNZRIJCoHire0JLk/09LWLWPPbAttWuqLZvirJy2beynHNfuzYVppG2kNzblnQsbunNhgvgPS3lizbPQz8OIGHlVGTs1nGW+hrtlr9lpWdidQDfMi3PBQE5tuV7rcxsl0qrUCBMI5cDTzPG6ISdkNWSdl73QgeMbmjmYzfLTt/iXJjme+m4HfS5HPP4qk2JnNelPLyn9VMMWOo4tdf6lRaoL+GbqmUadjGWDwLaCzlyUQLMttzWYPILTcmaWLUwiWZduNRgGCZfV606lACDyj1bbHb1klvXNoxd45etsu9D4F5qZ3KJbIf186ekJ40H+vB8L1tke/RR/2bugjK2XkuaUYtPBTgkGvV4TA/rcgTKcN/AiEcArbu6T7ZnM6vbl50D3J43lFBKSvfPeNhuMcHFQ+8uc/OeEWIcy8NwA=";

// --------------------------------------------------------------------
// WEB WORKER: JSON Parsing Only (Decompression in main thread)
// OPTIMIZED: Main thread uses already-loaded pako, no duplicate CDN fetch
// --------------------------------------------------------------------
const workerScript = `
        self.onmessage = function(e) {
            const jsonStr = e.data;
            try {
                self.postMessage({status: 'PARSING...'});
                const data = JSON.parse(jsonStr);
                self.postMessage({status: 'ANALYZING COSMOS...', result: data});
            } catch (err) {
                self.postMessage({error: err.message});
            }
        };
        `;

// Initialize Worker (minimal - no pako needed)
const blob = new Blob([workerScript], { type: 'application/javascript' });
const worker = new Worker(URL.createObjectURL(blob));

// OPTIMIZED: Decompress in main thread using already-loaded pako
function decompressPayload(payload) {
    // Update status
    const statusEl = document.getElementById('loader-status');
    if (statusEl) statusEl.innerText = 'DECOMPRESSING...';

    // 1. Decode Base64
    const charData = atob(payload);
    const binData = new Uint8Array(charData.length);
    for (let i = 0; i < charData.length; i++) {
        binData[i] = charData.charCodeAt(i);
    }

    // 2. Inflate using main thread's pako (already loaded from CDN)
    if (statusEl) statusEl.innerText = 'INFLATING...';
    const jsonStr = pako.inflate(binData, { to: 'string' });

    return jsonStr;
}

let FULL_GRAPH = null;
let Graph = null;
let DM = null;  // DataManager instance - initialized in initGraph()
let Legend = null;  // LegendManager instance - initialized in initGraph()
let CURRENT_DENSITY = 1; // Default: show all nodes
let ACTIVE_DATAMAPS = new Set();
let DATAMAP_CONFIGS = [];
let DATAMAP_INDEX = {};
let DATAMAP_UI = new Map();
let HOVERED_NODE = null;
// SELECTED_NODE_IDS - provided by selection.js module (getter to SELECT.ids)
let DATASET_KEY = 'default';
let GROUPS_STORAGE_KEY = 'collider_groups_default';
let GROUPS = [];
let ACTIVE_GROUP_ID = null;
// MARQUEE_ACTIVE, MARQUEE_START, MARQUEE_ADDITIVE, LAST_MARQUEE_END_TS - provided by selection.js module
let SELECTION_BOX = null;
const SELECTION_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
const GROUP_HALO_GEOMETRY = new THREE.SphereGeometry(1, 12, 12);
let SPACE_PRESSED = false;
let IS_3D = true;
let DIMENSION_TRANSITION = false;
// STARFIELD REMOVED - nodes ARE the stars, no need for confusing background dots
let BLOOM_PASS = null;
let BLOOM_STRENGTH = 0;
// EDGE_MODE - provided by edge-system.js module
let EDGE_DEFAULT_OPACITY = null;  // Initialized from appearance.tokens at runtime (token value: 0.08)

// PERF_MONITOR - provided by perf-monitor.js module (window.PERF, window.PERF_MONITOR)

// Initialize after DOM ready
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => PERF_MONITOR.init(), 100);
    // Initialize SidebarManager facade for sidebar controls
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.init) {
        SIDEBAR.init();
    }
});
let DEFAULT_LINK_DISTANCE = null;

// =================================================================
// THEME CONFIGURATION: Loaded from payload at runtime
// =================================================================
let THEME_CONFIG = {
    available: ['dark'],
    default: 'dark',
    current: 'dark',
    colors: {
        edge: {},
        viz: {},
        console: {},
        schemes: {}
    }
};

// Default color configs - will be overridden by payload tokens
// Edge mode configuration - populated from appearance.tokens at runtime
// Fallback values are defined in appearance.tokens.json:131-204
let EDGE_MODE_CONFIG = {
    resolution: {},
    weight: {},
    confidence: {},
    width: {},
    dim: {},
    opacity: null
};
// Edge type colors - populated from theme.tokens.json:501-512 at runtime
let EDGE_COLOR_CONFIG = {};
// FILE_COLOR_CONFIG, EDGE_RANGES, NODE_FILE_INDEX - provided by modules (file-viz.js, edge-system.js)
let NODE_COLOR_CONFIG = { tier: {}, ring: {}, unknown: '#666666' };

// Console logging colors - populated from theme config
let CONSOLE_COLORS = {
    success: '#4ade80',
    error: '#f87171',
    warning: '#ffaa00',
    info: '#4dd4ff'
};

// Viz colors for canvas and fallbacks - populated from theme config
let VIZ_COLORS = {
    canvasBg: '#03040a',
    nodeFallback: '#888888',
    edgeFallback: '#333333',
    groupHalo: '#88d0ff'
};
let FLOW_CONFIG = {};  // Flow mode settings from THE REMOTE CONTROL
window.GRAPH_MODE = 'atoms'; // atoms | files | hybrid - on window for FILE_VIZ access

// Layout stability: cache node positions to prevent re-randomization on toggles
let NODE_POSITION_CACHE = new Map();
let LAYOUT_FROZEN = false;  // When true, don't reheat simulation
let HINTS_ENABLED = true;   // Show mode toasts

// FILE_GRAPH, FILE_NODE_IDS, EXPANDED_FILES, FILE_EXPAND_MODE - provided by file-viz.js module
let LAST_FILTER_SUMMARY = null;
let FILE_NODE_POSITIONS = new Map();
let NODE_COLOR_MODE = 'tier';
let COLOR_TWEAKS = {
    hueShift: 0,
    chromaScale: 1,
    lightnessShift: 0
};
let VIS_FILTERS = {
    tiers: new Set(),
    rings: new Set(),
    roles: new Set(),
    edges: new Set(),
    families: new Set(),  // Atom families: LOG, DAT, ORG, EXE, EXT
    files: new Set(),     // File-based filtering
    layers: new Set(),    // D2_LAYER: Interface, Application, Core, Infrastructure, Test
    effects: new Set(),   // D6_EFFECT: Pure, Read, Write, ReadWrite
    edgeFamilies: new Set(), // Edge families: Structural, Dependency, Inheritance, Semantic, Temporal
    metadata: {
        showLabels: true,
        showFilePanel: true,
        showReportPanel: true,
        showEdges: true
    }
};
let SIDEBAR_STATE = {
    open: false,
    locked: false
};
let APPEARANCE_STATE = {
    nodeScale: 1,
    nodeOpacity: 1,
    labelSize: 1,
    showLabels: true,
    highlightSelected: true,
    edgeOpacity: null,
    edgeWidth: 1,
    edgeCurvature: 0,
    showArrows: false,
    gradientEdges: true,
    boundaryFill: null,
    boundaryWire: null,
    backgroundBase: null,
    backgroundBrightness: 1,
    fileLightness: null,
    clusterStrength: null,
    currentPreset: 'tier',
    colorMode: 'tier',
    sizeMode: 'fanout',
    edgeMode: 'type',
    // Amplifier: Power law exponent for visual contrast
    // γ=1 linear, γ>1 amplifies differences, γ<1 compresses
    amplifier: 1.0,
    amplifierTarget: 'all'  // 'all', 'edges', 'nodes', 'opacity'
};

// =====================================================================
// FILE BOUNDARY & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
// fileBoundaryMeshes, fileMode, fileVizMode - provided by file-viz.js module
let originalNodeColors = new Map();
let clusterForceActive = false;
let hullRedrawTimer = null;
let hullRedrawAttempts = 0;
const originalColorsForDim = new Map();
let flowMode = false; // Hoisted from line 7333

// REGISTRY - provided by registry.js module (window.REGISTRY)


// =================================================================
// GLOBAL CONSTANTS (Hoisted for safety)
// =================================================================
const SELECTION_SIZE_MULT = 2.2;    // Make selected nodes BIGGER

// OKLCH PENDULUM COLOR OSCILLATOR - FULL RAINBOW EDITION
const PENDULUM = {
    hue: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,        // Set from appearance.tokens
        gravity: null,        // Set from appearance.tokens
        length: 1.0,
        rotationSpeed: null   // Set from appearance.tokens
    },
    chroma: {
        angle: Math.random() * Math.PI * 2,
        velocity: 0,
        damping: null,
        gravity: null,
        length: 1.0,
        center: null,
        amplitude: null
    },
    lightness: {
        phase: 0,
        speed: null,
        center: null,
        amplitude: null
    },
    ripple: {
        speed: null,
        scale: null
    },
    currentHue: Math.random() * 360,
    lastTime: 0,
    running: false
};
// =====================================================================
// HOVER & SELECTION STATE (declared early to avoid TDZ errors)
// =====================================================================
let _lastHoveredNodeId = null;
const selectionOriginals = new Map();

// amplify, amplifyContrast - provided by core.js module

// =====================================================================
// DATA MANAGER: Minimal runtime checks for deterministic self-test/parity
// =====================================================================

// =====================================================================
// COLOR ORCHESTRATOR: Centralized Color Intelligence System
// =====================================================================
// SINGLE SOURCE OF TRUTH for ALL colors in the visualization.
// Everything reads from here. OKLCH transforms apply here.
// =====================================================================
const ColorOrchestrator = {
    // =================================================================
    // BASE PALETTE: Semantic color definitions (before OKLCH transforms)
    // =================================================================
    palette: {
        // NODE DIMENSIONS - VIVID BASE COLORS (high chroma for bold schemes)
        tier: {
            'T0': { h: 142, c: 0.22, l: 0.68, label: 'Foundation', semantic: 'stable' },      // Green
            'T1': { h: 220, c: 0.22, l: 0.68, label: 'Domain', semantic: 'structure' },       // Blue
            'T2': { h: 330, c: 0.22, l: 0.68, label: 'Application', semantic: 'active' },     // Pink
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }      // Gray
        },
        family: {
            'LOG': { h: 220, c: 0.24, l: 0.65, label: 'Logic', semantic: 'computation' },     // Blue
            'DAT': { h: 142, c: 0.22, l: 0.68, label: 'Data', semantic: 'storage' },          // Green
            'ORG': { h: 280, c: 0.24, l: 0.62, label: 'Organization', semantic: 'structure' },// Purple
            'EXE': { h: 15, c: 0.26, l: 0.62, label: 'Execution', semantic: 'action' },       // Red
            'EXT': { h: 35, c: 0.22, l: 0.65, label: 'External', semantic: 'boundary' },      // Orange
            'UNKNOWN': { h: 0, c: 0.04, l: 0.50, label: 'Unknown', semantic: 'neutral' }
        },
        ring: {
            'DOMAIN': { h: 45, c: 0.22, l: 0.70, label: 'Domain', semantic: 'core' },         // Amber
            'APPLICATION': { h: 220, c: 0.20, l: 0.65, label: 'Application', semantic: 'logic' },
            'INFRASTRUCTURE': { h: 0, c: 0.04, l: 0.50, label: 'Infrastructure', semantic: 'foundation' },
            'PRESENTATION': { h: 280, c: 0.20, l: 0.65, label: 'Presentation', semantic: 'interface' },
            'TESTING': { h: 165, c: 0.14, l: 0.60, label: 'Testing', semantic: 'validation' },
            'UNKNOWN': { h: 0, c: 0.02, l: 0.40, label: 'Unknown', semantic: 'neutral' }
        },
        layer: {
            'PHYSICAL': { h: 220, c: 0.14, l: 0.62, label: 'Physical', semantic: 'concrete' },
            'VIRTUAL': { h: 142, c: 0.14, l: 0.65, label: 'Virtual', semantic: 'runtime' },
            'SEMANTIC': { h: 330, c: 0.14, l: 0.65, label: 'Semantic', semantic: 'meaning' }
        },
        // EDGE DIMENSIONS
        edgeType: {
            'calls': { h: 220, c: 0.12, l: 0.55, label: 'Calls', semantic: 'flow' },
            'contains': { h: 142, c: 0.12, l: 0.55, label: 'Contains', semantic: 'structure' },
            'uses': { h: 45, c: 0.12, l: 0.55, label: 'Uses', semantic: 'dependency' },
            'imports': { h: 280, c: 0.12, l: 0.50, label: 'Imports', semantic: 'external' },
            'inherits': { h: 330, c: 0.12, l: 0.55, label: 'Inherits', semantic: 'hierarchy' },
            'implements': { h: 165, c: 0.12, l: 0.55, label: 'Implements', semantic: 'contract' },
            'unknown': { h: 0, c: 0.02, l: 0.35, label: 'Unknown', semantic: 'neutral' }
        }
    },

    // =================================================================
    // OKLCH TRANSFORM STATE: Applied to all colors
    // =================================================================
    transform: {
        hueShift: 0,        // -180 to 180
        chromaScale: 1.0,   // 0 to 2
        lightnessShift: 0,  // -20 to 20 (percentage points)
        amplifier: 1.0      // Gamma for contrast
    },

    // =================================================================
    // INTERVAL MAPPINGS: For numeric data → color gradients
    // =================================================================
    intervals: {
        markov: {
            stops: [
                { value: 0.0, h: 220, c: 0.05, l: 0.35 },  // Low probability - dim blue
                { value: 0.3, h: 45, c: 0.12, l: 0.55 },   // Medium - amber
                { value: 0.7, h: 15, c: 0.18, l: 0.60 },   // High - orange
                { value: 1.0, h: 0, c: 0.22, l: 0.65 }     // Max - red hot
            ]
        },
        weight: {
            stops: [
                { value: 0.0, h: 220, c: 0.08, l: 0.40 },
                { value: 0.5, h: 180, c: 0.12, l: 0.50 },
                { value: 1.0, h: 142, c: 0.16, l: 0.60 }
            ]
        },
        confidence: {
            stops: [
                { value: 0.0, h: 0, c: 0.02, l: 0.30 },    // Low confidence - gray
                { value: 0.5, h: 45, c: 0.10, l: 0.50 },   // Medium - amber
                { value: 1.0, h: 142, c: 0.16, l: 0.65 }   // High - green
            ]
        }
    },

    // =================================================================
    // CORE API: Get color with transforms applied
    // =================================================================
    get(dimension, category) {
        const base = this.palette[dimension]?.[category];
        if (!base) return this._toHex({ h: 0, c: 0.02, l: 0.40 }); // Fallback gray

        return this._applyTransform(base);
    },

    // Get color for a numeric value using interval mapping
    getInterval(intervalName, value) {
        const interval = this.intervals[intervalName];
        if (!interval) return this._toHex({ h: 0, c: 0.02, l: 0.40 });

        const stops = interval.stops;
        const v = Math.max(0, Math.min(1, value));

        // Find surrounding stops
        let lower = stops[0];
        let upper = stops[stops.length - 1];

        for (let i = 0; i < stops.length - 1; i++) {
            if (v >= stops[i].value && v <= stops[i + 1].value) {
                lower = stops[i];
                upper = stops[i + 1];
                break;
            }
        }

        // Interpolate between stops
        const range = upper.value - lower.value;
        const t = range > 0 ? (v - lower.value) / range : 0;

        const interpolated = {
            h: lower.h + (upper.h - lower.h) * t,
            c: lower.c + (upper.c - lower.c) * t,
            l: lower.l + (upper.l - lower.l) * t
        };

        return this._applyTransform(interpolated);
    },

    // Get raw OKLCH values (for advanced use)
    getRaw(dimension, category) {
        return this.palette[dimension]?.[category] || { h: 0, c: 0.02, l: 0.40 };
    },

    // Get all categories for a dimension
    getCategories(dimension) {
        return Object.keys(this.palette[dimension] || {});
    },

    // Get label for a category
    getLabel(dimension, category) {
        return this.palette[dimension]?.[category]?.label || category;
    },

    // =================================================================
    // TRANSFORM CONTROLS: Update OKLCH state
    // =================================================================
    setTransform(key, value) {
        if (key in this.transform) {
            this.transform[key] = value;
            this._notifySubscribers('transform-change', { key, value });
        }
    },

    setAllTransforms(transforms) {
        Object.assign(this.transform, transforms);
        this._notifySubscribers('transform-change', transforms);
    },

    resetTransforms() {
        this.transform = {
            hueShift: 0,
            chromaScale: 1.0,
            lightnessShift: 0,
            amplifier: 1.0
        };
        this._notifySubscribers('transform-change', this.transform);
    },

    // =================================================================
    // INTERNAL: Apply OKLCH transforms and convert to hex
    // =================================================================
    _applyTransform(oklch) {
        const t = this.transform;

        // Apply transforms
        let h = (oklch.h + t.hueShift + 360) % 360;
        let c = Math.max(0, Math.min(0.4, oklch.c * t.chromaScale));
        let l = Math.max(0, Math.min(1, oklch.l + t.lightnessShift / 100));

        // Apply amplifier to chroma for contrast
        if (t.amplifier !== 1) {
            c = Math.pow(c / 0.4, 1 / t.amplifier) * 0.4;
        }

        return this._toHex({ h, c, l });
    },

    _toHex(oklch) {
        // OKLCH to sRGB conversion (simplified)
        // Using CSS color conversion would be ideal, but this approximation works
        const { h, c, l } = oklch;

        // Convert OKLCH to approximate RGB
        const hRad = h * Math.PI / 180;
        const a = c * Math.cos(hRad);
        const b = c * Math.sin(hRad);

        // Simplified OKLab to linear RGB (approximate)
        const L = l;
        const l_ = L + 0.3963377774 * a + 0.2158037573 * b;
        const m_ = L - 0.1055613458 * a - 0.0638541728 * b;
        const s_ = L - 0.0894841775 * a - 1.2914855480 * b;

        const l3 = l_ * l_ * l_;
        const m3 = m_ * m_ * m_;
        const s3 = s_ * s_ * s_;

        let r = +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
        let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
        let bl = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

        // Clamp and convert to sRGB
        const toSRGB = (x) => {
            x = Math.max(0, Math.min(1, x));
            return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;
        };

        r = Math.round(toSRGB(r) * 255);
        g = Math.round(toSRGB(g) * 255);
        bl = Math.round(toSRGB(bl) * 255);

        r = Math.max(0, Math.min(255, r));
        g = Math.max(0, Math.min(255, g));
        bl = Math.max(0, Math.min(255, bl));

        return '#' + [r, g, bl].map(x => x.toString(16).padStart(2, '0')).join('');
    },

    // =================================================================
    // REACTIVE SUBSCRIPTIONS
    // =================================================================
    _subscribers: [],

    subscribe(callback) {
        this._subscribers.push(callback);
        return () => {
            this._subscribers = this._subscribers.filter(cb => cb !== callback);
        };
    },

    _notifySubscribers(event, data) {
        this._subscribers.forEach(cb => cb(event, data));
    },

    // =================================================================
    // DEBUG: Log current state
    // =================================================================
    debug() {
        console.log('[ColorOrchestrator] Transform state:', this.transform);
        console.log('[ColorOrchestrator] Palette dimensions:', Object.keys(this.palette));
        console.log('[ColorOrchestrator] Interval mappings:', Object.keys(this.intervals));
    }
};

// Global alias for convenience
const Color = ColorOrchestrator;



// =====================================================================
// FLOATING PANEL CONTROL SYSTEM
// =====================================================================
// openPanel, closePanel, togglePanel - MOVED TO modules/panels.js
// (backward compat shims in panels.js)

// Wire up command bar and panel controls
function initCommandBar() {
    // Command bar buttons
    const cmdBtns = {
        'cmd-view': 'view',
        'cmd-filter': 'filter',
        'cmd-style': 'style',
        'cmd-settings': 'settings'
    };

    Object.entries(cmdBtns).forEach(([btnId, panelId]) => {
        const btn = document.getElementById(btnId);
        if (btn) {
            btn.addEventListener('click', () => togglePanel(panelId));
        }
    });

    // Settings panel: Oval margin slider (debounced - apply 300ms after release)
    const ovalSlider = document.getElementById('oval-margin-slider');
    const ovalValue = document.getElementById('oval-margin-value');
    let ovalDebounceTimer = null;
    if (ovalSlider) {
        // Update display value immediately
        ovalSlider.addEventListener('input', (e) => {
            if (ovalValue) ovalValue.textContent = e.target.value + '%';
        });
        // Apply actual change only after 300ms pause (on mouseup/touchend)
        const applyOvalMargin = () => {
            clearTimeout(ovalDebounceTimer);
            ovalDebounceTimer = setTimeout(() => {
                const val = ovalSlider.value;
                document.documentElement.style.setProperty('--oval-margin', val + '%');
            }, 300);
        };
        ovalSlider.addEventListener('mouseup', applyOvalMargin);
        ovalSlider.addEventListener('touchend', applyOvalMargin);
        ovalSlider.addEventListener('change', applyOvalMargin);
    }

    // Oval debug toggle
    const toggleOvalDebug = document.getElementById('toggle-oval-debug');
    if (toggleOvalDebug) {
        toggleOvalDebug.addEventListener('click', () => {
            toggleOvalDebug.classList.toggle('active');
            const ovalDebug = document.querySelector('.oval-debug');
            if (ovalDebug) {
                ovalDebug.style.display = toggleOvalDebug.classList.contains('active') ? 'block' : 'none';
            }
        });
    }

    // ═══════════════════════════════════════════════════════════════════
    // STYLE PANEL SLIDERS - Connected to appearance system
    // ═══════════════════════════════════════════════════════════════════

    // Node Size Slider
    const nodeSizeSlider = document.getElementById('node-size-slider');
    const nodeSizeValue = document.getElementById('node-size-value');
    if (nodeSizeSlider) {
        nodeSizeSlider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            if (nodeSizeValue) nodeSizeValue.textContent = val.toFixed(1) + 'x';
            APPEARANCE_STATE.nodeScale = val;
            if (Graph) {
                Graph.nodeVal(node => (node.val || node.size || 1) * val);
            }
        });
    }

    // Edge Opacity Slider
    const edgeOpacitySlider = document.getElementById('edge-opacity-slider');
    const edgeOpacityValue = document.getElementById('edge-opacity-value');
    if (edgeOpacitySlider) {
        edgeOpacitySlider.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            if (edgeOpacityValue) edgeOpacityValue.textContent = val + '%';
            APPEARANCE_STATE.edgeOpacity = val / 100;
            if (typeof applyEdgeMode === 'function') applyEdgeMode();
        });
    }

    // Density Slider (filter panel duplicate)
    const densitySlider2 = document.getElementById('density-slider2');
    const densityValue2 = document.getElementById('density-value2');
    if (densitySlider2) {
        densitySlider2.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            if (densityValue2) densityValue2.textContent = val + '%';
            CURRENT_DENSITY = val;
            refreshGraph();
        });
    }

    // Toggle switches
    document.querySelectorAll('.toggle-switch').forEach(toggle => {
        toggle.addEventListener('click', () => {
            toggle.classList.toggle('active');
        });
    });

    // Segmented controls
    document.querySelectorAll('.segmented-control').forEach(control => {
        control.querySelectorAll('.segment').forEach(segment => {
            segment.addEventListener('click', () => {
                control.querySelectorAll('.segment').forEach(s => s.classList.remove('active'));
                segment.classList.add('active');

                // Handle dimension change
                if (control.id === 'dim-control') {
                    const dim = segment.dataset.dim;
                    if (dim === '2') {
                        IS_3D = false;
                        if (Graph) Graph.numDimensions(2);
                    } else {
                        IS_3D = true;
                        if (Graph) Graph.numDimensions(3);
                    }
                }

                // Handle node color mode
                if (control.id === 'node-color-control') {
                    const mode = segment.dataset.mode;
                    if (mode && typeof setNodeColorMode === 'function') {
                        setNodeColorMode(mode);
                    }
                }

                // Handle edge color mode
                if (control.id === 'edge-color-control') {
                    const mode = segment.dataset.mode;
                    if (mode) {
                        EDGE_MODE = mode;
                        if (typeof applyEdgeMode === 'function') applyEdgeMode();
                    }
                }

                // Handle panel layout
                if (control.id === 'layout-control') {
                    const layout = segment.dataset.layout;
                    if (layout) {
                        document.body.setAttribute('data-layout', layout);
                        console.log('[Layout] Switched to:', layout);
                    }
                }
            });
        });
    });

    // ═══════════════════════════════════════════════════════════════════
    // COMMAND BAR DIRECT ACTIONS (no proxy clicks - call functions directly)
    // ═══════════════════════════════════════════════════════════════════

    // File mode toggle
    REGISTRY.register('cmd-files2', () => {
        if (typeof setFileModeState === 'function') {
            const newState = !fileMode;
            setFileModeState(newState);
            // Visual feedback is handled by setFileModeState, but we toggle active here for instant response
            const btn = document.getElementById('cmd-files2');
            if (btn) btn.classList.toggle('active', newState);
        } else {
            console.warn('setFileModeState function missing');
        }
    }, { desc: 'Toggle File Boundaries Mode' });

    // Flow mode toggle
    REGISTRY.register('cmd-flow2', () => {
        if (typeof toggleFlowMode === 'function') {
            toggleFlowMode();
            // Visual feedback usually managed by toggle function
            const btn = document.getElementById('cmd-flow2');
            if (btn) btn.classList.toggle('active', flowMode);
        }
    }, { desc: 'Toggle Flow Mode' });

    // 3D toggle
    REGISTRY.register('cmd-3d', () => {
        if (typeof toggleDimensions === 'function') {
            toggleDimensions();
        } else {
            // Direct implementation fallback
            IS_3D = !IS_3D;
            if (Graph) Graph.numDimensions(IS_3D ? 3 : 2);
            const btnDim = document.getElementById('btn-dimensions');
            if (btnDim) btnDim.textContent = IS_3D ? '2D' : '3D';
        }
        const btn = document.getElementById('cmd-3d');
        if (btn) btn.classList.toggle('active', IS_3D);

        // Update dim-control if exists
        const dimControl = document.getElementById('dim-control');
        if (dimControl) {
            dimControl.querySelectorAll('.segment').forEach(s => {
                s.classList.toggle('active', s.dataset.dim === (IS_3D ? '3' : '2'));
            });
        }
    }, { desc: 'Toggle 2D/3D View' });

    console.log('[CommandBar] Initialized with direct function calls');
}

// Build chip buttons for filter groups
function buildChipGroup(containerId, items, stateSet, onUpdate) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.innerHTML = '';

    // "ALL" chip
    const allChip = document.createElement('button');
    allChip.className = 'chip active';
    allChip.textContent = 'ALL';
    allChip.addEventListener('click', () => {
        // Toggle all on/off
        const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
        if (allActive) {
            stateSet.clear();
            container.querySelectorAll('.chip').forEach(c => c.classList.remove('active'));
        } else {
            items.forEach((count, key) => stateSet.add(key));
            container.querySelectorAll('.chip').forEach(c => c.classList.add('active'));
        }
        if (onUpdate) onUpdate();
    });
    container.appendChild(allChip);

    // Individual chips
    items.forEach((count, key) => {
        const chip = document.createElement('button');
        chip.className = 'chip' + (stateSet.has(key) ? ' active' : '');
        chip.innerHTML = `${key}<span class="chip-count">${count}</span>`;
        chip.addEventListener('click', () => {
            if (stateSet.has(key)) {
                stateSet.delete(key);
                chip.classList.remove('active');
            } else {
                stateSet.add(key);
                chip.classList.add('active');
            }
            // Update "ALL" chip state
            const allActive = Array.from(items.keys()).every(k => stateSet.has(k));
            allChip.classList.toggle('active', allActive);
            if (onUpdate) onUpdate();
        });
        container.appendChild(chip);
    });
}

// Populate filter chips in floating panels
function populateFilterChips() {
    if (!DM) return;  // ALL DATA FROM DM

    // Use DM cached aggregations (O(1) lookups)
    const tierCounts = DM.getTierCounts();
    const ringCounts = DM.getRingCounts();
    const edgeCounts = DM.getEdgeTypeCounts();

    buildChipGroup('chips-tiers', tierCounts, VIS_FILTERS.tiers, refreshGraph);
    buildChipGroup('chips-rings', ringCounts, VIS_FILTERS.rings, refreshGraph);
    buildChipGroup('chips-edges', edgeCounts, VIS_FILTERS.edges, refreshGraph);
}

// renderLegendSection, renderAllLegends - MOVED TO modules/legend-manager.js

// Debounce wrapper to prevent DOM thrashing during rapid updates
let _legendDebounceTimer = null;
const _originalRenderAllLegends = renderAllLegends;
renderAllLegends = function () {
    if (_legendDebounceTimer) clearTimeout(_legendDebounceTimer);
    _legendDebounceTimer = setTimeout(() => {
        _originalRenderAllLegends();
        _legendDebounceTimer = null;
    }, 100); // 100ms debounce
};

// =====================================================================
// HUD LAYOUT MANAGER: MIGRATED TO modules/layout.js
// =====================================================================
// HudLayoutManager (390 lines) has been migrated to modules/layout.js
// which provides the LAYOUT module with:
//   - All original panel placement functionality
//   - NEW: Toast/control-bar collision detection
//   - NEW: Min-width graph validation
//   - NEW: Debug overlay (Ctrl+Shift+L)
//   - NEW: Component registration system
//
// Backward compatibility: window.HudLayoutManager = LAYOUT (alias)
// =====================================================================

worker.onmessage = function (e) {
    if (e.data.status && !e.data.result) {
        document.getElementById('loader-status').innerText = e.data.status;
    } else if (e.data.error) {
        document.getElementById('loader-status').innerText = "ERROR: " + e.data.error;
        document.getElementById('loader-status').style.color = "red";
    } else if (e.data.result) {
        FULL_GRAPH = e.data.result;
        FILE_GRAPH = null;
        FILE_NODE_POSITIONS = new Map();
        EXPANDED_FILES.clear();
        window.GRAPH_MODE = 'atoms';
        document.getElementById('loader-status').innerText = "INITIALIZING VISUALIZATION...";
        initGraph(FULL_GRAPH);
    }
};

// Start Work: Decompress in main thread, then send JSON string to worker for parsing
try {
    const jsonStr = decompressPayload(COMPRESSED_PAYLOAD);
    worker.postMessage(jsonStr);
} catch (err) {
    document.getElementById('loader-status').innerText = "ERROR: " + err.message;
    document.getElementById('loader-status').style.color = "red";
    console.error('[Decompression] Failed:', err);
}

// =====================================================================
// 2D CANVAS FALLBACK: Used when WebGL is unavailable
// =====================================================================
function initFallback2D(container, graphData, fullData) {
    console.log('[2D Fallback] Initializing canvas renderer');
    showToast('WebGL unavailable - using 2D fallback');

    const loader = document.getElementById('loader');
    if (loader) loader.style.display = 'none';

    // Update HUD stats even in 2D fallback mode
    updateHudStats(fullData);

    container.innerHTML = '';
    container.style.position = 'relative';
    container.style.overflow = 'hidden';

    const canvas = document.createElement('canvas');
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.display = 'block';
    canvas.style.background = VIZ_COLORS.canvasBg;
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    let width = container.clientWidth || window.innerWidth;
    let height = container.clientHeight || window.innerHeight;
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    canvas.width = width * dpr;
    canvas.height = height * dpr;
    ctx.scale(dpr, dpr);

    // Layout: simple force-directed positions
    const nodes = graphData.nodes || [];
    const links = graphData.links || [];
    const nodeMap = new Map();

    nodes.forEach((n, i) => {
        const angle = (i / nodes.length) * Math.PI * 2;
        const radius = Math.min(width, height) * 0.35;
        n._x = width / 2 + Math.cos(angle) * radius * (0.5 + Math.random() * 0.5);
        n._y = height / 2 + Math.sin(angle) * radius * (0.5 + Math.random() * 0.5);
        n._vx = 0;
        n._vy = 0;
        nodeMap.set(n.id, n);
    });

    // Camera state
    let camX = 0, camY = 0, zoom = 1;
    let dragging = false, lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', e => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mousemove', e => {
        if (!dragging) return;
        camX += (e.clientX - lastX) / zoom;
        camY += (e.clientY - lastY) / zoom;
        lastX = e.clientX;
        lastY = e.clientY;
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('mouseleave', () => dragging = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        zoom = Math.max(0.1, Math.min(5, zoom * factor));
    }, { passive: false });

    function toScreen(x, y) {
        return {
            x: (x + camX - width / 2) * zoom + width / 2,
            y: (y + camY - height / 2) * zoom + height / 2
        };
    }

    function parseColor(c) {
        if (typeof c === 'number') {
            return '#' + c.toString(16).padStart(6, '0');
        }
        return c || VIZ_COLORS.nodeFallback;
    }

    function render() {
        ctx.fillStyle = VIZ_COLORS.canvasBg;
        ctx.fillRect(0, 0, width, height);

        // Draw edges
        ctx.strokeStyle = 'rgba(100,100,100,0.3)';
        ctx.lineWidth = 0.5;
        for (const link of links) {
            const src = typeof link.source === 'object' ? link.source : nodeMap.get(link.source);
            const tgt = typeof link.target === 'object' ? link.target : nodeMap.get(link.target);
            if (!src || !tgt) continue;
            const p1 = toScreen(src._x, src._y);
            const p2 = toScreen(tgt._x, tgt._y);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // Draw nodes
        for (const node of nodes) {
            const p = toScreen(node._x, node._y);
            const r = Math.max(2, (node.val || 1) * zoom * 0.5);
            ctx.fillStyle = parseColor(node.color);
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
        }

        // Info overlay
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.font = '11px monospace';
        ctx.fillText('2D Fallback Mode (WebGL unavailable)', 10, 20);
        ctx.fillText('Drag to pan, scroll to zoom', 10, 35);
        ctx.fillText(`Nodes: ${nodes.length} | Edges: ${links.length}`, 10, 50);

        requestAnimationFrame(render);
    }

    function resize() {
        width = container.clientWidth || window.innerWidth;
        height = container.clientHeight || window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
    }

    window.addEventListener('resize', resize);
    render();

    // Initialize DataManager (required for UI controls)
    DM = new DataManager();
    DM.init(fullData);
    window.DM = DM;

    // Setup UI controls (they work independently of 3D graph)
    setupControls(fullData);
    setupReport(fullData);
    setupAIInsights(fullData);
    setupMetrics(fullData);
    setupHudFade();
    setupDimensionToggle();

    // Update stats with actual node/edge counts
    updateHudStats(graphData);
}

function initGraph(data) {
    // =================================================================
    // DATA MANAGER: Self-test + parity checks
    // =================================================================
    DM = new DataManager();
    DM.init(data);
    window.DM = DM;
    DM.selfTest();
    runDmParity(DM, data);

    // =================================================================
    // HUD STATS: Populate header and stats panel with graph data
    // =================================================================
    updateHudStats(data);

    // =================================================================
    // SIDEBAR: Populate filter chips from loaded data
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.populateFilterChips) {
        SIDEBAR.populateFilterChips(data);
    }

    // =================================================================
    // SIDEBAR: Apply deferred view mode (files mode if saved in localStorage)
    // =================================================================
    if (typeof SIDEBAR !== 'undefined' && SIDEBAR.applyDeferredViewMode) {
        SIDEBAR.applyDeferredViewMode();
    }

    // =================================================================
    // TOKEN-DRIVEN CONFIG: Extract from payload
    // =================================================================
    const physicsConfig = data.physics || {};
    const appearanceConfig = data.appearance || {};
    window.APPEARANCE_CONFIG = appearanceConfig;

    // =================================================================
    // THEME CONFIG: Load theme configuration for runtime switching
    // =================================================================
    if (data.theme_config) {
        THEME_CONFIG = {
            ...THEME_CONFIG,
            available: data.theme_config.available || ['dark'],
            default: data.theme_config.default || 'dark',
            current: data.theme_config.default || 'dark',
            colors: data.theme_config.colors || THEME_CONFIG.colors
        };

        // Apply edge colors from theme config
        if (THEME_CONFIG.colors.edge) {
            EDGE_COLOR_CONFIG = { ...EDGE_COLOR_CONFIG, ...THEME_CONFIG.colors.edge };
        }

        // Apply viz colors from theme config
        if (THEME_CONFIG.colors.viz) {
            const viz = THEME_CONFIG.colors.viz;
            VIZ_COLORS = {
                canvasBg: viz['canvas-bg'] || VIZ_COLORS.canvasBg,
                nodeFallback: viz['node-fallback'] || VIZ_COLORS.nodeFallback,
                edgeFallback: viz['edge-fallback'] || VIZ_COLORS.edgeFallback,
                groupHalo: viz['group-halo'] || VIZ_COLORS.groupHalo
            };
        }

        // Apply console colors from theme config
        if (THEME_CONFIG.colors.console) {
            CONSOLE_COLORS = { ...CONSOLE_COLORS, ...THEME_CONFIG.colors.console };
        }

        console.log(`%c[Theme] Loaded: ${THEME_CONFIG.available.join(', ')}`, `color: ${CONSOLE_COLORS.info}; font-weight: bold`);
    }
    const simulation = physicsConfig.simulation || {};
    const background = appearanceConfig.background || {};
    // const stars = background.stars || {};  // REMOVED - starfield feature deleted
    const bloom = background.bloom || {};
    // NEW: Render, highlight, flow_mode from THE REMOTE CONTROL
    const renderConfig = appearanceConfig.render || {};
    const highlightConfig = appearanceConfig.highlight || {};
    FLOW_CONFIG = appearanceConfig.flow_mode || {};

    // Merge animation tokens into PENDULUM (T004)
    const animationConfig = appearanceConfig.animation || {};
    if (animationConfig.hue) {
        PENDULUM.hue.damping = animationConfig.hue.damping ?? 0.9995;
        PENDULUM.hue.gravity = animationConfig.hue.speed ?? 0.0008;
        PENDULUM.hue.rotationSpeed = animationConfig.hue.rotation ?? 0.8;
    }
    if (animationConfig.chroma) {
        PENDULUM.chroma.damping = animationConfig.chroma.damping ?? 0.998;
        PENDULUM.chroma.gravity = animationConfig.chroma.gravity ?? 0.0004;
        PENDULUM.chroma.center = animationConfig.chroma.center ?? 0.32;
        PENDULUM.chroma.amplitude = animationConfig.chroma.amplitude ?? 0.08;
    }
    if (animationConfig.lightness) {
        PENDULUM.lightness.speed = animationConfig.lightness.speed ?? 0.02;
        PENDULUM.lightness.center = animationConfig.lightness.center ?? 82;
        PENDULUM.lightness.amplitude = animationConfig.lightness.amplitude ?? 10;
    }
    if (animationConfig.ripple) {
        PENDULUM.ripple.speed = animationConfig.ripple.speed ?? 0.035;
        PENDULUM.ripple.scale = animationConfig.ripple.scale ?? 200;
    }
    const edgeModes = appearanceConfig.edge_modes || {};
    EDGE_MODE_CONFIG = {
        resolution: edgeModes.resolution || { internal: '#4dd4ff', external: '#ff6b6b', unresolved: '#9aa0a6', unknown: '#666666' },
        weight: edgeModes.weight || { hue_min: 210, hue_max: 50, saturation: 45, lightness: 42 },
        confidence: edgeModes.confidence || { hue_min: 20, hue_max: 120, saturation: 45, lightness: 44 },
        width: edgeModes.width || { base: 0.6, weight_scale: 2.0, confidence_scale: 1.5 },
        dim: edgeModes.dim || { interfile_factor: 0.25 },
        opacity: (typeof edgeModes.opacity === 'number') ? edgeModes.opacity : 0.08
    };

    FILE_COLOR_CONFIG = Object.assign({}, FILE_COLOR_CONFIG, appearanceConfig.file_color || {});
    // Token value 0.08 from appearance.tokens.json:202, fallback only if token system fails
    EDGE_DEFAULT_OPACITY =
        (typeof EDGE_MODE_CONFIG.opacity === 'number') ? EDGE_MODE_CONFIG.opacity : 0.08;
    const boundaryConfig = appearanceConfig.boundary || {};
    APPEARANCE_STATE.edgeOpacity = EDGE_DEFAULT_OPACITY;
    APPEARANCE_STATE.boundaryFill = boundaryConfig.fill_opacity ?? APPEARANCE_STATE.boundaryFill;
    APPEARANCE_STATE.boundaryWire = boundaryConfig.wire_opacity ?? APPEARANCE_STATE.boundaryWire;
    APPEARANCE_STATE.backgroundBase = background.color || '#000000';
    APPEARANCE_STATE.fileLightness = FILE_COLOR_CONFIG.lightness ?? APPEARANCE_STATE.fileLightness;
    const nodeColor = appearanceConfig.node_color || {};
    NODE_COLOR_CONFIG = {
        tier: nodeColor.tier || {},
        ring: nodeColor.ring || {},
        unknown: nodeColor.unknown || '#666666'
    };
    const edgeColor = appearanceConfig.edge_color || {};
    EDGE_COLOR_CONFIG = {
        default: edgeColor.default || '#333333',
        calls: edgeColor.calls || '#4dd4ff',
        contains: edgeColor.contains || '#00ff9d',
        uses: edgeColor.uses || '#ffb800',
        imports: edgeColor.imports || '#9aa0a6',
        inherits: edgeColor.inherits || '#ff6b6b'
    };

    // Initial Filter: show full graph
    const filtered = filterGraph(data, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);

    // ═══════════════════════════════════════════════════════════════════
    // DATA PREP FOR ANIMATIONS: Assign file indices for wave patterns
    // ═══════════════════════════════════════════════════════════════════
    const fileMap = new Map();
    let nextFileIdx = 0;
    filtered.nodes.forEach(node => {
        // Extract filename from ID (assuming file path is in ID or explicit file prop)
        const file = node.file || (node.id.includes('/') ? node.id.split(':')[0] : 'unknown');
        if (!fileMap.has(file)) fileMap.set(file, nextFileIdx++);
        node.file_idx = fileMap.get(file);
    });

    const div = document.getElementById('3d-graph');

    // ═══════════════════════════════════════════════════════════════════
    // GRADIENT EDGES: Custom THREE.js lines with vertex colors
    // Creates beautiful gradients from source to target node colors
    // ═══════════════════════════════════════════════════════════════════
    let GRADIENT_EDGES_ENABLED = true;  // Toggle for gradient edges

    function hexToRgb(hex) {
        // Convert hex color to RGB array [0-1, 0-1, 0-1]
        if (typeof hex === 'number') {
            return [
                ((hex >> 16) & 255) / 255,
                ((hex >> 8) & 255) / 255,
                (hex & 255) / 255
            ];
        }
        if (typeof hex === 'string') {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const num = parseInt(hex, 16);
            return [
                ((num >> 16) & 255) / 255,
                ((num >> 8) & 255) / 255,
                (num & 255) / 255
            ];
        }
        return [0.5, 0.5, 0.5];  // Default gray
    }

    function createGradientEdge(link) {
        // Get source and target nodes
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        // Get colors from nodes (using current color mode)
        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        // Create geometry with 2 vertices
        const geometry = new THREE.BufferGeometry();

        // Positions will be updated by linkPositionUpdate
        const positions = new Float32Array([0, 0, 0, 0, 0, 0]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Vertex colors: source color at start, target color at end
        const colors = new Float32Array([
            srcRgb[0], srcRgb[1], srcRgb[2],  // Source vertex color
            tgtRgb[0], tgtRgb[1], tgtRgb[2]   // Target vertex color
        ]);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Material with vertex colors
        const material = new THREE.LineBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: link.opacity ?? EDGE_DEFAULT_OPACITY,
            linewidth: 1  // Note: linewidth > 1 only works on some platforms
        });

        return new THREE.Line(geometry, material);
    }

    function updateGradientEdge(line, link, coords) {
        // Update line positions
        const posArr = line.geometry.attributes.position.array;
        posArr[0] = coords.start.x || 0;
        posArr[1] = coords.start.y || 0;
        posArr[2] = coords.start.z || 0;
        posArr[3] = coords.end.x || 0;
        posArr[4] = coords.end.y || 0;
        posArr[5] = coords.end.z || 0;
        line.geometry.attributes.position.needsUpdate = true;

        // Update colors based on current node colors
        const srcNode = typeof link.source === 'object' ? link.source :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.source));
        const tgtNode = typeof link.target === 'object' ? link.target :
            (Graph?.graphData()?.nodes?.find(n => n.id === link.target));

        const srcColorHex = srcNode ? toColorNumber(getNodeColorByMode(srcNode), 0x888888) : 0x888888;
        const tgtColorHex = tgtNode ? toColorNumber(getNodeColorByMode(tgtNode), 0x888888) : 0x888888;
        const srcRgb = hexToRgb(srcColorHex);
        const tgtRgb = hexToRgb(tgtColorHex);

        const colArr = line.geometry.attributes.color.array;
        colArr[0] = srcRgb[0]; colArr[1] = srcRgb[1]; colArr[2] = srcRgb[2];
        colArr[3] = tgtRgb[0]; colArr[4] = tgtRgb[1]; colArr[5] = tgtRgb[2];
        line.geometry.attributes.color.needsUpdate = true;
    }

    // Refresh all gradient edge colors (call when node color mode changes)
    function refreshGradientEdgeColors() {
        if (!GRADIENT_EDGES_ENABLED || !Graph) return;
        // Force rebuild of all link objects to update colors
        Graph.linkThreeObject(link => createGradientEdge(link));
    }

    // Make it globally accessible for color mode changes
    window.refreshGradientEdgeColors = refreshGradientEdgeColors;

    // TOKEN-DRIVEN: Read render config from THE REMOTE CONTROL
    const dimensions = renderConfig.dimensions || 3;
    const nodeRes = renderConfig.nodeResolution || 8;

    try {
        Graph = ForceGraph3D({
            rendererConfig: {
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance'
            }
        })
            (div)
            .graphData(filtered)
            .numDimensions(dimensions)
            .backgroundColor(toColorNumber(background.color, 0x000000))
            .nodeLabel('name')
            .nodeColor(node => toColorNumber(node.color, 0x888888))
            .nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale)
            // ═══════════════════════════════════════════════════════════════════
            // GRADIENT EDGES: Custom THREE.Line with vertex colors
            // Each edge smoothly transitions from source node color to target node color
            // ═══════════════════════════════════════════════════════════════════
            .linkThreeObject(link => GRADIENT_EDGES_ENABLED ? createGradientEdge(link) : null)
            .linkPositionUpdate((line, coords, link) => {
                if (GRADIENT_EDGES_ENABLED && line) {
                    updateGradientEdge(line, link, coords);
                }
                return true;  // Keep default behavior for non-gradient
            })
            .linkColor(link => GRADIENT_EDGES_ENABLED ? null : toColorNumber(getEdgeColor(link), 0x222222))
            .linkOpacity(link => GRADIENT_EDGES_ENABLED ? 0 : (link.opacity ?? EDGE_DEFAULT_OPACITY))
            .nodeThreeObjectExtend(true)
            .nodeThreeObject(node => ensureNodeOverlays(node))
            .nodeResolution(Math.max(nodeRes, 16))
            .linkResolution(6)
            .showNavInfo(false)
            .warmupTicks(simulation.warmupTicks || 30)
            .cooldownTicks(simulation.cooldownTicks || 0)
            .onNodeHover(node => handleNodeHover(node, data))
            .onNodeClick((node, event) => handleNodeClick(node, event))
            .onBackgroundClick(() => maybeClearSelection())
            // ═══════════════════════════════════════════════════════════════════
            // GROUP DRAG: Move all selected nodes together, maintaining offsets
            // Note: onNodeDragStart doesn't exist - detect start via flag
            // ═══════════════════════════════════════════════════════════════════
            .onNodeDrag((node, translate) => {
                // Only handle group drag if multiple nodes selected and this node is selected
                if (SELECTED_NODE_IDS.size > 1 && SELECTED_NODE_IDS.has(node.id)) {
                    // First drag frame: store relative offsets
                    if (!window._groupDragActive) {
                        window._groupDragActive = true;
                        window._groupDragOffsets = new Map();
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            if (SELECTED_NODE_IDS.has(n.id) && n.id !== node.id) {
                                window._groupDragOffsets.set(n.id, {
                                    dx: (n.x || 0) - (node.x || 0),
                                    dy: (n.y || 0) - (node.y || 0),
                                    dz: (n.z || 0) - (node.z || 0)
                                });
                            }
                        });
                    }
                    // Move all other selected nodes with their offsets
                    if (window._groupDragOffsets) {
                        const nodes = Graph.graphData().nodes;
                        nodes.forEach(n => {
                            const offset = window._groupDragOffsets.get(n.id);
                            if (offset) {
                                n.fx = node.x + offset.dx;
                                n.fy = node.y + offset.dy;
                                n.fz = node.z + offset.dz;
                            }
                        });
                    }
                }
            })
            .onNodeDragEnd(node => {
                // Clear group drag state
                window._groupDragActive = false;
                window._groupDragOffsets = null;
                // Fix all selected nodes at their final positions
                if (SELECTED_NODE_IDS.size > 0) {
                    const nodes = Graph.graphData().nodes;
                    nodes.forEach(n => {
                        if (SELECTED_NODE_IDS.has(n.id)) {
                            n.fx = n.x; n.fy = n.y; n.fz = n.z;
                        }
                    });
                }
            })
            .onEngineStop(() => {
                // Physics-dependent operations (run after simulation stabilizes)
                drawFileBoundaries(data);
                // LAYOUT STABILITY: Freeze layout after initial simulation completes
                if (!LAYOUT_FROZEN) {
                    saveNodePositions();
                    freezeLayout();
                }
            });
    } catch (err) {
        console.error('[WebGL] Failed to initialize 3D graph:', err);
        initFallback2D(div, filtered, data);
        return;
    }

    window.Graph = Graph;

    // FIX: Drift on resize
    // Updates Graph renderer size when window creates
    window.addEventListener('resize', () => {
        if (Graph) {
            Graph.width(window.innerWidth);
            Graph.height(window.innerHeight);
        }
    });

    // OPTIMIZATION: Hide loader immediately after Graph creation (don't wait for physics)
    // This makes the visualization appear 200-500ms faster
    document.getElementById('loader').style.display = 'none';

    // =================================================================
    // RENDERER QUALITY: Enable anti-aliasing and high DPI
    // =================================================================
    const renderer = Graph.renderer();
    if (renderer) {
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // Enable high quality rendering
        renderer.antialias = true;
        renderer.alpha = true;
        renderer.powerPreference = 'high-performance';
    }

    initSelectionState(data);
    setupSelectionInteractions();
    updateSelectionVisuals();

    // =================================================================
    // CONTROLS: keep default camera behavior, enable damping
    // =================================================================
    const controls = Graph.controls();
    if (controls) {
        // TOKEN-DRIVEN: Read from payload (if available), else use defaults
        // Allow remote configuration of mouse buttons and damping
        const navConfig = data.config?.controls || data.controls || {};

        controls.enableDamping = navConfig.enableDamping !== undefined ? navConfig.enableDamping : true;
        controls.dampingFactor = navConfig.dampingFactor || 0.1;
        controls.enableRotate = navConfig.enableRotate !== undefined ? navConfig.enableRotate : true;
        controls.enablePan = navConfig.enablePan !== undefined ? navConfig.enablePan : true;

        // Mouse Buttons: Map generic names to integer constants
        // 0: ROTATE, 1: DOLLY (Zoom), 2: PAN
        const defaultButtons = {
            LEFT: 2, // PAN
            MIDDLE: 1, // DOLLY
            RIGHT: 0 // ROTATE
        };

        if (navConfig.mouseButtons) {
            controls.mouseButtons = {
                LEFT: navConfig.mouseButtons.LEFT ?? defaultButtons.LEFT,
                MIDDLE: navConfig.mouseButtons.MIDDLE ?? defaultButtons.MIDDLE,
                RIGHT: navConfig.mouseButtons.RIGHT ?? defaultButtons.RIGHT
            };
        } else {
            controls.mouseButtons = defaultButtons;
        }

        // Spacebar toggling disabled to ensure stability
    }

    // =================================================================
    // TOKEN-DRIVEN: Force Configuration
    // =================================================================
    const forces = physicsConfig.forces || {};
    if (forces.charge?.enabled) {
        Graph.d3Force('charge').strength(forces.charge.strength || -120);
        Graph.d3Force('charge').distanceMax(forces.charge.distanceMax || 500);
    }
    if (forces.link?.enabled) {
        const linkDistance = forces.link.distance || 50;
        Graph.d3Force('link').distance(linkDistance);
        DEFAULT_LINK_DISTANCE = linkDistance;
    }
    if (forces.center?.enabled) {
        Graph.d3Force('center').strength(forces.center.strength || 0.05);
    }

    // =================================================================
    // STARFIELD REMOVED - Nodes ARE the stars
    // Rationale: Adding background dots creates visual confusion with actual data nodes.
    // The cosmos metaphor works better when the data itself forms the starfield.
    // =================================================================

    // =================================================================
    // TOKEN-DRIVEN: Bloom Post-Processing (DISABLED - UMD build compatibility)
    // Post-processing addons require ES modules; using UMD for file:// support
    // =================================================================
    // Bloom disabled for compatibility - visualization works without it

    // Setup Hud Controls (TOKEN-DRIVEN)
    // OPTIMIZATION: Defer UI setup to next frame so graph renders first
    // This makes the visualization appear 150-200ms faster
    Promise.resolve().then(() => {
        setupControls(data);
        setupReport(data);
        setupAIInsights(data);
        setupMetrics(data);
        setupHudFade();
        setupDimensionToggle();
        applyEdgeMode();

        // SELF-TEST: Deterministic validation of UI controls (deferred)
        runSelfTest(data);
    });
}

function runSelfTest(data) {
    const results = {
        timestamp: new Date().toISOString(),
        passed: [],
        failed: []
    };

    const test = (name, condition) => {
        if (condition) {
            results.passed.push(name);
        } else {
            results.failed.push(name);
        }
    };

    // Test 1: Core UI structure (dual-sidebar layout)

    // Main layout containers
    test('header-exists', !!document.getElementById('header'));
    test('left-sidebar-exists', !!document.getElementById('left-sidebar'));
    test('right-sidebar-exists', !!document.getElementById('right-sidebar'));
    test('graph-container-exists', !!document.getElementById('3d-graph'));

    // Header stats
    test('stat-nodes-exists', !!document.getElementById('stat-nodes'));
    test('stat-edges-exists', !!document.getElementById('stat-edges'));
    test('target-name-exists', !!document.getElementById('target-name'));

    // Left sidebar configuration sections
    test('section-node-config-exists', !!document.getElementById('section-node-config'));
    test('section-edge-config-exists', !!document.getElementById('section-edge-config'));
    test('section-layout-exists', !!document.getElementById('section-layout'));
    test('section-physics-exists', !!document.getElementById('section-physics'));
    test('section-filters-exists', !!document.getElementById('section-filters'));
    test('section-actions-exists', !!document.getElementById('section-actions'));

    // Left sidebar action buttons
    test('btn-reset-exists', !!document.getElementById('btn-reset'));
    test('btn-screenshot-exists', !!document.getElementById('btn-screenshot'));
    test('btn-2d-exists', !!document.getElementById('btn-2d'));
    test('btn-freeze-exists', !!document.getElementById('btn-freeze'));

    // Right sidebar panels
    test('hover-panel-exists', !!document.getElementById('hover-panel'));
    test('section-schemes-exists', !!document.getElementById('section-schemes'));
    test('section-color-exists', !!document.getElementById('section-color'));

    // Selection elements
    test('selection-count-exists', !!document.getElementById('selection-count'));
    test('selection-list-exists', !!document.getElementById('selection-list'));

    // Stats panel
    test('stats-nodes-exists', !!document.getElementById('stats-nodes'));
    test('stats-edges-exists', !!document.getElementById('stats-edges'));

    // Performance HUD
    test('perf-hud-exists', !!document.getElementById('perf-hud'));
    test('perf-fps-exists', !!document.getElementById('perf-fps'));

    // Test 1b: Color mode buttons exist
    const colorButtons = document.querySelectorAll('.color-btn[data-preset]');
    test('color-mode-buttons-exist', colorButtons.length >= 4);

    // Test 1c: HUD Layout Manager tests
    test('hud-layout-manager-exists', typeof HudLayoutManager === 'object' && HudLayoutManager !== null);
    test('hud-layout-manager-has-reflow', typeof HudLayoutManager.reflow === 'function');
    test('hud-layout-manager-has-placePanel', typeof HudLayoutManager.placePanel === 'function');

    // Test 1d: HUD placement with synthetic rects (collision avoidance)
    if (typeof HudLayoutManager.placePanel === 'function') {
        // Create a test scenario: occupied rect on top-left, panel should avoid it
        const fakeOccupied = [{ left: 0, top: 0, right: 300, bottom: 200 }];
        const fakeCandidates = [
            { left: 20, top: 100 },   // Would overlap with occupied
            { left: 400, top: 100 }   // Should be clear
        ];
        // Create a mock panel element
        const mockPanel = document.createElement('div');
        mockPanel.style.width = '200px';
        mockPanel.style.height = '150px';
        mockPanel.style.position = 'fixed';
        document.body.appendChild(mockPanel);

        const result = HudLayoutManager.placePanel(mockPanel, fakeCandidates, fakeOccupied);
        // Should choose the second candidate (no overlap)
        const pickedNonOverlapping = result && result.left >= 300;
        test('hud-placement-avoids-overlap', pickedNonOverlapping);

        document.body.removeChild(mockPanel);
    }

    // Test 1e: Canonical taxonomy field tests
    // Test that node.tier is preferred over atom prefix inference
    const mockNodeWithTier = { tier: 'T2', atom: 'CORE.001', ring: 'DOMAIN' };
    const tierResult = getNodeTier(mockNodeWithTier);
    test('node-tier-prefers-field', tierResult === 'T2');  // Should use tier field, not infer T0 from CORE.

    // Test that node.ring is used when present
    const mockNodeWithRing = { ring: 'PRESENTATION', layer: 'APPLICATION' };
    const ringResult = getNodeRing(mockNodeWithRing);
    test('node-ring-prefers-field', ringResult === 'PRESENTATION');  // Should use ring, not layer

    // Test tier aliases work (CORE → T0, EXT → T2)
    test('tier-alias-core-to-t0', normalizeTier('CORE') === 'T0');
    test('tier-alias-ext-to-t2', normalizeTier('EXT') === 'T2');

    // Test atom_family extraction
    const mockNodeWithFamily = { atom_family: 'LOG', atom: 'ORG.AGG.M' };
    const familyResult = getNodeAtomFamily(mockNodeWithFamily);
    test('node-atom-family-prefers-field', familyResult === 'LOG');  // Should use atom_family, not infer ORG

    // Test 1f: Hover panel tests
    test('hover-panel-exists', document.getElementById('hover-panel') !== null);

    // Test hover panel uses canonical fields
    const mockCanonicalNode = {
        name: 'TestNode',
        atom_family: 'LOG',
        ring: 'PRESENTATION',
        tier: 'T2',
        atom: 'ORG.AGG.M',
        kind: 'function',
        role: 'Utility'
    };
    // Simulate updateHoverPanel with mock node
    if (typeof updateHoverPanel === 'function') {
        updateHoverPanel(mockCanonicalNode);
        const hoverFamily = document.getElementById('hover-family')?.textContent;
        const hoverRing = document.getElementById('hover-ring')?.textContent;
        const hoverTier = document.getElementById('hover-tier')?.textContent;
        // Verify canonical fields are used (LOG not ORG, PRESENTATION, T2)
        test('hover-panel-uses-canonical-fields',
            hoverFamily === 'LOG' && hoverRing === 'PRESENTATION' && hoverTier === 'T2');
        // Clean up: hide panel
        updateHoverPanel(null);
    }

    // Test 2: Header stats populated (stat-* elements - these are set early)
    const headerNodes = document.getElementById('stat-nodes');
    const headerEdges = document.getElementById('stat-edges');
    test('header-nodes-populated', headerNodes && headerNodes.textContent !== '0');
    test('header-edges-populated', headerEdges && headerEdges.textContent !== '0');

    // Test 3: Data integrity
    test('nodes-count-positive', data.nodes && data.nodes.length > 0);
    test('links-count-positive', data.links && data.links.length > 0);
    test('graph-initialized', !!window.Graph);

    // Test 4: Controls config loaded
    test('controls-config-exists', !!data.controls);
    test('appearance-config-exists', !!data.appearance);
    test('physics-config-exists', !!data.physics);

    // Test 5: Initial state correct
    const physicsCharge = document.getElementById('physics-charge');
    test('physics-slider-has-value', physicsCharge && physicsCharge.value !== undefined);
    test('3d-mode-default', IS_3D === true);

    // Test 6: VIS_STATE module loaded
    test('vis-state-module-exists', typeof VIS_STATE !== 'undefined');
    test('vis-state-has-applyState', typeof VIS_STATE?.applyState === 'function');
    test('vis-state-has-getState', typeof VIS_STATE?.getState === 'function');

    // Expose results to window for external testing
    window.SELF_TEST_RESULTS = results;

    // Log summary
    const total = results.passed.length + results.failed.length;
    const passRate = ((results.passed.length / total) * 100).toFixed(1);

    if (results.failed.length === 0) {
        console.log(`%c✅ SELF-TEST PASSED: ${results.passed.length}/${total} tests (${passRate}%)`, 'color: #00ff00; font-weight: bold');
    } else {
        console.warn(`%c⚠️ SELF-TEST: ${results.passed.length}/${total} passed (${passRate}%)`, 'color: #ffaa00; font-weight: bold');
        console.warn('Failed tests:', results.failed);
    }

    return results;
}

// TIER_ALIASES, normalizeTier, getNodeTier, getNodeAtomFamily, normalizeRingValue,
// getNodeRing, getNodeLayer, getNodeEffect - provided by node-accessors.js module

// getNodeColorByMode, getSubsystem, getPhase, getFileType, getRoleCategory, applyNodeColors - MOVED TO modules/node-helpers.js
// normalize - MOVED TO modules/utils.js

function filterGraph(data, minVal, datamapSet, filters) {
    // ALL DATA FROM DM - the processing pipeline
    const allNodes = DM ? DM.getNodes() : (data?.nodes || []);
    const allLinks = DM ? DM.getLinks() : (data?.links || []);

    const tierFilter = filters?.tiers || new Set();
    const ringFilter = filters?.rings || new Set();
    const roleFilter = filters?.roles || new Set();
    const edgeFilter = filters?.edges || new Set();
    const familyFilter = filters?.families || new Set();
    const layerFilter = filters?.layers || new Set();
    const effectFilter = filters?.effects || new Set();
    const edgeFamilyFilter = filters?.edgeFamilies || new Set();
    const showEdges = filters?.metadata?.showEdges !== false;

    const availableRings = Array.from(new Set(allNodes.map(n => getNodeRing(n)))).sort();
    let ringFilterValues = Array.from(ringFilter);
    let ringIntersection = ringFilterValues.filter(r => availableRings.includes(r));
    if (ringFilterValues.length > 0 && ringIntersection.length === 0) {
        console.warn('[Filters] Ring filter values not present in dataset; clearing.', {
            ringValues: ringFilterValues,
            availableRings
        });
        ringFilter.clear();
        ringFilterValues = [];
        ringIntersection = [];
    }

    // Filter nodes by size/importance
    let visibleNodes = allNodes.filter(n => (n.val ?? 1) >= minVal);

    if (datamapSet && datamapSet.size > 0) {
        visibleNodes = visibleNodes.filter(n => {
            for (const id of datamapSet) {
                const config = DATAMAP_INDEX[id];
                if (config && datamapMatches(n, config)) return true;
            }
            return false;
        });
    }

    const tierFilterActive = tierFilter.size > 0;
    const ringFilterActive = ringFilter.size > 0;
    const roleFilterActive = roleFilter.size > 0;
    const familyFilterActive = familyFilter.size > 0;
    const layerFilterActive = layerFilter.size > 0;
    const effectFilterActive = effectFilter.size > 0;

    const filterSummary = {
        active: {
            tier: tierFilter.size,
            ring: ringFilter.size,
            role: roleFilter.size,
            family: familyFilter.size,
            layer: layerFilter.size,
            effect: effectFilter.size
        },
        ringValues: ringFilterValues.slice().sort(),
        availableRings,
        ringIntersectionSize: ringIntersection.length
    };
    const filterSummaryKey = JSON.stringify(filterSummary);
    if (filterSummaryKey !== LAST_FILTER_SUMMARY) {
        console.log('[Filters] summary', filterSummary);
        LAST_FILTER_SUMMARY = filterSummaryKey;
    }

    visibleNodes = visibleNodes.filter(n => {
        if (tierFilterActive && !tierFilter.has(getNodeTier(n))) return false;
        if (ringFilterActive && !ringFilter.has(getNodeRing(n))) return false;
        if (roleFilterActive && !roleFilter.has(String(n.role || 'Unknown'))) return false;
        if (familyFilterActive && !familyFilter.has(getNodeAtomFamily(n))) return false;
        if (layerFilterActive && !layerFilter.has(getNodeLayer(n))) return false;
        if (effectFilterActive && !effectFilter.has(getNodeEffect(n))) return false;
        return true;
    });



    // Zero-node protection: warn when dimension filters result in empty graph
    if (visibleNodes.length === 0 && (tierFilterActive || ringFilterActive || roleFilterActive || familyFilterActive || layerFilterActive || effectFilterActive)) {
        const activeFilters = [];
        if (tierFilterActive) activeFilters.push(`tiers: [${Array.from(tierFilter).join(', ')}]`);
        if (ringFilterActive) activeFilters.push(`rings: [${Array.from(ringFilter).join(', ')}]`);
        if (roleFilterActive) activeFilters.push(`roles: [${Array.from(roleFilter).join(', ')}]`);
        if (familyFilterActive) activeFilters.push(`families: [${Array.from(familyFilter).join(', ')}]`);
        if (layerFilterActive) activeFilters.push(`layers: [${Array.from(layerFilter).join(', ')}]`);
        if (effectFilterActive) activeFilters.push(`effects: [${Array.from(effectFilter).join(', ')}]`);
        console.warn('[filterGraph] Zero nodes match filters:', activeFilters.join(', '));
    }

    const visibleIds = new Set(visibleNodes.map(n => n.id));

    // Keep edges only between visible nodes
    let visibleLinks = allLinks.filter(l =>
        visibleIds.has(l.source.id || l.source) &&
        visibleIds.has(l.target.id || l.target)
    );

    if (edgeFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFilter.has(String(l.edge_type || l.type || 'default')));
    }

    if (edgeFamilyFilter.size > 0) {
        visibleLinks = visibleLinks.filter(l => edgeFamilyFilter.has(l.family || 'Dependency'));
    }

    if (!showEdges) {
        visibleLinks = [];
    }

    return { nodes: visibleNodes, links: visibleLinks };
}

// ====================================================================
// LAYOUT STABILITY: saveNodePositions, restoreNodePositions, freezeLayout, unfreezeLayout, resetLayout - MOVED TO modules/layout-helpers.js
// showModeToast - MOVED TO modules/tooltips.js
// getLinkEndpointId, getFileTarget - MOVED TO modules/layout-helpers.js
// stableOffset - MOVED TO modules/utils.js

// buildFileGraph - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.buildFileGraph)
// captureFileNodePositions - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.captureFileNodePositions)

function buildHybridGraph(data) {
    // ALL DATA FROM DM - the reaction chamber for data chemistry
    if (!FILE_GRAPH) {
        FILE_GRAPH = buildFileGraph(data);
    }
    const boundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const nodes = DM ? DM.getNodes() : (data?.nodes || []);
    const links = DM ? DM.getLinks() : (data?.links || []);

    const totalFiles = boundaries.length;
    const clusterConfig = data?.physics?.cluster || {};
    const detachRadius = (typeof clusterConfig.radius === 'number') ? clusterConfig.radius * 1.3 : 200;
    const detachZ = (typeof clusterConfig.zSpacing === 'number') ? clusterConfig.zSpacing * 2 : 80;
    const expandRadius = 30;
    const expandedSet = new Set(EXPANDED_FILES);

    const fileNodes = FILE_GRAPH.nodes.map(node => {
        const copy = Object.assign({}, node);
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach' && expandedSet.has(node.fileIdx))
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        copy.x = anchor.x + detachOffset.x;
        copy.y = anchor.y + detachOffset.y;
        copy.z = (anchor.z || 0) + detachOffset.z;
        return copy;
    });

    const nodeFileIdx = new Map();
    nodes.forEach(n => {
        if (n && n.id) {
            nodeFileIdx.set(n.id, n.fileIdx ?? -1);
        }
    });

    const childNodes = [];
    nodes.forEach(node => {
        if (!expandedSet.has(node.fileIdx)) return;
        const anchor = FILE_NODE_POSITIONS.get(node.fileIdx) || getFileTarget(node.fileIdx, totalFiles, 140, 30);
        const detachOffset = (FILE_EXPAND_MODE === 'detach')
            ? getFileTarget(node.fileIdx, totalFiles, detachRadius, detachZ)
            : { x: 0, y: 0, z: 0 };
        const local = stableOffset(node, `file-${node.fileIdx}`, expandRadius);
        const copy = Object.assign({}, node);
        copy.x = anchor.x + detachOffset.x + local.x;
        copy.y = anchor.y + detachOffset.y + local.y;
        copy.z = (anchor.z || 0) + detachOffset.z + (IS_3D ? local.z : 0);
        childNodes.push(copy);
    });

    const childLinks = [];
    links.forEach(link => {
        const srcId = getLinkEndpointId(link, 'source');
        const tgtId = getLinkEndpointId(link, 'target');
        const srcIdx = nodeFileIdx.get(srcId) ?? -1;
        const tgtIdx = nodeFileIdx.get(tgtId) ?? -1;
        if (srcIdx < 0 || tgtIdx < 0 || srcIdx !== tgtIdx) return;
        if (!expandedSet.has(srcIdx)) return;
        childLinks.push({
            source: srcId,
            target: tgtId,
            color: link.color,
            opacity: link.opacity,
            edge_type: link.edge_type,
            weight: link.weight,
            confidence: link.confidence,
            resolution: link.resolution
        });
    });

    return {
        nodes: fileNodes.concat(childNodes),
        links: FILE_GRAPH.links.concat(childLinks)
    };
}

function setupControls(data) {
    // Initialize the Unified UI Manager
    UIManager.init(data);

    // HudLayoutManager.init() - REMOVED: Now handled by LAYOUT.init() in main.js
    // The LAYOUT module is initialized via initializeModules() to avoid double-init

    // Initialize Command Bar and Floating Panels
    initCommandBar();

    // Initialize Selection Detail Modal
    initSelectionModal();

    // Initialize Node & Edge Config Controls (PRIME SECTIONS)
    setupConfigControls();

    // Render color-coded legends with counts
    renderAllLegends();

    // Flow mode button (attached here for proper DOM timing)
    const btnFlow = document.getElementById('btn-flow');
    if (btnFlow) btnFlow.onclick = () => toggleFlowMode();
}

/**
 * =================================================================
 * setupConfigControls: Initialize NODE CONFIG and EDGE CONFIG panels
 * =================================================================
 * These are the "prime position" controls at the top of the sidebar
 */
function setupConfigControls() {
    // Helper: Bind slider with value display
    const bindSlider = (id, valueId, onChange, decimals = 1) => {
        const slider = document.getElementById(id);
        const valueEl = document.getElementById(valueId);
        if (!slider) return;
        slider.addEventListener('input', () => {
            const val = parseFloat(slider.value);
            if (valueEl) valueEl.textContent = decimals === 0 ? val.toString() : val.toFixed(decimals);
            onChange(val);
        });
    };

    // Helper: Bind toggle switch
    const bindToggle = (id, initialState, onChange) => {
        const toggle = document.getElementById(id);
        if (!toggle) return;
        if (initialState) toggle.classList.add('active');
        else toggle.classList.remove('active');
        toggle.addEventListener('click', () => {
            const isActive = toggle.classList.toggle('active');
            onChange(isActive);
        });
    };

    // Helper: Bind button group (radio-like selection)
    const bindButtonGroup = (container, dataAttr, onChange) => {
        const buttons = container.querySelectorAll(`[${dataAttr}]`);
        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                onChange(btn.getAttribute(dataAttr));
            });
        });
    };

    // ═══════════════════════════════════════════════════════════════════
    // NODE CONFIG
    // ═══════════════════════════════════════════════════════════════════

    // Size Mode Selector
    const nodeCfg = document.getElementById('section-node-config');
    if (nodeCfg) {
        bindButtonGroup(nodeCfg, 'data-size-mode', (mode) => {
            APPEARANCE_STATE.sizeMode = mode;
            applyNodeSizeMode(mode);
            console.log('[CONFIG] Size mode:', mode);
        });
    }

    // Node Base Size
    bindSlider('cfg-node-size', 'cfg-node-size-val', (val) => {
        APPEARANCE_STATE.nodeScale = val;
        applyNodeSizeMode(APPEARANCE_STATE.sizeMode || 'uniform');
    });

    // Node Opacity
    bindSlider('cfg-node-opacity', 'cfg-node-opacity-val', (val) => {
        APPEARANCE_STATE.nodeOpacity = val;
        if (Graph) Graph.nodeOpacity(val);
    });

    // Node Resolution (sphere segments)
    bindSlider('cfg-node-res', 'cfg-node-res-val', (val) => {
        APPEARANCE_STATE.nodeResolution = Math.round(val);
        if (Graph) Graph.nodeResolution(Math.round(val));
    }, 0);

    // Label Size
    bindSlider('cfg-label-size', 'cfg-label-size-val', (val) => {
        APPEARANCE_STATE.labelSize = val;
        if (Graph && APPEARANCE_STATE.showLabels) {
            Graph.nodeLabel(node => val > 0.2 ? (node.name || node.id) : null);
        }
    });

    // Show Labels Toggle
    bindToggle('cfg-toggle-labels', APPEARANCE_STATE.showLabels, (active) => {
        APPEARANCE_STATE.showLabels = active;
        if (Graph) Graph.nodeLabel(node => active ? (node.name || node.id) : null);
    });

    // Highlight Selected Toggle
    bindToggle('cfg-toggle-highlight', APPEARANCE_STATE.highlightSelected, (active) => {
        APPEARANCE_STATE.highlightSelected = active;
        if (typeof updateSelectionVisuals === 'function') updateSelectionVisuals();
    });

    // Pulse Animation Toggle
    bindToggle('cfg-toggle-pulse', false, (active) => {
        APPEARANCE_STATE.pulseAnimation = active;
        console.log('[CONFIG] Pulse animation:', active ? 'ON' : 'OFF');
    });

    // 3D Depth Shading Toggle
    bindToggle('cfg-toggle-depth', true, (active) => {
        APPEARANCE_STATE.depthShading = active;
        console.log('[CONFIG] Depth shading:', active ? 'ON' : 'OFF');
    });

    // ═══════════════════════════════════════════════════════════════════
    // EDGE CONFIG - Enhanced with better visibility and flow animation
    // ═══════════════════════════════════════════════════════════════════

    // Edge Style Selector
    const edgeCfg = document.getElementById('section-edge-config');
    if (edgeCfg) {
        bindButtonGroup(edgeCfg, 'data-edge-style', (style) => {
            APPEARANCE_STATE.edgeStyle = style;
            applyEdgeStyle(style);
            console.log('[CONFIG] Edge style:', style);
        });
    }

    // Edge Opacity - ENHANCED: Higher default for visibility
    bindSlider('cfg-edge-opacity', 'cfg-edge-opacity-val', (val) => {
        APPEARANCE_STATE.edgeOpacity = val;
        // Use applyEdgeMode to ensure consistent function-based opacity
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Width - ENHANCED: Thicker default
    bindSlider('cfg-edge-width', 'cfg-edge-width-val', (val) => {
        APPEARANCE_STATE.edgeWidth = val;
        // Use applyEdgeMode to ensure consistent function-based width
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Edge Curvature - Direct Graph API (not handled by EDGE module)
    bindSlider('cfg-edge-curve', 'cfg-edge-curve-val', (val) => {
        APPEARANCE_STATE.edgeCurvature = val;
        if (Graph) Graph.linkCurvature(val);
    });

    // Particle Speed - For FLOW visualization
    bindSlider('cfg-particle-speed', 'cfg-particle-speed-val', (val) => {
        APPEARANCE_STATE.particleSpeed = val;
        if (Graph) Graph.linkDirectionalParticleSpeed(val);
    }, 3);

    // Particle Density - For FLOW visualization
    bindSlider('cfg-particle-count', 'cfg-particle-count-val', (val) => {
        APPEARANCE_STATE.particleCount = Math.round(val);
        if (Graph) Graph.linkDirectionalParticles(Math.round(val));
    }, 0);

    // Show Arrows Toggle
    bindToggle('cfg-toggle-arrows', APPEARANCE_STATE.showArrows, (active) => {
        APPEARANCE_STATE.showArrows = active;
        if (Graph) {
            Graph.linkDirectionalArrowLength(active ? 6 : 0);
            Graph.linkDirectionalArrowRelPos(0.9);
        }
    });

    // Gradient Colors Toggle
    bindToggle('cfg-toggle-gradient', APPEARANCE_STATE.gradientEdges, (active) => {
        APPEARANCE_STATE.gradientEdges = active;
        if (typeof applyEdgeMode === 'function') applyEdgeMode();
    });

    // Highlight Edges on Hover Toggle
    bindToggle('cfg-toggle-edge-hover', true, (active) => {
        APPEARANCE_STATE.edgeHoverHighlight = active;
    });

    // ═══════════════════════════════════════════════════════════════════
    // Section Collapse Handlers
    // ═══════════════════════════════════════════════════════════════════
    document.querySelectorAll('.section-header[data-section]').forEach(header => {
        header.addEventListener('click', () => {
            const sectionId = header.dataset.section;
            const content = document.getElementById(`section-${sectionId}`);
            if (!content) return;
            const isCollapsed = header.classList.toggle('collapsed');
            content.classList.toggle('collapsed', isCollapsed);
        });
    });

    console.log('[CONFIG] Node & Edge config controls initialized');
}

// applyNodeSizeMode - MOVED TO modules/node-helpers.js

/**
 * Apply edge style - controls edge rendering mode
 */
function applyEdgeStyle(style) {
    if (!Graph) return;
    const opacity = APPEARANCE_STATE.edgeOpacity || 0.4;
    const speed = APPEARANCE_STATE.particleSpeed || 0.01;
    const count = APPEARANCE_STATE.particleCount || 0;

    switch (style) {
        case 'solid':
            Graph.linkLineDash(null);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'dashed':
            Graph.linkLineDash([4, 4]);
            Graph.linkOpacity(opacity);
            Graph.linkDirectionalParticles(count);
            break;
        case 'particle':
            // Particle mode: dim lines, bright particles for flow effect
            Graph.linkLineDash(null);
            Graph.linkOpacity(Math.max(0.1, opacity * 0.3));
            Graph.linkDirectionalParticles(Math.max(4, count));
            Graph.linkDirectionalParticleSpeed(speed);
            Graph.linkDirectionalParticleWidth(3);
            Graph.linkDirectionalParticleColor(link => {
                // Use source node color for particles
                if (link.source && typeof link.source === 'object') {
                    return link.source.__threeObj?.material?.color?.getStyle() || '#00d4ff';
                }
                return '#00d4ff';
            });
            break;
    }
}

// UIManager - provided by ui-manager.js module (window.UI_MANAGER, window.UIManager)

function refreshGraph() {
    if (!DM || !Graph) return;  // ALL DATA FROM DM

    // LAYOUT STABILITY: Save current positions before any graph update
    saveNodePositions();

    if (GRAPH_MODE === 'files') {
        if (!FILE_GRAPH) {
            FILE_GRAPH = buildFileGraph(null);  // Uses DM internally
        }
        restoreNodePositions(FILE_GRAPH.nodes);
        Graph.graphData(FILE_GRAPH);
        applyFileColors(FILE_GRAPH.nodes);
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel('name');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    if (GRAPH_MODE === 'hybrid') {
        const hybrid = buildHybridGraph(null);  // Uses DM internally
        restoreNodePositions(hybrid.nodes);
        Graph.graphData(hybrid);
        applyFileColors(hybrid.nodes);
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    const subset = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);  // Uses DM internally
    if (ACTIVE_DATAMAPS.size > 0 && subset.nodes.length === 0) {
        showToast('No nodes for that datamap selection.');
        ACTIVE_DATAMAPS.clear();
        const fallback = filterGraph(null, CURRENT_DENSITY, new Set(), VIS_FILTERS);  // Uses DM internally
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        // Force re-evaluation of accessors
        Graph.nodeColor(Graph.nodeColor());
        Graph.nodeRelSize(Graph.nodeRelSize());
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        if (fileMode && GRAPH_MODE === 'atoms') {
            applyFileVizMode();
        }
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    // Zero-node protection for VIS_FILTERS (tier/ring/family/role)
    const hasActiveFilters = VIS_FILTERS.tiers.size > 0 || VIS_FILTERS.rings.size > 0 ||
        VIS_FILTERS.families.size > 0 || VIS_FILTERS.roles.size > 0;
    if (subset.nodes.length === 0 && hasActiveFilters) {
        showToast('No nodes match current filters. Clearing filters.');
        clearAllFilters();
        const fallback = filterGraph(null, CURRENT_DENSITY, ACTIVE_DATAMAPS, VIS_FILTERS);
        restoreNodePositions(fallback.nodes);
        Graph.graphData(fallback);
        applyNodeColors(fallback.nodes);
        Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
        Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
        applyEdgeMode();
        updateDatamapControls();
        syncSelectionAfterGraphUpdate();
        if (LAYOUT_FROZEN) freezeLayout();
        return;
    }

    applyNodeColors(subset.nodes);
    restoreNodePositions(subset.nodes);
    Graph.graphData(subset);
    Graph.nodeVal(node => (node.val || 1) * APPEARANCE_STATE.nodeScale);
    Graph.nodeLabel(VIS_FILTERS.metadata.showLabels ? 'name' : '');
    applyEdgeMode();
    if (fileMode && GRAPH_MODE === 'atoms') {
        applyFileVizMode();
    }
    updateDatamapControls();
    syncSelectionAfterGraphUpdate();
    if (LAYOUT_FROZEN) freezeLayout();
}

// ═══════════════════════════════════════════════════════════════════════
// 3D TOPOLOGICAL MINIMAP - Interactive filter visualization
// THE STANDARD MODEL TOPOLOGY: 16 Levels × 3 Layers × Families
// ═══════════════════════════════════════════════════════════════════════

// THE 16 ABSTRACTION LEVELS (vertical axis: L-3 to L12)
const SCALE_16_LEVELS = {
    // COSMOLOGICAL (L8-L12) - Beyond scope, shown as outer haze
    'L12': { name: 'UNIVERSE', symbol: '🌐', zone: 'COSMOLOGICAL', y: 1.4, color: { h: 260, s: 30, l: 25 } },
    'L11': { name: 'DOMAIN', symbol: '🏛️', zone: 'COSMOLOGICAL', y: 1.3, color: { h: 250, s: 35, l: 30 } },
    'L10': { name: 'ORGANIZATION', symbol: '🏢', zone: 'COSMOLOGICAL', y: 1.2, color: { h: 240, s: 40, l: 35 } },
    'L9': { name: 'PLATFORM', symbol: '☁️', zone: 'COSMOLOGICAL', y: 1.1, color: { h: 230, s: 45, l: 40 } },
    'L8': { name: 'ECOSYSTEM', symbol: '🔗', zone: 'COSMOLOGICAL', y: 1.0, color: { h: 220, s: 50, l: 45 } },
    // ARCHITECTURAL (L4-L7) - Primary visible zone (teal - virtual depths)
    'L7': { name: 'SYSTEM', symbol: '⬡', zone: 'ARCHITECTURAL', y: 0.7, color: { h: 175, s: 60, l: 52 } },
    'L6': { name: 'PACKAGE', symbol: '📦', zone: 'ARCHITECTURAL', y: 0.5, color: { h: 178, s: 62, l: 48 } },
    'L5': { name: 'FILE', symbol: '📄', zone: 'ARCHITECTURAL', y: 0.3, color: { h: 180, s: 65, l: 44 } },
    'L4': { name: 'CONTAINER', symbol: '⬢', zone: 'ARCHITECTURAL', y: 0.1, color: { h: 182, s: 68, l: 40 } },
    // SEMANTIC (L1-L3) - The operational core (silver/white - surface light)
    'L3': { name: 'NODE', symbol: '★', zone: 'SEMANTIC', y: -0.1, color: { h: 210, s: 25, l: 92 } },  // Brightest - fundamental unit
    'L2': { name: 'BLOCK', symbol: '▣', zone: 'SEMANTIC', y: -0.3, color: { h: 210, s: 30, l: 85 } },
    'L1': { name: 'STATEMENT', symbol: '─', zone: 'SEMANTIC', y: -0.5, color: { h: 210, s: 35, l: 78 } },
    // SYNTACTIC (L0) - The event horizon between meaning and data
    'L0': { name: 'TOKEN', symbol: '·', zone: 'SYNTACTIC', y: -0.7, color: { h: 60, s: 90, l: 55 } },  // Bright yellow - event horizon
    // PHYSICAL (L-1 to L-3) - The substrate (deep blue - ocean floor)
    'L-1': { name: 'CHARACTER', symbol: 'a', zone: 'PHYSICAL', y: -0.9, color: { h: 220, s: 70, l: 42 } },
    'L-2': { name: 'BYTE', symbol: '01', zone: 'PHYSICAL', y: -1.1, color: { h: 220, s: 75, l: 35 } },
    'L-3': { name: 'BIT/QUBIT', symbol: '⚡', zone: 'PHYSICAL', y: -1.3, color: { h: 220, s: 80, l: 28 } }  // Deepest
};

// THE THREE PARALLEL LAYERS (shells around the structure) - Depth/Elevation palette
const THREE_LAYERS = {
    'PHYSICAL': { order: 0, radius: 1.8, opacity: 0.15, color: { h: 220, s: 75, l: 35 }, description: 'Hardware, bits, memory, I/O' },
    'VIRTUAL': { order: 1, radius: 1.4, opacity: 0.25, color: { h: 175, s: 65, l: 45 }, description: 'Code, structures, algorithms' },
    'SEMANTIC': { order: 2, radius: 1.0, opacity: 0.35, color: { h: 210, s: 30, l: 88 }, description: 'Meaning, business logic, intent' }
};

// ═══════════════════════════════════════════════════════════════════════
// STANDARD MODEL THEORY CONTENT - Semantic descriptions for tooltips
// The codespace is a high-dimensional space where all software artifacts exist
// ═══════════════════════════════════════════════════════════════════════

const SMC_THEORY = {
    // THE THREE FUNDAMENTAL LAYERS
    layers: {
        'PHYSICAL': {
            icon: '⚡',
            title: 'Physical Layer',
            subtitle: 'The Substrate',
            body: 'The hardware reality: electrons, circuits, memory cells. Everything that exists in physical space-time.',
            theory: '"Matter is the canvas upon which computation paints its patterns."',
            examples: ['CPU registers', 'RAM cells', 'disk sectors', 'network signals']
        },
        'VIRTUAL': {
            icon: '💠',
            title: 'Virtual Layer',
            subtitle: 'The Structure',
            body: 'Pure information structures: code, data, algorithms. The mathematical forms that live in computational space.',
            theory: '"Between the physical and the meaningful lies the virtual — pure form without matter or purpose."',
            examples: ['variables', 'functions', 'classes', 'data structures']
        },
        'SEMANTIC': {
            icon: '🎯',
            title: 'Semantic Layer',
            subtitle: 'The Meaning',
            body: 'Intent and purpose: business logic, user goals, system behavior. The "why" behind the code.',
            theory: '"Semantics is where computation meets human intention — the bridge between bits and understanding."',
            examples: ['user stories', 'business rules', 'API contracts', 'domain models']
        }
    },

    // ATOM FAMILIES
    families: {
        'LOG': {
            icon: '📊',
            title: 'Logic Family',
            subtitle: 'The Reasoners',
            body: 'Elements that transform data through computation: conditionals, loops, calculations.',
            theory: '"Logic atoms are the decision-makers — they take inputs and produce outputs through transformation."',
            examples: ['if/else', 'for loops', 'calculations', 'validators']
        },
        'DAT': {
            icon: '📦',
            title: 'Data Family',
            subtitle: 'The Containers',
            body: 'Elements that hold and organize information: variables, structures, databases.',
            theory: '"Data atoms store state — they are the nouns in the grammar of code."',
            examples: ['variables', 'arrays', 'objects', 'databases']
        },
        'ORG': {
            icon: '🏗️',
            title: 'Organization Family',
            subtitle: 'The Architects',
            body: 'Elements that structure code: modules, classes, packages. They create boundaries.',
            theory: '"Organization atoms create order from chaos — the folders in the file system of abstraction."',
            examples: ['modules', 'classes', 'packages', 'namespaces']
        },
        'EXE': {
            icon: '⚙️',
            title: 'Execution Family',
            subtitle: 'The Doers',
            body: 'Elements that perform actions: function calls, I/O, system operations.',
            theory: '"Execution atoms are the verbs — where potential becomes actual."',
            examples: ['function calls', 'API requests', 'file writes', 'renders']
        },
        'EXT': {
            icon: '🔌',
            title: 'External Family',
            subtitle: 'The Connectors',
            body: 'Elements that interface with the outside: APIs, imports, system calls.',
            theory: '"External atoms are portals — they connect isolated systems into larger ecosystems."',
            examples: ['imports', 'API calls', 'env vars', 'dependencies']
        }
    },

    // TIERS
    tiers: {
        'T0': {
            icon: '🔬',
            title: 'Tier 0 — Foundation',
            subtitle: 'Low-level primitives',
            body: 'The atomic building blocks: individual statements, expressions, basic operations.',
            theory: '"T0 is where code meets silicon — the ground floor of abstraction."',
            examples: ['assignments', 'operators', 'literals', 'basic types']
        },
        'T1': {
            icon: '🔧',
            title: 'Tier 1 — Components',
            subtitle: 'Functional units',
            body: 'Grouped functionality: functions, methods, small modules.',
            theory: '"T1 is the sweet spot — complex enough to be useful, simple enough to understand."',
            examples: ['functions', 'methods', 'handlers', 'utilities']
        },
        'T2': {
            icon: '🏛️',
            title: 'Tier 2 — Architecture',
            subtitle: 'System structure',
            body: 'High-level organization: classes, modules, services. The skeleton of the codebase.',
            theory: '"T2 defines the shape of software — patterns emerge that echo through every line."',
            examples: ['classes', 'modules', 'services', 'controllers']
        }
    },

    // SPECIAL ELEMENTS
    special: {
        'core': {
            icon: '✨',
            title: 'The Nexus',
            subtitle: 'Singularity Point',
            body: 'The center of the topology: where all paths converge.',
            theory: '"Every codebase has a heart — the central modules that everything depends upon."',
            examples: ['main.js', 'app.py', 'index.ts', 'core.rs']
        },
        'elevator': {
            icon: '🚀',
            title: 'Data Elevator',
            subtitle: 'Cross-tier Highway',
            body: 'Vertical connections that move data between abstraction levels.',
            theory: '"Elevators are the call stacks of architecture."',
            examples: ['API layers', 'ORMs', 'serializers', 'adapters']
        },
        'hub-star': {
            icon: '⭐',
            title: 'Hub Node',
            subtitle: 'High-connectivity Center',
            body: 'A node with many incoming connections. Often a critical dependency.',
            theory: '"Hubs are the load-bearing walls — remove them and everything collapses."',
            examples: ['utils', 'config', 'logger', 'database']
        }
    }
};

// Tooltip state - shared with modules/tooltips.js
const TOOLTIP_STATE = { visible: false, currentKey: null, element: null, hideTimeout: null };

// initTooltips, showTopoTooltip, hideTopoTooltip - MOVED TO modules/tooltips.js

// ZONES define which levels belong to which visual band
const LEVEL_ZONES = {
    'COSMOLOGICAL': { levels: ['L12', 'L11', 'L10', 'L9', 'L8'], opacity: 0.2, blur: true },
    'ARCHITECTURAL': { levels: ['L7', 'L6', 'L5', 'L4'], opacity: 0.6, blur: false },
    'SEMANTIC': { levels: ['L3', 'L2', 'L1'], opacity: 1.0, blur: false },        // Primary focus
    'SYNTACTIC': { levels: ['L0'], opacity: 0.8, blur: false },                   // Event horizon
    'PHYSICAL': { levels: ['L-1', 'L-2', 'L-3'], opacity: 0.4, blur: true }
};

// ═══════════════════════════════════════════════════════════════════════
// getTopoColor - MOVED TO modules/color-helpers.js


// ═══════════════════════════════════════════════════════════════════════
// VISUALIZATION PRESETS - Different ways to see the topology
// ═══════════════════════════════════════════════════════════════════════
const VIS_PRESETS = {
    'tier': {
        name: 'By Tier (T0/T1/T2)',
        description: 'Core → Architecture → External',
        colorBy: 'tier',
        sizeBy: 'fanout',
        edgeBy: 'type'
    },
    'family': {
        name: 'By Atom Family',
        description: 'LOG, DAT, ORG, EXE, EXT',
        colorBy: 'family',
        sizeBy: 'fanout',
        edgeBy: 'type'
    },
    'layer': {
        name: 'By Layer',
        description: 'Physical → Virtual → Semantic',
        colorBy: 'layer',
        sizeBy: 'uniform',
        edgeBy: 'resolution'
    },
    'ring': {
        name: 'By Ring (Domain)',
        description: 'Domain architecture layers',
        colorBy: 'ring',
        sizeBy: 'fanout',
        edgeBy: 'type'
    },
    'file': {
        name: 'By File',
        description: 'Each file gets unique hue',
        colorBy: 'file',
        sizeBy: 'uniform',
        edgeBy: 'resolution'
    },
    'flow': {
        name: 'Markov Flow',
        description: 'Edge width = transition probability',
        colorBy: 'tier',
        sizeBy: 'entropy',
        edgeBy: 'weight'
    },
    'depth': {
        name: 'By Depth (Call Distance)',
        description: 'Distance from entry points',
        colorBy: 'depth',
        sizeBy: 'fanout',
        edgeBy: 'type'
    }
    // NOTE: Color schemes (viridis, plasma, thermal, etc.) are now in color-engine.js schemePaths
    // Access via COLOR.listSchemes(), COLOR.applyScheme(), COLOR.getSchemeColor()
};

// ═══════════════════════════════════════════════════════════════════════
// LAYOUT PRESETS - MOVED TO modules/animation.js
// ═══════════════════════════════════════════════════════════════════════
// LAYOUT_PRESETS, STAGGER_PATTERNS, CURRENT_LAYOUT, LAYOUT_ANIMATION_ID,
// LAYOUT_TIME, CURRENT_STAGGER_PATTERN, applyLayoutPreset, cycleStaggerPattern,
// startLayoutMotion, startFlockSimulation, groupNodesByTier
// All now provided by ANIM module with O(n) spatial hashing (fixes ARCH-002)








// Count nodes by tier and family







// Hermite basis functions for C¹ continuous color interpolation




// ═══════════════════════════════════════════════════════════════









// OKLCH-inspired colors (converted to linear RGB for Three.js)
// Chaos (bottom): OKLCH(0.25, 0.12, 240) ≈ deep cosmic blue




// ═══════════════════════════════════════════════════════════════


























// clearAllFilters - MOVED TO modules/visibility.js







// collectCounts, buildCheckboxRow, buildFilterGroup - MOVED TO modules/ui-builders.js
// resolveDefaults - MOVED TO modules/utils.js
// normalizeDatamapConfig, resolveDatamapConfigs, datamapMatches - MOVED TO modules/datamap.js
// buildDatamapToggle, buildExclusiveOptions - MOVED TO modules/ui-builders.js

function buildMetadataControls(containerId, metadata) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.innerHTML = '';

    const toggles = [
        { id: 'meta-labels', label: 'LABELS', key: 'showLabels' },
        { id: 'meta-file-panel', label: 'FILE PANEL', key: 'showFilePanel' },
        { id: 'meta-report', label: 'REPORT', key: 'showReportPanel' },
        { id: 'meta-edges', label: 'EDGES', key: 'showEdges' }
    ];

    toggles.forEach((toggle) => {
        buildCheckboxRow(container, toggle.id, toggle.label, null, metadata[toggle.key], (checked) => {
            metadata[toggle.key] = checked;
            applyMetadataVisibility();
            refreshGraph();
        });
    });
}

function buildAppearanceSliders(containerId, sliderConfigs) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.innerHTML = '';

    const resolveSlider = (key, fallback) => {
        const config = (sliderConfigs && sliderConfigs[key]) ? sliderConfigs[key] : {};
        return {
            label: config.label || fallback.label,
            min: (config.min !== undefined) ? config.min : fallback.min,
            max: (config.max !== undefined) ? config.max : fallback.max,
            step: (config.step !== undefined) ? config.step : fallback.step,
            default: (config.default !== undefined) ? config.default : fallback.value
        };
    };

    const sliderDefs = [
        (() => {
            const config = resolveSlider('edgeOpacity', {
                label: 'EDGE OPACITY',
                min: 0.02,
                max: 0.4,
                step: 0.01,
                value: EDGE_DEFAULT_OPACITY
            });
            return {
                id: 'edge-opacity',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.edgeOpacity ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.edgeOpacity = val;
                    applyEdgeMode();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('nodeScale', {
                label: 'NODE SCALE',
                min: 0.6,
                max: 2.5,
                step: 0.1,
                value: 1
            });
            return {
                id: 'node-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.nodeScale ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.nodeScale = val;
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('backgroundBrightness', {
                label: 'BACKGROUND',
                min: 0,
                max: 1,
                step: 0.05,
                value: 1
            });
            return {
                id: 'bg-brightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.backgroundBrightness ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.backgroundBrightness = val;
                    updateBackgroundBrightness();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('fileLightness', {
                label: 'FILE LIGHT',
                min: 20,
                max: 80,
                step: 1,
                value: 50
            });
            return {
                id: 'file-lightness',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.fileLightness ?? config.default,
                onChange: (val) => {
                    FILE_COLOR_CONFIG.lightness = val;
                    APPEARANCE_STATE.fileLightness = val;
                    if (fileMode) {
                        applyFileVizMode();
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hueShift', {
                label: 'HUE SHIFT',
                min: -180,
                max: 180,
                step: 1,
                value: 0
            });
            return {
                id: 'hue-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.hueShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.hueShift = val;
                    Color.setTransform('hueShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('chromaScale', {
                label: 'CHROMA SCALE',
                min: 0,
                max: 2,
                step: 0.05,
                value: 1
            });
            return {
                id: 'chroma-scale',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.chromaScale ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.chromaScale = val;
                    Color.setTransform('chromaScale', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('lightnessShift', {
                label: 'LIGHT SHIFT',
                min: -20,
                max: 20,
                step: 1,
                value: 0
            });
            return {
                id: 'lightness-shift',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: COLOR_TWEAKS.lightnessShift ?? config.default,
                onChange: (val) => {
                    COLOR_TWEAKS.lightnessShift = val;
                    Color.setTransform('lightnessShift', val);  // Sync to ColorOrchestrator
                    renderAllLegends();  // Re-render legends with new colors
                    refreshGraph();
                }
            };
        })(),
        (() => {
            const config = resolveSlider('boundaryOpacity', {
                label: 'HULL OPACITY',
                min: 0.02,
                max: 0.25,
                step: 0.01,
                value: 0.1
            });
            return {
                id: 'boundary-fill',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryFill ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryFill = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('hullWireOpacity', {
                label: 'HULL WIRE',
                min: 0.05,
                max: 0.6,
                step: 0.02,
                value: 0.35
            });
            return {
                id: 'boundary-wire',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.boundaryWire ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.boundaryWire = val;
                    if (fileMode && fileVizMode === 'hulls') {
                        drawFileBoundaries(null);  // Uses DM internally
                    }
                }
            };
        })(),
        (() => {
            const config = resolveSlider('clusterStrength', {
                label: 'CLUSTER FORCE',
                min: 0,
                max: 1,
                step: 0.1,
                value: 0.45
            });
            return {
                id: 'cluster-strength',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.clusterStrength ?? config.default,
                onChange: (val) => {
                    APPEARANCE_STATE.clusterStrength = val;
                    if (fileMode && fileVizMode === 'cluster') {
                        applyClusterForce(null);  // Uses DM internally
                    }
                }
            };
        })(),
        // ═══════════════════════════════════════════════════════════
        // AMPLIFIER SLIDER - Power law exponent for visual contrast
        // γ=1 linear, γ>1 amplifies small differences, γ<1 compresses
        // Formula: amplified = value^(1/γ)
        // ═══════════════════════════════════════════════════════════
        (() => {
            const config = resolveSlider('amplifier', {
                label: 'AMPLIFIER (γ)',
                min: 0.3,
                max: 5.0,
                step: 0.1,
                value: 1.0
            });
            return {
                id: 'amplifier',
                label: config.label,
                min: config.min,
                max: config.max,
                step: config.step,
                value: APPEARANCE_STATE.amplifier ?? config.default,
                className: 'meta-amplifier',  // Special styling for meta-slider
                description: 'γ>1 amplifies differences, γ<1 compresses',
                onChange: (val) => {
                    APPEARANCE_STATE.amplifier = val;
                    // Re-apply edge mode to update widths with new amplification
                    applyEdgeMode();
                    // If in flow mode, re-apply flow visualization
                    if (flowMode) {
                        applyFlowVisualization();
                    }
                }
            };
        })()
    ];

    sliderDefs.forEach(def => {
        const wrapper = document.createElement('div');
        wrapper.className = 'slider-row' + (def.className ? ' ' + def.className : '');

        // Header row with label and value
        const header = document.createElement('div');
        header.className = 'slider-header';
        const label = document.createElement('span');
        label.className = 'slider-label';
        label.textContent = def.label;
        const valueDisplay = document.createElement('span');
        valueDisplay.className = 'slider-value';
        valueDisplay.id = def.id + '-value';
        const safeValue = def.value ?? def.min ?? 0;  // Fallback to min or 0 if value is null
        valueDisplay.textContent = safeValue.toFixed(def.step < 1 ? 2 : 0);
        header.appendChild(label);
        header.appendChild(valueDisplay);

        // The slider input
        const input = document.createElement('input');
        input.type = 'range';
        input.className = 'slider-input';
        input.id = def.id;
        input.min = def.min;
        input.max = def.max;
        input.step = def.step;
        input.value = safeValue;
        input.oninput = () => {
            const val = parseFloat(input.value);
            valueDisplay.textContent = val.toFixed(def.step < 1 ? 2 : 0);
            def.onChange(val);
        };

        wrapper.appendChild(header);
        wrapper.appendChild(input);

        // Optional description for meta-sliders
        if (def.description) {
            const desc = document.createElement('div');
            desc.className = 'slider-desc';
            desc.textContent = def.description;
            wrapper.appendChild(desc);
        }

        container.appendChild(wrapper);
    });
}

// ═══════════════════════════════════════════════════════════════════════
// PHYSICS CONTROLS - Real-time force simulation adjustment
// ═══════════════════════════════════════════════════════════════════════
const PHYSICS_STATE = {
    charge: -120,
    linkDistance: 50,
    centerStrength: 0.05,
    velocityDecay: 0.4
};

const PHYSICS_PRESETS = {
    default: { charge: -120, linkDistance: 50, centerStrength: 0.05, velocityDecay: 0.4, label: 'DEFAULT' },
    tight: { charge: -80, linkDistance: 30, centerStrength: 0.1, velocityDecay: 0.5, label: 'TIGHT' },
    loose: { charge: -200, linkDistance: 80, centerStrength: 0.02, velocityDecay: 0.3, label: 'LOOSE' },
    explosive: { charge: -400, linkDistance: 120, centerStrength: 0.01, velocityDecay: 0.2, label: 'EXPLOSIVE' }
};

// applyPhysicsState, applyPhysicsPreset, updatePhysicsSliders, buildPhysicsControls - MOVED TO modules/physics.js

// updateBackgroundBrightness, applyMetadataVisibility - MOVED TO modules/visibility.js

// Deprecated setupSidebar - replaced by UIManager
// Deprecated buildDatamapControls - replaced by UIManager


// ═══════════════════════════════════════════════════════════════
// PRESET BUTTONS - Quick visualization mode selection (Tier, Family, etc.)
// Uses VIS_STATE for unified state management
// ═══════════════════════════════════════════════════════════════
const presetGrid = document.getElementById('dock-presets');
const presetBtnGrid = document.getElementById('preset-grid');
if (presetBtnGrid) {
    presetBtnGrid.querySelectorAll('.preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const presetKey = btn.dataset.preset;

            // Use VIS_STATE for unified state management
            if (typeof VIS_STATE !== 'undefined') {
                VIS_STATE.applyPreset(presetKey);
                return;
            }

            // Fallback for when VIS_STATE not loaded
            const preset = VIS_PRESETS[presetKey];
            if (!preset) return;

            presetBtnGrid.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.scheme-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            APPEARANCE_STATE.currentPreset = presetKey;
            APPEARANCE_STATE.colorMode = preset.colorBy;

            setNodeColorMode(preset.colorBy);

            const edgeModes = { 'type': 'gradient-tier', 'weight': 'weight', 'resolution': 'gradient-file' };
            EDGE_MODE = edgeModes[preset.edgeBy] || preset.edgeBy || 'gradient-tier';
            applyEdgeMode();

            if (presetKey === 'flow') {
                if (!flowMode && typeof toggleFlowMode === 'function') toggleFlowMode();
            } else if (flowMode && typeof disableFlowMode === 'function') {
                disableFlowMode();
            }

            if (typeof window.refreshGradientEdgeColors === 'function') {
                window.refreshGradientEdgeColors();
            }

            if (typeof renderAllLegends === 'function') {
                renderAllLegends();
            }

            console.log('[Preset] Applied:', preset.name, '| colorBy:', preset.colorBy, '| edgeBy:', preset.edgeBy);
        });
    });
}

// ═══════════════════════════════════════════════════════════════
// NOTE: Color scheme buttons are now handled by sidebar.js via SIDEBAR.initSchemeNavigator()
// The 33 named schemes (viridis, plasma, thermal, etc.) are defined in color-engine.js schemePaths
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// LAYOUT BUTTONS - Graph layout presets with perpetual motion
// ═══════════════════════════════════════════════════════════════
const layoutGrid = document.getElementById('layout-grid');
if (layoutGrid) {
    layoutGrid.querySelectorAll('.layout-btn').forEach(btn => {
        const layoutKey = btn.dataset.layout;
        // Assign ID if missing for Registry
        if (!btn.id) btn.id = `layout-btn-${layoutKey}`;

        REGISTRY.register(btn.id, () => {
            if (!layoutKey || !LAYOUT_PRESETS[layoutKey]) return;

            // Update active state
            layoutGrid.querySelectorAll('.layout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Apply the layout
            applyLayoutPreset(layoutKey, true);

            console.log('[Layout] Applied:', LAYOUT_PRESETS[layoutKey].name);
        }, { desc: `Activate ${layoutKey} layout` });
    });
}

// VIEW section controls
buildExclusiveOptions('filter-node-color', [
    { label: 'TIER', value: 'tier' },
    { label: 'RING', value: 'ring' },
    { label: 'FAMILY', value: 'family' },
    { label: 'LAYER', value: 'layer' },
    { label: 'FILE', value: 'file' },
    { label: 'ATOM', value: 'atom' },
    { label: 'COMPLEXITY', value: 'complexity' },
    { label: 'CHURN', value: 'churn' }
], NODE_COLOR_MODE, setNodeColorMode);
buildExclusiveOptions('filter-edge-mode', [
    { label: 'GRAD-FILE', value: 'gradient-file' },
    { label: 'GRAD-TIER', value: 'gradient-tier' },
    { label: 'GRAD-FLOW', value: 'gradient-flow' },
    { label: 'TYPE', value: 'type' },
    { label: 'WEIGHT', value: 'weight' },
    { label: 'MONO', value: 'mono' }
], EDGE_MODE, setEdgeMode);
buildMetadataControls('filter-metadata', VIS_FILTERS.metadata);
buildAppearanceSliders('appearance-sliders', {}); // controlsConfig removed - sliders built dynamically
buildPhysicsControls('physics-sliders');  // Physics/forces controls

applyMetadataVisibility();
updateBackgroundBrightness();
refreshGraph();

// setupCollapsibleSections - MOVED TO modules/visibility.js

// setupReport, setupAIInsights, setupMetrics - MOVED TO modules/report.js

// escapeHtml - MOVED TO modules/utils.js

// setupHudFade, updateHudStats - MOVED TO modules/hud.js

// showToast - MOVED TO modules/tooltips.js
// updateDatamapControls - MOVED TO modules/datamap.js

// toggleDimensions, setupDimensionToggle, animateDimensionChange - MOVED TO modules/dimension.js

// stableSeed, stableZ - MOVED TO modules/utils.js

// ====================================================================
// EDGE VISUALIZATION MODES - GRADIENT & DATA-DRIVEN SYSTEM
// ====================================================================
// NEW: Edge modes with gradients showing data progression & regions
const EDGE_MODE_ORDER = [
    'gradient-tier',      // Source→Target tier flow (architecture layers)
    'gradient-file',      // File boundaries (module regions)
    'gradient-flow',      // Markov probability (hot paths)
    'gradient-depth',     // Call depth progression
    'gradient-semantic',  // Semantic distance (type similarity)
    'type',               // Classic type-based
    'weight',             // Weight intensity
    'mono'                // Minimal monochrome
];
const EDGE_MODE_LABELS = {
    'gradient-tier': '▼ TIER FLOW',
    'gradient-file': '▼ FILE REGIONS',
    'gradient-flow': '▼ HOT PATHS',
    'gradient-depth': '▼ CALL DEPTH',
    'gradient-semantic': '▼ SEMANTIC',
    type: 'EDGE: TYPE',
    weight: 'EDGE: WEIGHT',
    mono: 'EDGE: MONO'
};
const EDGE_MODE_HINTS = {
    'gradient-tier': 'Gradient by architecture tier (T0→T1→T2)',
    'gradient-file': 'Color by file region - shows module boundaries',
    'gradient-flow': 'Hot paths - markov probability gradient',
    'gradient-depth': 'Color by call chain depth',
    'gradient-semantic': 'Color by semantic similarity of endpoints',
    type: 'Edge color by type (calls, imports, etc.)',
    weight: 'Edge width & color by weight',
    mono: 'Minimal monochrome'
};

// Gradient color palettes for different modes
const GRADIENT_PALETTES = {
    tier: {
        // Cool to Warm: Entry (blue) → Core (purple) → Exit (orange)
        T0: { h: 210, s: 70, l: 55 },  // Blue - entry points
        T1: { h: 280, s: 65, l: 50 },  // Purple - core logic
        T2: { h: 30, s: 80, l: 50 },   // Orange - utilities/exit
        UNKNOWN: { h: 0, s: 0, l: 40 } // Gray
    },
    file: {
        // Rainbow hues distributed across files
        saturation: 65,
        lightness: 48
    },
    flow: {
        // Cold (low prob) to Hot (high prob)
        cold: { h: 220, s: 60, l: 45 },   // Blue
        warm: { h: 45, s: 85, l: 50 },    // Yellow
        hot: { h: 0, s: 90, l: 55 }       // Red
    },
    depth: {
        // Shallow (bright) to Deep (dark, saturated)
        shallow: { h: 180, s: 50, l: 65 },  // Light cyan
        mid: { h: 260, s: 70, l: 50 },      // Purple
        deep: { h: 320, s: 80, l: 40 }      // Magenta
    },
    semantic: {
        // Similar (harmonious) to Different (contrasting)
        similar: { h: 150, s: 60, l: 50 },    // Green - same type
        related: { h: 200, s: 65, l: 48 },    // Cyan - related
        different: { h: 340, s: 75, l: 50 }   // Pink - different
    }
};

// FILE_HUE_MAP, buildFileHueMap - provided by edge-system.js module

// Get node tier value (0=T0, 1=T1, 2=T2)
// getNodeTierValue, getNodeDepth, getSemanticSimilarity - MOVED TO modules/node-helpers.js

// interpolateColor, applyColorTweaks, oklchToSrgb, oklchColor - MOVED TO modules/color-engine.js
// Use COLOR.interpolate() and COLOR.get() instead

// getGradientEdgeColor - MOVED TO modules/edge-system.js
// clamp01, clampValue - MOVED TO modules/utils.js
// hslColor REMOVED - Using OKLCH Native via Color.interpolate
// parseOklchString - MOVED TO modules/utils.js
// normalizeColorInput, toColorNumber - MOVED TO modules/color-helpers.js

// updateEdgeRanges, refreshNodeFileIndex, getLinkFileIdx - MOVED TO modules/edge-system.js
// (shims delegate to EDGE.updateRanges, EDGE.refreshNodeFileIndex; getLinkFileIdx is internal)

// normalizeMetric - MOVED TO modules/utils.js
// getEdgeColor, getEdgeWidth, applyEdgeMode, cycleEdgeMode, setEdgeMode - MOVED TO modules/edge-system.js
// (backward compat shims in edge-system.js)

// Datamap toggles are wired in buildDatamapControls().
const btnReport = document.getElementById('btn-report');
if (btnReport) {
    btnReport.onclick = () => {
        const panel = document.getElementById('report-panel');
        const btn = document.getElementById('btn-report');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// AI INSIGHTS PANEL TOGGLE
const btnInsights = document.getElementById('btn-insights');
if (btnInsights) {
    btnInsights.onclick = () => {
        const panel = document.getElementById('insights-panel');
        const btn = document.getElementById('btn-insights');
        if (!panel) return;
        const isOpen = panel.style.display === 'block';
        panel.style.display = isOpen ? 'none' : 'block';
        btn.classList.toggle('active', !isOpen);
    };
}

// setStarsVisible, STARS_STORAGE_KEY, stars toggle binding - MOVED TO modules/stars.js
// Call STARS.init() to initialize (done in modules/main.js)

// Reset Layout button - explicitly re-run physics
const btnResetLayout = document.getElementById('btn-reset-layout');
if (btnResetLayout) {
    btnResetLayout.onclick = () => resetLayout();
}

// Hints toggle - enable/disable mode toasts
const btnHints = document.getElementById('btn-hints');
if (btnHints) {
    btnHints.onclick = () => {
        HINTS_ENABLED = !HINTS_ENABLED;
        btnHints.classList.toggle('active', HINTS_ENABLED);
        if (HINTS_ENABLED) {
            showModeToast('Hints enabled');
        }
    };
}

const btnEdgeMode = document.getElementById('btn-edge-mode');
if (btnEdgeMode) {
    btnEdgeMode.onclick = () => cycleEdgeMode();
}

// ====================================================================
// FLOW MODE: Markov Chain Visualization (Token-Driven)
// ====================================================================
// flowMode hoisted to top
let originalLinkWidths = new Map();
let highEntropyNodes = new Set();
// FLOW_CONFIG is set in initGraph() from THE REMOTE CONTROL tokens

// getFlowPresetColor, getFlowPresetValue - MOVED TO modules/flow.js

// FLOW_PRESETS, currentFlowPreset - MOVED TO modules/flow.js

// toggleFlowMode, disableFlowMode, applyFlowVisualization, clearFlowVisualization - MOVED TO modules/flow.js

// setDatamap, setNodeColorMode, applyDatamap - MOVED TO modules/datamap.js

// ====================================================================
// FILE BOUNDARIES & HOVER SYSTEM
// ====================================================================
// NOTE: fileBoundaryMeshes, fileMode, fileVizMode, etc. declared at top of file

// hashToUnit - MOVED TO modules/utils.js
// getFileHue, getFileColor - MOVED TO modules/color-helpers.js
// updateHoverPanel, handleNodeHover, handleNodeClick - MOVED TO modules/hover.js
// buildDatasetKey - MOVED TO modules/utils.js
// loadGroups, saveGroups, getNextGroupColor, getGroupById, getPrimaryGroupForNode - MOVED TO modules/groups.js
// renderGroupList, updateGroupButtonState, createGroupFromSelection - MOVED TO modules/groups.js

// getSelectedNodes, setSelection, toggleSelection, clearSelection, maybeClearSelection - MOVED TO modules/selection.js
// Use SELECT.getSelectedNodes(), SELECT.set(), SELECT.toggle(), SELECT.clear(), SELECT.maybeClear()
// Shims in selection.js provide global function names for backward compatibility

function formatCountList(items, limit = 4) {
    return items.slice(0, limit).map(([key, count]) => `${key} ${count}`).join(' · ') || '--';
}

function appendSelectionRow(container, label, value) {
    const row = document.createElement('div');
    row.className = 'selection-row';
    const labelEl = document.createElement('span');
    labelEl.className = 'label';
    labelEl.textContent = label;
    const valueEl = document.createElement('span');
    valueEl.textContent = value || '--';
    row.appendChild(labelEl);
    row.appendChild(valueEl);
    container.appendChild(row);
}

function updateSelectionPanel() {
    const panel = document.getElementById('selection-panel');
    const body = document.getElementById('selection-body');
    const title = document.getElementById('selection-title');
    if (!panel || !body) return;

    const nodes = getSelectedNodes();
    if (!nodes.length) {
        panel.classList.remove('visible');
        body.innerHTML = '';
        return;
    }

    panel.classList.add('visible');
    if (title) title.textContent = `SELECTION (${nodes.length})`;
    body.innerHTML = '';

    if (nodes.length <= 3) {
        nodes.forEach(node => {
            const item = document.createElement('div');
            item.className = 'selection-item';
            const name = document.createElement('div');
            name.className = 'selection-name';
            name.textContent = node.name || node.id || 'Unknown';
            item.appendChild(name);
            appendSelectionRow(item, 'Family', getNodeAtomFamily(node));
            appendSelectionRow(item, 'Ring', getNodeRing(node));
            appendSelectionRow(item, 'Tier', getNodeTier(node));
            appendSelectionRow(item, 'Role', node.role || '--');
            const filePath = node.file_path || node.file || '';
            if (filePath) {
                const shortPath = filePath.length > 48 ? '...' + filePath.slice(-45) : filePath;
                appendSelectionRow(item, 'File', shortPath);
            }
            body.appendChild(item);
        });
    } else {
        const summary = document.createElement('div');
        summary.className = 'selection-summary';

        const families = collectCounts(nodes, n => getNodeAtomFamily(n));
        const rings = collectCounts(nodes, n => getNodeRing(n));
        const tiers = collectCounts(nodes, n => getNodeTier(n));

        const total = document.createElement('div');
        total.textContent = `Total: ${nodes.length} nodes`;
        summary.appendChild(total);

        const familyRow = document.createElement('div');
        familyRow.textContent = `Family: ${formatCountList(families)}`;
        summary.appendChild(familyRow);

        const ringRow = document.createElement('div');
        ringRow.textContent = `Ring: ${formatCountList(rings)}`;
        summary.appendChild(ringRow);

        const tierRow = document.createElement('div');
        tierRow.textContent = `Tier: ${formatCountList(tiers)}`;
        summary.appendChild(tierRow);

        const numericKeys = [
            ['tokens', 'TOKENS'],
            ['bytes', 'BYTES'],
            ['loc', 'LOC'],
            ['lines', 'LINES'],
            ['lines_of_code', 'LOC'],
            ['size', 'SIZE']
        ];
        const totals = {};
        nodes.forEach(node => {
            numericKeys.forEach(([key]) => {
                const value = Number(node[key]);
                if (Number.isFinite(value)) {
                    totals[key] = (totals[key] || 0) + value;
                }
            });
        });
        numericKeys.forEach(([key, label]) => {
            if (totals[key]) {
                const row = document.createElement('div');
                row.textContent = `${label}: ${Math.round(totals[key])}`;
                summary.appendChild(row);
            }
        });

        body.appendChild(summary);
    }

    HudLayoutManager.reflow();
}

// ═══════════════════════════════════════════════════════════════════════
// SELECTION DETAIL MODAL: Consolidated view of selected nodes
// ═══════════════════════════════════════════════════════════════════════
function showSelectionModal() {
    const nodes = getSelectedNodes();
    if (!nodes.length) {
        showToast('No nodes selected');
        return;
    }

    const overlay = document.getElementById('selection-modal-overlay');
    const title = document.getElementById('selection-modal-title');
    const statsContainer = document.getElementById('selection-modal-stats');
    const body = document.getElementById('selection-modal-body');

    if (!overlay || !body) return;

    // Calculate aggregates
    let totalTokens = 0, totalBytes = 0, totalLoc = 0;
    const tierCounts = {};
    const ringCounts = {};
    const familyCounts = {};
    const levelCounts = {};

    nodes.forEach(node => {
        totalTokens += Number(node.tokens) || 0;
        totalBytes += Number(node.bytes) || 0;
        totalLoc += Number(node.loc || node.lines || node.lines_of_code) || 0;

        const tier = getNodeTier(node);
        const ring = getNodeRing(node);
        const family = getNodeAtomFamily(node);
        const level = node.level || node.scale_level || 'L3';

        tierCounts[tier] = (tierCounts[tier] || 0) + 1;
        ringCounts[ring] = (ringCounts[ring] || 0) + 1;
        familyCounts[family] = (familyCounts[family] || 0) + 1;
        levelCounts[level] = (levelCounts[level] || 0) + 1;
    });

    // Calculate max relevance for normalization
    const maxVal = Math.max(...nodes.map(n => n.val || n.size || 1));

    // Update title
    title.textContent = `SELECTED NODES (${nodes.length})`;

    // Build stats bar
    statsContainer.innerHTML = '';
    const stats = [
        ['NODES', nodes.length.toLocaleString()],
        ['TOKENS', totalTokens.toLocaleString()],
        ['BYTES', totalBytes.toLocaleString()],
        ['LOC', totalLoc.toLocaleString()],
        ['TIERS', Object.keys(tierCounts).join(', ')],
        ['FAMILIES', Object.keys(familyCounts).length]
    ];
    stats.forEach(([label, value]) => {
        if (value && value !== '0') {
            const stat = document.createElement('div');
            stat.className = 'selection-modal-stat';
            stat.innerHTML = `
                        <span class="selection-modal-stat-label">${label}</span>
                        <span class="selection-modal-stat-value">${value}</span>
                    `;
            statsContainer.appendChild(stat);
        }
    });

    // Build table
    const sortedNodes = [...nodes].sort((a, b) => (b.val || b.size || 1) - (a.val || a.size || 1));

    body.innerHTML = `
                <table class="selection-modal-table">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Tier</th>
                            <th>Ring</th>
                            <th>Family</th>
                            <th>Level</th>
                            <th>Tokens</th>
                            <th>LOC</th>
                            <th>Relevance</th>
                        </tr>
                    </thead>
                    <tbody id="selection-modal-tbody"></tbody>
                </table>
            `;

    const tbody = document.getElementById('selection-modal-tbody');
    sortedNodes.forEach(node => {
        const tier = getNodeTier(node);
        const ring = getNodeRing(node);
        const family = getNodeAtomFamily(node);
        const level = node.level || node.scale_level || 'L3';
        const tokens = Number(node.tokens) || '--';
        const loc = Number(node.loc || node.lines || node.lines_of_code) || '--';
        const relevance = ((node.val || node.size || 1) / maxVal * 100).toFixed(0);

        const row = document.createElement('tr');
        row.innerHTML = `
                    <td class="node-name" title="${node.name || node.id}">${node.name || node.id}</td>
                    <td><span class="level-badge tier-badge">${tier}</span></td>
                    <td><span class="level-badge ring-badge">${ring}</span></td>
                    <td><span class="level-badge family-badge">${family}</span></td>
                    <td>${level}</td>
                    <td class="numeric">${typeof tokens === 'number' ? tokens.toLocaleString() : tokens}</td>
                    <td class="numeric">${typeof loc === 'number' ? loc.toLocaleString() : loc}</td>
                    <td>
                        <div class="relevance-bar">
                            <div class="relevance-fill" style="width: ${relevance}%"></div>
                        </div>
                    </td>
                `;
        tbody.appendChild(row);
    });

    // Show modal
    overlay.classList.add('visible');
}

function hideSelectionModal() {
    const overlay = document.getElementById('selection-modal-overlay');
    if (overlay) overlay.classList.remove('visible');
}

function initSelectionModal() {
    const overlay = document.getElementById('selection-modal-overlay');
    const closeBtn = document.getElementById('selection-modal-close');
    const selectionTitle = document.getElementById('selection-title');

    if (closeBtn) {
        closeBtn.addEventListener('click', hideSelectionModal);
    }

    if (overlay) {
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) hideSelectionModal();
        });
    }

    // Click on selection panel title to open modal
    if (selectionTitle) {
        selectionTitle.style.cursor = 'pointer';
        selectionTitle.addEventListener('click', showSelectionModal);
    }

    // Keyboard shortcut: 'i' for info when nodes selected
    document.addEventListener('keydown', (e) => {
        if (e.key === 'i' && !e.ctrlKey && !e.metaKey && !e.altKey) {
            const activeEl = document.activeElement;
            if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
            if (getSelectedNodes().length > 0) {
                e.preventDefault();
                showSelectionModal();
            }
        }
        if (e.key === 'Escape') {
            hideSelectionModal();
        }
        // Wave Pattern Cycling
        if (e.key === 'w' || e.key === 'W') {
            const activeEl = document.activeElement;
            if (!activeEl || (activeEl.tagName !== 'INPUT' && activeEl.tagName !== 'TEXTAREA')) {
                cycleStaggerPattern();
            }
        }
    });
}

function updateOverlayScale(node) {
    const base = Math.max(0.6, (node.val || 1) * (APPEARANCE_STATE.nodeScale || 1));
    const selectionScale = base * 2.5;  // BIGGER halo - was 1.9
    const groupScale = base * 1.8;      // Slightly bigger group halo
    if (node.__selectionHalo) {
        node.__selectionHalo.scale.set(selectionScale, selectionScale, selectionScale);
    }
    if (node.__groupHalo) {
        node.__groupHalo.scale.set(groupScale, groupScale, groupScale);
    }
}

function ensureNodeOverlays(node) {
    if (!node) return null;
    if (node.__overlayGroup) return node.__overlayGroup;

    const group = new THREE.Group();

    const selectionMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,      // BRIGHT CYAN - unmissable!
        transparent: true,
        opacity: 0.85,        // MUCH BRIGHTER - was 0.35
        depthWrite: false
    });
    const selectionHalo = new THREE.Mesh(SELECTION_HALO_GEOMETRY, selectionMaterial);
    selectionHalo.visible = false;
    selectionHalo.renderOrder = 3;

    const groupMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.45,        // BRIGHTER - was 0.18
        depthWrite: false
    });
    const groupHalo = new THREE.Mesh(GROUP_HALO_GEOMETRY, groupMaterial);
    groupHalo.visible = false;
    groupHalo.renderOrder = 2;

    group.add(selectionHalo);
    group.add(groupHalo);

    node.__selectionHalo = selectionHalo;
    node.__groupHalo = groupHalo;
    node.__overlayGroup = group;
    return group;
}

// Store original colors/sizes for selection restore
// (selectionOriginals declared early at top of file to avoid TDZ)
// SELECTION_SIZE_MULT moved to top
// PENDULUM moved to top

// Initialize from Config (if available)
// We call this immediately to load overrides from the graph data
if (typeof graph !== 'undefined' && graph.appearance && graph.appearance.animation) {
    const cfg = graph.appearance.animation;
    if (cfg.hue) Object.assign(PENDULUM.hue, cfg.hue);
    if (cfg.chroma) Object.assign(PENDULUM.chroma, cfg.chroma);
    if (cfg.lightness) Object.assign(PENDULUM.lightness, cfg.lightness);
    if (cfg.ripple) Object.assign(PENDULUM.ripple, cfg.ripple);
    console.log("Animation Config Loaded:", PENDULUM);
}

// Store original colors for dimming non-selected nodes
// NOTE: originalColorsForDim declared at top of file

// oklchToHex - MOVED TO modules/color-engine.js (use COLOR.get() instead)
// updatePendulums, getSelectionColor, getNodeSpatialPhase, animateSelectionColors - MOVED TO modules/selection.js
// startSelectionAnimation, stopSelectionAnimation - MOVED TO modules/selection.js (shims provide global names)
// dimColor - MOVED TO modules/color-helpers.js

function updateSelectionVisuals() {
    if (!Graph || !Graph.graphData) return;
    const nodes = Graph.graphData().nodes || [];
    const hasSelection = SELECTED_NODE_IDS.size > 0;

    nodes.forEach(node => {
        const isSelected = SELECTED_NODE_IDS.has(node.id);

        // Save original color/size for ALL nodes when selection starts
        if (hasSelection && !originalColorsForDim.has(node.id)) {
            originalColorsForDim.set(node.id, {
                color: node.color,
                val: node.val || 1
            });
        }

        // Also track selected nodes separately for size restore
        if (isSelected && !selectionOriginals.has(node.id)) {
            selectionOriginals.set(node.id, {
                color: node.color,
                val: node.val || 1
            });
        }

        // Apply styling based on selection state
        if (hasSelection) {
            if (isSelected) {
                // SELECTED: Make bigger, color will be animated
                const orig = selectionOriginals.get(node.id);
                node.val = (orig?.val || 1) * SELECTION_SIZE_MULT;
            } else {
                // NOT SELECTED: Dim by 33%
                const orig = originalColorsForDim.get(node.id);
                if (orig) {
                    node.color = dimColor(orig.color, 0.33);
                }
            }
        } else {
            // NO SELECTION: Restore all original colors and sizes
            if (originalColorsForDim.has(node.id)) {
                const orig = originalColorsForDim.get(node.id);
                node.color = orig.color;
                node.val = orig.val;
            }
            if (selectionOriginals.has(node.id)) {
                const orig = selectionOriginals.get(node.id);
                node.color = orig.color;
                node.val = orig.val;
                selectionOriginals.delete(node.id);
            }
        }

        // Also update overlays (halos)
        ensureNodeOverlays(node);
        updateOverlayScale(node);
        if (node.__selectionHalo) {
            node.__selectionHalo.visible = isSelected;
        }
        if (node.__groupHalo) {
            const group = getPrimaryGroupForNode(node.id);
            if (group) {
                node.__groupHalo.visible = group.visible !== false;
                node.__groupHalo.material.color.set(group.color || '#88d0ff');
                node.__groupHalo.material.opacity =
                    (group.id === ACTIVE_GROUP_ID) ? 0.7 : 0.45;
            } else {
                node.__groupHalo.visible = false;
            }
        }
    });

    // Clear dim cache when no selection
    if (!hasSelection) {
        originalColorsForDim.clear();
    }

    // Start/stop animation based on selection state
    if (hasSelection) {
        startSelectionAnimation();
    } else {
        stopSelectionAnimation();
    }

    // Force re-render with new colors
    Graph.nodeColor(n => toColorNumber(n.color, 0x888888));
}

function syncSelectionAfterGraphUpdate() {
    if (!Graph || !Graph.graphData) return;
    const visibleIds = new Set((Graph.graphData().nodes || []).map(n => n.id));
    const idsToRemove = [];
    Array.from(SELECTED_NODE_IDS).forEach(id => {
        if (!visibleIds.has(id)) {
            idsToRemove.push(id);
        }
    });
    if (idsToRemove.length > 0) {
        // Use SELECT.remove() for proper module integration
        // This triggers updateSelectionVisuals via the hook
        SELECT.remove(idsToRemove);
    } else {
        // No changes to selection, but still need to update visuals
        updateSelectionVisuals();
    }
    updateGroupButtonState();
}

function updateSelectionBox(rect) {
    if (!SELECTION_BOX) return;
    SELECTION_BOX.style.display = 'block';
    SELECTION_BOX.style.left = `${rect.left}px`;
    SELECTION_BOX.style.top = `${rect.top}px`;
    SELECTION_BOX.style.width = `${rect.width}px`;
    SELECTION_BOX.style.height = `${rect.height}px`;
}

// getBoxRect - MOVED TO modules/utils.js

function getNodeScreenPosition(node) {
    if (!Graph || !Graph.camera || !node) return null;
    if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return null;
    const camera = Graph.camera();
    const vector = new THREE.Vector3(node.x, node.y, node.z || 0);
    vector.project(camera);
    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
    const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
    return { x, y };
}

function selectNodesInBox(rect, additive = true) {
    if (!Graph || !Graph.graphData) return;
    const nodes = Graph.graphData().nodes || [];
    const selected = [];
    nodes.forEach(node => {
        const pos = getNodeScreenPosition(node);
        if (!pos) return;
        if (pos.x >= rect.left && pos.x <= rect.right &&
            pos.y >= rect.top && pos.y <= rect.bottom) {
            if (node.id) selected.push(node.id);
        }
    });
    if (selected.length) {
        setSelection(selected, additive);
    }
}

function setupSelectionInteractions() {
    const clearBtn = document.getElementById('selection-clear');
    if (clearBtn) {
        clearBtn.onclick = () => clearSelection();
    }

    const groupBtn = document.getElementById('btn-create-group');
    if (groupBtn) {
        groupBtn.onclick = () => createGroupFromSelection();
    }

    SELECTION_BOX = document.getElementById('selection-box');
    if (!Graph || !Graph.renderer || !SELECTION_BOX) return;

    const canvas = Graph.renderer().domElement;
    if (!canvas) return;

    const onPointerDown = (e) => {
        // Left-drag = marquee selection (space+drag reserved for pan)
        if (e.button !== 0) return;
        if (SPACE_PRESSED) return;
        if (e.target !== canvas) return;
        if (HOVERED_NODE) return;
        MARQUEE_ACTIVE = true;
        MARQUEE_ADDITIVE = !!e.shiftKey;
        MARQUEE_START = { x: e.clientX, y: e.clientY };
        updateSelectionBox(getBoxRect(MARQUEE_START, MARQUEE_START));
        if (Graph.controls()) {
            Graph.controls().enabled = false;
        }
        e.preventDefault();
    };

    const onPointerMove = (e) => {
        if (!MARQUEE_ACTIVE || !MARQUEE_START) return;
        updateSelectionBox(getBoxRect(MARQUEE_START, { x: e.clientX, y: e.clientY }));
    };

    const finishSelection = (e) => {
        if (!MARQUEE_ACTIVE || !MARQUEE_START) return;
        const rect = getBoxRect(MARQUEE_START, { x: e.clientX, y: e.clientY });
        SELECTION_BOX.style.display = 'none';
        const additive = MARQUEE_ADDITIVE;
        MARQUEE_ACTIVE = false;
        MARQUEE_START = null;
        MARQUEE_ADDITIVE = false;
        if (Graph.controls()) {
            Graph.controls().enabled = true;
        }
        const didDrag = rect.width > 4 && rect.height > 4;
        if (didDrag) {
            LAST_MARQUEE_END_TS = Date.now();
            selectNodesInBox(rect, additive);
        }
    };

    canvas.addEventListener('pointerdown', onPointerDown, { passive: false });
    canvas.addEventListener('pointermove', onPointerMove, { passive: true });
    canvas.addEventListener('pointerup', finishSelection, { passive: true });
    canvas.addEventListener('pointerleave', finishSelection, { passive: true });
}

function initSelectionState(data) {
    DATASET_KEY = buildDatasetKey(data);
    GROUPS_STORAGE_KEY = `collider_groups_${DATASET_KEY}`;
    loadGroups();
    renderGroupList();
    updateSelectionPanel();
    updateGroupButtonState();
}

function handleNodeHover(node, data) {
    const filePanel = document.getElementById('file-panel');
    HOVERED_NODE = node || null;

    // Always update hover panel (separate from file panel)
    updateHoverPanel(node);

    // Guard: file-panel may not exist in minimal template
    if (!filePanel) return;

    if (!VIS_FILTERS.metadata.showFilePanel) {
        filePanel.classList.remove('visible');
        return;
    }

    if (!node) {
        // Mouse left node - hide panel after delay
        setTimeout(() => {
            if (!fileMode) filePanel.classList.remove('visible');
        }, 300);
        return;
    }

    // Get file info from boundaries
    const boundaries = data.file_boundaries || [];
    const fileIdx = node.fileIdx;

    if (fileIdx < 0 || fileIdx >= boundaries.length) {
        return;
    }

    const fileInfo = boundaries[fileIdx];

    // Update panel content (with null checks for minimal template)
    const setEl = (id, val) => {
        const el = document.getElementById(id);
        if (el) el.textContent = val;
    };
    setEl('file-name', fileInfo.file_name || 'unknown');
    setEl('file-cohesion', `Cohesion: ${(fileInfo.cohesion * 100).toFixed(0)}%`);
    setEl('file-purpose', fileInfo.purpose || '--');
    setEl('file-atom-count', fileInfo.atom_count || 0);
    setEl('file-lines', fileInfo.line_range ? `${fileInfo.line_range[0]}-${fileInfo.line_range[1]}` : '--');
    setEl('file-classes', (fileInfo.classes || []).join(', ') || 'none');
    setEl('file-functions', 'Functions: ' + ((fileInfo.functions || []).slice(0, 8).join(', ') || 'none'));

    // Show code preview from node body
    const code = node.body || '// no source available';
    setEl('file-code', code);

    // Show panel and trigger smart placement
    filePanel.classList.add('visible');
    HudLayoutManager.reflow();
}

function handleNodeClick(node, event) {
    if (!node) return;
    const additive = event && event.shiftKey;
    if (additive) {
        toggleSelection(node);
        return;
    }
    if (node.id) {
        setSelection([node.id]);
    }
    if ((GRAPH_MODE === 'files' || GRAPH_MODE === 'hybrid') && node.isFileNode) {
        toggleFileExpand(node.fileIdx);
    }
}

function toggleFileExpand(fileIdx) {
    if (!Number.isFinite(fileIdx)) return;
    captureFileNodePositions();
    const fileInfo = DM ? DM.getFile(fileIdx) : {};  // ALL DATA FROM DM
    const fileLabel = fileInfo?.file_name || fileInfo?.file || `file-${fileIdx}`;
    if (EXPANDED_FILES.has(fileIdx)) {
        EXPANDED_FILES.delete(fileIdx);
        showToast(`Collapsed ${fileLabel}`);
    } else {
        EXPANDED_FILES.clear();
        EXPANDED_FILES.add(fileIdx);
        showToast(`Expanded ${fileLabel}`);
    }
    window.GRAPH_MODE = (EXPANDED_FILES.size > 0) ? 'hybrid' : 'files';
    refreshGraph();
}

// sampleFileNodes, buildHull2D, computeCentroid - MOVED TO modules/spatial.js
// quantile - MOVED TO modules/utils.js

function drawFileBoundaries(data) {
    // ALL DATA FROM DM - the rendering pipeline
    let drawn = 0;
    const boundaryConfig = data?.appearance?.boundary || {};
    const fillOpacity =
        (typeof APPEARANCE_STATE.boundaryFill === 'number')
            ? APPEARANCE_STATE.boundaryFill
            : (boundaryConfig.fill_opacity || 0.08);
    const wireOpacity =
        (typeof APPEARANCE_STATE.boundaryWire === 'number')
            ? APPEARANCE_STATE.boundaryWire
            : (boundaryConfig.wire_opacity || 0.3);
    const padding = boundaryConfig.padding || 1.2;
    const minExtent = boundaryConfig.min_extent || 6;
    const quantileRange = boundaryConfig.quantile || 0.9;
    const lowQ = Math.max(0, (1 - quantileRange) / 2);
    const highQ = Math.min(1, 1 - lowQ);
    const boundaryPhysics = data?.physics?.boundary || {};
    const hullType = String(boundaryPhysics.hullType || 'convex').toLowerCase();
    const fileBoundaries = DM ? DM.getFileBoundaries() : (data?.file_boundaries || []);
    const totalFiles = fileBoundaries.length;

    const graphNodes = DM ? DM.getVisibleNodes() : (Graph?.graphData()?.nodes || []);
    const scene = Graph.scene();

    // Clear existing boundary meshes
    fileBoundaryMeshes.forEach(mesh => scene.remove(mesh));
    fileBoundaryMeshes = [];

    if (!fileMode) return drawn;

    // Group nodes by file (only use nodes with stable positions)
    const fileGroups = {};
    const validNodes = graphNodes.filter(node => {
        if (!node) return false;
        if (!Number.isFinite(node.x) || !Number.isFinite(node.y)) return false;
        if (IS_3D && !Number.isFinite(node.z)) return false;
        return true;
    });

    if (!validNodes.length) return drawn;

    validNodes.forEach(node => {
        const idx = node.fileIdx;
        if (idx >= 0) {
            if (!fileGroups[idx]) fileGroups[idx] = [];
            fileGroups[idx].push(node);
        }
    });

    // Draw boundary for each file group
    Object.entries(fileGroups).forEach(([fileIdx, nodes]) => {
        const sampled = sampleFileNodes(nodes, 180);
        const xs = sampled.map(n => n.x || 0);
        const ys = sampled.map(n => n.y || 0);
        const zs = sampled.map(n => n.z || 0);

        const minX = quantile(xs, lowQ);
        const maxX = quantile(xs, highQ);
        const minY = quantile(ys, lowQ);
        const maxY = quantile(ys, highQ);
        const minZ = quantile(zs, lowQ);
        const maxZ = quantile(zs, highQ);

        const filtered = sampled.filter(n => {
            const x = n.x || 0;
            const y = n.y || 0;
            const z = n.z || 0;
            return x >= minX && x <= maxX && y >= minY && y <= maxY && z >= minZ && z <= maxZ;
        });
        const hullNodes = filtered.length >= 3 ? filtered : sampled;
        const positions = hullNodes.map(n => new THREE.Vector3(n.x || 0, n.y || 0, n.z || 0));
        const centroid = computeCentroid(positions);
        const zRange = maxZ - minZ;
        const extentX = Math.max(0.001, maxX - minX);
        const extentY = Math.max(0.001, maxY - minY);
        const extentZ = Math.max(0.001, maxZ - minZ);
        const scaleFixX = Math.max(1, minExtent / extentX);
        const scaleFixY = Math.max(1, minExtent / extentY);
        const scaleFixZ = IS_3D ? Math.max(1, minExtent / extentZ) : 1;
        const scaleX = padding * scaleFixX;
        const scaleY = padding * scaleFixY;
        const scaleZ = padding * scaleFixZ;
        const sizeX = extentX * scaleX;
        const sizeY = extentY * scaleY;
        const sizeZ = extentZ * scaleZ;

        const fileIndex = Number.parseInt(fileIdx, 10);
        const safeFileIdx = Number.isFinite(fileIndex) ? fileIndex : 0;
        const fileInfo = (data.file_boundaries || [])[safeFileIdx] || {};
        const fileLabel = fileInfo.file || fileInfo.file_name || fileIdx;
        const color = new THREE.Color(
            getFileColor(safeFileIdx, totalFiles, fileLabel)
        );

        let mesh = null;
        let wireMesh = null;

        if (nodes.length < 3) {
            const rawPositions = nodes.map(n => new THREE.Vector3(n.x || 0, n.y || 0, n.z || 0));
            const smallCentroid = computeCentroid(rawPositions);
            const maxRadius = rawPositions.reduce((acc, p) => {
                return Math.max(acc, p.distanceTo(smallCentroid));
            }, 0);
            const bubbleRadius = Math.max(minExtent * 0.5, maxRadius + minExtent * 0.35);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: fillOpacity,
                wireframe: false,
                side: THREE.DoubleSide
            });
            if (IS_3D) {
                const geometry = new THREE.SphereGeometry(bubbleRadius, 14, 10);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(smallCentroid);
                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const edges = new THREE.EdgesGeometry(geometry);
                wireMesh = new THREE.LineSegments(edges, wireMaterial);
                wireMesh.position.copy(mesh.position);
            } else {
                const geometry = new THREE.CircleGeometry(bubbleRadius, 32);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(smallCentroid.x, smallCentroid.y, smallCentroid.z);
                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const edges = new THREE.EdgesGeometry(geometry);
                wireMesh = new THREE.LineSegments(edges, wireMaterial);
                wireMesh.position.copy(mesh.position);
            }
        }

        if (!mesh && hullType === 'convex') {
            if (IS_3D && zRange > 0.001 && positions.length >= 4) {
                const ConvexCtor =
                    (typeof ConvexGeometry !== 'undefined')
                        ? ConvexGeometry
                        : (THREE.ConvexGeometry || null);
                const relPoints = positions.map(p => p.clone().sub(centroid));
                let boundaryGeometry = null;
                if (ConvexCtor) {
                    try {
                        boundaryGeometry = new ConvexCtor(relPoints);
                    } catch (err) {
                        boundaryGeometry = null;
                    }
                }
                if (boundaryGeometry) {
                    const material = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: fillOpacity,
                        wireframe: false,
                        side: THREE.DoubleSide
                    });
                    mesh = new THREE.Mesh(boundaryGeometry, material);
                    mesh.position.copy(centroid);
                    mesh.scale.set(scaleX, scaleY, scaleZ);

                    const wireMaterial = new THREE.LineBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: wireOpacity
                    });
                    const edges = new THREE.EdgesGeometry(boundaryGeometry);
                    wireMesh = new THREE.LineSegments(edges, wireMaterial);
                    wireMesh.position.copy(centroid);
                    wireMesh.scale.copy(mesh.scale);
                }
            }

            if (!mesh) {
                const hull2d = buildHull2D(positions.map(p => new THREE.Vector2(p.x, p.y)));
                if (!hull2d || hull2d.length < 3) return;
                const localHull = hull2d.map(p => new THREE.Vector2(p.x - centroid.x, p.y - centroid.y));
                const shape = new THREE.Shape(localHull);
                const boundaryGeometry = new THREE.ShapeGeometry(shape);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: fillOpacity,
                    wireframe: false,
                    side: THREE.DoubleSide
                });
                mesh = new THREE.Mesh(boundaryGeometry, material);
                mesh.position.set(centroid.x, centroid.y, centroid.z);
                mesh.scale.set(scaleX, scaleY, 1);

                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const wireGeometry = new THREE.BufferGeometry().setFromPoints(
                    localHull.map(p => new THREE.Vector3(p.x, p.y, 0))
                );
                wireMesh = new THREE.LineLoop(wireGeometry, wireMaterial);
                wireMesh.position.copy(mesh.position);
                wireMesh.scale.copy(mesh.scale);
            }
        } else if (!mesh && hullType === 'box') {
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: fillOpacity,
                wireframe: false,
                side: THREE.DoubleSide
            });
            if (IS_3D) {
                const geometry = new THREE.BoxGeometry(sizeX, sizeY, sizeZ);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(centroid);
                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const edges = new THREE.EdgesGeometry(geometry);
                wireMesh = new THREE.LineSegments(edges, wireMaterial);
                wireMesh.position.copy(mesh.position);
            } else {
                const geometry = new THREE.PlaneGeometry(sizeX, sizeY);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(centroid.x, centroid.y, centroid.z);
                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const edges = new THREE.EdgesGeometry(geometry);
                wireMesh = new THREE.LineSegments(edges, wireMaterial);
                wireMesh.position.copy(mesh.position);
            }
        } else if (!mesh) {
            const radius = 0.5 * Math.max(sizeX, sizeY, IS_3D ? sizeZ : 0);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: fillOpacity,
                wireframe: false,
                side: THREE.DoubleSide
            });
            if (IS_3D) {
                const geometry = new THREE.SphereGeometry(radius, 18, 14);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(centroid);
                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const edges = new THREE.EdgesGeometry(geometry);
                wireMesh = new THREE.LineSegments(edges, wireMaterial);
                wireMesh.position.copy(mesh.position);
            } else {
                const geometry = new THREE.CircleGeometry(radius, 40);
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(centroid.x, centroid.y, centroid.z);
                const wireMaterial = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: wireOpacity
                });
                const edges = new THREE.EdgesGeometry(geometry);
                wireMesh = new THREE.LineSegments(edges, wireMaterial);
                wireMesh.position.copy(mesh.position);
            }
        }

        if (!mesh) return;
        scene.add(mesh);
        fileBoundaryMeshes.push(mesh);
        drawn += 1;
        if (wireMesh) {
            scene.add(wireMesh);
            fileBoundaryMeshes.push(wireMesh);
        }
    });
    return drawn;
}

// ═══════════════════════════════════════════════════════════════════════
// FILE CONTAINMENT SYSTEM - Spherical fields with particle physics
// "Metaphysical force from another dimension" - holding particles together
// ═══════════════════════════════════════════════════════════════════════

const FILE_CONTAINMENT = {
    spheres: [],              // Three.js sphere meshes
    directoryTree: null,      // Parsed directory hierarchy
    particleActivity: {},    // FileIdx → activity level (0-1)
    boundariesPopped: false,  // Animation state
    popProgress: 0,           // 0 = contained, 1 = fully free
    slowMotionFactor: 0.15,   // Time multiplier for dreamy slow motion
    collisionEnabled: true,   // Enable soft collisions
    spatialGrid: null,        // For efficient collision detection
    gridCellSize: 20,         // Size of spatial hash cells
    animationFrame: null,
    isAnimating: false
};

// SPATIAL HASHING: buildSpatialGrid, getNeighborCells, applySoftCollisions - MOVED TO modules/spatial.js

// Build directory tree from file paths
function buildDirectoryTree(fileBoundaries) {
    const tree = { name: '/', path: '', depth: 0, children: {}, files: [], totalNodes: 0 };

    fileBoundaries.forEach((file, idx) => {
        const filePath = file.file || file.file_name || '';
        const parts = filePath.split('/').filter(p => p);
        let current = tree;

        parts.forEach((part, partIdx) => {
            const isFile = partIdx === parts.length - 1;
            if (isFile) {
                current.files.push({
                    name: part, path: filePath, fileIdx: idx,
                    nodeCount: (file.atom_ids || []).length, activity: 0
                });
            } else {
                if (!current.children[part]) {
                    current.children[part] = {
                        name: part, path: parts.slice(0, partIdx + 1).join('/'),
                        depth: partIdx + 1, children: {}, files: [], totalNodes: 0
                    };
                }
                current = current.children[part];
            }
        });
    });

    FILE_CONTAINMENT.directoryTree = tree;
    return tree;
}

// Compute activity levels from markov transitions
function computeFileActivity(data) {
    const markov = data.markov || {};
    const highEntropy = markov.high_entropy_nodes || [];
    const transitions = markov.transitions || {};
    const fileActivity = {};

    (data.file_boundaries || []).forEach((file, idx) => {
        const atomIds = file.atom_ids || [];
        let activity = 0;
        atomIds.forEach(atomId => {
            if (highEntropy.some(h => h.node === atomId)) activity += 0.3;
            const fanout = Object.keys(transitions[atomId] || {}).length;
            activity += Math.min(fanout / 10, 0.5);
        });
        fileActivity[idx] = Math.min(1, activity / Math.max(1, atomIds.length));
    });

    FILE_CONTAINMENT.particleActivity = fileActivity;
    return fileActivity;
}

// Draw containment spheres
// Draw containment hulls (Optimized for performance and aesthetics)
function drawContainmentSpheres(_data) {
    const scene = Graph.scene();
    if (!scene) return;
    const graphNodes = DM ? DM.getVisibleNodes() : (Graph?.graphData()?.nodes || []);

    // Clear existing
    FILE_CONTAINMENT.spheres.forEach(s => {
        if (s.mesh) scene.remove(s.mesh);
        if (s.wireframe) scene.remove(s.wireframe);
        if (s.glow) scene.remove(s.glow);
    });
    FILE_CONTAINMENT.spheres = [];

    // ONLY DRAW IF: 
    // 1. File Mode is ON
    // 2. We are NOT in Flow Mode (Flow is exclusive)
    // 3. Hulls button is active (explicit user choice)
    const hullsActive = document.getElementById('btn-file-hulls')?.classList.contains('active');

    if (!fileMode || flowMode || !hullsActive || FILE_CONTAINMENT.boundariesPopped) return;

    // Group nodes by file
    const fileGroups = {};
    graphNodes.filter(n => n && Number.isFinite(n.x)).forEach(node => {
        if (node.fileIdx >= 0) {
            if (!fileGroups[node.fileIdx]) fileGroups[node.fileIdx] = [];
            fileGroups[node.fileIdx].push(node);
        }
    });

    Object.entries(fileGroups).forEach(([fileIdx, nodes]) => {
        if (nodes.length < 3) return; // Cull singletons/pairs

        // Calculate Bounding Box
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        let minZ = Infinity, maxZ = -Infinity;

        nodes.forEach(n => {
            minX = Math.min(minX, n.x); maxX = Math.max(maxX, n.x);
            minY = Math.min(minY, n.y); maxY = Math.max(maxY, n.y);
            minZ = Math.min(minZ, n.z || 0); maxZ = Math.max(maxZ, n.z || 0);
        });

        // Add padding
        const pad = 10;
        const width = (maxX - minX) + pad * 2;
        const height = (maxY - minY) + pad * 2;
        const depth = (maxZ - minZ) + pad * 2;

        if (width < 5 || height < 5 || depth < 5) return;

        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY) / 2;
        const cz = (minZ + maxZ) / 2;

        const geometry = new THREE.BoxGeometry(width, height, depth);
        const color = new THREE.Color(nodes[0].color || '#4488ff');

        const material = new THREE.MeshLambertMaterial({
            color: color,
            transparent: true,
            opacity: 0.15,
            depthWrite: false,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(cx, cy, cz);
        scene.add(mesh);

        // Wireframe
        const wireGeo = new THREE.EdgesGeometry(geometry);
        const wireMat = new THREE.LineBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending
        });
        const wireframe = new THREE.LineSegments(wireGeo, wireMat);
        wireframe.position.set(cx, cy, cz);
        scene.add(wireframe);

        FILE_CONTAINMENT.spheres.push({
            mesh, wireframe,
            fileIdx: parseInt(fileIdx),
            velocity: new THREE.Vector3(0, 0, 0),
            // FIX: Add activity and nodes for animation (was missing, caused crashes)
            activity: FILE_CONTAINMENT.particleActivity[fileIdx] || 0,
            nodes: nodes.map(n => n.id)
        });
    });
}
// ═══════════════════════════════════════════════════════════════════════
// SLOW MOTION PARTICLE ANIMATION - Dreamy physics with collisions
// ═══════════════════════════════════════════════════════════════════════

function startContainmentAnimation() {
    if (FILE_CONTAINMENT.isAnimating) return;
    FILE_CONTAINMENT.isAnimating = true;

    function animate() {
        if (!FILE_CONTAINMENT.isAnimating) return;

        const time = Date.now() * 0.001 * FILE_CONTAINMENT.slowMotionFactor;
        const graphNodes = Graph.graphData().nodes;

        if (FILE_CONTAINMENT.boundariesPopped) {
            // FREE PARTICLE MODE - Brownian motion with collisions
            applySoftCollisions(graphNodes, FILE_CONTAINMENT.gridCellSize, 0.4);

            graphNodes.forEach(node => {
                if (!node || !node.__physics) return;
                const p = node.__physics;

                // Perlin-like wandering
                const wander = 0.08;
                p.vx += (Math.sin(time * 0.7 + (node.__wanderPhase || 0)) - 0.5) * wander;
                p.vy += (Math.cos(time * 0.5 + (node.__wanderPhase || 0) * 1.3) - 0.5) * wander;
                if (IS_3D) p.vz += (Math.sin(time * 0.6 + (node.__wanderPhase || 0) * 0.7) - 0.5) * wander;

                // Damping
                p.vx *= 0.985;
                p.vy *= 0.985;
                p.vz *= 0.985;

                // Apply velocity
                node.x += p.vx;
                node.y += p.vy;
                if (IS_3D) node.z = (node.z || 0) + p.vz;
            });

        } else {
            // CONTAINED MODE - Activity-based oscillation inside spheres
            FILE_CONTAINMENT.spheres.forEach(sphere => {
                const activity = sphere.activity;

                // Pulse sphere opacity
                const pulse = Math.sin(time * 2 + sphere.fileIdx) * 0.5 + 0.5;
                if (sphere.mesh?.material) {
                    sphere.mesh.material.opacity = 0.04 + activity * 0.12 * pulse;
                }
                if (sphere.wireframe?.material) {
                    sphere.wireframe.material.opacity = 0.08 + activity * 0.2 * pulse;
                }

                if (activity < 0.05) return;

                // Perturb particles inside based on activity
                sphere.nodes.forEach(nodeId => {
                    const node = graphNodes.find(n => n.id === nodeId);
                    if (!node || !Number.isFinite(node.x)) return;

                    if (!node.__activityPhase) {
                        node.__activityPhase = {
                            x: Math.random() * Math.PI * 2,
                            y: Math.random() * Math.PI * 2,
                            z: Math.random() * Math.PI * 2
                        };
                    }

                    const amp = activity * 0.4;
                    const freq = 0.5 + activity * 0.5;
                    const phase = node.__activityPhase;

                    node.__renderOffsetX = Math.sin(time * freq + phase.x) * amp;
                    node.__renderOffsetY = Math.sin(time * freq * 1.2 + phase.y) * amp;
                    if (IS_3D) node.__renderOffsetZ = Math.sin(time * freq * 0.9 + phase.z) * amp;
                });
            });
        }

        if (Graph) Graph.refresh();
        FILE_CONTAINMENT.animationFrame = requestAnimationFrame(animate);
    }

    animate();
}

function stopContainmentAnimation() {
    FILE_CONTAINMENT.isAnimating = false;
    if (FILE_CONTAINMENT.animationFrame) {
        cancelAnimationFrame(FILE_CONTAINMENT.animationFrame);
    }
}

// ═══════════════════════════════════════════════════════════════════════
// POP THE BOUNDARIES - Release particles into free Brownian motion
// ═══════════════════════════════════════════════════════════════════════

function popBoundaries(duration = 3000) {
    if (FILE_CONTAINMENT.boundariesPopped) {
        restoreBoundaries(duration);
        return;
    }

    console.log('[Containment] Popping boundaries...');
    FILE_CONTAINMENT.boundariesPopped = true;
    const startTime = Date.now();
    const scene = Graph.scene();
    const graphNodes = Graph.graphData().nodes;

    // Initialize physics for each node
    graphNodes.forEach(node => {
        if (!node || !Number.isFinite(node.x)) return;
        node.__physics = {
            vx: (Math.random() - 0.5) * 1.5,
            vy: (Math.random() - 0.5) * 1.5,
            vz: IS_3D ? (Math.random() - 0.5) * 1.5 : 0
        };
        node.__wanderPhase = Math.random() * Math.PI * 2;
    });

    function animatePop() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(1, elapsed / duration);
        FILE_CONTAINMENT.popProgress = progress;
        const eased = 1 - Math.pow(1 - progress, 3);

        // Fade out spheres
        FILE_CONTAINMENT.spheres.forEach(s => {
            if (s.mesh?.material) s.mesh.material.opacity = (1 - eased) * 0.1;
            if (s.wireframe?.material) s.wireframe.material.opacity = (1 - eased) * 0.25;
            if (s.glow?.material) s.glow.material.opacity = (1 - eased) * 0.08;
        });

        if (progress < 1) {
            requestAnimationFrame(animatePop);
        } else {
            // Remove spheres
            FILE_CONTAINMENT.spheres.forEach(s => {
                if (s.mesh) scene.remove(s.mesh);
                if (s.wireframe) scene.remove(s.wireframe);
                if (s.glow) scene.remove(s.glow);
            });
            FILE_CONTAINMENT.spheres = [];
            console.log('[Containment] Particles now FREE - Brownian motion with collisions');
        }

        if (Graph) Graph.refresh();
    }

    animatePop();
    startContainmentAnimation();
}

function restoreBoundaries(duration = 2000) {
    if (!FILE_CONTAINMENT.boundariesPopped) return;

    console.log('[Containment] Restoring boundaries...');
    const startTime = Date.now();
    const graphNodes = Graph.graphData().nodes;

    graphNodes.forEach(node => {
        if (!node || !Number.isFinite(node.x)) return;
        node.__freePos = { x: node.x, y: node.y, z: node.z || 0 };
    });

    function animateRestore() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(1, elapsed / duration);
        FILE_CONTAINMENT.popProgress = 1 - progress;
        const eased = Math.pow(progress, 2);

        graphNodes.forEach(node => {
            if (!node || !node.__freePos || !node.__originalPos) return;
            node.x = node.__freePos.x + (node.__originalPos.x - node.__freePos.x) * eased;
            node.y = node.__freePos.y + (node.__originalPos.y - node.__freePos.y) * eased;
            if (IS_3D) node.z = node.__freePos.z + ((node.__originalPos.z || 0) - node.__freePos.z) * eased;
        });

        if (progress < 1) {
            requestAnimationFrame(animateRestore);
        } else {
            FILE_CONTAINMENT.boundariesPopped = false;
            if (DM) drawContainmentSpheres(null);  // Uses DM internally
            console.log('[Containment] Boundaries restored');
        }

        if (Graph) Graph.refresh();
    }

    animateRestore();
}

// Expose to global for button binding
window.popBoundaries = popBoundaries;
window.restoreBoundaries = restoreBoundaries;
window.FILE_CONTAINMENT = FILE_CONTAINMENT;

// ====================================================================
// FILE MODE HANDLERS
// ====================================================================

// setFileModeState - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setEnabled)

const btnFiles = document.getElementById('btn-files');
if (btnFiles) btnFiles.onclick = () => setFileModeState(!fileMode);

// COLOR mode - atoms colored by file
const btnFileColor = document.getElementById('btn-file-color');
if (btnFileColor) btnFileColor.onclick = () => setFileVizMode('color');

// HULLS mode - draw boundary spheres
const btnFileHulls = document.getElementById('btn-file-hulls');
if (btnFileHulls) btnFileHulls.onclick = () => setFileVizMode('hulls');

// CLUSTER mode - force clustering by file
const btnFileCluster = document.getElementById('btn-file-cluster');
if (btnFileCluster) btnFileCluster.onclick = () => setFileVizMode('cluster');

// MAP mode - show file nodes
const btnFileMap = document.getElementById('btn-file-map');
if (btnFileMap) btnFileMap.onclick = () => setFileVizMode('map');

// SPHERES mode - show containment spheres (button may be hidden)
const spheresBtn = document.getElementById('btn-file-spheres');
if (spheresBtn) spheresBtn.onclick = () => setFileVizMode('spheres');

// POP button - toggle boundary pop/restore (button may be hidden)
const popBtn = document.getElementById('btn-file-pop');
if (popBtn) {
    popBtn.onclick = () => {
        if (!FILE_CONTAINMENT.boundariesPopped) {
            popBoundaries(3000);
            popBtn.classList.add('active');
            popBtn.textContent = 'RESTORE';
            showToast('Boundaries popped! Particles in slow-motion chaos...');
        } else {
            restoreBoundaries(2000);
            popBtn.classList.remove('active');
            popBtn.textContent = 'POP!';
            showToast('Boundaries restored. Order from chaos.');
        }
    };
}

// Expand mode toggles (only relevant in MAP mode)
const btnExpandInline = document.getElementById('btn-expand-inline');
if (btnExpandInline) {
    btnExpandInline.onclick = () => {
        FILE_EXPAND_MODE = 'inline';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}

const btnExpandDetach = document.getElementById('btn-expand-detach');
if (btnExpandDetach) {
    btnExpandDetach.onclick = () => {
        FILE_EXPAND_MODE = 'detach';
        updateExpandButtons();
        if (GRAPH_MODE === 'hybrid') {
            refreshGraph();
        }
    };
}

function updateExpandButtons() {
    const inlineBtn = document.getElementById('btn-expand-inline');
    const detachBtn = document.getElementById('btn-expand-detach');
    if (inlineBtn) inlineBtn.classList.toggle('active', FILE_EXPAND_MODE === 'inline');
    if (detachBtn) detachBtn.classList.toggle('active', FILE_EXPAND_MODE === 'detach');
}

// setFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.setMode)

// applyFileVizMode - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.apply)

// scheduleHullRedraw - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.scheduleHullRedraw)

// applyFileColors - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.applyColors)

// clearFileBoundaries - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearBoundaries)

// Moved here to avoid temporal dead zone issue
let fileCohesionActive = false;

// clearAllFileModes - MOVED TO modules/file-viz.js (shim delegates to FILE_VIZ.clearAllModes)

// applyClusterForce, applyFileCohesion, clearFileCohesion - MOVED TO modules/file-viz.js

// ════════════════════════════════════════════════════════════════════════
// SURFACE PARITY HANDLERS - Architectural Enforcements
// ════════════════════════════════════════════════════════════════════════

// Panel Handlers - use togglePanel('view') etc. or PANELS.toggle('view')
// togglePanelView/Filter/Style/Settings - simplified via modules/panels.js


// Action Handlers
function handleCmdFiles() {
    const btn = document.getElementById('cmd-files');
    const isActive = btn ? btn.classList.contains('active') : false;
    setFileModeState(!isActive);
}
function handleCmdFlow() { toggleFlowMode(); }
function handleCmd3d() { toggleDimensions(); }

// PanelManager - provided by panels.js module (window.PANEL_DRAG, window.PanelManager)

// =================================================================
// THEME SWITCHING - MOVED TO modules/theme.js
// setTheme, getTheme, getAvailableThemes, cycleTheme, initTheme

// Initialize theme on DOM ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        // Small delay to ensure CSS vars are loaded
        setTimeout(initTheme, 50);
    });
} else {
    setTimeout(initTheme, 50);
}

// Expose theme functions globally
window.setTheme = setTheme;
window.getTheme = getTheme;
window.getAvailableThemes = getAvailableThemes;
window.cycleTheme = cycleTheme;
window.THEME_CONFIG = THEME_CONFIG;

// Expose filtering/graph globals for module access
window.VIS_FILTERS = VIS_FILTERS;
window.refreshGraph = refreshGraph;

    </script>
</body>

</html>