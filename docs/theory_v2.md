---
# STANDARD MODEL OF CODE - UNIFIED THEORY
# A pedagogical journey from humility to understanding

schema_version: "3.0.0"
document_name: "Standard Model of Code"
last_verified: "2025-12-26"

# This document follows a narrative arc:
# 1. We don't know -> 2. The problem -> 3. Tools for thinking -> 4. The objects -> 5. The validation -> 6. What remains unknown

structure:
  - "PART I: THE HUMBLE BEGINNING"
  - "PART II: THE PROBLEM OF SOFTWARE"
  - "PART III: THE POWER OF ANALOGIES"
  - "PART IV: THE LAYERS OF ABSTRACTION"
  - "PART V: THE THREE BODIES, ONE ENTITY"
  - "PART VI: THE PERIODIC TABLE OF CODE"
  - "PART VII: THE OCTAHEDRAL ATOM"
  - "PART VIII: THE RELATIONSHIPS"
  - "PART IX: THE VALIDATION"
  - "PART X: THE OPEN FRONTIER"

reference_counts:
  planes: 3              # Physical, Virtual, Semantic
  levels: 16             # L-3 to L12
  lenses: 8              # Identity through Epistemology
  dimensions: 8          # WHAT, LAYER, ROLE, BOUNDARY, STATE, EFFECT, LIFECYCLE, TRUST
  phases: 4              # DATA, LOGIC, ORGANIZATION, EXECUTION
  families: 22           # 22 atom families across 4 phases
  atoms: 200             # Current working set
  roles: 33              # Semantic purposes
  edge_families: 5       # Structural, Dependency, Inheritance, Semantic, Temporal
---

# STANDARD MODEL OF CODE
## A Map, Not the Territory

---

<!-- @SECTION: humble_beginning -->
<!-- @TOPIC: epistemic_stance -->
<!-- @ORDER: 1.0 -->
<!-- @DEPENDS_ON: none -->
<!-- @PROVIDES: epistemic_humility, map_not_territory -->
<!-- @VERSION: 3.0.0 -->
<!-- @STATUS: stable -->

# PART I: THE HUMBLE BEGINNING

> **"We know that we don't know."**

This is the first truth of this work. Everything that follows is a **map**, not the territory. We are cartographers, not prophets. The territory exists independent of our drawings. Our purpose is to create a usable legend that improves navigation, prediction, and reasoning about software.

---

<!-- @SECTION: what_this_is_not -->
<!-- @TOPIC: negative_definition -->
<!-- @ORDER: 1.1 -->
<!-- @DEPENDS_ON: humble_beginning -->
<!-- @PROVIDES: boundaries -->

## 1.1 What This Document Is NOT

- NOT a "theory of everything" for code
- NOT a closed or complete model
- NOT proof that these categories are all that exist
- NOT a claim of ultimate truth

<!-- @END_SECTION: what_this_is_not -->

---

<!-- @SECTION: what_this_is -->
<!-- @TOPIC: positive_definition -->
<!-- @ORDER: 1.2 -->
<!-- @DEPENDS_ON: what_this_is_not -->
<!-- @PROVIDES: purpose, versioned_model -->

## 1.2 What This Document IS

- A working map of software engineering territory
- A versioned, testable, revisable model (v3.0.0)
- An open framework designed to evolve with evidence
- A tool for understanding, not a dogma

<!-- @END_SECTION: what_this_is -->

---

<!-- @SECTION: operating_principles -->
<!-- @TOPIC: principles -->
<!-- @ORDER: 1.3 -->
<!-- @DEPENDS_ON: what_this_is -->
<!-- @PROVIDES: open_world, unknown_first_class, provisional_certainty, humble_science -->

## 1.3 Operating Principles

| Principle | Meaning |
|-----------|---------|
| **Open World** | All inventories are working sets—versioned, testable. They are abstractions, not reality. |
| **Unknown is First-Class** | Anything that doesn't fit becomes evidence that the map must evolve. |
| **Provisional Certainty** | We crystallize knowledge because usefulness requires it, but we never claim completeness. |
| **Humble Science** | Every "postulate" is a hypothesis with validation obligations, not a proven theorem. |

<!-- @END_SECTION: operating_principles -->
<!-- @END_SECTION: humble_beginning -->

---

<!-- @SECTION: problem_of_software -->
<!-- @TOPIC: motivation -->
<!-- @ORDER: 2.0 -->
<!-- @DEPENDS_ON: operating_principles -->
<!-- @PROVIDES: problem_statement, fragmented_knowledge -->

# PART II: THE PROBLEM OF SOFTWARE

Software engineering lacks a unified language. We speak in fragments:
- Halstead measured text complexity
- Halliday analyzed linguistic structure
- Alexander described architectural patterns
- Category Theory formalized mathematical structures

These are not competing theories. They are **different lenses on the same phenomenon**. The Standard Model attempts to connect them.

---

<!-- @SECTION: the_question -->
<!-- @ORDER: 2.1 -->
<!-- @DEPENDS_ON: problem_of_software -->
<!-- @PROVIDES: central_question -->

## 2.1 The Question We're Trying to Answer

> *"What IS a piece of code, really?"*

Not philosophically. Practically. What categories describe it? What relationships define it? What patterns repeat across all software?

<!-- @END_SECTION: the_question -->

---

<!-- @SECTION: why_no_one_before -->
<!-- @ORDER: 2.2 -->
<!-- @DEPENDS_ON: the_question -->
<!-- @PROVIDES: three_planes_intro -->

## 2.2 Why No One Has Done This Before

Because software is simultaneously:
- **Physical** (bytes on disk)
- **Virtual** (symbols in structure)
- **Semantic** (meaning in context)

Most approaches focus on one plane. We attempt to map all three.

<!-- @END_SECTION: why_no_one_before -->
<!-- @END_SECTION: problem_of_software -->

---

<!-- @SECTION: power_of_analogies -->
<!-- @TOPIC: methodology -->
<!-- @ORDER: 3.0 -->
<!-- @DEPENDS_ON: why_no_one_before -->
<!-- @PROVIDES: universal_analogy, tudo_e_uma_analogia -->

# PART III: THE POWER OF ANALOGIES

> **"Tudo é uma analogia pra tudo."**
> *(Everything is an analogy for everything.)*

This is the methodological foundation. Cross-domain mapping works because **all domains share structural patterns**.

---

<!-- @SECTION: analogies_we_use -->
<!-- @ORDER: 3.1 -->
<!-- @DEPENDS_ON: power_of_analogies -->
<!-- @PROVIDES: analogy_table -->

## 3.1 The Analogies We Use

| Source Domain | Target Domain | What It Reveals |
|---------------|---------------|-----------------|
| Particle Physics | Code Classification | Standard Model of 200+ atoms |
| Biological Taxonomy | Software Categories | Phyla, families, species |
| Map/Territory | Abstraction/Implementation | We draw maps, not realities |
| Holons | Software Modules | Parts that are also wholes |
| Chemistry | Code Structure | Periodic table organization |
| DNA | Code Patterns | ~98% "junk" may have hidden function |

---

<!-- @SECTION: why_analogies_work -->
<!-- @ORDER: 3.2 -->
<!-- @DEPENDS_ON: analogies_we_use -->
<!-- @PROVIDES: isomorphism, computation_universal -->

## 3.2 Why Analogies Work

The universe computes. All computation is isomorphic. Therefore, patterns discovered in one domain illuminate patterns in others. We are not "borrowing" metaphors—we are recognizing structural similarities.

<!-- @END_SECTION: why_analogies_work -->
<!-- @END_SECTION: analogies_we_use -->
<!-- @END_SECTION: power_of_analogies -->

---

<!-- @SECTION: layers_of_abstraction -->
<!-- @TOPIC: hierarchy -->
<!-- @ORDER: 4.0 -->
<!-- @DEPENDS_ON: why_analogies_work -->
<!-- @PROVIDES: layer_concept, abstraction_ladder -->

# PART IV: THE LAYERS OF ABSTRACTION

Understanding software requires understanding **layers**. Concepts build on concepts. Nothing exists in isolation.

---

<!-- @SECTION: inheritance_chain -->
<!-- @ORDER: 4.1 -->
<!-- @DEPENDS_ON: layers_of_abstraction -->
<!-- @PROVIDES: intellectual_lineage -->

## 4.1 The Inheritance Chain of Ideas

This theory inherits from:

```
Epistemology (Popper, Kuhn)
    └── Philosophy of Science
         └── Systems Theory (Bertalanffy, Koestler)
              └── Linguistics (Halliday, Chomsky)
                   └── Computer Science (Dijkstra, Parnas)
                        └── Software Engineering (Alexander, Fowler)
                             └── This Map
```

We stand on shoulders. Every concept has ancestors.

<!-- @END_SECTION: inheritance_chain -->

---

<!-- @SECTION: sixteen_levels -->
<!-- @ORDER: 4.2 -->
<!-- @DEPENDS_ON: inheritance_chain -->
<!-- @PROVIDES: L-3_to_L12, abstraction_scale, token_as_zero -->

## 4.2 The 16 Levels of Abstraction

The scale runs from L-3 (Bit/Qubit) to L12 (Universe):

```
╔═════════════════════════════════════════════════════════════════════════════╗
║  #   LEVEL           DEFINITION                                             ║
╠═════════════════════════════════════════════════════════════════════════════╣
║                    ════════ COSMOLOGICAL ════════                           ║
║ L12  UNIVERSE       All code everywhere                                     ║
║ L11  DOMAIN         Industry vertical                                       ║
║ L10  ORGANIZATION   Company codebase                                        ║
║ L9   PLATFORM       Infrastructure                                          ║
║ L8   ECOSYSTEM      Connected systems                                       ║
╠═════════════════════════════════════════════════════════════════════════════╣
║                    ════════ SYSTEMIC ════════                               ║
║ L7   SYSTEM         Deployable codebase                                     ║
║ L6   PACKAGE        Module/folder                                           ║
║ L5   FILE           Source file                                             ║
║ L4   CONTAINER      Class/struct                                            ║
╠═════════════════════════════════════════════════════════════════════════════╣
║                    ════════ SEMANTIC ════════                               ║
║ L3   NODE ★         Function/method (THE ATOM)                              ║
║ L2   BLOCK          Control structure                                       ║
║ L1   STATEMENT      Instruction                                             ║
╠═════════════════════════════════════════════════════════════════════════════╣
║                    ════════ SYNTACTIC ════════                              ║
║ L0   TOKEN          Lexical unit                                            ║
╠═════════════════════════════════════════════════════════════════════════════╣
║                    ════════ PHYSICAL ════════                               ║
║ L-1  CHARACTER      Alphanumeric symbol                                     ║
║ L-2  BYTE           8-bit unit                                              ║
║ L-3  BIT/QUBIT      Classical or quantum bit (FOUNDATION)                   ║
╚═════════════════════════════════════════════════════════════════════════════╝
```

**L3 (Node)** is our fundamental unit of semantic analysis.
**L-3 (Bit/Qubit)** is the physical foundation.

<!-- @END_SECTION: sixteen_levels -->
<!-- @END_SECTION: layers_of_abstraction -->

---

<!-- @SECTION: three_bodies -->
<!-- @TOPIC: planes_of_existence -->
<!-- @ORDER: 5.0 -->
<!-- @DEPENDS_ON: sixteen_levels -->
<!-- @PROVIDES: three_planes, physical_virtual_semantic -->

# PART V: THE THREE BODIES, ONE ENTITY

Every piece of code exists simultaneously in **three planes**.

---

<!-- @SECTION: three_planes -->
<!-- @ORDER: 5.1 -->
<!-- @DEPENDS_ON: three_bodies -->
<!-- @PROVIDES: plane_definitions -->

## 5.1 The Three Planes

| Plane | Substance | Question | Example |
|-------|-----------|----------|---------|
| **PHYSICAL** | Matter, Energy | Where is it stored? | Bytes on disk |
| **VIRTUAL** | Symbols, Structure | What is its form? | AST node |
| **SEMANTIC** | Meaning, Intent | What does it mean? | Purpose, role |

<!-- @END_SECTION: three_planes -->

---

<!-- @SECTION: flow_between_planes -->
<!-- @ORDER: 5.2 -->
<!-- @DEPENDS_ON: three_planes -->
<!-- @PROVIDES: encoding, interpretation -->

## 5.2 The Flow Between Planes

```
P1 PHYSICAL  ──encoding──▶  P2 VIRTUAL  ──interpretation──▶  P3 SEMANTIC
   (bytes)                    (symbols)                        (meaning)
```

We READ from P2 (Virtual) and PRODUCE P3 (Semantic).

<!-- @END_SECTION: flow_between_planes -->

---

<!-- @SECTION: converging_to_entity -->
<!-- @ORDER: 5.3 -->
<!-- @DEPENDS_ON: flow_between_planes -->
<!-- @PROVIDES: node_as_fundamental, node_L3 -->

## 5.3 Converging to a Single Entity

Despite three planes, we classify single entities: **Nodes**.

A Node (L3) is:
- A function, method, or procedure
- The smallest unit with meaning and behavior
- The "atom" of semantic analysis

<!-- @END_SECTION: converging_to_entity -->
<!-- @END_SECTION: three_bodies -->

---

<!-- @SECTION: periodic_table -->
<!-- @TOPIC: atom_organization -->
<!-- @ORDER: 6.0 -->
<!-- @DEPENDS_ON: converging_to_entity -->
<!-- @PROVIDES: 200_atoms, 4_phases, 22_families -->

# PART VI: THE PERIODIC TABLE OF CODE

Just as chemistry has 118 elements organized in a periodic table, code has **200+ atoms** organized in **4 phases and 22 families**.

---

<!-- @SECTION: the_200_atoms -->
<!-- @ORDER: 6.1 -->
<!-- @DEPENDS_ON: periodic_table -->
<!-- @PROVIDES: atom_inventory, phases_families -->

## 6.1 The 200 Atoms

These are the building blocks of all code:

| Phase | Families | Atoms | Description |
|-------|----------|-------|-------------|
| **DATA** | 5 | 28 | The matter of software |
| **LOGIC** | 6 | 58 | The behavior of software |
| **ORGANIZATION** | 5 | 52 | The structure of software |
| **EXECUTION** | 6 | 62 | The runtime of software |
| **TOTAL** | 22 | 200 | Current working set |

<!-- @END_SECTION: the_200_atoms -->

---

<!-- @SECTION: why_organization_works -->
<!-- @ORDER: 6.2 -->
<!-- @DEPENDS_ON: the_200_atoms -->
<!-- @PROVIDES: coverage_validation -->

## 6.2 Why This Organization Works

Like the periodic table:
- Elements (atoms) have intrinsic properties
- Families share characteristics
- Position predicts behavior
- Coverage is empirically validated (~98% across 5 languages)

<!-- @END_SECTION: why_organization_works -->

---

<!-- @SECTION: the_33_roles -->
<!-- @ORDER: 6.3 -->
<!-- @DEPENDS_ON: why_organization_works -->
<!-- @PROVIDES: role_taxonomy, 33_roles -->

## 6.3 The 33 Roles

Atoms have **type** (what they ARE). Roles describe **purpose** (what they DO).

| Category | Roles |
|----------|-------|
| Query (Read) | Query, Finder, Loader, Getter |
| Command (Write) | Command, Creator, Mutator, Destroyer |
| Factory (Create) | Factory, Builder |
| Storage (Persist) | Repository, Store, Cache |
| Orchestration | Service, Controller, Manager |
| Validation | Validator, Guard, Asserter |
| Transform | Transformer, Mapper, Serializer |
| Event | Handler, Listener, Subscriber |
| Utility | Utility, Formatter, Helper |
| Internal | Internal, Lifecycle |
| Unknown | Unknown (unclassified) |

<!-- @END_SECTION: the_33_roles -->
<!-- @END_SECTION: periodic_table -->

---

<!-- @SECTION: octahedral_atom -->
<!-- @TOPIC: geometric_model -->
<!-- @ORDER: 7.0 -->
<!-- @DEPENDS_ON: the_33_roles -->
<!-- @PROVIDES: octahedron_shape, 8_faces -->

# PART VII: THE OCTAHEDRAL ATOM

Each atom is geometrically represented as an **octahedron** with 8 triangular faces—one for each dimension.

---

<!-- @SECTION: why_octahedron -->
<!-- @ORDER: 7.1 -->
<!-- @DEPENDS_ON: octahedral_atom -->
<!-- @PROVIDES: geometry_justification -->

## 7.1 Why Octahedron?

- Exactly 8 faces (perfect for 8 dimensions)
- Dual of the cube (mathematical elegance)
- Symmetric (all faces are equilateral triangles)
- No privileged face (all dimensions equally accessible)

<!-- @END_SECTION: why_octahedron -->

---

<!-- @SECTION: eight_dimensions -->
<!-- @ORDER: 7.2 -->
<!-- @DEPENDS_ON: why_octahedron -->
<!-- @PROVIDES: D1_to_D8, dimension_definitions -->

## 7.2 The 8 Dimensions (Faces)

| Face | Dimension | Question | Values |
|------|-----------|----------|--------|
| 1 | **WHAT** | What is this? | 200 atom types |
| 2 | **LAYER** | Where in architecture? | Interface/App/Core/Infra/Test |
| 3 | **ROLE** | What's its purpose? | 33 roles |
| 4 | **BOUNDARY** | Crosses boundaries? | Internal/Input/I-O/Output |
| 5 | **STATE** | Maintains state? | Stateful/Stateless |
| 6 | **EFFECT** | Side effects? | Pure/Read/Write/ReadModify |
| 7 | **LIFECYCLE** | In what phase? | Create/Use/Destroy |
| 8 | **TRUST** | Confidence level? | 0-100% |

<!-- @END_SECTION: eight_dimensions -->

---

<!-- @SECTION: dual_dimensions -->
<!-- @ORDER: 7.3 -->
<!-- @DEPENDS_ON: eight_dimensions -->
<!-- @PROVIDES: dualities, opposite_faces -->

## 7.3 Dual Dimensions (Opposite Faces)

| Face 1 | Face 2 | Duality |
|--------|--------|---------|
| STATE | EFFECT | Internal ↔ External |
| WHAT | ROLE | Structure ↔ Purpose |
| LAYER | BOUNDARY | Position ↔ Transition |
| LIFECYCLE | TRUST | Time ↔ Confidence |

<!-- @END_SECTION: dual_dimensions -->

---

<!-- @SECTION: dual_nature -->
<!-- @ORDER: 7.4 -->
<!-- @DEPENDS_ON: dual_dimensions -->
<!-- @PROVIDES: epistemic_ontological, lens_dimension_duality -->

## 7.4 The Dual Nature of Atoms

Every atom has **two natures**, like wave-particle duality in physics:

| Nature | What It Is | The Question |
|--------|------------|--------------|
| **EPISTEMIC** (Lenses) | How we ASK about the atom | 8 ways to interrogate |
| **ONTOLOGICAL** (Dimensions) | Where the atom IS | 8 coordinates in classification space |

```
         LENSES (8)                    DIMENSIONS (8)
         ┌─────────┐                   ┌─────────┐
         │ How do  │                   │ Where   │
         │ I ASK?  │                   │ IS it?  │
         └────┬────┘                   └────┬────┘
              │                             │
              ▼                             ▼
         ┌─────────────────────────────────────┐
         │            ATOM                     │
         │       (dual nature)                 │
         └─────────────────────────────────────┘
```

<!-- @SECTION: eight_lenses -->
<!-- @ORDER: 7.4.1 -->
<!-- @DEPENDS_ON: dual_nature -->
<!-- @PROVIDES: R1_to_R8, lens_definitions -->

**The 8 Lenses (Epistemic Nature):**

| # | Lens | Question | Reveals | Example Answer |
|---|------|----------|---------|----------------|
| R1 | **IDENTITY** | What is it called? | Name, path, signature | `getUserById` at `core/user.py:42` |
| R2 | **ONTOLOGY** | What exists here? | Entity type, properties | "A function with 3 params" |
| R3 | **CLASSIFICATION** | What kind is it? | Role, category, atom | "This is a Query" |
| R4 | **COMPOSITION** | How is it structured? | Parts, container, nesting | "6 methods inside 1 class" |
| R5 | **RELATIONSHIPS** | How is it connected? | Calls, imports, inherits | "Called by 5, calls 2" |
| R6 | **TRANSFORMATION** | What does it do? | Input → Output | "Takes ID, returns User" |
| R7 | **SEMANTICS** | What does it mean? | Purpose, intent | "Retrieves user from DB" |
| R8 | **EPISTEMOLOGY** | How certain are we? | Confidence, evidence | "92% from name pattern" |

<!-- @END_SECTION: eight_lenses -->

**The 8 Dimensions (Ontological Nature):**

| # | Dimension | Question | Values | Example |
|---|-----------|----------|--------|---------|
| D1 | **WHAT** | What is this? | 200 atom types | `Function`, `Class`, `ForLoop` |
| D2 | **LAYER** | Where in architecture? | Interface/App/Core/Infra/Test | `Application` layer |
| D3 | **ROLE** | What's its purpose? | 33 roles | `Repository`, `Controller` |
| D4 | **BOUNDARY** | Crosses boundaries? | Internal/Input/I-O/Output | `I-O` (database call) |
| D5 | **STATE** | Maintains state? | Stateful/Stateless | `Stateless` |
| D6 | **EFFECT** | Side effects? | Pure/Read/Write/ReadModify | `ReadModify` |
| D7 | **LIFECYCLE** | In what phase? | Create/Use/Destroy | `Use` |
| D8 | **TRUST** | Confidence level? | 0-100% | `87%` |

> *Like quantum mechanics: the observer (lenses) and the observed (dimensions) are inseparable. You cannot know an atom without asking through lenses; you cannot ask without the atom having dimensional properties.*

<!-- @SECTION: lens_dimension_question -->
<!-- @ORDER: 7.4.2 -->
<!-- @DEPENDS_ON: eight_lenses, eight_dimensions -->
<!-- @PROVIDES: open_question_lenses_dimensions -->

**⚠️ OPEN QUESTION:** How exactly do Lenses and Dimensions relate?

| Hypothesis | Description | Implies |
|------------|-------------|---------|
| **Matrix 8×8** | Each lens can interrogate each dimension | 64 inquiry points |
| **Parallel** | They are independent perspectives | 16 separate perspectives |
| **Overlap** | Some lenses map to specific dimensions | Redundancy to investigate |
| **Unknown** | We haven't discovered the true relationship | More research needed |

*We do not currently know which hypothesis is correct. This is documented as an open frontier.*

<!-- @END_SECTION: lens_dimension_question -->
<!-- @END_SECTION: dual_nature -->
<!-- @END_SECTION: octahedral_atom -->

---

<!-- @SECTION: relationships -->
<!-- @TOPIC: edge_types -->
<!-- @ORDER: 8.0 -->
<!-- @DEPENDS_ON: octahedral_atom -->
<!-- @PROVIDES: edge_taxonomy, code_as_graph -->

# PART VIII: THE RELATIONSHIPS

Atoms don't exist in isolation. They connect via **edges**.

---

<!-- @SECTION: edge_types -->
<!-- @ORDER: 8.1 -->
<!-- @DEPENDS_ON: relationships -->
<!-- @PROVIDES: 5_edge_categories -->

## 8.1 Edge Types

| Category | Edges |
|----------|-------|
| **Structural** | contains, is_part_of |
| **Dependency** | calls, imports, uses |
| **Inheritance** | inherits, implements, mixes_in |
| **Semantic** | is_a, has_role, serves, delegates_to |
| **Temporal** | initializes, triggers, disposes, precedes |

<!-- @END_SECTION: edge_types -->

---

<!-- @SECTION: graph_of_code -->
<!-- @ORDER: 8.2 -->
<!-- @DEPENDS_ON: edge_types -->
<!-- @PROVIDES: graph_model -->

## 8.2 The Graph of Code

Code is a **graph**:
- Nodes = 200 atom types
- Edges = relationships
- Positions = 8-dimensional coordinates

<!-- @END_SECTION: graph_of_code -->
<!-- @END_SECTION: relationships -->

---

<!-- @SECTION: validation -->
<!-- @TOPIC: empirical_testing -->
<!-- @ORDER: 9.0 -->
<!-- @DEPENDS_ON: graph_of_code -->
<!-- @PROVIDES: validation_approach, empirical_evidence -->

# PART IX: THE VALIDATION

This map must be tested against reality.

---

<!-- @SECTION: empirical_coverage -->
<!-- @ORDER: 9.1 -->
<!-- @DEPENDS_ON: validation -->
<!-- @PROVIDES: language_coverage_stats -->

## 9.1 Empirical Coverage

| Language | Mapped Nodes | Total AST Nodes | Coverage |
|----------|--------------|-----------------|----------|
| Python | 76 | 108 | 70% |
| TypeScript | 110 | 115 | 96% |
| Java | 90 | 95 | 95% |
| Go | 52 | 52 | **100%** |
| Rust | 80 | 84 | 95% |

<!-- @END_SECTION: empirical_coverage -->

---

<!-- @SECTION: what_validated -->
<!-- @ORDER: 9.2 -->
<!-- @DEPENDS_ON: empirical_coverage -->
<!-- @PROVIDES: confirmed_hypotheses -->

## 9.2 What We Validated

- The 200-atom hypothesis holds (~98% coverage)
- Cross-language mapping is possible
- The periodic table organization works

<!-- @END_SECTION: what_validated -->

---

<!-- @SECTION: what_not_validated -->
<!-- @ORDER: 9.3 -->
<!-- @DEPENDS_ON: what_validated -->
<!-- @PROVIDES: limitations, open_questions -->

## 9.3 What We Did NOT Validate

- Completeness (we claim usefulness, not totality)
- Optimality (other organizations may work better)
- Universality (new languages may require new atoms)

<!-- @END_SECTION: what_not_validated -->
<!-- @END_SECTION: validation -->

---

<!-- @SECTION: open_frontier -->
<!-- @TOPIC: unknown -->
<!-- @ORDER: 10.0 -->
<!-- @DEPENDS_ON: what_not_validated -->
<!-- @PROVIDES: frontier_acknowledgment, epistemic_closure -->

# PART X: THE OPEN FRONTIER

> **"We know that we don't know."**

This is where we end as we began.

---

<!-- @SECTION: what_not_mapped -->
<!-- @ORDER: 10.1 -->
<!-- @DEPENDS_ON: open_frontier -->
<!-- @PROVIDES: gap_inventory -->

## 10.1 What We Haven't Mapped

- Quantum computing integration (L-3 Qubit)
- The "junk code" hypothesis (is 98% of configuration space useless?)
- New paradigms (AI-generated code, biological computing)
- The territory beyond our current map

<!-- @END_SECTION: what_not_mapped -->

---

<!-- @SECTION: the_98_percent_problem -->
<!-- @ORDER: 10.2 -->
<!-- @DEPENDS_ON: what_not_mapped -->
<!-- @PROVIDES: junk_code_hypothesis -->

## 10.2 The ~98% Problem

Like "junk DNA" that turned out to have regulatory functions:

| Domain | "Functional" | "Unknown Purpose" |
|--------|--------------|-------------------|
| DNA | ~2% | ~98% |
| Code Configurations | ~1.5% | ~98.5% |

**Warning:** This numerical similarity may be pure coincidence. We do not claim causation.

<!-- @END_SECTION: the_98_percent_problem -->

---

<!-- @SECTION: the_invitation -->
<!-- @ORDER: 10.3 -->
<!-- @DEPENDS_ON: the_98_percent_problem -->
<!-- @PROVIDES: open_contribution -->

## 10.3 The Invitation

This map is open. If you find territory we haven't mapped:
1. Document it
2. Propose an update
3. Test empirically
4. Contribute

<!-- @END_SECTION: the_invitation -->
<!-- @END_SECTION: open_frontier -->

---

<!-- @SECTION: taxonomy -->
<!-- @TOPIC: classification_patterns -->
<!-- @ORDER: 11.0 -->
<!-- @DEPENDS_ON: open_frontier -->
<!-- @PROVIDES: classification_system, pattern_recognition -->

# PART XI: THE TAXONOMY (Classification System)

How we determine what something IS through pattern recognition.

---

<!-- @SECTION: classification_sources -->
<!-- @ORDER: 11.1 -->
<!-- @DEPENDS_ON: taxonomy -->
<!-- @PROVIDES: confidence_by_source -->

## 11.1 Classification Sources

| SOURCE | CONFIDENCE | MECHANISM | EXAMPLE |
|--------|------------|-----------|---------|
| **Human Verified** | 100% | Manual verification | Human-labeled |
| **Decorator** | 85-95% | AST decorator analysis | `@app.route` → Controller |
| **Inheritance** | 80-95% | Type hierarchy | `extends Repository` → Repository |
| **Name Pattern** | 60-90% | Regex matching | `get*` → Query |
| **Graph Inference** | 50-70% | Call graph analysis | Called by Controller → likely Service |
| **LLM Fallback** | 40-60% | AI classification | Embedding similarity |
| **Unknown** | 0-30% | No evidence | Needs review |

<!-- @END_SECTION: classification_sources -->

---

<!-- @SECTION: confidence_levels -->
<!-- @ORDER: 11.2 -->
<!-- @DEPENDS_ON: classification_sources -->
<!-- @PROVIDES: confidence_thresholds -->

## 11.2 Confidence Levels

| RANGE | LEVEL | MEANING | ACTION |
|-------|-------|---------|--------|
| 95-100% | **CERTAIN** | Human verified / overwhelming evidence | Trust |
| 80-94% | **HIGH** | Strong pattern match | Accept |
| 60-79% | **MEDIUM** | Pattern with ambiguity | Review if critical |
| 40-59% | **LOW** | Weak evidence | Verify |
| 0-39% | **UNCERTAIN** | Insufficient evidence | Human review required |

<!-- @END_SECTION: confidence_levels -->

---

<!-- @SECTION: pattern_types -->
<!-- @ORDER: 11.3 -->
<!-- @DEPENDS_ON: confidence_levels -->
<!-- @PROVIDES: prefix_suffix_path_patterns -->

## 11.3 Pattern Types

### 11.3.1 PREFIX PATTERNS (Name Starts With)

| PREFIX | ROLE | CONFIDENCE | EXAMPLE |
|--------|------|------------|---------|
| `get`, `fetch`, `find` | Query | 85% | `getUserById` |
| `create`, `make`, `build` | Creator | 85% | `createUser` |
| `update`, `set`, `modify` | Mutator | 80% | `updateEmail` |
| `delete`, `remove`, `destroy` | Destroyer | 85% | `deleteUser` |
| `is`, `has`, `can`, `should` | Predicate | 90% | `isValid` |
| `validate`, `check`, `verify` | Validator | 85% | `validateEmail` |
| `to`, `from`, `parse`, `format` | Transformer | 80% | `toJSON` |
| `on`, `handle` | Handler | 80% | `onUserCreated` |
| `_`, `__` (not dunder) | Internal | 90% | `_buildQuery` |
| `test_`, `spec_` | Test | 95% | `test_user_creation` |

### 11.3.2 SUFFIX PATTERNS (Name Ends With)

| SUFFIX | ROLE | CONFIDENCE | EXAMPLE |
|--------|------|------------|---------|
| `Repository`, `Repo` | Repository | 95% | `UserRepository` |
| `Service` | Service | 90% | `UserService` |
| `Controller` | Controller | 95% | `UserController` |
| `Factory` | Factory | 95% | `UserFactory` |
| `Handler` | Handler | 85% | `EventHandler` |
| `Manager` | Manager | 85% | `CacheManager` |
| `Validator` | Validator | 90% | `EmailValidator` |
| `Builder` | Builder | 90% | `QueryBuilder` |
| `Mapper` | Mapper | 85% | `UserMapper` |
| `Adapter` | Adapter | 85% | `DatabaseAdapter` |

### 11.3.3 PATH PATTERNS (File Location)

| PATH CONTAINS | LAYER | CONFIDENCE | EXAMPLE |
|---------------|-------|------------|---------|
| `test/`, `tests/`, `spec/` | Test | 95% | `tests/user_test.py` |
| `api/`, `controllers/`, `routes/` | Interface | 85% | `api/users.py` |
| `services/`, `application/` | Application | 80% | `services/user_service.py` |
| `domain/`, `models/`, `entities/` | Core | 80% | `domain/user.py` |
| `infrastructure/`, `adapters/` | Infrastructure | 85% | `infrastructure/db.py` |

<!-- @END_SECTION: pattern_types -->
<!-- @END_SECTION: taxonomy -->

---

<!-- @SECTION: lineage -->
<!-- @TOPIC: intellectual_inheritance -->
<!-- @ORDER: 12.0 -->
<!-- @DEPENDS_ON: taxonomy -->
<!-- @PROVIDES: epistemic_contract, concept_provenance -->
<!-- @SOURCES: Aristotle350BC, Dijkstra1968, Shannon1948, Koestler1967, Popper1972, Evans2003, Martin2012 -->

# PART XII: THE LINEAGE (Intellectual Inheritance)

> *"Just like code has inheritance chains, we must track where each concept comes from."*

We rely on understanding concepts that we did not develop. We borrow knowledge from those who came before. This section traces the **intellectual provenance** of every Standard Code concept.

---

<!-- @SECTION: foundational_lineages -->
<!-- @ORDER: 12.1 -->
<!-- @DEPENDS_ON: lineage -->
<!-- @PROVIDES: concept_ancestry -->

## 12.1 Foundational Lineages

### 12.1.1 THE 3 PLANES

```
PLANES ← Semiotics: Syntactics/Semantics/Pragmatics (Morris, 1938)
       ← Three Worlds Theory (Karl Popper, 1972)
           └── World 1: Physical → P1 PHYSICAL
           └── World 2: Mental 
           └── World 3: Abstract Objects → P3 SEMANTIC
       ← Levels of Abstraction (Floridi, 2008)
```

**Synthesis:** We renamed Popper's "Worlds" to "Planes" and aligned with software substrates.

### 12.1.2 THE 16 LEVELS

```
LEVELS ← Abstraction Layers (Dijkstra, "THE", 1968)
       ← Holarchy (Koestler, "Ghost in the Machine", 1967)
           └── Holons: Simultaneously whole and part
       ← Scalar Hierarchy (Allen & Starr, 1982)
       ← Levels of Abstraction (Floridi, 2008)
```

**Synthesis:** Combined Dijkstra's layers, Koestler's holons, ecological scaling.

### 12.1.3 THE 8 LENSES

```
LENSES ← Aristotle's Four Causes (350 BC)
       ← Zachman Framework (1987): What, How, Where, Who, When, Why
       ← 4+1 Architectural Views (Kruchten, 1995)
```

| Lens | Primary Ancestor |
|------|------------------|
| R1 Identity | Universal naming |
| R2 Ontology | Aristotle |
| R3 Classification | Linnaeus taxonomy |
| R4 Composition | Mereology |
| R5 Relationships | Euler (Graph Theory) |
| R6 Transformation | Shannon |
| R7 Semantics | Morris (Semiotics) |
| R8 Epistemology | **Novel** |

### 12.1.4 THE 8 DIMENSIONS

```
DIMENSIONS ← Faceted Classification (Ranganathan, 1933)
           ← DDD Concepts (Evans, 2003)
           ← Clean Architecture (Martin, 2012)
```

| Dimension | Primary Ancestor |
|-----------|------------------|
| D1 WHAT | Compiler Theory (AST) |
| D2 LAYER | Clean Architecture |
| D3 ROLE | DDD Patterns |
| D4 BOUNDARY | Hexagonal (Cockburn) |
| D5 STATE | Mealy/Moore |
| D6 EFFECT | Lambda Calculus |
| D7 LIFECYCLE | Event-Driven Arch |
| D8 TRUST | Garbage Collection |

### 12.1.5 THE 200 ATOMS

```
ATOMS ← AST Node Kinds (Compiler Theory)
      ← Periodic Table Metaphor (Mendeleev, 1869)
      ← Design Patterns (GoF, 1994)
      ← DDD Building Blocks (Evans, 2003)
```

### 12.1.6 THE 33 ROLES

```
ROLES ← DDD Tactical Patterns (Evans, 2003)
      ← CQRS (Greg Young, 2010)
      ← Hexagonal Architecture (Cockburn, 2005)
      ← Clean Architecture (Martin, 2012)
```

<!-- @END_SECTION: foundational_lineages -->

---

<!-- @SECTION: novel_contributions -->
<!-- @ORDER: 12.2 -->
<!-- @DEPENDS_ON: foundational_lineages -->
<!-- @PROVIDES: original_synthesis -->

## 12.2 Novel Contributions

What is **new** in this work, not borrowed:

| Concept | Novel Contribution |
|---------|-------------------|
| **8D Classification Manifold** | 8 orthogonal dimensions as semantic space |
| **Particle = Node + Atom + Confidence** | The triple with uncertainty |
| **L3 as Semantic Event Horizon** | Function as fundamental unit |
| **R8 Epistemology Lens** | Confidence tracking as first-class |
| **Frontier Register** | Unknown as first-class |
| **Postulates with Validation Obligations** | Every claim falsifiable |
| **Dual Nature (Lenses/Dimensions)** | Epistemic/Ontological duality |
| **Marker System** | Programmatic concept traceability |

<!-- @END_SECTION: novel_contributions -->

---

<!-- @SECTION: bibliography -->
<!-- @ORDER: 12.3 -->
<!-- @DEPENDS_ON: novel_contributions -->
<!-- @PROVIDES: primary_sources -->

## 12.3 Bibliography (Key Sources)

| Author | Work | Year | Concepts |
|--------|------|------|----------|
| Aristotle | Categories | -350 | Ontology |
| Dijkstra | Structure of THE | 1968 | Layers |
| Shannon | Information Theory | 1948 | IPO |
| Koestler | Ghost in the Machine | 1967 | Holons |
| Popper | Objective Knowledge | 1972 | 3 Worlds |
| Bejan | Constructal Theory | 1996 | Flow |
| Evans | Domain-Driven Design | 2003 | DDD |
| Martin | Clean Architecture | 2012 | Layers |
| Ranganathan | Colon Classification | 1933 | Facets |
| Korzybski | Science and Sanity | 1931 | Map/Territory |

<!-- @END_SECTION: bibliography -->
<!-- @END_SECTION: lineage -->

---

> *"The map grows to match the territory. We are always running behind."*
> 
> *"Somos cartógrafos humildes. O mapa cresce com o território. Sempre haverá mais território."*

---

**Version:** 3.0.0  
**Status:** Working Map (Open, Versioned, Humble)  
**Last Updated:** 2025-12-26
