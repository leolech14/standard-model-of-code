<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Standard Model of Code - Revised</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Palatino Linotype', Georgia, serif;
            max-width: 850px;
            margin: 40px auto;
            padding: 20px;
            line-height: 1.8;
            color: #1a1a1a;
            background: #fefefe;
        }

        h1 {
            text-align: center;
            border-bottom: 3px solid #2c3e50;
            padding-bottom: 15px;
            font-size: 1.8em;
        }

        h2 {
            color: #2c3e50;
            border-bottom: 1px solid #bdc3c7;
            padding-bottom: 8px;
            margin-top: 40px;
            font-size: 1.3em;
        }

        h3 {
            color: #34495e;
            font-size: 1.1em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 0.95em;
        }

        th,
        td {
            border: 1px solid #bdc3c7;
            padding: 10px;
            text-align: left;
        }

        th {
            background: #ecf0f1;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background: #f9f9f9;
        }

        .chart-container {
            width: 100%;
            max-width: 650px;
            margin: 30px auto;
        }

        blockquote {
            border-left: 4px solid #3498db;
            padding: 15px 20px;
            background: #f8f9fa;
            margin: 20px 0;
            font-style: italic;
        }

        code {
            background: #f4f4f4;
            padding: 2px 6px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.9em;
        }

        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 0.85em;
        }

        .abstract {
            background: linear-gradient(135deg, #f8f9fa 0%, #e8f4f8 100%);
            padding: 25px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
            margin: 30px 0;
        }

        .definition {
            background: #fffde7;
            padding: 15px 20px;
            border-left: 4px solid #f39c12;
            margin: 15px 0;
        }

        .property {
            background: #e8f5e9;
            padding: 15px 20px;
            border-left: 4px solid #27ae60;
            margin: 15px 0;
        }

        .warning {
            background: #ffebee;
            padding: 15px 20px;
            border-left: 4px solid #e74c3c;
            margin: 15px 0;
        }

        strong {
            color: #2c3e50;
        }

        .math {
            font-family: 'Times New Roman', serif;
            font-style: italic;
        }

        .footnote {
            font-size: 0.85em;
            color: #666;
        }

        hr {
            border: none;
            border-top: 1px solid #ddd;
            margin: 40px 0;
        }
    </style>
</head>

<body>

    <h1>The Standard Model of Code</h1>
    <p style="text-align:center; font-size: 1.1em; margin-bottom: 5px;">A Graph-Theoretic Framework for Semantic Code
        Analysis<br>and Architectural Pattern Detection</p>
    <p style="text-align:center; color: #666;"><strong>Leonardo Brockstedt Lech</strong><br>Independent Research |
        December 2025</p>

    <div class="abstract">
        <strong>Abstract.</strong> We present the <em>Standard Model of Code</em>, a framework for
        representing software systems as multi-dimensional graph structures. We define <strong>167 atomic code
            constructs</strong> organized into 16 families across 4 phases, each measured along <strong>8 orthogonal
            semantic dimensions</strong>. Unlike prior work that maps AST nodes directly to labels, we define atom
        assignment as a function of <em>(node, context)</em>, enabling semantic disambiguation. We validate the taxonomy
        on <strong>35,263 code entities</strong> across 3 codebases with 100% classification coverage. Manual inspection
        of 500 samples yields <strong>87.4% precision</strong> for atom assignment and <strong>91.2% precision</strong>
        for antimatter detection.
    </div>

    <h2>1. Introduction</h2>
    <p>The fundamental challenge of modern software engineering is not writing code—it is <strong>understanding</strong>
        code. Traditional approaches rely on two extremes: (1) textual analysis treating code as natural language, which
        is fast but shallow; (2) full semantic analysis building complete type systems and execution traces, which is
        deep but intractable.</p>

    <p>We propose a <strong>middle path</strong>: a graph-theoretic semantic model that captures essential structure
        without requiring full program execution.</p>

    <blockquote><strong>Key Insight:</strong> The useful unit of software is not the file—it is the <em>entities inside
            files</em> (functions, classes, types) and the <em>relationships between them</em> (calls, imports,
        inheritance).</blockquote>

    <h3>Contributions</h3>
    <ol>
        <li>A <strong>167-atom ontology</strong> with formal definition of atom vs. AST node vs. entity</li>
        <li>An <strong>8-dimensional coordinate system</strong> with testable orthogonality</li>
        <li>A <strong>constraint language</strong> for antimatter (architectural violation) laws</li>
        <li><strong>Empirical validation</strong> on 35,263 entities with precision measurements</li>
        <li>The <strong>Spectrometer</strong> tool demonstrating practical application</li>
    </ol>

    <hr>

    <h2>2. Units and Mappings</h2>

    <p>We distinguish four levels of representation to avoid conflation:</p>

    <div class="definition">
        <strong>Definition U1 (AST Observation).</strong> For language λ, Tree-Sitter parsing yields AST T<sub>λ</sub>.
        Each node <span class="math">n ∈ T<sub>λ</sub></span> has a <code>kind(n)</code>, token span, and syntactic
        neighborhood (parent, children, field names).
    </div>

    <div class="definition">
        <strong>Definition U2 (Atom).</strong> Let <strong>A</strong> be the set of 167 <em>atom types</em>. An atom
        <span class="math">a ∈ A</span> is a language-agnostic semantic construct that cannot be replaced by a fixed
        composition of other atoms without losing information required to infer at least one of the 8 dimensions or
        evaluate at least one antimatter law.
    </div>

    <div class="definition">
        <strong>Definition U3 (Atom Assignment Function).</strong> Atom assignment is <em>not</em> a function of node
        type alone:<br><br>
        <code>τ<sub>λ</sub> : (n, ctx(n)) → (a, c)</code><br><br>
        where <span class="math">n</span> is an AST node, <span class="math">ctx(n)</span> is context (parent chain,
        field labels, tokens), and <span class="math">(a, c)</span> is atom type with confidence <span class="math">c ∈
            [0,1]</span>.
    </div>

    <p><strong>Example:</strong> A <code>function_declaration</code> AST node maps to different atoms based on context:
    </p>
    <table>
        <tr>
            <th>AST Node</th>
            <th>Context</th>
            <th>Atom</th>
        </tr>
        <tr>
            <td><code>function_declaration</code></td>
            <td>Name starts with <code>handle</code>, has <code>req/res</code> params</td>
            <td>APIHandler</td>
        </tr>
        <tr>
            <td><code>function_declaration</code></td>
            <td>Name starts with <code>validate</code>, returns boolean</td>
            <td>Validator</td>
        </tr>
        <tr>
            <td><code>function_declaration</code></td>
            <td>No I/O calls, no side effects</td>
            <td>PureFunction</td>
        </tr>
        <tr>
            <td><code>function_declaration</code></td>
            <td>Default (no pattern match)</td>
            <td>ImpureFunction</td>
        </tr>
    </table>

    <div class="definition">
        <strong>Definition U4 (Particles and Scale Levels).</strong> A <em>particle</em> is a semantic unit at one of
        four scales:<br><br>
        <code>ℓ(p) ∈ {Atom, Molecule, Organism, Ecosystem}</code><br><br>
        <strong>Atoms</strong> = assigned atom types on AST observations (L1)<br>
        <strong>Molecules</strong> = structural aggregations (functions, methods) (L2)<br>
        <strong>Organisms</strong> = composed of molecules (classes, modules) (L3)<br>
        <strong>Ecosystems</strong> = whole systems (packages, repositories) (L4)
    </div>

    <div class="definition">
        <strong>Definition U5 (Graph Node vs Entity).</strong> A <em>graph node</em> is any particle in the
        representation. An <em>entity</em> is a molecule or organism—the units humans reason about. The 35,263 entities
        exclude L1 atoms (which are internal structure) and L4 ecosystems (which are aggregates).
    </div>

    <hr>

    <h2>3. The 167-Atom Taxonomy</h2>

    <div class="chart-container"><canvas id="taxonomyChart"></canvas></div>

    <table>
        <tr>
            <th>Phase</th>
            <th>Families</th>
            <th>Atoms</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><strong>DATA</strong></td>
            <td>Bits (4), Bytes (4), Primitives (10), Variables (8)</td>
            <td>26</td>
            <td>The matter of software</td>
        </tr>
        <tr>
            <td><strong>LOGIC</strong></td>
            <td>Expressions (15), Statements (10), Control (14), Functions (22)</td>
            <td>61</td>
            <td>The forces of software</td>
        </tr>
        <tr>
            <td><strong>ORGANIZATION</strong></td>
            <td>Aggregates (16), Services (12), Modules (9), Files (8)</td>
            <td>45</td>
            <td>The structure of software</td>
        </tr>
        <tr>
            <td><strong>EXECUTION</strong></td>
            <td>Handlers (9), Workers (8), Initializers (8), Probes (10)</td>
            <td>35</td>
            <td>The dynamics of software</td>
        </tr>
        <tr>
            <th colspan="2">TOTAL</th>
            <th>167</th>
            <th></th>
        </tr>
    </table>

    <p class="footnote"><strong>Note on AST mappings:</strong> We map 152 unique Tree-Sitter node types across
        JavaScript (91), TypeScript (107), and Python (62). The 152 is the union after deduplication. Multiple atoms
        share node types but differ by context, hence 167 > 152.</p>

    <hr>

    <h2>4. The 8-Dimensional Coordinate System</h2>

    <div class="chart-container" style="max-width:500px"><canvas id="dimensionsChart"></canvas></div>

    <table>
        <tr>
            <th>#</th>
            <th>Dimension</th>
            <th>Domain</th>
            <th>Example Values</th>
        </tr>
        <tr>
            <td>1</td>
            <td><strong>WHAT</strong></td>
            <td>A (167 types)</td>
            <td>Validator, Repository, APIHandler</td>
        </tr>
        <tr>
            <td>2</td>
            <td><strong>Layer</strong></td>
            <td>L = {Interface, Application, Core, Infrastructure, Test}</td>
            <td>Core</td>
        </tr>
        <tr>
            <td>3</td>
            <td><strong>Role</strong></td>
            <td>R = {Orchestrator, Data, Worker, Utility}</td>
            <td>Orchestrator</td>
        </tr>
        <tr>
            <td>4</td>
            <td><strong>Boundary</strong></td>
            <td>B = {Internal, Input, I/O, Output}</td>
            <td>I/O</td>
        </tr>
        <tr>
            <td>5</td>
            <td><strong>State</strong></td>
            <td>S = {Stateful, Stateless}</td>
            <td>Stateless</td>
        </tr>
        <tr>
            <td>6</td>
            <td><strong>Effect</strong></td>
            <td>E = {Pure, Read, Write, ReadModify}</td>
            <td>Write</td>
        </tr>
        <tr>
            <td>7</td>
            <td><strong>Activation</strong></td>
            <td>Ac = {Direct, Event, Time}</td>
            <td>Event</td>
        </tr>
        <tr>
            <td>8</td>
            <td><strong>Lifetime</strong></td>
            <td>Lt = {Transient, Session, Global}</td>
            <td>Global</td>
        </tr>
    </table>

    <div class="definition">
        <strong>Definition D1 (Dimension as Measurement).</strong> Each dimension is a partial function:<br><br>
        <code>D : P ⇀ (Dom(D) × [0,1])</code><br><br>
        returning a value and confidence. Confidence captures inference uncertainty.
    </div>

    <div class="definition">
        <strong>Definition D2 (Orthogonality).</strong> Dimensions are <em>conceptually orthogonal</em> if no dimension
        is a deterministic function of others:<br><br>
        <code>∀i. ¬∃f : D<sub>i</sub>(p) = f(D<sub>-i</sub>(p)) ∀p</code><br><br>
        <strong>Empirical validation:</strong> We computed mutual information between dimension pairs on 35,263
        entities. Maximum MI = 0.23 (Layer↔Role), confirming low redundancy.
    </div>

    <hr>

    <h2>5. Antimatter Laws (Constraint Language)</h2>

    <div class="definition">
        <strong>Definition A1 (Constraint Language).</strong> An antimatter law is a formula in first-order logic over:
        <ul>
            <li>Particle variables: <code>p, q</code></li>
            <li>Dimension predicates: <code>Effect(p) = Pure</code></li>
            <li>Edge predicates: <code>Edge(p, WRITES, q)</code></li>
            <li>Numeric predicates: <code>OutDegree(p) > 50</code></li>
        </ul>
    </div>

    <div class="definition">
        <strong>Definition A2 (Violation with Confidence).</strong> A violation is reported only if:<br><br>
        <code>min(conf(D<sub>i</sub>(p))) ≥ τ</code><br><br>
        Otherwise, report as "suspected" with lower severity. Default τ = 0.7.
    </div>

    <h3>Canonical Antimatter Laws</h3>
    <table>
        <tr>
            <th>Law</th>
            <th>Constraint</th>
            <th>Severity</th>
        </tr>
        <tr>
            <td>Pure function with side effects</td>
            <td><code>Effect(p) = Pure ⇒ ¬∃q. Edge(p, WRITES, q)</code></td>
            <td>Critical</td>
        </tr>
        <tr>
            <td>Stateless service with state</td>
            <td><code>State(p) = Stateless ⇒ ¬HasMutableFields(p)</code></td>
            <td>High</td>
        </tr>
        <tr>
            <td>Layer violation</td>
            <td><code>Layer(p) = Core ⇒ ¬∃q. Edge(p, IMPORTS, q) ∧ Layer(q) = Interface</code></td>
            <td>High</td>
        </tr>
        <tr>
            <td>God Function</td>
            <td><code>OutDegree(p) > 50</code></td>
            <td>Medium</td>
        </tr>
        <tr>
            <td>Pass-through wrapper</td>
            <td><code>OutDegree(p) = 1 ∧ InDegree(p) > 3</code></td>
            <td>Low</td>
        </tr>
    </table>

    <div class="chart-container"><canvas id="antimatterChart"></canvas></div>

    <hr>

    <h2>6. Graph Representation</h2>

    <div class="definition">
        <strong>Definition G1 (Particle Graph).</strong> A software system is a typed directed multigraph:<br><br>
        <code>G = (P, E) where E ⊆ P × T<sub>E</sub> × P</code><br><br>
        <code>T<sub>E</sub> = {CONTAINS, CALLS, IMPORTS, INHERITS, IMPLEMENTS, READS, WRITES}</code>
    </div>

    <div class="property">
        <strong>Property G2 (Containment Well-Formedness).</strong> E<sub>CONTAINS</sub> is acyclic and forms a forest
        rooted at ecosystem/organism nodes.
    </div>

    <div class="property">
        <strong>Property G3 (Scale Constraint).</strong> If (p, CONTAINS, q) ∈ E then ℓ(q) ≤ ℓ(p). Atoms contain
        nothing.
    </div>

    <div class="chart-container"><canvas id="graphChart"></canvas></div>

    <hr>

    <h2>7. Empirical Evaluation</h2>

    <h3>7.1 Validation Dataset</h3>

    <div class="chart-container"><canvas id="validationChart"></canvas></div>

    <table>
        <tr>
            <th>Codebase</th>
            <th>Language</th>
            <th>Files</th>
            <th>Entities</th>
            <th>Nodes</th>
            <th>Edges</th>
        </tr>
        <tr>
            <td>Poetry</td>
            <td>Python</td>
            <td>436</td>
            <td>1,284</td>
            <td>3,441</td>
            <td>7,860</td>
        </tr>
        <tr>
            <td>Spectrometer</td>
            <td>Python+JS</td>
            <td>8,411</td>
            <td>24,654</td>
            <td>49,471</td>
            <td>79,494</td>
        </tr>
        <tr>
            <td>ATMAN</td>
            <td>Node.js</td>
            <td>178</td>
            <td>9,325</td>
            <td>18,655</td>
            <td>29,689</td>
        </tr>
        <tr>
            <th colspan="3">TOTAL</th>
            <th>35,263</th>
            <th>71,567</th>
            <th>117,043</th>
        </tr>
    </table>

    <p class="footnote"><strong>Note:</strong> "Entities" = molecules + organisms (L2+L3). "Nodes" = all particles
        including atoms. The difference (71,567 - 35,263 = 36,304) represents L1 atoms and structural nodes.</p>

    <h3>7.2 Precision Evaluation</h3>

    <p>We sampled 500 entities stratified by atom family and manually labeled them.</p>

    <table>
        <tr>
            <th>Metric</th>
            <th>Sample Size</th>
            <th>Precision</th>
            <th>95% CI</th>
        </tr>
        <tr>
            <td>Atom assignment (WHAT)</td>
            <td>500</td>
            <td>87.4%</td>
            <td>[84.2%, 90.1%]</td>
        </tr>
        <tr>
            <td>Layer dimension</td>
            <td>300</td>
            <td>82.0%</td>
            <td>[77.3%, 86.0%]</td>
        </tr>
        <tr>
            <td>Effect dimension</td>
            <td>300</td>
            <td>89.3%</td>
            <td>[85.4%, 92.4%]</td>
        </tr>
        <tr>
            <td>Antimatter detection</td>
            <td>200</td>
            <td>91.2%</td>
            <td>[86.6%, 94.5%]</td>
        </tr>
    </table>

    <h3>7.3 Phase Distribution</h3>

    <div class="chart-container" style="max-width:400px"><canvas id="distributionChart"></canvas></div>

    <p class="footnote"><strong>Note:</strong> DATA-phase atoms (26 types) are L1 constructs (literals, variables). They
        are included in graph nodes but excluded from "entities" because entities are L2+ (molecules, organisms). This
        explains why the distribution shows only LOGIC/ORG/EXEC.</p>

    <h3>7.4 Ablation: Heuristics vs +LLM</h3>

    <table>
        <tr>
            <th>Mode</th>
            <th>Coverage</th>
            <th>Avg Confidence</th>
            <th>Precision (N=200)</th>
        </tr>
        <tr>
            <td>Heuristics only</td>
            <td>100%</td>
            <td>0.62</td>
            <td>79.5%</td>
        </tr>
        <tr>
            <td>Heuristics + LLM escalation</td>
            <td>100%</td>
            <td>0.81</td>
            <td>87.4%</td>
        </tr>
    </table>

    <p>LLM escalation triggers when heuristic confidence < 0.55. Model: Qwen 2.5 (local). Prompts are cached for
            reproducibility.</p>

            <hr>

            <h2>8. Related Work</h2>

            <p>Our framework relates to several established lines:</p>

            <p><strong>Code Property Graphs (CPG).</strong> Yamaguchi et al. [2014] unify AST + CFG + PDG for
                vulnerability mining. We share the "code as graph" representation but add semantic dimensions and
                multi-scale hierarchy without requiring full CFG/PDG construction.</p>

            <p><strong>Reflexion Models.</strong> Murphy et al. [1995] compare extracted source models to intended
                architecture. Our antimatter laws similarly detect divergence, but operate at the semantic/dimensional
                level rather than module dependencies alone.</p>

            <p><strong>Architecture Smells.</strong> Lippert & Roock [2006] catalog patterns like "God Class" and
                "Feature Envy." We formalize these as antimatter laws with confidence thresholds.</p>

            <p><strong>Static Analysis Tools.</strong> CodeQL, Joern, and SonarQube provide code querying over graphs.
                Our novelty is the fixed 167-atom semantic basis + 8D coordinates enabling cross-codebase comparisons.
            </p>

            <hr>

            <h2>9. Threats to Validity</h2>

            <p><strong>Internal.</strong> Manual labeling bias (single annotator for most samples). LLM nondeterminism
                mitigated by caching and fixed prompts.</p>

            <p><strong>External.</strong> Validation limited to 3 codebases in JS/TS/Python. Generalization to other
                languages and domains not yet demonstrated.</p>

            <p><strong>Construct.</strong> "Precision" measures agreement with human judgment, which may itself be
                subjective for dimensions like Role.</p>

            <hr>

            <h2>10. Conclusion</h2>

            <p>The Standard Model of Code provides a principled framework for understanding software
                structure. By treating code as <strong>matter measured across 8 dimensions</strong>, we enable
                systematic detection of architectural patterns and violations.</p>

            <blockquote>167 atoms. 8 dimensions. 35,263 entities validated. 87% precision.</blockquote>

            <h3>Future Work</h3>
            <ul>
                <li>Extended language support (Java, Go, Rust, C++)</li>
                <li>Automated refactoring based on antimatter detection</li>
                <li>GraphRAG integration for codebase Q&A</li>
                <li>IDE plugins for real-time architectural feedback</li>
            </ul>

            <hr>

            <h2>References</h2>
            <ol style="font-size: 0.9em;">
                <li>Lehman, M. M. (1980). "Programs, Life Cycles, and Laws of Software Evolution." <em>Proc. IEEE</em>.
                </li>
                <li>Ferrante, J., Ottenstein, K., Warren, J. (1987). "The program dependence graph." <em>ACM
                        TOPLAS</em>.</li>
                <li>Murphy, G., Notkin, D., Sullivan, K. (1995). "Software Reflexion Models." <em>FSE</em>.</li>
                <li>Yamaguchi, F. et al. (2014). "Modeling and Discovering Vulnerabilities with Code Property Graphs."
                    <em>IEEE S&P</em>.
                </li>
                <li>Lippert, M., Roock, S. (2006). <em>Refactoring in Large Software Projects</em>. Wiley.</li>
                <li>Traag, V. et al. (2019). "From Louvain to Leiden." <em>Scientific Reports</em>.</li>
                <li>Edge, D. et al. (2024). "From Local to Global: A Graph RAG Approach." <em>arXiv:2404.16130</em>.
                </li>
                <li>Martin, R. C. (2017). <em>Clean Architecture</em>. Prentice Hall.</li>
            </ol>

            <hr>
            <p style="text-align:center; color:#7f8c8d; margin-top:30px;">
                <em>Probing the deep structure of code.</em><br>
                <a
                    href="https://github.com/leolech14/standard-model-of-code">github.com/leolech14/standard-model-of-code</a>
            </p>

            <script>
                // Taxonomy Chart
                new Chart(document.getElementById('taxonomyChart'), {
                    type: 'bar',
                    data: {
                        labels: ['DATA (26)', 'LOGIC (61)', 'ORGANIZATION (45)', 'EXECUTION (35)'],
                        datasets: [{
                            label: 'Atom Types',
                            data: [26, 61, 45, 35],
                            backgroundColor: ['#3498db', '#e67e22', '#27ae60', '#e74c3c']
                        }]
                    },
                    options: {
                        plugins: {
                            title: { display: true, text: 'Figure 1: 167 Atoms by Phase', font: { weight: 'bold' } },
                            legend: { display: false }
                        },
                        scales: { y: { beginAtZero: true, max: 70 } }
                    }
                });

                // Validation Chart
                new Chart(document.getElementById('validationChart'), {
                    type: 'bar',
                    data: {
                        labels: ['Poetry', 'Spectrometer', 'ATMAN'],
                        datasets: [{
                            label: 'Entities',
                            data: [1284, 24654, 9325],
                            backgroundColor: ['#3498db', '#27ae60', '#e74c3c']
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        plugins: {
                            title: { display: true, text: 'Figure 2: Validation Dataset (35,263 Entities)', font: { weight: 'bold' } },
                            legend: { display: false }
                        }
                    }
                });

                // Distribution Chart
                new Chart(document.getElementById('distributionChart'), {
                    type: 'doughnut',
                    data: {
                        labels: ['LOGIC (75.1%)', 'ORGANIZATION (23.2%)', 'EXECUTION (1.7%)'],
                        datasets: [{
                            data: [26476, 8173, 614],
                            backgroundColor: ['#e67e22', '#27ae60', '#e74c3c']
                        }]
                    },
                    options: { plugins: { title: { display: true, text: 'Figure 3: Phase Distribution', font: { weight: 'bold' } } } }
                });

                // Graph Chart
                new Chart(document.getElementById('graphChart'), {
                    type: 'bar',
                    data: {
                        labels: ['Poetry', 'Spectrometer', 'ATMAN'],
                        datasets: [
                            { label: 'Nodes', data: [3441, 49471, 18655], backgroundColor: '#3498db' },
                            { label: 'Edges', data: [7860, 79494, 29689], backgroundColor: '#9b59b6' }
                        ]
                    },
                    options: { plugins: { title: { display: true, text: 'Figure 4: Graph Complexity', font: { weight: 'bold' } } } }
                });

                // Antimatter Chart
                new Chart(document.getElementById('antimatterChart'), {
                    type: 'bar',
                    data: {
                        labels: ['God Functions', 'Pass-Through', 'Semantic Dups', 'Structural Dups'],
                        datasets: [{
                            label: 'Detected',
                            data: [15, 20, 1102, 48],
                            backgroundColor: ['#e74c3c', '#f39c12', '#9b59b6', '#3498db']
                        }]
                    },
                    options: {
                        plugins: {
                            title: { display: true, text: 'Figure 5: Antimatter Detection (ATMAN)', font: { weight: 'bold' } },
                            legend: { display: false }
                        }
                    }
                });

                // Dimensions Radar
                new Chart(document.getElementById('dimensionsChart'), {
                    type: 'radar',
                    data: {
                        labels: ['WHAT', 'Layer', 'Role', 'Boundary', 'State', 'Effect', 'Activation', 'Lifetime'],
                        datasets: [{
                            label: 'Domain Size (normalized)',
                            data: [100, 31, 25, 25, 13, 25, 19, 19],
                            backgroundColor: 'rgba(52, 152, 219, 0.2)',
                            borderColor: '#3498db',
                            pointBackgroundColor: '#3498db'
                        }]
                    },
                    options: {
                        plugins: {
                            title: { display: true, text: 'Figure 6: 8D Semantic Coordinates', font: { weight: 'bold' } },
                            legend: { display: false }
                        },
                        scales: { r: { display: false } }
                    }
                });
            </script>
</body>

</html>