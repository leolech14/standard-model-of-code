"""
Fix Generator - Code Templates for Optimization Schemas

Generates starter code templates based on the insights and schemas
detected by the Insights Engine.
"""

from typing import Dict, List, Optional
from dataclasses import dataclass


@dataclass
class CodeTemplate:
    """A code template for an optimization schema"""
    language: str
    filename: str
    code: str
    description: str


# =============================================================================
# CODE TEMPLATES BY SCHEMA
# =============================================================================

TEMPLATES = {
    "REPOSITORY_PATTERN": {
        "python": CodeTemplate(
            language="python",
            filename="{entity}_repository.py",
            code='''"""
Repository for {Entity} entity.
Generated by Collider - Standard Model of Code.
"""
from abc import ABC, abstractmethod
from typing import List, Optional


class I{Entity}Repository(ABC):
    """Repository interface for {Entity}."""
    
    @abstractmethod
    def get_by_id(self, id: str) -> Optional[{Entity}]:
        """Retrieve a {Entity} by ID."""
        pass
    
    @abstractmethod
    def save(self, entity: {Entity}) -> {Entity}:
        """Persist a {Entity}."""
        pass
    
    @abstractmethod
    def delete(self, id: str) -> bool:
        """Delete a {Entity} by ID."""
        pass
    
    @abstractmethod
    def list_all(self) -> List[{Entity}]:
        """List all {Entity} entities."""
        pass


class {Entity}Repository(I{Entity}Repository):
    """Concrete repository implementation."""
    
    def __init__(self, db_session):
        self._session = db_session
    
    def get_by_id(self, id: str) -> Optional[{Entity}]:
        return self._session.query({Entity}).get(id)
    
    def save(self, entity: {Entity}) -> {Entity}:
        self._session.add(entity)
        self._session.commit()
        return entity
    
    def delete(self, id: str) -> bool:
        entity = self.get_by_id(id)
        if entity:
            self._session.delete(entity)
            self._session.commit()
            return True
        return False
    
    def list_all(self) -> List[{Entity}]:
        return self._session.query({Entity}).all()
''',
            description="Repository pattern implementation for clean data access"
        ),
        
        "typescript": CodeTemplate(
            language="typescript",
            filename="{entity}.repository.ts",
            code='''/**
 * Repository for {Entity} entity.
 * Generated by Collider - Standard Model of Code.
 */

export interface I{Entity}Repository {
  getById(id: string): Promise<{Entity} | null>;
  save(entity: {Entity}): Promise<{Entity}>;
  delete(id: string): Promise<boolean>;
  listAll(): Promise<{Entity}[]>;
}

export class {Entity}Repository implements I{Entity}Repository {
  constructor(private readonly db: Database) {}

  async getById(id: string): Promise<{Entity} | null> {
    return this.db.findOne('{entity}', { id });
  }

  async save(entity: {Entity}): Promise<{Entity}> {
    return this.db.upsert('{entity}', entity);
  }

  async delete(id: string): Promise<boolean> {
    const result = await this.db.delete('{entity}', { id });
    return result.affected > 0;
  }

  async listAll(): Promise<{Entity}[]> {
    return this.db.findAll('{entity}');
  }
}
''',
            description="Repository pattern implementation for clean data access"
        )
    },
    
    "TEST_COVERAGE": {
        "python": CodeTemplate(
            language="python",
            filename="test_{component}.py",
            code='''"""
Tests for {Component}.
Generated by Collider - Standard Model of Code.
"""
import pytest
from unittest.mock import Mock, patch


class Test{Component}:
    """Test suite for {Component}."""
    
    @pytest.fixture
    def sut(self):
        """Create System Under Test."""
        # TODO: Set up with proper dependencies
        return {Component}()
    
    def test_should_handle_valid_input(self, sut):
        """Test happy path with valid input."""
        # Arrange
        input_data = {{}}  # TODO: Define valid input
        
        # Act
        result = sut.execute(input_data)
        
        # Assert
        assert result is not None
        # TODO: Add specific assertions
    
    def test_should_handle_invalid_input(self, sut):
        """Test validation with invalid input."""
        # Arrange
        invalid_data = None
        
        # Act & Assert
        with pytest.raises(ValueError):
            sut.execute(invalid_data)
    
    def test_should_integrate_with_dependency(self, sut):
        """Test integration with external dependency."""
        # Arrange
        mock_dependency = Mock()
        sut.dependency = mock_dependency
        
        # Act
        sut.execute({{}})
        
        # Assert
        mock_dependency.called_method.assert_called_once()
''',
            description="Test template following Arrange-Act-Assert pattern"
        )
    },
    
    "SERVICE_EXTRACTION": {
        "python": CodeTemplate(
            language="python",
            filename="{entity}_service.py",
            code='''"""
Service layer for {Entity} operations.
Generated by Collider - Standard Model of Code.
"""
from typing import Optional, List


class {Entity}Service:
    """
    Application service for {Entity} domain operations.
    
    This service coordinates business logic and should NOT contain:
    - HTTP handling (that's controller's job)
    - Direct database access (use repositories)
    - UI concerns
    """
    
    def __init__(self, repository: I{Entity}Repository):
        self._repo = repository
    
    def create(self, data: dict) -> {Entity}:
        """Create a new {Entity}."""
        # Validate
        self._validate_create(data)
        
        # Create entity
        entity = {Entity}(**data)
        
        # Persist
        return self._repo.save(entity)
    
    def get(self, id: str) -> Optional[{Entity}]:
        """Get {Entity} by ID."""
        return self._repo.get_by_id(id)
    
    def update(self, id: str, data: dict) -> Optional[{Entity}]:
        """Update existing {Entity}."""
        entity = self._repo.get_by_id(id)
        if not entity:
            return None
        
        # Update fields
        for key, value in data.items():
            setattr(entity, key, value)
        
        return self._repo.save(entity)
    
    def delete(self, id: str) -> bool:
        """Delete {Entity} by ID."""
        return self._repo.delete(id)
    
    def list(self) -> List[{Entity}]:
        """List all {Entity} entities."""
        return self._repo.list_all()
    
    def _validate_create(self, data: dict) -> None:
        """Validate creation data."""
        # TODO: Add validation logic
        if not data:
            raise ValueError("{Entity} data cannot be empty")
''',
            description="Service layer encapsulating business logic"
        )
    },
    
    "CQRS_SEPARATION": {
        "python": CodeTemplate(
            language="python",
            filename="{entity}_cqrs.py",
            code='''"""
CQRS implementation for {Entity}.
Generated by Collider - Standard Model of Code.
"""
from dataclasses import dataclass
from typing import List, Optional


# =============================================================================
# QUERIES (Read operations)
# =============================================================================

@dataclass
class Get{Entity}Query:
    """Query to get single {Entity}."""
    id: str


@dataclass
class List{Entity}Query:
    """Query to list all {Entity} entities."""
    filters: dict = None
    limit: int = 100
    offset: int = 0


class {Entity}QueryHandler:
    """Handles all read operations for {Entity}."""
    
    def __init__(self, read_model):
        self._read_model = read_model
    
    def get(self, query: Get{Entity}Query) -> Optional[{Entity}]:
        return self._read_model.find_by_id(query.id)
    
    def list(self, query: List{Entity}Query) -> List[{Entity}]:
        return self._read_model.find_all(
            filters=query.filters,
            limit=query.limit,
            offset=query.offset
        )


# =============================================================================
# COMMANDS (Write operations)
# =============================================================================

@dataclass
class Create{Entity}Command:
    """Command to create {Entity}."""
    data: dict


@dataclass
class Update{Entity}Command:
    """Command to update {Entity}."""
    id: str
    data: dict


@dataclass
class Delete{Entity}Command:
    """Command to delete {Entity}."""
    id: str


class {Entity}CommandHandler:
    """Handles all write operations for {Entity}."""
    
    def __init__(self, repository, event_bus=None):
        self._repo = repository
        self._events = event_bus
    
    def create(self, command: Create{Entity}Command) -> {Entity}:
        entity = {Entity}(**command.data)
        saved = self._repo.save(entity)
        
        if self._events:
            self._events.publish({Entity}Created(saved))
        
        return saved
    
    def update(self, command: Update{Entity}Command) -> Optional[{Entity}]:
        entity = self._repo.get_by_id(command.id)
        if not entity:
            return None
        
        for key, value in command.data.items():
            setattr(entity, key, value)
        
        saved = self._repo.save(entity)
        
        if self._events:
            self._events.publish({Entity}Updated(saved))
        
        return saved
    
    def delete(self, command: Delete{Entity}Command) -> bool:
        result = self._repo.delete(command.id)
        
        if result and self._events:
            self._events.publish({Entity}Deleted(command.id))
        
        return result
''',
            description="CQRS pattern separating read and write operations"
        )
    },
    
    "GOD_CLASS_DECOMPOSITION": {
        "python": CodeTemplate(
            language="python",
            filename="{class}_components.py",
            code='''"""
Decomposed components from {Class}.
Generated by Collider - Standard Model of Code.

Original god class responsibilities extracted into focused components:
- {Class}QueryHandler: Read operations
- {Class}CommandHandler: Write operations  
- {Class}Validator: Validation logic
- {Class}Facade: Composition of above
"""


class {Class}QueryHandler:
    """Handles query/read operations."""
    
    def get_by_id(self, id: str):
        """Get by ID."""
        pass
    
    def list_all(self):
        """List all items."""
        pass
    
    def search(self, criteria: dict):
        """Search with criteria."""
        pass


class {Class}CommandHandler:
    """Handles command/write operations."""
    
    def create(self, data: dict):
        """Create new item."""
        pass
    
    def update(self, id: str, data: dict):
        """Update existing item."""
        pass
    
    def delete(self, id: str):
        """Delete item."""
        pass


class {Class}Validator:
    """Handles validation logic."""
    
    def validate_create(self, data: dict) -> bool:
        """Validate creation data."""
        pass
    
    def validate_update(self, data: dict) -> bool:
        """Validate update data."""
        pass


class {Class}Facade:
    """
    Facade composing all handlers.
    
    Use this if you need the original interface for backwards compatibility.
    New code should use the specific handlers directly.
    """
    
    def __init__(
        self,
        query_handler: {Class}QueryHandler,
        command_handler: {Class}CommandHandler,
        validator: {Class}Validator
    ):
        self._queries = query_handler
        self._commands = command_handler
        self._validator = validator
    
    # Delegate to appropriate handler
    def get_by_id(self, id: str):
        return self._queries.get_by_id(id)
    
    def create(self, data: dict):
        self._validator.validate_create(data)
        return self._commands.create(data)
''',
            description="God class decomposed into focused single-responsibility components"
        )
    }
}


class FixGenerator:
    """Generates code fixes from insights."""
    
    def __init__(self, language: str = "python"):
        self.language = language
    
    def generate_fix(self, schema_name: str, context: dict = None) -> Optional[CodeTemplate]:
        """
        Generate a code template for an optimization schema.
        
        Args:
            schema_name: Name of the schema (e.g., "REPOSITORY_PATTERN")
            context: Dict with placeholders like {"entity": "User", "Entity": "User"}
        
        Returns:
            CodeTemplate with filled placeholders
        """
        context = context or {}
        
        if schema_name not in TEMPLATES:
            return None
        
        schema_templates = TEMPLATES[schema_name]
        
        if self.language not in schema_templates:
            # Fallback to first available language
            self.language = next(iter(schema_templates.keys()))
        
        template = schema_templates[self.language]
        
        # Fill placeholders
        filled_code = template.code
        filled_filename = template.filename
        
        for key, value in context.items():
            filled_code = filled_code.replace("{" + key + "}", value)
            filled_filename = filled_filename.replace("{" + key + "}", value.lower())
        
        return CodeTemplate(
            language=template.language,
            filename=filled_filename,
            code=filled_code,
            description=template.description
        )
    
    def generate_all_fixes(self, insights: list) -> List[CodeTemplate]:
        """Generate all fixes for a list of insights."""
        fixes = []
        
        for insight in insights:
            if insight.schema:
                # Extract entity name from affected components if possible
                context = {"entity": "Entity", "Entity": "Entity", 
                          "component": "Component", "Component": "Component",
                          "class": "Class", "Class": "Class"}
                
                fix = self.generate_fix(insight.schema, context)
                if fix:
                    fixes.append(fix)
        
        return fixes


def generate_fixes(insights: list, language: str = "python") -> List[CodeTemplate]:
    """
    Convenience function to generate fixes from insights.
    
    Usage:
        from fix_generator import generate_fixes
        
        insights, _ = generate_insights(nodes)
        fixes = generate_fixes(insights)
        for fix in fixes:
            print(f"# {fix.filename}")
            print(fix.code)
    """
    generator = FixGenerator(language)
    return generator.generate_all_fixes(insights)


if __name__ == "__main__":
    # Demo
    generator = FixGenerator("python")
    
    fix = generator.generate_fix("REPOSITORY_PATTERN", {
        "entity": "user",
        "Entity": "User"
    })
    
    if fix:
        print(f"# {fix.filename}")
        print(fix.code)
