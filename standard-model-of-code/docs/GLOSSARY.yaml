# ============================================================================
# GLOSSARY.yaml - Canonical Vocabulary of the Standard Model of Code
# ============================================================================
#
# This is the SINGLE SOURCE OF TRUTH for all domain-specific vocabulary.
#
# STRUCTURE:
#   - category: origin classification
#   - origin: attribution for borrowed terms
#   - project_meaning: how WE use this term
#   - not_to_be_confused_with: disambiguation
#
# CATEGORIES:
#   - original_invention: We created this term (46 terms)
#   - physics_metaphor: Borrowed from physics with new meaning (18 terms)
#   - borrowed_theory: Academic concept with attribution (22 terms)
#   - standard_cs: Conventional CS term (31 terms)
#
# Last updated: 2026-01-24
# Total terms: 122
# ============================================================================

schema_version: "1.0.0"
project: "Standard Model of Code"
maintainer: "Leonardo Lech <leonardo.lech@gmail.com>"

# ============================================================================
# ORIGINAL INVENTIONS (35 terms) - "We Baptized These"
# ============================================================================

terms:

  # ---------------------------------------------------------------------------
  # Architecture & Structure
  # ---------------------------------------------------------------------------

  alien_architecture:
    canonical_name: "Alien Architecture"
    category: original_invention
    introduced:
      version: "0.1.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      The whimsical name for the project's AI-centric development methodology,
      where AI agents are first-class participants in the development process
      with specialized roles and protocols.
    related_terms: [the_triad, agent_school, brain_body_architecture]

  brain_body_architecture:
    canonical_name: "Brain/Body Architecture"
    category: original_invention
    introduced:
      version: "0.2.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      The core organizing principle separating the codebase into two hemispheres:
      - BODY: The Collider analysis engine (standard-model-of-code/)
      - BRAIN: AI tools, context management, cloud integration (context-management/)
    related_terms: [collider, the_triad]

  the_triad:
    canonical_name: "The Triad"
    category: original_invention
    introduced:
      version: "0.3.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      The three specialized AI roles designed for different cognitive tasks:
      1. The Librarian - Exploration and discovery via RAG
      2. The Surgeon - Forensic, line-level verification with citations
      3. The Architect - High-level reasoning with theory context
    related_terms: [the_librarian, the_surgeon, the_architect]

  the_librarian:
    canonical_name: "The Librarian"
    category: original_invention
    introduced:
      version: "0.3.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      AI role specialized for exploration and discovery. Uses RAG (Retrieval-
      Augmented Generation) over indexed codebase to find relevant files,
      patterns, and connections. Best for "where is X?" questions.
    related_terms: [the_triad, analysis_sets]

  the_surgeon:
    canonical_name: "The Surgeon"
    category: original_invention
    introduced:
      version: "0.3.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      AI role specialized for forensic, line-level verification. Provides
      exact citations (file:line) for every claim. Best for validation and
      fact-checking. Never hallucinates - if unsure, says "not found".
    related_terms: [the_triad, line_level_evidence]

  the_architect:
    canonical_name: "The Architect"
    category: original_invention
    introduced:
      version: "0.3.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      AI role specialized for high-level reasoning. Automatically receives
      architectural theory as context. Best for design decisions, trade-off
      analysis, and understanding system-wide implications.
    related_terms: [the_triad, global_topology]

  holographic_socratic_layer:
    canonical_name: "Holographic-Socratic Layer"
    category: original_invention
    introduced:
      version: "0.4.0"
      date: "2026"
      by: "Leonardo Lech"
    definition: |
      Self-maintaining semantic validation system with two properties:
      - HOLOGRAPHIC: Can reconstruct the whole from any part (like a hologram)
      - SOCRATIC: Perpetually questions invariants and assumptions
      Runs as 24/7 guardian detecting drift between docs and implementation.
    related_terms: [antimatter_laws, context_amnesia]

  brain_download:
    canonical_name: "Brain Download"
    category: original_invention
    introduced:
      version: "0.2.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      A structured markdown report (output.md) generated by the Collider tool
      containing the complete analysis of a codebase. Formatted for consumption
      by both humans and LLMs. Contains: Identity, Character (RPBL), Architecture,
      Health Status, Improvements, Visual Reasoning, Domain Context.
    output_file: "output.md"
    related_terms: [collider, rpbl_classification]

  # ---------------------------------------------------------------------------
  # Classification Systems
  # ---------------------------------------------------------------------------

  rpbl_classification:
    canonical_name: "RPBL Classification"
    category: original_invention
    introduced:
      version: "0.2.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      A 4-dimensional behavioral profile for characterizing code health:
      - R: Responsibility (1-9) - How focused is this code's purpose?
      - P: Purity (1-9) - How free of side effects?
      - B: Boundary (1-9) - How well-defined are its interfaces?
      - L: Lifecycle (1-9) - How well-managed is its creation/destruction?
    acronym_expansion: "Responsibility, Purity, Boundary, Lifecycle"
    related_terms: [eight_dimensions, brain_download]

  eight_dimensions:
    canonical_name: "8 Dimensions"
    category: original_invention
    introduced:
      version: "0.1.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      The 8 orthogonal axes used to classify every code particle:
      D1: WHAT (Atom type), D2: LAYER (Architecture), D3: ROLE (Purpose),
      D4: BOUNDARY (Internal/External), D5: STATE (Stateful/Stateless),
      D6: EFFECT (Pure/Effectful), D7: LIFECYCLE (Creation/Destruction),
      D8: TRUST (Trusted/Untrusted)
    inspired_by:
      term: "Faceted Classification"
      author: "S.R. Ranganathan"
    related_terms: [tau_notation, manifold]

  eight_lenses:
    canonical_name: "8 Lenses"
    category: original_invention
    introduced:
      version: "0.1.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      The 8 perspectives for interrogating any code particle:
      1. Identity (What is it called?)
      2. Ontology (What exists?)
      3. Classification (What kind?)
      4. Composition (How structured?)
      5. Relationships (How connected?)
      6. Transformation (What does it do?)
      7. Semantics (What does it mean?)
      8. Epistemology (How certain are we?)
    inspired_by:
      term: "Zachman Framework"
      author: "John Zachman"
    related_terms: [eight_dimensions]

  tau_notation:
    canonical_name: "Tau Notation (τ)"
    category: original_invention
    introduced:
      version: "0.3.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      The canonical notation for representing a particle's 8-dimensional
      classification in a single line. Format: τ(D1, D2, D3, D4, D5, D6, D7, D8)
      Example: τ(Function, Application, Service, Internal, Stateless, Pure, Transient, Trusted)
    related_terms: [eight_dimensions, particle]

  # ---------------------------------------------------------------------------
  # Pipeline & Analysis
  # ---------------------------------------------------------------------------

  analysis_sets:
    canonical_name: "Analysis Sets"
    category: original_invention
    introduced:
      version: "0.3.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      Pre-defined collections of files used as context windows for AI analysis.
      Examples: 'brain' (AI tools), 'body' (Collider engine), 'theory' (docs),
      'complete' (everything). Configured in analysis_sets.yaml.
    config_file: "context-management/config/analysis_sets.yaml"
    related_terms: [the_librarian, context_amnesia]

  unified_node:
    canonical_name: "UnifiedNode"
    category: original_invention
    introduced:
      version: "0.2.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      The canonical Data Transfer Object (DTO) for code nodes in the analysis
      pipeline. Creates a fixed data contract ensuring consistent structure
      regardless of source language or parser.
    related_terms: [unified_edge, codebase_state]

  unified_edge:
    canonical_name: "UnifiedEdge"
    category: original_invention
    introduced:
      version: "0.2.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      The canonical Data Transfer Object (DTO) for relationships between nodes.
      Types: calls, imports, inherits, implements, contains, uses.
    related_terms: [unified_node, codebase_state]

  codebase_state:
    canonical_name: "CodebaseState"
    category: original_invention
    introduced:
      version: "0.2.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      The primary in-memory data management class that holds the complete
      graph representation of a codebase and its indexes for O(1) lookups.
    implementation: "src/core/codebase_state.py"
    related_terms: [unified_node, unified_edge]

  context_amnesia:
    canonical_name: "Context Amnesia"
    category: original_invention
    introduced:
      version: "0.3.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      The problem of standard AI tools lacking a global view of a repository.
      Each conversation starts fresh, losing accumulated understanding.
      The Holographic-Socratic Layer is designed to combat this.
    related_terms: [holographic_socratic_layer, global_topology]

  global_topology:
    canonical_name: "Global Topology"
    category: original_invention
    introduced:
      version: "0.2.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      The complete, interconnected structure of an entire codebase viewed
      as a single graph. Includes all nodes, edges, and their relationships.
    related_terms: [topology_reasoning, context_amnesia]

  line_level_evidence:
    canonical_name: "Line-Level Evidence"
    category: original_invention
    introduced:
      version: "0.3.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      Verifiable, cited facts at the code line number level (file:line).
      A key feature of "The Surgeon" role - every claim must have a citation.
    related_terms: [the_surgeon]

  # ---------------------------------------------------------------------------
  # Modules & Components
  # ---------------------------------------------------------------------------

  semantic_cortex:
    canonical_name: "Semantic Cortex"
    category: original_invention
    introduced:
      version: "0.3.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      Module responsible for domain inference - understanding WHAT business
      domain a codebase represents (e.g., e-commerce, healthcare, fintech).
    implementation: "src/core/semantic_cortex.py"
    related_terms: [topology_reasoning, purpose_field]

  topology_reasoning:
    canonical_name: "Topology Reasoning"
    category: original_invention
    introduced:
      version: "0.2.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      Module responsible for classifying the overall shape of the code graph.
      Detects: Star (central hub), Hierarchical (layers), Mesh (interconnected),
      Islands (disconnected clusters), Layered (clean architecture).
    implementation: "src/core/topology_reasoning.py"
    related_terms: [global_topology, semantic_cortex]

  purpose_field:
    canonical_name: "Purpose Field"
    category: original_invention
    introduced:
      version: "0.4.0"
      date: "2026"
      by: "Leonardo Lech"
    definition: |
      Module/concept for assigning semantic layers and purpose to code.
      Inspired by the Higgs Field in physics - gives "meaning" to otherwise
      meaningless code particles.
    inspired_by:
      term: "Higgs Field"
      field: "particle physics"
    related_terms: [higgs_purpose_field, eight_dimensions]

  knot_detection:
    canonical_name: "Knot Detection"
    category: original_invention
    introduced:
      version: "0.3.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      Analysis computation that finds tangled, circular dependencies in the
      codebase - "knots" that are difficult to untangle and indicate
      architectural problems.
    related_terms: [coupling, topology_reasoning]

  # ---------------------------------------------------------------------------
  # Levels & Hierarchy
  # ---------------------------------------------------------------------------

  level_blindness:
    canonical_name: "Level Blindness"
    category: original_invention
    introduced:
      version: "0.5.0"
      date: "2026-01-23"
      by: "Leonardo Lech"
    definition: |
      The principle that entities operating at one abstraction level
      perceive lower levels only through abstracted interfaces, not
      raw implementation. A System "sees" its Packages as contracts,
      not as collections of bytes. A Function "sees" its calls as
      black boxes, not as token streams.
    key_insight: |
      Not physical blindness (we CAN inspect tokens with debuggers)
      but OPERATIONAL blindness (we CHOOSE not to at runtime).
      This selective ignorance is what makes abstraction useful.
      Each level has its own "umwelt" - its perceived world.
    inspired_by:
      - term: "Flatland"
        author: "Edwin Abbott (1884)"
        insight: "2D beings cannot perceive 3D - dimensional blindness"
      - term: "Umwelt"
        author: "Jakob von Uexkull (1909)"
        insight: "Each organism has its own perceived world"
    not_to_be_confused_with:
      - "Physical impossibility - we CAN inspect lower levels"
      - "Ignorance - this is deliberate, useful abstraction"
    related_terms: [sixteen_levels, abstraction, containment, holon]

  sixteen_levels:
    canonical_name: "16-Level Abstraction Hierarchy"
    category: original_invention
    introduced:
      version: "0.1.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      The containment hierarchy from L-3 (Bit/Qubit) to L12 (Universe).
      Each level CONTAINS lower levels and IS CONTAINED BY higher levels.
      Higher levels represent greater abstraction - hiding details and
      simplifying complexity progressively.

      PHYSICAL ZONE (L-3 to L-1):
        L-3: Bit/Qubit    - Raw binary / quantum state
        L-2: Byte         - 8-bit grouping
        L-1: Character    - Encoded symbol

      SYNTACTIC ZONE (L0):
        L0:  Token        - The "event horizon" where text becomes logic

      SEMANTIC ZONE (L1 to L3):
        L1:  Statement    - Single instruction
        L2:  Block        - Grouped statements
        L3:  Node         - Function/Method (fundamental unit of analysis)

      SYSTEMIC ZONE (L4 to L7):
        L4:  Container    - Class/Struct
        L5:  File         - Source file
        L6:  Package      - Module/directory
        L7:  System       - Service/application

      COSMOLOGICAL ZONE (L8 to L12):
        L8:  Ecosystem    - Framework/runtime
        L9:  Platform     - OS/cloud
        L10: Organization - Company/team
        L11: Domain       - Industry vertical
        L12: Universe     - All software
    inspired_by:
      - term: "Holons"
        author: "Arthur Koestler (1967)"
        insight: "Wholes that are parts - recursive containment"
      - term: "Information Hiding"
        author: "David Parnas (1972)"
        insight: "Modules hide internals = abstraction hierarchy"
      - term: "Layered Architecture"
        field: "Systems Theory"
        insight: "Higher layers abstract lower ones"
    key_insight: |
      Each level transition is an EMERGENCE boundary. The purpose of a higher
      level is emergent from, not merely aggregated from, its parts.
      L3 (Function) is the operational focus - the "atom" of semantic analysis.
    related_terms: [containment, abstraction, holon, holarchy, purpose_field]

  # ---------------------------------------------------------------------------
  # Anti-Patterns & Forensics
  # ---------------------------------------------------------------------------

  timestamp_forensics:
    canonical_name: "Timestamp Forensics"
    category: original_invention
    introduced:
      version: "0.4.0"
      date: "2026"
      by: "Leonardo Lech"
    definition: |
      Analysis technique using file creation/modification times to detect
      AI-induced anti-patterns. Files created and never modified may indicate
      "hollow generation" - AI output that was never refined by humans.
    related_terms: [hollow_generator]

  hollow_generator:
    canonical_name: "Hollow Generator"
    category: original_invention
    introduced:
      version: "0.4.0"
      date: "2026"
      by: "Leonardo Lech"
    definition: |
      AI-specific anti-pattern where a file is created by AI and never
      refined, reviewed, or modified by humans. Detected via timestamp
      forensics (creation_time == modification_time).
    related_terms: [timestamp_forensics]

  the_mirror:
    canonical_name: "The Mirror"
    category: original_invention
    introduced:
      version: "0.3.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      Tool (archive.py mirror) that syncs the local repository to cloud
      storage (GCS) for AI access. Creates a "mirror" of the codebase
      accessible to cloud-based AI tools.
    command: "python context-management/tools/archive/archive.py mirror"
    related_terms: [analysis_sets]

  agent_school:
    canonical_name: "Agent School"
    category: original_invention
    introduced:
      version: "0.4.0"
      date: "2026"
      by: "Leonardo Lech"
    definition: |
      The set of documents and protocols for initiating new AI agents into
      the repository. Includes AGENT_KERNEL.md, AGENT_INITIATION.md, and
      boot scripts that ensure agents understand project conventions.
    location: "context-management/docs/agent_school/"
    related_terms: [the_triad, alien_architecture]

  workflow_factory:
    canonical_name: "Workflow Factory"
    category: original_invention
    introduced:
      version: "0.3.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      System for choosing the right AI tool/tier for a given task.
      Routes simple queries to fast models, complex analysis to powerful models.
    related_terms: [the_triad, analysis_sets]

  ever_was_always_been:
    canonical_name: "Ever Was, Always Been"
    category: original_invention
    introduced:
      version: "1.5.0"
      date: "2026-01-24"
      by: "Leonardo Lech"
    definition: |
      A scaffolding principle for integrating new features into a codebase.
      A feature achieves "ever was, always been" status when it is so seamlessly
      woven into documentation, tooling, onboarding, and configuration that new
      agents perceive it as foundational rather than added. The goal is invisible
      integration - the feature appears native, as if it always existed.
    application: |
      When adding a new subsystem (e.g., commit hygiene):
      1. Update KERNEL.md (non-negotiables, boot protocol)
      2. Register in SUBSYSTEM_INTEGRATION.md
      3. Add to CLAUDE.md (commands, lookup table)
      4. Add cross-references where related concepts appear
      5. Verify with external validation (analyze.py)
    antonym: '"bolted-on" - a feature obviously added later, creating cognitive load'
    related_terms: [agent_school, alien_architecture, brain_body_architecture]

  # ---------------------------------------------------------------------------
  # Law Taxonomy (2026-01-24)
  # ---------------------------------------------------------------------------

  natural_law_of_code:
    canonical_name: "Natural Law of Code"
    category: original_invention
    introduced:
      version: "1.5.0"
      date: "2026-01-24"
      by: "Leonardo Lech"
    definition: |
      A constraint proven by mathematics (information theory, computability,
      thermodynamics) or graph theory that imposes unavoidable cost when violated,
      independent of language, paradigm, culture, resources, or intent.
    recognition_test: |
      1. Is it mathematical/physical? (not social/conventional)
      2. Can you violate it with infinite willpower and resources?
      3. Does it hold if no one knows about it?
      4. Does it operate through mechanism, not coordination?
      If YES to #1, NO to #2, YES to #3 and #4: Natural Law.
    examples:
      - "Kolmogorov bound: Cannot compress below intrinsic complexity"
      - "Landauer's principle: Bit erasure costs >= kT ln 2 energy"
      - "Rice's theorem: Non-trivial semantic properties are undecidable"
      - "Graph centrality: High-degree nodes concentrate risk (topological fact)"
    antonym: roadmap_law
    related_terms: [roadmap_law, moore_law_drift, empirical_law]

  roadmap_law:
    canonical_name: "Roadmap Law"
    category: original_invention
    introduced:
      version: "1.5.0"
      date: "2026-01-24"
      by: "Leonardo Lech"
    definition: |
      A simple empirical trend that becomes a target the ecosystem organizes
      around, thereby extending or shaping the trend through coordination.
      Holds partly because people plan and invest to make it hold.
    recognition_test: |
      If violating the "law" just means "the industry misses its targets,"
      it's a Roadmap Law, not a Natural Law.
    canonical_example: |
      Moore's Law (1965): Gordon Moore observed transistor density doubling
      yearly at minimum cost. The industry turned this into a planning target,
      making it self-fulfilling. It held for 50 years not because physics
      demanded it, but because Intel, TSMC, and others coordinated around it.
    key_insight: |
      Roadmap Laws are Schelling points - coordination mechanisms that work
      because everyone agrees to aim for them. Natural Laws work whether
      anyone agrees or not.
    related_terms: [natural_law_of_code, moore_law_drift, empirical_law]

  moore_law_drift:
    canonical_name: "Moore-Law Drift"
    category: original_invention
    introduced:
      version: "1.5.0"
      date: "2026-01-24"
      by: "Leonardo Lech"
    definition: |
      The antipattern where an observed trend gets promoted to "law" status
      through social coordination and repetition, then mistaken for an
      invariant constraint. Named after Moore's Law, which was a techno-economic
      forecast that became an industry roadmap, not a physical law.
    mechanism: |
      1. Someone observes a trend and makes a prediction
      2. The prediction is named (naming = weaponized compression)
      3. Industry coordinates around the prediction as a target
      4. The trend holds because people make it hold
      5. Longevity promotes it from "trend" to "law" in popular usage
      6. People forget it was ever a prediction
    warning: |
      When hunting Natural Laws of Code, watch for Moore-Law Drift.
      Ask: "Would this hold if the industry stopped believing in it?"
      If NO, it's coordination, not constraint.
    historical_note: |
      The term "Moore's Law" was coined by Carver Mead, not Gordon Moore.
      Moore's original 1965 paper was about minimum cost curves, not
      physical limits. The 18-month cadence is a press misquote; Moore's
      revised (1975) cadence was ~2 years.
    related_terms: [natural_law_of_code, roadmap_law]

  empirical_law:
    canonical_name: "Empirical Law"
    category: original_invention
    introduced:
      version: "1.5.0"
      date: "2026-01-24"
      by: "Leonardo Lech"
    definition: |
      A pattern observed across many systems that holds statistically but
      can be falsified under specific conditions. Between Natural Law
      (unfalsifiable by design) and Heuristic (weak correlation).
    canonical_example: |
      Lehman's Laws of Software Evolution (1974): Eight empirical patterns
      observed in large systems. Laws L1, L6, L7 hold universally. Laws
      L2, L4, L5 were partially falsified by Linux's accelerating growth
      (Godfrey & Tu, 2000).
    key_distinction: |
      Empirical Laws are discovered through observation and can be wrong.
      Natural Laws are proven through mathematics and cannot be violated.
    related_terms: [natural_law_of_code, roadmap_law, lehmans_laws]

  law_surface:
    canonical_name: "Law Surface (5-Tuple)"
    category: original_invention
    introduced:
      version: "1.5.0"
      date: "2026-01-24"
      by: "Leonardo Lech"
    definition: |
      The minimal specification for any candidate law, making it testable
      and implementable. A law is only touchable when all five components
      are defined.
    structure: |
      Law = (Scope, Observable, Perturbation, Prediction, Cost)

      1. SCOPE: Where it should hold
         - Language-agnostic? OO-only? Distributed systems?
         - Static structure? Runtime? Socio-technical?

      2. OBSERVABLE: What you can measure in units
         - Graph: edges, cycles, centrality, cut-points, modularity
         - Information: redundancy, compression, entropy proxies
         - Evolution: churn, change amplification, lead time
         - Outcomes: defects, incidents, rollback rates, MTTR

      3. PERTURBATION: What you can change deliberately
         - Add/remove dependency edge
         - Introduce/break a cycle
         - Split/merge a module boundary
         - Change team boundary (Conway perturbation)

      4. PREDICTION: What should happen if law is real
         - Must be falsifiable, ideally directional + monotonic
         - "If coupling increases, change amplification increases"

      5. COST: What violation exacts
         - Unavoidable (mathematical/physical)
         - Expected (empirical, statistical)
         - Coordination-based (roadmap/Schelling)
    contact_operation: |
      The minimal touch: ΔCause → ΔObservable → ΔCost
      If you can't produce controlled ΔCause, or can't measure ΔObservable,
      or there is no ΔCost, you're not touching a law. You're touching vibes.
    related_terms: [natural_law_of_code, hunt_protocol, evidence_triangle]

  evidence_triangle:
    canonical_name: "Evidence Triangle"
    category: original_invention
    introduced:
      version: "1.5.0"
      date: "2026-01-24"
      by: "Leonardo Lech"
    definition: |
      The three parallel datasets required to validate a candidate law.
      A law becomes touchable when it links all three.
    structure: |
      Dataset 1 — STRUCTURE (static):
        dependency graphs, cycles, centrality, boundaries

      Dataset 2 — EVOLUTION (time):
        git churn, change amplification, ownership, review load

      Dataset 3 — OUTCOMES (cost):
        defects, incidents, rollbacks, lead time, MTTR
    validation_chain: |
      Structure → predicts Evolution → predicts Outcomes

      If it only links Structure → "feels messy," you're above the
      observer horizon (semantic layer), not in law territory.
    why_three: |
      Any two can correlate spuriously. The third breaks degeneracy.
      Structure alone is description. Evolution alone is history.
      Outcomes alone is post-hoc rationalization.
      All three together: causation candidate.
    related_terms: [law_surface, observer_horizon, hunt_protocol]

  observer_effect_taxonomy:
    canonical_name: "Observer Effect Taxonomy"
    category: original_invention
    introduced:
      version: "1.5.0"
      date: "2026-01-24"
      by: "Leonardo Lech"
    definition: |
      Three distinct ways observation can change "the system" in code analysis.
      Conflating them leads to epistemological confusion.
    effects: |
      EFFECT A: Instrumentation Overhead (Physical/Behavioral)
        Adding tracing, profiling, logging changes latency, cache behavior,
        timing-sensitive bugs, performance. The sensor couples to the system.
        Rule: Treat instrumentation as perturbation, not neutral lens.

      EFFECT B: Interpretive Collapse (Semantic)
        Static analysis labels a node "hub" or "bridge." The graph didn't
        change, but meaning collapses from many readings to one shared frame.
        Changes coordination, not bytes.
        Rule: Semantics are co-created; structure is discovered.

      EFFECT C: Goodhart/Governance (Social/Behavioral)
        Metrics on dashboards get optimized. Coverage % → coverage theater.
        Coupling score → gaming the score. Complexity target → move complexity
        to config, ops, or callers. Measurement changes behavior changes thing.
        Rule: Measurement-as-knowledge differs from measurement-as-control.
    key_insight: |
      Observation doesn't change the structure.
      Observation changes the trajectory.
      The instrument becomes part of the system.
    related_terms: [observer_horizon, reflexive_law, goodhart_dynamics]

  reflexive_law:
    canonical_name: "Reflexive Law"
    category: original_invention
    introduced:
      version: "1.5.0"
      date: "2026-01-24"
      by: "Leonardo Lech"
    definition: |
      A law that changes based on whether people know about it and act on it.
      Contrasts with Non-Reflexive (Natural) Laws which hold regardless of belief.
    distinction: |
      NON-REFLEXIVE (Natural Laws):
        Hold even if nobody believes them.
        Topology, information theory, thermodynamics.
        Can be discovered in isolation.

      REFLEXIVE (Goodhart-style):
        Laws of the human+code system, not topology alone.
        Change when measured, incentivized, or targeted.
        Real, but require socio-technical framing.
    examples: |
      Non-reflexive: "Cycles increase minimum reasoning span"
        (True whether you know it or not)

      Reflexive: "Code review coverage correlates with quality"
        (Changes when review becomes a checkbox ritual)
    warning: |
      Reflexive laws aren't "fake." They're laws of a different system.
      The mistake is treating them as topology when they're sociology.
    related_terms: [natural_law_of_code, observer_effect_taxonomy, goodhart_dynamics]

  hunt_protocol:
    canonical_name: "Hunt Protocol"
    category: original_invention
    introduced:
      version: "1.5.0"
      date: "2026-01-24"
      by: "Leonardo Lech"
    definition: |
      The complete methodology for validating candidate Natural Laws of Code.
      Reusable for any claim.
    steps: |
      1. DEFINE O (Observable): "What do we measure?"
      2. DEFINE C (Cost): "What pain metric proves 'real'?"
      3. DEFINE P (Perturbation): "What deliberate change moves O?"
      4. PREDICT: "If law holds, ΔO implies ΔC (direction + shape)"
      5. TEST ON HISTORY: "Does it predict out-of-sample?"
      6. TRY TO BREAK IT: "Find counterexamples; shrink scope if needed"
      7. CLASSIFY:
         - Theorem/Invariant (mathematical proof)
         - Empirical Law (statistical, falsifiable)
         - Roadmap/Coordination Law (Schelling point)
         - Heuristic (weak, context-heavy)
    methodology_rules: |
      - Separate "science mode" from "governance mode"
        Science: measure privately, predict, test on history, don't incentivize
        Governance: once validated, gate/policy — but accept you're shaping reality

      - Pre-register predictions (even informally)
        Write what you predict, what counts as cost, what falsifies it
        BEFORE showing results. Prevents "we saw it therefore it's true."

      - Prefer counterfactuals computable without changing human behavior
        Code advantage: replay git history, analyze past snapshots,
        compare similar modules, run virtual perturbations

      - Use Evidence Triangle (three parallel datasets)
        Structure + Evolution + Outcomes = causation candidate
    disqualification_test: |
      WRONG: "Can you still ship?" (Gravity doesn't prevent walking)
      RIGHT: "Can you violate without ANY measurable cost, over time, across contexts?"

      If cost-free violation is possible: not a constraint.
      If violation only costs elsewhere: constraint-shaped.
      If cost only appears with coordination: roadmap/Schelling mechanism.
    related_terms: [law_surface, evidence_triangle, natural_law_of_code]

  observer_horizon:
    canonical_name: "Observer Horizon"
    category: original_invention
    introduced:
      version: "1.5.0"
      date: "2026-01-24"
      by: "Leonardo Lech"
    definition: |
      The boundary between layers where observation discovers vs. creates.
      Below the horizon: laws operate independently (discovery).
      Above the horizon: observation participates in creation (invention).
    layers: |
      BELOW HORIZON (Discovery):
        Physical layer (bytes): Unchanged by observation
        Structural layer (graph): Discovered, not created

      ABOVE HORIZON (Co-creation):
        Semantic layer (meaning): Co-created, interpretive
        Behavioral layer (future): Changed by observation, agency
    implication: |
      True Natural Laws must live below the observer horizon.
      Claims about "meaning" or "quality" are above it — observer-dependent.

      The Collider sits AT the horizon:
        - Discovering what's below (topology)
        - Enabling what's above (interpretation, action)
    related_terms: [observer_effect_taxonomy, reflexive_law, natural_law_of_code]

  # ---------------------------------------------------------------------------
  # Visualization
  # ---------------------------------------------------------------------------

  token_resolver:
    canonical_name: "TokenResolver"
    category: original_invention
    introduced:
      version: "0.3.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      Singleton class responsible for resolving design tokens for visualization.
      Maps semantic token names to actual CSS values.
    pattern: "Singleton"
    related_terms: [appearance_engine]

  appearance_engine:
    canonical_name: "AppearanceEngine"
    category: original_invention
    introduced:
      version: "0.3.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      Module in visualization architecture responsible for visual styling
      of nodes and edges based on their classification and metrics.
    pattern: "Strategy"
    related_terms: [token_resolver, controls_engine]

  controls_engine:
    canonical_name: "ControlsEngine"
    category: original_invention
    introduced:
      version: "0.3.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      Module in visualization architecture responsible for user interface
      controls (sliders, toggles, buttons) in the visualization.
    related_terms: [appearance_engine]

# ============================================================================
# PHYSICS METAPHORS (18 terms) - "Borrowed from Physics"
# ============================================================================

  standard_model_of_code:
    canonical_name: "Standard Model of Code"
    category: physics_metaphor
    origin:
      term: "Standard Model"
      field: "particle physics"
      coined_by: "Abraham Pais & Sam Treiman"
      year: 1975
      note: "Steven Weinberg claims earlier use in 1973"
    project_meaning: |
      The overarching theoretical framework treating code analysis like
      particle physics - finding the fundamental "particles" (atoms) that
      make up all software, their properties, and their interactions.
    not_to_be_confused_with:
      - term: "Standard Model (physics)"
        distinction: "The physics theory describes actual subatomic particles"

  collider:
    canonical_name: "Collider"
    category: physics_metaphor
    origin:
      term: "Particle Collider"
      field: "particle physics"
      example: "Large Hadron Collider (LHC) at CERN"
      year: 1957
      note: "First collider: Stanford Mark III, 1957"
    project_meaning: |
      The primary analysis tool that "smashes" code to reveal its constituent
      parts. Takes a codebase as input, produces unified_analysis.json,
      output.md (Brain Download), and collider_report.html (visualization).
    command: "./collider full <path> --output <dir>"
    previous_name: "Spectrometer"
    related_terms: [spectrometer, brain_download]

  spectrometer:
    canonical_name: "Spectrometer"
    category: physics_metaphor
    origin:
      term: "Spectrometer"
      field: "physics/chemistry"
      note: "Instrument for measuring properties of light spectra"
    project_meaning: |
      DEPRECATED. Original name for the Collider tool, reflecting intent
      to analyze the "spectrum" of code types. Renamed to Collider for
      better metaphorical fit.
    deprecated: true
    deprecated_date: "2025-06"
    replacement: "collider"

  particle:
    canonical_name: "Particle"
    category: physics_metaphor
    origin:
      term: "Particle"
      field: "physics"
      note: "General term for subatomic matter"
    project_meaning: |
      A raw code unit after parsing but before full classification.
      A function, class, or method that has been extracted from source
      but not yet assigned its full dimensional coordinates.
    related_terms: [atom, unified_node]

  atom:
    canonical_name: "Atom"
    category: physics_metaphor
    origin:
      term: "Atom"
      field: "physics/chemistry"
      coined_by: "Democritus"
      year: "~400 BCE"
      etymology: "Greek 'atomos' = uncuttable"
      revived_by: "John Dalton"
      revived_year: 1808
    project_meaning: |
      The smallest classified semantic unit of code. The "element" in our
      Periodic Table of Code. Examples: Function, Class, Method, Module.
      Each atom has properties defined by the 8 Dimensions.
    not_to_be_confused_with:
      - term: "Atomic operation"
        distinction: "Different concept - refers to indivisible transactions"
    related_terms: [particle, hadron]

  hadron:
    canonical_name: "Hadron"
    category: physics_metaphor
    origin:
      term: "Hadron"
      field: "particle physics"
      coined_by: "Louis Rosenfeld"
      year: 1962
      etymology: "Greek 'hadros' = thick, heavy"
      note: "Composite particles made of quarks (e.g., protons, neutrons)"
    project_meaning: |
      A composite code structure made of multiple atoms. A canonical
      data structure that groups related code elements together.
    related_terms: [atom, quark]

  quark:
    canonical_name: "Quark"
    category: physics_metaphor
    origin:
      term: "Quark"
      field: "particle physics"
      coined_by: "Murray Gell-Mann"
      year: 1964
      etymology: "From James Joyce's Finnegans Wake: 'Three quarks for Muster Mark'"
    project_meaning: |
      A sub-element of an atom - the smallest meaningful code fragment.
      Statements, expressions, tokens that make up a function or class.
    related_terms: [atom, hadron]

  antimatter:
    canonical_name: "Antimatter"
    category: physics_metaphor
    origin:
      term: "Antimatter"
      field: "particle physics"
      predicted_by: "Paul Dirac"
      year: 1928
      term_coined_by: "Arthur Schuster"
      term_year: 1898
    project_meaning: |
      Forbidden code patterns - architectural violations that should not
      exist. When detected, indicates a problem (like matter meeting
      antimatter causes annihilation). Examples: LayerSkipViolation,
      ReverseLayerDependency, GodClass, AnemicModel.
    related_terms: [antimatter_laws, holographic_socratic_layer]

  antimatter_laws:
    canonical_name: "Antimatter Laws"
    category: physics_metaphor
    origin:
      derived_from: "antimatter"
    project_meaning: |
      The set of architectural invariants that define what constitutes
      "antimatter" (forbidden patterns). Violations are detected and
      reported. Currently 5 laws: AM001-AM005.
    schema_file: "schema/antimatter_laws.yaml"
    related_terms: [antimatter]

  fermion:
    canonical_name: "Fermion"
    category: physics_metaphor
    origin:
      term: "Fermion"
      field: "particle physics"
      named_after: "Enrico Fermi"
      coined_by: "Paul Dirac"
      year: 1945
      note: "Particles with half-integer spin, obey Pauli Exclusion Principle"
    project_meaning: |
      Code elements that are stateful and unique - like entities in DDD.
      Two fermions cannot occupy the same state (each entity has unique
      identity). Contrasted with Bosons (stateless, interchangeable).
    related_terms: [boson, entity]

  boson:
    canonical_name: "Boson"
    category: physics_metaphor
    origin:
      term: "Boson"
      field: "particle physics"
      named_after: "Satyendra Nath Bose"
      coined_by: "Paul Dirac"
      year: 1945
      note: "Particles with integer spin, can occupy same state"
    project_meaning: |
      Code elements that are stateless and interchangeable - like services.
      Multiple bosons can occupy the same state (services are fungible).
      Act as "force carriers" coordinating work between entities.
    related_terms: [fermion, service]

  manifold:
    canonical_name: "Manifold"
    category: physics_metaphor
    origin:
      term: "Manifold"
      field: "mathematics/physics"
      note: "A topological space that locally resembles Euclidean space"
    project_meaning: |
      The 8-dimensional space where every code particle has a coordinate.
      Each particle's position in this manifold is described by Tau notation.
    related_terms: [eight_dimensions, tau_notation]

  mass:
    canonical_name: "Mass (Code)"
    category: physics_metaphor
    origin:
      term: "Mass"
      field: "physics"
      note: "Resistance to acceleration, measure of matter"
    project_meaning: |
      A metaphor for code complexity - "resistance to change". High-mass
      code is difficult to modify, refactor, or understand.
    related_terms: [energy_code, black_hole]

  energy_code:
    canonical_name: "Energy (Code)"
    category: physics_metaphor
    origin:
      term: "Energy"
      field: "physics"
      note: "Capacity to do work"
    project_meaning: |
      A metaphor for code execution or the "intent" that makes things happen.
      Static code has potential energy; running code has kinetic energy.
    related_terms: [mass]

  black_hole:
    canonical_name: "Black Hole (Code)"
    category: physics_metaphor
    origin:
      term: "Black Hole"
      field: "astrophysics"
      popularized_by: "John Wheeler"
      year: 1967
    project_meaning: |
      A metaphor for a "God Class" that has immense gravitational pull
      (high coupling). Everything depends on it, nothing escapes its
      influence. A critical architectural smell.
    related_terms: [god_class, coupling]

  dark_matter:
    canonical_name: "Dark Matter (Code)"
    category: physics_metaphor
    origin:
      term: "Dark Matter"
      field: "astrophysics"
      coined_by: "Fritz Zwicky"
      year: 1933
    project_meaning: |
      A metaphor for undocumented or invisible code that still has
      gravitational (dependency) effect on the system. Code that exists
      but isn't visible in the primary analysis.
    related_terms: [orphan_node]

  wormhole:
    canonical_name: "Wormhole (Code)"
    category: physics_metaphor
    origin:
      term: "Wormhole"
      field: "theoretical physics"
      note: "Hypothetical passage through spacetime"
    project_meaning: |
      A metaphor for a well-defined interface (like an API contract) that
      connects two otherwise separate systems ("Holons") without exposing
      their internal complexity.
    related_terms: [holon, boundary]

  higgs_purpose_field:
    canonical_name: "Higgs/Purpose Field"
    category: physics_metaphor
    origin:
      term: "Higgs Field"
      field: "particle physics"
      predicted_by: "Peter Higgs et al."
      year: 1964
      note: "Field that gives particles their mass"
    project_meaning: |
      A theoretical concept in our model - a field that gives "meaning"
      (semantic purpose) to otherwise meaningless code particles. The
      Purpose Field module implements this idea.
    related_terms: [purpose_field]

# ============================================================================
# BORROWED THEORIES (22 terms) - "Standing on Giants"
# ============================================================================

  holon:
    canonical_name: "Holon"
    category: borrowed_theory
    origin:
      term: "Holon"
      field: "systems theory"
      coined_by: "Arthur Koestler"
      year: 1967
      work: "The Ghost in the Machine"
      definition: "A system that is simultaneously a whole and a part"
    project_meaning: |
      A software system viewed as both complete in itself AND a component
      of a larger system. Every module is a holon - self-contained yet
      part of the application.
    related_terms: [holarchy]

  holarchy:
    canonical_name: "Holarchy"
    category: borrowed_theory
    origin:
      term: "Holarchy"
      field: "systems theory"
      coined_by: "Arthur Koestler"
      year: 1967
      work: "The Ghost in the Machine"
      definition: "A hierarchy of holons"
    project_meaning: |
      The nested, self-similar structure of a codebase where each level
      (function → class → module → package → system) is both a whole
      and a part of something larger.
    related_terms: [holon, sixteen_levels]

  three_worlds:
    canonical_name: "Three Worlds / 3 Planes"
    category: borrowed_theory
    origin:
      term: "Three Worlds"
      field: "philosophy of science"
      coined_by: "Karl Popper"
      year: 1972
      work: "Objective Knowledge: An Evolutionary Approach"
    project_meaning: |
      Every code entity exists in all 3 planes simultaneously:
      1. PHYSICAL: Bytes on storage
      2. VIRTUAL: Symbols and structure
      3. SEMANTIC: Meaning and intent
    related_terms: [eight_dimensions]

  map_territory:
    canonical_name: "Map vs Territory"
    category: borrowed_theory
    origin:
      term: "Map-Territory Relation"
      field: "general semantics"
      coined_by: "Alfred Korzybski"
      year: 1933
      work: "Science and Sanity"
      quote: "The map is not the territory"
    project_meaning: |
      Core epistemic stance: Our model (the "map") is not the code itself
      (the "territory"). The unified_analysis.json is a representation,
      not the actual codebase.
    related_terms: [epistemology_lens]

  faceted_classification:
    canonical_name: "Faceted Classification"
    category: borrowed_theory
    origin:
      term: "Faceted Classification"
      field: "library and information science"
      coined_by: "S.R. Ranganathan"
      year: 1933
      work: "The Colon Classification"
    project_meaning: |
      The method of organizing by multiple independent facets (dimensions)
      rather than a single hierarchy. Direct inspiration for our 8 Dimensions -
      each dimension is an independent facet.
    related_terms: [eight_dimensions]

  systemic_functional_linguistics:
    canonical_name: "Systemic Functional Linguistics"
    category: borrowed_theory
    origin:
      term: "Systemic Functional Linguistics"
      field: "linguistics"
      coined_by: "M.A.K. Halliday"
      year: 1978
      work: "Language as Social Semiotic"
    project_meaning: |
      Theory of simultaneous "metafunctions" in language. Directly inspired
      our 8 Dimensions - every code element simultaneously fulfills multiple
      functional roles (ideational, interpersonal, textual).
    related_terms: [eight_dimensions]

  constructal_law:
    canonical_name: "Constructal Law"
    category: borrowed_theory
    origin:
      term: "Constructal Law"
      field: "thermodynamics/engineering"
      coined_by: "Adrian Bejan"
      year: 1996
      work: "Journal of Advanced Transportation"
      statement: "For a flow system to persist, it must evolve to provide easier access to its currents"
    project_meaning: |
      Explains why codebases self-organize into hierarchical structures.
      Like river deltas, code evolves to minimize friction in the "flow"
      of data and control.
    related_terms: [holarchy, topology_reasoning]

  information_theory:
    canonical_name: "Information Theory / Entropy"
    category: borrowed_theory
    origin:
      term: "Information Entropy"
      field: "information theory"
      coined_by: "Claude Shannon"
      year: 1948
      work: "A Mathematical Theory of Communication"
      journal: "Bell System Technical Journal"
    project_meaning: |
      Used to measure code complexity and unpredictability. High-entropy
      code is harder to understand; low-entropy code is more predictable.
    related_terms: [complexity_density]

  category_theory:
    canonical_name: "Category Theory"
    category: borrowed_theory
    origin:
      term: "Category Theory"
      field: "mathematics"
      coined_by: "Samuel Eilenberg & Saunders Mac Lane"
      year: 1945
      work: "General Algebra, Annals of Mathematics"
    project_meaning: |
      Used to formalize the concept of "pure functions" as morphisms
      between objects. A pure function is a morphism that preserves
      structure without side effects.
    related_terms: [purity, effect_dimension]

  nature_of_order:
    canonical_name: "The Nature of Order / Centers"
    category: borrowed_theory
    origin:
      term: "Centers"
      field: "architecture theory"
      coined_by: "Christopher Alexander"
      year: 2002
      work: "The Nature of Order (4 volumes)"
    project_meaning: |
      Theory of "living structures" composed of mutually reinforcing "centers".
      Used to explain code cohesion - good modules have strong centers that
      reinforce each other.
    related_terms: [cohesion, pattern_language]

  pattern_language:
    canonical_name: "Pattern Language"
    category: borrowed_theory
    origin:
      term: "Pattern Language"
      field: "architecture theory"
      coined_by: "Christopher Alexander"
      year: 1977
      work: "A Pattern Language: Towns, Buildings, Construction"
    project_meaning: |
      Inspiration for software design patterns. A vocabulary of reusable
      solutions. Our Atom catalog is a pattern language for code structures.
    related_terms: [nature_of_order, atom]

  vitruvian_triad:
    canonical_name: "Vitruvian Triad"
    category: borrowed_theory
    origin:
      term: "Firmitas, Utilitas, Venustas"
      field: "classical architecture"
      coined_by: "Vitruvius"
      year: "~15 BCE"
      work: "De Architectura"
      translation: "Strength, Utility, Beauty"
    project_meaning: |
      Mapped to code quality dimensions:
      - Firmitas (Strength) → Robustness, error handling
      - Utilitas (Utility) → Functionality, correctness
      - Venustas (Beauty) → Readability, elegance
    related_terms: [rpbl_classification]

  linnaean_taxonomy:
    canonical_name: "Linnaean Taxonomy"
    category: borrowed_theory
    origin:
      term: "Linnaean Taxonomy"
      field: "biology"
      coined_by: "Carl Linnaeus"
      year: 1735
      work: "Systema Naturae"
    project_meaning: |
      Inspiration for our 16-Level containment hierarchy. Like Kingdom →
      Phylum → Class → Species, we have Universe → Domain → System → Function.
    related_terms: [sixteen_levels]

  ooda_loop:
    canonical_name: "OODA Loop"
    category: borrowed_theory
    origin:
      term: "OODA Loop"
      field: "military strategy"
      coined_by: "John Boyd"
      year: 1976
      work: "Patterns of Conflict (briefing)"
      expansion: "Observe, Orient, Decide, Act"
    project_meaning: |
      Analogy for the M-I-P-O (Memory-Input-Process-Output) fractal pattern
      we observe in code at all levels. Every function is a mini-OODA loop.
    related_terms: [transformation_lens]

  critical_rationalism:
    canonical_name: "Critical Rationalism"
    category: borrowed_theory
    origin:
      term: "Critical Rationalism"
      field: "philosophy of science"
      coined_by: "Karl Popper"
      year: 1934
      work: "The Logic of Scientific Discovery"
    project_meaning: |
      Core epistemic stance: theories must be falsifiable. Our classifications
      are hypotheses that can be proven wrong. We prefer "Unknown" over
      false certainty.
    related_terms: [confidence_levels, epistemology_lens]

  clean_architecture:
    canonical_name: "Clean Architecture"
    category: borrowed_theory
    origin:
      term: "Clean Architecture"
      field: "software engineering"
      coined_by: "Robert C. Martin (Uncle Bob)"
      year: 2012
      work: "Blog post 'The Clean Architecture'"
      book: "Clean Architecture: A Craftsman's Guide (2017)"
    project_meaning: |
      One of the architectural patterns we detect and validate. Layers:
      Entities → Use Cases → Controllers → Frameworks. Dependency rule:
      inner layers know nothing of outer layers.
    related_terms: [layer_dimension, antimatter_laws]

  domain_driven_design:
    canonical_name: "Domain-Driven Design (DDD)"
    category: borrowed_theory
    origin:
      term: "Domain-Driven Design"
      field: "software engineering"
      coined_by: "Eric Evans"
      year: 2003
      work: "Domain-Driven Design: Tackling Complexity in the Heart of Software"
    project_meaning: |
      Concepts we borrow: Entity, Value Object, Aggregate, Repository,
      Service, Bounded Context. Our Role dimension maps to DDD tactical
      patterns.
    acronym: "DDD"
    related_terms: [entity, repository, service]

  cqrs:
    canonical_name: "CQRS"
    category: borrowed_theory
    origin:
      term: "CQRS"
      field: "software architecture"
      coined_by: "Greg Young"
      year: 2010
      expansion: "Command Query Responsibility Segregation"
    project_meaning: |
      Pattern we detect in Role classification. Queries (read) and Commands
      (write) should be separate. Violation of this is an antimatter smell.
    related_terms: [query_role, command_role]

# ============================================================================
# STANDARD CS TERMS (31 terms) - "Conventional Vocabulary"
# ============================================================================

  pagerank:
    canonical_name: "PageRank"
    category: standard_cs
    origin:
      term: "PageRank"
      field: "computer science / information retrieval"
      invented_by: "Larry Page, Sergey Brin"
      year: 1998
      work: "The PageRank Citation Ranking: Bringing Order to the Web"
      institution: "Stanford University"
    project_meaning: |
      Standard graph algorithm used to rank node importance. We use it to
      identify the most "important" functions/classes in a codebase based
      on how many other nodes depend on them.
    related_terms: [hub, topology_reasoning]

  coupling:
    canonical_name: "Coupling"
    category: standard_cs
    origin:
      term: "Coupling"
      field: "software engineering"
      coined_by: "Larry Constantine"
      year: 1974
      work: "Structured Design (with Ed Yourdon)"
    project_meaning: |
      Standard metric: degree of interdependence between modules. Low
      coupling is desirable. Measured via edge analysis.
    related_terms: [cohesion, black_hole]

  cohesion:
    canonical_name: "Cohesion"
    category: standard_cs
    origin:
      term: "Cohesion"
      field: "software engineering"
      coined_by: "Larry Constantine"
      year: 1974
      work: "Structured Design (with Ed Yourdon)"
    project_meaning: |
      Standard metric: degree to which elements of a module belong together.
      High cohesion is desirable. Measured via internal relationship density.
    related_terms: [coupling, nature_of_order]

  cyclomatic_complexity:
    canonical_name: "Cyclomatic Complexity"
    category: standard_cs
    origin:
      term: "Cyclomatic Complexity"
      field: "software engineering"
      invented_by: "Thomas J. McCabe"
      year: 1976
      work: "A Complexity Measure"
      journal: "IEEE Transactions on Software Engineering"
    project_meaning: |
      Standard metric: number of linearly independent paths through code.
      Higher = more complex = harder to test. We compute this per function.
    related_terms: [complexity_density]

  abstract_syntax_tree:
    canonical_name: "Abstract Syntax Tree (AST)"
    category: standard_cs
    origin:
      term: "Abstract Syntax Tree"
      field: "computer science / compilers"
      emerged: "1960s"
      note: "No single inventor; evolved from compiler theory"
    project_meaning: |
      Standard tree representation of parsed source code. Our analysis
      starts with AST extraction via Tree-sitter. Nodes in the AST become
      particles in our model.
    acronym: "AST"
    related_terms: [tree_sitter, particle]

  tree_sitter:
    canonical_name: "Tree-sitter"
    category: standard_cs
    origin:
      term: "Tree-sitter"
      field: "software engineering"
      created_by: "Max Brunsfeld (GitHub)"
      year: 2018
    project_meaning: |
      Standard parser generator library we use for AST extraction. Supports
      incremental parsing and multiple languages with unified API.
    implementation: "src/core/tree_sitter_engine.py"
    related_terms: [abstract_syntax_tree]

  dead_code:
    canonical_name: "Dead Code"
    category: standard_cs
    origin:
      term: "Dead Code"
      field: "software engineering"
      note: "Standard industry term"
    project_meaning: |
      Standard concept: unreachable or unused code. We detect this via
      graph analysis - nodes with no incoming edges (except entry points).
    related_terms: [orphan_node]

  orphan_node:
    canonical_name: "Orphan Node"
    category: standard_cs
    origin:
      term: "Orphan"
      field: "graph theory"
      note: "Standard term for disconnected node"
    project_meaning: |
      Node with no incoming or outgoing edges. May indicate dead code,
      entry point, or external API. We classify orphans by "codome boundary"
      to explain WHY they appear disconnected.
    related_terms: [dead_code, codome_boundary]

  hub:
    canonical_name: "Hub"
    category: standard_cs
    origin:
      term: "Hub"
      field: "network theory"
      note: "Standard term from scale-free network research"
    project_meaning: |
      Standard concept: central node with many connections. In code, a
      function or class that many others depend on. High in-degree = hub.
    related_terms: [pagerank, black_hole]

  god_class:
    canonical_name: "God Class"
    category: standard_cs
    origin:
      term: "God Class"
      field: "software engineering"
      note: "Standard anti-pattern term"
    project_meaning: |
      Standard anti-pattern: class that knows too much or does too much.
      We detect via size metrics + high coupling. Metaphorically a "black hole".
    related_terms: [black_hole, antimatter]

# ============================================================================
# Additional standard CS terms (abbreviated for length)
# ============================================================================

  rag:
    canonical_name: "RAG"
    category: standard_cs
    acronym_expansion: "Retrieval-Augmented Generation"
    origin:
      year: 2020
      coined_by: "Facebook AI Research (Lewis et al.)"
    project_meaning: "Mechanism used by The Librarian for context retrieval"

  dto:
    canonical_name: "DTO"
    category: standard_cs
    acronym_expansion: "Data Transfer Object"
    origin:
      coined_by: "Martin Fowler"
      work: "Patterns of Enterprise Application Architecture"
    project_meaning: "Pattern used for UnifiedNode and UnifiedEdge"

  singleton:
    canonical_name: "Singleton Pattern"
    category: standard_cs
    origin:
      work: "Design Patterns: Elements of Reusable Object-Oriented Software"
      year: 1994
      authors: "Gang of Four (Gamma, Helm, Johnson, Vlissides)"
    project_meaning: "Pattern used by TokenResolver"

  facade:
    canonical_name: "Facade Pattern"
    category: standard_cs
    origin:
      work: "Design Patterns: Elements of Reusable Object-Oriented Software"
      year: 1994
    project_meaning: "Pattern used by TreeSitterUniversalEngine"

  strategy:
    canonical_name: "Strategy Pattern"
    category: standard_cs
    origin:
      work: "Design Patterns: Elements of Reusable Object-Oriented Software"
      year: 1994
    project_meaning: "Pattern used by AppearanceEngine"

# ============================================================================
# METADATA
# ============================================================================

# ============================================================================
# MISSING ORIGINAL INVENTIONS (4 more)
# ============================================================================

  twelve_stage_pipeline:
    canonical_name: "12-Stage Full Analysis Pipeline"
    category: original_invention
    introduced:
      version: "0.2.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      The specific named pipeline that performs complete codebase analysis.
      Stages 1-6: Unified Analysis (parsing to graph)
      Stages 7-12: Full Analysis (enrichment and semantics)
    implementation: "src/core/full_analysis.py"
    related_terms: [unified_analysis, full_analysis]

  unified_analysis:
    canonical_name: "Unified Analysis"
    category: original_invention
    introduced:
      version: "0.2.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      Stages 1-6 of the pipeline: File Discovery, AST Parsing, Symbol Extraction,
      Atom Classification, Role Detection, Dependency Extraction. Produces the
      base graph structure.
    related_terms: [twelve_stage_pipeline, full_analysis]

  full_analysis:
    canonical_name: "Full Analysis"
    category: original_invention
    introduced:
      version: "0.2.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      Stages 7-12 of the pipeline: Metrics Computation, Topology Analysis,
      Graph Construction, PageRank, Community Detection, Antimatter Detection,
      Report Generation, Visualization. Adds semantic enrichment.
    related_terms: [twelve_stage_pipeline, unified_analysis]

  execution_flow:
    canonical_name: "Execution Flow"
    category: original_invention
    introduced:
      version: "0.3.0"
      date: "2025"
      by: "Leonardo Lech"
    definition: |
      Module for identifying entry points and orphans in the codebase.
      Traces how execution flows through the call graph.
    implementation: "src/core/execution_flow.py"
    related_terms: [orphan_node, topology_reasoning]

  # ---------------------------------------------------------------------------
  # Codespace, Codome, Landscape, Topology (2026-01-23)
  # ---------------------------------------------------------------------------

  codespace:
    canonical_name: "Codespace"
    category: original_invention
    introduced:
      version: "0.5.0"
      date: "2026-01-23"
      by: "Leonardo Lech"
    definition: |
      The geometric space in which all code exists. NOT Euclidean.
      Codespace has unique geometric properties:
      - HYPERBOLIC: Exponentially expanding (hierarchies grow outward)
      - FRACTAL: Self-similar at all scales
      - NON-EUCLIDEAN: Distances don't add simply (A→B + B→C ≠ A→C)
      - FOLDED: Layers intersect and overlap
      - TUNNELED: Wormholes (events, callbacks) connect distant regions
      - CAVERNOUS: Hidden complexity behind simple interfaces
    key_insight: |
      Codespace is ASYMMETRIC:
      - DOWN: Hard bedrock (bits, qubits, physics) - cannot go below
      - UP: Theoretically unlimited abstraction
      The physical world is the FLOOR. We build UP from it, abstracting
      complexity and increasing purpose alignment at each level.
    not_to_be_confused_with:
      - "GitHub Codespaces (cloud dev environment)"
      - "Simple 3D Euclidean space"
    related_terms: [codome, landscape, sixteen_levels]

  codome:
    canonical_name: "Codome"
    category: original_invention
    introduced:
      version: "0.5.0"
      date: "2026-01-23"
      by: "Leonardo Lech"
    definition: |
      A bounded region of Codespace containing a single codebase with
      defined boundaries. The "genome" of a codebase - its complete
      genetic/structural information.

      Defined by the Survey (Stage 0) which answers:
      1. IDENTITY: What IS this system?
      2. BOUNDARIES: Where does it START and END?
      3. NATURE: What is the TEXTURE?
      4. POLLUTION: What VIOLATES the physics?
      5. ADAPTATION: How must instruments be calibrated?
    etymology: |
      Blend of "code" + "-ome" (suffix meaning "complete set of", as in
      genome, proteome, microbiome). The codome is the complete structural
      definition of a codebase.
    related_terms: [codespace, landscape, survey]
    spec_doc: "docs/specs/CODOME_BOUNDARY_DEFINITION.md"

  landscape:
    canonical_name: "Landscape"
    category: original_invention
    introduced:
      version: "0.5.0"
      date: "2026-01-23"
      by: "Leonardo Lech"
    definition: |
      The navigable topological surface of a Codome. What humans traverse
      when exploring code. The EXPERIENCE of code structure.

      Landscape features:
      - ELEVATION: Complexity height (peaks = god classes, valleys = clean code)
      - GRADIENT: How fast complexity changes (cliffs = abstraction leaks)
      - REGIONS: Bounded territories (modules, domains)
      - PATHS: Dependency routes (how to get from A to B)
      - HOLES: Topological voids (cycles, gaps)
      - CAVES: Hidden complexity behind interfaces
      - WORMHOLES: Non-local connections (events, callbacks)
    key_distinction: |
      TOPOLOGY = How we COMPUTE it (Betti numbers, homology, math)
      LANDSCAPE = How we EXPERIENCE it (terrain, navigation, intuition)
    related_terms: [topology, codome, codespace]
    spec_doc: "docs/specs/CODOME_LANDSCAPE.md"

  topology:
    canonical_name: "Topology (Code)"
    category: physics_metaphor
    origin:
      term: "Topology"
      field: "mathematics"
      etymology: "Greek 'topos' (place) + 'logos' (study)"
      note: "Study of properties preserved under continuous deformation"
    project_meaning: |
      The mathematical structure of the code Landscape. Computed via
      topological data analysis methods:

      BETTI NUMBERS:
      - b₀: Connected components (islands in the codome)
      - b₁: Independent cycles (circular dependencies)
      - b₂: Voids (architectural gaps)

      EULER CHARACTERISTIC: χ = b₀ - b₁ + b₂

      PERSISTENT HOMOLOGY: Features that persist across scales

      HOMEOMORPHISM: Valid refactoring preserves topology
    key_distinction: |
      TOPOLOGY = How we COMPUTE it (math, invariants)
      LANDSCAPE = How we EXPERIENCE it (terrain, navigation)
    not_to_be_confused_with:
      - "topology_reasoning.py (module that computes connectivity patterns)"
      - "Network topology (physical network layout)"
    related_terms: [landscape, betti_numbers, euler_characteristic]

  archetype:
    canonical_name: "Archetype"
    category: original_invention
    introduced:
      version: "0.5.0"
      date: "2026-01-23"
      by: "Leonardo Lech"
    definition: |
      The organizational form of a Codome - its MACRO shape as a container.
      Detected by Survey (Stage 0).

      Values:
      - MONOLITH: Single unified codebase
      - MONOREPO: Multiple packages in one repository
      - MICROSERVICES: Distributed service architecture
      - LIBRARY: Reusable package for consumption
      - CLI: Command-line tool
    key_distinction: |
      ARCHETYPE = What KIND of building (L10 Organization)
      TOPOLOGY/LANDSCAPE = What's the TERRAIN inside (L7 System)

      Archetype CONSTRAINS possible topologies:
      - Monolith → Single connected landmass
      - Microservices → Archipelago (islands)
      - Monorepo → Continent with distinct regions
    not_to_be_confused_with:
      - "Topology (internal structure)"
      - "Architecture patterns (MVC, DDD)"
    related_terms: [topology, landscape, survey]

  betti_numbers:
    canonical_name: "Betti Numbers"
    category: borrowed_theory
    origin:
      term: "Betti Numbers"
      field: "algebraic topology"
      named_after: "Enrico Betti"
      year: 1871
      formalized_by: "Henri Poincaré"
    project_meaning: |
      Topological invariants counting holes of different dimensions:

      b₀ = Connected components (islands)
           → b₀ = 1: Fully connected codebase
           → b₀ > 1: Isolated islands exist

      b₁ = Independent cycles (loops)
           → b₁ = 0: No circular dependencies
           → b₁ > 0: Cycles exist (potential problems)

      b₂ = Voids (cavities)
           → Architectural gaps

      Health target: b₀ = 1, b₁ ≤ N/10 (where N = module count)
    related_terms: [topology, euler_characteristic, persistent_homology]

  euler_characteristic:
    canonical_name: "Euler Characteristic"
    category: borrowed_theory
    origin:
      term: "Euler Characteristic"
      field: "topology"
      named_after: "Leonhard Euler"
      year: 1752
      formula: "χ = V - E + F (vertices - edges + faces)"
    project_meaning: |
      Single number summarizing topological structure:

      χ = b₀ - b₁ + b₂

      For code:
      - Healthy layered system: χ ≈ number of layers
      - Problematic system: χ negative (more holes than components)
    related_terms: [betti_numbers, topology]

  persistent_homology:
    canonical_name: "Persistent Homology"
    category: borrowed_theory
    origin:
      term: "Persistent Homology"
      field: "topological data analysis"
      developed: "Early 2000s"
      key_paper: "Edelsbrunner et al., 2002"
    project_meaning: |
      Technique tracking topological features across multiple scales.

      At different scales (ε):
      - ε = 0.1: Function-level dependencies
      - ε = 0.5: Module-level patterns
      - ε = 1.0: System-wide architecture

      Features that PERSIST across scales = Real architecture
      Features that appear at single scale = Noise

      Used to separate architectural truth from implementation details.
    related_terms: [betti_numbers, topology, landscape]

  spatialization:
    canonical_name: "Spatialization"
    category: borrowed_theory
    origin:
      term: "Spatialization"
      field: "information visualization / data science"
      note: "Academic term for transforming semantic data into spatial representations"
      references:
        - "Graph spatialization in information visualization"
        - "Visual metaphors for representing complex data"
    project_meaning: |
      The academic term for what the Standard Model of Code does:
      transforming semantic code data into navigable spatial representations.

      The Collider tool spatializes a codebase by:
      1. Parsing code into a graph structure
      2. Computing topological properties
      3. Projecting into 3D space via force-directed layout
      4. Applying visual encodings (color, size, shape)

      The result is a "map" of code that can be navigated spatially.
    key_insight: |
      Standard Model of Code is a "meta-language with DSL characteristics"
      that performs spatialization. It sits between raw code and human
      understanding, transforming complex structures into navigable space.
    related_terms: [landscape, visualization, meta_language]

  meta_language:
    canonical_name: "Meta-Language"
    category: borrowed_theory
    origin:
      term: "Meta-language"
      field: "linguistics / formal methods"
      note: "A language used to describe or analyze another language"
      references:
        - "Tarski (1936) - distinction between object language and metalanguage"
        - "Domain-Specific Languages in software engineering"
    project_meaning: |
      Classification of what the Standard Model of Code IS:
      a meta-language for describing and analyzing code structure.

      Like how:
      - BNF is a meta-language for describing grammar
      - UML is a meta-language for describing software design
      - Mathematical notation is a meta-language for describing relations

      Standard Model of Code is a meta-language for describing
      the structural, semantic, and topological properties of codebases.

      More precisely: "A meta-language with DSL characteristics" -
      it has both the descriptive power of a meta-language and the
      focused vocabulary of a domain-specific language.
    not_to_be_confused_with:
      - "Programming languages (these are object languages, not meta-languages)"
      - "Natural language (too imprecise for formal analysis)"
    related_terms: [spatialization, atom, eight_dimensions]

  entity_stratification:
    canonical_name: "Entity Stratification"
    category: borrowed_theory
    origin:
      term: "Multi-level Modeling"
      field: "software engineering / metamodeling"
      references:
        - "Atkinson & Kühne (2001) - The Essence of Multilevel Metamodeling"
        - "Clabject concept in OCA, Melanee frameworks"
    project_meaning: |
      The principle that entities in the 16-level hierarchy are not
      fixed particles at single levels, but FIELDS spanning multiple
      levels with varying intensity.

      Key concepts:
      - CLABJECT: An entity that is simultaneously a class AND an instance
        at different levels. A Service class (L4) is an instance of "Service
        pattern" (L6) and a class for ServiceInstances (L3).

      - POTENCY: How many levels down an entity's properties remain active.
        Potency-2 means properties cascade 2 levels down.

      - FIELD NATURE: Entities are wave functions, not particles. They have
        "probability distributions" across levels, not fixed positions.

      This resolves the apparent paradox: how can a Function be at L3
      while also participating in L7 (System) patterns? Answer: it's a
      field with different manifestations at each level.
    key_insight: |
      Entity stratification explains emergence: the whole (L7 System) is
      more than the sum of its parts (L3 Functions) because entities
      SPAN levels, creating cross-level correlations that pure aggregation
      cannot capture.
    related_terms: [sixteen_levels, holon, holarchy, emergence]

  emergence:
    canonical_name: "Emergence"
    category: borrowed_theory
    origin:
      term: "Emergence"
      field: "philosophy of science / complexity theory"
      references:
        - "Mill (1843) - British Emergentists"
        - "Bedau (1997) - Weak vs Strong Emergence"
        - "Holland (1998) - Emergence in Complex Adaptive Systems"
    project_meaning: |
      The principle that higher-level properties arise from but are not
      reducible to lower-level components.

      In the Standard Model:
      - The PURPOSE of L7 (System) is emergent from L3 (Functions)
      - NOT merely aggregated FROM the parts
      - But ARISING THROUGH their interactions

      Two types:
      - WEAK EMERGENCE: Unpredictable from parts but realized through
        their interactions. (Mainstream scientific view)
      - STRONG EMERGENCE: Irreducible, with genuine downward causation.
        (Controversial, minority position)

      Our definition aligns with WEAK emergence: system-level purpose
      emerges from organized interactions of lower-level components,
      but is still grounded in those components.
    key_insight: |
      Each level transition in the 16-level hierarchy is an EMERGENCE
      boundary. The purpose of a higher level is emergent from, not
      merely aggregated from, its parts.
    not_to_be_confused_with:
      - "Aggregation (simple summing of properties)"
      - "Composition (lifecycle coupling without new properties)"
    related_terms: [sixteen_levels, entity_stratification, holon]

# ============================================================================
# MISSING BORROWED THEORIES (7 more)
# ============================================================================

  containment:
    canonical_name: "Containment"
    category: borrowed_theory
    origin:
      term: "Containment"
      field: "systems theory / UML"
      note: "Structural relationship in hierarchical systems"
      references:
        - "UML/Enterprise Architect - requirement grouping"
        - "Containment Domains (UT Austin, 2011)"
        - "Containment Units (ACM, 2002)"
    project_meaning: |
      A structural relationship where a container element ENCLOSES child
      elements, forming nested hierarchies. Each level CONTAINS the levels
      below it. Distinct from composition (lifecycle binding) and aggregation
      (weak reference). In our model, containment is the primary organizing
      principle: Package contains Files contains Classes contains Functions.
    not_to_be_confused_with:
      - composition: "Strong has-a with shared lifecycle"
      - aggregation: "Weak has-a with independent lifecycle"
      - inheritance: "is-a relationship (subtyping)"
    related_terms: [sixteen_levels, holon, holarchy]

  abstraction:
    canonical_name: "Abstraction"
    category: borrowed_theory
    origin:
      term: "Abstraction"
      field: "computer science"
      definition: "Hiding implementation details to focus on essential features"
      references:
        - "Parnas (1972) - Information Hiding"
        - "Liskov (1987) - Data Abstraction"
    project_meaning: |
      The progressive hiding of details as you move up the containment hierarchy.
      Higher levels abstract lower levels by ignoring their implementation details.
      L0 (Token) exposes raw syntax; L7 (System) abstracts entire subsystems.
      Each level transition represents an increase in abstraction.
    key_insight: |
      In the Standard Model, abstraction and containment are linked:
      higher containment = higher abstraction. A System abstracts its Packages,
      which abstract their Files, which abstract their Classes, etc.
    related_terms: [sixteen_levels, containment, information_hiding]

  information_hiding:
    canonical_name: "Information Hiding"
    category: borrowed_theory
    origin:
      term: "Information Hiding"
      field: "software engineering"
      coined_by: "David Parnas"
      year: 1972
      work: "On the Criteria To Be Used in Decomposing Systems into Modules"
    project_meaning: |
      The principle that modules should hide internal details behind stable
      interfaces. Foundation of abstraction hierarchies - each level hides
      the complexity of levels below it.
    related_terms: [abstraction, containment, encapsulation]

  semiotics:
    canonical_name: "Semiotics"
    category: borrowed_theory
    origin:
      term: "Semiotics"
      field: "linguistics/philosophy"
      founders: "Ferdinand de Saussure, Charles Sanders Peirce"
      year: "1900s"
    project_meaning: |
      Study of signs - relationship between Signifier (code syntax) and
      Signified (code meaning). We analyze code as a sign system.
    related_terms: [three_worlds]

  generative_grammar:
    canonical_name: "Generative Grammar"
    category: borrowed_theory
    origin:
      term: "Generative Grammar"
      field: "linguistics"
      coined_by: "Noam Chomsky"
      year: 1957
      work: "Syntactic Structures"
    project_meaning: |
      Theory that language is generated by recursive rules. Analogy for
      how code syntax is generated from grammar rules (BNF, Tree-sitter).
    related_terms: [abstract_syntax_tree]

  phylogenetics:
    canonical_name: "Phylogenetics"
    category: borrowed_theory
    origin:
      term: "Phylogenetics"
      field: "biology"
      note: "Study of evolutionary relationships"
    project_meaning: |
      Used as analogy for code evolution - how codebases fork, merge,
      and evolve over time. Git history as phylogenetic tree.
    related_terms: [linnaean_taxonomy]

  code_is_law:
    canonical_name: "Code is Law"
    category: borrowed_theory
    origin:
      term: "Code is Law"
      field: "cyberlaw"
      coined_by: "Lawrence Lessig"
      year: 1999
      work: "Code and Other Laws of Cyberspace"
    project_meaning: |
      Framing a codebase as a legal system with a "constitution" (architecture),
      "laws" (invariants), and "violations" (antimatter).
    related_terms: [antimatter_laws]

# ============================================================================
# MISSING STANDARD CS TERMS (16 more)
# ============================================================================

  graph:
    canonical_name: "Graph"
    category: standard_cs
    origin:
      term: "Graph"
      field: "mathematics/computer science"
      note: "Fundamental data structure"
    project_meaning: |
      Data structure of nodes and edges representing the codebase.
      We use directed graphs where nodes are code entities and edges
      are relationships (calls, imports, inherits).

  node:
    canonical_name: "Node"
    category: standard_cs
    origin:
      term: "Node"
      field: "graph theory"
    project_meaning: |
      A vertex in the graph; a code entity like a function, class, or module.
      Synonym: Particle (before classification), UnifiedNode (after).

  edge:
    canonical_name: "Edge"
    category: standard_cs
    origin:
      term: "Edge"
      field: "graph theory"
    project_meaning: |
      A connection between nodes representing a relationship.
      Types: calls, imports, inherits, implements, contains, uses.

  pipeline:
    canonical_name: "Pipeline"
    category: standard_cs
    origin:
      term: "Pipeline"
      field: "software engineering"
    project_meaning: |
      Series of data processing stages. Our 12-stage pipeline transforms
      source code into analyzed graph with metrics and reports.

  schema:
    canonical_name: "Schema"
    category: standard_cs
    origin:
      term: "Schema"
      field: "database/data modeling"
    project_meaning: |
      Formal definition of a data structure. We have schemas for nodes
      (particle.schema.json), edges, and output formats.

  api:
    canonical_name: "API"
    category: standard_cs
    acronym_expansion: "Application Programming Interface"
    project_meaning: "Standard meaning - interface for programmatic access"

  cli:
    canonical_name: "CLI"
    category: standard_cs
    acronym_expansion: "Command-Line Interface"
    project_meaning: "The ./collider command interface"

  linter:
    canonical_name: "Linter"
    category: standard_cs
    origin:
      term: "Lint"
      coined_by: "Stephen C. Johnson"
      year: 1978
      note: "Named after lint (fabric fibers)"
    project_meaning: |
      Static code analysis tool. Collider is a superset of a linter -
      it analyzes structure, not just style.

  refactoring:
    canonical_name: "Refactoring"
    category: standard_cs
    origin:
      term: "Refactoring"
      field: "software engineering"
      popularized_by: "Martin Fowler"
      year: 1999
      work: "Refactoring: Improving the Design of Existing Code"
    project_meaning: "Standard meaning - restructuring code without changing behavior"

  dependency:
    canonical_name: "Dependency"
    category: standard_cs
    project_meaning: |
      Standard concept - when one module requires another. We track
      dependencies as edges in the graph.

  inheritance:
    canonical_name: "Inheritance"
    category: standard_cs
    project_meaning: |
      OOP concept - deriving a class from another. We track via
      'inherits' edge type.

  polymorphism:
    canonical_name: "Polymorphism"
    category: standard_cs
    project_meaning: |
      OOP concept - same interface, different implementations.
      Metaphorically: "quantum superposition" of implementations.
    related_terms: [quantum_superposition]

  memoization:
    canonical_name: "Memoization"
    category: standard_cs
    project_meaning: |
      Caching technique for function results. Used in our analysis
      for performance optimization.

  networkx:
    canonical_name: "NetworkX"
    category: standard_cs
    origin:
      created_by: "Aric Hagberg, Dan Schult, Pieter Swart"
      year: 2004
    project_meaning: |
      Python graph analysis library we use for PageRank, betweenness
      centrality, and other graph algorithms.

  betweenness_centrality:
    canonical_name: "Betweenness Centrality"
    category: standard_cs
    origin:
      term: "Betweenness Centrality"
      field: "network analysis"
      coined_by: "Linton Freeman"
      year: 1977
    project_meaning: |
      Graph metric measuring how often a node lies on shortest paths.
      High betweenness = critical bridge/bottleneck.

  microservices:
    canonical_name: "Microservices"
    category: standard_cs
    project_meaning: |
      Architectural pattern - small, independent services. One of
      the topology shapes we detect.

  side_effects:
    canonical_name: "Side Effects"
    category: standard_cs
    origin:
      field: "functional programming"
    project_meaning: |
      Operations that modify state outside their scope. Captured in
      D6: EFFECT dimension (Pure vs Effectful).
    related_terms: [purity, effect_dimension]

# ============================================================================
# METADATA
# ============================================================================

statistics:
  total_terms: 111
  original_inventions: 35
  physics_metaphors: 18
  borrowed_theories: 27
  standard_cs: 31
  coverage: "100%"

version_history:
  - version: "1.1.0"
    date: "2026-01-23"
    author: "Leonardo Lech + Claude"
    changes: |
      Added 5 new borrowed_theory terms from Phase 10 research:
      - spatialization: Academic term for what SMoC does
      - meta_language: Classification of SMoC as a meta-language
      - entity_stratification: Multi-level modeling concepts (clabjects, potency)
      - emergence: Weak vs strong emergence, level transitions
      - (existing terms updated with cross-references)
  - version: "1.0.0"
    date: "2026-01-21"
    author: "Leonardo Lech + Claude"
    changes: "Initial comprehensive glossary with full attribution"
