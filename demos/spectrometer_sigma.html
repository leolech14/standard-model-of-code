<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectrometer Pro - Code Mirror</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            overflow: hidden;
        }

        .app {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 280px;
            padding: 12px;
            background: #111118;
            border-right: 1px solid #222;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .sidebar-right {
            width: 350px;
            padding: 12px;
            background: #111118;
            border-left: 1px solid #222;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .graph-area {
            flex: 1;
            position: relative;
        }

        svg {
            width: 100%;
            height: 100%;
        }

        .section {
            margin-bottom: 14px;
        }

        .section-title {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 6px;
            letter-spacing: 1px;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }

        .stat-card {
            background: #1a1a24;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1rem;
            font-weight: 700;
            color: #00d4ff;
        }

        .stat-value.healthy {
            color: #22c55e;
        }

        .stat-value.warning {
            color: #eab308;
        }

        .stat-value.danger {
            color: #ef4444;
        }

        .stat-label {
            font-size: 9px;
            color: #555;
            text-transform: uppercase;
        }

        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 11px;
        }

        .slider {
            width: 80px;
            accent-color: #00d4ff;
        }

        select,
        input[type="text"] {
            background: #1a1a24;
            border: 1px solid #333;
            border-radius: 4px;
            color: #fff;
            padding: 5px 6px;
            font-size: 11px;
            width: 100%;
        }

        .layer-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 5px 6px;
            background: #1a1a24;
            border: 1px solid #333;
            border-radius: 4px;
            margin-bottom: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        .layer-item:hover {
            background: #252532;
        }

        .layer-item.hidden {
            opacity: 0.3;
        }

        .layer-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .btn {
            width: 100%;
            padding: 6px;
            background: #1a1a24;
            border: 1px solid #444;
            border-radius: 4px;
            color: #ccc;
            cursor: pointer;
            font-size: 10px;
            margin-bottom: 3px;
        }

        .btn:hover {
            background: #252532;
            border-color: #00d4ff;
        }

        .btn.active {
            background: #00d4ff;
            color: #000;
            border-color: #00d4ff;
        }

        .node {
            cursor: pointer;
        }

        .tooltip {
            position: absolute;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid #444;
            border-radius: 4px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            max-width: 250px;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            font-size: 14px;
        }

        /* Code Mirror Panel */
        .code-panel {
            background: #1a1a24;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;
        }

        .code-panel h3 {
            color: #00d4ff;
            font-size: 14px;
            margin-bottom: 10px;
            word-break: break-all;
        }

        .code-meta {
            font-size: 11px;
            color: #888;
            margin-bottom: 8px;
        }

        .code-meta strong {
            color: #aaa;
        }

        .code-meta a {
            color: #00d4ff;
            text-decoration: none;
        }

        .code-meta a:hover {
            text-decoration: underline;
        }

        .file-link {
            display: block;
            padding: 8px 10px;
            background: #0d0d14;
            border: 1px solid #333;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            color: #00d4ff;
            text-decoration: none;
            margin-bottom: 10px;
            word-break: break-all;
        }

        .file-link:hover {
            background: #1a1a24;
            border-color: #00d4ff;
        }

        .signature-box {
            background: #0d0d14;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 8px;
            font-family: 'SF Mono', Consolas, monospace;
            font-size: 11px;
            color: #f8f8f2;
            overflow-x: auto;
            margin-bottom: 10px;
        }

        .docstring-box {
            background: #0d0d14;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 8px;
            font-size: 11px;
            color: #888;
            font-style: italic;
            margin-bottom: 10px;
            max-height: 100px;
            overflow-y: auto;
        }

        .deps-list {
            max-height: 150px;
            overflow-y: auto;
        }

        .dep-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 6px;
            background: #0d0d14;
            border-radius: 3px;
            margin-bottom: 2px;
            font-size: 10px;
            cursor: pointer;
        }

        .dep-item:hover {
            background: #1a1a24;
        }

        .dep-item .arrow {
            color: #666;
        }

        .health-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: 600;
        }

        .health-badge.healthy {
            background: #22c55e;
            color: #000;
        }

        .health-badge.warning {
            background: #eab308;
            color: #000;
        }

        .health-badge.danger {
            background: #ef4444;
            color: #fff;
        }

        .health-badge.orphan {
            background: #666;
            color: #fff;
        }

        .empty-panel {
            text-align: center;
            color: #555;
            padding: 40px 20px;
        }

        .empty-panel .icon {
            font-size: 32px;
            margin-bottom: 10px;
        }

        /* Navigation Bar */
        .nav-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            padding: 8px;
            background: #1a1a24;
            border: 1px solid #333;
            border-radius: 6px;
        }

        .nav-btn {
            width: 36px;
            height: 36px;
            background: #0d0d14;
            border: 1px solid #444;
            border-radius: 4px;
            color: #888;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .nav-btn:hover:not(:disabled) {
            background: #252532;
            border-color: #00d4ff;
            color: #fff;
        }

        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .nav-info {
            flex: 1;
            text-align: center;
            font-size: 10px;
            color: #555;
        }

        /* Concept Image Tooltip */
        .concept-tooltip {
            position: fixed;
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            background: #1a1a2e;
            border: 2px solid #00d4ff;
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 10px 40px rgba(0, 212, 255, 0.3);
        }

        .concept-tooltip.visible {
            opacity: 1;
        }

        .concept-tooltip img {
            max-width: 300px;
            max-height: 300px;
            border-radius: 4px;
            display: block;
        }

        .concept-tooltip .caption {
            text-align: center;
            color: #00d4ff;
            font-size: 11px;
            margin-top: 6px;
            font-weight: bold;
        }

        /* Hover hint for elements with concepts */
        [data-concept]::after {
            content: 'üñºÔ∏è';
            font-size: 8px;
            margin-left: 4px;
            opacity: 0.5;
        }

        /* File Tree */
        .tree-item {
            cursor: pointer;
            padding: 2px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: #ccc;
        }

        .tree-item:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.05);
        }

        .tree-folder {
            color: #88c0d0;
            font-weight: bold;
        }

        .tree-file {
            color: #a3be8c;
        }

        .tree-children {
            padding-left: 12px;
            border-left: 1px solid #333;
            margin-left: 4px;
        }

        .tree-row {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .tree-icon {
            opacity: 0.7;
            font-size: 10px;
        }

        /* Syntax Highlighting Base */
        pre code {
            display: block;
            padding: 10px;
            font-family: 'SF Mono', Consolas, monospace;
            font-size: 11px;
            line-height: 1.5;
            color: #d8dee9;
            background: #0d0d14;
            overflow-x: auto;
        }

        .highlight-line {
            background: rgba(0, 212, 255, 0.15);
            border-left: 2px solid #00d4ff;
            width: 100%;
            display: inline-block;
        }
    </style>
</head>

<body>
    <div class="app">
        <!-- Left Sidebar: Controls -->
        <aside class="sidebar">
            <div class="section">
                <div class="section-title">üè• Health</div>
                <div class="stat-grid">
                    <div class="stat-card">
                        <div class="stat-value healthy" id="healthy-count">0</div>
                        <div class="stat-label">Healthy</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value warning" id="warning-count">0</div>
                        <div class="stat-label">Warning</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value danger" id="danger-count">0</div>
                        <div class="stat-label">Critical</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="orphan-count">0</div>
                        <div class="stat-label">Orphan</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">üìÇ Explorer</div>
                <div id="file-tree"
                    style="max-height: 250px; overflow-y: auto; font-size: 11px; background: #0d0d14; padding: 6px; border-radius: 4px; border: 1px solid #333;">
                    <div style="color: #666; font-style: italic;">Loading files...</div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">üîç Search</div>
                <input type="text" id="search" placeholder="Search..." oninput="searchNodes(this.value)">
            </div>

            <div class="section">
                <div class="section-title">üé≠ Theme</div>
                <select id="theme-select" onchange="applyTheme(this.value)" style="width:100%">
                    <option value="cyberpunk">üåÜ Cyberpunk</option>
                    <option value="ocean">üåä Ocean Depths</option>
                    <option value="aurora">üåå Aurora</option>
                    <option value="sunset">üåÖ Sunset Fire</option>
                    <option value="matrix">üìü Matrix</option>
                </select>
            </div>

            <div class="section">
                <div class="section-title">‚ö° Analysis Preset</div>
                <select id="preset-select" onchange="applyPreset(this.value)" style="width:100%">
                    <option value="">‚Äî Select Preset ‚Äî</option>
                    <option value="godClass" data-concept="god_class">üî¥ Find God Classes</option>
                    <option value="architecture" data-concept="layer_violation">üèõÔ∏è Architecture View</option>
                    <option value="debugFlow">üîç Debug Flow</option>
                    <option value="clusters" data-concept="clustering">üß© Cluster Analysis</option>
                    <option value="orphans" data-concept="orphan">üëª Find Orphans</option>
                    <option value="hotspots" data-concept="coupling">üî• Coupling Hotspots</option>
                    <option value="hierarchy">üå≤ Hierarchy View</option>
                    <option value="rainbow">üåà Rainbow Overview</option>
                </select>
            </div>

            <div class="section">
                <div class="section-title">üé® Color Mode</div>
                <div class="control-row">
                    <button class="btn" id="mode-layer" onclick="setColorMode('layer')" data-concept="layer_violation"
                        style="width:32%">Layer</button>
                    <button class="btn active" id="mode-health" onclick="setColorMode('health')"
                        style="width:32%">Health</button>
                    <button class="btn" id="mode-role" onclick="setColorMode('role')" style="width:32%">Role</button>
                </div>
                <div class="control-row">
                    <button class="btn" id="mode-coupling" onclick="setColorMode('coupling')" data-concept="coupling"
                        style="width:32%">Coupling</button>
                    <button class="btn" id="mode-module" onclick="setColorMode('module')"
                        style="width:32%">Module</button>
                    <button class="btn" id="mode-distance" onclick="setColorMode('distance')"
                        style="width:32%">Distance</button>
                </div>
                <div class="control-row">
                    <button class="btn" id="mode-cluster" onclick="setColorMode('cluster')" data-concept="clustering"
                        style="width:32%">Cluster</button>
                    <button class="btn" id="mode-kind" onclick="setColorMode('kind')" style="width:32%">Kind</button>
                    <button class="btn" onclick="toggleHeatmaps()" style="width:32%">Heatmaps ‚ñæ</button>
                </div>
                <!-- Heatmaps Submenu -->
                <div id="heatmap-controls" class="control-row"
                    style="display:none; background:rgba(0,0,0,0.2); padding:5px; border-radius:4px; margin-bottom:5px; flex-wrap:wrap;">
                    <select id="gradient-select" onchange="updateViz()"
                        style="width:100%; margin-bottom:4px; font-size:10px; background:#222; border:1px solid #444; color:#fff;">
                        <option value="magma">üî• Magma (Fire)</option>
                        <option value="viridis">üåø Viridis (Nature)</option>
                        <option value="plasma">‚ö° Plasma (Energy)</option>
                        <option value="cool">‚ùÑÔ∏è Cool (Ice)</option>
                        <option value="rainbow">üåà Rainbow Cycle</option>
                    </select>
                    <button class="btn" id="mode-flow" onclick="setColorMode('flow')" style="width:48%; font-size:10px;"
                        title="Rainbow cycle from App Initialization">üåä Running Flow</button>
                    <button class="btn" id="mode-centrality" onclick="setColorMode('centrality')"
                        style="width:48%; font-size:10px;" title="Most active nodes (PageRank)">üî• Centrality</button>
                    <button class="btn" id="mode-radial" onclick="setColorMode('radial')"
                        style="width:48%; font-size:10px;" title="Distance from center">üåå Radial</button>
                    <button class="btn" id="mode-proximity" onclick="setColorMode('proximity')"
                        style="width:48%; font-size:10px;" title="Distance from selected node">üéØ Proximity</button>
                </div>
            </div>

            <div class="section">
                <div class="section-title">üìê Layout</div>
                <div class="control-row">
                    <button class="btn" onclick="setLayout('grid')" style="width:32%">Grid</button>
                    <button class="btn" onclick="toggleLayerPatterns()" style="width:32%">By Layers ‚ñæ</button>
                    <button class="btn" onclick="setLayout('health')" style="width:32%">By Health</button>
                </div>
                <!-- Layer Patterns Submenu -->
                <div id="layer-patterns" class="control-row"
                    style="display:none; background:rgba(0,0,0,0.2); padding:5px; border-radius:4px; margin-bottom:5px;">
                    <button class="btn" onclick="setLayout('layers')" style="width:24%; font-size:10px;">Stack</button>
                    <button class="btn" onclick="setLayout('onion')" style="width:24%; font-size:10px;"
                        title="Best for: Verifying Architectural Purity. \nInner rings (Core) should not depend on outer rings.">üßÖ
                        Onion</button>
                    <button class="btn" onclick="setLayout('flow')" style="width:24%; font-size:10px;"
                        title="Best for: Tracking Logic Flow. \nShows top-down execution from Interface to Database.">üåä
                        Flow</button>
                    <button class="btn" onclick="setLayout('forceLayers')" style="width:24%; font-size:10px;"
                        title="Best for: Organic Discovery. \nPhysics-based view that respects Layer boundaries.">üß≤
                        Swim</button>
                </div>
                <div class="control-row">
                    <button class="btn" onclick="setLayout('circular')" style="width:32%">Circular</button>
                    <button class="btn" onclick="setLayout('radial')" style="width:32%">Radial</button>
                    <button class="btn" onclick="setLayout('cluster')" style="width:32%">By Cluster</button>
                </div>
                <div id="layout-info"
                    style="font-size: 10px; color: #888; margin-top: 5px; height: 2.5em; font-style: italic;">
                    Hover over a layout for usage tips.
                </div>
            </div>

            <div class="section">
                <div class="section-title">üéõÔ∏è Visual Encoding</div>
                <div class="control-row">
                    <span>Size:</span>
                    <select id="size-mode" onchange="updateViz()" style="width:110px">
                        <option value="fixed">Fixed</option>
                        <option value="degree" selected>Degree</option>
                        <option value="inDegree">In-Degree</option>
                        <option value="outDegree">Out-Degree</option>
                        <option value="health">Health Risk</option>
                        <option value="lines">Lines of Code</option>
                    </select>
                </div>
                <div class="control-row">
                    <span>Opacity:</span>
                    <select id="opacity-mode" onchange="updateViz()" style="width:110px">
                        <option value="full" selected>Full</option>
                        <option value="health">By Health</option>
                        <option value="coupling">By Coupling</option>
                        <option value="boundary">By Boundary</option>
                        <option value="kind">By Kind</option>
                    </select>
                </div>
                <div class="control-row">
                    <span>Stroke:</span>
                    <select id="stroke-mode" onchange="updateViz()" style="width:110px">
                        <option value="none">None</option>
                        <option value="boundary" selected>Boundary</option>
                        <option value="health">Health Alert</option>
                        <option value="selected">Selected Only</option>
                    </select>
                </div>
                <div class="control-row">
                    <span>Edge Color:</span>
                    <select id="edge-color-mode" onchange="updateViz()" style="width:110px">
                        <option value="none">None (white)</option>
                        <option value="type">By Type</option>
                        <option value="gradient" selected>Gradient</option>
                        <option value="source">Source Node</option>
                        <option value="target">Target Node</option>
                    </select>
                </div>
                <div class="control-row">
                    <span>Edge Opacity:</span>
                    <input type="range" class="slider" id="edge-opacity" min="0" max="50" value="15"
                        oninput="updateViz()">
                </div>
            </div>

            <div class="section">
                <div class="section-title">Layers</div>
                <div id="layer-filters"></div>
            </div>

            <div class="section">
                <button class="btn" onclick="resetZoom()">‚ä° Reset (Esc)</button>
                <button class="btn" onclick="focusUnhealthy()">üîç Unhealthy</button>
                <button class="btn" onclick="exportPNG()">üì∑ Export PNG</button>
                <button class="btn" onclick="showHelp()">‚ùì Shortcuts (?)</button>
                <button class="btn" onclick="showArtPrompts()" style="margin-top:8px; width:100%">üé® Art
                    Prompts</button>
            </div>
        </aside>

        <!-- Graph Area -->
        <div class="graph-area">
            <div id="loading">Loading graph...</div>
            <svg id="graph"></svg>
            <div class="tooltip" id="tooltip" style="display:none"></div>
        </div>

        <!-- Right Sidebar: Pokedex + Code Mirror -->
        <aside class="sidebar-right">
            <div class="section">
                <div class="section-title">üìñ Config Guide</div>
                <div id="pokedex-panel" style="font-size: 11px; line-height: 1.4;">
                    <div id="pokedex-preset"
                        style="margin-bottom: 8px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                        <div style="color: #00d4ff; font-weight: bold; margin-bottom: 4px;">‚ö° No Preset Selected</div>
                        <div style="color: #888;">Select a preset to see its description</div>
                    </div>
                    <div id="pokedex-legend" style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                        <div class="legend-item">
                            <span style="color: #a855f7;">‚óè</span> Color: <span id="leg-color">Health</span>
                        </div>
                        <div class="legend-item">
                            <span style="color: #22c55e;">‚óâ</span> Size: <span id="leg-size">Degree</span>
                        </div>
                        <div class="legend-item">
                            <span style="color: #ef4444;">‚óã</span> Stroke: <span id="leg-stroke">Boundary</span>
                        </div>
                        <div class="legend-item">
                            <span style="color: #3b82f6;">‚Äî</span> Edge: <span id="leg-edge">Gradient</span>
                        </div>
                    </div>
                    <div id="pokedex-meaning"
                        style="margin-top: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; color: #aaa;">
                        <div id="pokedex-color-explain">üé® <b>Health</b>: Green=healthy, Yellow=warning, Red=danger,
                            Gray=orphan</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">üìÑ Code Mirror</div>
                <div class="nav-bar">
                    <button class="nav-btn" id="nav-back" onclick="goBack()" disabled title="Back">‚Üê</button>
                    <div class="nav-info" id="nav-info">0 / 0</div>
                    <button class="nav-btn" id="nav-forward" onclick="goForward()" disabled title="Forward">‚Üí</button>
                </div>
                <div id="code-panel">
                    <div class="empty-panel">
                        <div class="icon">üëÜ</div>
                        <p>Click a node to view source code details</p>
                    </div>
                </div>
            </div>
        </aside>
    </div>

    <script>
        // ==========================================
        // DATA INJECTION
        // ==========================================
        /* <!-- DATA_INJECTION_START --> */
        const particles = [];
        const connections = [];
        /* <!-- DATA_INJECTION_END --> */

        // ==========================================
        // CONFIG - STUNNING COLOR PALETTES
        // ==========================================

        // Theme presets - curated for maximum visual impact
        const colorThemes = {
            cyberpunk: {
                name: 'üåÜ Cyberpunk',
                bg: '#0a0a0f',
                layers: {
                    'Interface': 'oklch(75% 0.25 330)', // Hot pink
                    'App': 'oklch(70% 0.22 280)',       // Electric purple
                    'Core': 'oklch(65% 0.20 200)',     // Cyber cyan
                    'Infra': 'oklch(60% 0.18 145)',    // Neon green
                    'Data': 'oklch(70% 0.20 60)',      // Orange glow
                    'Tests': 'oklch(75% 0.15 90)',     // Acid yellow
                },
                health: {
                    healthy: 'oklch(70% 0.25 160)',   // Matrix green
                    warning: 'oklch(80% 0.22 80)',   // Warning yellow
                    danger: 'oklch(65% 0.28 25)',    // Blood red
                    orphan: 'oklch(40% 0.05 270)',   // Dark purple
                }
            },
            ocean: {
                name: 'üåä Ocean Depths',
                bg: '#0a1628',
                layers: {
                    'Interface': 'oklch(80% 0.12 220)', // Surface light
                    'App': 'oklch(70% 0.15 210)',       // Mid water
                    'Core': 'oklch(55% 0.18 230)',     // Deep blue
                    'Infra': 'oklch(45% 0.15 200)',    // Abyss
                    'Data': 'oklch(65% 0.20 180)',     // Coral teal
                    'Tests': 'oklch(75% 0.18 60)',     // Sandy yellow
                },
                health: {
                    healthy: 'oklch(70% 0.20 180)',
                    warning: 'oklch(75% 0.18 90)',
                    danger: 'oklch(60% 0.25 15)',
                    orphan: 'oklch(35% 0.08 240)',
                }
            },
            aurora: {
                name: 'üåå Aurora',
                bg: '#050510',
                layers: {
                    'Interface': 'oklch(75% 0.22 150)', // Aurora green
                    'App': 'oklch(70% 0.25 180)',       // Teal shimmer
                    'Core': 'oklch(65% 0.22 280)',     // Purple wave
                    'Infra': 'oklch(70% 0.20 330)',    // Pink glow
                    'Data': 'oklch(75% 0.18 200)',     // Cyan light
                    'Tests': 'oklch(80% 0.15 110)',    // Lime flash
                },
                health: {
                    healthy: 'oklch(75% 0.22 160)',
                    warning: 'oklch(80% 0.20 80)',
                    danger: 'oklch(65% 0.25 350)',
                    orphan: 'oklch(30% 0.05 270)',
                }
            },
            sunset: {
                name: 'üåÖ Sunset Fire',
                bg: '#1a0a05',
                layers: {
                    'Interface': 'oklch(85% 0.20 60)',  // Golden sun
                    'App': 'oklch(75% 0.25 45)',        // Deep orange
                    'Core': 'oklch(65% 0.28 30)',      // Crimson
                    'Infra': 'oklch(55% 0.22 15)',     // Dark red
                    'Data': 'oklch(70% 0.18 340)',     // Rose
                    'Tests': 'oklch(80% 0.15 90)',     // Warm yellow
                },
                health: {
                    healthy: 'oklch(70% 0.18 150)',
                    warning: 'oklch(80% 0.22 60)',
                    danger: 'oklch(60% 0.30 25)',
                    orphan: 'oklch(35% 0.10 30)',
                }
            },
            matrix: {
                name: 'üìü Matrix',
                bg: '#000800',
                layers: {
                    'Interface': 'oklch(85% 0.25 145)', // Bright green
                    'App': 'oklch(70% 0.22 150)',       // Matrix green
                    'Core': 'oklch(55% 0.18 155)',     // Deep green
                    'Infra': 'oklch(40% 0.12 160)',    // Dark green
                    'Data': 'oklch(75% 0.15 140)',     // Lime
                    'Tests': 'oklch(65% 0.10 130)',    // Olive
                },
                health: {
                    healthy: 'oklch(80% 0.25 145)',
                    warning: 'oklch(75% 0.20 90)',
                    danger: 'oklch(50% 0.20 25)',
                    orphan: 'oklch(30% 0.08 150)',
                }
            }
        };

        // Active theme
        let currentTheme = 'cyberpunk';

        // Dynamic getters that respect current theme
        const layerColors = {
            'Interface': '#00d4ff',
            'App': '#a855f7',
            'Core': '#ec4899',
            'Infra': '#22c55e',
            'Data': '#ef4444',
            'Tests': '#eab308',
        };
        const healthColors = {
            healthy: '#22c55e',
            warning: '#eab308',
            danger: '#ef4444',
            orphan: '#666666'
        };

        function applyTheme(themeName) {
            currentTheme = themeName;
            const theme = colorThemes[themeName];

            // Update body background
            document.body.style.background = theme.bg;

            // Update color maps
            Object.assign(layerColors, convertOklchToHex(theme.layers));
            Object.assign(healthColors, convertOklchToHex(theme.health));

            updateViz();
        }

        function convertOklchToHex(colorMap) {
            // For now, pass through - browser will handle OKLCH
            // In production, would convert to hex for compatibility
            return colorMap;
        }

        // Analysis presets - complete visual encoding combinations
        const analysisPresets = {
            godClass: {
                name: 'üî¥ Find God Classes',
                color: 'coupling',
                size: 'degree',
                opacity: 'full',
                stroke: 'health',
                edgeColor: 'gradient',
                edgeOpacity: 20,
                description: 'Large red nodes = God classes with high coupling'
            },
            architecture: {
                name: 'üèõÔ∏è Architecture View',
                color: 'layer',
                size: 'fixed',
                opacity: 'full',
                stroke: 'boundary',
                edgeColor: 'type',
                edgeOpacity: 15,
                description: 'Layers colored, edges by type (import/contains)'
            },
            debugFlow: {
                name: 'üîç Debug Flow',
                color: 'distance',
                size: 'outDegree',
                opacity: 'coupling',
                stroke: 'selected',
                edgeColor: 'gradient',
                edgeOpacity: 25,
                description: 'Click node to see dependency flow with distance coloring'
            },
            clusters: {
                name: 'üß© Cluster Analysis',
                color: 'module',
                size: 'degree',
                opacity: 'full',
                stroke: 'none',
                edgeColor: 'gradient',
                edgeOpacity: 10,
                description: 'Directory-based clusters with gradient connections'
            },
            orphans: {
                name: 'üëª Find Orphans',
                color: 'health',
                size: 'health',
                opacity: 'health',
                stroke: 'health',
                edgeColor: 'none',
                edgeOpacity: 5,
                description: 'Orphan nodes highlighted, healthy nodes faded'
            },
            hotspots: {
                name: 'üî• Coupling Hotspots',
                color: 'coupling',
                size: 'inDegree',
                opacity: 'coupling',
                stroke: 'health',
                edgeColor: 'target',
                edgeOpacity: 30,
                description: 'Hot colors = high coupling, size = dependency count'
            },
            hierarchy: {
                name: 'üå≤ Hierarchy View',
                color: 'role',
                size: 'outDegree',
                opacity: 'boundary',
                stroke: 'boundary',
                edgeColor: 'type',
                edgeOpacity: 20,
                description: 'Role colors, containment edges green, imports purple'
            },
            rainbow: {
                name: 'üåà Rainbow Overview',
                color: 'module',
                size: 'lines',
                opacity: 'full',
                stroke: 'none',
                edgeColor: 'gradient',
                edgeOpacity: 8,
                description: 'Maximum color variety - each module unique color'
            }
        };

        // Leiden clustering for community detection
        let leidenClusters = {};
        function computeLeidenClusters() {
            // Simple Louvain-like community detection (fast approximation)
            const adj = {};
            nodes.forEach(n => { adj[n.id] = []; leidenClusters[n.id] = n.id; });
            edges.forEach(e => {
                adj[e.source.id].push(e.target.id);
                adj[e.target.id].push(e.source.id);
            });

            // Iterative label propagation
            let changed = true;
            let iterations = 0;
            while (changed && iterations < 10) {
                changed = false;
                iterations++;
                nodes.forEach(node => {
                    const neighbors = adj[node.id];
                    if (neighbors.length === 0) return;

                    // Count neighbor labels
                    const labelCounts = {};
                    neighbors.forEach(nid => {
                        const label = leidenClusters[nid];
                        labelCounts[label] = (labelCounts[label] || 0) + 1;
                    });

                    // Find most common label
                    let maxLabel = leidenClusters[node.id];
                    let maxCount = 0;
                    for (const [label, count] of Object.entries(labelCounts)) {
                        if (count > maxCount) {
                            maxCount = count;
                            maxLabel = label;
                        }
                    }

                    if (leidenClusters[node.id] !== maxLabel) {
                        leidenClusters[node.id] = maxLabel;
                        changed = true;
                    }
                });
            }

            // Assign cluster colors
            const uniqueClusters = [...new Set(Object.values(leidenClusters))];
            const clusterColors = {};
            uniqueClusters.forEach((cluster, i) => {
                const hue = (i * 137.5) % 360; // Golden angle for max separation
                clusterColors[cluster] = `hsl(${hue}, 75%, 55%)`;
            });

            nodes.forEach(n => {
                n.clusterColor = clusterColors[leidenClusters[n.id]];
            });

            console.log(`Leiden found ${uniqueClusters.length} clusters in ${iterations} iterations`);
        }

        function applyPreset(presetName) {
            if (!presetName) return;
            const preset = analysisPresets[presetName];
            if (!preset) return;

            // Apply all settings
            setColorMode(preset.color);
            document.getElementById('size-mode').value = preset.size;
            document.getElementById('opacity-mode').value = preset.opacity;
            document.getElementById('stroke-mode').value = preset.stroke;
            document.getElementById('edge-color-mode').value = preset.edgeColor;
            document.getElementById('edge-opacity').value = preset.edgeOpacity;

            updateViz();
            updatePokedex(presetName);
            console.log(`Applied preset: ${preset.name} - ${preset.description}`);
        }

        // Color mode explanations for the Pokedex
        const colorModeExplanations = {
            layer: 'üèõÔ∏è <b>Layer</b>: Architectural layer - Interface (API), App (business logic), Core (domain), Infra (external services), Data (storage), Tests',
            health: 'ü©∫ <b>Health</b>: Code health status - Green=healthy, Yellow=warning (high coupling), Red=danger (God class), Gray=orphan (unused)',
            role: 'üé≠ <b>Role</b>: Architectural pattern - Orchestrator, Worker, Factory, Adapter, Repository, Service, Controller, Model, View, Utility',
            coupling: 'üîó <b>Coupling</b>: Dependency intensity - Blue=low coupling (isolated), Red=high coupling (many dependencies = potential God class)',
            module: 'üìÅ <b>Module</b>: File directory grouping - Same color = same folder/package. Helps identify clusters and modules',
            distance: 'üìè <b>Distance</b>: BFS distance from selected node - Hue rotates with depth, lightness varies with branch. Click a node first!',
            cluster: 'üß© <b>Cluster</b>: Leiden community detection - Automatically groups tightly-connected nodes. Same color = same community',
            kind: 'üî∑ <b>Kind</b>: Node type - Red=repo, Green=directory, Blue=file, Purple=function, Yellow=aggregate, Pink=handler',
            extension: 'üìÑ <b>Extension</b>: File type - Yellow=JS, Blue=TS, React=Cyan, Python=Navy, CSS=Royal, JSON=Green, etc.'
        };

        const sizeModeExplanations = {
            fixed: 'All nodes same size',
            degree: 'Larger = more total connections',
            inDegree: 'Larger = more things depend on it',
            outDegree: 'Larger = depends on more things',
            health: 'Larger = more health issues',
            lines: 'Larger = more lines of code'
        };

        function updatePokedex(presetName = null) {
            const presetEl = document.getElementById('pokedex-preset');
            const colorExplainEl = document.getElementById('pokedex-color-explain');

            // Update preset description
            if (presetName && analysisPresets[presetName]) {
                const preset = analysisPresets[presetName];
                presetEl.innerHTML = `
                    <div style="color: #00d4ff; font-weight: bold; margin-bottom: 4px;">${preset.name}</div>
                    <div style="color: #ccc;">${preset.description}</div>
                `;
            } else {
                presetEl.innerHTML = `
                    <div style="color: #666; font-weight: bold; margin-bottom: 4px;">‚ö° Custom Configuration</div>
                    <div style="color: #888;">Manually configured settings</div>
                `;
            }

            // Update legend values
            document.getElementById('leg-color').textContent = colorMode.charAt(0).toUpperCase() + colorMode.slice(1);
            document.getElementById('leg-size').textContent = document.getElementById('size-mode').value;
            document.getElementById('leg-stroke').textContent = document.getElementById('stroke-mode').value;
            document.getElementById('leg-edge').textContent = document.getElementById('edge-color-mode').value;

            // Update color explanation
            colorExplainEl.innerHTML = colorModeExplanations[colorMode] || 'üé® Select a color mode';
        }

        // Role colors for architectural patterns
        const roleColors = {
            'Orchestrator': '#ff6b6b',   // Red - controls flow
            'Worker': '#4ecdc4',          // Teal - does work
            'Factory': '#ffe66d',         // Yellow - creates things
            'Adapter': '#a8e6cf',         // Mint - bridges systems
            'Repository': '#dda0dd',      // Plum - data access
            'Service': '#87ceeb',         // Sky blue - business logic
            'Controller': '#ffa07a',      // Salmon - handles requests
            'Model': '#98d8c8',           // Seafoam - data structure
            'View': '#f7dc6f',            // Gold - presentation
            'Utility': '#bb8fce',         // Purple - helpers
            'Config': '#85c1e9',          // Light blue - settings
            'Test': '#f8b500',            // Orange - tests
        };

        // Hash string to color for module-based coloring
        function hashColor(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            const h = Math.abs(hash) % 360;
            return `hsl(${h}, 70%, 55%)`;
        }

        // Hierarchical coloring: Similar paths = Similar colors
        function getHierarchicalColor(path) {
            if (!path) return '#666';

            // Normalize path
            const parts = path.split('/').filter(p => p && p !== '.');
            if (parts.length === 0) return hashColor(path);

            // 1. Root Segment determines Base Hue (major category)
            // Use a stable hash for the root to divide the spectrum
            const root = parts[0];
            let hash = 0;
            for (let i = 0; i < root.length; i++) hash = root.charCodeAt(i) + ((hash << 5) - hash);
            let hue = Math.abs(hash) % 360;

            // 2. Leaf Segment (File) determines fine-tuning
            // Use different saturation/lightness or slight hue shift
            if (parts.length > 1) {
                const leaf = parts[parts.length - 1];
                let leafHash = 0;
                for (let i = 0; i < leaf.length; i++) leafHash = leaf.charCodeAt(i) + ((leafHash << 5) - leafHash);

                // Shift hue slightly based on file name (¬±15 degrees) keeps it in same "family"
                const hueShift = (Math.abs(leafHash) % 30) - 15;
                hue = (hue + hueShift + 360) % 360;
            }

            // 3. Assign
            // High saturation/lightness for visibility on dark bg
            return `hsl(${hue}, 85%, 60%)`;
        }

        // Edge type colors
        const edgeTypeColors = {
            'import': '#a855f7',    // Purple - dependency
            'contains': '#22c55e',  // Green - hierarchy
            'calls': '#ef4444',     // Red - invocation
            'uses': '#3b82f6',      // Blue - usage
        };

        // Kind colors (node type)
        const kindColors = {
            'repo': '#ef4444',      // Red
            'directory': '#22c55e', // Green
            'file': '#3b82f6',      // Blue
            'FNC': '#a855f7',       // Purple
            'AGG': '#eab308',       // Yellow
            'HDL': '#ec4899',       // Pink
        };

        const layerRank = { 'Interface': 5, 'App': 4, 'Core': 3, 'Infra': 2, 'Data': 1, 'Tests': 0 };

        let activeFilters = new Set(Object.keys(layerColors));
        let colorMode = 'health';
        let nodes = [];
        let edges = [];
        let svg, g, zoom;
        let selectedNode = null;
        let nodeDistances = {}; // BFS distances from selected node
        let nodeBranches = {};  // Which branch each node belongs to (for horizontal spread)
        let branchCountAtDepth = {}; // How many branches at each depth level

        // OKLCH Color Generation
        // Hue rotates with depth (0-360), Lightness varies with branch index
        function getOklchColor(depth, branchIndex, totalBranches) {
            if (depth === 0) return '#ffffff'; // Selected node is white

            // Hue: rotate through spectrum by depth (each level ~40-50 degrees apart)
            const hue = (depth * 45) % 360;

            // Lightness: varies by branch index (60-85% range for visibility)
            const lightnessRange = 0.25;
            const baseLightness = 0.72;
            const lightness = totalBranches > 1
                ? baseLightness + (branchIndex / totalBranches - 0.5) * lightnessRange
                : baseLightness;

            // Chroma: high for visibility, slight variation by branch
            const chroma = 0.15 + (branchIndex % 3) * 0.02;

            // Return OKLCH color string (modern browsers support this)
            return `oklch(${lightness} ${chroma} ${hue})`;
        }

        // Fallback HSL for older browsers
        function getHslColor(depth, branchIndex, totalBranches) {
            if (depth === 0) return '#ffffff';

            const hue = (depth * 45) % 360;
            const saturation = 85;
            const lightness = totalBranches > 1
                ? 50 + (branchIndex / totalBranches - 0.5) * 30
                : 55;

            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        // Navigation History (unlimited)
        let navHistory = [];
        let navIndex = -1;

        // ==========================================
        // HEALTH ANALYSIS
        // ==========================================
        function analyzeHealth(node) {
            let score = 100;
            const issues = [];
            if (node.degree > 20) { issues.push('God Class'); score -= 50; }
            else if (node.degree > 10) { issues.push('High Coupling'); score -= 20; }
            if (node.degree === 0) { issues.push('Orphan'); score -= 30; }
            if (node.outDegree > 15) { issues.push('High Fan-Out'); score -= 15; }

            let status = 'healthy';
            if (node.degree === 0) status = 'orphan';
            else if (score < 50) status = 'danger';
            else if (score < 80) status = 'warning';

            return { score, status, issues };
        }

        // ==========================================
        // INIT
        // ==========================================
        function init() {
            if (particles.length === 0) {
                document.getElementById('loading').textContent = 'No data';
                return;
            }
            document.getElementById('loading').style.display = 'none';

            // Compute degrees
            const inDegree = {}, outDegree = {};
            connections.forEach(c => {
                outDegree[c.from] = (outDegree[c.from] || 0) + 1;
                inDegree[c.to] = (inDegree[c.to] || 0) + 1;
            });

            // Build nodes
            const cols = Math.ceil(Math.sqrt(particles.length));
            const spacing = 15;

            nodes = particles.map((p, i) => {
                const node = {
                    ...p,
                    x: (i % cols) * spacing,
                    y: Math.floor(i / cols) * spacing,
                    inDegree: inDegree[p.id] || 0,
                    outDegree: outDegree[p.id] || 0,
                    degree: (inDegree[p.id] || 0) + (outDegree[p.id] || 0),
                    layerColor: layerColors[p.layer] || '#666'
                };
                const health = analyzeHealth(node);
                node.health = health.status;
                node.healthScore = health.score;
                node.healthIssues = health.issues;
                return node;
            });

            // Build edges
            const nodeMap = {};
            nodes.forEach(n => nodeMap[n.id] = n);
            edges = connections.filter(c => nodeMap[c.from] && nodeMap[c.to]).map(c => ({
                source: nodeMap[c.from],
                target: nodeMap[c.to],
                type: c.type
            }));

            // Compute Leiden clusters for community coloring
            computeLeidenClusters();

            // Setup SVG
            svg = d3.select('#graph');
            const width = svg.node().clientWidth;
            const height = svg.node().clientHeight;

            zoom = d3.zoom()
                .scaleExtent([0.01, 10])
                .on('zoom', (e) => g.attr('transform', e.transform));
            svg.call(zoom);

            g = svg.append('g');

            // Draw edges
            g.append('g').attr('class', 'edges')
                .selectAll('line')
                .data(edges)
                .enter().append('line')
                .attr('class', 'edge')
                .attr('stroke', '#fff');

            // Draw nodes
            g.append('g').attr('class', 'nodes')
                .selectAll('circle')
                .data(nodes)
                .enter().append('circle')
                .attr('class', 'node')
                .on('mouseover', showTooltip)
                .on('mouseout', hideTooltip)
                .on('click', selectNode);

            computeMaxes();
            updateViz();
            buildFilters();
            updateStats();
            setTimeout(resetZoom, 100);
        }

        // ==========================================
        // UPDATE
        // ==========================================
        function updateViz() {
            const edgeOpacity = +document.getElementById('edge-opacity').value / 100;

            g.selectAll('.node')
                .attr('cx', d => d.x)
                .attr('cy', d => d.y)
                .attr('r', d => getNodeSize(d))
                .attr('fill', d => getNodeColor(d))
                .attr('opacity', d => getNodeOpacity(d))
                .attr('stroke', d => getNodeStroke(d).color)
                .attr('stroke-width', d => getNodeStroke(d).width)
                .attr('display', d => activeFilters.has(d.layer) ? null : 'none');

            g.selectAll('.edge')
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y)
                .attr('stroke', d => getEdgeColor(d))
                .attr('stroke-opacity', edgeOpacity)
                .attr('display', d => (!activeFilters.has(d.source.layer) || !activeFilters.has(d.target.layer)) ? 'none' : null);
        }

        function getEdgeColor(edge) {
            const mode = document.getElementById('edge-color-mode').value;

            switch (mode) {
                case 'none':
                    return '#ffffff';
                case 'type':
                    return edgeTypeColors[edge.type] || '#666';
                case 'source':
                    return getNodeColor(edge.source);
                case 'target':
                    return getNodeColor(edge.target);
                case 'gradient':
                    // Interpolate between source and target colors
                    return interpolateColors(getNodeColor(edge.source), getNodeColor(edge.target), 0.5);
                default:
                    return '#ffffff';
            }
        }

        // Interpolate between two colors (simple HSL midpoint)
        function interpolateColors(color1, color2, t) {
            // Parse colors to RGB
            const c1 = parseColor(color1);
            const c2 = parseColor(color2);

            // Interpolate RGB
            const r = Math.round(c1.r + (c2.r - c1.r) * t);
            const g = Math.round(c1.g + (c2.g - c1.g) * t);
            const b = Math.round(c1.b + (c2.b - c1.b) * t);

            return `rgb(${r}, ${g}, ${b})`;
        }

        function parseColor(color) {
            // Handle hex
            if (color.startsWith('#')) {
                const hex = color.slice(1);
                return {
                    r: parseInt(hex.substr(0, 2), 16),
                    g: parseInt(hex.substr(2, 2), 16),
                    b: parseInt(hex.substr(4, 2), 16)
                };
            }
            // Handle rgb()
            if (color.startsWith('rgb')) {
                const match = color.match(/\d+/g);
                return { r: +match[0], g: +match[1], b: +match[2] };
            }
            // Handle hsl()
            if (color.startsWith('hsl')) {
                const match = color.match(/[\d.]+/g);
                const h = +match[0], s = +match[1] / 100, l = +match[2] / 100;
                return hslToRgb(h, s, l);
            }
            // Default gray
            return { r: 128, g: 128, b: 128 };
        }

        function hslToRgb(h, s, l) {
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;
            let r, g, b;
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            return {
                r: Math.round((r + m) * 255),
                g: Math.round((g + m) * 255),
                b: Math.round((b + m) * 255)
            };
        }

        // Compute max values once for efficiency
        let maxDegree = 1, maxInDegree = 1, maxOutDegree = 1, maxLines = 1;
        function computeMaxes() {
            maxDegree = Math.max(...nodes.map(n => n.degree), 1);
            maxInDegree = Math.max(...nodes.map(n => n.inDegree), 1);
            maxOutDegree = Math.max(...nodes.map(n => n.outDegree), 1);
            maxLines = Math.max(...nodes.map(n => (n.endLine - n.startLine) || 1), 1);
        }

        function getNodeSize(node) {
            const mode = document.getElementById('size-mode').value;
            const baseSize = 2;
            const maxSize = 12;

            switch (mode) {
                case 'fixed': return 3;
                case 'degree': return baseSize + (node.degree / maxDegree) * maxSize;
                case 'inDegree': return baseSize + (node.inDegree / maxInDegree) * maxSize;
                case 'outDegree': return baseSize + (node.outDegree / maxOutDegree) * maxSize;
                case 'health':
                    const healthSize = { healthy: 3, warning: 6, danger: 10, orphan: 4 };
                    return healthSize[node.health] || 3;
                case 'lines':
                    const lines = (node.endLine - node.startLine) || 1;
                    return baseSize + (lines / maxLines) * maxSize;
                default: return 3;
            }
        }

        function getNodeOpacity(node) {
            const mode = document.getElementById('opacity-mode').value;

            switch (mode) {
                case 'full': return 1;
                case 'health':
                    return { healthy: 0.6, warning: 0.85, danger: 1, orphan: 0.3 }[node.health] || 0.6;
                case 'coupling':
                    return 0.3 + (node.degree / maxDegree) * 0.7;
                case 'boundary':
                    return node.boundary === 'Public' ? 1 : 0.5;
                case 'kind':
                    const kindOpacity = { 'class': 1, 'function': 0.8, 'method': 0.6, 'module': 0.9 };
                    return kindOpacity[node.kind] || 0.7;
                default: return 1;
            }
        }

        function getNodeStroke(node) {
            const mode = document.getElementById('stroke-mode').value;

            switch (mode) {
                case 'none':
                    return { color: null, width: 0 };
                case 'boundary':
                    if (node.boundary === 'Public') return { color: '#00ffff', width: 1.5 };
                    if (node.boundary === 'Internal') return { color: '#666', width: 0.5 };
                    return { color: null, width: 0 };
                case 'health':
                    if (node.health === 'danger') return { color: '#ff0000', width: 2 };
                    if (node.health === 'warning') return { color: '#ffaa00', width: 1.5 };
                    if (node.health === 'orphan') return { color: '#888', width: 1 };
                    return { color: null, width: 0 };
                case 'selected':
                    return node === selectedNode ? { color: '#fff', width: 2 } : { color: null, width: 0 };
                default:
                    return { color: null, width: 0 };
            }
        }


        function toggleHeatmaps() {
            const el = document.getElementById('heatmap-controls');
            const isHidden = el.style.display === 'none';
            el.style.display = isHidden ? 'flex' : 'none';
        }

        // Flow Depth Calculation (Startup Wave)
        let flowDepths = {};
        function computeFlowDepth() {
            flowDepths = {};
            const queue = [];

            // 1. Find Roots (Entry Points)
            nodes.forEach(n => {
                const label = n.label.toLowerCase();
                const isEntry = n.inDegree === 0 ||
                    label.includes('main') ||
                    label.includes('index') ||
                    label.includes('app') ||
                    label.includes('server');
                if (isEntry) {
                    queue.push({ id: n.id, depth: 0 });
                    flowDepths[n.id] = 0;
                }
            });

            // 2. BFS Propagate
            const visited = new Set(Object.keys(flowDepths));

            // Build adjacency
            const adj = {};
            edges.forEach(e => {
                if (!adj[e.source.id]) adj[e.source.id] = [];
                adj[e.source.id].push(e.target.id);
            });

            while (queue.length > 0) {
                const { id, depth } = queue.shift();
                const neighbors = adj[id] || [];

                neighbors.forEach(nid => {
                    if (!visited.has(nid)) {
                        visited.add(nid);
                        flowDepths[nid] = depth + 1;
                        queue.push({ id: nid, depth: depth + 1 });
                    }
                });
            }
        }

        function getGradientColor(t, palette) {
            // t is 0.0 to 1.0
            t = Math.max(0, Math.min(1, t));

            if (palette === 'magma') {
                // Black -> Purple -> Red -> Yellow
                if (t < 0.33) return interpolateColors('#000004', '#721f81', t * 3);
                if (t < 0.66) return interpolateColors('#721f81', '#f1605d', (t - 0.33) * 3);
                return interpolateColors('#f1605d', '#fcfdbf', (t - 0.66) * 3);
            } else if (palette === 'viridis') {
                // Purple -> Teal -> Yellow
                if (t < 0.5) return interpolateColors('#440154', '#21908d', t * 2);
                return interpolateColors('#21908d', '#fde725', (t - 0.5) * 2);
            } else if (palette === 'plasma') {
                // Blue -> Red -> Yellow
                if (t < 0.5) return interpolateColors('#0d0887', '#cc4778', t * 2);
                return interpolateColors('#cc4778', '#f0f921', (t - 0.5) * 2);
            } else if (palette === 'cool') {
                return interpolateColors('#00ffff', '#0000ff', t);
            }
            return interpolateColors('#000000', '#ffffff', t);
        }

        function getNodeColor(node) {
            const palette = document.getElementById('gradient-select').value;

            if (colorMode === 'health') {
                return healthColors[node.health] || '#666';
            } else if (colorMode === 'layer') {
                return layerColors[node.layer] || '#666';
            } else if (colorMode === 'role') {
                return roleColors[node.role] || '#888';
            } else if (colorMode === 'coupling') {
                // Gradient from blue (low coupling) to red (high coupling)
                const maxDeg = Math.max(...nodes.map(n => n.degree), 1);
                const ratio = node.degree / maxDeg;
                const h = 240 - (ratio * 240); // 240=blue, 0=red
                const s = 70 + (ratio * 20);   // More saturated at high coupling
                const l = 60 - (ratio * 20);   // Darker at high coupling
                return `hsl(${h}, ${s}%, ${l}%)`;
            } else if (colorMode === 'module') {
                // Color by exact file to cluster components in the same file
                // Use hierarchical coloring to ensure file proximity = color proximity
                const filePath = node.file || node.id;
                return getHierarchicalColor(filePath);
            } else if (colorMode === 'flow') {
                // Running Flow Cycle
                if (Object.keys(flowDepths).length === 0) computeFlowDepth();
                const d = flowDepths[node.id] || 0;

                if (palette === 'rainbow') {
                    // Cyclic Rainbow: Depth cycles through Hue
                    // Each step is 20 degrees. Cycle every 18 levels.
                    const hue = (d * 20) % 360;
                    return `hsl(${hue}, 90%, 60%)`;
                } else {
                    // Gradient map
                    // Normalize depth (assume max depth ~15 for typical apps)
                    const norm = (d % 20) / 20;
                    return getGradientColor(norm, palette);
                }

            } else if (colorMode === 'centrality') {
                // Approximate centrality using Degree
                // In a real implementation we might compute PageRank
                const val = node.degree / maxDegree;
                return getGradientColor(val, palette);

            } else if (colorMode === 'radial') {
                // Distance from (0,0)
                // Normalize based on max possible coordinate (2000)
                const dist = Math.sqrt(node.x * node.x + node.y * node.y);
                const norm = 1 - Math.min(dist / 1000, 1); // Center = 1 (Hot), Edge = 0 (Cold)
                return getGradientColor(norm, palette);

            } else if (colorMode === 'proximity') {
                // Distance from selected node
                if (!selectedNode) return '#333';
                const dist = nodeDistances[node.id];
                if (dist === undefined) return '#1a1a1a';
                // Hot (0) -> Cold (10)
                const norm = Math.max(0, 1 - (dist / 8));
                return getGradientColor(norm, palette);

            } else if (colorMode === 'distance') {
                // Legacy distance mode (preserves original behavior)
                if (!selectedNode) return '#333';
                const dist = nodeDistances[node.id];
                if (dist === undefined) return '#1a1a1a';

                const branchInfo = nodeBranches[node.id] || { index: 0, total: 1 };
                try {
                    return getOklchColor(dist, branchInfo.index, branchInfo.total);
                } catch (e) {
                    return getHslColor(dist, branchInfo.index, branchInfo.total);
                }
            } else if (colorMode === 'cluster') {
                // Leiden clustering colors
                return node.clusterColor || '#666';
            } else if (colorMode === 'kind') {
                // Node type colors
                return kindColors[node.kind] || '#888';
            } else if (colorMode === 'extension') {
                // File extension colors
                const ext = (node.file || '').split('.').pop() || 'unknown';
                const extColors = {
                    'js': '#f7df1e',    // JavaScript yellow
                    'ts': '#3178c6',    // TypeScript blue
                    'tsx': '#61dafb',   // React blue
                    'jsx': '#61dafb',   // React blue
                    'py': '#3776ab',    // Python blue
                    'css': '#264de4',   // CSS blue
                    'scss': '#cc6699',  // Sass pink
                    'json': '#8bc34a',  // JSON green
                    'md': '#083fa1',    // Markdown navy
                    'html': '#e34c26',  // HTML orange
                    'vue': '#42b883',   // Vue green
                    'sql': '#00758f',   // SQL teal
                    'yaml': '#cb171e',  // YAML red
                    'sh': '#4eaa25',    // Shell green
                };
                return extColors[ext] || hashColor(ext);
            }
            return '#666';
        }

        function setColorMode(mode) {
            colorMode = mode;
            document.querySelectorAll('[id^="mode-"]').forEach(b => b.classList.remove('active'));
            const btn = document.getElementById('mode-' + mode);
            if (btn) btn.classList.add('active');
            updateViz();
        }

        // ==========================================
        // LAYOUTS
        // ==========================================
        function setLayout(type) {
            if (type === 'grid') {
                const cols = Math.ceil(Math.sqrt(nodes.length));
                nodes.forEach((n, i) => {
                    n.x = (i % cols) * 15;
                    n.y = Math.floor(i / cols) * 15;
                });
            } else if (type === 'layers') {
                const layerOrder = ['Interface', 'App', 'Core', 'Infra', 'Data', 'Tests'];
                const byLayer = {};
                nodes.forEach(n => { if (!byLayer[n.layer]) byLayer[n.layer] = []; byLayer[n.layer].push(n); });
                let yOffset = 0;
                layerOrder.forEach(layer => {
                    const layerNodes = byLayer[layer] || [];
                    const cols = Math.ceil(Math.sqrt(layerNodes.length));
                    layerNodes.forEach((n, i) => {
                        n.x = (i % cols) * 10;
                        n.y = yOffset + Math.floor(i / cols) * 10;
                    });
                    yOffset += Math.ceil(layerNodes.length / cols) * 10 + 40;
                });
            } else if (type === 'health') {
                const healthOrder = ['danger', 'warning', 'orphan', 'healthy'];
                const byHealth = {};
                nodes.forEach(n => { if (!byHealth[n.health]) byHealth[n.health] = []; byHealth[n.health].push(n); });
                let yOffset = 0;
                healthOrder.forEach(status => {
                    const healthNodes = byHealth[status] || [];
                    const cols = Math.ceil(Math.sqrt(healthNodes.length));
                    healthNodes.forEach((n, i) => {
                        n.x = (i % cols) * 12;
                        n.y = yOffset + Math.floor(i / cols) * 12;
                    });
                    yOffset += Math.ceil(healthNodes.length / cols) * 12 + 50;
                });
            } else if (type === 'circular') {
                // Circular layout - all nodes on a circle
                const radius = Math.max(200, nodes.length * 0.5);
                nodes.forEach((n, i) => {
                    const angle = (i / nodes.length) * 2 * Math.PI;
                    n.x = radius * Math.cos(angle);
                    n.y = radius * Math.sin(angle);
                });
            } else if (type === 'radial') {
                // Radial spiral - nodes spiral outward
                const baseRadius = 10;
                const spacing = 3;
                nodes.forEach((n, i) => {
                    const angle = i * 0.3; // Golden angle approximation
                    const radius = baseRadius + spacing * Math.sqrt(i);
                    n.x = radius * Math.cos(angle);
                    n.y = radius * Math.sin(angle);
                });
            } else if (type === 'cluster') {
                // Group by Leiden cluster
                const clusters = {};
                nodes.forEach(n => {
                    const cluster = leidenClusters[n.id] || 'unknown';
                    if (!clusters[cluster]) clusters[cluster] = [];
                    clusters[cluster].push(n);
                });

                // Position clusters in a grid
                const clusterList = Object.values(clusters);
                const numClusters = clusterList.length;
                const clusterCols = Math.ceil(Math.sqrt(numClusters));
                const clusterSpacing = 200;

                clusterList.forEach((clusterNodes, ci) => {
                    const cx = (ci % clusterCols) * clusterSpacing;
                    const cy = Math.floor(ci / clusterCols) * clusterSpacing;

                    // Arrange nodes within cluster circularly
                    const radius = Math.max(20, clusterNodes.length * 2);
                    clusterNodes.forEach((n, ni) => {
                        const angle = (ni / clusterNodes.length) * 2 * Math.PI;
                        n.x = cx + radius * Math.cos(angle);
                        n.y = cy + radius * Math.sin(angle);
                    });
                });
            } else if (type === 'onion') {
                // Onion Architecture: Concentric rings
                // Core (0) -> App (1) -> Data/Infra (2) -> Interface (3) -> Tests (4)
                const onionRank = { 'Core': 0, 'App': 1, 'Data': 2, 'Infra': 2, 'Interface': 3, 'Tests': 4 };
                const byRing = {};
                nodes.forEach(n => {
                    const rank = onionRank[n.layer] !== undefined ? onionRank[n.layer] : 5;
                    if (!byRing[rank]) byRing[rank] = [];
                    byRing[rank].push(n);
                });

                // Distribute rings
                const baseRadius = 100;
                Object.keys(byRing).forEach(rank => {
                    const ringNodes = byRing[rank];
                    const radius = baseRadius * (parseInt(rank) + 1);
                    ringNodes.forEach((n, i) => {
                        const angle = (i / ringNodes.length) * 2 * Math.PI;
                        n.x = radius * Math.cos(angle);
                        n.y = radius * Math.sin(angle);
                    });
                });
            } else if (type === 'flow') {
                // Dependency Flow (DAG visualization approximation)
                // Y-axis = Depth/Layer, X-axis = Distributed
                const flowRank = { 'Interface': 0, 'App': 1, 'Core': 2, 'Data': 3, 'Infra': 4, 'Tests': 5 };
                const byRank = {};
                nodes.forEach(n => {
                    // Refine rank by dependency depth (in-degree - out-degree hint)
                    let rank = flowRank[n.layer] !== undefined ? flowRank[n.layer] : 3;
                    if (!byRank[rank]) byRank[rank] = [];
                    byRank[rank].push(n);
                });

                const spacingX = 40;
                const spacingY = 150;

                Object.keys(byRank).forEach(rank => {
                    const rankNodes = byRank[rank];
                    // Sort by clustering to minimize crossings
                    rankNodes.sort((a, b) => (leidenClusters[a.id] || 0) - (leidenClusters[b.id] || 0));

                    const width = rankNodes.length * spacingX;
                    const startX = -width / 2;

                    rankNodes.forEach((n, i) => {
                        n.x = startX + i * spacingX;
                        n.y = (rank - 2) * spacingY; // Centered vertically
                    });
                });
            } else if (type === 'forceLayers') {
                // Force simulation with Swimlanes
                // Initialize simulation
                initForceSimulation('layers');
                return; // updating is handled by tick
            }

            // If not a force layout, stop any running simulation
            if (type !== 'forceLayers' && simulation) simulation.stop();
            updateViz();
        }

        // ==========================================
        // FORCE SIMULATION
        // ==========================================
        let simulation;
        function initForceSimulation(mode) {
            if (simulation) simulation.stop();

            const flowRank = { 'Interface': -200, 'App': -100, 'Core': 0, 'Data': 100, 'Infra': 200, 'Tests': 300 };

            simulation = d3.forceSimulation(nodes)
                .force("charge", d3.forceManyBody().strength(-50))
                .force("link", d3.forceLink(edges).id(d => d.id).distance(30).strength(0.2))
                .force("collide", d3.forceCollide(d => getNodeSize(d) + 2).iterations(2));

            if (mode === 'layers') {
                // Constrain Y to layer, let X float
                simulation.force("y", d3.forceY(d => flowRank[d.layer] || 0).strength(2))
                    .force("x", d3.forceX(0).strength(0.05));
            }

            simulation.on("tick", updateViz);
            simulation.alpha(1).restart();
        }

        // ==========================================
        // CODE MIRROR PANEL
        // ==========================================
        function selectNode(e, d, fromNav = false) {
            selectedNode = d;

            // Push to history (only if not navigating back/forward)
            if (!fromNav) {
                // Truncate forward history if we're in the middle
                if (navIndex < navHistory.length - 1) {
                    navHistory = navHistory.slice(0, navIndex + 1);
                }
                navHistory.push(d);
                navIndex = navHistory.length - 1;
            }

            updateNavUI();
            updateViz();
            showCodePanel(d);
            highlightConnections(d);
        }

        function goBack() {
            if (navIndex > 0) {
                navIndex--;
                selectNode(null, navHistory[navIndex], true);
            }
        }

        function goForward() {
            if (navIndex < navHistory.length - 1) {
                navIndex++;
                selectNode(null, navHistory[navIndex], true);
            }
        }

        function updateNavUI() {
            document.getElementById('nav-back').disabled = navIndex <= 0;
            document.getElementById('nav-forward').disabled = navIndex >= navHistory.length - 1;
            document.getElementById('nav-info').textContent = navHistory.length > 0
                ? `${navIndex + 1} / ${navHistory.length}`
                : '0 / 0';
        }

        function showCodePanel(node) {
            const incoming = edges.filter(e => e.target.id === node.id).map(e => e.source);
            const outgoing = edges.filter(e => e.source.id === node.id).map(e => e.target);

            const vscodeUrl = node.file ? `vscode://file/${node.file}:${node.startLine}` : null;
            const fileDisplay = node.file ? node.file.split('/').slice(-3).join('/') : 'Unknown';

            const panel = document.getElementById('code-panel');
            panel.innerHTML = `
                <div class="code-panel">
                    <h3>${node.label}</h3>
                    <div class="code-meta">
                        <span class="health-badge ${node.health}">${node.health.toUpperCase()}</span>
                        <strong>${node.kind}</strong> in <strong>${node.layer}</strong>
                    </div>
                    
                    ${vscodeUrl ? `
                    <a href="${vscodeUrl}" class="file-link" title="Open in VS Code">
                        üìÇ ${fileDisplay}:${node.startLine}-${node.endLine}
                    </a>
                    ` : '<div class="code-meta">No file path available</div>'}

                    ${node.intelligence ? `
                    <div class="section-title" style="color: #ef4444;">‚öñÔ∏è Intelligence Report</div>
                    <div class="signature-box" style="border-left: 3px solid #ef4444; background: rgba(239, 68, 68, 0.1);">
                        ${node.intelligence.violations.map(v => `
                            <div style="margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px;">
                                <div style="color: #ef4444; font-weight: bold; font-size: 11px;">‚úï ${v.rule}</div>
                                <div style="color: #ccc; font-size: 10px; margin-bottom: 4px;">${v.message}</div>
                                <div style="color: #22c55e; font-weight: bold; margin-top: 4px; font-size: 10px;">üí° Solution:</div>
                                <div style="color: #fff; font-style: italic; font-size: 11px;">${v.solution}</div>
                            </div>
                        `).join('')}
                    </div>
                    ` : ''}
                    
                    ${node.signature ? `
                    <div class="section-title">Signature</div>
                    <div class="signature-box">${escapeHtml(node.signature)}</div>
                    ` : ''}
                    
                    ${node.docstring ? `
                    <div class="section-title">Docstring</div>
                    <div class="docstring-box">${escapeHtml(node.docstring)}</div>
                    ` : ''}
                    
                    <div class="section-title">Dependencies (${outgoing.length})</div>
                    <div class="deps-list">
                        ${outgoing.slice(0, 20).map(n => `
                            <div class="dep-item" onclick="focusNode('${n.id}')">
                                <span class="arrow">‚Üí</span>
                                <span class="layer-dot" style="background:${layerColors[n.layer] || '#666'}"></span>
                                ${n.label}
                            </div>
                        `).join('') || '<div class="code-meta">None</div>'}
                        ${outgoing.length > 20 ? `<div class="code-meta">...and ${outgoing.length - 20} more</div>` : ''}
                    </div>
                    
                    <div class="section-title">Dependents (${incoming.length})</div>
                    <div class="deps-list">
                        ${incoming.slice(0, 20).map(n => `
                            <div class="dep-item" onclick="focusNode('${n.id}')">
                                <span class="arrow">‚Üê</span>
                                <span class="layer-dot" style="background:${layerColors[n.layer] || '#666'}"></span>
                                ${n.label}
                            </div>
                        `).join('') || '<div class="code-meta">None</div>'}
                        ${incoming.length > 20 ? `<div class="code-meta">...and ${incoming.length - 20} more</div>` : ''}
                    </div>
                </div>
            `;
        }

        function focusNode(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (node) selectNode(null, node);
        }

        function highlightConnections(d) {
            // Build adjacency list for BFS
            const adj = {};
            nodes.forEach(n => adj[n.id] = []);
            edges.forEach(e => {
                adj[e.source.id].push(e.target.id);
                adj[e.target.id].push(e.source.id);
            });

            // BFS with branch tracking
            nodeDistances = {};
            nodeBranches = {};
            branchCountAtDepth = {};

            // Track which nodes are at each depth and their branch
            const nodesAtDepth = {}; // depth -> [nodeIds]
            const parentBranch = {}; // nodeId -> parent's branch index

            const queue = [[d.id, 0, 0]]; // [nodeId, depth, branchIndex]
            nodeDistances[d.id] = 0;
            nodeBranches[d.id] = { index: 0, total: 1, parent: null };
            nodesAtDepth[0] = [d.id];

            while (queue.length > 0) {
                const [nodeId, dist, fromBranch] = queue.shift();
                const neighbors = adj[nodeId] || [];

                // Track new nodes at this level
                let branchCounter = 0;
                for (const neighbor of neighbors) {
                    if (nodeDistances[neighbor] === undefined) {
                        const newDist = dist + 1;
                        nodeDistances[neighbor] = newDist;

                        // Track nodes at each depth for branch assignment
                        if (!nodesAtDepth[newDist]) nodesAtDepth[newDist] = [];
                        nodesAtDepth[newDist].push(neighbor);

                        // Assign preliminary branch (will be finalized after)
                        parentBranch[neighbor] = fromBranch;

                        queue.push([neighbor, newDist, branchCounter]);
                        branchCounter++;
                    }
                }
            }

            // Assign final branch indices per depth level
            for (const depth in nodesAtDepth) {
                const nodesHere = nodesAtDepth[depth];
                const total = nodesHere.length;
                branchCountAtDepth[depth] = total;
                nodesHere.forEach((nodeId, idx) => {
                    nodeBranches[nodeId] = { index: idx, total: total };
                });
            }

            // Apply opacity based on reachability
            g.selectAll('.node').attr('opacity', n => nodeDistances[n.id] !== undefined ? 1 : 0.08);

            // Color edges based on distance with OKLCH
            g.selectAll('.edge')
                .attr('stroke', e => {
                    const srcDist = nodeDistances[e.source.id];
                    const tgtDist = nodeDistances[e.target.id];
                    if (srcDist !== undefined && tgtDist !== undefined) {
                        const minDist = Math.min(srcDist, tgtDist);
                        return getHslColor(minDist, 0, 1); // Use simple HSL for edges
                    }
                    return '#111';
                })
                .attr('stroke-opacity', e => {
                    const srcDist = nodeDistances[e.source.id];
                    const tgtDist = nodeDistances[e.target.id];
                    if (srcDist !== undefined && tgtDist !== undefined) return 0.3;
                    return 0.01;
                });

            // Refresh colors if in distance mode
            if (colorMode === 'distance') updateViz();
        }

        function escapeHtml(str) {
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        // ==========================================
        // OTHER INTERACTIONS
        // ==========================================
        function updateStats() {
            const stats = { healthy: 0, warning: 0, danger: 0, orphan: 0 };
            nodes.forEach(n => stats[n.health]++);
            document.getElementById('healthy-count').textContent = stats.healthy;
            document.getElementById('warning-count').textContent = stats.warning;
            document.getElementById('danger-count').textContent = stats.danger;
            document.getElementById('orphan-count').textContent = stats.orphan;
        }

        function buildFilters() {
            const counts = {};
            nodes.forEach(n => counts[n.layer] = (counts[n.layer] || 0) + 1);
            const html = Object.entries(layerColors).map(([layer, color]) => `
                <div class="layer-item" onclick="toggleLayer('${layer}', this)">
                    <div class="layer-dot" style="background:${color}"></div>
                    <span>${layer}</span>
                    <span style="margin-left:auto;color:#555">${counts[layer] || 0}</span>
                </div>
            `).join('');
            document.getElementById('layer-filters').innerHTML = html;
        }

        function toggleLayer(layer, el) {
            el.classList.toggle('hidden');
            if (activeFilters.has(layer)) activeFilters.delete(layer);
            else activeFilters.add(layer);
            updateViz();
        }

        function searchNodes(q) {
            q = q.toLowerCase();
            g.selectAll('.node').attr('opacity', d => (!q || d.label.toLowerCase().includes(q)) ? 1 : 0.1);
        }

        function showTooltip(e, d) {
            const tip = document.getElementById('tooltip');
            tip.innerHTML = `<strong>${d.label}</strong><br>${d.layer} | ${d.role}<br>Deps: ${d.degree}`;
            tip.style.display = 'block';
            tip.style.left = (e.pageX + 10) + 'px';
            tip.style.top = (e.pageY + 10) + 'px';
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        function focusUnhealthy() {
            g.selectAll('.node').attr('opacity', d => (d.health === 'danger' || d.health === 'warning') ? 1 : 0.05);
        }

        function resetZoom() {
            selectedNode = null;
            g.selectAll('.node').attr('opacity', 1);
            g.selectAll('.edge').attr('stroke-opacity', +document.getElementById('edge-opacity').value / 100);
            document.getElementById('code-panel').innerHTML = '<div class="empty-panel"><div class="icon">üëÜ</div><p>Click a node to view source code details</p></div>';

            const bounds = g.node().getBBox();
            const width = svg.node().clientWidth;
            const height = svg.node().clientHeight;
            if (bounds.width && bounds.height) {
                const scale = Math.min(width / bounds.width, height / bounds.height) * 0.9;
                const tx = width / 2 - bounds.width * scale / 2 - bounds.x * scale;
                const ty = height / 2 - bounds.height * scale / 2 - bounds.y * scale;
                svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
            }
            updateViz();
        }

        // ==========================================
        // KEYBOARD SHORTCUTS
        // ==========================================
        document.addEventListener('keydown', (e) => {
            // Don't capture if typing in search
            if (e.target.tagName === 'INPUT') return;

            switch (e.key) {
                case 'ArrowLeft':
                    goBack();
                    break;
                case 'ArrowRight':
                    goForward();
                    break;
                case 'Escape':
                    resetZoom();
                    break;
                case '/':
                    e.preventDefault();
                    document.getElementById('search').focus();
                    break;
                case '1':
                    setColorMode('layer');
                    break;
                case '2':
                    setColorMode('health');
                    break;
                case '3':
                    setColorMode('distance');
                    break;
                case 'g':
                    setLayout('grid');
                    break;
                case 'l':
                    setLayout('layers');
                    break;
                case 'h':
                    setLayout('health');
                    break;
                case '?':
                    showHelp();
                    break;
            }
        });

        function showHelp() {
            alert(`
Keyboard Shortcuts:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚Üê ‚Üí     Navigate history
Escape  Reset view
/       Focus search
1 2 3   Color: Layer/Health/Distance
G L H   Layout: Grid/Layers/Health
?       Show this help
            `.trim());
        }

        // ==========================================
        // EXPORT
        // ==========================================
        function exportPNG() {
            const svgEl = document.getElementById('graph');
            const svgData = new XMLSerializer().serializeToString(svgEl);
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();

            canvas.width = svgEl.clientWidth * 2;
            canvas.height = svgEl.clientHeight * 2;
            ctx.scale(2, 2);
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            img.onload = () => {
                ctx.drawImage(img, 0, 0);
                const link = document.createElement('a');
                link.download = 'spectrometer-graph.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            };
            img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
        }

        // ==========================================
        // ART PROMPTS (NanoBanan Pro / Midjourney)
        // ==========================================
        const artPrompts = [
            {
                name: 'üî¥ God Class Detection',
                prompt: `Dark navy background (#0a0a1a), abstract network graph visualization. 3-4 massive glowing RED spheres with intense orange-red glow halos in the center, connected by dozens of thin white luminescent lines radiating outward like spider webs. Hundreds of tiny blue and cyan dots scattered around as small healthy nodes. The red nodes are 5x larger than the blue ones, looking overloaded and dangerous. Clean minimalist data visualization aesthetic, subtle particle effects, professional infographic quality. --ar 16:9 --style raw --v 6`
            },
            {
                name: 'üß© Leiden Clustering',
                prompt: `Deep black background (#050510), abstract network graph art showing community clusters. 6 distinct nebula-like cluster groups, each a different vibrant neon color: hot pink, electric cyan, acid green, golden yellow, purple, coral orange. Within each cluster, glowing nodes tightly connected with matching colored luminescent edges. Between clusters, sparse thin white connection lines creating a constellation effect. Clean minimalist data visualization, nodes with soft glow halos. --ar 16:9 --style raw --v 6`
            },
            {
                name: 'üèõÔ∏è Architecture Layers',
                prompt: `Dark gradient background, abstract network visualization of software architecture. 5 horizontal bands stacked vertically like geological strata or aurora layers. Top band: cyan/turquoise glowing nodes (Interface). Second: purple nodes (App). Middle: pink/magenta nodes (Core). Fourth: green nodes (Infra). Bottom: red nodes (Data). Edges flowing downward between layers as white streams. A few bright red dashed lines going upward as violations. Each layer has subtle ambient glow matching its color. --ar 16:9 --style raw --v 6`
            },
            {
                name: 'üëª Orphan Detection',
                prompt: `Dark background abstract network graph showing orphan detection. Center: dense luminescent cluster of interconnected bright green and cyan glowing nodes forming a healthy connected core, edges like fiber optic cables. Scattered around the edges: isolated single gray/dim faded nodes with no connections - lonely orphans. Strong contrast between the bright vibrant connected center and the dim ghostly isolated edges. Ethereal particle effects around orphans. Professional data visualization style. --ar 16:9 --style raw --v 6`
            },
            {
                name: 'üî• Coupling Hotspots',
                prompt: `Dark background (#0a0a1a) thermal network visualization showing coupling hotspots. Nodes colored as thermal gradient: cool blue and cyan at the edges, transitioning through yellow and orange, to intense glowing red and white-hot nodes in problem areas. Larger nodes pulsing with more heat/glow. Edges as heat flow lines connecting the thermal nodes. Like an infrared scan of code dependencies. Volumetric lighting, subtle smoke/heat distortion effects around the hottest nodes. --ar 16:9 --style raw --v 6`
            },
            {
                name: 'üåà Distance Coloring',
                prompt: `Dark cosmic background (#050510) abstract network graph showing distance coloring. One brilliant WHITE glowing node in the exact center as the origin point. Radiating outward in perfect concentric rings: first ring RED, second ORANGE, third YELLOW, fourth GREEN, fifth CYAN, outermost BLUE/VIOLET. Creates a beautiful rainbow gradient sphere radiating outward like ripples in space. Edges follow the color gradient smoothly as light rays. Cosmic nebula aesthetic, prismatic light effects. --ar 16:9 --style raw --v 6`
            }
        ];

        function showArtPrompts() {
            const modal = document.createElement('div');
            modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.9);z-index:10000;overflow-y:auto;padding:40px;';

            let html = `
                <div style="max-width:900px;margin:0 auto;color:#fff;font-family:system-ui;">
                    <h1 style="color:#00d4ff;margin-bottom:20px;">üé® Art Prompts for Visualization Concepts</h1>
                    <p style="color:#888;margin-bottom:30px;">Use these prompts with NanoBanan Pro, Midjourney, or other image generators.</p>
            `;

            artPrompts.forEach((p, i) => {
                html += `
                    <div style="background:#1a1a2e;padding:20px;margin-bottom:20px;border-radius:8px;border-left:4px solid #00d4ff;">
                        <h3 style="color:#00d4ff;margin:0 0 10px 0;">${p.name}</h3>
                        <pre style="background:#0a0a1a;padding:15px;border-radius:4px;white-space:pre-wrap;word-wrap:break-word;color:#ccc;font-size:12px;line-height:1.5;cursor:pointer;" onclick="navigator.clipboard.writeText(this.textContent);this.style.border='2px solid #22c55e';setTimeout(()=>this.style.border='none',500)">${p.prompt}</pre>
                        <small style="color:#666;">Click to copy</small>
                    </div>
                `;
            });

            html += `
                    <button onclick="this.parentElement.parentElement.remove()" style="background:#00d4ff;color:#000;border:none;padding:12px 30px;border-radius:4px;cursor:pointer;font-weight:bold;margin-top:20px;">Close</button>
                </div>
            `;

            modal.innerHTML = html;
            document.body.appendChild(modal);
        }

        // ==========================================
        // CONCEPT IMAGE TOOLTIPS (3-second hover)
        // ==========================================
        // CONCEPT_IMAGES_INJECTION marker - viz_generator will inject base64 images here
        const conceptImages = {
            // ___CONCEPT_IMAGES_START___
            god_class: null,
            coupling: null,
            layer_violation: null,
            clustering: null,
            orphan: null
            // ___CONCEPT_IMAGES_END___
        };

        let conceptTooltip = null;
        let conceptHoverTimer = null;

        function initConceptTooltips() {
            // Create tooltip element
            conceptTooltip = document.createElement('div');
            conceptTooltip.className = 'concept-tooltip';
            conceptTooltip.innerHTML = '<img src="" alt=""><div class="caption"></div>';
            document.body.appendChild(conceptTooltip);

            // Add hover listeners to all elements with data-concept
            document.querySelectorAll('[data-concept]').forEach(el => {
                el.addEventListener('mouseenter', (e) => {
                    const concept = el.dataset.concept;
                    if (!conceptImages[concept]) return;

                    conceptHoverTimer = setTimeout(() => {
                        showConceptTooltip(concept, e.clientX, e.clientY);
                    }, 3000); // 3 second delay
                });

                el.addEventListener('mouseleave', () => {
                    clearTimeout(conceptHoverTimer);
                    hideConceptTooltip();
                });

                el.addEventListener('mousemove', (e) => {
                    if (conceptTooltip.classList.contains('visible')) {
                        positionTooltip(e.clientX, e.clientY);
                    }
                });
            });
        }

        function showConceptTooltip(concept, x, y) {
            const img = conceptTooltip.querySelector('img');
            const caption = conceptTooltip.querySelector('.caption');

            img.src = conceptImages[concept];
            caption.textContent = concept.replace(/_/g, ' ').toUpperCase();

            positionTooltip(x, y);
            conceptTooltip.classList.add('visible');
        }

        function hideConceptTooltip() {
            conceptTooltip.classList.remove('visible');
        }

        function positionTooltip(x, y) {
            const rect = conceptTooltip.getBoundingClientRect();
            const vw = window.innerWidth;
            const vh = window.innerHeight;

            // Position near cursor but don't overflow viewport
            let left = x + 20;
            let top = y + 20;

            if (left + 320 > vw) left = x - 320;
            if (top + 340 > vh) top = y - 340;
            if (left < 0) left = 10;
            if (top < 0) top = 10;

            conceptTooltip.style.left = left + 'px';
            conceptTooltip.style.top = top + 'px';
        }

        // ==========================================
        // IDE FEATURES
        // ==========================================
        function initIDE() {
            // Render File Tree
            const treeEl = document.getElementById('file-tree');
            if (typeof fileTree !== 'undefined' && fileTree.length > 0) {
                treeEl.innerHTML = renderTree(fileTree);
            } else {
                treeEl.innerHTML = '<div style="color:#666">No file structure available</div>';
            }
        }

        function renderTree(nodes) {
            return nodes.map(node => {
                if (node.type === 'folder') {
                    return `
                        <div class="tree-item">
                            <div class="tree-row" onclick="toggleFolder(this)">
                                <span class="tree-icon">üìÅ</span>
                                <span class="tree-folder">${node.name}</span>
                            </div>
                            <div class="tree-children" style="display:none">
                                ${renderTree(node.children)}
                            </div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="tree-item tree-row" onclick="openFile('${node.path}')">
                            <span class="tree-icon">üìÑ</span>
                            <span class="tree-file">${node.name}</span>
                        </div>
                    `;
                }
            }).join('');
        }

        function toggleFolder(el) {
            const children = el.parentElement.querySelector('.tree-children');
            children.style.display = children.style.display === 'none' ? 'block' : 'none';
        }

        function openFile(nodeOrPath, startLine = 0, endLine = 0) {
            let path, loc, tokens;

            // Handle both object (node) and direct path string
            if (typeof nodeOrPath === 'object') {
                path = nodeOrPath.file;
                startLine = nodeOrPath.startLine || 0;
                endLine = nodeOrPath.endLine || 0;
                loc = nodeOrPath.loc;
                tokens = nodeOrPath.tokens;
            } else {
                path = nodeOrPath;
            }

            if (!path) return;

            // 1. Get Source
            const content = (typeof sourceMap !== 'undefined' && sourceMap[path])
                ? sourceMap[path]
                : '// Source not available in this build.\\n// File: ' + path;

            // 2. Update Panel
            const panel = document.getElementById('code-panel');

            // Generate highlighted lines
            const lines = content.split('\n');
            const numberedLines = lines.map((line, i) => {
                const lineNum = i + 1;
                const isHighlight = lineNum >= startLine && lineNum <= endLine;
                const style = isHighlight ? 'class="highlight-line"' : '';
                return `<div ${style} id="L${lineNum}"><span style="color:#555;margin-right:10px;user-select:none;width:25px;display:inline-block;text-align:right;">${lineNum}</span>${line}</div>`;
            }).join('');

            const displayLoc = loc || (lines.length);
            const displayTokens = tokens || (displayLoc * 7);

            panel.innerHTML = `
                <div class="code-panel" style="padding:0; overflow:hidden;">
                    <div style="background:#1a1a24; padding:8px; border-bottom:1px solid #333; display:flex; justify-content:space-between; align-items:center;">
                        <span style="color:#00d4ff; font-family:monospace; font-size:10px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:60%;" title="${path}">${path.split('/').pop()}</span>
                        <div style="font-size:9px; color:#666; display:flex; gap:8px; white-space:nowrap;">
                            <span>üìÑ ${displayLoc}L</span>
                            <span>üî§ ~${displayTokens} tok</span>
                            <button onclick="copyCode()" style="background:none; border:none; color:#666; cursor:pointer;" title="Copy Code">üìã</button>
                        </div>
                    </div>
                    <pre style="margin:0; height:400px; overflow:auto;" id="source-view"><code>${numberedLines}</code></pre>
                </div>
                `;

            // 3. Scroll to line
            if (startLine > 0) {
                setTimeout(() => {
                    const el = document.getElementById(`L${startLine}`);
                    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
            }
        }

        // Override showCodePanel to link with IDE features
        const originalShowCodePanel = showCodePanel;
        showCodePanel = function (node) {
            if (node.file && typeof sourceMap !== 'undefined' && sourceMap[node.file]) {
                openFile(node);
                // Append extra metadata
                const metaDiv = document.createElement('div');
                metaDiv.style.padding = '10px';
                metaDiv.style.borderTop = '1px solid #333';
                metaDiv.innerHTML = `
                        <div style="margin-bottom:5px;"><strong style="color:#fff">${node.kind}</strong> <span style="color:#888">in</span> <strong style="color:#fff">${node.layer}</strong></div>
                        ${node.intelligence ? renderIntelligence(node.intelligence) : ''}
                    `;
                document.getElementById('code-panel').appendChild(metaDiv);
            } else {
                originalShowCodePanel(node);
            }
        };

        function renderIntelligence(intel) {
            if (!intel || !intel.violations || intel.violations.length === 0) return '';
            return `
                    <div style="margin-top:10px; padding:5px; background:#2a1a1a; border-left:3px solid #ff4444;">
                        <div style="color:#ff4444; font-weight:bold; font-size:10px;">‚ö†Ô∏è Intelligence Report</div>
                        ${intel.violations.map(v => `<div style="font-size:9px; color:#ccc; margin-top:2px;">‚Ä¢ ${v.message}</div>`).join('')}
                    </div>
                `;
        }


        init();
        function toggleLayerPatterns() {
            const el = document.getElementById('layer-patterns');
            const isHidden = el.style.display === 'none';
            el.style.display = isHidden ? 'flex' : 'none';
            // Default to stack if opening
            if (isHidden) setLayout('layers');
        }

        // Layout Tooltips
        document.querySelectorAll('button[onclick^="setLayout"]').forEach(btn => {
            btn.addEventListener('mouseenter', (e) => {
                const info = e.target.getAttribute('title');
                if (info) {
                    const cleanInfo = info.replace('Best for: ', '').replace('\n', ' - ');
                    document.getElementById('layout-info').textContent = cleanInfo;
                    document.getElementById('layout-info').style.color = '#00d4ff';
                }
            });
            btn.addEventListener('mouseleave', () => {
                document.getElementById('layout-info').textContent = 'Hover over a layout for usage tips.';
                document.getElementById('layout-info').style.color = '#888';
            });
        });

        initIDE(); // Init IDE features
        initConceptTooltips();
    </script>
</body>

</html>