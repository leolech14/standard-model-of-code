#!/usr/bin/env python3
"""
AUTO_EXTRACT.PY - Automated God Class Decomposition Tool

This script uses tree-sitter to parse JavaScript files and automatically
extract functions into logical modules based on naming patterns.

Usage:
    python3 auto_extract.py <source_file> <output_dir>

Example:
    python3 auto_extract.py /path/to/server.js /path/to/output/
"""

import json
import re
import sys
import os
from pathlib import Path
from collections import defaultdict

try:
    import tree_sitter_javascript as tsjs
    from tree_sitter import Language, Parser
    HAS_TREE_SITTER = True
except ImportError:
    HAS_TREE_SITTER = False
    print("âš ï¸  tree-sitter not available, falling back to regex parsing")


# === EXTRACTION RULES ===
# Maps function name patterns to target modules
# ORDER MATTERS - first match wins
EXTRACTION_RULES = [
    # Error handling
    (r"Error$", "error_handling"),
    (r"^(as|throw|handle).*Error", "error_handling"),
    
    # HTTP I/O
    (r"^send", "http_utils"),
    (r"^parse(Body|Csv|Json)", "http_utils"),
    
    # API helpers
    (r"^api", "api_helpers"),
    (r"^getTrace", "api_helpers"),
    
    # Normalization
    (r"^normalize", "normalizers"),
    (r"^sanitize", "normalizers"),
    (r"^extract", "extractors"),
    
    # Mappers (UI data transformation)
    (r"^map[A-Z]", "mappers"),
    
    # Builders
    (r"^build", "builders"),
    (r"^compute", "computations"),
    (r"^format", "formatters"),
    
    # Data access
    (r"^(load|save|get|set|find|query)", "data_access"),
    (r"^run.*Background", "data_access"),
    (r"^await", "async_utils"),
    
    # Mock/Test
    (r"Mock", "mocking"),
    (r"^ensure", "mocking"),
    
    # Crypto/Security  
    (r"^(hash|timing|mask)", "security"),
    
    # Math/Utils
    (r"^(round|pad|clamp|chunk|mulberry)", "math_utils"),
    (r"^csv", "csv_utils"),
    
    # Connection handling
    (r"Connection", "connection_utils"),
    (r"^is[A-Z]", "validators"),
    
    # Keep the rest in core (should be minimal now)
    (r".*", "core"),
]


def parse_with_regex(source_code: str) -> list:
    """Fallback regex-based function extraction."""
    pattern = r'^(?:async\s+)?function\s+(\w+)\s*\([^)]*\)\s*\{'
    functions = []
    
    lines = source_code.split('\n')
    for i, line in enumerate(lines):
        match = re.match(pattern, line)
        if match:
            func_name = match.group(1)
            # Find the closing brace (simple heuristic)
            brace_count = 1
            end_line = i
            for j in range(i + 1, len(lines)):
                brace_count += lines[j].count('{') - lines[j].count('}')
                if brace_count <= 0:
                    end_line = j
                    break
            
            functions.append({
                'name': func_name,
                'start_line': i + 1,
                'end_line': end_line + 1,
                'code': '\n'.join(lines[i:end_line + 1])
            })
    
    return functions


def parse_with_tree_sitter(source_code: str) -> list:
    """Use tree-sitter for accurate parsing."""
    JS_LANGUAGE = Language(tsjs.language())
    parser = Parser(JS_LANGUAGE)
    
    tree = parser.parse(bytes(source_code, 'utf8'))
    root = tree.root_node
    
    functions = []
    
    def extract_functions(node):
        if node.type in ('function_declaration', 'generator_function_declaration'):
            name_node = node.child_by_field_name('name')
            if name_node:
                name = source_code[name_node.start_byte:name_node.end_byte]
                functions.append({
                    'name': name,
                    'start_line': node.start_point[0] + 1,
                    'end_line': node.end_point[0] + 1,
                    'start_byte': node.start_byte,
                    'end_byte': node.end_byte,
                    'code': source_code[node.start_byte:node.end_byte]
                })
        
        for child in node.children:
            extract_functions(child)
    
    extract_functions(root)
    return functions


def classify_function(func_name: str) -> str:
    """Determine which module a function belongs to."""
    for pattern, module in EXTRACTION_RULES:
        if re.search(pattern, func_name):
            return module
    return "core"


def generate_module(module_name: str, functions: list, output_dir: Path):
    """Generate a new module file with the extracted functions."""
    if not functions:
        return
    
    output_file = output_dir / f"{module_name}.js"
    
    header = f'''/**
 * {module_name.upper()} - Auto-extracted from server.js
 * Generated by auto_extract.py
 * 
 * Contains {len(functions)} functions.
 */

'''
    
    code_blocks = [header]
    exports = []
    
    for func in functions:
        code_blocks.append(func['code'])
        code_blocks.append('\n\n')
        exports.append(func['name'])
    
    # Add exports
    code_blocks.append(f"\nmodule.exports = {{\n")
    for name in exports:
        code_blocks.append(f"  {name},\n")
    code_blocks.append("};\n")
    
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(''.join(code_blocks))
    
    print(f"  ðŸ“¦ {module_name}.js: {len(functions)} functions")
    return exports


def generate_import_statements(modules: dict) -> str:
    """Generate require statements for all extracted modules."""
    imports = []
    for module_name, functions in modules.items():
        if module_name == 'core' or not functions:
            continue
        func_names = ', '.join(f['name'] for f in functions)
        imports.append(f'const {{ {func_names} }} = require("./{module_name}");')
    return '\n'.join(imports)


def main():
    if len(sys.argv) < 2:
        print("Usage: python3 auto_extract.py <source_file> [output_dir]")
        sys.exit(1)
    
    source_file = Path(sys.argv[1])
    output_dir = Path(sys.argv[2]) if len(sys.argv) > 2 else source_file.parent / "extracted"
    
    if not source_file.exists():
        print(f"âŒ Source file not found: {source_file}")
        sys.exit(1)
    
    output_dir.mkdir(parents=True, exist_ok=True)
    
    print(f"ðŸ”¬ Analyzing: {source_file}")
    print(f"ðŸ“ Output: {output_dir}")
    
    with open(source_file, 'r', encoding='utf-8') as f:
        source_code = f.read()
    
    # Parse functions
    if HAS_TREE_SITTER:
        print("ðŸŒ³ Using tree-sitter parser")
        functions = parse_with_tree_sitter(source_code)
    else:
        print("ðŸ“ Using regex parser (less accurate)")
        functions = parse_with_regex(source_code)
    
    print(f"ðŸ” Found {len(functions)} functions")
    
    # Classify functions into modules
    modules = defaultdict(list)
    for func in functions:
        module = classify_function(func['name'])
        modules[module].append(func)
    
    print("\nðŸ“Š Classification Results:")
    for module, funcs in sorted(modules.items(), key=lambda x: -len(x[1])):
        print(f"   {module}: {len(funcs)} functions")
    
    # Generate module files
    print("\nðŸ’¾ Generating modules:")
    all_exports = {}
    for module_name, funcs in modules.items():
        if module_name == 'core':
            continue  # Skip core - these stay in the original file
        exports = generate_module(module_name, funcs, output_dir)
        if exports:
            all_exports[module_name] = exports
    
    # Generate import helper
    print("\nðŸ“‹ Import statements to add to server.js:")
    print("-" * 50)
    for module_name, exports in all_exports.items():
        print(f'const {{ {", ".join(exports[:3])}{"..." if len(exports) > 3 else ""} }} = require("./{module_name}");')
    print("-" * 50)
    
    # Summary
    extracted_count = sum(len(f) for m, f in modules.items() if m != 'core')
    core_count = len(modules.get('core', []))
    
    print(f"\nâœ… Extraction Complete!")
    print(f"   ðŸ“¤ Extracted: {extracted_count} functions")
    print(f"   ðŸ“¥ Remaining in core: {core_count} functions")
    print(f"   ðŸ“ˆ Reduction: {extracted_count / (extracted_count + core_count) * 100:.1f}%")


if __name__ == "__main__":
    main()
