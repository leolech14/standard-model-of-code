#!/usr/bin/env python3
"""
EXTRACT_DEPENDENCIES.PY - Extract missing dependencies for route handlers

This script:
1. Extracts specific functions from server.js into new modules
2. Updates all route files with the correct imports
"""

import re
import sys
from pathlib import Path

# Target functions to extract, grouped by destination module
EXTRACTION_TARGETS = {
    'apiHelpers': [
        'apiMeta',
        'getTraceId', 
        'asApiError',
        'sendApiError',
        'missingParamError',
        'invalidJsonError',
    ],
    'mocking': [
        'isMockConnection',
        'buildMockTransactionsForAccount',
        'ensureMockTransactions',
        'hashToUint32',
        'mulberry32',
        'roundMoney',
    ],
    'config': [
        # These are constants, not functions - handle differently
    ],
    'mappers': [
        'mapPopupAccount',
        'mapPopupIdentity', 
        'mapPopupInvestment',
        'mapPopupLoan',
        'mapPopupTransaction',
        'mapPopupBill',
    ],
    'builders': [
        'buildRecentMonthWindow',
        'buildAssistantContext',
        'computeBillPayments',
    ],
    'extractors': [
        'extractConsentExpiresAt',
        'normalizeErrorCandidate',
        'normalizeConnectionLastErrorMessage',
        'normalizeHookSignature',
        'timingSafeEqualHex',
        'parseCsvIds',
        'csvCell',
        'chunkArray',
        'pad2',
        'formatMonthKeyFromMs',
        'truncateString',
        'sanitizeDetail',
    ],
}


def extract_function(source: str, func_name: str) -> str:
    """Extract a single function from source code."""
    # Pattern for async and regular functions
    patterns = [
        rf'^(async\s+)?function\s+{func_name}\s*\([^)]*\)\s*\{{',
        rf'^const\s+{func_name}\s*=\s*(?:async\s*)?\([^)]*\)\s*=>\s*\{{',
    ]
    
    lines = source.split('\n')
    
    for i, line in enumerate(lines):
        for pattern in patterns:
            if re.match(pattern, line):
                # Found the function, now find its end
                start_line = i
                brace_count = line.count('{') - line.count('}')
                end_line = i
                
                for j in range(i + 1, len(lines)):
                    brace_count += lines[j].count('{') - lines[j].count('}')
                    if brace_count <= 0:
                        end_line = j
                        break
                
                return '\n'.join(lines[start_line:end_line + 1])
    
    return None


def generate_module(module_name: str, functions: dict, output_dir: Path):
    """Generate a new module file with extracted functions."""
    if not functions:
        return
    
    output_file = output_dir / f"{module_name}.js"
    
    # Build imports based on what these functions need
    imports = []
    if module_name == 'apiHelpers':
        imports = [
            'const { ApiError } = require("./errors");',
            'const crypto = require("crypto");',
        ]
    elif module_name == 'mocking':
        imports = [
            'const crypto = require("crypto");',
        ]
    elif module_name == 'mappers':
        imports = [
            'const { maskSensitive, maskIdentifier } = require("./financeUtils");',
        ]
    elif module_name == 'builders':
        imports = [
            'const { loadDb } = require("./jsonDb");',
        ]
    
    header = f'''/**
 * {module_name.upper()} - Auto-extracted from server.js
 * Generated by extract_dependencies.py
 */

{chr(10).join(imports)}

'''
    
    code_blocks = [header]
    exports = []
    
    for func_name, func_code in functions.items():
        if func_code:
            code_blocks.append(func_code)
            code_blocks.append('\n\n')
            exports.append(func_name)
    
    if not exports:
        return
    
    # Add exports
    code_blocks.append(f"\nmodule.exports = {{\n")
    for name in exports:
        code_blocks.append(f"  {name},\n")
    code_blocks.append("};\n")
    
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(''.join(code_blocks))
    
    print(f"  ğŸ“¦ {module_name}.js: {len(exports)} functions")
    return exports


def update_route_files(routes_dir: Path, new_imports: dict):
    """Add missing imports to all route files."""
    import_lines = []
    
    for module, funcs in new_imports.items():
        if funcs:
            func_list = ', '.join(funcs)
            import_lines.append(f'const {{ {func_list} }} = require("../lib/{module}");')
    
    if not import_lines:
        return
    
    import_block = '\n'.join(import_lines)
    
    updated_count = 0
    for filepath in routes_dir.glob("*.js"):
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Find where to insert imports (after existing imports)
        insert_marker = '// Constants (should be centralized)'
        if insert_marker in content:
            new_content = content.replace(
                insert_marker,
                f'{import_block}\n\n{insert_marker}'
            )
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(new_content)
            
            updated_count += 1
    
    print(f"  ğŸ“ Updated {updated_count} route files with new imports")


def generate_config_module(output_dir: Path):
    """Generate config.js with constants."""
    content = '''/**
 * CONFIG - Application constants
 * Auto-extracted from server.js
 */

const GRID_TOTAL_SLOTS = 28;
const SHORTCUT_TOTAL_SLOTS = 60;

const DISABLE_MOCKS = ["1", "true", "yes", "on"].includes(
  String(process.env.DISABLE_MOCKS || process.env.REAL_DATA_ONLY || "").toLowerCase()
);

const ENABLE_MOCKS =
  !DISABLE_MOCKS && ["1", "true", "yes", "on"].includes(String(process.env.ENABLE_MOCKS || "").toLowerCase());

const SERVER_START_MS = Date.now();

const DIAG_MAX_EVENTS = Number(process.env.DIAG_MAX_EVENTS || 200);
const VIZ_CACHE_MAX = Number(process.env.VIZ_CACHE_MAX || 20);

module.exports = {
  GRID_TOTAL_SLOTS,
  SHORTCUT_TOTAL_SLOTS,
  DISABLE_MOCKS,
  ENABLE_MOCKS,
  SERVER_START_MS,
  DIAG_MAX_EVENTS,
  VIZ_CACHE_MAX,
};
'''
    
    with open(output_dir / "config.js", 'w', encoding='utf-8') as f:
        f.write(content)
    
    print("  ğŸ“¦ config.js: 7 constants")


def main():
    server_js = Path(sys.argv[1]) if len(sys.argv) > 1 else Path("/Users/lech/PROJECTS_all/PROJECT_atman/ATMAN/server.js")
    output_dir = Path(sys.argv[2]) if len(sys.argv) > 2 else server_js.parent / "lib"
    routes_dir = server_js.parent / "refactored" / "routes"
    
    print(f"ğŸ”¬ Extracting dependencies from: {server_js}")
    print(f"ğŸ“ Output: {output_dir}")
    
    with open(server_js, 'r', encoding='utf-8') as f:
        source = f.read()
    
    print("\nğŸ’¾ Generating modules:")
    
    new_imports = {}
    
    for module_name, func_names in EXTRACTION_TARGETS.items():
        if not func_names:
            continue
            
        functions = {}
        for func_name in func_names:
            code = extract_function(source, func_name)
            if code:
                functions[func_name] = code
        
        if functions:
            exports = generate_module(module_name, functions, output_dir)
            if exports:
                new_imports[module_name] = exports
    
    # Generate config module
    generate_config_module(output_dir)
    new_imports['config'] = ['ENABLE_MOCKS', 'DISABLE_MOCKS', 'DIAG_MAX_EVENTS']
    
    # Update route files
    print("\nğŸ“ Updating route files:")
    update_route_files(routes_dir, new_imports)
    
    print("\nâœ… Dependency extraction complete!")
    
    # Summary
    total_extracted = sum(len(funcs) for funcs in new_imports.values())
    print(f"   ğŸ“¤ Extracted: {total_extracted} functions/constants")
    print(f"   ğŸ“¦ Created: {len(new_imports)} new modules")


if __name__ == "__main__":
    main()
